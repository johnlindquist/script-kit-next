This file is a merged representation of the filtered codebase, combined into a single document by packx.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of filtered repository contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<usage_guidelines>
- Treat this file as a snapshot of the repository's state
- Be aware that this file may contain sensitive information
</usage_guidelines>

<notes>
- Files were filtered by packx based on content and extension matching
- Total files included: 10
</notes>
</file_summary>

<directory_structure>
src/shortcuts/context.rs
src/shortcuts/mod.rs
src/shortcuts/hotkey_compat.rs
src/shortcuts/persistence.rs
src/shortcuts/registry.rs
src/shortcuts/types.rs
src/theme/mod.rs
src/components/shortcut_recorder.rs
src/app_actions.rs
src/hotkeys.rs
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="src/shortcuts/context.rs">
//! Shortcut context stack for deterministic keyboard routing.
//!
//! The context stack determines which shortcuts are active based on the current
//! UI state. Contexts are ordered from most-specific to least-specific, and
//! shortcuts are matched against the first context that contains them.
//!
//! This prevents issues like "Global shortcut eats arrow keys in editor" by
//! ensuring editor-specific shortcuts take precedence over global ones.

// Allow dead code during incremental development
#![allow(dead_code)]

/// A context in which shortcuts can be active.
///
/// Contexts are ordered by specificity:
/// - Modal contexts (ActionsDialog) are most specific
/// - View contexts (Editor, ScriptList, etc.) are next
/// - Group contexts (AnyPrompt) catch multiple views
/// - Global is always last
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord)]
pub enum ShortcutContext {
    /// Active when the actions dialog/popup is open (most specific)
    /// Takes precedence over all other contexts
    ActionsDialog,

    /// Active when editor prompt is focused
    Editor,

    /// Active when terminal prompt is focused
    Terminal,

    /// Active when script list is focused (main menu)
    ScriptList,

    /// Active when arg prompt is shown (list selection)
    ArgPrompt,

    /// Active when form prompt is shown
    FormPrompt,

    /// Active when div prompt is shown (HTML content)
    DivPrompt,

    /// Active when path prompt is shown (file picker)
    PathPrompt,

    /// Active in any prompt (catch-all for prompts)
    AnyPrompt,

    /// Always active (least specific)
    /// Should only contain shortcuts that don't conflict with view-specific ones
    Global,
}

impl ShortcutContext {
    /// Get the specificity level (lower = more specific = higher priority).
    ///
    /// Used for sorting context stacks and resolving conflicts.
    pub fn specificity(&self) -> u8 {
        match self {
            // Modal contexts (highest priority)
            Self::ActionsDialog => 0,

            // Specific view contexts
            Self::Editor => 10,
            Self::Terminal => 10,
            Self::ScriptList => 10,
            Self::ArgPrompt => 10,
            Self::FormPrompt => 10,
            Self::DivPrompt => 10,
            Self::PathPrompt => 10,

            // Group context
            Self::AnyPrompt => 20,

            // Global (lowest priority)
            Self::Global => 100,
        }
    }

    /// Check if this context contains another (for shadowing detection).
    ///
    /// Returns true if `self` is a more general context that contains `other`.
    pub fn contains(&self, other: &ShortcutContext) -> bool {
        match self {
            Self::Global => true, // Global contains everything
            Self::AnyPrompt => matches!(
                other,
                Self::ArgPrompt
                    | Self::FormPrompt
                    | Self::DivPrompt
                    | Self::PathPrompt
                    | Self::Editor
                    | Self::Terminal
            ),
            _ => self == other,
        }
    }

    /// Check if this context is a modal (blocks underlying contexts).
    pub fn is_modal(&self) -> bool {
        matches!(self, Self::ActionsDialog)
    }
}

/// An ordered stack of active contexts.
///
/// Built from current UI state, ordered from most-specific to least-specific.
/// Shortcut matching searches contexts in order, stopping at the first match.
#[derive(Clone, Debug, Default)]
pub struct ContextStack {
    /// Contexts in order from most-specific to least-specific
    contexts: Vec<ShortcutContext>,
}

impl ContextStack {
    /// Create an empty context stack.
    pub fn new() -> Self {
        Self { contexts: vec![] }
    }

    /// Create a context stack with just Global.
    pub fn global_only() -> Self {
        Self {
            contexts: vec![ShortcutContext::Global],
        }
    }

    /// Build a context stack from current UI state.
    ///
    /// # Arguments
    /// * `view` - Current view type
    /// * `has_actions_popup` - Whether actions dialog is open
    ///
    /// Returns a properly ordered stack for shortcut matching.
    pub fn from_state(view: ViewType, has_actions_popup: bool) -> Self {
        let mut contexts = Vec::new();

        // Modal takes precedence if open
        if has_actions_popup {
            contexts.push(ShortcutContext::ActionsDialog);
        }

        // Add view-specific context
        match view {
            ViewType::ScriptList => contexts.push(ShortcutContext::ScriptList),
            ViewType::ArgPrompt => {
                contexts.push(ShortcutContext::ArgPrompt);
                contexts.push(ShortcutContext::AnyPrompt);
            }
            ViewType::Editor => {
                contexts.push(ShortcutContext::Editor);
                contexts.push(ShortcutContext::AnyPrompt);
            }
            ViewType::Terminal => {
                contexts.push(ShortcutContext::Terminal);
                contexts.push(ShortcutContext::AnyPrompt);
            }
            ViewType::Form => {
                contexts.push(ShortcutContext::FormPrompt);
                contexts.push(ShortcutContext::AnyPrompt);
            }
            ViewType::Div => {
                contexts.push(ShortcutContext::DivPrompt);
                contexts.push(ShortcutContext::AnyPrompt);
            }
            ViewType::Path => {
                contexts.push(ShortcutContext::PathPrompt);
                contexts.push(ShortcutContext::AnyPrompt);
            }
        }

        // Global is always last (unless modal is blocking)
        // Note: ActionsDialog is modal, so we still add Global for non-navigation keys
        contexts.push(ShortcutContext::Global);

        Self { contexts }
    }

    /// Get the contexts in order.
    pub fn contexts(&self) -> &[ShortcutContext] {
        &self.contexts
    }

    /// Check if a context is in this stack.
    pub fn contains(&self, context: ShortcutContext) -> bool {
        self.contexts.contains(&context)
    }

    /// Check if any modal context is active.
    pub fn has_modal(&self) -> bool {
        self.contexts.iter().any(|c| c.is_modal())
    }

    /// Iterate over contexts in order.
    pub fn iter(&self) -> impl Iterator<Item = &ShortcutContext> {
        self.contexts.iter()
    }
}

/// View type for building context stacks.
///
/// Maps to the current prompt/view being displayed.
#[derive(Clone, Copy, Debug, PartialEq, Eq)]
pub enum ViewType {
    /// Main script list
    ScriptList,
    /// Arg prompt (list selection)
    ArgPrompt,
    /// Editor prompt
    Editor,
    /// Terminal prompt
    Terminal,
    /// Form prompt
    Form,
    /// Div prompt (HTML content)
    Div,
    /// Path prompt (file picker)
    Path,
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn context_specificity_ordering() {
        assert!(
            ShortcutContext::ActionsDialog.specificity() < ShortcutContext::Editor.specificity()
        );
        assert!(ShortcutContext::Editor.specificity() < ShortcutContext::AnyPrompt.specificity());
        assert!(ShortcutContext::AnyPrompt.specificity() < ShortcutContext::Global.specificity());
    }

    #[test]
    fn context_contains_relationship() {
        assert!(ShortcutContext::Global.contains(&ShortcutContext::Editor));
        assert!(ShortcutContext::Global.contains(&ShortcutContext::ScriptList));
        assert!(ShortcutContext::Global.contains(&ShortcutContext::Global));

        assert!(ShortcutContext::AnyPrompt.contains(&ShortcutContext::ArgPrompt));
        assert!(ShortcutContext::AnyPrompt.contains(&ShortcutContext::Editor));
        assert!(!ShortcutContext::AnyPrompt.contains(&ShortcutContext::ScriptList));

        assert!(ShortcutContext::Editor.contains(&ShortcutContext::Editor));
        assert!(!ShortcutContext::Editor.contains(&ShortcutContext::Terminal));
    }

    #[test]
    fn context_stack_from_script_list() {
        let stack = ContextStack::from_state(ViewType::ScriptList, false);
        let contexts = stack.contexts();

        assert_eq!(contexts.len(), 2);
        assert_eq!(contexts[0], ShortcutContext::ScriptList);
        assert_eq!(contexts[1], ShortcutContext::Global);
    }

    #[test]
    fn context_stack_from_editor() {
        let stack = ContextStack::from_state(ViewType::Editor, false);
        let contexts = stack.contexts();

        assert_eq!(contexts.len(), 3);
        assert_eq!(contexts[0], ShortcutContext::Editor);
        assert_eq!(contexts[1], ShortcutContext::AnyPrompt);
        assert_eq!(contexts[2], ShortcutContext::Global);
    }

    #[test]
    fn context_stack_with_actions_popup() {
        let stack = ContextStack::from_state(ViewType::Editor, true);
        let contexts = stack.contexts();

        assert_eq!(contexts[0], ShortcutContext::ActionsDialog);
        assert!(stack.has_modal());
    }

    #[test]
    fn context_stack_ordering_is_deterministic() {
        // Same state should always produce same stack
        let stack1 = ContextStack::from_state(ViewType::ArgPrompt, true);
        let stack2 = ContextStack::from_state(ViewType::ArgPrompt, true);

        assert_eq!(stack1.contexts(), stack2.contexts());
    }

    #[test]
    fn modal_contexts_identified() {
        assert!(ShortcutContext::ActionsDialog.is_modal());
        assert!(!ShortcutContext::Editor.is_modal());
        assert!(!ShortcutContext::Global.is_modal());
    }

    #[test]
    fn global_only_stack() {
        let stack = ContextStack::global_only();
        assert_eq!(stack.contexts().len(), 1);
        assert_eq!(stack.contexts()[0], ShortcutContext::Global);
    }
}

</file>

<file path="src/shortcuts/mod.rs">
//! Unified keyboard shortcut system.
//!
//! This module provides:
//! - Centralized shortcut definitions
//! - Deterministic context-aware matching
//! - Conflict detection and handling
//! - User customization support
//! - Platform-aware display formatting
//!
//! # Architecture
//!
//! The shortcut system uses an ordered context stack for deterministic routing:
//! - Most specific context (e.g., ActionsDialog) is checked first
//! - Falls through to less specific contexts (e.g., Global)
//! - Prevents "Global eats arrow keys in editor" bugs
//!
//! # Example
//!
//! ```ignore
//! use script_kit_gpui::shortcuts::{Shortcut, ShortcutParseError, ContextStack, ViewType};
//!
//! let shortcut = Shortcut::parse("cmd+shift+k")?;
//! println!("Display: {}", shortcut.display()); // ⌘⇧K on macOS
//!
//! // Build context stack from UI state
//! let stack = ContextStack::from_state(ViewType::Editor, false);
//! // Shortcuts are matched against contexts in order
//! ```

mod context;
mod hotkey_compat;
mod persistence;
mod registry;
mod types;

#[cfg(test)]
#[path = "types_tests.rs"]
mod types_tests;

#[cfg(test)]
#[path = "registry_tests.rs"]
mod registry_tests;

// Re-export core types (allow unused during incremental development)
#[allow(unused_imports)]
pub use types::{
    canonicalize_key, is_known_key, Modifiers, Platform, Shortcut, ShortcutParseError,
};

// Re-export context types
#[allow(unused_imports)]
pub use context::{ContextStack, ShortcutContext, ViewType};

// Re-export registry types
#[allow(unused_imports)]
pub use registry::{
    BindingSource, ConflictType, PotentialConflict, ShortcutBinding, ShortcutCategory,
    ShortcutConflict, ShortcutRegistry, ShortcutScope,
};

// Re-export hotkey compatibility functions (used by hotkeys.rs, prompt_handler.rs, etc.)
pub use hotkey_compat::{keystroke_to_shortcut, normalize_shortcut, parse_shortcut};

// Re-export persistence types
#[allow(unused_imports)]
pub use persistence::{
    default_overrides_path, load_shortcut_overrides, remove_shortcut_override,
    save_shortcut_override, PersistenceError, ShortcutOverrides,
};

</file>

<file path="src/shortcuts/hotkey_compat.rs">
//! Compatibility functions for global_hotkey crate integration.
//!
//! These functions bridge between our `Shortcut` type and the
//! `global_hotkey::hotkey::{Code, Modifiers}` types.

use global_hotkey::hotkey::{Code, Modifiers};

use crate::logging;

/// Parse a shortcut string into (Modifiers, Code) for global_hotkey crate.
///
/// Supports flexible formats:
/// - Space-separated: "opt i", "cmd shift k"
/// - Plus-separated: "cmd+shift+k", "ctrl+alt+delete"
/// - Mixed: "cmd + shift + k"
///
/// Returns None if the shortcut string is invalid.
pub fn parse_shortcut(shortcut: &str) -> Option<(Modifiers, Code)> {
    let normalized = shortcut
        .replace('+', " ")
        .split_whitespace()
        .collect::<Vec<_>>()
        .join(" ");

    let parts: Vec<&str> = normalized.split_whitespace().collect();
    if parts.is_empty() {
        return None;
    }

    let mut modifiers = Modifiers::empty();
    let mut key_part: Option<&str> = None;

    for part in &parts {
        let part_lower = part.to_lowercase();
        match part_lower.as_str() {
            "cmd" | "command" | "meta" | "super" | "win" | "⌘" => modifiers |= Modifiers::META,
            "ctrl" | "control" | "ctl" | "^" => modifiers |= Modifiers::CONTROL,
            "alt" | "opt" | "option" | "⌥" => modifiers |= Modifiers::ALT,
            "shift" | "shft" | "⇧" => modifiers |= Modifiers::SHIFT,
            _ => key_part = Some(part),
        }
    }

    let key = key_part?;
    let key_lower = key.to_lowercase();

    let code = match key_lower.as_str() {
        "a" => Code::KeyA,
        "b" => Code::KeyB,
        "c" => Code::KeyC,
        "d" => Code::KeyD,
        "e" => Code::KeyE,
        "f" => Code::KeyF,
        "g" => Code::KeyG,
        "h" => Code::KeyH,
        "i" => Code::KeyI,
        "j" => Code::KeyJ,
        "k" => Code::KeyK,
        "l" => Code::KeyL,
        "m" => Code::KeyM,
        "n" => Code::KeyN,
        "o" => Code::KeyO,
        "p" => Code::KeyP,
        "q" => Code::KeyQ,
        "r" => Code::KeyR,
        "s" => Code::KeyS,
        "t" => Code::KeyT,
        "u" => Code::KeyU,
        "v" => Code::KeyV,
        "w" => Code::KeyW,
        "x" => Code::KeyX,
        "y" => Code::KeyY,
        "z" => Code::KeyZ,
        "0" => Code::Digit0,
        "1" => Code::Digit1,
        "2" => Code::Digit2,
        "3" => Code::Digit3,
        "4" => Code::Digit4,
        "5" => Code::Digit5,
        "6" => Code::Digit6,
        "7" => Code::Digit7,
        "8" => Code::Digit8,
        "9" => Code::Digit9,
        "f1" => Code::F1,
        "f2" => Code::F2,
        "f3" => Code::F3,
        "f4" => Code::F4,
        "f5" => Code::F5,
        "f6" => Code::F6,
        "f7" => Code::F7,
        "f8" => Code::F8,
        "f9" => Code::F9,
        "f10" => Code::F10,
        "f11" => Code::F11,
        "f12" => Code::F12,
        "space" => Code::Space,
        "enter" | "return" => Code::Enter,
        "tab" => Code::Tab,
        "escape" | "esc" => Code::Escape,
        "backspace" | "back" => Code::Backspace,
        "delete" | "del" => Code::Delete,
        ";" | "semicolon" => Code::Semicolon,
        "'" | "quote" | "apostrophe" => Code::Quote,
        "," | "comma" => Code::Comma,
        "." | "period" | "dot" => Code::Period,
        "/" | "slash" | "forwardslash" => Code::Slash,
        "\\" | "backslash" => Code::Backslash,
        "[" | "bracketleft" | "leftbracket" => Code::BracketLeft,
        "]" | "bracketright" | "rightbracket" => Code::BracketRight,
        "-" | "minus" | "dash" | "hyphen" => Code::Minus,
        "=" | "equal" | "equals" => Code::Equal,
        "`" | "backquote" | "backtick" | "grave" => Code::Backquote,
        "up" | "arrowup" | "uparrow" => Code::ArrowUp,
        "down" | "arrowdown" | "downarrow" => Code::ArrowDown,
        "left" | "arrowleft" | "leftarrow" => Code::ArrowLeft,
        "right" | "arrowright" | "rightarrow" => Code::ArrowRight,
        "home" => Code::Home,
        "end" => Code::End,
        "pageup" | "pgup" => Code::PageUp,
        "pagedown" | "pgdn" | "pgdown" => Code::PageDown,
        _ => {
            logging::log(
                "SHORTCUT",
                &format!("Unknown key in shortcut '{}': '{}'", shortcut, key),
            );
            return None;
        }
    };

    Some((modifiers, code))
}

/// Normalize a shortcut string for consistent comparison.
/// Converts "cmd+shift+c" and "Cmd+Shift+C" to "cmd+shift+c".
pub fn normalize_shortcut(shortcut: &str) -> String {
    let mut parts: Vec<&str> = shortcut.split('+').collect();
    let mut modifiers: Vec<&str> = Vec::new();
    let mut key: Option<&str> = None;

    for part in parts.drain(..) {
        let lower = part.trim().to_lowercase();
        match lower.as_str() {
            "cmd" | "command" | "meta" | "super" => modifiers.push("cmd"),
            "ctrl" | "control" => modifiers.push("ctrl"),
            "alt" | "option" | "opt" => modifiers.push("alt"),
            "shift" => modifiers.push("shift"),
            _ => key = Some(part.trim()),
        }
    }

    modifiers.sort();
    let mut result = modifiers.join("+");
    if let Some(k) = key {
        if !result.is_empty() {
            result.push('+');
        }
        result.push_str(&k.to_lowercase());
    }

    result
}

/// Convert a GPUI keystroke to a normalized shortcut string.
pub fn keystroke_to_shortcut(key: &str, modifiers: &gpui::Modifiers) -> String {
    let mut parts: Vec<&str> = Vec::new();
    if modifiers.alt {
        parts.push("alt");
    }
    if modifiers.platform {
        parts.push("cmd");
    }
    if modifiers.control {
        parts.push("ctrl");
    }
    if modifiers.shift {
        parts.push("shift");
    }

    let key_lower = key.to_lowercase();
    let mut result = parts.join("+");
    if !result.is_empty() {
        result.push('+');
    }
    result.push_str(&key_lower);
    result
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn parse_shortcut_accepts_space_and_plus() {
        let (mods, code) = parse_shortcut("cmd shift k").expect("shortcut should parse");
        assert!(mods.contains(Modifiers::META));
        assert!(mods.contains(Modifiers::SHIFT));
        assert_eq!(code, Code::KeyK);

        let (mods, code) = parse_shortcut("ctrl+alt+delete").expect("shortcut should parse");
        assert!(mods.contains(Modifiers::CONTROL));
        assert!(mods.contains(Modifiers::ALT));
        assert_eq!(code, Code::Delete);
    }

    #[test]
    fn parse_shortcut_handles_arrows_and_invalid_keys() {
        let (mods, code) = parse_shortcut("shift down").expect("shortcut should parse");
        assert!(mods.contains(Modifiers::SHIFT));
        assert_eq!(code, Code::ArrowDown);

        assert!(parse_shortcut("cmd+madeup").is_none());
    }

    #[test]
    fn normalize_shortcut_sorts_and_lowercases() {
        assert_eq!(normalize_shortcut("Cmd+Shift+C"), "cmd+shift+c");
        assert_eq!(normalize_shortcut("shift+cmd+C"), "cmd+shift+c");
        assert_eq!(normalize_shortcut("ctrl+alt+delete"), "alt+ctrl+delete");
        assert_eq!(normalize_shortcut("command+opt+K"), "alt+cmd+k");
    }

    #[test]
    fn keystroke_to_shortcut_orders_modifiers() {
        let modifiers = gpui::Modifiers {
            alt: true,
            shift: true,
            ..Default::default()
        };
        assert_eq!(keystroke_to_shortcut("K", &modifiers), "alt+shift+k");

        let modifiers = gpui::Modifiers::default();
        assert_eq!(keystroke_to_shortcut("A", &modifiers), "a");
    }
}

</file>

<file path="src/shortcuts/persistence.rs">
//! User shortcut customization persistence.
//!
//! Handles loading and saving user shortcut overrides to/from config.
//! Format: HashMap<binding_id, Option<String>> where:
//! - Some(shortcut_string) = user override to new shortcut
//! - None = user disabled this shortcut

#![allow(dead_code)]

use std::collections::HashMap;
use std::fs;
use std::path::Path;

use serde::{Deserialize, Serialize};

use super::registry::ShortcutRegistry;
use super::types::{Shortcut, ShortcutParseError};

/// User shortcut overrides configuration.
///
/// Stored in ~/.scriptkit/shortcuts.json
#[derive(Clone, Debug, Default, Serialize, Deserialize)]
pub struct ShortcutOverrides {
    /// Map of binding_id -> override
    /// - Some(string) = new shortcut
    /// - null in JSON = disabled
    #[serde(default)]
    pub overrides: HashMap<String, Option<String>>,
}

/// Error that can occur when loading/saving shortcut overrides.
#[derive(Debug)]
pub enum PersistenceError {
    /// IO error reading/writing file
    Io(std::io::Error),
    /// JSON parse error
    Json(serde_json::Error),
    /// Invalid shortcut string in config
    InvalidShortcut {
        binding_id: String,
        shortcut: String,
        error: ShortcutParseError,
    },
}

impl std::fmt::Display for PersistenceError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::Io(e) => write!(f, "IO error: {}", e),
            Self::Json(e) => write!(f, "JSON parse error: {}", e),
            Self::InvalidShortcut {
                binding_id,
                shortcut,
                error,
            } => {
                write!(
                    f,
                    "Invalid shortcut '{}' for binding '{}': {}",
                    shortcut, binding_id, error
                )
            }
        }
    }
}

impl std::error::Error for PersistenceError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::Io(e) => Some(e),
            Self::Json(e) => Some(e),
            Self::InvalidShortcut { error, .. } => Some(error),
        }
    }
}

impl From<std::io::Error> for PersistenceError {
    fn from(e: std::io::Error) -> Self {
        Self::Io(e)
    }
}

impl From<serde_json::Error> for PersistenceError {
    fn from(e: serde_json::Error) -> Self {
        Self::Json(e)
    }
}

impl ShortcutOverrides {
    /// Load overrides from a JSON file.
    ///
    /// Returns empty overrides if file doesn't exist.
    pub fn load(path: &Path) -> Result<Self, PersistenceError> {
        if !path.exists() {
            return Ok(Self::default());
        }

        let content = fs::read_to_string(path)?;
        let overrides: Self = serde_json::from_str(&content)?;
        Ok(overrides)
    }

    /// Save overrides to a JSON file.
    pub fn save(&self, path: &Path) -> Result<(), PersistenceError> {
        // Create parent directories if needed
        if let Some(parent) = path.parent() {
            fs::create_dir_all(parent)?;
        }

        let content = serde_json::to_string_pretty(self)?;
        fs::write(path, content)?;
        Ok(())
    }

    /// Apply overrides to a registry.
    ///
    /// Returns a list of parse errors for invalid shortcuts (but still applies valid ones).
    pub fn apply_to_registry(&self, registry: &mut ShortcutRegistry) -> Vec<PersistenceError> {
        let mut errors = Vec::new();

        for (binding_id, override_opt) in &self.overrides {
            match override_opt {
                None => {
                    // Disable this shortcut
                    registry.set_override(binding_id, None);
                }
                Some(shortcut_str) => {
                    // Parse and set override
                    match Shortcut::parse(shortcut_str) {
                        Ok(shortcut) => {
                            registry.set_override(binding_id, Some(shortcut));
                        }
                        Err(e) => {
                            errors.push(PersistenceError::InvalidShortcut {
                                binding_id: binding_id.clone(),
                                shortcut: shortcut_str.clone(),
                                error: e,
                            });
                        }
                    }
                }
            }
        }

        errors
    }

    /// Extract current overrides from a registry.
    pub fn from_registry(registry: &ShortcutRegistry) -> Self {
        let overrides = registry.export_overrides();
        Self { overrides }
    }

    /// Set an override.
    pub fn set(&mut self, binding_id: impl Into<String>, shortcut: Option<String>) {
        self.overrides.insert(binding_id.into(), shortcut);
    }

    /// Remove an override (revert to default).
    pub fn remove(&mut self, binding_id: &str) {
        self.overrides.remove(binding_id);
    }

    /// Check if a binding has an override.
    pub fn has_override(&self, binding_id: &str) -> bool {
        self.overrides.contains_key(binding_id)
    }

    /// Get the override for a binding.
    pub fn get(&self, binding_id: &str) -> Option<&Option<String>> {
        self.overrides.get(binding_id)
    }

    /// Get the number of overrides.
    pub fn len(&self) -> usize {
        self.overrides.len()
    }

    /// Check if there are no overrides.
    pub fn is_empty(&self) -> bool {
        self.overrides.is_empty()
    }

    /// Clear all overrides.
    pub fn clear(&mut self) {
        self.overrides.clear();
    }
}

/// Get the default path for shortcut overrides.
pub fn default_overrides_path() -> std::path::PathBuf {
    dirs::home_dir()
        .unwrap_or_default()
        .join(".scriptkit")
        .join("shortcuts.json")
}

// ============================================================================
// Standalone convenience functions for UI integration
// ============================================================================
// These functions provide a simpler API for the shortcut recorder UI.
// The JSON format is: { "command_id": { "modifiers": {...}, "key": "..." }, ... }
// ============================================================================

use anyhow::{Context, Result};

/// Load all shortcut overrides from ~/.scriptkit/shortcuts.json.
///
/// Returns a HashMap mapping command_id to Shortcut.
/// Returns an empty HashMap if the file doesn't exist.
///
/// # Errors
/// Returns an error if the file exists but cannot be read or parsed.
pub fn load_shortcut_overrides() -> Result<HashMap<String, Shortcut>> {
    let path = default_overrides_path();

    if !path.exists() {
        return Ok(HashMap::new());
    }

    let content = fs::read_to_string(&path)
        .with_context(|| format!("Failed to read shortcuts file: {}", path.display()))?;

    let overrides: HashMap<String, Shortcut> = serde_json::from_str(&content)
        .with_context(|| format!("Failed to parse shortcuts file: {}", path.display()))?;

    Ok(overrides)
}

/// Save a shortcut override for a specific command.
///
/// This function:
/// 1. Loads existing overrides (or creates empty map if file doesn't exist)
/// 2. Adds/updates the shortcut for the given command_id
/// 3. Writes the updated overrides back to ~/.scriptkit/shortcuts.json
///
/// # Arguments
/// * `command_id` - The unique identifier for the command (e.g., "script.my-script")
/// * `shortcut` - The new shortcut to assign
///
/// # Errors
/// Returns an error if the file cannot be written or the JSON cannot be serialized.
pub fn save_shortcut_override(command_id: &str, shortcut: &Shortcut) -> Result<()> {
    let path = default_overrides_path();

    // Load existing overrides
    let mut overrides = load_shortcut_overrides().unwrap_or_default();

    // Update with new shortcut
    overrides.insert(command_id.to_string(), shortcut.clone());

    // Ensure parent directory exists
    if let Some(parent) = path.parent() {
        fs::create_dir_all(parent)
            .with_context(|| format!("Failed to create directory: {}", parent.display()))?;
    }

    // Write back to file
    let content = serde_json::to_string_pretty(&overrides)
        .context("Failed to serialize shortcuts to JSON")?;

    fs::write(&path, content)
        .with_context(|| format!("Failed to write shortcuts file: {}", path.display()))?;

    Ok(())
}

/// Remove a shortcut override for a specific command.
///
/// This reverts the command to its default shortcut (or no shortcut).
/// If the command_id doesn't exist in overrides, this is a no-op.
///
/// # Arguments
/// * `command_id` - The unique identifier for the command to remove
///
/// # Errors
/// Returns an error if the file cannot be read or written.
pub fn remove_shortcut_override(command_id: &str) -> Result<()> {
    let path = default_overrides_path();

    // If file doesn't exist, nothing to remove
    if !path.exists() {
        return Ok(());
    }

    // Load existing overrides
    let mut overrides = load_shortcut_overrides()?;

    // Remove the override
    overrides.remove(command_id);

    // Write back to file (even if empty, to reflect the removal)
    let content = serde_json::to_string_pretty(&overrides)
        .context("Failed to serialize shortcuts to JSON")?;

    fs::write(&path, content)
        .with_context(|| format!("Failed to write shortcuts file: {}", path.display()))?;

    Ok(())
}

#[cfg(test)]
mod tests {
    use super::*;
    use tempfile::tempdir;

    #[test]
    fn load_nonexistent_returns_empty() {
        let result = ShortcutOverrides::load(Path::new("/nonexistent/path/shortcuts.json"));
        assert!(result.is_ok());
        assert!(result.unwrap().is_empty());
    }

    #[test]
    fn save_and_load_roundtrip() {
        let dir = tempdir().unwrap();
        let path = dir.path().join("shortcuts.json");

        let mut overrides = ShortcutOverrides::default();
        overrides.set("test.action", Some("cmd+k".to_string()));
        overrides.set("test.disabled", None);

        overrides.save(&path).unwrap();

        let loaded = ShortcutOverrides::load(&path).unwrap();
        assert_eq!(loaded.len(), 2);
        assert_eq!(loaded.get("test.action"), Some(&Some("cmd+k".to_string())));
        assert_eq!(loaded.get("test.disabled"), Some(&None));
    }

    #[test]
    fn apply_valid_override_to_registry() {
        use super::super::context::ShortcutContext;
        use super::super::registry::{ShortcutBinding, ShortcutCategory, ShortcutRegistry};
        use super::super::types::Modifiers;

        let mut registry = ShortcutRegistry::new();
        registry.register(ShortcutBinding::builtin(
            "test.action",
            "Test",
            Shortcut {
                key: "k".to_string(),
                modifiers: Modifiers::cmd(),
            },
            ShortcutContext::Global,
            ShortcutCategory::Actions,
        ));

        let mut overrides = ShortcutOverrides::default();
        overrides.set("test.action", Some("cmd+j".to_string()));

        let errors = overrides.apply_to_registry(&mut registry);
        assert!(errors.is_empty());

        let shortcut = registry.get_shortcut("test.action").unwrap();
        assert_eq!(shortcut.key, "j");
    }

    #[test]
    fn apply_disable_override_to_registry() {
        use super::super::context::ShortcutContext;
        use super::super::registry::{ShortcutBinding, ShortcutCategory, ShortcutRegistry};
        use super::super::types::Modifiers;

        let mut registry = ShortcutRegistry::new();
        registry.register(ShortcutBinding::builtin(
            "test.action",
            "Test",
            Shortcut {
                key: "k".to_string(),
                modifiers: Modifiers::cmd(),
            },
            ShortcutContext::Global,
            ShortcutCategory::Actions,
        ));

        let mut overrides = ShortcutOverrides::default();
        overrides.set("test.action", None);

        let errors = overrides.apply_to_registry(&mut registry);
        assert!(errors.is_empty());

        assert!(registry.is_disabled("test.action"));
    }

    #[test]
    fn apply_invalid_shortcut_returns_error() {
        use super::super::registry::ShortcutRegistry;

        let mut registry = ShortcutRegistry::new();
        let mut overrides = ShortcutOverrides::default();
        overrides.set("test.action", Some("invalid+shortcut+xyz".to_string()));

        let errors = overrides.apply_to_registry(&mut registry);
        assert_eq!(errors.len(), 1);
        match &errors[0] {
            PersistenceError::InvalidShortcut { binding_id, .. } => {
                assert_eq!(binding_id, "test.action");
            }
            _ => panic!("Expected InvalidShortcut error"),
        }
    }

    #[test]
    fn set_and_remove_override() {
        let mut overrides = ShortcutOverrides::default();

        overrides.set("test.action", Some("cmd+k".to_string()));
        assert!(overrides.has_override("test.action"));

        overrides.remove("test.action");
        assert!(!overrides.has_override("test.action"));
    }

    #[test]
    fn json_format_is_readable() {
        let mut overrides = ShortcutOverrides::default();
        overrides.set("nav.up", Some("cmd+k".to_string()));
        overrides.set("nav.down", Some("cmd+j".to_string()));
        overrides.set("edit.copy", None);

        let json = serde_json::to_string_pretty(&overrides).unwrap();

        // Verify it's human-readable
        assert!(json.contains("nav.up"));
        assert!(json.contains("cmd+k"));
        assert!(json.contains("edit.copy"));
        assert!(json.contains("null")); // disabled shortcut
    }

    // ========================================================================
    // Tests for standalone convenience functions
    // ========================================================================

    #[test]
    fn load_shortcut_overrides_empty_when_no_file() {
        // The standalone function uses default path, but we can test the behavior
        // by verifying it returns empty HashMap for non-existent files
        // (this relies on the file not existing at the default path during tests)

        // Create a temp directory and test there via the underlying mechanisms
        let dir = tempdir().unwrap();
        let path = dir.path().join("shortcuts.json");

        // Directly test the logic: reading non-existent file
        assert!(!path.exists());
        let content = std::fs::read_to_string(&path);
        assert!(content.is_err());
    }

    #[test]
    fn save_and_load_shortcut_override_roundtrip() {
        use super::super::types::Modifiers;

        let dir = tempdir().unwrap();
        let path = dir.path().join("shortcuts.json");

        // Create a shortcut
        let shortcut = Shortcut {
            key: "k".to_string(),
            modifiers: Modifiers {
                cmd: true,
                shift: true,
                ..Default::default()
            },
        };

        // Manually save to temp path (simulating what save_shortcut_override does)
        let mut overrides: HashMap<String, Shortcut> = HashMap::new();
        overrides.insert("test.command".to_string(), shortcut.clone());

        std::fs::create_dir_all(dir.path()).unwrap();
        let content = serde_json::to_string_pretty(&overrides).unwrap();
        std::fs::write(&path, &content).unwrap();

        // Load back
        let loaded_content = std::fs::read_to_string(&path).unwrap();
        let loaded: HashMap<String, Shortcut> = serde_json::from_str(&loaded_content).unwrap();

        assert_eq!(loaded.len(), 1);
        let loaded_shortcut = loaded.get("test.command").unwrap();
        assert_eq!(loaded_shortcut.key, "k");
        assert!(loaded_shortcut.modifiers.cmd);
        assert!(loaded_shortcut.modifiers.shift);
        assert!(!loaded_shortcut.modifiers.ctrl);
        assert!(!loaded_shortcut.modifiers.alt);
    }

    #[test]
    fn remove_shortcut_override_from_map() {
        use super::super::types::Modifiers;

        let dir = tempdir().unwrap();
        let path = dir.path().join("shortcuts.json");

        // Create initial overrides
        let mut overrides: HashMap<String, Shortcut> = HashMap::new();
        overrides.insert(
            "test.command1".to_string(),
            Shortcut {
                key: "k".to_string(),
                modifiers: Modifiers::cmd(),
            },
        );
        overrides.insert(
            "test.command2".to_string(),
            Shortcut {
                key: "j".to_string(),
                modifiers: Modifiers::cmd(),
            },
        );

        // Save
        let content = serde_json::to_string_pretty(&overrides).unwrap();
        std::fs::write(&path, &content).unwrap();

        // Remove one
        overrides.remove("test.command1");

        // Save again
        let content = serde_json::to_string_pretty(&overrides).unwrap();
        std::fs::write(&path, &content).unwrap();

        // Verify
        let loaded_content = std::fs::read_to_string(&path).unwrap();
        let loaded: HashMap<String, Shortcut> = serde_json::from_str(&loaded_content).unwrap();
        assert_eq!(loaded.len(), 1);
        assert!(!loaded.contains_key("test.command1"));
        assert!(loaded.contains_key("test.command2"));
    }

    #[test]
    fn shortcut_json_format_matches_spec() {
        use super::super::types::Modifiers;

        // Verify the JSON format is: { "command_id": { "modifiers": {...}, "key": "..." } }
        let mut overrides: HashMap<String, Shortcut> = HashMap::new();
        overrides.insert(
            "my.command".to_string(),
            Shortcut {
                key: "k".to_string(),
                modifiers: Modifiers {
                    cmd: true,
                    shift: true,
                    ctrl: false,
                    alt: false,
                },
            },
        );

        let json = serde_json::to_string_pretty(&overrides).unwrap();

        // Verify structure
        assert!(json.contains("\"my.command\""));
        assert!(json.contains("\"key\""));
        assert!(json.contains("\"modifiers\""));
        assert!(json.contains("\"cmd\""));
        assert!(json.contains("\"shift\""));
        assert!(json.contains("\"k\""));
    }

    #[test]
    fn shortcut_serialization_includes_all_modifiers() {
        use super::super::types::Modifiers;

        let shortcut = Shortcut {
            key: "a".to_string(),
            modifiers: Modifiers {
                cmd: true,
                ctrl: true,
                alt: true,
                shift: true,
            },
        };

        let json = serde_json::to_string(&shortcut).unwrap();

        assert!(json.contains("\"cmd\":true"));
        assert!(json.contains("\"ctrl\":true"));
        assert!(json.contains("\"alt\":true"));
        assert!(json.contains("\"shift\":true"));
        assert!(json.contains("\"key\":\"a\""));
    }

    #[test]
    fn shortcut_deserialization_with_missing_modifiers_defaults_false() {
        // Test that missing modifier fields default to false
        let json = r#"{"key": "b", "modifiers": {"cmd": true}}"#;
        let shortcut: Shortcut = serde_json::from_str(json).unwrap();

        assert_eq!(shortcut.key, "b");
        assert!(shortcut.modifiers.cmd);
        assert!(!shortcut.modifiers.ctrl);
        assert!(!shortcut.modifiers.alt);
        assert!(!shortcut.modifiers.shift);
    }
}

</file>

<file path="src/shortcuts/registry.rs">
//! Deterministic shortcut registry with Vec storage.
//!
//! Uses Vec for deterministic iteration order and HashMap for O(1) lookup.

#![allow(dead_code)]

use std::collections::{HashMap, HashSet};

use super::context::ShortcutContext;
use super::types::{ConflictInfo, Shortcut};

/// Source of a shortcut binding.
///
/// Priority order (highest first): user_override > Builtin > Script
/// This ensures built-in shortcuts aren't silently stolen by scripts.
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord)]
pub enum BindingSource {
    /// Built-in app shortcut (highest priority)
    Builtin = 0,
    /// Script-defined shortcut (lower priority)
    Script = 1,
}

impl BindingSource {
    /// Get the priority value (lower = higher priority).
    pub fn priority(&self) -> u8 {
        match self {
            Self::Builtin => 0,
            Self::Script => 1,
        }
    }
}

/// Scope in which a shortcut operates.
#[derive(Clone, Copy, Debug, Default, PartialEq, Eq, Hash)]
pub enum ShortcutScope {
    #[default]
    App,
    Global,
}

/// Category for organizing shortcuts in UI.
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub enum ShortcutCategory {
    Navigation,
    Actions,
    Edit,
    View,
    Scripts,
    System,
}

/// A shortcut binding with metadata.
#[derive(Clone, Debug)]
pub struct ShortcutBinding {
    pub id: String,
    pub name: String,
    pub default_shortcut: Shortcut,
    pub context: ShortcutContext,
    pub scope: ShortcutScope,
    pub category: ShortcutCategory,
    pub source: BindingSource,
    pub customizable: bool,
}

impl ShortcutBinding {
    pub fn builtin(
        id: impl Into<String>,
        name: impl Into<String>,
        shortcut: Shortcut,
        context: ShortcutContext,
        category: ShortcutCategory,
    ) -> Self {
        Self {
            id: id.into(),
            name: name.into(),
            default_shortcut: shortcut,
            context,
            scope: ShortcutScope::App,
            category,
            source: BindingSource::Builtin,
            customizable: true,
        }
    }

    pub fn script(id: impl Into<String>, name: impl Into<String>, shortcut: Shortcut) -> Self {
        Self {
            id: id.into(),
            name: name.into(),
            default_shortcut: shortcut,
            context: ShortcutContext::Global,
            scope: ShortcutScope::App,
            category: ShortcutCategory::Scripts,
            source: BindingSource::Script,
            customizable: false,
        }
    }

    pub fn non_customizable(mut self) -> Self {
        self.customizable = false;
        self
    }

    pub fn global(mut self) -> Self {
        self.scope = ShortcutScope::Global;
        self
    }
}

/// Central registry of all keyboard shortcuts.
pub struct ShortcutRegistry {
    bindings: Vec<ShortcutBinding>,
    id_to_index: HashMap<String, usize>,
    user_overrides: HashMap<String, Option<Shortcut>>,
    disabled: HashSet<String>,
}

impl Default for ShortcutRegistry {
    fn default() -> Self {
        Self::new()
    }
}

impl ShortcutRegistry {
    pub fn new() -> Self {
        Self {
            bindings: Vec::new(),
            id_to_index: HashMap::new(),
            user_overrides: HashMap::new(),
            disabled: HashSet::new(),
        }
    }

    pub fn register(&mut self, binding: ShortcutBinding) {
        let id = binding.id.clone();
        if let Some(&existing_index) = self.id_to_index.get(&id) {
            self.bindings[existing_index] = binding;
        } else {
            let index = self.bindings.len();
            self.bindings.push(binding);
            self.id_to_index.insert(id, index);
        }
    }

    pub fn unregister(&mut self, id: &str) {
        self.disabled.insert(id.to_string());
    }

    pub fn get(&self, id: &str) -> Option<&ShortcutBinding> {
        self.id_to_index.get(id).and_then(|&i| self.bindings.get(i))
    }

    pub fn get_shortcut(&self, id: &str) -> Option<Shortcut> {
        if self.disabled.contains(id) {
            return None;
        }
        if let Some(override_opt) = self.user_overrides.get(id) {
            return override_opt.clone();
        }
        self.get(id).map(|b| b.default_shortcut.clone())
    }

    pub fn set_override(&mut self, id: &str, shortcut: Option<Shortcut>) {
        if shortcut.is_none() {
            self.disabled.insert(id.to_string());
        } else {
            self.disabled.remove(id);
        }
        self.user_overrides.insert(id.to_string(), shortcut);
    }

    pub fn clear_override(&mut self, id: &str) {
        self.user_overrides.remove(id);
        self.disabled.remove(id);
    }

    pub fn is_disabled(&self, id: &str) -> bool {
        self.disabled.contains(id)
    }

    /// Find a matching binding for a keystroke in the given context stack.
    ///
    /// Within each context, priority order is:
    /// 1. User overrides (always win if present)
    /// 2. Builtins (win over scripts)
    /// 3. Scripts (lowest priority)
    pub fn find_match(
        &self,
        keystroke: &gpui::Keystroke,
        contexts: &[ShortcutContext],
    ) -> Option<&str> {
        for context in contexts {
            // Collect all matches in this context
            let mut matches: Vec<(&ShortcutBinding, bool)> = Vec::new();

            for binding in &self.bindings {
                if binding.context != *context || self.disabled.contains(&binding.id) {
                    continue;
                }

                let has_user_override = self.user_overrides.contains_key(&binding.id);
                let shortcut = if let Some(override_opt) = self.user_overrides.get(&binding.id) {
                    match override_opt {
                        Some(s) => s.clone(),
                        None => continue, // Disabled via override
                    }
                } else {
                    binding.default_shortcut.clone()
                };

                if shortcut.matches_keystroke(keystroke) {
                    matches.push((binding, has_user_override));
                }
            }

            // If we have matches, return the highest priority one
            if !matches.is_empty() {
                // Sort by: user_override first, then source priority, then registration order
                matches.sort_by(|(a, a_override), (b, b_override)| {
                    // User override always wins
                    match (a_override, b_override) {
                        (true, false) => std::cmp::Ordering::Less,
                        (false, true) => std::cmp::Ordering::Greater,
                        _ => {
                            // Same override status: compare source priority
                            a.source.priority().cmp(&b.source.priority())
                        }
                    }
                });

                return Some(&matches[0].0.id);
            }
        }
        None
    }

    /// Check if a script shortcut would conflict with a builtin.
    ///
    /// Returns the ID of the conflicting builtin if one exists.
    pub fn check_builtin_conflict(
        &self,
        shortcut: &Shortcut,
        context: ShortcutContext,
    ) -> Option<&str> {
        for binding in &self.bindings {
            if binding.source != BindingSource::Builtin {
                continue;
            }
            if binding.context != context && binding.context != ShortcutContext::Global {
                continue;
            }
            if self.disabled.contains(&binding.id) {
                continue;
            }

            let effective = self
                .user_overrides
                .get(&binding.id)
                .cloned()
                .unwrap_or_else(|| Some(binding.default_shortcut.clone()));

            if let Some(builtin_shortcut) = effective {
                if builtin_shortcut == *shortcut {
                    return Some(&binding.id);
                }
            }
        }
        None
    }

    pub fn bindings(&self) -> &[ShortcutBinding] {
        &self.bindings
    }

    pub fn bindings_by_category(&self, category: ShortcutCategory) -> Vec<&ShortcutBinding> {
        self.bindings
            .iter()
            .filter(|b| b.category == category && !self.disabled.contains(&b.id))
            .collect()
    }

    pub fn bindings_by_context(&self, context: ShortcutContext) -> Vec<&ShortcutBinding> {
        self.bindings
            .iter()
            .filter(|b| b.context == context && !self.disabled.contains(&b.id))
            .collect()
    }

    pub fn active_count(&self) -> usize {
        self.bindings
            .iter()
            .filter(|b| !self.disabled.contains(&b.id))
            .count()
    }

    /// Get all user overrides as a map of binding_id -> Option<Shortcut>.
    ///
    /// Returns None for disabled shortcuts, Some(shortcut) for overridden shortcuts.
    pub fn get_overrides(&self) -> &HashMap<String, Option<Shortcut>> {
        &self.user_overrides
    }

    /// Export user overrides as canonical strings for persistence.
    ///
    /// Returns a map of binding_id -> Option<String> where:
    /// - Some(string) = override shortcut as canonical string
    /// - None = shortcut is disabled
    pub fn export_overrides(&self) -> HashMap<String, Option<String>> {
        self.user_overrides
            .iter()
            .map(|(id, opt)| (id.clone(), opt.as_ref().map(|s| s.to_canonical_string())))
            .collect()
    }

    /// Find all conflicts in the registry.
    ///
    /// Returns a list of conflicts, each containing:
    /// - The type of conflict
    /// - The IDs of the conflicting bindings
    /// - The conflicting shortcut
    pub fn find_conflicts(&self) -> Vec<ShortcutConflict> {
        let mut conflicts = Vec::new();

        // Build a map of effective shortcuts to bindings
        let mut shortcut_map: HashMap<(String, ShortcutContext), Vec<&ShortcutBinding>> =
            HashMap::new();

        for binding in &self.bindings {
            if self.disabled.contains(&binding.id) {
                continue;
            }

            let effective = self
                .user_overrides
                .get(&binding.id)
                .cloned()
                .unwrap_or_else(|| Some(binding.default_shortcut.clone()));

            if let Some(shortcut) = effective {
                let key = (shortcut.to_canonical_string(), binding.context);
                shortcut_map.entry(key).or_default().push(binding);
            }
        }

        // Check for hard conflicts (same shortcut + same context)
        for ((shortcut_str, context), bindings) in &shortcut_map {
            if bindings.len() > 1 {
                // Sort by priority to determine winner/loser
                let mut sorted: Vec<_> = bindings.iter().collect();
                sorted.sort_by_key(|b| b.source.priority());

                let winner = sorted[0];
                for loser in &sorted[1..] {
                    let conflict_type = if winner.source == loser.source {
                        ConflictType::Hard
                    } else {
                        // Different sources: higher priority shadows lower
                        ConflictType::Shadowed
                    };

                    conflicts.push(ShortcutConflict {
                        conflict_type,
                        winner_id: winner.id.clone(),
                        loser_id: loser.id.clone(),
                        shortcut: shortcut_str.clone(),
                        context: *context,
                    });
                }
            }
        }

        // Check for shadowing across context specificity
        for binding in &self.bindings {
            if self.disabled.contains(&binding.id) {
                continue;
            }

            let effective = self
                .user_overrides
                .get(&binding.id)
                .cloned()
                .unwrap_or_else(|| Some(binding.default_shortcut.clone()));

            if let Some(shortcut) = effective {
                let shortcut_str = shortcut.to_canonical_string();

                // Check if this binding is shadowed by a more specific context
                for other in &self.bindings {
                    if other.id == binding.id || self.disabled.contains(&other.id) {
                        continue;
                    }

                    // Skip if not same shortcut
                    let other_effective = self
                        .user_overrides
                        .get(&other.id)
                        .cloned()
                        .unwrap_or_else(|| Some(other.default_shortcut.clone()));

                    let other_shortcut = match other_effective {
                        Some(s) => s,
                        None => continue,
                    };

                    if other_shortcut.to_canonical_string() != shortcut_str {
                        continue;
                    }

                    // Check context specificity: other shadows binding if other is more specific
                    if other.context.specificity() > binding.context.specificity()
                        && binding.context.contains(&other.context)
                    {
                        // Already covered by same-context check
                        continue;
                    }
                }
            }
        }

        // Check for OS-reserved shortcuts (unreachable)
        let os_reserved = Self::get_os_reserved_shortcuts();
        for binding in &self.bindings {
            if self.disabled.contains(&binding.id) {
                continue;
            }

            let effective = self
                .user_overrides
                .get(&binding.id)
                .cloned()
                .unwrap_or_else(|| Some(binding.default_shortcut.clone()));

            if let Some(shortcut) = effective {
                let canonical = shortcut.to_canonical_string();
                if os_reserved.contains(&canonical.as_str()) {
                    conflicts.push(ShortcutConflict {
                        conflict_type: ConflictType::Unreachable,
                        winner_id: "system".to_string(),
                        loser_id: binding.id.clone(),
                        shortcut: canonical,
                        context: binding.context,
                    });
                }
            }
        }

        conflicts
    }

    /// Get list of OS-reserved shortcuts that cannot be overridden.
    ///
    /// These are typically system-level shortcuts that apps cannot intercept.
    fn get_os_reserved_shortcuts() -> HashSet<&'static str> {
        let mut reserved = HashSet::new();

        #[cfg(target_os = "macos")]
        {
            // macOS system shortcuts
            reserved.insert("cmd+tab"); // App switcher
            reserved.insert("cmd+shift+tab"); // Reverse app switcher
            reserved.insert("cmd+space"); // Spotlight (often)
            reserved.insert("cmd+ctrl+q"); // Lock screen
            reserved.insert("cmd+shift+3"); // Screenshot full
            reserved.insert("cmd+shift+4"); // Screenshot selection
            reserved.insert("cmd+shift+5"); // Screenshot/record options
            reserved.insert("ctrl+up"); // Mission Control
            reserved.insert("ctrl+down"); // App windows
            reserved.insert("ctrl+left"); // Move space left
            reserved.insert("ctrl+right"); // Move space right
        }

        #[cfg(target_os = "windows")]
        {
            // Windows system shortcuts
            reserved.insert("cmd+tab"); // Alt+Tab (cmd maps to Win)
            reserved.insert("cmd+d"); // Show desktop
            reserved.insert("cmd+l"); // Lock
            reserved.insert("cmd+e"); // File Explorer
            reserved.insert("ctrl+alt+delete"); // Security options
        }

        #[cfg(target_os = "linux")]
        {
            // Common Linux shortcuts (vary by DE)
            reserved.insert("alt+tab"); // Window switcher
            reserved.insert("cmd+tab"); // Super+Tab
            reserved.insert("ctrl+alt+t"); // Terminal (common)
            reserved.insert("ctrl+alt+delete"); // System
        }

        reserved
    }

    /// Get conflicts for a specific binding.
    pub fn conflicts_for(&self, id: &str) -> Vec<ShortcutConflict> {
        self.find_conflicts()
            .into_iter()
            .filter(|c| c.winner_id == id || c.loser_id == id)
            .collect()
    }

    /// Check if adding a shortcut would create conflicts.
    ///
    /// Returns the conflicts that would be created if this shortcut were added.
    pub fn would_conflict(
        &self,
        shortcut: &Shortcut,
        context: ShortcutContext,
        source: BindingSource,
    ) -> Vec<PotentialConflict> {
        let mut conflicts = Vec::new();
        let canonical = shortcut.to_canonical_string();

        // Check OS reserved
        let os_reserved = Self::get_os_reserved_shortcuts();
        if os_reserved.contains(&canonical.as_str()) {
            conflicts.push(PotentialConflict {
                conflict_type: ConflictType::Unreachable,
                existing_id: "system".to_string(),
                existing_name: "System Shortcut".to_string(),
            });
        }

        // Check existing bindings
        for binding in &self.bindings {
            if self.disabled.contains(&binding.id) {
                continue;
            }

            let effective = self
                .user_overrides
                .get(&binding.id)
                .cloned()
                .unwrap_or_else(|| Some(binding.default_shortcut.clone()));

            if let Some(existing_shortcut) = effective {
                if existing_shortcut.to_canonical_string() != canonical {
                    continue;
                }

                // Same shortcut - check context overlap
                let contexts_overlap = binding.context == context
                    || binding.context == ShortcutContext::Global
                    || context == ShortcutContext::Global
                    || binding.context.contains(&context)
                    || context.contains(&binding.context);

                if contexts_overlap {
                    let conflict_type = if binding.context == context
                        && source.priority() == binding.source.priority()
                    {
                        ConflictType::Hard // Same context + same priority = hard conflict
                    } else {
                        ConflictType::Shadowed // Different priority or context = shadowing
                    };

                    conflicts.push(PotentialConflict {
                        conflict_type,
                        existing_id: binding.id.clone(),
                        existing_name: binding.name.clone(),
                    });
                }
            }
        }

        conflicts
    }

    /// Find a conflict for a proposed shortcut.
    ///
    /// This is the primary API for the ShortcutRecorder UI. It checks if the given
    /// shortcut is already registered (either as a default or user override) and
    /// returns conflict information suitable for displaying to the user.
    ///
    /// # Arguments
    /// * `shortcut` - The shortcut to check for conflicts
    ///
    /// # Returns
    /// * `Some(ConflictInfo)` if the shortcut conflicts with an existing binding
    /// * `None` if the shortcut is available
    ///
    /// # Example
    /// ```ignore
    /// let shortcut = Shortcut::parse("cmd+k").unwrap();
    /// if let Some(conflict) = registry.find_conflict(&shortcut) {
    ///     println!("Conflict with: {} ({})", conflict.command_name, conflict.command_type);
    /// }
    /// ```
    pub fn find_conflict(&self, shortcut: &Shortcut) -> Option<ConflictInfo> {
        let canonical = shortcut.to_canonical_string();

        // Check OS reserved shortcuts first
        let os_reserved = Self::get_os_reserved_shortcuts();
        if os_reserved.contains(&canonical.as_str()) {
            return Some(ConflictInfo::system());
        }

        // Check all registered bindings (both defaults and user overrides)
        for binding in &self.bindings {
            if self.disabled.contains(&binding.id) {
                continue;
            }

            // Get the effective shortcut (user override or default)
            let effective = self
                .user_overrides
                .get(&binding.id)
                .cloned()
                .unwrap_or_else(|| Some(binding.default_shortcut.clone()));

            if let Some(existing_shortcut) = effective {
                if existing_shortcut.to_canonical_string() == canonical {
                    // Found a conflict
                    let command_type = match binding.source {
                        BindingSource::Builtin => "builtin",
                        BindingSource::Script => "script",
                    };

                    return Some(ConflictInfo {
                        conflicting_command_id: binding.id.clone(),
                        command_name: binding.name.clone(),
                        command_type: command_type.to_string(),
                    });
                }
            }
        }

        None
    }

    /// Find a conflict for a shortcut, excluding a specific command ID.
    ///
    /// This is useful when editing an existing shortcut - you want to check
    /// for conflicts but not report a conflict with the command being edited.
    ///
    /// # Arguments
    /// * `shortcut` - The shortcut to check for conflicts
    /// * `exclude_id` - The command ID to exclude from conflict checking
    ///
    /// # Returns
    /// * `Some(ConflictInfo)` if the shortcut conflicts with another binding
    /// * `None` if the shortcut is available (or only conflicts with excluded ID)
    pub fn find_conflict_excluding(
        &self,
        shortcut: &Shortcut,
        exclude_id: &str,
    ) -> Option<ConflictInfo> {
        let canonical = shortcut.to_canonical_string();

        // Check OS reserved shortcuts first
        let os_reserved = Self::get_os_reserved_shortcuts();
        if os_reserved.contains(&canonical.as_str()) {
            return Some(ConflictInfo::system());
        }

        // Check all registered bindings (both defaults and user overrides)
        for binding in &self.bindings {
            // Skip the excluded binding
            if binding.id == exclude_id {
                continue;
            }
            if self.disabled.contains(&binding.id) {
                continue;
            }

            // Get the effective shortcut (user override or default)
            let effective = self
                .user_overrides
                .get(&binding.id)
                .cloned()
                .unwrap_or_else(|| Some(binding.default_shortcut.clone()));

            if let Some(existing_shortcut) = effective {
                if existing_shortcut.to_canonical_string() == canonical {
                    // Found a conflict
                    let command_type = match binding.source {
                        BindingSource::Builtin => "builtin",
                        BindingSource::Script => "script",
                    };

                    return Some(ConflictInfo {
                        conflicting_command_id: binding.id.clone(),
                        command_name: binding.name.clone(),
                        command_type: command_type.to_string(),
                    });
                }
            }
        }

        None
    }

    /// Get the human-readable name for a command ID.
    ///
    /// # Arguments
    /// * `id` - The command ID to look up
    ///
    /// # Returns
    /// * `Some(&str)` with the command name if found
    /// * `None` if the command ID is not registered
    pub fn get_command_name(&self, id: &str) -> Option<&str> {
        self.get(id).map(|binding| binding.name.as_str())
    }

    /// Get full binding info for a command ID, useful for UI display.
    ///
    /// Returns the binding along with its effective shortcut (considering overrides).
    pub fn get_binding_info(&self, id: &str) -> Option<(&ShortcutBinding, Option<Shortcut>)> {
        self.get(id).map(|binding| {
            let effective = self
                .user_overrides
                .get(&binding.id)
                .cloned()
                .unwrap_or_else(|| Some(binding.default_shortcut.clone()));
            (binding, effective)
        })
    }
}

/// Type of shortcut conflict.
#[derive(Clone, Copy, Debug, PartialEq, Eq)]
pub enum ConflictType {
    /// Same shortcut + same context + same priority.
    /// One must be changed or disabled.
    Hard,
    /// Shortcut exists but is intentionally shadowed by context specificity
    /// or source priority. The more specific/higher priority binding wins.
    Shadowed,
    /// Shortcut is reserved by the OS and cannot be overridden.
    Unreachable,
}

/// A conflict between two shortcut bindings.
#[derive(Clone, Debug)]
pub struct ShortcutConflict {
    pub conflict_type: ConflictType,
    pub winner_id: String,
    pub loser_id: String,
    pub shortcut: String,
    pub context: ShortcutContext,
}

/// A potential conflict that would occur if a shortcut were added.
#[derive(Clone, Debug)]
pub struct PotentialConflict {
    pub conflict_type: ConflictType,
    pub existing_id: String,
    pub existing_name: String,
}

</file>

<file path="src/shortcuts/types.rs">
//! Core shortcut types with proper error handling and platform-aware display.
//!
//! This module provides:
//! - `Shortcut` - A keyboard shortcut (modifiers + key)
//! - `Modifiers` - Modifier key flags (cmd, ctrl, alt, shift)
//! - `ShortcutParseError` - Detailed parse errors for user feedback
//! - Platform-aware display (⌘⇧K on macOS, Ctrl+Shift+K on Windows/Linux)

// Allow dead code during incremental development - these types will be used
// by the context stack (task 2) and registry (task 3).
#![allow(dead_code)]

use serde::{Deserialize, Serialize};
use std::fmt;
use thiserror::Error;

/// Errors that can occur when parsing a shortcut string.
#[derive(Error, Debug, Clone, PartialEq, Eq)]
pub enum ShortcutParseError {
    #[error("shortcut string is empty")]
    Empty,
    #[error("shortcut has no key, only modifiers")]
    MissingKey,
    #[error("unknown token '{0}' in shortcut")]
    UnknownToken(String),
    #[error("unknown key '{0}'")]
    UnknownKey(String),
}

/// Modifier keys for a shortcut.
///
/// Note on `cmd` (platform accelerator):
/// - On macOS: Command (⌘)
/// - On Windows/Linux: Ctrl
#[derive(Clone, Copy, Debug, Default, PartialEq, Eq, Hash, Serialize, Deserialize)]
pub struct Modifiers {
    #[serde(default)]
    pub cmd: bool,
    #[serde(default)]
    pub ctrl: bool,
    #[serde(default)]
    pub alt: bool,
    #[serde(default)]
    pub shift: bool,
}

impl Modifiers {
    pub fn cmd() -> Self {
        Self {
            cmd: true,
            ..Default::default()
        }
    }
    pub fn shift() -> Self {
        Self {
            shift: true,
            ..Default::default()
        }
    }
    pub fn any(&self) -> bool {
        self.cmd || self.ctrl || self.alt || self.shift
    }
    pub fn none(&self) -> bool {
        !self.any()
    }
}

/// Platform enum for display formatting.
#[derive(Clone, Copy, Debug, PartialEq, Eq)]
pub enum Platform {
    MacOS,
    Windows,
    Linux,
}

impl Platform {
    pub fn current() -> Self {
        #[cfg(target_os = "macos")]
        {
            Platform::MacOS
        }
        #[cfg(target_os = "windows")]
        {
            Platform::Windows
        }
        #[cfg(target_os = "linux")]
        {
            Platform::Linux
        }
        #[cfg(not(any(target_os = "macos", target_os = "windows", target_os = "linux")))]
        {
            Platform::Linux
        }
    }
}

/// A keyboard shortcut consisting of modifier keys and a main key.
#[derive(Clone, Debug, PartialEq, Eq, Hash, Serialize, Deserialize)]
pub struct Shortcut {
    pub key: String,
    pub modifiers: Modifiers,
}

impl Shortcut {
    pub fn new(key: impl Into<String>, modifiers: Modifiers) -> Self {
        Self {
            key: canonicalize_key(&key.into()),
            modifiers,
        }
    }

    pub fn parse(s: &str) -> Result<Self, ShortcutParseError> {
        let s = s.trim();
        if s.is_empty() {
            return Err(ShortcutParseError::Empty);
        }

        let normalized = s.replace('+', " ");
        let parts: Vec<&str> = normalized.split_whitespace().collect();
        if parts.is_empty() {
            return Err(ShortcutParseError::Empty);
        }

        let mut modifiers = Modifiers::default();
        let mut key_part: Option<&str> = None;

        for part in &parts {
            let part_lower = part.to_lowercase();
            match part_lower.as_str() {
                "cmd" | "command" | "meta" | "super" | "win" | "⌘" | "mod" => {
                    modifiers.cmd = true
                }
                "ctrl" | "control" | "ctl" | "^" => modifiers.ctrl = true,
                "alt" | "opt" | "option" | "⌥" => modifiers.alt = true,
                "shift" | "shft" | "⇧" => modifiers.shift = true,
                _ => {
                    if key_part.is_some() {
                        return Err(ShortcutParseError::UnknownToken(part.to_string()));
                    }
                    key_part = Some(part);
                }
            }
        }

        let key = key_part.ok_or(ShortcutParseError::MissingKey)?;
        let canonical_key = canonicalize_key(key);
        if !is_known_key(&canonical_key) {
            return Err(ShortcutParseError::UnknownKey(key.to_string()));
        }

        Ok(Self {
            key: canonical_key,
            modifiers,
        })
    }

    pub fn display(&self) -> String {
        self.display_for_platform(Platform::current())
    }

    pub fn display_for_platform(&self, platform: Platform) -> String {
        match platform {
            Platform::MacOS => self.display_macos(),
            Platform::Windows | Platform::Linux => self.display_other(),
        }
    }

    fn display_macos(&self) -> String {
        let mut s = String::new();
        if self.modifiers.ctrl {
            s.push('⌃');
        }
        if self.modifiers.alt {
            s.push('⌥');
        }
        if self.modifiers.shift {
            s.push('⇧');
        }
        if self.modifiers.cmd {
            s.push('⌘');
        }
        s.push_str(&self.key_display());
        s
    }

    fn display_other(&self) -> String {
        let mut parts: Vec<String> = Vec::new();
        if self.modifiers.ctrl {
            parts.push("Ctrl".to_string());
        }
        if self.modifiers.alt {
            parts.push("Alt".to_string());
        }
        if self.modifiers.shift {
            parts.push("Shift".to_string());
        }
        if self.modifiers.cmd {
            parts.push("Super".to_string());
        }
        parts.push(self.key_display_text());
        parts.join("+")
    }

    fn key_display(&self) -> String {
        match self.key.as_str() {
            "enter" => "↵",
            "escape" => "⎋",
            "tab" => "⇥",
            "space" => "␣",
            "backspace" => "⌫",
            "delete" => "⌦",
            "up" => "↑",
            "down" => "↓",
            "left" => "←",
            "right" => "→",
            "home" => "↖",
            "end" => "↘",
            "pageup" => "⇞",
            "pagedown" => "⇟",
            k => return k.to_uppercase(),
        }
        .to_string()
    }

    fn key_display_text(&self) -> String {
        match self.key.as_str() {
            "enter" => "Enter",
            "escape" => "Esc",
            "tab" => "Tab",
            "space" => "Space",
            "backspace" => "Backspace",
            "delete" => "Delete",
            "up" => "Up",
            "down" => "Down",
            "left" => "Left",
            "right" => "Right",
            "home" => "Home",
            "end" => "End",
            "pageup" => "PageUp",
            "pagedown" => "PageDown",
            k => return k.to_uppercase(),
        }
        .to_string()
    }

    pub fn to_canonical_string(&self) -> String {
        let mut parts: Vec<&str> = Vec::new();
        if self.modifiers.alt {
            parts.push("alt");
        }
        if self.modifiers.cmd {
            parts.push("cmd");
        }
        if self.modifiers.ctrl {
            parts.push("ctrl");
        }
        if self.modifiers.shift {
            parts.push("shift");
        }
        parts.push(&self.key);
        parts.join("+")
    }

    pub fn matches_keystroke(&self, keystroke: &gpui::Keystroke) -> bool {
        let canonical = canonicalize_key(&keystroke.key.to_lowercase());
        canonical == self.key
            && keystroke.modifiers.platform == self.modifiers.cmd
            && keystroke.modifiers.control == self.modifiers.ctrl
            && keystroke.modifiers.alt == self.modifiers.alt
            && keystroke.modifiers.shift == self.modifiers.shift
    }
}

impl fmt::Display for Shortcut {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        write!(f, "{}", self.display())
    }
}

/// Canonicalize a key name to the internal standard form.
pub fn canonicalize_key(key: &str) -> String {
    let key_lower = key.to_lowercase();
    match key_lower.as_str() {
        "arrowup" | "uparrow" => "up",
        "arrowdown" | "downarrow" => "down",
        "arrowleft" | "leftarrow" => "left",
        "arrowright" | "rightarrow" => "right",
        "return" => "enter",
        "esc" => "escape",
        "back" => "backspace",
        "del" => "delete",
        "/" | "forwardslash" => "slash",
        "\\" => "backslash",
        ";" => "semicolon",
        "'" | "apostrophe" => "quote",
        "," => "comma",
        "." | "dot" => "period",
        "[" | "leftbracket" => "bracketleft",
        "]" | "rightbracket" => "bracketright",
        "-" | "dash" | "hyphen" => "minus",
        "=" | "equals" => "equal",
        "`" | "backtick" | "grave" => "backquote",
        "pgup" => "pageup",
        "pgdn" | "pgdown" => "pagedown",
        _ => return key_lower,
    }
    .to_string()
}

/// Information about a shortcut conflict.
///
/// This struct provides UI-friendly information about a conflict between
/// a proposed shortcut and an existing one. Used by ShortcutRecorder to
/// display warnings before saving.
#[derive(Clone, Debug, PartialEq, Eq)]
pub struct ConflictInfo {
    /// The ID of the command that already has this shortcut
    pub conflicting_command_id: String,
    /// Human-readable name of the conflicting command (e.g., "Move Selection Up")
    pub command_name: String,
    /// Type of command: "builtin", "script", or "system"
    pub command_type: String,
}

impl ConflictInfo {
    /// Create a new ConflictInfo for a builtin command
    pub fn builtin(id: impl Into<String>, name: impl Into<String>) -> Self {
        Self {
            conflicting_command_id: id.into(),
            command_name: name.into(),
            command_type: "builtin".to_string(),
        }
    }

    /// Create a new ConflictInfo for a script command
    pub fn script(id: impl Into<String>, name: impl Into<String>) -> Self {
        Self {
            conflicting_command_id: id.into(),
            command_name: name.into(),
            command_type: "script".to_string(),
        }
    }

    /// Create a new ConflictInfo for a system/OS reserved shortcut
    pub fn system() -> Self {
        Self {
            conflicting_command_id: "system".to_string(),
            command_name: "System Shortcut".to_string(),
            command_type: "system".to_string(),
        }
    }
}

/// Check if a key name is known/valid.
pub fn is_known_key(key: &str) -> bool {
    matches!(
        key,
        "a" | "b"
            | "c"
            | "d"
            | "e"
            | "f"
            | "g"
            | "h"
            | "i"
            | "j"
            | "k"
            | "l"
            | "m"
            | "n"
            | "o"
            | "p"
            | "q"
            | "r"
            | "s"
            | "t"
            | "u"
            | "v"
            | "w"
            | "x"
            | "y"
            | "z"
            | "0"
            | "1"
            | "2"
            | "3"
            | "4"
            | "5"
            | "6"
            | "7"
            | "8"
            | "9"
            | "f1"
            | "f2"
            | "f3"
            | "f4"
            | "f5"
            | "f6"
            | "f7"
            | "f8"
            | "f9"
            | "f10"
            | "f11"
            | "f12"
            | "f13"
            | "f14"
            | "f15"
            | "f16"
            | "f17"
            | "f18"
            | "f19"
            | "f20"
            | "f21"
            | "f22"
            | "f23"
            | "f24"
            | "space"
            | "enter"
            | "tab"
            | "escape"
            | "backspace"
            | "delete"
            | "up"
            | "down"
            | "left"
            | "right"
            | "home"
            | "end"
            | "pageup"
            | "pagedown"
            | "semicolon"
            | "quote"
            | "comma"
            | "period"
            | "slash"
            | "backslash"
            | "bracketleft"
            | "bracketright"
            | "minus"
            | "equal"
            | "backquote"
    )
}

</file>

<file path="src/theme/mod.rs">
//! Theme module - Color schemes and styling
//!
//! This module provides functionality for:
//! - Loading theme from ~/.scriptkit/kit/theme.json
//! - Color scheme definitions (dark/light mode)
//! - Focus-aware color variations
//! - Terminal ANSI color palette
//! - gpui-component theme integration
//! - Global theme service for multi-window theme sync
//!
//! # Module Structure
//!
//! - `hex_color` - Hex color parsing and serialization
//! - `types` - Theme struct definitions
//! - `helpers` - Lightweight color extraction for render closures
//! - `gpui_integration` - gpui-component theme mapping
//! - `service` - Global theme watcher service

mod gpui_integration;
mod helpers;
pub mod hex_color;
pub mod semantic;
pub mod service;
mod types;
pub mod validation;

#[cfg(test)]
#[path = "validation_tests.rs"]
mod validation_tests;

// Re-export types used externally
pub use types::{ColorScheme, Theme};

// Re-export semantic types (allow unused - designed for incremental adoption)
#[allow(unused_imports)]
pub use semantic::{FocusAware, SemanticColors, Surface, SurfaceStyle};

// Re-export validation types
#[allow(unused_imports)]
pub use validation::{validate_theme_json, Diagnostic, DiagnosticSeverity, ThemeDiagnostics};

// Re-export loader functions
pub use types::load_theme;

// Re-export gpui integration
pub use gpui_integration::sync_gpui_component_theme;

// Additional exports for tests
#[cfg(test)]
pub use hex_color::{hex_color_serde, HexColor};

#[cfg(test)]
#[allow(unused_imports)]
pub use types::{
    detect_system_appearance, BackgroundOpacity, BackgroundRole, DropShadow, FontConfig,
    VibrancyMaterial, VibrancySettings,
};

#[cfg(test)]
pub use helpers::{InputFieldColors, ListItemColors};

#[cfg(test)]
#[path = "theme_tests.rs"]
mod tests;

</file>

<file path="src/components/shortcut_recorder.rs">
//! Shortcut Recorder Component
//!
//! A modal overlay for recording keyboard shortcuts. Captures key combinations
//! and displays them using macOS-style symbols (⌘⇧K format).
//!
//! ## Features
//! - Captures modifier keys (Cmd, Ctrl, Alt, Shift) + a single key
//! - Displays shortcuts visually using symbols
//! - Shows conflict warnings when shortcuts are already assigned
//! - Clear, Cancel, and Save buttons
//!
//! ## Usage
//! ```rust,ignore
//! let recorder = ShortcutRecorder::new(focus_handle, theme)
//!     .with_command_name("My Script")
//!     .with_command_description("Does something useful")
//!     .on_save(|shortcut| { /* handle save */ })
//!     .on_cancel(|| { /* handle cancel */ });
//! ```

#![allow(dead_code)]

use crate::components::button::{Button, ButtonColors, ButtonVariant};
use crate::logging;
use crate::theme::Theme;
use gpui::{
    div, prelude::*, px, rgb, rgba, App, Context, FocusHandle, Focusable, IntoElement, Render,
    Window,
};
use std::sync::Arc;

/// Constants for shortcut recorder styling
const MODAL_WIDTH: f32 = 420.0;
const MODAL_PADDING: f32 = 24.0;
const KEY_DISPLAY_HEIGHT: f32 = 64.0;
const KEY_DISPLAY_PADDING: f32 = 16.0;
const KEYCAP_SIZE: f32 = 44.0;
const KEYCAP_GAP: f32 = 8.0;
const BUTTON_GAP: f32 = 12.0;

/// Pre-computed colors for ShortcutRecorder rendering
#[derive(Clone, Copy, Debug)]
pub struct ShortcutRecorderColors {
    /// Background color for the modal overlay
    pub overlay_bg: u32,
    /// Background color for the modal itself
    pub modal_bg: u32,
    /// Border color for the modal
    pub border: u32,
    /// Primary text color
    pub text_primary: u32,
    /// Secondary text color (for descriptions)
    pub text_secondary: u32,
    /// Muted text color (for hints)
    pub text_muted: u32,
    /// Accent color for highlights
    pub accent: u32,
    /// Warning color for conflicts
    pub warning: u32,
    /// Key display area background
    pub key_display_bg: u32,
    /// Keycap background color
    pub keycap_bg: u32,
    /// Keycap border color
    pub keycap_border: u32,
}

impl ShortcutRecorderColors {
    /// Create colors from theme reference
    pub fn from_theme(theme: &Theme) -> Self {
        Self {
            overlay_bg: 0x000000,
            modal_bg: theme.colors.background.main,
            border: theme.colors.ui.border,
            text_primary: theme.colors.text.primary,
            text_secondary: theme.colors.text.secondary,
            text_muted: theme.colors.text.muted,
            accent: theme.colors.accent.selected,
            warning: theme.colors.ui.warning,
            key_display_bg: theme.colors.background.search_box,
            keycap_bg: theme.colors.background.title_bar,
            keycap_border: theme.colors.ui.border,
        }
    }
}

impl Default for ShortcutRecorderColors {
    fn default() -> Self {
        Self {
            overlay_bg: 0x000000,
            modal_bg: 0x1e1e1e,
            border: 0x464647,
            text_primary: 0xffffff,
            text_secondary: 0xcccccc,
            text_muted: 0x808080,
            accent: 0xfbbf24,
            warning: 0xf59e0b,
            key_display_bg: 0x3c3c3c,
            keycap_bg: 0x2d2d30,
            keycap_border: 0x464647,
        }
    }
}

/// Represents a recorded keyboard shortcut
#[derive(Clone, Debug, Default, PartialEq)]
pub struct RecordedShortcut {
    /// Command key (macOS) / Super key
    pub cmd: bool,
    /// Control key
    pub ctrl: bool,
    /// Option/Alt key
    pub alt: bool,
    /// Shift key
    pub shift: bool,
    /// The actual key pressed (single character or key name)
    pub key: Option<String>,
}

impl RecordedShortcut {
    /// Create a new empty shortcut
    pub fn new() -> Self {
        Self::default()
    }

    /// Check if the shortcut has any content
    pub fn is_empty(&self) -> bool {
        !self.cmd && !self.ctrl && !self.alt && !self.shift && self.key.is_none()
    }

    /// Check if only modifiers are set (no key yet)
    pub fn has_only_modifiers(&self) -> bool {
        (self.cmd || self.ctrl || self.alt || self.shift) && self.key.is_none()
    }

    /// Check if the shortcut is complete (has modifiers + key)
    pub fn is_complete(&self) -> bool {
        (self.cmd || self.ctrl || self.alt || self.shift) && self.key.is_some()
    }

    /// Format as a display string using macOS symbols
    pub fn to_display_string(&self) -> String {
        let mut parts = Vec::new();

        if self.ctrl {
            parts.push("⌃");
        }
        if self.alt {
            parts.push("⌥");
        }
        if self.shift {
            parts.push("⇧");
        }
        if self.cmd {
            parts.push("⌘");
        }

        if let Some(ref key) = self.key {
            parts.push(key.as_str());
        }

        parts.join("")
    }

    /// Format as a config string (e.g., "cmd+shift+k")
    pub fn to_config_string(&self) -> String {
        let mut parts = Vec::new();

        if self.ctrl {
            parts.push("ctrl".to_string());
        }
        if self.alt {
            parts.push("alt".to_string());
        }
        if self.shift {
            parts.push("shift".to_string());
        }
        if self.cmd {
            parts.push("cmd".to_string());
        }

        if let Some(ref key) = self.key {
            parts.push(key.to_lowercase());
        }

        parts.join("+")
    }

    /// Get individual keycaps for display
    pub fn to_keycaps(&self) -> Vec<String> {
        let mut keycaps = Vec::new();

        if self.ctrl {
            keycaps.push("⌃".to_string());
        }
        if self.alt {
            keycaps.push("⌥".to_string());
        }
        if self.shift {
            keycaps.push("⇧".to_string());
        }
        if self.cmd {
            keycaps.push("⌘".to_string());
        }

        if let Some(ref key) = self.key {
            keycaps.push(Self::format_key_display(key));
        }

        keycaps
    }

    /// Format a key for display (uppercase letters, special key names)
    fn format_key_display(key: &str) -> String {
        match key.to_lowercase().as_str() {
            "enter" | "return" => "↵".to_string(),
            "escape" | "esc" => "⎋".to_string(),
            "tab" => "⇥".to_string(),
            "backspace" | "delete" => "⌫".to_string(),
            "space" => "␣".to_string(),
            "up" | "arrowup" => "↑".to_string(),
            "down" | "arrowdown" => "↓".to_string(),
            "left" | "arrowleft" => "←".to_string(),
            "right" | "arrowright" => "→".to_string(),
            _ => key.to_uppercase(),
        }
    }
}

/// Conflict information for a shortcut
#[derive(Clone, Debug)]
pub struct ShortcutConflict {
    /// Name of the command that has this shortcut
    pub command_name: String,
    /// The conflicting shortcut string
    pub shortcut: String,
}

/// Callback types for shortcut recorder
pub type OnSaveCallback = Box<dyn Fn(RecordedShortcut) + 'static>;
pub type OnCancelCallback = Box<dyn Fn() + 'static>;
pub type ConflictChecker = Box<dyn Fn(&RecordedShortcut) -> Option<ShortcutConflict> + 'static>;

/// Actions that can be triggered by the recorder
#[derive(Clone, Debug, PartialEq)]
pub enum RecorderAction {
    /// User wants to save the shortcut
    Save(RecordedShortcut),
    /// User wants to cancel
    Cancel,
}

/// Shortcut Recorder Modal Component
///
/// A modal dialog for recording keyboard shortcuts with visual feedback.
pub struct ShortcutRecorder {
    /// Focus handle for keyboard input
    pub focus_handle: FocusHandle,
    /// Theme for styling
    pub theme: Arc<Theme>,
    /// Pre-computed colors
    pub colors: ShortcutRecorderColors,
    /// Name of the command being configured
    pub command_name: Option<String>,
    /// Description of the command
    pub command_description: Option<String>,
    /// Currently recorded shortcut (final result with key)
    pub shortcut: RecordedShortcut,
    /// Currently held modifiers (for live display before final key)
    pub current_modifiers: gpui::Modifiers,
    /// Current conflict if any
    pub conflict: Option<ShortcutConflict>,
    /// Callback when save is pressed
    pub on_save: Option<OnSaveCallback>,
    /// Callback when cancel is pressed
    pub on_cancel: Option<OnCancelCallback>,
    /// Function to check for conflicts
    pub conflict_checker: Option<ConflictChecker>,
    /// Whether recording is active (listening for keys)
    pub is_recording: bool,
    /// Pending action for the parent to handle (polled after render)
    pub pending_action: Option<RecorderAction>,
}

impl ShortcutRecorder {
    /// Create a new shortcut recorder
    /// The focus_handle MUST be created from the entity's own context (cx.focus_handle())
    /// for keyboard events to work properly.
    pub fn new(cx: &mut Context<Self>, theme: Arc<Theme>) -> Self {
        let colors = ShortcutRecorderColors::from_theme(&theme);
        // Create focus handle from THIS entity's context - critical for keyboard events
        let focus_handle = cx.focus_handle();
        logging::log("SHORTCUT", "Created ShortcutRecorder with new focus handle");
        Self {
            focus_handle,
            theme,
            colors,
            command_name: None,
            command_description: None,
            shortcut: RecordedShortcut::new(),
            current_modifiers: gpui::Modifiers::default(),
            conflict: None,
            on_save: None,
            on_cancel: None,
            conflict_checker: None,
            is_recording: true,
            pending_action: None,
        }
    }

    /// Set the command name
    pub fn with_command_name(mut self, name: impl Into<String>) -> Self {
        self.command_name = Some(name.into());
        self
    }

    /// Set the command description
    pub fn with_command_description(mut self, description: impl Into<String>) -> Self {
        self.command_description = Some(description.into());
        self
    }

    /// Set the save callback
    pub fn on_save(mut self, callback: impl Fn(RecordedShortcut) + 'static) -> Self {
        self.on_save = Some(Box::new(callback));
        self
    }

    /// Set the cancel callback
    pub fn on_cancel(mut self, callback: impl Fn() + 'static) -> Self {
        self.on_cancel = Some(Box::new(callback));
        self
    }

    /// Set the conflict checker
    pub fn with_conflict_checker(
        mut self,
        checker: impl Fn(&RecordedShortcut) -> Option<ShortcutConflict> + 'static,
    ) -> Self {
        self.conflict_checker = Some(Box::new(checker));
        self
    }

    /// Set command name (mutable version)
    pub fn set_command_name(&mut self, name: Option<String>) {
        self.command_name = name;
    }

    /// Set command description (mutable version)
    pub fn set_command_description(&mut self, description: Option<String>) {
        self.command_description = description;
    }

    /// Clear the recorded shortcut
    pub fn clear(&mut self, cx: &mut Context<Self>) {
        self.shortcut = RecordedShortcut::new();
        self.conflict = None;
        self.is_recording = true;
        logging::log("SHORTCUT", "Shortcut cleared");
        cx.notify();
    }

    /// Handle save button press
    pub fn save(&mut self) {
        if self.shortcut.is_complete() && self.conflict.is_none() {
            logging::log(
                "SHORTCUT",
                &format!("Saving shortcut: {}", self.shortcut.to_config_string()),
            );
            // Set pending action for parent to poll
            self.pending_action = Some(RecorderAction::Save(self.shortcut.clone()));
            // Also call legacy callback if set
            if let Some(ref callback) = self.on_save {
                callback(self.shortcut.clone());
            }
        }
    }

    /// Handle cancel button press
    pub fn cancel(&mut self) {
        logging::log("SHORTCUT", "Shortcut recording cancelled");
        // Set pending action for parent to poll
        self.pending_action = Some(RecorderAction::Cancel);
        // Also call legacy callback if set
        if let Some(ref callback) = self.on_cancel {
            callback();
        }
    }

    /// Take the pending action (returns it and clears the field)
    pub fn take_pending_action(&mut self) -> Option<RecorderAction> {
        self.pending_action.take()
    }

    /// Handle a key down event
    pub fn handle_key_down(
        &mut self,
        key: &str,
        modifiers: gpui::Modifiers,
        cx: &mut Context<Self>,
    ) {
        if !self.is_recording {
            return;
        }

        // ALWAYS update current_modifiers for live display
        // This provides feedback even if on_modifiers_changed doesn't fire
        self.current_modifiers = modifiers;

        // Update shortcut modifiers
        self.shortcut.cmd = modifiers.platform;
        self.shortcut.ctrl = modifiers.control;
        self.shortcut.alt = modifiers.alt;
        self.shortcut.shift = modifiers.shift;

        // Check if this is a modifier-only key press
        let is_modifier_key = matches!(
            key.to_lowercase().as_str(),
            "shift"
                | "control"
                | "alt"
                | "meta"
                | "command"
                | "cmd"
                | "super"
                | "win"
                | "ctrl"
                | "opt"
                | "option"
        );

        if !is_modifier_key && !key.is_empty() {
            // Got a real key, record it
            self.shortcut.key = Some(key.to_uppercase());
            self.is_recording = false;

            logging::log(
                "SHORTCUT",
                &format!(
                    "Recorded shortcut: {} (config: {})",
                    self.shortcut.to_display_string(),
                    self.shortcut.to_config_string()
                ),
            );

            // Check for conflicts
            self.check_conflict();
        } else if is_modifier_key {
            // For modifier-only keypresses, log that we're showing live feedback
            logging::log(
                "SHORTCUT",
                &format!(
                    "Modifier key pressed (live feedback): key='{}' cmd={} ctrl={} alt={} shift={}",
                    key, modifiers.platform, modifiers.control, modifiers.alt, modifiers.shift
                ),
            );
        }

        cx.notify();
    }

    /// Handle escape key
    pub fn handle_escape(&mut self, cx: &mut Context<Self>) {
        if self.shortcut.is_empty() {
            // If nothing recorded, cancel
            self.cancel();
        } else {
            // Otherwise, clear the recording
            self.clear(cx);
        }
    }

    /// Check for shortcut conflicts
    fn check_conflict(&mut self) {
        if let Some(ref checker) = self.conflict_checker {
            self.conflict = checker(&self.shortcut);
            if let Some(ref conflict) = self.conflict {
                logging::log(
                    "SHORTCUT",
                    &format!(
                        "Conflict detected with '{}' (shortcut: {})",
                        conflict.command_name, conflict.shortcut
                    ),
                );
            }
        }
    }

    /// Update theme
    pub fn update_theme(&mut self, theme: Arc<Theme>) {
        self.colors = ShortcutRecorderColors::from_theme(&theme);
        self.theme = theme;
    }

    /// Render a single keycap
    fn render_keycap(&self, key: &str) -> impl IntoElement {
        let colors = self.colors;
        div()
            .w(px(KEYCAP_SIZE))
            .h(px(KEYCAP_SIZE))
            .flex()
            .items_center()
            .justify_center()
            .bg(rgba((colors.keycap_bg << 8) | 0xFF))
            .border_1()
            .border_color(rgba((colors.keycap_border << 8) | 0x80))
            .rounded(px(8.))
            .text_xl()
            .font_weight(gpui::FontWeight::MEDIUM)
            .text_color(rgb(colors.text_primary))
            .child(key.to_string())
    }

    /// Get keycaps for live display - shows current modifiers while recording,
    /// or the final recorded shortcut when complete
    fn get_display_keycaps(&self) -> Vec<String> {
        if self.shortcut.is_complete() {
            // Show the final recorded shortcut
            self.shortcut.to_keycaps()
        } else if self.is_recording {
            // Show currently held modifiers (live feedback)
            let mut keycaps = Vec::new();
            if self.current_modifiers.control {
                keycaps.push("⌃".to_string());
            }
            if self.current_modifiers.alt {
                keycaps.push("⌥".to_string());
            }
            if self.current_modifiers.shift {
                keycaps.push("⇧".to_string());
            }
            if self.current_modifiers.platform {
                keycaps.push("⌘".to_string());
            }
            keycaps
        } else {
            // Recording complete but no final key - show what we have
            self.shortcut.to_keycaps()
        }
    }

    /// Render the key display area
    fn render_key_display(&self) -> impl IntoElement {
        let colors = self.colors;
        let keycaps = self.get_display_keycaps();

        let mut key_row = div()
            .flex()
            .flex_row()
            .items_center()
            .justify_center()
            .gap(px(KEYCAP_GAP));

        if keycaps.is_empty() {
            // Show placeholder when nothing is pressed
            key_row = key_row.child(
                div()
                    .text_base()
                    .text_color(rgb(colors.text_muted))
                    .child("Press any key combination..."),
            );
        } else {
            // Show keycaps (either live modifiers or recorded shortcut)
            for keycap in keycaps {
                key_row = key_row.child(self.render_keycap(&keycap));
            }
        }

        div()
            .w_full()
            .h(px(KEY_DISPLAY_HEIGHT))
            .px(px(KEY_DISPLAY_PADDING))
            .flex()
            .items_center()
            .justify_center()
            .bg(rgba((colors.key_display_bg << 8) | 0x60))
            .rounded(px(8.))
            .border_1()
            .border_color(rgba((colors.border << 8) | 0x40))
            .child(key_row)
    }

    /// Render conflict warning if present
    fn render_conflict_warning(&self) -> impl IntoElement {
        let colors = self.colors;

        if let Some(ref conflict) = self.conflict {
            div()
                .w_full()
                .mt(px(12.))
                .px(px(12.))
                .py(px(8.))
                .bg(rgba((colors.warning << 8) | 0x20))
                .border_1()
                .border_color(rgba((colors.warning << 8) | 0x40))
                .rounded(px(6.))
                .flex()
                .flex_row()
                .items_center()
                .gap(px(8.))
                .child(div().text_sm().text_color(rgb(colors.warning)).child("⚠"))
                .child(
                    div()
                        .flex_1()
                        .text_sm()
                        .text_color(rgb(colors.text_secondary))
                        .child(format!("Already used by \"{}\"", conflict.command_name)),
                )
                .into_any_element()
        } else {
            div().into_any_element()
        }
    }
}

impl Focusable for ShortcutRecorder {
    fn focus_handle(&self, _cx: &App) -> FocusHandle {
        self.focus_handle.clone()
    }
}

impl Render for ShortcutRecorder {
    fn render(&mut self, _window: &mut Window, cx: &mut Context<Self>) -> impl IntoElement {
        let colors = self.colors;
        let button_colors = ButtonColors::from_theme(&self.theme);

        // Determine button states
        let can_save = self.shortcut.is_complete() && self.conflict.is_none();
        let can_clear = !self.shortcut.is_empty();

        // Build header with command info
        let header = div()
            .w_full()
            .flex()
            .flex_col()
            .gap(px(4.))
            .child(
                div()
                    .text_lg()
                    .font_weight(gpui::FontWeight::SEMIBOLD)
                    .text_color(rgb(colors.text_primary))
                    .child("Record Keyboard Shortcut"),
            )
            .when_some(self.command_name.clone(), |d, name| {
                d.child(
                    div()
                        .text_base()
                        .text_color(rgb(colors.text_secondary))
                        .child(format!("For: {}", name)),
                )
            })
            .when_some(self.command_description.clone(), |d, desc| {
                d.child(
                    div()
                        .text_sm()
                        .text_color(rgb(colors.text_muted))
                        .child(desc),
                )
            });

        // Build button row
        let clear_handler = cx.listener(|this, _: &gpui::ClickEvent, _window, cx| {
            this.clear(cx);
        });

        let cancel_handler = cx.listener(|this, _: &gpui::ClickEvent, _window, _cx| {
            this.cancel();
        });

        let save_handler = cx.listener(|this, _: &gpui::ClickEvent, _window, _cx| {
            this.save();
        });

        let buttons = div()
            .w_full()
            .mt(px(16.))
            .flex()
            .flex_row()
            .items_center()
            .justify_between()
            .child(
                // Left side: Clear button
                Button::new("Clear", button_colors)
                    .variant(ButtonVariant::Ghost)
                    .disabled(!can_clear)
                    .on_click(Box::new(move |event, window, cx| {
                        clear_handler(event, window, cx);
                    })),
            )
            .child(
                // Right side: Cancel and Save
                div()
                    .flex()
                    .flex_row()
                    .gap(px(BUTTON_GAP))
                    .child(
                        Button::new("Cancel", button_colors)
                            .variant(ButtonVariant::Ghost)
                            .shortcut("Esc")
                            .on_click(Box::new(move |event, window, cx| {
                                cancel_handler(event, window, cx);
                            })),
                    )
                    .child(
                        Button::new("Save", button_colors)
                            .variant(ButtonVariant::Primary)
                            .shortcut("↵")
                            .disabled(!can_save)
                            .on_click(Box::new(move |event, window, cx| {
                                save_handler(event, window, cx);
                            })),
                    ),
            );

        // Instructions
        let instructions = div()
            .w_full()
            .mt(px(12.))
            .text_xs()
            .text_color(rgb(colors.text_muted))
            .text_center()
            .child("Press a modifier (⌘⌃⌥⇧) + a key");

        // Key down event handler - captures modifiers and keys
        let handle_key_down = cx.listener(move |this, event: &gpui::KeyDownEvent, _window, cx| {
            let key = event.keystroke.key.as_str();
            let mods = event.keystroke.modifiers;

            logging::log(
                "SHORTCUT",
                &format!(
                    "KeyDown: key='{}' cmd={} ctrl={} alt={} shift={}",
                    key, mods.platform, mods.control, mods.alt, mods.shift
                ),
            );

            // Handle special keys
            match key.to_lowercase().as_str() {
                "escape" => {
                    this.handle_escape(cx);
                }
                "enter" if this.shortcut.is_complete() && this.conflict.is_none() => {
                    this.save();
                    cx.notify();
                }
                _ => {
                    this.handle_key_down(key, mods, cx);
                }
            }
        });

        // Modifiers changed handler - CRITICAL for live modifier feedback
        // This fires whenever ANY modifier key is pressed or released (e.g., pressing Cmd alone)
        let handle_modifiers_changed = cx.listener(
            move |this, event: &gpui::ModifiersChangedEvent, _window, cx| {
                // Only update if we're still recording (haven't captured a complete shortcut yet)
                if this.is_recording {
                    logging::log(
                        "SHORTCUT",
                        &format!(
                            "ModifiersChanged: cmd={} ctrl={} alt={} shift={}",
                            event.modifiers.platform,
                            event.modifiers.control,
                            event.modifiers.alt,
                            event.modifiers.shift
                        ),
                    );
                    // Update current modifiers for live display
                    this.current_modifiers = event.modifiers;
                    cx.notify(); // Trigger re-render to show keycaps
                }
            },
        );

        // Cancel handler for backdrop clicks
        let backdrop_cancel = cx.listener(|this, _: &gpui::ClickEvent, _window, _cx| {
            logging::log("SHORTCUT", "Backdrop clicked - cancelling");
            this.cancel();
        });

        // Modal content - with stop propagation to prevent backdrop dismiss
        let modal = div()
            .id("shortcut-modal-content")
            .w(px(MODAL_WIDTH))
            .p(px(MODAL_PADDING))
            .bg(rgba((colors.modal_bg << 8) | 0xF0))
            .border_1()
            .border_color(rgba((colors.border << 8) | 0x80))
            .rounded(px(12.))
            .flex()
            .flex_col()
            // Stop propagation - clicks inside modal shouldn't dismiss it
            .on_mouse_down(gpui::MouseButton::Left, |_, _, _| {
                // Empty handler stops propagation to backdrop
            })
            .child(header)
            .child(div().h(px(16.))) // Spacer
            .child(self.render_key_display())
            .child(self.render_conflict_warning())
            .child(instructions)
            .child(buttons);

        // Full-screen overlay with backdrop and centered modal
        // The overlay captures ALL keyboard and modifier events while open
        div()
            .id("shortcut-recorder-overlay")
            .absolute()
            .inset_0()
            .track_focus(&self.focus_handle)
            .on_key_down(handle_key_down)
            .on_modifiers_changed(handle_modifiers_changed) // CRITICAL: Live modifier feedback
            // Backdrop layer - semi-transparent, captures clicks to dismiss
            .child(
                div()
                    .id("shortcut-backdrop")
                    .absolute()
                    .inset_0()
                    .bg(rgba((colors.overlay_bg << 8) | 0x80)) // 50% opacity
                    .on_click(backdrop_cancel),
            )
            // Modal container - centered on top of backdrop
            .child(
                div()
                    .absolute()
                    .inset_0()
                    .flex()
                    .items_center()
                    .justify_center()
                    .child(modal),
            )
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_recorded_shortcut_to_display_string() {
        let mut shortcut = RecordedShortcut::new();
        shortcut.cmd = true;
        shortcut.shift = true;
        shortcut.key = Some("K".to_string());

        assert_eq!(shortcut.to_display_string(), "⇧⌘K");
    }

    #[test]
    fn test_recorded_shortcut_to_config_string() {
        let mut shortcut = RecordedShortcut::new();
        shortcut.cmd = true;
        shortcut.shift = true;
        shortcut.key = Some("K".to_string());

        assert_eq!(shortcut.to_config_string(), "shift+cmd+k");
    }

    #[test]
    fn test_recorded_shortcut_is_empty() {
        let shortcut = RecordedShortcut::new();
        assert!(shortcut.is_empty());

        let mut shortcut_with_mod = RecordedShortcut::new();
        shortcut_with_mod.cmd = true;
        assert!(!shortcut_with_mod.is_empty());
    }

    #[test]
    fn test_recorded_shortcut_is_complete() {
        let mut shortcut = RecordedShortcut::new();
        shortcut.cmd = true;
        assert!(!shortcut.is_complete()); // No key yet

        shortcut.key = Some("K".to_string());
        assert!(shortcut.is_complete()); // Has modifier + key
    }

    #[test]
    fn test_recorded_shortcut_to_keycaps() {
        let mut shortcut = RecordedShortcut::new();
        shortcut.ctrl = true;
        shortcut.alt = true;
        shortcut.shift = true;
        shortcut.cmd = true;
        shortcut.key = Some("K".to_string());

        let keycaps = shortcut.to_keycaps();
        assert_eq!(keycaps, vec!["⌃", "⌥", "⇧", "⌘", "K"]);
    }

    #[test]
    fn test_format_key_display_special_keys() {
        assert_eq!(RecordedShortcut::format_key_display("enter"), "↵");
        assert_eq!(RecordedShortcut::format_key_display("escape"), "⎋");
        assert_eq!(RecordedShortcut::format_key_display("tab"), "⇥");
        assert_eq!(RecordedShortcut::format_key_display("backspace"), "⌫");
        assert_eq!(RecordedShortcut::format_key_display("space"), "␣");
        assert_eq!(RecordedShortcut::format_key_display("up"), "↑");
        assert_eq!(RecordedShortcut::format_key_display("arrowdown"), "↓");
    }

    #[test]
    fn test_shortcut_recorder_colors_default() {
        let colors = ShortcutRecorderColors::default();
        assert_eq!(colors.accent, 0xfbbf24);
        assert_eq!(colors.warning, 0xf59e0b);
    }
}

</file>

<file path="src/app_actions.rs">
// Actions handling methods - extracted from app_impl.rs
// This file is included via include!() macro in main.rs
// Contains: handle_action, trigger_action_by_name

impl ScriptListApp {
    /// Helper to hide main window and set reset flag
    fn hide_main_and_reset(&self, cx: &mut Context<Self>) {
        set_main_window_visible(false);
        NEEDS_RESET.store(true, Ordering::SeqCst);
        cx.hide();
    }

    /// Helper to reveal a path in Finder (macOS)
    fn reveal_in_finder(&self, path: &std::path::Path) {
        let path_str = path.to_string_lossy().to_string();
        std::thread::spawn(move || {
            use std::process::Command;
            match Command::new("open").arg("-R").arg(&path_str).spawn() {
                Ok(_) => logging::log("UI", &format!("Revealed in Finder: {}", path_str)),
                Err(e) => logging::log("ERROR", &format!("Failed to reveal in Finder: {}", e)),
            }
        });
    }

    /// Copy text to clipboard using pbcopy on macOS.
    /// Critical: This properly closes stdin before waiting to prevent hangs.
    #[cfg(target_os = "macos")]
    fn pbcopy(&self, text: &str) -> Result<(), std::io::Error> {
        use std::io::Write;
        use std::process::{Command, Stdio};

        let mut child = Command::new("pbcopy").stdin(Stdio::piped()).spawn()?;

        // Take ownership of stdin, write, then drop to signal EOF
        if let Some(mut stdin) = child.stdin.take() {
            stdin.write_all(text.as_bytes())?;
            // stdin is dropped here => EOF delivered to pbcopy
        }

        // Now it's safe to wait - pbcopy has received EOF
        child.wait()?;
        Ok(())
    }

    /// Handle action selection from the actions dialog
    fn handle_action(&mut self, action_id: String, cx: &mut Context<Self>) {
        logging::log("UI", &format!("Action selected: {}", action_id));

        // Close the dialog and return to script list
        self.current_view = AppView::ScriptList;
        self.pending_focus = Some(FocusTarget::MainFilter);

        match action_id.as_str() {
            "create_script" => {
                logging::log("UI", "Create script action - opening scripts folder");
                let scripts_dir = shellexpand::tilde("~/.scriptkit/scripts").to_string();
                std::thread::spawn(move || {
                    use std::process::Command;
                    match Command::new("open").arg(&scripts_dir).spawn() {
                        Ok(_) => {
                            logging::log("UI", &format!("Opened scripts folder: {}", scripts_dir))
                        }
                        Err(e) => {
                            logging::log("ERROR", &format!("Failed to open scripts folder: {}", e))
                        }
                    }
                });
                self.last_output = Some(SharedString::from("Opened scripts folder"));
                self.hide_main_and_reset(cx);
            }
            "run_script" => {
                logging::log("UI", "Run script action");
                self.execute_selected(cx);
            }
            "view_logs" => {
                logging::log("UI", "View logs action");
                self.toggle_logs(cx);
            }
            "reveal_in_finder" => {
                logging::log("UI", "Reveal in Finder action");
                if let Some(result) = self.get_selected_result() {
                    let path_opt = match result {
                        scripts::SearchResult::Script(m) => Some(m.script.path.clone()),
                        scripts::SearchResult::App(m) => Some(m.app.path.clone()),
                        scripts::SearchResult::Agent(m) => Some(m.agent.path.clone()),
                        scripts::SearchResult::Scriptlet(_) => {
                            self.last_output =
                                Some(SharedString::from("Cannot reveal scriptlets in Finder"));
                            None
                        }
                        scripts::SearchResult::BuiltIn(_) => {
                            self.last_output =
                                Some(SharedString::from("Cannot reveal built-in features"));
                            None
                        }
                        scripts::SearchResult::Window(_) => {
                            self.last_output =
                                Some(SharedString::from("Cannot reveal windows in Finder"));
                            None
                        }
                        scripts::SearchResult::Fallback(_) => {
                            self.last_output = Some(SharedString::from(
                                "Cannot reveal fallback commands in Finder",
                            ));
                            None
                        }
                    };

                    if let Some(path) = path_opt {
                        self.reveal_in_finder(&path);
                        self.last_output = Some(SharedString::from("Revealed in Finder"));
                        self.hide_main_and_reset(cx);
                    }
                } else {
                    self.last_output = Some(SharedString::from("No item selected"));
                }
            }
            "copy_path" => {
                logging::log("UI", "Copy path action");
                if let Some(result) = self.get_selected_result() {
                    let path_opt = match result {
                        scripts::SearchResult::Script(m) => Some(m.script.path.clone()),
                        scripts::SearchResult::App(m) => Some(m.app.path.clone()),
                        scripts::SearchResult::Agent(m) => Some(m.agent.path.clone()),
                        scripts::SearchResult::Scriptlet(_) => {
                            self.last_output =
                                Some(SharedString::from("Cannot copy scriptlet path"));
                            None
                        }
                        scripts::SearchResult::BuiltIn(_) => {
                            self.last_output =
                                Some(SharedString::from("Cannot copy built-in path"));
                            None
                        }
                        scripts::SearchResult::Window(_) => {
                            self.last_output = Some(SharedString::from("Cannot copy window path"));
                            None
                        }
                        scripts::SearchResult::Fallback(_) => {
                            self.last_output =
                                Some(SharedString::from("Cannot copy fallback command path"));
                            None
                        }
                    };

                    if let Some(path) = path_opt {
                        let path_str = path.to_string_lossy().to_string();

                        #[cfg(target_os = "macos")]
                        {
                            match self.pbcopy(&path_str) {
                                Ok(_) => {
                                    logging::log(
                                        "UI",
                                        &format!("Copied path to clipboard: {}", path_str),
                                    );
                                    self.last_output =
                                        Some(SharedString::from(format!("Copied: {}", path_str)));
                                }
                                Err(e) => {
                                    logging::log("ERROR", &format!("pbcopy failed: {}", e));
                                    self.last_output =
                                        Some(SharedString::from("Failed to copy path"));
                                }
                            }
                        }

                        #[cfg(not(target_os = "macos"))]
                        {
                            use arboard::Clipboard;
                            match Clipboard::new().and_then(|mut c| c.set_text(&path_str)) {
                                Ok(_) => {
                                    logging::log(
                                        "UI",
                                        &format!("Copied path to clipboard: {}", path_str),
                                    );
                                    self.last_output =
                                        Some(SharedString::from(format!("Copied: {}", path_str)));
                                }
                                Err(e) => {
                                    logging::log("ERROR", &format!("Failed to copy path: {}", e));
                                    self.last_output =
                                        Some(SharedString::from("Failed to copy path"));
                                }
                            }
                        }
                    }
                } else {
                    self.last_output = Some(SharedString::from("No item selected"));
                }
            }
            // Handle both legacy "configure_shortcut" and new dynamic actions
            // "add_shortcut" and "update_shortcut" open the shortcut recorder
            "configure_shortcut" | "add_shortcut" | "update_shortcut" => {
                logging::log("UI", &format!("{} action", action_id));
                if let Some(result) = self.get_selected_result() {
                    match result {
                        // Scripts: open the script file to edit // Shortcut: comment
                        scripts::SearchResult::Script(m) => {
                            self.edit_script(&m.script.path);
                            self.hide_main_and_reset(cx);
                        }
                        scripts::SearchResult::Agent(m) => {
                            self.edit_script(&m.agent.path);
                            self.hide_main_and_reset(cx);
                        }
                        // Non-scripts: show inline shortcut recorder
                        scripts::SearchResult::Scriptlet(m) => {
                            let command_id = format!("scriptlet/{}", m.scriptlet.name);
                            let command_name = m.scriptlet.name.clone();
                            self.show_shortcut_recorder(command_id, command_name, cx);
                        }
                        scripts::SearchResult::BuiltIn(m) => {
                            let command_id = format!("builtin/{}", m.entry.id);
                            let command_name = m.entry.name.clone();
                            self.show_shortcut_recorder(command_id, command_name, cx);
                        }
                        scripts::SearchResult::App(m) => {
                            // Use bundle ID if available, otherwise use name
                            let command_id = if let Some(ref bundle_id) = m.app.bundle_id {
                                format!("app/{}", bundle_id)
                            } else {
                                format!("app/{}", m.app.name.to_lowercase().replace(' ', "-"))
                            };
                            let command_name = m.app.name.clone();
                            self.show_shortcut_recorder(command_id, command_name, cx);
                        }
                        scripts::SearchResult::Window(_) => {
                            self.last_output = Some(SharedString::from(
                                "Window shortcuts not supported - windows are transient",
                            ));
                        }
                        scripts::SearchResult::Fallback(m) => {
                            match &m.fallback {
                                crate::fallbacks::collector::FallbackItem::Builtin(b) => {
                                    let command_id = format!("fallback/{}", m.fallback.name());
                                    let command_name = b.name.to_string();
                                    self.show_shortcut_recorder(command_id, command_name, cx);
                                }
                                crate::fallbacks::collector::FallbackItem::Script(s) => {
                                    // Script-based fallback - open the script
                                    self.edit_script(&s.script.path);
                                    self.hide_main_and_reset(cx);
                                }
                            }
                        }
                    }
                } else {
                    self.last_output = Some(SharedString::from("No item selected"));
                }
            }
            // "remove_shortcut" removes the existing shortcut from the registry
            "remove_shortcut" => {
                logging::log("UI", "Remove shortcut action");
                if let Some(result) = self.get_selected_result() {
                    let command_id_opt = match result {
                        scripts::SearchResult::Script(m) => {
                            Some(format!("script/{}", m.script.name))
                        }
                        scripts::SearchResult::Scriptlet(m) => {
                            Some(format!("scriptlet/{}", m.scriptlet.name))
                        }
                        scripts::SearchResult::BuiltIn(m) => {
                            Some(format!("builtin/{}", m.entry.id))
                        }
                        scripts::SearchResult::App(m) => {
                            if let Some(ref bundle_id) = m.app.bundle_id {
                                Some(format!("app/{}", bundle_id))
                            } else {
                                Some(format!(
                                    "app/{}",
                                    m.app.name.to_lowercase().replace(' ', "-")
                                ))
                            }
                        }
                        scripts::SearchResult::Agent(m) => Some(format!("agent/{}", m.agent.name)),
                        scripts::SearchResult::Window(_) => {
                            self.last_output =
                                Some(SharedString::from("Window shortcuts not supported"));
                            None
                        }
                        scripts::SearchResult::Fallback(m) => {
                            Some(format!("fallback/{}", m.fallback.name()))
                        }
                    };

                    if let Some(command_id) = command_id_opt {
                        // Remove the shortcut override from persistence
                        match crate::shortcuts::remove_shortcut_override(&command_id) {
                            Ok(()) => {
                                logging::log(
                                    "SHORTCUT",
                                    &format!("Removed shortcut for: {}", command_id),
                                );
                                self.last_output = Some(SharedString::from("Shortcut removed"));
                                // Refresh scripts to update shortcut display
                                self.refresh_scripts(cx);
                            }
                            Err(e) => {
                                logging::log("ERROR", &format!("Failed to remove shortcut: {}", e));
                                self.last_output = Some(SharedString::from(format!(
                                    "Failed to remove shortcut: {}",
                                    e
                                )));
                            }
                        }
                    }
                    self.hide_main_and_reset(cx);
                } else {
                    self.last_output = Some(SharedString::from("No item selected"));
                }
            }
            "edit_script" => {
                logging::log("UI", "Edit script action");
                if let Some(result) = self.get_selected_result() {
                    let path_opt = match result {
                        scripts::SearchResult::Script(m) => Some(m.script.path.clone()),
                        scripts::SearchResult::Agent(m) => Some(m.agent.path.clone()),
                        scripts::SearchResult::Scriptlet(_) => {
                            self.last_output = Some(SharedString::from("Cannot edit scriptlets"));
                            None
                        }
                        scripts::SearchResult::BuiltIn(_) => {
                            self.last_output =
                                Some(SharedString::from("Cannot edit built-in features"));
                            None
                        }
                        scripts::SearchResult::App(_) => {
                            self.last_output = Some(SharedString::from("Cannot edit applications"));
                            None
                        }
                        scripts::SearchResult::Window(_) => {
                            self.last_output = Some(SharedString::from("Cannot edit windows"));
                            None
                        }
                        scripts::SearchResult::Fallback(_) => {
                            self.last_output =
                                Some(SharedString::from("Cannot edit fallback commands"));
                            None
                        }
                    };

                    if let Some(path) = path_opt {
                        self.edit_script(&path);
                        self.hide_main_and_reset(cx);
                    }
                } else {
                    self.last_output = Some(SharedString::from("No script selected"));
                }
            }
            "reload_scripts" => {
                logging::log("UI", "Reload scripts action");
                self.refresh_scripts(cx);
                self.last_output = Some(SharedString::from("Scripts reloaded"));
            }
            "settings" => {
                logging::log("UI", "Settings action");
                self.last_output = Some(SharedString::from("Settings (TODO)"));
            }
            "quit" => {
                logging::log("UI", "Quit action");
                PROCESS_MANAGER.kill_all_processes();
                PROCESS_MANAGER.remove_main_pid();
                cx.quit();
                return; // Early return after quit - no notify needed
            }
            "__cancel__" => {
                logging::log("UI", "Actions dialog cancelled");
                // Clear file search actions path on cancel
                self.file_search_actions_path = None;
            }
            // File search specific actions
            "open_file" | "open_directory" => {
                if let Some(ref path) = self.file_search_actions_path {
                    logging::log("UI", &format!("Opening file: {}", path));
                    let _ = crate::file_search::open_file(path);
                    self.file_search_actions_path = None;
                    self.close_and_reset_window(cx);
                }
            }
            "quick_look" => {
                if let Some(ref path) = self.file_search_actions_path {
                    logging::log("UI", &format!("Quick Look: {}", path));
                    let _ = crate::file_search::quick_look(path);
                    self.file_search_actions_path = None;
                    // Don't close window for Quick Look - user may want to continue
                }
            }
            "open_with" => {
                if let Some(ref path) = self.file_search_actions_path {
                    logging::log("UI", &format!("Open With: {}", path));
                    let _ = crate::file_search::open_with(path);
                    self.file_search_actions_path = None;
                }
            }
            "show_info" => {
                if let Some(ref path) = self.file_search_actions_path {
                    logging::log("UI", &format!("Show Info: {}", path));
                    let _ = crate::file_search::show_info(path);
                    self.file_search_actions_path = None;
                }
            }
            "copy_filename" => {
                if let Some(ref path) = self.file_search_actions_path {
                    let filename = std::path::Path::new(path)
                        .file_name()
                        .and_then(|n| n.to_str())
                        .unwrap_or("");
                    logging::log("UI", &format!("Copy filename: {}", filename));
                    #[cfg(target_os = "macos")]
                    {
                        let _ = self.pbcopy(filename);
                    }
                    #[cfg(not(target_os = "macos"))]
                    {
                        use arboard::Clipboard;
                        let _ = Clipboard::new().and_then(|mut c| c.set_text(filename));
                    }
                    self.last_output = Some(SharedString::from(format!("Copied: {}", filename)));
                    self.file_search_actions_path = None;
                }
            }
            _ => {
                // Check if this is a file search action with reveal_in_finder or copy_path
                // (these actions exist both for scripts and file search)
                if let Some(path) = self.file_search_actions_path.clone() {
                    match action_id.as_str() {
                        "reveal_in_finder" => {
                            logging::log(
                                "UI",
                                &format!("Reveal in Finder (file search): {}", path),
                            );
                            self.reveal_in_finder(std::path::Path::new(&path));
                            self.file_search_actions_path = None;
                            cx.notify();
                            return;
                        }
                        "copy_path" => {
                            logging::log("UI", &format!("Copy path (file search): {}", path));
                            #[cfg(target_os = "macos")]
                            {
                                let _ = self.pbcopy(&path);
                            }
                            #[cfg(not(target_os = "macos"))]
                            {
                                use arboard::Clipboard;
                                let _ = Clipboard::new().and_then(|mut c| c.set_text(&path));
                            }
                            self.last_output =
                                Some(SharedString::from(format!("Copied: {}", path)));
                            self.file_search_actions_path = None;
                            cx.notify();
                            return;
                        }
                        _ => {}
                    }
                }
                // Handle SDK actions using shared helper
                self.trigger_sdk_action_internal(&action_id);
            }
        }

        cx.notify();
    }

    /// Internal helper for triggering SDK actions - used by both handle_action and trigger_action_by_name
    fn trigger_sdk_action_internal(&mut self, action_name: &str) {
        if let Some(ref actions) = self.sdk_actions {
            if let Some(action) = actions.iter().find(|a| a.name == action_name) {
                let send_result = if action.has_action {
                    logging::log(
                        "ACTIONS",
                        &format!(
                            "SDK action with handler: '{}' (has_action=true), sending ActionTriggered",
                            action_name
                        ),
                    );
                    if let Some(ref sender) = self.response_sender {
                        let msg = protocol::Message::action_triggered(
                            action_name.to_string(),
                            action.value.clone(),
                            self.arg_input.text().to_string(),
                        );
                        Some(sender.try_send(msg))
                    } else {
                        None
                    }
                } else if let Some(ref value) = action.value {
                    logging::log(
                        "ACTIONS",
                        &format!(
                            "SDK action without handler: '{}' (has_action=false), submitting value: {:?}",
                            action_name, value
                        ),
                    );
                    if let Some(ref sender) = self.response_sender {
                        let msg = protocol::Message::Submit {
                            id: "action".to_string(),
                            value: Some(value.clone()),
                        };
                        Some(sender.try_send(msg))
                    } else {
                        None
                    }
                } else {
                    logging::log(
                        "ACTIONS",
                        &format!(
                            "SDK action '{}' has no value and has_action=false",
                            action_name
                        ),
                    );
                    None
                };

                // Log any send errors
                if let Some(result) = send_result {
                    match result {
                        Ok(()) => {}
                        Err(std::sync::mpsc::TrySendError::Full(_)) => {
                            logging::log(
                                "WARN",
                                &format!(
                                    "Response channel full - action '{}' dropped",
                                    action_name
                                ),
                            );
                        }
                        Err(std::sync::mpsc::TrySendError::Disconnected(_)) => {
                            logging::log("UI", "Response channel disconnected - script exited");
                        }
                    }
                }
            } else {
                logging::log("UI", &format!("Unknown action: {}", action_name));
            }
        } else {
            logging::log("UI", &format!("Unknown action: {}", action_name));
        }
    }

    /// Trigger an SDK action by name
    /// Returns true if the action was found and triggered
    fn trigger_action_by_name(&mut self, action_name: &str, cx: &mut Context<Self>) -> bool {
        if let Some(ref actions) = self.sdk_actions {
            if actions.iter().any(|a| a.name == action_name) {
                logging::log(
                    "ACTIONS",
                    &format!("Triggering SDK action '{}' via shortcut", action_name),
                );
                self.trigger_sdk_action_internal(action_name);
                cx.notify();
                return true;
            }
        }
        false
    }
}

</file>

<file path="src/hotkeys.rs">
use global_hotkey::{
    hotkey::{Code, HotKey, Modifiers},
    Error as HotkeyError, GlobalHotKeyEvent, GlobalHotKeyManager, HotKeyState,
};
use std::collections::HashMap;
use std::sync::atomic::{AtomicBool, AtomicU64, Ordering};
use std::sync::{Mutex, OnceLock, RwLock};

use crate::{config, logging, scripts, shortcuts};

// =============================================================================
// Unified Hotkey Routing System
// =============================================================================
// All hotkey events (main, notes, ai, scripts) are dispatched through a single
// routing table. This ensures:
// 1. Consistent dispatch behavior for all hotkey types
// 2. Proper hot-reload support (routing and registration are coupled)
// 3. No lost hotkeys on failed registration (transactional updates)

/// Action to take when a hotkey is pressed
#[derive(Clone, Debug, PartialEq)]
pub enum HotkeyAction {
    /// Main launcher hotkey
    Main,
    /// Notes window hotkey
    Notes,
    /// AI window hotkey
    Ai,
    /// Script shortcut - run the script at this path
    Script(String),
}

/// Registered hotkey entry with all needed data for unregistration/updates
#[derive(Clone)]
struct RegisteredHotkey {
    /// The HotKey object (needed for unregister)
    hotkey: HotKey,
    /// What action to take on press
    action: HotkeyAction,
    /// Display string for logging (e.g., "cmd+shift+k")
    display: String,
}

/// Unified routing table for all hotkeys
/// Uses RwLock for fast reads (event dispatch) with occasional writes (updates)
struct HotkeyRoutes {
    /// Maps hotkey ID -> registered hotkey entry
    routes: HashMap<u32, RegisteredHotkey>,
    /// Reverse lookup: script path -> hotkey ID (for script updates)
    script_paths: HashMap<String, u32>,
    /// Current main hotkey ID (for quick lookup)
    main_id: Option<u32>,
    /// Current notes hotkey ID (for quick lookup)
    notes_id: Option<u32>,
    /// Current AI hotkey ID (for quick lookup)
    ai_id: Option<u32>,
}

impl HotkeyRoutes {
    fn new() -> Self {
        Self {
            routes: HashMap::new(),
            script_paths: HashMap::new(),
            main_id: None,
            notes_id: None,
            ai_id: None,
        }
    }

    /// Get the action for a hotkey ID
    fn get_action(&self, id: u32) -> Option<HotkeyAction> {
        self.routes.get(&id).map(|r| r.action.clone())
    }

    /// Add a route (internal - doesn't register with OS)
    fn add_route(&mut self, id: u32, entry: RegisteredHotkey) {
        match &entry.action {
            HotkeyAction::Main => self.main_id = Some(id),
            HotkeyAction::Notes => self.notes_id = Some(id),
            HotkeyAction::Ai => self.ai_id = Some(id),
            HotkeyAction::Script(path) => {
                self.script_paths.insert(path.clone(), id);
            }
        }
        self.routes.insert(id, entry);
    }

    /// Remove a route by ID (internal - doesn't unregister from OS)
    fn remove_route(&mut self, id: u32) -> Option<RegisteredHotkey> {
        if let Some(entry) = self.routes.remove(&id) {
            match &entry.action {
                HotkeyAction::Main => {
                    if self.main_id == Some(id) {
                        self.main_id = None;
                    }
                }
                HotkeyAction::Notes => {
                    if self.notes_id == Some(id) {
                        self.notes_id = None;
                    }
                }
                HotkeyAction::Ai => {
                    if self.ai_id == Some(id) {
                        self.ai_id = None;
                    }
                }
                HotkeyAction::Script(path) => {
                    self.script_paths.remove(path);
                }
            }
            Some(entry)
        } else {
            None
        }
    }

    /// Get script hotkey ID by path
    fn get_script_id(&self, path: &str) -> Option<u32> {
        self.script_paths.get(path).copied()
    }

    /// Get the hotkey entry for an action type
    #[allow(dead_code)]
    fn get_builtin_entry(&self, action: &HotkeyAction) -> Option<&RegisteredHotkey> {
        let id = match action {
            HotkeyAction::Main => self.main_id?,
            HotkeyAction::Notes => self.notes_id?,
            HotkeyAction::Ai => self.ai_id?,
            HotkeyAction::Script(path) => *self.script_paths.get(path)?,
        };
        self.routes.get(&id)
    }
}

/// Global routing table - protected by RwLock for fast reads
static HOTKEY_ROUTES: OnceLock<RwLock<HotkeyRoutes>> = OnceLock::new();

fn routes() -> &'static RwLock<HotkeyRoutes> {
    HOTKEY_ROUTES.get_or_init(|| RwLock::new(HotkeyRoutes::new()))
}

/// The main GlobalHotKeyManager - stored globally so update_hotkeys can access it
static MAIN_MANAGER: OnceLock<Mutex<GlobalHotKeyManager>> = OnceLock::new();

/// Parse a HotkeyConfig into (Modifiers, Code)
fn parse_hotkey_config(hk: &config::HotkeyConfig) -> Option<(Modifiers, Code)> {
    let code = match hk.key.as_str() {
        "Semicolon" => Code::Semicolon,
        "KeyK" => Code::KeyK,
        "KeyP" => Code::KeyP,
        "Space" => Code::Space,
        "Enter" => Code::Enter,
        "Digit0" => Code::Digit0,
        "Digit1" => Code::Digit1,
        "Digit2" => Code::Digit2,
        "Digit3" => Code::Digit3,
        "Digit4" => Code::Digit4,
        "Digit5" => Code::Digit5,
        "Digit6" => Code::Digit6,
        "Digit7" => Code::Digit7,
        "Digit8" => Code::Digit8,
        "Digit9" => Code::Digit9,
        "KeyA" => Code::KeyA,
        "KeyB" => Code::KeyB,
        "KeyC" => Code::KeyC,
        "KeyD" => Code::KeyD,
        "KeyE" => Code::KeyE,
        "KeyF" => Code::KeyF,
        "KeyG" => Code::KeyG,
        "KeyH" => Code::KeyH,
        "KeyI" => Code::KeyI,
        "KeyJ" => Code::KeyJ,
        "KeyL" => Code::KeyL,
        "KeyM" => Code::KeyM,
        "KeyN" => Code::KeyN,
        "KeyO" => Code::KeyO,
        "KeyQ" => Code::KeyQ,
        "KeyR" => Code::KeyR,
        "KeyS" => Code::KeyS,
        "KeyT" => Code::KeyT,
        "KeyU" => Code::KeyU,
        "KeyV" => Code::KeyV,
        "KeyW" => Code::KeyW,
        "KeyX" => Code::KeyX,
        "KeyY" => Code::KeyY,
        "KeyZ" => Code::KeyZ,
        "F1" => Code::F1,
        "F2" => Code::F2,
        "F3" => Code::F3,
        "F4" => Code::F4,
        "F5" => Code::F5,
        "F6" => Code::F6,
        "F7" => Code::F7,
        "F8" => Code::F8,
        "F9" => Code::F9,
        "F10" => Code::F10,
        "F11" => Code::F11,
        "F12" => Code::F12,
        _ => return None,
    };

    let mut modifiers = Modifiers::empty();
    for modifier in &hk.modifiers {
        match modifier.as_str() {
            "meta" => modifiers |= Modifiers::META,
            "ctrl" => modifiers |= Modifiers::CONTROL,
            "alt" => modifiers |= Modifiers::ALT,
            "shift" => modifiers |= Modifiers::SHIFT,
            _ => {}
        }
    }

    Some((modifiers, code))
}

/// Convert a HotkeyConfig to a display string (e.g., "meta+shift+N")
fn hotkey_config_to_display(hk: &config::HotkeyConfig) -> String {
    format!(
        "{}{}{}",
        hk.modifiers.join("+"),
        if hk.modifiers.is_empty() { "" } else { "+" },
        hk.key
    )
}

/// Transactional hotkey rebind: register new BEFORE unregistering old
/// This prevents losing a working hotkey if the new registration fails
fn rebind_hotkey_transactional(
    manager: &GlobalHotKeyManager,
    action: HotkeyAction,
    mods: Modifiers,
    code: Code,
    display: &str,
) -> bool {
    let new_hotkey = HotKey::new(Some(mods), code);
    let new_id = new_hotkey.id();

    // Check if already registered with same ID (no change needed)
    let current_id = {
        let routes_guard = routes().read().unwrap();
        match &action {
            HotkeyAction::Main => routes_guard.main_id,
            HotkeyAction::Notes => routes_guard.notes_id,
            HotkeyAction::Ai => routes_guard.ai_id,
            HotkeyAction::Script(path) => routes_guard.get_script_id(path),
        }
    };

    if current_id == Some(new_id) {
        return true; // No change needed
    }

    // TRANSACTIONAL: Register new FIRST, before unregistering old
    // This ensures we never lose a working hotkey on registration failure
    if let Err(e) = manager.register(new_hotkey) {
        logging::log(
            "HOTKEY",
            &format!("Failed to register {}: {} - keeping existing", display, e),
        );
        return false;
    }

    // New registration succeeded - now safe to update routing and unregister old
    let old_entry = {
        let mut routes_guard = routes().write().unwrap();

        // Get old entry before adding new (they might have same action type)
        let old_id = match &action {
            HotkeyAction::Main => routes_guard.main_id,
            HotkeyAction::Notes => routes_guard.notes_id,
            HotkeyAction::Ai => routes_guard.ai_id,
            HotkeyAction::Script(path) => routes_guard.get_script_id(path),
        };
        let old_entry = old_id.and_then(|id| routes_guard.remove_route(id));

        // Add new route
        routes_guard.add_route(
            new_id,
            RegisteredHotkey {
                hotkey: new_hotkey,
                action: action.clone(),
                display: display.to_string(),
            },
        );

        old_entry
    };

    // Unregister old hotkey (best-effort - it's already removed from routing)
    if let Some(old) = old_entry {
        if let Err(e) = manager.unregister(old.hotkey) {
            logging::log(
                "HOTKEY",
                &format!(
                    "Warning: failed to unregister old {} hotkey: {}",
                    old.display, e
                ),
            );
            // Continue anyway - new hotkey is working
        }
    }

    logging::log(
        "HOTKEY",
        &format!(
            "Hot-reloaded {:?} hotkey: {} (id: {})",
            action, display, new_id
        ),
    );
    true
}

/// Update hotkeys from config - call this when config changes
/// Uses transactional updates: register new before unregistering old
pub fn update_hotkeys(cfg: &config::Config) {
    let manager_guard = match MAIN_MANAGER.get() {
        Some(m) => match m.lock() {
            Ok(g) => g,
            Err(e) => {
                logging::log("HOTKEY", &format!("Failed to lock manager: {}", e));
                return;
            }
        },
        None => {
            logging::log("HOTKEY", "Manager not initialized - hotkeys not updated");
            return;
        }
    };

    // Update main hotkey
    let main_config = &cfg.hotkey;
    if let Some((mods, code)) = parse_hotkey_config(main_config) {
        let display = hotkey_config_to_display(main_config);
        let success =
            rebind_hotkey_transactional(&manager_guard, HotkeyAction::Main, mods, code, &display);
        MAIN_HOTKEY_REGISTERED.store(success, Ordering::Relaxed);
    }

    // Update notes hotkey
    let notes_config = cfg.get_notes_hotkey();
    if let Some((mods, code)) = parse_hotkey_config(&notes_config) {
        let display = hotkey_config_to_display(&notes_config);
        rebind_hotkey_transactional(&manager_guard, HotkeyAction::Notes, mods, code, &display);
    }

    // Update AI hotkey
    let ai_config = cfg.get_ai_hotkey();
    if let Some((mods, code)) = parse_hotkey_config(&ai_config) {
        let display = hotkey_config_to_display(&ai_config);
        rebind_hotkey_transactional(&manager_guard, HotkeyAction::Ai, mods, code, &display);
    }
}

// =============================================================================
// Dynamic Script Hotkey Manager
// =============================================================================

/// Manages dynamic registration/unregistration of script hotkeys.
/// Uses a thread-safe global singleton pattern for access from multiple contexts.
pub struct ScriptHotkeyManager {
    /// The underlying global hotkey manager
    manager: GlobalHotKeyManager,
    /// Maps hotkey ID -> script path
    hotkey_map: HashMap<u32, String>,
    /// Maps script path -> hotkey ID (reverse lookup for unregistration)
    path_to_id: HashMap<String, u32>,
    /// Maps script path -> HotKey object (needed for proper unregistration)
    path_to_hotkey: HashMap<String, HotKey>,
}

impl ScriptHotkeyManager {
    /// Create a new ScriptHotkeyManager.
    /// NOTE: Must be created on the main thread.
    fn new(manager: GlobalHotKeyManager) -> Self {
        Self {
            manager,
            hotkey_map: HashMap::new(),
            path_to_id: HashMap::new(),
            path_to_hotkey: HashMap::new(),
        }
    }

    /// Register a hotkey for a script.
    /// Returns the hotkey ID on success.
    pub fn register(&mut self, path: &str, shortcut: &str) -> anyhow::Result<u32> {
        // Parse the shortcut
        let (mods, code) = shortcuts::parse_shortcut(shortcut)
            .ok_or_else(|| anyhow::anyhow!("Failed to parse shortcut: {}", shortcut))?;

        let hotkey = HotKey::new(Some(mods), code);
        let hotkey_id = hotkey.id();

        // Register with the OS - provide specific error messages based on error type
        if let Err(e) = self.manager.register(hotkey) {
            return Err(match e {
                HotkeyError::AlreadyRegistered(hk) => {
                    anyhow::anyhow!(
                        "Hotkey '{}' is already registered (conflict with another app or script). Hotkey ID: {}",
                        shortcut,
                        hk.id()
                    )
                }
                HotkeyError::FailedToRegister(msg) => {
                    anyhow::anyhow!(
                        "System rejected hotkey '{}': {}. This may be reserved by macOS or another app.",
                        shortcut,
                        msg
                    )
                }
                HotkeyError::OsError(os_err) => {
                    anyhow::anyhow!("OS error registering hotkey '{}': {}", shortcut, os_err)
                }
                other => {
                    anyhow::anyhow!("Failed to register hotkey '{}': {}", shortcut, other)
                }
            });
        }

        // Track the mapping
        self.hotkey_map.insert(hotkey_id, path.to_string());
        self.path_to_id.insert(path.to_string(), hotkey_id);
        self.path_to_hotkey.insert(path.to_string(), hotkey);

        logging::log(
            "HOTKEY",
            &format!(
                "Registered script hotkey '{}' for {} (id: {})",
                shortcut, path, hotkey_id
            ),
        );

        Ok(hotkey_id)
    }

    /// Unregister a hotkey for a script by path.
    /// Returns Ok(()) even if the path wasn't registered (no-op).
    pub fn unregister(&mut self, path: &str) -> anyhow::Result<()> {
        if let Some(hotkey_id) = self.path_to_id.remove(path) {
            // Remove from hotkey_map
            self.hotkey_map.remove(&hotkey_id);

            // Unregister from OS using stored HotKey object
            if let Some(hotkey) = self.path_to_hotkey.remove(path) {
                if let Err(e) = self.manager.unregister(hotkey) {
                    logging::log(
                        "HOTKEY",
                        &format!(
                            "Warning: Failed to unregister hotkey for {} (id: {}): {}",
                            path, hotkey_id, e
                        ),
                    );
                    // Continue anyway - the internal tracking is already updated
                }
            }

            logging::log(
                "HOTKEY",
                &format!(
                    "Unregistered script hotkey for {} (id: {})",
                    path, hotkey_id
                ),
            );
        }
        // If path wasn't registered, this is a no-op (success)
        Ok(())
    }

    /// Update a script's hotkey.
    /// Handles add (old=None, new=Some), remove (old=Some, new=None), and change (both Some).
    pub fn update(
        &mut self,
        path: &str,
        old_shortcut: Option<&str>,
        new_shortcut: Option<&str>,
    ) -> anyhow::Result<()> {
        match (old_shortcut, new_shortcut) {
            (None, None) => {
                // No change needed
                Ok(())
            }
            (None, Some(new)) => {
                // Add new hotkey
                self.register(path, new)?;
                Ok(())
            }
            (Some(_old), None) => {
                // Remove old hotkey
                self.unregister(path)
            }
            (Some(_old), Some(new)) => {
                // Change: unregister old, register new
                self.unregister(path)?;
                self.register(path, new)?;
                Ok(())
            }
        }
    }

    /// Get the script path for a given hotkey ID.
    pub fn get_script_path(&self, hotkey_id: u32) -> Option<&String> {
        self.hotkey_map.get(&hotkey_id)
    }

    /// Get all registered hotkeys as (path, hotkey_id) pairs.
    pub fn get_registered_hotkeys(&self) -> Vec<(String, u32)> {
        self.path_to_id
            .iter()
            .map(|(path, id)| (path.clone(), *id))
            .collect()
    }

    /// Check if a script has a registered hotkey.
    #[allow(dead_code)]
    pub fn is_registered(&self, path: &str) -> bool {
        self.path_to_id.contains_key(path)
    }
}

/// Global singleton for the ScriptHotkeyManager.
/// Initialized when start_hotkey_listener is called.
static SCRIPT_HOTKEY_MANAGER: OnceLock<Mutex<ScriptHotkeyManager>> = OnceLock::new();

/// Initialize the global ScriptHotkeyManager.
/// Must be called from the main thread.
/// Returns an error if already initialized.
#[allow(dead_code)]
pub fn init_script_hotkey_manager(manager: GlobalHotKeyManager) -> anyhow::Result<()> {
    SCRIPT_HOTKEY_MANAGER
        .set(Mutex::new(ScriptHotkeyManager::new(manager)))
        .map_err(|_| anyhow::anyhow!("ScriptHotkeyManager already initialized"))
}

/// Register a script hotkey dynamically.
/// Returns the hotkey ID on success.
pub fn register_script_hotkey(path: &str, shortcut: &str) -> anyhow::Result<u32> {
    let manager = SCRIPT_HOTKEY_MANAGER
        .get()
        .ok_or_else(|| anyhow::anyhow!("ScriptHotkeyManager not initialized"))?;

    let mut guard = manager
        .lock()
        .map_err(|e| anyhow::anyhow!("Lock poisoned: {}", e))?;
    guard.register(path, shortcut)
}

/// Unregister a script hotkey by path.
/// Returns Ok(()) even if the path wasn't registered (no-op).
pub fn unregister_script_hotkey(path: &str) -> anyhow::Result<()> {
    let manager = SCRIPT_HOTKEY_MANAGER
        .get()
        .ok_or_else(|| anyhow::anyhow!("ScriptHotkeyManager not initialized"))?;

    let mut guard = manager
        .lock()
        .map_err(|e| anyhow::anyhow!("Lock poisoned: {}", e))?;
    guard.unregister(path)
}

/// Update a script's hotkey.
/// Handles add (old=None, new=Some), remove (old=Some, new=None), and change (both Some).
pub fn update_script_hotkey(
    path: &str,
    old_shortcut: Option<&str>,
    new_shortcut: Option<&str>,
) -> anyhow::Result<()> {
    let manager = SCRIPT_HOTKEY_MANAGER
        .get()
        .ok_or_else(|| anyhow::anyhow!("ScriptHotkeyManager not initialized"))?;

    let mut guard = manager
        .lock()
        .map_err(|e| anyhow::anyhow!("Lock poisoned: {}", e))?;
    guard.update(path, old_shortcut, new_shortcut)
}

/// Get the script path for a given hotkey ID.
#[allow(dead_code)]
pub fn get_script_for_hotkey(hotkey_id: u32) -> Option<String> {
    let manager = SCRIPT_HOTKEY_MANAGER.get()?;
    let guard = manager.lock().ok()?;
    guard.get_script_path(hotkey_id).cloned()
}

/// Get all registered script hotkeys.
#[allow(dead_code)]
pub fn get_registered_hotkeys() -> Vec<(String, u32)> {
    SCRIPT_HOTKEY_MANAGER
        .get()
        .and_then(|m| m.lock().ok())
        .map(|guard| guard.get_registered_hotkeys())
        .unwrap_or_default()
}

// =============================================================================
// Dynamic shortcut registration (for shortcuts.json overrides)
// =============================================================================

/// Register a shortcut dynamically for a command (scriptlet, builtin, app).
/// This adds the shortcut to the unified routing table and registers with the OS.
///
/// # Arguments
/// * `command_id` - Unique identifier (e.g., "scriptlet/my-scriptlet", "builtin/ai-chat")
/// * `shortcut` - Shortcut string (e.g., "cmd+shift+k")
/// * `display_name` - Human-readable name for logging
///
/// # Returns
/// The hotkey ID on success, or an error if registration fails.
pub fn register_dynamic_shortcut(
    command_id: &str,
    shortcut: &str,
    display_name: &str,
) -> anyhow::Result<u32> {
    let manager = MAIN_MANAGER
        .get()
        .ok_or_else(|| anyhow::anyhow!("Hotkey manager not initialized"))?;

    let manager_guard = manager
        .lock()
        .map_err(|e| anyhow::anyhow!("Lock poisoned: {}", e))?;

    let (mods, code) = shortcuts::parse_shortcut(shortcut)
        .ok_or_else(|| anyhow::anyhow!("Failed to parse shortcut: {}", shortcut))?;

    let hotkey = HotKey::new(Some(mods), code);
    let id = hotkey.id();

    // Check if already registered
    {
        let routes_guard = routes().read().unwrap();
        if routes_guard.get_action(id).is_some() {
            return Err(anyhow::anyhow!(
                "Shortcut '{}' is already registered",
                shortcut
            ));
        }
    }

    // Register with OS
    manager_guard
        .register(hotkey)
        .map_err(|e| anyhow::anyhow!("Failed to register hotkey '{}': {}", shortcut, e))?;

    // Add to routing table
    {
        let mut routes_guard = routes().write().unwrap();
        routes_guard.add_route(
            id,
            RegisteredHotkey {
                hotkey,
                action: HotkeyAction::Script(command_id.to_string()),
                display: shortcut.to_string(),
            },
        );
    }

    logging::log(
        "HOTKEY",
        &format!(
            "Registered dynamic shortcut '{}' for {} (id: {})",
            shortcut, display_name, id
        ),
    );

    Ok(id)
}

/// Unregister a dynamic shortcut by command_id.
/// Returns Ok(()) even if the shortcut wasn't registered (no-op).
#[allow(dead_code)]
pub fn unregister_dynamic_shortcut(command_id: &str) -> anyhow::Result<()> {
    let manager = MAIN_MANAGER
        .get()
        .ok_or_else(|| anyhow::anyhow!("Hotkey manager not initialized"))?;

    let manager_guard = manager
        .lock()
        .map_err(|e| anyhow::anyhow!("Lock poisoned: {}", e))?;

    // Find the hotkey ID for this command
    let (id, hotkey) = {
        let routes_guard = routes().read().unwrap();
        routes_guard
            .get_script_id(command_id)
            .and_then(|id| routes_guard.routes.get(&id).map(|entry| (id, entry.hotkey)))
    }
    .ok_or_else(|| anyhow::anyhow!("No shortcut registered for {}", command_id))?;

    // Unregister from OS
    if let Err(e) = manager_guard.unregister(hotkey) {
        logging::log(
            "HOTKEY",
            &format!(
                "Warning: Failed to unregister hotkey for {}: {}",
                command_id, e
            ),
        );
    }

    // Remove from routing table
    {
        let mut routes_guard = routes().write().unwrap();
        routes_guard.remove_route(id);
    }

    logging::log(
        "HOTKEY",
        &format!(
            "Unregistered dynamic shortcut for {} (id: {})",
            command_id, id
        ),
    );

    Ok(())
}

// =============================================================================
// GCD dispatch for immediate main-thread execution (bypasses async runtime)
// =============================================================================

use std::sync::Arc;

/// Callback type for hotkey actions - uses Arc<dyn Fn()> for repeated invocation
pub type HotkeyHandler = Arc<dyn Fn() + Send + Sync>;

/// Static storage for handlers to be invoked on main thread
static NOTES_HANDLER: OnceLock<std::sync::Mutex<Option<HotkeyHandler>>> = OnceLock::new();
static AI_HANDLER: OnceLock<std::sync::Mutex<Option<HotkeyHandler>>> = OnceLock::new();

/// Register a handler to be invoked when the Notes hotkey is pressed.
/// This handler will be executed on the main thread via GCD dispatch_async.
/// The handler can be called multiple times (it's not consumed).
#[allow(dead_code)]
pub fn set_notes_hotkey_handler<F: Fn() + Send + Sync + 'static>(handler: F) {
    let storage = NOTES_HANDLER.get_or_init(|| std::sync::Mutex::new(None));
    *storage.lock().unwrap() = Some(Arc::new(handler));
}

/// Register a handler to be invoked when the AI hotkey is pressed.
/// This handler will be executed on the main thread via GCD dispatch_async.
/// The handler can be called multiple times (it's not consumed).
#[allow(dead_code)]
pub fn set_ai_hotkey_handler<F: Fn() + Send + Sync + 'static>(handler: F) {
    let storage = AI_HANDLER.get_or_init(|| std::sync::Mutex::new(None));
    *storage.lock().unwrap() = Some(Arc::new(handler));
}

#[cfg(target_os = "macos")]
mod gcd {
    use std::ffi::c_void;
    use std::panic::{catch_unwind, AssertUnwindSafe};

    // Link to libSystem for GCD functions
    // Note: dispatch_get_main_queue is actually a macro that returns &_dispatch_main_q
    // We use the raw symbol directly instead
    #[link(name = "System", kind = "framework")]
    extern "C" {
        fn dispatch_async_f(
            queue: *const c_void,
            context: *mut c_void,
            work: extern "C" fn(*mut c_void),
        );
        // The main dispatch queue is a global static symbol, not a function
        #[link_name = "_dispatch_main_q"]
        static DISPATCH_MAIN_QUEUE: c_void;
    }

    /// Dispatch a closure to the main thread via GCD.
    /// This is the key to making hotkeys work before the GPUI event loop is "warmed up".
    ///
    /// SAFETY: The trampoline uses catch_unwind to prevent panics from unwinding
    /// across the FFI boundary, which would be undefined behavior.
    pub fn dispatch_to_main<F: FnOnce() + Send + 'static>(f: F) {
        let boxed: Box<dyn FnOnce() + Send> = Box::new(f);
        let raw = Box::into_raw(Box::new(boxed));

        extern "C" fn trampoline(context: *mut c_void) {
            unsafe {
                let boxed: Box<Box<dyn FnOnce() + Send>> = Box::from_raw(context as *mut _);
                // CRITICAL: Catch panics to prevent UB from unwinding across FFI boundary
                let result = catch_unwind(AssertUnwindSafe(|| {
                    boxed();
                }));
                if let Err(e) = result {
                    // Log the panic but don't propagate it across FFI
                    let msg = if let Some(s) = e.downcast_ref::<&str>() {
                        s.to_string()
                    } else if let Some(s) = e.downcast_ref::<String>() {
                        s.clone()
                    } else {
                        "unknown panic".to_string()
                    };
                    eprintln!("[HOTKEY] PANIC in GCD dispatch: {}", msg);
                }
            }
        }

        unsafe {
            let main_queue = &DISPATCH_MAIN_QUEUE as *const c_void;
            dispatch_async_f(main_queue, raw as *mut c_void, trampoline);
        }
    }
}

#[cfg(not(target_os = "macos"))]
mod gcd {
    /// Fallback for non-macOS: just call the closure directly (in the current thread)
    pub fn dispatch_to_main<F: FnOnce() + Send + 'static>(f: F) {
        f();
    }
}

/// Dispatch the Notes hotkey handler to the main thread.
///
/// Strategy (mutually exclusive to prevent double-fire):
/// - If a handler is registered: use it directly via GCD dispatch
/// - Otherwise: send to channel for async polling
///
/// This works even before the main window is activated because GCD dispatch
/// directly integrates with the NSApplication run loop that GPUI uses.
fn dispatch_notes_hotkey() {
    // Check if a direct handler is registered (takes priority over channel)
    let handler = NOTES_HANDLER
        .get_or_init(|| std::sync::Mutex::new(None))
        .lock()
        .unwrap()
        .clone();

    if let Some(handler) = handler {
        // Handler is set - use direct GCD dispatch (skip channel to avoid double-fire)
        gcd::dispatch_to_main(move || {
            handler();
        });
    } else {
        // No handler - use channel approach for async polling
        if notes_hotkey_channel().0.try_send(()).is_err() {
            logging::log("HOTKEY", "Notes hotkey channel full/closed");
        }
        // Dispatch an empty closure to wake GPUI's event loop
        // This ensures the channel message gets processed even if GPUI was idle
        gcd::dispatch_to_main(|| {
            // Empty closure - just wakes the run loop
        });
    }
}

/// Dispatch the AI hotkey handler to the main thread.
///
/// Strategy (mutually exclusive to prevent double-fire):
/// - If a handler is registered: use it directly via GCD dispatch
/// - Otherwise: send to channel for async polling
fn dispatch_ai_hotkey() {
    // Check if a direct handler is registered (takes priority over channel)
    let handler = AI_HANDLER
        .get_or_init(|| std::sync::Mutex::new(None))
        .lock()
        .unwrap()
        .clone();

    if let Some(handler) = handler {
        // Handler is set - use direct GCD dispatch (skip channel to avoid double-fire)
        gcd::dispatch_to_main(move || {
            handler();
        });
    } else {
        // No handler - use channel approach for async polling
        if ai_hotkey_channel().0.try_send(()).is_err() {
            logging::log("HOTKEY", "AI hotkey channel full/closed");
        }
        // Dispatch an empty closure to wake GPUI's event loop
        gcd::dispatch_to_main(|| {
            // Empty closure - just wakes the run loop
        });
    }
}

// HOTKEY_CHANNEL: Event-driven async_channel for hotkey events (replaces AtomicBool polling)
#[allow(dead_code)]
static HOTKEY_CHANNEL: OnceLock<(async_channel::Sender<()>, async_channel::Receiver<()>)> =
    OnceLock::new();

/// Get the hotkey channel, initializing it on first access.
#[allow(dead_code)]
pub(crate) fn hotkey_channel() -> &'static (async_channel::Sender<()>, async_channel::Receiver<()>)
{
    HOTKEY_CHANNEL.get_or_init(|| async_channel::bounded(10))
}

// SCRIPT_HOTKEY_CHANNEL: Channel for script shortcut events (sends script path)
#[allow(dead_code)]
static SCRIPT_HOTKEY_CHANNEL: OnceLock<(
    async_channel::Sender<String>,
    async_channel::Receiver<String>,
)> = OnceLock::new();

/// Get the script hotkey channel, initializing it on first access.
#[allow(dead_code)]
pub(crate) fn script_hotkey_channel() -> &'static (
    async_channel::Sender<String>,
    async_channel::Receiver<String>,
) {
    SCRIPT_HOTKEY_CHANNEL.get_or_init(|| async_channel::bounded(10))
}

// NOTES_HOTKEY_CHANNEL: Channel for notes hotkey events
#[allow(dead_code)]
static NOTES_HOTKEY_CHANNEL: OnceLock<(async_channel::Sender<()>, async_channel::Receiver<()>)> =
    OnceLock::new();

/// Get the notes hotkey channel, initializing it on first access.
#[allow(dead_code)]
pub(crate) fn notes_hotkey_channel(
) -> &'static (async_channel::Sender<()>, async_channel::Receiver<()>) {
    NOTES_HOTKEY_CHANNEL.get_or_init(|| async_channel::bounded(10))
}

// AI_HOTKEY_CHANNEL: Channel for AI hotkey events
#[allow(dead_code)]
static AI_HOTKEY_CHANNEL: OnceLock<(async_channel::Sender<()>, async_channel::Receiver<()>)> =
    OnceLock::new();

/// Get the AI hotkey channel, initializing it on first access.
#[allow(dead_code)]
pub(crate) fn ai_hotkey_channel(
) -> &'static (async_channel::Sender<()>, async_channel::Receiver<()>) {
    AI_HOTKEY_CHANNEL.get_or_init(|| async_channel::bounded(10))
}

/// Tracks whether the main hotkey was successfully registered
/// Used by main.rs to detect if the app has an alternate entry point
static MAIN_HOTKEY_REGISTERED: AtomicBool = AtomicBool::new(false);

/// Check if the main hotkey was successfully registered
pub fn is_main_hotkey_registered() -> bool {
    MAIN_HOTKEY_REGISTERED.load(Ordering::Relaxed)
}

#[allow(dead_code)]
static HOTKEY_TRIGGER_COUNT: AtomicU64 = AtomicU64::new(0);

/// Format a hotkey registration error with helpful context
fn format_hotkey_error(e: &HotkeyError, shortcut_display: &str) -> String {
    match e {
        HotkeyError::AlreadyRegistered(hk) => {
            format!(
                "Hotkey '{}' is already registered by another application or script (ID: {}). \
                 Try a different shortcut or close the conflicting app.",
                shortcut_display,
                hk.id()
            )
        }
        HotkeyError::FailedToRegister(msg) => {
            format!(
                "System rejected hotkey '{}': {}. This shortcut may be reserved by macOS.",
                shortcut_display, msg
            )
        }
        HotkeyError::OsError(os_err) => {
            format!(
                "OS error registering '{}': {}. Check system hotkey settings.",
                shortcut_display, os_err
            )
        }
        other => format!(
            "Failed to register hotkey '{}': {}",
            shortcut_display, other
        ),
    }
}

/// Register a builtin hotkey (main/notes/ai) and add to unified routing table
fn register_builtin_hotkey(
    manager: &GlobalHotKeyManager,
    action: HotkeyAction,
    cfg: &config::HotkeyConfig,
) -> Option<u32> {
    let (mods, code) = parse_hotkey_config(cfg)?;
    let hotkey = HotKey::new(Some(mods), code);
    let id = hotkey.id();
    let display = hotkey_config_to_display(cfg);

    match manager.register(hotkey) {
        Ok(()) => {
            let mut routes_guard = routes().write().unwrap();
            routes_guard.add_route(
                id,
                RegisteredHotkey {
                    hotkey,
                    action: action.clone(),
                    display: display.clone(),
                },
            );
            logging::log(
                "HOTKEY",
                &format!("Registered {:?} hotkey {} (id: {})", action, display, id),
            );
            Some(id)
        }
        Err(e) => {
            logging::log("HOTKEY", &format_hotkey_error(&e, &display));
            None
        }
    }
}

/// Register a script hotkey and add to unified routing table
fn register_script_hotkey_internal(
    manager: &GlobalHotKeyManager,
    path: &str,
    shortcut: &str,
    name: &str,
) -> Option<u32> {
    let (mods, code) = shortcuts::parse_shortcut(shortcut)?;
    let hotkey = HotKey::new(Some(mods), code);
    let id = hotkey.id();

    match manager.register(hotkey) {
        Ok(()) => {
            let mut routes_guard = routes().write().unwrap();
            routes_guard.add_route(
                id,
                RegisteredHotkey {
                    hotkey,
                    action: HotkeyAction::Script(path.to_string()),
                    display: shortcut.to_string(),
                },
            );
            logging::log(
                "HOTKEY",
                &format!(
                    "Registered script shortcut '{}' for {} (id: {})",
                    shortcut, name, id
                ),
            );
            Some(id)
        }
        Err(e) => {
            logging::log(
                "HOTKEY",
                &format!("{} (script: {})", format_hotkey_error(&e, shortcut), name),
            );
            None
        }
    }
}

#[allow(dead_code)]
pub(crate) fn start_hotkey_listener(config: config::Config) {
    std::thread::spawn(move || {
        let manager = match GlobalHotKeyManager::new() {
            Ok(m) => m,
            Err(e) => {
                logging::log("HOTKEY", &format!("Failed to create hotkey manager: {}", e));
                return;
            }
        };

        if MAIN_MANAGER.set(Mutex::new(manager)).is_err() {
            logging::log("HOTKEY", "Manager already initialized (unexpected)");
            return;
        }

        let manager_guard = match MAIN_MANAGER.get().unwrap().lock() {
            Ok(g) => g,
            Err(e) => {
                logging::log("HOTKEY", &format!("Failed to lock manager: {}", e));
                return;
            }
        };

        // Register main hotkey using unified registration
        if register_builtin_hotkey(&manager_guard, HotkeyAction::Main, &config.hotkey).is_some() {
            MAIN_HOTKEY_REGISTERED.store(true, Ordering::Relaxed);
        }

        // Register notes and AI hotkeys
        register_builtin_hotkey(
            &manager_guard,
            HotkeyAction::Notes,
            &config.get_notes_hotkey(),
        );
        register_builtin_hotkey(&manager_guard, HotkeyAction::Ai, &config.get_ai_hotkey());

        // Register script shortcuts
        let mut script_count = 0;

        let all_scripts = scripts::read_scripts();
        for script in &all_scripts {
            if let Some(ref shortcut) = script.shortcut {
                let path = script.path.to_string_lossy().to_string();
                if register_script_hotkey_internal(&manager_guard, &path, shortcut, &script.name)
                    .is_some()
                {
                    script_count += 1;
                }
            }
        }

        let all_scriptlets = scripts::load_scriptlets();
        for scriptlet in &all_scriptlets {
            if let Some(ref shortcut) = scriptlet.shortcut {
                let path = scriptlet
                    .file_path
                    .clone()
                    .unwrap_or_else(|| scriptlet.name.clone());
                if register_script_hotkey_internal(&manager_guard, &path, shortcut, &scriptlet.name)
                    .is_some()
                {
                    script_count += 1;
                }
            }
        }

        logging::log(
            "HOTKEY",
            &format!("Registered {} script/scriptlet shortcuts", script_count),
        );

        // Track which command IDs have been registered to avoid duplicates
        let mut registered_commands: std::collections::HashSet<String> =
            std::collections::HashSet::new();

        // Priority 1: Load shortcuts from config.ts commands field (highest priority)
        let mut config_count = 0;
        if let Some(commands) = &config.commands {
            for (command_id, cmd_config) in commands {
                if let Some(hotkey_config) = &cmd_config.shortcut {
                    let shortcut_str = hotkey_config.to_shortcut_string();
                    if register_script_hotkey_internal(
                        &manager_guard,
                        command_id,
                        &shortcut_str,
                        command_id,
                    )
                    .is_some()
                    {
                        registered_commands.insert(command_id.clone());
                        config_count += 1;
                    }
                }
            }
            if config_count > 0 {
                logging::log(
                    "HOTKEY",
                    &format!(
                        "Registered {} command shortcuts from config.ts",
                        config_count
                    ),
                );
            }
        }

        // Priority 2: Load user shortcut overrides from shortcuts.json
        // (skips commands already registered from config.ts)
        let mut override_count = 0;
        match crate::shortcuts::load_shortcut_overrides() {
            Ok(overrides) => {
                for (command_id, shortcut) in overrides {
                    // Skip if already registered from config.ts
                    if registered_commands.contains(&command_id) {
                        logging::log(
                            "HOTKEY",
                            &format!(
                                "Skipping shortcuts.json entry for '{}' (config.ts takes priority)",
                                command_id
                            ),
                        );
                        continue;
                    }

                    let shortcut_str = shortcut.to_canonical_string();
                    if register_script_hotkey_internal(
                        &manager_guard,
                        &command_id,
                        &shortcut_str,
                        &command_id,
                    )
                    .is_some()
                    {
                        override_count += 1;
                    }
                }
                if override_count > 0 {
                    logging::log(
                        "HOTKEY",
                        &format!(
                            "Registered {} user shortcut overrides from shortcuts.json",
                            override_count
                        ),
                    );
                }
            }
            Err(e) => {
                logging::log("HOTKEY", &format!("Failed to load shortcuts.json: {}", e));
            }
        }

        // Log routing table summary
        {
            let routes_guard = routes().read().unwrap();
            logging::log(
                "HOTKEY",
                &format!(
                    "Routing table: main={:?}, notes={:?}, ai={:?}, scripts={}",
                    routes_guard.main_id,
                    routes_guard.notes_id,
                    routes_guard.ai_id,
                    routes_guard.script_paths.len()
                ),
            );
        }

        drop(manager_guard);
        let receiver = GlobalHotKeyEvent::receiver();

        loop {
            if let Ok(event) = receiver.recv() {
                if event.state != HotKeyState::Pressed {
                    continue;
                }

                // Look up action in unified routing table (fast read lock)
                let action = {
                    let routes_guard = routes().read().unwrap();
                    routes_guard.get_action(event.id)
                };

                match action {
                    Some(HotkeyAction::Main) => {
                        let count = HOTKEY_TRIGGER_COUNT.fetch_add(1, Ordering::Relaxed);
                        // NON-BLOCKING: Use try_send to prevent hotkey thread from blocking
                        if hotkey_channel().0.try_send(()).is_err() {
                            logging::log("HOTKEY", "Main hotkey channel full/closed");
                        }
                        logging::log(
                            "HOTKEY",
                            &format!("Main hotkey pressed (trigger #{})", count + 1),
                        );
                    }
                    Some(HotkeyAction::Notes) => {
                        logging::log(
                            "HOTKEY",
                            "Notes hotkey pressed - dispatching to main thread",
                        );
                        dispatch_notes_hotkey();
                    }
                    Some(HotkeyAction::Ai) => {
                        logging::log("HOTKEY", "AI hotkey pressed - dispatching to main thread");
                        dispatch_ai_hotkey();
                    }
                    Some(HotkeyAction::Script(path)) => {
                        logging::log("HOTKEY", &format!("Script shortcut triggered: {}", path));
                        // NON-BLOCKING: Use try_send to prevent hotkey thread from blocking
                        if script_hotkey_channel().0.try_send(path.clone()).is_err() {
                            logging::log(
                                "HOTKEY",
                                &format!("Script channel full/closed for {}", path),
                            );
                        }
                    }
                    None => {
                        // Unknown hotkey ID - can happen during hot-reload transitions
                        logging::log("HOTKEY", &format!("Unknown hotkey event id={}", event.id));
                    }
                }
            }
        }
    });
}

#[cfg(test)]
mod tests {
    use super::*;
    use async_channel::TryRecvError;

    // =============================================================================
    // Unified Routing Table Tests
    // =============================================================================
    mod routing_table_tests {
        use super::*;

        #[test]
        fn test_hotkey_routes_new() {
            let routes = HotkeyRoutes::new();
            assert!(routes.routes.is_empty());
            assert!(routes.script_paths.is_empty());
            assert!(routes.main_id.is_none());
            assert!(routes.notes_id.is_none());
            assert!(routes.ai_id.is_none());
        }

        #[test]
        fn test_add_main_route() {
            let mut routes = HotkeyRoutes::new();
            let hotkey = HotKey::new(Some(Modifiers::META), Code::Semicolon);
            let entry = RegisteredHotkey {
                hotkey,
                action: HotkeyAction::Main,
                display: "cmd+;".to_string(),
            };
            routes.add_route(hotkey.id(), entry);

            assert_eq!(routes.main_id, Some(hotkey.id()));
            assert!(routes.routes.contains_key(&hotkey.id()));
            assert_eq!(routes.get_action(hotkey.id()), Some(HotkeyAction::Main));
        }

        #[test]
        fn test_add_script_route() {
            let mut routes = HotkeyRoutes::new();
            let hotkey = HotKey::new(Some(Modifiers::META | Modifiers::SHIFT), Code::KeyT);
            let path = "/test/script.ts".to_string();
            let entry = RegisteredHotkey {
                hotkey,
                action: HotkeyAction::Script(path.clone()),
                display: "cmd+shift+t".to_string(),
            };
            routes.add_route(hotkey.id(), entry);

            assert_eq!(routes.script_paths.get(&path), Some(&hotkey.id()));
            assert_eq!(routes.get_script_id(&path), Some(hotkey.id()));
            assert_eq!(
                routes.get_action(hotkey.id()),
                Some(HotkeyAction::Script(path))
            );
        }

        #[test]
        fn test_remove_route() {
            let mut routes = HotkeyRoutes::new();
            let hotkey = HotKey::new(Some(Modifiers::META), Code::KeyN);
            let entry = RegisteredHotkey {
                hotkey,
                action: HotkeyAction::Notes,
                display: "cmd+n".to_string(),
            };
            routes.add_route(hotkey.id(), entry);
            assert!(routes.notes_id.is_some());

            let removed = routes.remove_route(hotkey.id());
            assert!(removed.is_some());
            assert!(routes.notes_id.is_none());
            assert!(routes.get_action(hotkey.id()).is_none());
        }

        #[test]
        fn test_remove_script_route() {
            let mut routes = HotkeyRoutes::new();
            let hotkey = HotKey::new(Some(Modifiers::META), Code::KeyS);
            let path = "/test/script.ts".to_string();
            let entry = RegisteredHotkey {
                hotkey,
                action: HotkeyAction::Script(path.clone()),
                display: "cmd+s".to_string(),
            };
            routes.add_route(hotkey.id(), entry);
            assert!(routes.script_paths.contains_key(&path));

            routes.remove_route(hotkey.id());
            assert!(!routes.script_paths.contains_key(&path));
        }

        #[test]
        fn test_hotkey_action_equality() {
            assert_eq!(HotkeyAction::Main, HotkeyAction::Main);
            assert_eq!(HotkeyAction::Notes, HotkeyAction::Notes);
            assert_eq!(HotkeyAction::Ai, HotkeyAction::Ai);
            assert_eq!(
                HotkeyAction::Script("/a.ts".to_string()),
                HotkeyAction::Script("/a.ts".to_string())
            );
            assert_ne!(HotkeyAction::Main, HotkeyAction::Notes);
            assert_ne!(
                HotkeyAction::Script("/a.ts".to_string()),
                HotkeyAction::Script("/b.ts".to_string())
            );
        }
    }

    #[test]
    fn hotkey_channels_are_independent() {
        while hotkey_channel().1.try_recv().is_ok() {}
        while script_hotkey_channel().1.try_recv().is_ok() {}

        hotkey_channel().0.send_blocking(()).expect("send hotkey");
        assert!(matches!(
            script_hotkey_channel().1.try_recv(),
            Err(TryRecvError::Empty)
        ));
        assert!(hotkey_channel().1.try_recv().is_ok());

        script_hotkey_channel()
            .0
            .send_blocking("script".to_string())
            .expect("send script hotkey");
        assert_eq!(
            script_hotkey_channel()
                .1
                .try_recv()
                .expect("recv script hotkey"),
            "script"
        );
    }

    // =============================================================================
    // ScriptHotkeyManager Unit Tests
    // =============================================================================
    // Note: These tests cannot actually register system hotkeys in the test environment
    // because GlobalHotKeyManager requires a running event loop and proper OS permissions.
    // Instead, we test the logic of the manager's internal tracking.

    mod script_hotkey_manager_tests {
        use super::*;

        /// Helper to create a manager for testing.
        /// Note: Registration will fail without an event loop, but we can test tracking logic.
        fn create_test_manager() -> Option<ScriptHotkeyManager> {
            // GlobalHotKeyManager::new() may fail in test environment
            GlobalHotKeyManager::new()
                .ok()
                .map(ScriptHotkeyManager::new)
        }

        #[test]
        fn test_manager_creation() {
            // Just verify we can create the struct (manager creation may fail in CI)
            if let Some(manager) = create_test_manager() {
                assert!(manager.hotkey_map.is_empty());
                assert!(manager.path_to_id.is_empty());
            }
        }

        #[test]
        fn test_get_registered_hotkeys_empty() {
            if let Some(manager) = create_test_manager() {
                assert!(manager.get_registered_hotkeys().is_empty());
            }
        }

        #[test]
        fn test_is_registered_false_for_unknown_path() {
            if let Some(manager) = create_test_manager() {
                assert!(!manager.is_registered("/some/unknown/path.ts"));
            }
        }

        #[test]
        fn test_unregister_nonexistent_is_noop() {
            if let Some(mut manager) = create_test_manager() {
                // Should not error when unregistering a path that was never registered
                let result = manager.unregister("/nonexistent/path.ts");
                assert!(result.is_ok());
            }
        }

        #[test]
        fn test_update_none_to_none_is_noop() {
            if let Some(mut manager) = create_test_manager() {
                // No old, no new -> no-op, should succeed
                let result = manager.update("/some/path.ts", None, None);
                assert!(result.is_ok());
            }
        }

        // Note: The following tests would require a working GlobalHotKeyManager
        // which may not be available in all test environments.
        // In a real CI environment, these would be integration tests.

        #[test]
        fn test_register_tracks_mapping() {
            if let Some(mut manager) = create_test_manager() {
                // Try to register - this may fail in test environment, that's OK
                let result = manager.register("/test/script.ts", "cmd+shift+t");
                if result.is_ok() {
                    // If registration succeeded, verify tracking
                    assert!(manager.is_registered("/test/script.ts"));
                    let hotkeys = manager.get_registered_hotkeys();
                    assert_eq!(hotkeys.len(), 1);
                    assert_eq!(hotkeys[0].0, "/test/script.ts");
                }
                // If it failed (no event loop), that's expected in test env
            }
        }

        #[test]
        fn test_unregister_removes_tracking() {
            if let Some(mut manager) = create_test_manager() {
                // Try to register first
                if manager.register("/test/script.ts", "cmd+shift+u").is_ok() {
                    assert!(manager.is_registered("/test/script.ts"));

                    // Now unregister
                    let result = manager.unregister("/test/script.ts");
                    assert!(result.is_ok());
                    assert!(!manager.is_registered("/test/script.ts"));
                }
            }
        }

        #[test]
        fn test_update_add_hotkey() {
            if let Some(mut manager) = create_test_manager() {
                // None -> Some = add
                let result = manager.update("/test/add.ts", None, Some("cmd+shift+a"));
                if result.is_ok() {
                    assert!(manager.is_registered("/test/add.ts"));
                }
            }
        }

        #[test]
        fn test_update_remove_hotkey() {
            if let Some(mut manager) = create_test_manager() {
                // First register
                if manager.register("/test/remove.ts", "cmd+shift+r").is_ok() {
                    // Some -> None = remove
                    let result = manager.update("/test/remove.ts", Some("cmd+shift+r"), None);
                    assert!(result.is_ok());
                    assert!(!manager.is_registered("/test/remove.ts"));
                }
            }
        }

        #[test]
        fn test_update_change_hotkey() {
            if let Some(mut manager) = create_test_manager() {
                // First register with old shortcut
                if manager.register("/test/change.ts", "cmd+shift+c").is_ok() {
                    // Some -> Some (different) = change
                    let result =
                        manager.update("/test/change.ts", Some("cmd+shift+c"), Some("cmd+alt+c"));
                    if result.is_ok() {
                        // Should still be registered (with new shortcut)
                        assert!(manager.is_registered("/test/change.ts"));
                    }
                }
            }
        }

        #[test]
        fn test_get_script_path() {
            if let Some(mut manager) = create_test_manager() {
                if let Ok(hotkey_id) = manager.register("/test/lookup.ts", "cmd+shift+l") {
                    let path = manager.get_script_path(hotkey_id);
                    assert_eq!(path, Some(&"/test/lookup.ts".to_string()));

                    // Unknown ID returns None
                    assert!(manager.get_script_path(99999).is_none());
                }
            }
        }
    }
}

</file>

</files>