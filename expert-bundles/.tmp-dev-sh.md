This file is a merged representation of the filtered codebase, combined into a single document by packx.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of filtered repository contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<usage_guidelines>
- Treat this file as a snapshot of the repository's state
- Be aware that this file may contain sensitive information
</usage_guidelines>

<notes>
- Files were filtered by packx based on content and extension matching
- Total files included: 6
</notes>
</file_summary>

<directory_structure>
src/setup.rs
src/watcher.rs
dev.sh
Cargo.toml
build.rs
DEV.md
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="src/setup.rs">
//! Script Kit environment setup and initialization.
//!
//! Ensures ~/.scriptkit exists with required directories and starter files.
//! The path can be overridden via the SK_PATH environment variable.
//! Idempotent: user-owned files are never overwritten; app-owned files may be refreshed.

use std::fs;
use std::path::{Path, PathBuf};

use tracing::{debug, info, instrument, warn};

/// Embedded config template (included at compile time)
const EMBEDDED_CONFIG_TEMPLATE: &str = include_str!("../kit-init/config-template.ts");

/// Embedded SDK content (included at compile time)
const EMBEDDED_SDK: &str = include_str!("../scripts/kit-sdk.ts");

/// Optional theme example (included at compile time)
const EMBEDDED_THEME_EXAMPLE: &str = include_str!("../kit-init/theme.example.json");

/// Embedded package.json template for user's kit directory
/// The "type": "module" enables top-level await in all .ts scripts
const EMBEDDED_PACKAGE_JSON: &str = r#"{
  "name": "@scriptkit/kit",
  "type": "module",
  "private": true,
  "scripts": {
    "typecheck": "tsc --noEmit"
  }
}
"#;

/// Embedded GUIDE.md comprehensive user guide
const EMBEDDED_GUIDE_MD: &str = include_str!("../kit-init/GUIDE.md");

/// Embedded AGENTS.md guide for AI agents writing user scripts
const EMBEDDED_AGENTS_MD: &str = r###"# Script Kit User Scripts Guide

This guide is for AI agents and developers writing scripts for Script Kit.
Script Kit is a productivity tool that runs TypeScript scripts with a rich UI.

---

## Quick Start

```typescript
import "@scriptkit/sdk";

export const metadata = {
  name: "My Script",
  description: "Does something useful",
};

const choice = await arg("Pick an option", ["Option 1", "Option 2"]);
await div(`<h1>You chose: ${choice}</h1>`);
```

---

## Table of Contents

1. [Script Metadata](#script-metadata)
2. [SDK Import](#sdk-import)
3. [Core SDK Functions](#core-sdk-functions)
4. [Scriptlet Format](#scriptlet-format)
5. [Configuration (config.ts)](#configuration-configts)
6. [Testing Scripts](#testing-scripts)
7. [Examples](#examples)

---

## Script Metadata

Scripts use the `metadata` export for configuration. This is the **preferred format** over comment-based metadata.

### Basic Metadata

```typescript
import "@scriptkit/sdk";

export const metadata = {
  name: "My Script",           // Display name in menu
  description: "What it does", // Shown below the name
  shortcut: "cmd shift m",     // Global hotkey (optional)
  alias: "ms",                 // Quick search alias (optional)
};
```

### All Metadata Fields

| Field | Type | Description |
|-------|------|-------------|
| `name` | string | Display name in the Script Kit menu |
| `description` | string | Description shown below the name |
| `shortcut` | string | Global keyboard shortcut (e.g., "cmd shift k") |
| `alias` | string | Short alias for quick triggering |
| `author` | string | Script author |
| `enter` | string | Custom text for Enter/Submit button |
| `icon` | string | Icon name (e.g., "file", "terminal", "star") |
| `tags` | string[] | Tags for categorization and search |
| `hidden` | boolean | Hide from the main script list |
| `background` | boolean | Run without UI (background process) |
| `schedule` | string | Cron expression for scheduled execution |
| `watch` | string | File path pattern that triggers the script |

### Legacy Comment-Based Metadata (Deprecated)

Comment-based metadata is supported but **deprecated** for new scripts:

```typescript
// Name: My Script
// Description: What it does
// Shortcut: cmd shift m
```

**Why prefer `export const metadata`?**
- Full TypeScript type safety
- IDE autocomplete and error checking
- Access to more metadata fields
- Easier to read and maintain

---

## SDK Import

Import the Script Kit SDK to get global functions:

```typescript
import "@scriptkit/sdk";
```

This import:
- Makes all SDK functions available globally (arg, div, editor, etc.)
- Provides TypeScript types for IDE support
- Is resolved via tsconfig.json path mapping

---

## Core SDK Functions

### Prompts

#### `arg()` - Text Input with Choices

```typescript
// Simple text input
const name = await arg("What's your name?");

// With string choices
const color = await arg("Pick a color", ["Red", "Green", "Blue"]);

// With rich choices
const file = await arg("Select a file", [
  { name: "Document.pdf", value: "/path/to/doc.pdf", description: "PDF file" },
  { name: "Image.png", value: "/path/to/img.png", description: "Image file" },
]);

// With dynamic choices (async function)
const repo = await arg("Select repo", async () => {
  const response = await fetch("https://api.github.com/user/repos");
  const repos = await response.json();
  return repos.map((r: any) => ({ name: r.name, value: r.html_url }));
});
```

#### `div()` - Display HTML Content

```typescript
// Simple HTML
await div("<h1>Hello World!</h1>");

// With Tailwind CSS classes
await div(`
  <div class="flex flex-col items-center p-8">
    <h1 class="text-4xl font-bold text-yellow-400">Welcome!</h1>
    <p class="text-gray-400 mt-4">Press Escape to close</p>
  </div>
`);
```

#### `editor()` - Code Editor

```typescript
// Open editor with content
const code = await editor("// Write your code here", "typescript");

// Edit existing file content
const edited = await editor(existingContent, "json");
```

#### `fields()` - Multi-Field Form

```typescript
const [name, email, age] = await fields([
  { name: "name", label: "Name", type: "text", placeholder: "John Doe" },
  { name: "email", label: "Email", type: "email" },
  { name: "age", label: "Age", type: "number" },
]);
```

### File System

#### `path()` - File/Folder Picker

```typescript
// Pick a file
const filePath = await path("Select a file");

// Pick with starting directory
const docPath = await path({ startPath: "~/Documents", hint: "Choose a document" });
```

#### `drop()` - Drag and Drop

```typescript
// Accept dropped files
const files = await drop("Drop files here");
for (const file of files) {
  console.log(file.path, file.name, file.size);
}
```

### Input Capture

#### `hotkey()` - Capture Keyboard Shortcut

```typescript
const shortcut = await hotkey("Press a keyboard shortcut");
console.log(shortcut.key, shortcut.command, shortcut.shift);
```

### Display

#### `md()` - Render Markdown

```typescript
const html = md(`
# Hello World
This is **bold** and this is *italic*.
`);
await div(html);
```

### Advanced

#### `term()` - Terminal Emulator

```typescript
await term("htop");  // Run interactive command
await term({ command: "npm install", cwd: "/path/to/project" });
```

#### `chat()` - Chat Interface

```typescript
await chat({
  onSubmit: async (input) => {
    // Handle user message
    return { text: `You said: ${input}`, position: "left" };
  }
});
```

#### `widget()` - Floating Widget Window

```typescript
const w = await widget(`<h1>Floating Widget</h1>`, {
  width: 300,
  height: 200,
  draggable: true,
  alwaysOnTop: true,
});
```

---

## Scriptlet Format

Extensions are markdown files with embedded commands. They live in `~/.scriptkit/kit/main/extensions/`.

### Basic Scriptlet

```markdown
---
name: My Scriptlet
description: A quick tool
author: Your Name
---

# My Scriptlet

## Greeting Tool
\`\`\`tool:greet
import "@scriptkit/sdk";
const name = await arg("Enter name");
await div(`<h1>Hello, ${name}!</h1>`);
\`\`\`
```

### Frontmatter Fields

| Field | Type | Description |
|-------|------|-------------|
| `name` | string | Display name for the bundle |
| `description` | string | Brief description |
| `author` | string | Author name |
| `icon` | string | Icon identifier |

### Code Block Types

- `tool:name` - Executable tool
- `template:name` - Text expansion template
- `snippet:name` - Code snippet
- `prompt:name` - AI prompt

### Variable Substitution

Templates support `{{variable}}` substitution:

```markdown
\`\`\`template:email-reply
Hi {{name}},

Thank you for your email about {{topic}}.

Best regards
\`\`\`
```

---

## Configuration (config.ts)

The `~/.scriptkit/kit/config.ts` file configures Script Kit:

```typescript
import type { Config } from "@scriptkit/sdk";

export default {
  // Global hotkey to show Script Kit
  hotkey: {
    key: "Space",
    modifiers: ["command"],
  },

  // UI settings
  editorFontSize: 14,
  terminalFontSize: 14,

  // Built-in features
  builtIns: {
    clipboardHistory: true,
    appLauncher: true,
  },
} satisfies Config;
```

### Config Options

| Option | Type | Default | Description |
|--------|------|---------|-------------|
| `hotkey` | object | cmd+; | Global activation hotkey |
| `editorFontSize` | number | 14 | Editor font size |
| `terminalFontSize` | number | 14 | Terminal font size |
| `builtIns.clipboardHistory` | boolean | true | Enable clipboard history |
| `builtIns.appLauncher` | boolean | true | Enable app launcher |

---

## Testing Scripts

### Run from Script Kit

1. Open Script Kit (default: Cmd+;)
2. Type your script name
3. Press Enter to run

### Run from Terminal

```bash
# Using bun directly
bun run ~/.scriptkit/kit/main/scripts/my-script.ts

# With the kit CLI (if installed)
kit run my-script
```

### Debugging

Add console.error() for debug output:

```typescript
import "@scriptkit/sdk";

console.error("[DEBUG] Script starting...");
const result = await arg("Choose", ["A", "B"]);
console.error("[DEBUG] User chose:", result);
```

---

## Examples

### Example 1: Quick Note

```typescript
import "@scriptkit/sdk";

export const metadata = {
  name: "Quick Note",
  description: "Save a quick note to a file",
  shortcut: "cmd shift n",
};

const note = await arg("Enter your note");
const timestamp = new Date().toISOString();
const entry = `\n## ${timestamp}\n${note}\n`;

await Bun.write(
  Bun.file(`${home()}/notes.md`),
  (await Bun.file(`${home()}/notes.md`).text().catch(() => "# Notes\n")) + entry
);

await div(`<p class="text-green-400">Note saved!</p>`);
```

### Example 2: GitHub Repo Opener

```typescript
import "@scriptkit/sdk";

export const metadata = {
  name: "Open GitHub Repo",
  description: "Search and open a GitHub repository",
  shortcut: "cmd shift g",
};

const repo = await arg("Search repos", async (input) => {
  if (!input) return [];
  const res = await fetch(`https://api.github.com/search/repositories?q=${input}`);
  const data = await res.json();
  return data.items?.map((r: any) => ({
    name: r.full_name,
    value: r.html_url,
    description: r.description || "No description",
  })) || [];
});

await open(repo);
```

### Example 3: JSON Formatter

```typescript
import "@scriptkit/sdk";

export const metadata = {
  name: "Format JSON",
  description: "Pretty-print JSON from clipboard",
};

const clipboard = await paste();
try {
  const formatted = JSON.stringify(JSON.parse(clipboard), null, 2);
  await copy(formatted);
  await div(`<pre class="text-green-400">${formatted}</pre>`);
} catch {
  await div(`<p class="text-red-400">Invalid JSON in clipboard</p>`);
}
```

### Example 4: System Info Widget

```typescript
import "@scriptkit/sdk";
import os from "os";

export const metadata = {
  name: "System Info",
  description: "Show system information",
};

const info = `
  <div class="p-4 space-y-2">
    <p><strong>Platform:</strong> ${os.platform()}</p>
    <p><strong>Arch:</strong> ${os.arch()}</p>
    <p><strong>CPUs:</strong> ${os.cpus().length}</p>
    <p><strong>Memory:</strong> ${Math.round(os.totalmem() / 1024 / 1024 / 1024)}GB</p>
    <p><strong>Uptime:</strong> ${Math.round(os.uptime() / 3600)} hours</p>
  </div>
`;

await div(info);
```

### Example 5: File Search

```typescript
import "@scriptkit/sdk";

export const metadata = {
  name: "Find Files",
  description: "Search for files by name",
  shortcut: "cmd shift f",
};

const query = await arg("Search for files");
const { stdout } = await $`find ~ -name "*${query}*" -type f 2>/dev/null | head -20`;

const files = stdout.trim().split("\n").filter(Boolean);

if (files.length === 0) {
  await div(`<p class="text-yellow-400">No files found</p>`);
} else {
  const selected = await arg("Select file", files.map(f => ({
    name: f.split("/").pop() || f,
    value: f,
    description: f,
  })));
  
  await open(selected);
}
```

---

## Best Practices

1. **Always use `export const metadata`** - Get type safety and IDE support
2. **Import the SDK first** - `import "@scriptkit/sdk"` at the top
3. **Use Tailwind classes** - Built-in support for styling in div()
4. **Handle errors gracefully** - Wrap async operations in try/catch
5. **Keep scripts focused** - One script, one task
6. **Use meaningful names** - Clear metadata.name and description
7. **Add shortcuts sparingly** - Only for frequently used scripts

---

## File Locations

| Path | Purpose |
|------|---------|
| `~/.scriptkit/kit/main/scripts/` | Your scripts |
| `~/.scriptkit/kit/main/extensions/` | Your extensions |
| `~/.scriptkit/kit/main/agents/` | Your AI agent definitions |
| `~/.scriptkit/kit/config.ts` | Configuration |
| `~/.scriptkit/kit/theme.json` | Theme customization |
| `~/.scriptkit/sdk/` | SDK (managed by app) |
| `~/.scriptkit/kit/AGENTS.md` | This guide (for AI agents) |
| `~/.scriptkit/kit/CLAUDE.md` | Claude-specific instructions |
"###;

/// Embedded CLAUDE.md for Claude-specific guidance
const EMBEDDED_CLAUDE_MD: &str = r###"# Script Kit - Claude Instructions

This file provides Claude-specific guidance for working with Script Kit GPUI.

## ‚ö†Ô∏è Critical: This is Script Kit GPUI (v2), NOT the original Script Kit

Script Kit GPUI is a **complete rewrite** of the original Script Kit:
- **Old Script Kit (v1)**: Electron + Node.js
- **Script Kit GPUI (v2)**: GPUI (Rust) + Bun

If your training data includes the old Script Kit, **ignore those patterns**. Use only what's documented here.

---

## Directory Structure

```
~/.scriptkit/
‚îú‚îÄ‚îÄ kit/                          # Version-controllable kit directory
‚îÇ   ‚îú‚îÄ‚îÄ main/                     # Main kit (default)
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ scripts/             # Your TypeScript scripts
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ extensions/          # Markdown files with embedded commands
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ agents/              # AI agent definitions
‚îÇ   ‚îú‚îÄ‚îÄ config.ts                # Configuration (hotkey, font sizes, etc.)
‚îÇ   ‚îú‚îÄ‚îÄ theme.json               # Theme customization (colors, etc.)
‚îÇ   ‚îú‚îÄ‚îÄ package.json             # Enables top-level await ("type": "module")
‚îÇ   ‚îú‚îÄ‚îÄ tsconfig.json            # TypeScript configuration
‚îÇ   ‚îú‚îÄ‚îÄ AGENTS.md                # SDK documentation for AI agents
‚îÇ   ‚îî‚îÄ‚îÄ CLAUDE.md                # This file
‚îú‚îÄ‚îÄ sdk/                          # SDK (managed by app, do not edit)
‚îÇ   ‚îî‚îÄ‚îÄ kit-sdk.ts
‚îú‚îÄ‚îÄ db/                           # SQLite databases
‚îú‚îÄ‚îÄ logs/                         # Application logs
‚îî‚îÄ‚îÄ GUIDE.md                      # User guide
```

---

## Writing Scripts

### Minimal Script Template

```typescript
import "@scriptkit/sdk";

export const metadata = {
  name: "My Script",
  description: "What this script does",
};

// Your code here - top-level await is supported
const result = await arg("Choose an option", ["A", "B", "C"]);
console.log(result);
```

### Key Points

1. **Always import the SDK first**: `import "@scriptkit/sdk";`
2. **Use `export const metadata`**: NOT comment-based metadata (deprecated)
3. **Top-level await**: Works out of the box (thanks to `package.json` `"type": "module"`)
4. **Bun APIs**: Use `Bun.file()`, `Bun.write()`, `$\`command\`` - NOT Node.js fs/child_process

### Common SDK Functions

```typescript
// User input
const text = await arg("Enter something");
const choice = await arg("Pick one", ["Option 1", "Option 2"]);

// Display content
await div("<h1 class='text-2xl'>Hello</h1>");  // HTML with Tailwind

// Editor
const code = await editor("// Edit this", "typescript");

// Forms
const [name, email] = await fields([
  { name: "name", label: "Name" },
  { name: "email", label: "Email", type: "email" },
]);

// Clipboard
const text = await paste();
await copy("Copied this text");

// Open URLs/files
await open("https://example.com");
```

---

## Configuration (config.ts)

Located at `~/.scriptkit/kit/config.ts`:

```typescript
import type { Config } from "@scriptkit/sdk";

export default {
  hotkey: { key: "Space", modifiers: ["command"] },
  editorFontSize: 14,
  terminalFontSize: 14,
  builtIns: { clipboardHistory: true, appLauncher: true },
} satisfies Config;
```

---

## Theme (theme.json)

Located at `~/.scriptkit/kit/theme.json`:

```json
{
  "colors": {
    "background": { "main": "#1e1e2e", "panel": "#181825" },
    "text": { "primary": "#cdd6f4", "secondary": "#a6adc8" },
    "accent": { "primary": "#89b4fa", "secondary": "#74c7ec" },
    "ui": { "border": "#313244", "divider": "#45475a" }
  }
}
```

---

## Extensions (formerly Scriptlets)

Markdown files in `~/.scriptkit/kit/main/extensions/*.md` with embedded code:

```markdown
---
name: My Tools
description: Collection of useful tools
---

# My Tools

## Say Hello
\`\`\`tool:hello
import "@scriptkit/sdk";
const name = await arg("Name?");
await div(`<h1>Hello, ${name}!</h1>`);
\`\`\`

## Quick Template
\`\`\`template:greeting
Hello {{name}}, welcome to {{place}}!
\`\`\`
```

---

## DO NOT

- Use `require()` - use ES imports
- Use Node.js `fs` - use `Bun.file()` and `Bun.write()`
- Use Node.js `child_process` - use `$\`command\`` (Bun shell)
- Use comment-based metadata (`// Name:`) - use `export const metadata`
- Modify files in `~/.scriptkit/sdk/` - they're managed by the app
- Reference old Script Kit v1 patterns (Electron, Kit SDK, @johnlindquist/kit)

---

## File Locations Summary

| Purpose | Path |
|---------|------|
| Scripts | `~/.scriptkit/kit/main/scripts/*.ts` |
| Extensions | `~/.scriptkit/kit/main/extensions/*.md` |
| Agents | `~/.scriptkit/kit/main/agents/*.md` |
| Config | `~/.scriptkit/kit/config.ts` |
| Theme | `~/.scriptkit/kit/theme.json` |
| SDK Docs | `~/.scriptkit/kit/AGENTS.md` |
"###;

/// Environment variable to override the default ~/.scriptkit path
pub const SK_PATH_ENV: &str = "SK_PATH";

/// Result of setup process
#[derive(Debug)]
pub struct SetupResult {
    /// Whether ~/.scriptkit didn't exist before this run
    pub is_fresh_install: bool,
    /// Path to ~/.scriptkit (or SK_PATH override, or fallback if home dir couldn't be resolved)
    pub kit_path: PathBuf,
    /// Whether bun looks discoverable on this machine
    pub bun_available: bool,
    /// Any warnings encountered during setup
    pub warnings: Vec<String>,
}

/// Get the kit path, respecting SK_PATH environment variable
///
/// Priority:
/// 1. SK_PATH environment variable (if set)
/// 2. ~/.scriptkit (default)
/// 3. Temp directory fallback (if home dir unavailable)
pub fn get_kit_path() -> PathBuf {
    // Check for SK_PATH override first
    if let Ok(sk_path) = std::env::var(SK_PATH_ENV) {
        return PathBuf::from(shellexpand::tilde(&sk_path).as_ref());
    }

    // Default: ~/.scriptkit
    match dirs::home_dir() {
        Some(home) => home.join(".scriptkit"),
        None => std::env::temp_dir().join("script-kit"),
    }
}

/// Migrate from legacy ~/.kenv to new ~/.scriptkit structure
///
/// This function handles one-time migration from the old directory structure:
/// - Moves ~/.kenv contents to ~/.scriptkit
/// - Moves ~/.kenv/scripts to ~/.scriptkit/kit/main/scripts
/// - Moves ~/.kenv/scriptlets to ~/.scriptkit/kit/main/extensions
/// - Creates a symlink ~/.kenv -> ~/.scriptkit for backwards compatibility
///
/// Returns true if migration was performed, false if not needed
#[instrument(level = "info", name = "migrate_from_kenv")]
pub fn migrate_from_kenv() -> bool {
    let home = match dirs::home_dir() {
        Some(h) => h,
        None => return false,
    };

    let old_kenv = home.join(".kenv");
    let new_scriptkit = home.join(".scriptkit");

    // Only migrate if old path exists and new path doesn't
    if !old_kenv.exists() || new_scriptkit.exists() {
        return false;
    }

    info!(
        old_path = %old_kenv.display(),
        new_path = %new_scriptkit.display(),
        "Migrating from ~/.kenv to ~/.scriptkit"
    );

    // Create the new structure (under kit/ subdirectory)
    let main_scripts = new_scriptkit.join("kit").join("main").join("scripts");
    let main_extensions = new_scriptkit.join("kit").join("main").join("extensions");

    if let Err(e) = fs::create_dir_all(&main_scripts) {
        warn!(error = %e, "Failed to create main/scripts directory");
        return false;
    }

    if let Err(e) = fs::create_dir_all(&main_extensions) {
        warn!(error = %e, "Failed to create main/extensions directory");
        return false;
    }

    // Move scripts from ~/.kenv/scripts to ~/.scriptkit/kit/main/scripts
    let old_scripts = old_kenv.join("scripts");
    if old_scripts.exists() && old_scripts.is_dir() {
        if let Ok(entries) = fs::read_dir(&old_scripts) {
            for entry in entries.flatten() {
                let old_path = entry.path();
                let file_name = old_path.file_name().unwrap_or_default();
                let new_path = main_scripts.join(file_name);

                if let Err(e) = fs::rename(&old_path, &new_path) {
                    warn!(
                        error = %e,
                        old = %old_path.display(),
                        new = %new_path.display(),
                        "Failed to move script"
                    );
                }
            }
        }
    }

    // Move scriptlets from ~/.kenv/scriptlets to ~/.scriptkit/kit/main/extensions
    let old_scriptlets = old_kenv.join("scriptlets");
    if old_scriptlets.exists() && old_scriptlets.is_dir() {
        if let Ok(entries) = fs::read_dir(&old_scriptlets) {
            for entry in entries.flatten() {
                let old_path = entry.path();
                let file_name = old_path.file_name().unwrap_or_default();
                let new_path = main_extensions.join(file_name);

                if let Err(e) = fs::rename(&old_path, &new_path) {
                    warn!(
                        error = %e,
                        old = %old_path.display(),
                        new = %new_path.display(),
                        "Failed to move scriptlet"
                    );
                }
            }
        }
    }

    // Move config files to new root
    let config_files = ["config.ts", "theme.json", "tsconfig.json", ".gitignore"];
    for file in config_files {
        let old_path = old_kenv.join(file);
        let new_path = new_scriptkit.join(file);
        if old_path.exists() && !new_path.exists() {
            if let Err(e) = fs::rename(&old_path, &new_path) {
                warn!(error = %e, file = file, "Failed to move config file");
            }
        }
    }

    // Move data directories to new root
    let data_dirs = ["logs", "cache", "db", "sdk"];
    for dir in data_dirs {
        let old_path = old_kenv.join(dir);
        let new_path = new_scriptkit.join(dir);
        if old_path.exists() && old_path.is_dir() && !new_path.exists() {
            if let Err(e) = fs::rename(&old_path, &new_path) {
                warn!(error = %e, dir = dir, "Failed to move data directory");
            }
        }
    }

    // Move data files to new root
    let data_files = [
        "frecency.json",
        "store.json",
        "server.json",
        "agent-token",
        "notes.db",
        "ai-chats.db",
        "clipboard-history.db",
    ];
    for file in data_files {
        let old_path = old_kenv.join(file);
        let new_path = new_scriptkit.join(file);
        if old_path.exists() && !new_path.exists() {
            if let Err(e) = fs::rename(&old_path, &new_path) {
                warn!(error = %e, file = file, "Failed to move data file");
            }
        }
    }

    // Remove the old ~/.kenv directory (should be mostly empty now)
    if let Err(e) = fs::remove_dir_all(&old_kenv) {
        warn!(error = %e, "Failed to remove old ~/.kenv directory, may have remaining files");
    }

    // Create symlink for backwards compatibility (Unix only)
    #[cfg(unix)]
    {
        if let Err(e) = std::os::unix::fs::symlink(&new_scriptkit, &old_kenv) {
            warn!(error = %e, "Failed to create ~/.kenv symlink for backwards compatibility");
        } else {
            info!("Created ~/.kenv -> ~/.scriptkit symlink for backwards compatibility");
        }
    }

    info!("Migration from ~/.kenv to ~/.scriptkit complete");
    true
}

/// Ensure the ~/.scriptkit environment is properly set up.
///
/// This function is idempotent - it will create missing directories and files
/// without overwriting existing user configurations.
///
/// # Directory Structure Created
/// ```text
/// ~/.scriptkit/                  # Root (can be overridden via SK_PATH)
/// ‚îú‚îÄ‚îÄ kit/                       # All kits container (for easy version control)
/// ‚îÇ   ‚îú‚îÄ‚îÄ main/                  # Default user kit
/// ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ scripts/           # User scripts (.ts, .js files)
/// ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ extensions/         # Markdown extension files
/// ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ agents/             # AI agent definitions (.md)
/// ‚îÇ   ‚îî‚îÄ‚îÄ custom-kit/            # Additional custom kits
/// ‚îÇ       ‚îú‚îÄ‚îÄ scripts/
/// ‚îÇ       ‚îú‚îÄ‚îÄ extensions/
/// ‚îÇ       ‚îî‚îÄ‚îÄ agents/
/// ‚îÇ   ‚îú‚îÄ‚îÄ package.json           # Node.js module config (type: module for top-level await)
/// ‚îÇ   ‚îî‚îÄ‚îÄ tsconfig.json          # TypeScript path mappings
/// ‚îÇ   ‚îú‚îÄ‚îÄ config.ts              # User configuration (created from template if missing)
/// ‚îÇ   ‚îú‚îÄ‚îÄ theme.json             # Theme configuration (created from example if missing)
/// ‚îÇ   ‚îú‚îÄ‚îÄ AGENTS.md              # AI agent guide (SDK documentation)
/// ‚îÇ   ‚îî‚îÄ‚îÄ CLAUDE.md              # Claude-specific instructions
/// ‚îú‚îÄ‚îÄ sdk/                       # Runtime SDK (kit-sdk.ts)
/// ‚îú‚îÄ‚îÄ db/                        # Databases
/// ‚îú‚îÄ‚îÄ logs/                      # Application logs
/// ‚îú‚îÄ‚îÄ cache/
/// ‚îÇ   ‚îî‚îÄ‚îÄ app-icons/             # Cached application icons
/// ‚îú‚îÄ‚îÄ GUIDE.md                   # User guide
/// ‚îî‚îÄ‚îÄ .gitignore                 # Ignore transient files
/// ```
///
/// # Environment Variables
/// - `SK_PATH`: Override the default ~/.scriptkit path
///
/// # Returns
/// `SetupResult` with information about the setup process.
#[instrument(level = "info", name = "ensure_kit_setup")]
pub fn ensure_kit_setup() -> SetupResult {
    let mut warnings = Vec::new();

    let kit_dir = get_kit_path();

    // Check if this is a fresh install before we create anything
    let is_fresh_install = !kit_dir.exists();

    // Log if using SK_PATH override
    if std::env::var(SK_PATH_ENV).is_ok() {
        info!(
            kit_path = %kit_dir.display(),
            "Using SK_PATH override"
        );
    }

    // Ensure root kit directory exists first
    if let Err(e) = fs::create_dir_all(&kit_dir) {
        warnings.push(format!(
            "Failed to create kit root {}: {}",
            kit_dir.display(),
            e
        ));
        // If we can't create the root, there's not much else we can safely do.
        return SetupResult {
            is_fresh_install,
            kit_path: kit_dir,
            bun_available: false,
            warnings,
        };
    }

    // Required directory structure
    // Note: kit/main/scripts and kit/main/extensions are the default user workspace
    // All kits live under kit/ for easier version control
    let required_dirs = [
        kit_dir.join("kit").join("main").join("scripts"),
        kit_dir.join("kit").join("main").join("extensions"),
        kit_dir.join("kit").join("main").join("agents"),
        kit_dir.join("sdk"),
        kit_dir.join("db"),
        kit_dir.join("logs"),
        kit_dir.join("cache").join("app-icons"),
    ];

    for dir in required_dirs {
        ensure_dir(&dir, &mut warnings);
    }

    // App-managed: SDK (refresh if changed)
    let sdk_path = kit_dir.join("sdk").join("kit-sdk.ts");
    write_string_if_changed(&sdk_path, EMBEDDED_SDK, &mut warnings, "sdk/kit-sdk.ts");

    // User-owned: config.ts (only create if missing)
    // Located in kit/ directory so it can be version controlled with user scripts
    let config_path = kit_dir.join("kit").join("config.ts");
    write_string_if_missing(
        &config_path,
        EMBEDDED_CONFIG_TEMPLATE,
        &mut warnings,
        "kit/config.ts",
    );

    // User-owned (optional): theme.json (only create if missing)
    // Located in kit/ directory so it can be version controlled with user scripts
    let theme_path = kit_dir.join("kit").join("theme.json");
    write_string_if_missing(
        &theme_path,
        EMBEDDED_THEME_EXAMPLE,
        &mut warnings,
        "kit/theme.json",
    );

    // App-managed: tsconfig.json path mappings in kit/ directory (merge-safe)
    // Located at ~/.scriptkit/kit/tsconfig.json to be alongside user scripts
    ensure_tsconfig_paths(&kit_dir.join("kit").join("tsconfig.json"), &mut warnings);

    // App-managed: package.json for top-level await support in kit/ directory
    // The "type": "module" allows scripts in kit/main/scripts/*.ts to use top-level await
    let package_json_path = kit_dir.join("kit").join("package.json");
    write_string_if_missing(
        &package_json_path,
        EMBEDDED_PACKAGE_JSON,
        &mut warnings,
        "kit/package.json",
    );

    // User guide: AGENTS.md for AI agents writing scripts (in kit/ directory)
    let agents_md_path = kit_dir.join("kit").join("AGENTS.md");
    write_string_if_missing(
        &agents_md_path,
        EMBEDDED_AGENTS_MD,
        &mut warnings,
        "kit/AGENTS.md",
    );

    // Claude-specific instructions (in kit/ directory)
    let claude_md_path = kit_dir.join("kit").join("CLAUDE.md");
    write_string_if_missing(
        &claude_md_path,
        EMBEDDED_CLAUDE_MD,
        &mut warnings,
        "kit/CLAUDE.md",
    );

    // User-owned: GUIDE.md (only create if missing)
    // Comprehensive user guide for learning Script Kit
    let guide_md_path = kit_dir.join("GUIDE.md");
    write_string_if_missing(&guide_md_path, EMBEDDED_GUIDE_MD, &mut warnings, "GUIDE.md");

    // App-managed: .gitignore (refresh if changed)
    let gitignore_path = kit_dir.join(".gitignore");
    let gitignore_content = r#"# Script Kit managed .gitignore
# This file is regenerated on app start - edit with caution

# =============================================================================
# Node.js / Bun dependencies
# =============================================================================
# Root node_modules (for package.json at ~/.scriptkit/kit/)
node_modules/

# Kit-specific node_modules (e.g., main/node_modules, examples/node_modules)
*/node_modules/

# Package manager files
package-lock.json
yarn.lock
pnpm-lock.yaml
bun.lockb
.pnpm-store/

# =============================================================================
# Databases
# =============================================================================
# SQLite databases
*.db
*.db-journal
*.db-shm
*.db-wal

# Specific databases (redundant with *.db but explicit for clarity)
db/
clipboard-history.db
notes.db
ai-chats.db

# =============================================================================
# Runtime & Cache
# =============================================================================
# SDK is managed by the app, always regenerated
sdk/

# Application logs
logs/

# Cache files (app icons, etc.)
cache/

# Frecency tracking (regenerated from usage)
frecency.json

# Server state
server.json

# Authentication tokens
agent-token

# =============================================================================
# Build & Tooling
# =============================================================================
# TypeScript build output
*.tsbuildinfo
dist/
build/
.turbo/

# IDE
.idea/
.vscode/
*.swp
*.swo
*~

# macOS
.DS_Store
._*

# =============================================================================
# Secrets & Environment
# =============================================================================
.env
.env.local
.env.*.local
*.pem
*.key

# =============================================================================
# Temporary files
# =============================================================================
*.tmp
*.temp
*.log
tmp/
temp/
"#;
    write_string_if_changed(
        &gitignore_path,
        gitignore_content,
        &mut warnings,
        ".gitignore",
    );

    // Dependency check: bun (no process spawn; just path checks)
    let bun_available = bun_is_discoverable();
    if !bun_available {
        warnings.push(
            "bun not found (PATH/common install locations). Config/scripts may not run until bun is installed.".to_string(),
        );
    }

    // Optional "getting started" content only on truly fresh installs
    if is_fresh_install {
        create_sample_files(&kit_dir, &mut warnings);
    }

    info!(
        kit_path = %kit_dir.display(),
        is_fresh_install,
        bun_available,
        warning_count = warnings.len(),
        "Kit setup complete"
    );

    SetupResult {
        is_fresh_install,
        kit_path: kit_dir,
        bun_available,
        warnings,
    }
}

fn ensure_dir(path: &Path, warnings: &mut Vec<String>) {
    if path.exists() {
        return;
    }
    if let Err(e) = fs::create_dir_all(path) {
        warnings.push(format!(
            "Failed to create directory {}: {}",
            path.display(),
            e
        ));
    } else {
        debug!(path = %path.display(), "Created directory");
    }
}

fn write_string_if_missing(path: &Path, contents: &str, warnings: &mut Vec<String>, label: &str) {
    if path.exists() {
        return;
    }
    if let Some(parent) = path.parent() {
        if let Err(e) = fs::create_dir_all(parent) {
            warnings.push(format!(
                "Failed to create parent dir for {} ({}): {}",
                label,
                parent.display(),
                e
            ));
            return;
        }
    }
    if let Err(e) = fs::write(path, contents) {
        warnings.push(format!(
            "Failed to write {} ({}): {}",
            label,
            path.display(),
            e
        ));
    } else {
        info!(path = %path.display(), "Created {}", label);
    }
}

/// Write string to path if content changed, using atomic rename for safety
///
/// This function uses an atomic write pattern to prevent race conditions and
/// partial writes:
/// 1. Write to a temporary file in the same directory
/// 2. Atomically rename temp file to target path
///
/// The rename is atomic on most filesystems, so readers will either see the
/// old content or the new content, never a partial write.
fn write_string_if_changed(path: &Path, contents: &str, warnings: &mut Vec<String>, label: &str) {
    if let Ok(existing) = fs::read_to_string(path) {
        if existing == contents {
            return;
        }
    }

    if let Some(parent) = path.parent() {
        if let Err(e) = fs::create_dir_all(parent) {
            warnings.push(format!(
                "Failed to create parent dir for {} ({}): {}",
                label,
                parent.display(),
                e
            ));
            return;
        }
    }

    // Atomic write: write to temp file then rename
    // This prevents readers from seeing partial writes during concurrent access
    let temp_path = path.with_extension("tmp");

    if let Err(e) = fs::write(&temp_path, contents) {
        warnings.push(format!(
            "Failed to write temp file for {} ({}): {}",
            label,
            temp_path.display(),
            e
        ));
        return;
    }

    // Atomic rename - this is atomic on most filesystems
    if let Err(e) = fs::rename(&temp_path, path) {
        warnings.push(format!(
            "Failed to rename {} to {}: {}",
            temp_path.display(),
            path.display(),
            e
        ));
        // Clean up temp file on failure
        let _ = fs::remove_file(&temp_path);
    } else {
        debug!(path = %path.display(), "Updated {}", label);
    }
}

/// Ensure tsconfig.json has proper TypeScript/Bun settings (merge-safe)
/// The tsconfig lives at ~/.scriptkit/kit/tsconfig.json, SDK at ~/.scriptkit/sdk/
///
/// Sets essential options while preserving user customizations:
/// - target: ESNext (for top-level await and modern features)
/// - module: ESNext (ES modules)
/// - moduleResolution: Bundler (optimal for Bun)
/// - paths: @scriptkit/sdk mapping
/// - noEmit: true (Bun runs .ts directly)
/// - skipLibCheck: true (faster)
/// - esModuleInterop: true (CommonJS compat)
fn ensure_tsconfig_paths(tsconfig_path: &Path, warnings: &mut Vec<String>) {
    use serde_json::{json, Value};

    // Path is relative from kit/ to sdk/: ../sdk/kit-sdk.ts
    let expected_sdk_path = json!(["../sdk/kit-sdk.ts"]);

    let mut config: Value = if tsconfig_path.exists() {
        match fs::read_to_string(tsconfig_path) {
            Ok(content) => serde_json::from_str(&content).unwrap_or_else(|_| json!({})),
            Err(_) => json!({}),
        }
    } else {
        json!({})
    };

    // Ensure compilerOptions exists
    if config.get("compilerOptions").is_none() {
        config["compilerOptions"] = json!({});
    }

    let compiler_options = config["compilerOptions"].as_object_mut().unwrap();
    let mut changed = false;

    // Essential settings for Bun/TypeScript scripts (set if missing)
    let defaults = [
        ("target", json!("ESNext")),
        ("module", json!("ESNext")),
        ("moduleResolution", json!("Bundler")),
        ("noEmit", json!(true)),
        ("skipLibCheck", json!(true)),
        ("esModuleInterop", json!(true)),
        ("allowImportingTsExtensions", json!(true)),
        ("verbatimModuleSyntax", json!(true)),
    ];

    for (key, value) in defaults {
        if !compiler_options.contains_key(key) {
            compiler_options.insert(key.to_string(), value);
            changed = true;
        }
    }

    // Ensure paths exists
    if !compiler_options.contains_key("paths") {
        compiler_options.insert("paths".to_string(), json!({}));
        changed = true;
    }

    // Always ensure @scriptkit/sdk path is correct
    let paths = compiler_options
        .get_mut("paths")
        .unwrap()
        .as_object_mut()
        .unwrap();
    if paths.get("@scriptkit/sdk") != Some(&expected_sdk_path) {
        paths.insert("@scriptkit/sdk".to_string(), expected_sdk_path);
        changed = true;
    }

    if !changed {
        return;
    }

    match serde_json::to_string_pretty(&config) {
        Ok(json_str) => {
            if let Err(e) = fs::write(tsconfig_path, json_str) {
                warnings.push(format!(
                    "Failed to write tsconfig.json ({}): {}",
                    tsconfig_path.display(),
                    e
                ));
                warn!(error = %e, "Failed to write tsconfig.json");
            } else {
                info!("Updated tsconfig.json with TypeScript/Bun settings");
            }
        }
        Err(e) => {
            warnings.push(format!("Failed to serialize tsconfig.json: {}", e));
            warn!(error = %e, "Failed to serialize tsconfig.json");
        }
    }
}

/// Fast check: looks for bun in common locations and PATH without spawning a process.
fn bun_is_discoverable() -> bool {
    let mut candidates: Vec<PathBuf> = Vec::new();

    // Common install locations
    if let Some(home) = dirs::home_dir() {
        candidates.push(home.join(".bun").join("bin").join(bun_exe_name()));
    }
    candidates.push(PathBuf::from("/opt/homebrew/bin").join(bun_exe_name()));
    candidates.push(PathBuf::from("/usr/local/bin").join(bun_exe_name()));
    candidates.push(PathBuf::from("/usr/bin").join(bun_exe_name()));

    // PATH scan
    if let Ok(path_var) = std::env::var("PATH") {
        for dir in std::env::split_paths(&path_var) {
            candidates.push(dir.join(bun_exe_name()));
        }
    }

    candidates.into_iter().any(|p| p.exists())
}

fn bun_exe_name() -> &'static str {
    #[cfg(windows)]
    {
        "bun.exe"
    }
    #[cfg(not(windows))]
    {
        "bun"
    }
}

fn create_sample_files(kit_dir: &Path, warnings: &mut Vec<String>) {
    // Create sample files in the main kit (under kit/ subdirectory)
    let main_scripts_dir = kit_dir.join("kit").join("main").join("scripts");
    let main_extensions_dir = kit_dir.join("kit").join("main").join("extensions");
    let main_agents_dir = kit_dir.join("kit").join("main").join("agents");

    // Create hello-world.ts script
    let hello_script_path = main_scripts_dir.join("hello-world.ts");
    if !hello_script_path.exists() {
        let hello_script = r#"/*
# Hello World

A simple greeting script demonstrating Script Kit basics.

## Features shown:
- `arg()` - Prompt for user input with choices
- `div()` - Display HTML content with Tailwind CSS
- `md()` - Render markdown to HTML
*/

export const metadata = {
  name: "Hello World",
  description: "A simple greeting script",
  // shortcut: "cmd shift h",  // Uncomment to add a global hotkey
};

// Prompt the user to select or type their name
const name = await arg("What's your name?", [
  "World",
  "Script Kit",
  "Friend",
]);

// Display a greeting using HTML with Tailwind CSS classes
await div(`
  <div class="flex flex-col items-center justify-center h-full p-8">
    <h1 class="text-4xl font-bold text-yellow-400 mb-4">
      Hello, ${name}! üëã
    </h1>
    <p class="text-gray-400 text-lg">
      Welcome to Script Kit
    </p>
    <div class="mt-6 text-sm text-gray-500">
      Press <kbd class="px-2 py-1 bg-gray-700 rounded">Escape</kbd> to close
    </div>
  </div>
`);
"#;
        if let Err(e) = fs::write(&hello_script_path, hello_script) {
            warnings.push(format!(
                "Failed to create sample script {}: {}",
                hello_script_path.display(),
                e
            ));
        } else {
            info!(path = %hello_script_path.display(), "Created sample script");
        }
    }

    // Create hello-world.md extension
    let hello_extension_path = main_extensions_dir.join("hello-world.md");
    if !hello_extension_path.exists() {
        let hello_extension = r#"# Hello World Extensions

Quick shell commands you can run from Script Kit.
Each code block is a separate scriptlet that appears in the menu.

---

## Say Hello
<!-- 
name: Say Hello
description: Display a greeting notification
shortcut: ctrl h
-->

```bash
echo "Hello from Script Kit! üéâ"
```

---

## Current Date
<!-- 
name: Current Date
description: Copy today's date to clipboard
shortcut: ctrl d
-->

```bash
date +"%Y-%m-%d" | pbcopy
echo "Date copied: $(date +"%Y-%m-%d")"
```

---

## Open Downloads
<!-- 
name: Open Downloads
description: Open the Downloads folder in Finder
-->

```bash
open ~/Downloads
```

---

## Quick Note
<!-- 
name: Quick Note
description: Append a timestamped note to notes.txt
-->

```bash
echo "[$(date +"%Y-%m-%d %H:%M")] $1" >> ~/notes.txt
echo "Note saved!"
```

---

## System Info
<!-- 
name: System Info
description: Show basic system information
-->

```bash
echo "User: $(whoami)"
echo "Host: $(hostname)"
echo "OS: $(sw_vers -productName) $(sw_vers -productVersion)"
echo "Shell: $SHELL"
```
"#;
        if let Err(e) = fs::write(&hello_extension_path, hello_extension) {
            warnings.push(format!(
                "Failed to create sample extension {}: {}",
                hello_extension_path.display(),
                e
            ));
        } else {
            info!(path = %hello_extension_path.display(), "Created sample extension");
        }
    }

    // Create hello-world.claude.md agent
    let hello_agent_path = main_agents_dir.join("hello-world.claude.md");
    if !hello_agent_path.exists() {
        let hello_agent = r#"---
_sk_name: Hello World Assistant
_sk_description: A friendly assistant that helps with simple tasks
_sk_interactive: true
---

You are a friendly, helpful assistant. Keep responses concise and practical.

When the user asks for help:
1. Understand their request clearly
2. Provide a direct, actionable answer
3. Offer to help with follow-up questions

Be conversational but efficient. Focus on solving the user's immediate needs.
"#;
        if let Err(e) = fs::write(&hello_agent_path, hello_agent) {
            warnings.push(format!(
                "Failed to create sample agent {}: {}",
                hello_agent_path.display(),
                e
            ));
        } else {
            info!(path = %hello_agent_path.display(), "Created sample agent");
        }
    }

    // Create README.md at kit root
    let readme_path = kit_dir.join("README.md");
    if !readme_path.exists() {
        let readme = r##"# Script Kit

Welcome to Script Kit! This directory contains your scripts, configuration, and data.

## Directory Structure

```
~/.scriptkit/
‚îú‚îÄ‚îÄ kit/                    # All kits (version control friendly)
‚îÇ   ‚îú‚îÄ‚îÄ main/               # Your default kit
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ scripts/        # TypeScript/JavaScript scripts (.ts, .js)
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ extensions/     # Markdown extension files (.md)
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ agents/         # AI agent definitions (.md)
‚îÇ   ‚îú‚îÄ‚îÄ package.json        # Node.js module config (enables top-level await)
‚îÇ   ‚îî‚îÄ‚îÄ tsconfig.json       # TypeScript path mappings
‚îú‚îÄ‚îÄ sdk/                    # Runtime SDK (managed by app)
‚îú‚îÄ‚îÄ db/                     # Databases (clipboard history, etc.)
‚îú‚îÄ‚îÄ logs/                   # Application logs
‚îú‚îÄ‚îÄ cache/                  # Cached data (app icons, etc.)
‚îú‚îÄ‚îÄ config.ts               # Your configuration
‚îú‚îÄ‚îÄ theme.json              # Theme customization
‚îî‚îÄ‚îÄ README.md               # This file
```

## File Watching

Script Kit watches these files and reloads automatically:

| File/Directory | What happens on change |
|----------------|------------------------|
| `config.ts` | Reloads configuration (hotkeys, settings) |
| `theme.json` | Applies new theme colors immediately |
| `main/scripts/*.ts` | Updates script list and metadata |
| `main/extensions/*.md` | Updates extension list |

## Scripts

Scripts are TypeScript files in `main/scripts/`. They have full access to the Script Kit SDK.

### Example Script

```typescript
// main/scripts/my-script.ts

export const metadata = {
  name: "My Script",
  description: "Does something useful",
  shortcut: "cmd shift m",  // Optional global hotkey
};

// Prompt for input
const choice = await arg("Pick an option", ["Option 1", "Option 2"]);

// Show result
await div(`<div class="p-4">You chose: ${choice}</div>`);
```

### Script Metadata

Use the `metadata` export for type-safe configuration:

```typescript
export const metadata = {
  name: "Script Name",           // Display name in menu
  description: "What it does",   // Shown below the name
  shortcut: "cmd shift x",       // Global hotkey (optional)
  alias: "sn",                   // Quick search alias (optional)
};
```

## Scriptlets

Scriptlets are Markdown files containing quick shell commands. Each code block becomes a menu item.

### Example Scriptlet

```markdown
# My Scriptlets

## Open Project
<!-- shortcut: cmd shift p -->

\`\`\`bash
cd ~/projects/myapp && code .
\`\`\`

## Git Status
<!-- name: Check Git Status -->

\`\`\`bash
git status
\`\`\`
```

### Scriptlet Metadata

Add HTML comments before code blocks:

```markdown
<!-- 
name: Display Name
description: What this does
shortcut: cmd shift x
-->
```

## Configuration (config.ts)

Your `config.ts` controls Script Kit behavior:

```typescript
export default {
  // Global hotkey to open Script Kit
  hotkey: {
    key: "Semicolon",
    modifiers: ["meta"],  // cmd+;
  },
  
  // UI Settings
  editorFontSize: 16,
  terminalFontSize: 14,
  
  // Built-in features
  builtIns: {
    clipboardHistory: true,
    appLauncher: true,
  },
} satisfies Config;
```

## Theme (theme.json)

Customize colors in `theme.json`:

```json
{
  "colors": {
    "background": {
      "main": "#1E1E1E"
    },
    "text": {
      "primary": "#FFFFFF",
      "secondary": "#CCCCCC"
    },
    "accent": {
      "selected": "#FBBF24"
    }
  }
}
```

Colors can be specified as:
- Hex strings: `"#FBBF24"` or `"FBBF24"`
- RGB: `"rgb(251, 191, 36)"`
- RGBA: `"rgba(251, 191, 36, 1.0)"`

## Environment Variable

Set `SK_PATH` to use a different directory:

```bash
export SK_PATH=~/my-scripts
```

## Quick Tips

1. **Create a new script**: Add a `.ts` file to `main/scripts/`
2. **Add a hotkey**: Set `shortcut` in the metadata
3. **Test changes**: Scripts reload automatically on save
4. **View logs**: Check `logs/script-kit-gpui.jsonl` for debugging
5. **Complete guide**: See `GUIDE.md` for comprehensive tutorials and documentation

## Links

- Documentation: https://scriptkit.com/docs
- GitHub: https://github.com/johnlindquist/kit

---

Happy scripting! üöÄ
"##;
        if let Err(e) = fs::write(&readme_path, readme) {
            warnings.push(format!(
                "Failed to create README {}: {}",
                readme_path.display(),
                e
            ));
        } else {
            info!(path = %readme_path.display(), "Created README.md");
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use tempfile::TempDir;

    /// Test that kit directory structure uses kit/ subdirectory
    /// Expected structure: ~/.scriptkit/kit/main/scripts, ~/.scriptkit/kit/main/extensions
    #[test]
    fn test_kit_directory_uses_kit_subdirectory() {
        let temp_dir = TempDir::new().unwrap();
        let kit_root = temp_dir.path().to_path_buf();

        // Set SK_PATH to our temp directory
        std::env::set_var(SK_PATH_ENV, kit_root.to_str().unwrap());

        // Run setup
        let result = ensure_kit_setup();

        // Verify the kit/ subdirectory structure exists
        let kit_main_scripts = kit_root.join("kit").join("main").join("scripts");
        let kit_main_extensions = kit_root.join("kit").join("main").join("extensions");

        assert!(
            kit_main_scripts.exists(),
            "Expected kit/main/scripts to exist at {:?}",
            kit_main_scripts
        );
        assert!(
            kit_main_extensions.exists(),
            "Expected kit/main/extensions to exist at {:?}",
            kit_main_extensions
        );

        // The old structure should NOT exist
        let old_main_scripts = kit_root.join("main").join("scripts");
        assert!(
            !old_main_scripts.exists(),
            "Old structure main/scripts should NOT exist at {:?}",
            old_main_scripts
        );

        // Cleanup
        std::env::remove_var(SK_PATH_ENV);
        assert!(!result.warnings.iter().any(|w| w.contains("Failed")));
    }

    /// Test that sample files are created in kit/main/scripts
    #[test]
    fn test_sample_files_in_kit_subdirectory() {
        let temp_dir = TempDir::new().unwrap();
        let kit_root = temp_dir.path().to_path_buf();

        std::env::set_var(SK_PATH_ENV, kit_root.to_str().unwrap());

        let result = ensure_kit_setup();

        // On fresh install, sample hello-world.ts should be in kit/main/scripts
        if result.is_fresh_install {
            let hello_script = kit_root
                .join("kit")
                .join("main")
                .join("scripts")
                .join("hello-world.ts");
            assert!(
                hello_script.exists(),
                "Expected hello-world.ts at {:?}",
                hello_script
            );
        }

        std::env::remove_var(SK_PATH_ENV);
    }

    #[test]
    fn test_bun_is_discoverable() {
        // This test just verifies the function doesn't panic
        let _ = bun_is_discoverable();
    }

    #[test]
    fn test_bun_exe_name() {
        let name = bun_exe_name();
        #[cfg(windows)]
        assert_eq!(name, "bun.exe");
        #[cfg(not(windows))]
        assert_eq!(name, "bun");
    }

    #[test]
    fn test_get_kit_path_default() {
        // Without SK_PATH set, should return ~/.scriptkit
        std::env::remove_var(SK_PATH_ENV);
        let path = get_kit_path();
        assert!(path.to_string_lossy().contains(".scriptkit"));
    }

    #[test]
    fn test_get_kit_path_with_override() {
        // With SK_PATH set, should return the override
        std::env::set_var(SK_PATH_ENV, "/custom/path");
        let path = get_kit_path();
        assert_eq!(path, PathBuf::from("/custom/path"));
        std::env::remove_var(SK_PATH_ENV);
    }

    #[test]
    fn test_get_kit_path_with_tilde() {
        // SK_PATH with tilde should expand
        std::env::set_var(SK_PATH_ENV, "~/.config/kit");
        let path = get_kit_path();
        assert!(!path.to_string_lossy().contains("~"));
        assert!(path.to_string_lossy().contains(".config/kit"));
        std::env::remove_var(SK_PATH_ENV);
    }

    /// Comprehensive setup verification test
    /// Verifies the complete directory structure matches documentation:
    /// ```
    /// ~/.scriptkit/
    /// ‚îú‚îÄ‚îÄ kit/
    /// ‚îÇ   ‚îú‚îÄ‚îÄ main/
    /// ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ scripts/
    /// ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ extensions/
    /// ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ agents/
    /// ‚îÇ   ‚îú‚îÄ‚îÄ config.ts
    /// ‚îÇ   ‚îú‚îÄ‚îÄ theme.json
    /// ‚îÇ   ‚îú‚îÄ‚îÄ package.json
    /// ‚îÇ   ‚îú‚îÄ‚îÄ tsconfig.json
    /// ‚îÇ   ‚îú‚îÄ‚îÄ AGENTS.md
    /// ‚îÇ   ‚îî‚îÄ‚îÄ CLAUDE.md
    /// ‚îú‚îÄ‚îÄ sdk/
    /// ‚îÇ   ‚îî‚îÄ‚îÄ kit-sdk.ts
    /// ‚îú‚îÄ‚îÄ db/
    /// ‚îú‚îÄ‚îÄ logs/
    /// ‚îú‚îÄ‚îÄ cache/
    /// ‚îî‚îÄ‚îÄ GUIDE.md
    /// ```
    #[test]
    fn test_complete_setup_structure() {
        let temp_dir = TempDir::new().unwrap();
        // Use a subdirectory that definitely doesn't exist for fresh install detection
        let kit_root = temp_dir.path().join("scriptkit-test");

        std::env::set_var(SK_PATH_ENV, kit_root.to_str().unwrap());

        let result = ensure_kit_setup();
        // Don't assert is_fresh_install - just verify the structure is correct
        assert!(
            result.warnings.is_empty() || !result.warnings.iter().any(|w| w.contains("Failed"))
        );

        // Verify kit/ subdirectory structure
        let kit_dir = kit_root.join("kit");
        assert!(kit_dir.exists(), "kit/ directory should exist");

        // Verify main kit directories
        let main_dir = kit_dir.join("main");
        assert!(
            main_dir.join("scripts").exists(),
            "kit/main/scripts/ should exist"
        );
        assert!(
            main_dir.join("extensions").exists(),
            "kit/main/extensions/ should exist"
        );
        assert!(
            main_dir.join("agents").exists(),
            "kit/main/agents/ should exist"
        );

        // Verify user config files in kit/
        assert!(
            kit_dir.join("config.ts").exists(),
            "kit/config.ts should exist"
        );
        assert!(
            kit_dir.join("theme.json").exists(),
            "kit/theme.json should exist"
        );
        assert!(
            kit_dir.join("package.json").exists(),
            "kit/package.json should exist"
        );
        assert!(
            kit_dir.join("tsconfig.json").exists(),
            "kit/tsconfig.json should exist"
        );
        assert!(
            kit_dir.join("AGENTS.md").exists(),
            "kit/AGENTS.md should exist"
        );
        assert!(
            kit_dir.join("CLAUDE.md").exists(),
            "kit/CLAUDE.md should exist"
        );

        // Verify SDK directory
        assert!(
            kit_root.join("sdk").join("kit-sdk.ts").exists(),
            "sdk/kit-sdk.ts should exist"
        );

        // Verify other directories
        assert!(kit_root.join("db").exists(), "db/ directory should exist");
        assert!(
            kit_root.join("logs").exists(),
            "logs/ directory should exist"
        );
        assert!(
            kit_root.join("cache").exists(),
            "cache/ directory should exist"
        );

        // Verify GUIDE.md at root
        assert!(
            kit_root.join("GUIDE.md").exists(),
            "GUIDE.md should exist at root"
        );

        // Verify sample script on fresh install
        let hello_script = main_dir.join("scripts").join("hello-world.ts");
        assert!(
            hello_script.exists(),
            "hello-world.ts sample script should exist"
        );

        // Verify config.ts content
        let config_content = fs::read_to_string(kit_dir.join("config.ts")).unwrap();
        assert!(
            config_content.contains("@scriptkit/sdk"),
            "config.ts should import @scriptkit/sdk"
        );
        assert!(
            config_content.contains("hotkey"),
            "config.ts should have hotkey config"
        );

        // Verify package.json has correct name and type
        let package_content = fs::read_to_string(kit_dir.join("package.json")).unwrap();
        assert!(
            package_content.contains("@scriptkit/kit"),
            "package.json should have @scriptkit/kit name"
        );
        assert!(
            package_content.contains("\"type\": \"module\""),
            "package.json should enable ESM"
        );

        // Verify AGENTS.md content
        let agents_content = fs::read_to_string(kit_dir.join("AGENTS.md")).unwrap();
        assert!(
            agents_content.contains("Script Kit"),
            "AGENTS.md should mention Script Kit"
        );
        assert!(
            agents_content.contains("~/.scriptkit/kit/config.ts"),
            "AGENTS.md should have correct config path"
        );

        // Verify CLAUDE.md content
        let claude_content = fs::read_to_string(kit_dir.join("CLAUDE.md")).unwrap();
        assert!(
            claude_content.contains("Script Kit GPUI"),
            "CLAUDE.md should mention Script Kit GPUI"
        );
        assert!(
            claude_content.contains("NOT the original Script Kit"),
            "CLAUDE.md should warn about v1 vs v2"
        );

        std::env::remove_var(SK_PATH_ENV);
    }

    /// Test that paths in AGENTS.md match actual setup paths
    #[test]
    fn test_agents_md_paths_match_setup() {
        let temp_dir = TempDir::new().unwrap();
        let kit_root = temp_dir.path().to_path_buf();

        std::env::set_var(SK_PATH_ENV, kit_root.to_str().unwrap());
        let _ = ensure_kit_setup();

        let agents_content = fs::read_to_string(kit_root.join("kit").join("AGENTS.md")).unwrap();

        // Verify documented paths actually exist
        let documented_paths = [
            ("kit/main/scripts", "~/.scriptkit/kit/main/scripts/"),
            ("kit/main/extensions", "~/.scriptkit/kit/main/extensions/"),
            ("kit/config.ts", "~/.scriptkit/kit/config.ts"),
            ("kit/theme.json", "~/.scriptkit/kit/theme.json"),
            ("sdk/kit-sdk.ts", "~/.scriptkit/sdk/"),
        ];

        for (relative_path, doc_path) in documented_paths {
            assert!(
                agents_content.contains(doc_path),
                "AGENTS.md should document path: {}",
                doc_path
            );

            let actual_path = kit_root.join(relative_path);
            // For directories, check they exist; for files, check the parent exists
            if relative_path.contains('.') {
                assert!(
                    actual_path.exists(),
                    "Documented path {} should exist as file: {:?}",
                    doc_path,
                    actual_path
                );
            } else {
                assert!(
                    actual_path.exists(),
                    "Documented path {} should exist as directory: {:?}",
                    doc_path,
                    actual_path
                );
            }
        }

        std::env::remove_var(SK_PATH_ENV);
    }
}

</file>

<file path="src/watcher.rs">
#![allow(dead_code)]
use notify::{recommended_watcher, RecursiveMode, Result as NotifyResult, Watcher};
use std::collections::HashMap;
use std::ffi::OsString;
use std::path::PathBuf;
use std::sync::mpsc::{channel, Receiver, RecvTimeoutError, Sender};
use std::thread;
use std::time::{Duration, Instant};

use std::process::Command;
use tracing::{debug, info, warn};

/// Internal control messages for watcher threads
enum ControlMsg {
    /// Signal from notify callback with a file event
    Notify(notify::Result<notify::Event>),
    /// Signal to stop the watcher thread
    Stop,
}

/// Debounce configuration
const DEBOUNCE_MS: u64 = 500;
/// Storm threshold: if more than this many unique paths pending, collapse to FullReload
const STORM_THRESHOLD: usize = 200;
/// Initial backoff delay for supervisor restart (ms)
const INITIAL_BACKOFF_MS: u64 = 100;
/// Maximum backoff delay for supervisor restart (ms)
const MAX_BACKOFF_MS: u64 = 30_000; // 30 seconds
/// Maximum consecutive notify errors before logging warning
const MAX_NOTIFY_ERRORS: u32 = 10;

/// Check if an event kind is relevant (not just Access events)
fn is_relevant_event_kind(kind: &notify::EventKind) -> bool {
    !matches!(kind, notify::EventKind::Access(_))
}

/// Compute exponential backoff delay, capped at MAX_BACKOFF_MS
fn compute_backoff(attempt: u32) -> Duration {
    let delay_ms = INITIAL_BACKOFF_MS.saturating_mul(2u64.saturating_pow(attempt));
    Duration::from_millis(delay_ms.min(MAX_BACKOFF_MS))
}

/// Sleep with interruptible checks against a stop flag
/// Returns true if sleep completed, false if stop was signaled
fn interruptible_sleep(duration: Duration, stop_flag: &std::sync::atomic::AtomicBool) -> bool {
    let check_interval = Duration::from_millis(100);
    let mut remaining = duration;

    while remaining > Duration::ZERO {
        if stop_flag.load(std::sync::atomic::Ordering::Relaxed) {
            return false;
        }
        let sleep_time = remaining.min(check_interval);
        thread::sleep(sleep_time);
        remaining = remaining.saturating_sub(sleep_time);
    }
    true
}

/// Event emitted when config needs to be reloaded
#[derive(Debug, Clone)]
pub enum ConfigReloadEvent {
    Reload,
}

/// Event emitted when theme needs to be reloaded
#[derive(Debug, Clone)]
pub enum ThemeReloadEvent {
    Reload,
}

/// Event emitted when scripts need to be reloaded
#[derive(Debug, Clone, PartialEq, Eq)]
pub enum ScriptReloadEvent {
    /// A specific file was modified
    FileChanged(PathBuf),
    /// A new file was created
    FileCreated(PathBuf),
    /// A file was deleted
    FileDeleted(PathBuf),
    /// Fallback for complex events (e.g., bulk changes, renames)
    FullReload,
}

/// Event emitted when system appearance changes (light/dark mode)
#[derive(Debug, Clone, PartialEq, Eq)]
pub enum AppearanceChangeEvent {
    /// Dark mode is now active
    Dark,
    /// Light mode is now active
    Light,
}

/// Watches ~/.scriptkit/kit/config.ts for changes and emits reload events
///
/// Uses trailing-edge debounce: each new event resets the deadline.
/// Handles atomic saves (rename/remove operations).
/// Properly shuts down via Stop control message.
/// Includes supervisor restart with exponential backoff on transient errors.
pub struct ConfigWatcher {
    tx: Option<Sender<ConfigReloadEvent>>,
    stop_flag: Option<std::sync::Arc<std::sync::atomic::AtomicBool>>,
    watcher_thread: Option<thread::JoinHandle<()>>,
}

impl ConfigWatcher {
    /// Create a new ConfigWatcher
    ///
    /// Returns a tuple of (watcher, receiver) where receiver will emit ConfigReloadEvent
    /// when the config file changes.
    pub fn new() -> (Self, Receiver<ConfigReloadEvent>) {
        let (tx, rx) = channel();
        let watcher = ConfigWatcher {
            tx: Some(tx),
            stop_flag: None,
            watcher_thread: None,
        };
        (watcher, rx)
    }

    /// Start watching the config file for changes
    ///
    /// This spawns a background thread that watches ~/.scriptkit/kit/config.ts and sends
    /// reload events through the receiver when changes are detected.
    /// On transient errors, the watcher will retry with exponential backoff.
    pub fn start(&mut self) -> NotifyResult<()> {
        let tx = self
            .tx
            .take()
            .ok_or_else(|| std::io::Error::other("watcher already started"))?;

        let stop_flag = std::sync::Arc::new(std::sync::atomic::AtomicBool::new(false));
        let thread_stop_flag = stop_flag.clone();
        self.stop_flag = Some(stop_flag);

        let target_path = PathBuf::from(shellexpand::tilde("~/.scriptkit/kit/config.ts").as_ref());

        let thread_handle = thread::spawn(move || {
            Self::supervisor_loop(target_path, tx, thread_stop_flag);
        });

        self.watcher_thread = Some(thread_handle);
        Ok(())
    }

    /// Supervisor loop that restarts the watcher on failures with exponential backoff
    fn supervisor_loop(
        target_path: PathBuf,
        out_tx: Sender<ConfigReloadEvent>,
        stop_flag: std::sync::Arc<std::sync::atomic::AtomicBool>,
    ) {
        let mut attempt: u32 = 0;

        loop {
            if stop_flag.load(std::sync::atomic::Ordering::Relaxed) {
                info!(watcher = "config", "Config watcher supervisor stopping");
                break;
            }

            // Create channels for this watch attempt
            let (control_tx, control_rx) = channel::<ControlMsg>();

            match Self::watch_loop(
                target_path.clone(),
                out_tx.clone(),
                control_rx,
                control_tx,
                stop_flag.clone(),
            ) {
                Ok(()) => {
                    // Normal shutdown (via stop flag)
                    info!(watcher = "config", "Config watcher completed normally");
                    break;
                }
                Err(e) => {
                    if stop_flag.load(std::sync::atomic::Ordering::Relaxed) {
                        break;
                    }

                    let backoff = compute_backoff(attempt);
                    warn!(
                        error = %e,
                        watcher = "config",
                        attempt = attempt,
                        backoff_ms = backoff.as_millis(),
                        "Config watcher error, retrying with backoff"
                    );

                    if !interruptible_sleep(backoff, &stop_flag) {
                        break;
                    }
                    attempt = attempt.saturating_add(1);
                }
            }
        }

        info!(
            watcher = "config",
            "Config watcher supervisor shutting down"
        );
    }

    /// Internal watch loop running in background thread
    fn watch_loop(
        target_path: PathBuf,
        out_tx: Sender<ConfigReloadEvent>,
        control_rx: Receiver<ControlMsg>,
        callback_tx: Sender<ControlMsg>,
        stop_flag: std::sync::Arc<std::sync::atomic::AtomicBool>,
    ) -> NotifyResult<()> {
        let target_name: OsString = target_path
            .file_name()
            .unwrap_or_else(|| std::ffi::OsStr::new(""))
            .to_owned();

        let watch_path = target_path
            .parent()
            .unwrap_or_else(|| std::path::Path::new("."));

        // Create the watcher with a callback that forwards to control channel
        let mut watcher: Box<dyn Watcher> = Box::new(recommended_watcher(
            move |res: notify::Result<notify::Event>| {
                let _ = callback_tx.send(ControlMsg::Notify(res));
            },
        )?);

        watcher.watch(watch_path, RecursiveMode::NonRecursive)?;

        info!(
            path = %watch_path.display(),
            target = ?target_name,
            "Config watcher started"
        );

        let mut consecutive_errors: u32 = 0;

        let debounce = Duration::from_millis(DEBOUNCE_MS);
        let mut deadline: Option<Instant> = None;

        loop {
            // Check stop flag before blocking
            if stop_flag.load(std::sync::atomic::Ordering::Relaxed) {
                break;
            }

            // Use a timeout even when no deadline to periodically check stop flag
            let timeout = deadline
                .map(|dl| dl.saturating_duration_since(Instant::now()))
                .unwrap_or(Duration::from_millis(500));

            let msg = match control_rx.recv_timeout(timeout) {
                Ok(m) => Some(m),
                Err(RecvTimeoutError::Timeout) => {
                    if let Some(dl) = deadline {
                        if Instant::now() >= dl {
                            // Quiet period ended => emit reload
                            debug!(file = ?target_name, "Config debounce complete, emitting reload");
                            let _ = out_tx.send(ConfigReloadEvent::Reload);
                            info!(file = ?target_name, "Config file changed, emitting reload event");
                            deadline = None;
                        }
                    }
                    continue;
                }
                Err(RecvTimeoutError::Disconnected) => break,
            };

            let Some(msg) = msg else { continue };

            match msg {
                ControlMsg::Stop => {
                    info!(watcher = "config", "Config watcher received stop signal");
                    break;
                }

                ControlMsg::Notify(Err(e)) => {
                    consecutive_errors = consecutive_errors.saturating_add(1);
                    warn!(
                        error = %e,
                        watcher = "config",
                        consecutive_errors = consecutive_errors,
                        "notify delivered error"
                    );

                    // If too many consecutive errors, return Err to trigger supervisor restart
                    if consecutive_errors >= MAX_NOTIFY_ERRORS {
                        warn!(
                            watcher = "config",
                            consecutive_errors = consecutive_errors,
                            "Too many consecutive errors, triggering restart"
                        );
                        return Err(notify::Error::generic("Too many consecutive notify errors"));
                    }
                }

                ControlMsg::Notify(Ok(event)) => {
                    // Reset error counter on successful event
                    consecutive_errors = 0;

                    // Filter: does this event mention the target filename?
                    let touches_target = event.paths.iter().any(|p| {
                        p.file_name()
                            .map(|n| n == target_name.as_os_str())
                            .unwrap_or(false)
                    });

                    // Treat everything except Access as potentially relevant
                    // This covers atomic saves (remove/rename) too
                    let relevant_kind = is_relevant_event_kind(&event.kind);

                    if touches_target && relevant_kind {
                        // Trailing-edge debounce: reset deadline on every hit
                        debug!(
                            file = ?target_name,
                            event_kind = ?event.kind,
                            "Config change detected, resetting debounce"
                        );
                        deadline = Some(Instant::now() + debounce);
                    }
                }
            }
        }

        info!(watcher = "config", "Config watcher shutting down");
        Ok(())
    }
}

impl Drop for ConfigWatcher {
    fn drop(&mut self) {
        // Signal stop via atomic flag
        if let Some(flag) = self.stop_flag.take() {
            flag.store(true, std::sync::atomic::Ordering::Relaxed);
        }
        // Now join - the thread will exit because stop flag is set
        if let Some(handle) = self.watcher_thread.take() {
            let _ = handle.join();
        }
    }
}

/// Watches ~/.scriptkit/kit/theme.json for changes and emits reload events
///
/// Uses trailing-edge debounce: each new event resets the deadline.
/// Handles atomic saves (rename/remove operations).
/// Properly shuts down via Stop control message.
/// Includes supervisor restart with exponential backoff on transient errors.
pub struct ThemeWatcher {
    tx: Option<Sender<ThemeReloadEvent>>,
    stop_flag: Option<std::sync::Arc<std::sync::atomic::AtomicBool>>,
    watcher_thread: Option<thread::JoinHandle<()>>,
}

impl ThemeWatcher {
    /// Create a new ThemeWatcher
    ///
    /// Returns a tuple of (watcher, receiver) where receiver will emit ThemeReloadEvent
    /// when the theme file changes.
    pub fn new() -> (Self, Receiver<ThemeReloadEvent>) {
        let (tx, rx) = channel();
        let watcher = ThemeWatcher {
            tx: Some(tx),
            stop_flag: None,
            watcher_thread: None,
        };
        (watcher, rx)
    }

    /// Start watching the theme file for changes
    ///
    /// This spawns a background thread that watches ~/.scriptkit/kit/theme.json and sends
    /// reload events through the receiver when changes are detected.
    /// On transient errors, the watcher will retry with exponential backoff.
    pub fn start(&mut self) -> NotifyResult<()> {
        let tx = self
            .tx
            .take()
            .ok_or_else(|| std::io::Error::other("watcher already started"))?;

        let stop_flag = std::sync::Arc::new(std::sync::atomic::AtomicBool::new(false));
        let thread_stop_flag = stop_flag.clone();
        self.stop_flag = Some(stop_flag);

        let target_path = PathBuf::from(shellexpand::tilde("~/.scriptkit/kit/theme.json").as_ref());

        let thread_handle = thread::spawn(move || {
            Self::supervisor_loop(target_path, tx, thread_stop_flag);
        });

        self.watcher_thread = Some(thread_handle);
        Ok(())
    }

    /// Supervisor loop that restarts the watcher on failures with exponential backoff
    fn supervisor_loop(
        target_path: PathBuf,
        out_tx: Sender<ThemeReloadEvent>,
        stop_flag: std::sync::Arc<std::sync::atomic::AtomicBool>,
    ) {
        let mut attempt: u32 = 0;

        loop {
            if stop_flag.load(std::sync::atomic::Ordering::Relaxed) {
                info!(watcher = "theme", "Theme watcher supervisor stopping");
                break;
            }

            let (control_tx, control_rx) = channel::<ControlMsg>();

            match Self::watch_loop(
                target_path.clone(),
                out_tx.clone(),
                control_rx,
                control_tx,
                stop_flag.clone(),
            ) {
                Ok(()) => {
                    info!(watcher = "theme", "Theme watcher completed normally");
                    break;
                }
                Err(e) => {
                    if stop_flag.load(std::sync::atomic::Ordering::Relaxed) {
                        break;
                    }

                    let backoff = compute_backoff(attempt);
                    warn!(
                        error = %e,
                        watcher = "theme",
                        attempt = attempt,
                        backoff_ms = backoff.as_millis(),
                        "Theme watcher error, retrying with backoff"
                    );

                    if !interruptible_sleep(backoff, &stop_flag) {
                        break;
                    }
                    attempt = attempt.saturating_add(1);
                }
            }
        }

        info!(watcher = "theme", "Theme watcher supervisor shutting down");
    }

    /// Internal watch loop running in background thread
    fn watch_loop(
        target_path: PathBuf,
        out_tx: Sender<ThemeReloadEvent>,
        control_rx: Receiver<ControlMsg>,
        callback_tx: Sender<ControlMsg>,
        stop_flag: std::sync::Arc<std::sync::atomic::AtomicBool>,
    ) -> NotifyResult<()> {
        let target_name: OsString = target_path
            .file_name()
            .unwrap_or_else(|| std::ffi::OsStr::new(""))
            .to_owned();

        let watch_path = target_path
            .parent()
            .unwrap_or_else(|| std::path::Path::new("."));

        let mut watcher: Box<dyn Watcher> = Box::new(recommended_watcher(
            move |res: notify::Result<notify::Event>| {
                let _ = callback_tx.send(ControlMsg::Notify(res));
            },
        )?);

        watcher.watch(watch_path, RecursiveMode::NonRecursive)?;

        info!(
            path = %watch_path.display(),
            target = ?target_name,
            "Theme watcher started"
        );

        let mut consecutive_errors: u32 = 0;
        let debounce = Duration::from_millis(DEBOUNCE_MS);
        let mut deadline: Option<Instant> = None;

        loop {
            if stop_flag.load(std::sync::atomic::Ordering::Relaxed) {
                break;
            }

            let timeout = deadline
                .map(|dl| dl.saturating_duration_since(Instant::now()))
                .unwrap_or(Duration::from_millis(500));

            let msg = match control_rx.recv_timeout(timeout) {
                Ok(m) => Some(m),
                Err(RecvTimeoutError::Timeout) => {
                    if let Some(dl) = deadline {
                        if Instant::now() >= dl {
                            debug!(file = ?target_name, "Theme debounce complete, emitting reload");
                            let _ = out_tx.send(ThemeReloadEvent::Reload);
                            info!(file = ?target_name, "Theme file changed, emitting reload event");
                            deadline = None;
                        }
                    }
                    continue;
                }
                Err(RecvTimeoutError::Disconnected) => break,
            };

            let Some(msg) = msg else { continue };

            match msg {
                ControlMsg::Stop => {
                    info!(watcher = "theme", "Theme watcher received stop signal");
                    break;
                }

                ControlMsg::Notify(Err(e)) => {
                    consecutive_errors = consecutive_errors.saturating_add(1);
                    warn!(
                        error = %e,
                        watcher = "theme",
                        consecutive_errors = consecutive_errors,
                        "notify delivered error"
                    );

                    if consecutive_errors >= MAX_NOTIFY_ERRORS {
                        warn!(
                            watcher = "theme",
                            consecutive_errors = consecutive_errors,
                            "Too many consecutive errors, triggering restart"
                        );
                        return Err(notify::Error::generic("Too many consecutive notify errors"));
                    }
                }

                ControlMsg::Notify(Ok(event)) => {
                    consecutive_errors = 0;

                    let touches_target = event.paths.iter().any(|p| {
                        p.file_name()
                            .map(|n| n == target_name.as_os_str())
                            .unwrap_or(false)
                    });

                    let relevant_kind = is_relevant_event_kind(&event.kind);

                    if touches_target && relevant_kind {
                        debug!(
                            file = ?target_name,
                            event_kind = ?event.kind,
                            "Theme change detected, resetting debounce"
                        );
                        deadline = Some(Instant::now() + debounce);
                    }
                }
            }
        }

        info!(watcher = "theme", "Theme watcher shutting down");
        Ok(())
    }
}

impl Drop for ThemeWatcher {
    fn drop(&mut self) {
        if let Some(flag) = self.stop_flag.take() {
            flag.store(true, std::sync::atomic::Ordering::Relaxed);
        }
        if let Some(handle) = self.watcher_thread.take() {
            let _ = handle.join();
        }
    }
}

/// Check if a file path is a relevant script file (ts, js, or md)
fn is_relevant_script_file(path: &std::path::Path) -> bool {
    // Skip hidden files
    if let Some(file_name) = path.file_name().and_then(|n| n.to_str()) {
        if file_name.starts_with('.') {
            return false;
        }
    }

    // Check for relevant extensions
    matches!(
        path.extension().and_then(|ext| ext.to_str()),
        Some("ts") | Some("js") | Some("md")
    )
}

/// Compute the next deadline from pending events and global full_reload_at
fn next_deadline(
    pending: &HashMap<PathBuf, (ScriptReloadEvent, Instant)>,
    full_reload_at: Option<Instant>,
    debounce: Duration,
) -> Option<Instant> {
    let pending_deadline = pending.values().map(|(_, t)| *t + debounce).min();
    let full_reload_deadline = full_reload_at.map(|t| t + debounce);

    match (pending_deadline, full_reload_deadline) {
        (Some(p), Some(f)) => Some(p.min(f)),
        (Some(p), None) => Some(p),
        (None, Some(f)) => Some(f),
        (None, None) => None,
    }
}

/// Flush expired events from pending map and global full_reload_at
///
/// If full_reload_at has expired, emits a single FullReload and clears pending.
/// Otherwise, flushes individual expired events from pending.
fn flush_expired(
    pending: &mut HashMap<PathBuf, (ScriptReloadEvent, Instant)>,
    full_reload_at: &mut Option<Instant>,
    debounce: Duration,
    out_tx: &Sender<ScriptReloadEvent>,
) {
    let now = Instant::now();

    // Check global full_reload_at first - it supersedes all pending events
    if let Some(reload_time) = *full_reload_at {
        if now.duration_since(reload_time) >= debounce {
            debug!("FullReload debounce complete, flushing");
            info!(event = ?ScriptReloadEvent::FullReload, "Emitting script reload event");
            let _ = out_tx.send(ScriptReloadEvent::FullReload);
            *full_reload_at = None;
            pending.clear(); // Clear any remaining pending - superseded by FullReload
            return;
        }
    }

    // Flush individual expired events
    let mut to_send: Vec<ScriptReloadEvent> = Vec::new();

    pending.retain(|path, (ev, t)| {
        if now.duration_since(*t) >= debounce {
            debug!(path = %path.display(), event = ?ev, "Script debounce complete, flushing");
            to_send.push(ev.clone());
            false
        } else {
            true
        }
    });

    for ev in to_send {
        info!(event = ?ev, "Emitting script reload event");
        let _ = out_tx.send(ev);
    }
}

/// Watches ~/.scriptkit/kit/*/scripts and ~/.scriptkit/kit/*/extensions directories for changes
///
/// Uses per-file trailing-edge debounce with storm coalescing.
/// No separate flush thread - all debouncing in single recv_timeout loop.
/// Properly shuts down via Stop control message.
/// Includes supervisor restart with exponential backoff on transient errors.
/// Dynamically watches extensions directory when it appears.
pub struct ScriptWatcher {
    tx: Option<Sender<ScriptReloadEvent>>,
    stop_flag: Option<std::sync::Arc<std::sync::atomic::AtomicBool>>,
    watcher_thread: Option<thread::JoinHandle<()>>,
}

impl ScriptWatcher {
    /// Create a new ScriptWatcher
    ///
    /// Returns a tuple of (watcher, receiver) where receiver will emit ScriptReloadEvent
    /// when files in the scripts directory change.
    pub fn new() -> (Self, Receiver<ScriptReloadEvent>) {
        let (tx, rx) = channel();
        let watcher = ScriptWatcher {
            tx: Some(tx),
            stop_flag: None,
            watcher_thread: None,
        };
        (watcher, rx)
    }

    /// Start watching the scripts directory for changes
    ///
    /// This spawns a background thread that watches ~/.scriptkit/scripts recursively and sends
    /// reload events through the receiver when scripts are added, modified, or deleted.
    /// On transient errors, the watcher will retry with exponential backoff.
    pub fn start(&mut self) -> NotifyResult<()> {
        let tx = self
            .tx
            .take()
            .ok_or_else(|| std::io::Error::other("watcher already started"))?;

        let stop_flag = std::sync::Arc::new(std::sync::atomic::AtomicBool::new(false));
        let thread_stop_flag = stop_flag.clone();
        self.stop_flag = Some(stop_flag);

        let scripts_path =
            PathBuf::from(shellexpand::tilde("~/.scriptkit/kit/main/scripts").as_ref());
        let extensions_path =
            PathBuf::from(shellexpand::tilde("~/.scriptkit/kit/main/extensions").as_ref());

        let thread_handle = thread::spawn(move || {
            Self::supervisor_loop(scripts_path, extensions_path, tx, thread_stop_flag);
        });

        self.watcher_thread = Some(thread_handle);
        Ok(())
    }

    /// Supervisor loop that restarts the watcher on failures with exponential backoff
    fn supervisor_loop(
        scripts_path: PathBuf,
        extensions_path: PathBuf,
        out_tx: Sender<ScriptReloadEvent>,
        stop_flag: std::sync::Arc<std::sync::atomic::AtomicBool>,
    ) {
        let mut attempt: u32 = 0;

        loop {
            if stop_flag.load(std::sync::atomic::Ordering::Relaxed) {
                info!(watcher = "scripts", "Script watcher supervisor stopping");
                break;
            }

            let (control_tx, control_rx) = channel::<ControlMsg>();

            match Self::watch_loop(
                scripts_path.clone(),
                extensions_path.clone(),
                out_tx.clone(),
                control_rx,
                control_tx,
                stop_flag.clone(),
            ) {
                Ok(()) => {
                    info!(watcher = "scripts", "Script watcher completed normally");
                    break;
                }
                Err(e) => {
                    if stop_flag.load(std::sync::atomic::Ordering::Relaxed) {
                        break;
                    }

                    let backoff = compute_backoff(attempt);
                    warn!(
                        error = %e,
                        watcher = "scripts",
                        attempt = attempt,
                        backoff_ms = backoff.as_millis(),
                        "Script watcher error, retrying with backoff"
                    );

                    if !interruptible_sleep(backoff, &stop_flag) {
                        break;
                    }
                    attempt = attempt.saturating_add(1);
                }
            }
        }

        info!(
            watcher = "scripts",
            "Script watcher supervisor shutting down"
        );
    }

    /// Internal watch loop running in background thread
    fn watch_loop(
        scripts_path: PathBuf,
        extensions_path: PathBuf,
        out_tx: Sender<ScriptReloadEvent>,
        control_rx: Receiver<ControlMsg>,
        callback_tx: Sender<ControlMsg>,
        stop_flag: std::sync::Arc<std::sync::atomic::AtomicBool>,
    ) -> NotifyResult<()> {
        let mut watcher: Box<dyn Watcher> = Box::new(recommended_watcher({
            let tx = callback_tx.clone();
            move |res: notify::Result<notify::Event>| {
                let _ = tx.send(ControlMsg::Notify(res));
            }
        })?);

        watcher.watch(&scripts_path, RecursiveMode::Recursive)?;

        // Track whether we're watching extensions directory
        let mut watching_extensions = false;
        if extensions_path.exists() {
            watcher.watch(&extensions_path, RecursiveMode::Recursive)?;
            watching_extensions = true;
            info!(
                path = %extensions_path.display(),
                recursive = true,
                "Scriptlets watcher started"
            );
        }

        // Also watch the parent directory (main/) for extensions dir creation
        let main_path = extensions_path.parent().map(|p| p.to_path_buf());
        if let Some(ref main) = main_path {
            if main.exists() && !watching_extensions {
                // Watch parent non-recursively to detect extensions dir creation
                let _ = watcher.watch(main, RecursiveMode::NonRecursive);
                debug!(
                    path = %main.display(),
                    "Watching main directory for extensions creation"
                );
            }
        }

        info!(
            path = %scripts_path.display(),
            recursive = true,
            "Script watcher started"
        );

        let mut consecutive_errors: u32 = 0;
        let debounce = Duration::from_millis(DEBOUNCE_MS);
        let mut pending: HashMap<PathBuf, (ScriptReloadEvent, Instant)> = HashMap::new();
        // Global FullReload state: when set, supersedes all per-file events
        // This prevents multiple FullReload emissions during event storms
        let mut full_reload_at: Option<Instant> = None;

        loop {
            if stop_flag.load(std::sync::atomic::Ordering::Relaxed) {
                break;
            }

            // Use a max timeout to periodically check stop flag
            let deadline = next_deadline(&pending, full_reload_at, debounce);
            let timeout = deadline
                .map(|dl| dl.saturating_duration_since(Instant::now()))
                .unwrap_or(Duration::from_millis(500));

            let msg = match control_rx.recv_timeout(timeout) {
                Ok(m) => Some(m),
                Err(RecvTimeoutError::Timeout) => {
                    flush_expired(&mut pending, &mut full_reload_at, debounce, &out_tx);
                    continue;
                }
                Err(RecvTimeoutError::Disconnected) => break,
            };

            let Some(msg) = msg else { continue };

            match msg {
                ControlMsg::Stop => {
                    info!(watcher = "scripts", "Script watcher received stop signal");
                    break;
                }

                ControlMsg::Notify(Err(e)) => {
                    consecutive_errors = consecutive_errors.saturating_add(1);
                    warn!(
                        error = %e,
                        watcher = "scripts",
                        consecutive_errors = consecutive_errors,
                        "notify delivered error"
                    );

                    if consecutive_errors >= MAX_NOTIFY_ERRORS {
                        warn!(
                            watcher = "scripts",
                            consecutive_errors = consecutive_errors,
                            "Too many consecutive errors, triggering restart"
                        );
                        return Err(notify::Error::generic("Too many consecutive notify errors"));
                    }
                }

                ControlMsg::Notify(Ok(event)) => {
                    consecutive_errors = 0;
                    let kind = &event.kind;

                    // Check if extensions directory was created
                    if !watching_extensions && extensions_path.exists() {
                        if let Err(e) = watcher.watch(&extensions_path, RecursiveMode::Recursive) {
                            warn!(
                                error = %e,
                                path = %extensions_path.display(),
                                "Failed to start watching extensions directory"
                            );
                        } else {
                            watching_extensions = true;
                            info!(
                                path = %extensions_path.display(),
                                "Extensions directory appeared, now watching"
                            );
                        }
                    }

                    for path in event.paths.iter() {
                        if !is_relevant_script_file(path) {
                            continue;
                        }

                        let now = Instant::now();

                        // Handle event types
                        match kind {
                            notify::EventKind::Create(_) => {
                                debug!(
                                    path = %path.display(),
                                    event_kind = ?kind,
                                    "Script change detected (create), merging event"
                                );
                                // Use merge_script_event to handle atomic saves
                                merge_script_event(
                                    &mut pending,
                                    path,
                                    ScriptReloadEvent::FileCreated(path.clone()),
                                    now,
                                );
                            }
                            notify::EventKind::Modify(_) => {
                                debug!(
                                    path = %path.display(),
                                    event_kind = ?kind,
                                    "Script change detected (modify), updating pending"
                                );
                                pending.insert(
                                    path.clone(),
                                    (ScriptReloadEvent::FileChanged(path.clone()), now),
                                );
                            }
                            notify::EventKind::Remove(_) => {
                                debug!(
                                    path = %path.display(),
                                    event_kind = ?kind,
                                    "Script change detected (remove), merging event"
                                );
                                // Use merge_script_event to handle atomic saves
                                merge_script_event(
                                    &mut pending,
                                    path,
                                    ScriptReloadEvent::FileDeleted(path.clone()),
                                    now,
                                );
                            }
                            // Access events are not relevant
                            notify::EventKind::Access(_) => continue,
                            // For Other/Any events, trigger global FullReload
                            _ => {
                                debug!(
                                    path = %path.display(),
                                    event_kind = ?kind,
                                    "Unknown event kind, triggering global FullReload"
                                );
                                // Set global FullReload state and clear pending
                                // This ensures only ONE FullReload is emitted after debounce
                                full_reload_at = Some(now);
                                pending.clear();
                            }
                        }

                        // Storm coalescing: if too many pending events, collapse to FullReload
                        if pending.len() >= STORM_THRESHOLD {
                            warn!(
                                pending_count = pending.len(),
                                threshold = STORM_THRESHOLD,
                                "Event storm detected, collapsing to FullReload"
                            );
                            // Set global FullReload instead of immediate emission
                            // This ensures proper debounce even during storms
                            full_reload_at = Some(Instant::now());
                            pending.clear();
                        }
                    }
                }
            }
        }

        info!(watcher = "scripts", "Script watcher shutting down");
        Ok(())
    }
}

impl Drop for ScriptWatcher {
    fn drop(&mut self) {
        if let Some(flag) = self.stop_flag.take() {
            flag.store(true, std::sync::atomic::Ordering::Relaxed);
        }
        if let Some(handle) = self.watcher_thread.take() {
            let _ = handle.join();
        }
    }
}

/// Watches system appearance (light/dark mode) for changes and emits events
///
/// This watcher polls the system appearance setting every 2 seconds by running
/// the `defaults read -g AppleInterfaceStyle` command on macOS.
///
/// Properly shuts down via stop flag.
pub struct AppearanceWatcher {
    tx: Option<async_channel::Sender<AppearanceChangeEvent>>,
    stop_flag: Option<std::sync::Arc<std::sync::atomic::AtomicBool>>,
    watcher_thread: Option<thread::JoinHandle<()>>,
}

impl AppearanceWatcher {
    /// Create a new AppearanceWatcher
    ///
    /// Returns a tuple of (watcher, receiver) where receiver will emit AppearanceChangeEvent
    /// when the system appearance changes.
    pub fn new() -> (Self, async_channel::Receiver<AppearanceChangeEvent>) {
        let (tx, rx) = async_channel::bounded(100);
        let watcher = AppearanceWatcher {
            tx: Some(tx),
            stop_flag: None,
            watcher_thread: None,
        };
        (watcher, rx)
    }

    /// Start watching the system appearance for changes
    ///
    /// This spawns a background thread that polls the system appearance every 2 seconds
    /// and sends appearance change events through the receiver when changes are detected.
    pub fn start(&mut self) -> Result<(), String> {
        let tx = self
            .tx
            .take()
            .ok_or_else(|| "watcher already started".to_string())?;

        let stop_flag = std::sync::Arc::new(std::sync::atomic::AtomicBool::new(false));
        let thread_stop_flag = stop_flag.clone();
        self.stop_flag = Some(stop_flag);

        let thread_handle = thread::spawn(move || {
            if let Err(e) = Self::watch_loop(tx, thread_stop_flag) {
                warn!(error = %e, watcher = "appearance", "Appearance watcher error");
            }
        });

        self.watcher_thread = Some(thread_handle);
        Ok(())
    }

    /// Internal watch loop running in background thread
    fn watch_loop(
        tx: async_channel::Sender<AppearanceChangeEvent>,
        stop_flag: std::sync::Arc<std::sync::atomic::AtomicBool>,
    ) -> Result<(), String> {
        let mut last_appearance: Option<AppearanceChangeEvent> = None;

        info!(poll_interval_secs = 2, "Appearance watcher started");

        loop {
            // Check stop flag first
            if stop_flag.load(std::sync::atomic::Ordering::Relaxed) {
                info!(
                    watcher = "appearance",
                    "Appearance watcher received stop signal"
                );
                break;
            }

            // Detect current system appearance
            let current_appearance = Self::detect_appearance();

            // Send event if appearance changed
            if last_appearance != Some(current_appearance.clone()) {
                let mode = match current_appearance {
                    AppearanceChangeEvent::Dark => "dark",
                    AppearanceChangeEvent::Light => "light",
                };
                info!(mode = mode, "System appearance changed");
                if tx.send_blocking(current_appearance.clone()).is_err() {
                    info!(
                        watcher = "appearance",
                        "Appearance watcher receiver dropped, shutting down"
                    );
                    break;
                }
                last_appearance = Some(current_appearance);
            }

            // Poll with interruptible sleep (check stop flag more frequently)
            for _ in 0..20 {
                // 20 * 100ms = 2s
                if stop_flag.load(std::sync::atomic::Ordering::Relaxed) {
                    info!(
                        watcher = "appearance",
                        "Appearance watcher received stop signal during sleep"
                    );
                    return Ok(());
                }
                thread::sleep(Duration::from_millis(100));
            }
        }

        info!(watcher = "appearance", "Appearance watcher shutting down");
        Ok(())
    }

    /// Detect the current system appearance
    fn detect_appearance() -> AppearanceChangeEvent {
        match Command::new("defaults")
            .args(["read", "-g", "AppleInterfaceStyle"])
            .output()
        {
            Ok(output) => {
                let stdout = String::from_utf8_lossy(&output.stdout);
                if stdout.to_lowercase().contains("dark") {
                    AppearanceChangeEvent::Dark
                } else {
                    AppearanceChangeEvent::Light
                }
            }
            Err(_) => {
                // Command failed, likely in light mode on macOS
                AppearanceChangeEvent::Light
            }
        }
    }
}

impl Drop for AppearanceWatcher {
    fn drop(&mut self) {
        // Signal stop
        if let Some(flag) = self.stop_flag.take() {
            flag.store(true, std::sync::atomic::Ordering::Relaxed);
        }
        // Wait for thread to finish
        if let Some(handle) = self.watcher_thread.take() {
            let _ = handle.join();
        }
    }
}

/// Merge create/delete event pairs for the same path into FileChanged (atomic save handling)
///
/// Editors often save files via temp file ‚Üí rename, causing Delete+Create sequences.
/// Within the debounce window, we merge these into FileChanged.
fn merge_script_event(
    pending: &mut HashMap<PathBuf, (ScriptReloadEvent, Instant)>,
    path: &PathBuf,
    new_event: ScriptReloadEvent,
    timestamp: Instant,
) {
    if let Some((existing_event, _existing_time)) = pending.get(path) {
        // Check if we can merge:
        // FileDeleted + FileCreated ‚Üí FileChanged (file was atomically saved)
        // FileCreated + FileDeleted ‚Üí FileChanged (temp file dance)
        let merged = match (&existing_event, &new_event) {
            (ScriptReloadEvent::FileDeleted(_), ScriptReloadEvent::FileCreated(_))
            | (ScriptReloadEvent::FileCreated(_), ScriptReloadEvent::FileDeleted(_)) => {
                Some(ScriptReloadEvent::FileChanged(path.clone()))
            }
            _ => None,
        };

        if let Some(merged_event) = merged {
            pending.insert(path.clone(), (merged_event, timestamp));
            return;
        }
    }

    // No merge - insert new event
    pending.insert(path.clone(), (new_event, timestamp));
}

/// Event emitted when applications need to be reloaded
#[derive(Debug, Clone, PartialEq, Eq)]
pub enum AppReloadEvent {
    /// A new .app bundle was added
    AppAdded(PathBuf),
    /// An .app bundle was removed
    AppRemoved(PathBuf),
    /// An .app bundle was updated (modified)
    AppUpdated(PathBuf),
    /// Fallback for complex events (e.g., bulk changes)
    FullReload,
}

/// Check if a path is a .app bundle directory
fn is_app_bundle(path: &std::path::Path) -> bool {
    // Must end in .app extension
    if let Some(ext) = path.extension() {
        if ext == "app" {
            // Additionally check it's a directory (when it exists)
            // For remove events, the path may not exist anymore
            return path.is_dir() || !path.exists();
        }
    }
    false
}

/// Compute the next deadline from pending app events and global full_reload_at
fn next_app_deadline(
    pending: &HashMap<PathBuf, (AppReloadEvent, Instant)>,
    full_reload_at: Option<Instant>,
    debounce: Duration,
) -> Option<Instant> {
    let pending_deadline = pending.values().map(|(_, t)| *t + debounce).min();
    let full_reload_deadline = full_reload_at.map(|t| t + debounce);

    match (pending_deadline, full_reload_deadline) {
        (Some(p), Some(f)) => Some(p.min(f)),
        (Some(p), None) => Some(p),
        (None, Some(f)) => Some(f),
        (None, None) => None,
    }
}

/// Flush expired app events from pending map and global full_reload_at
///
/// If full_reload_at has expired, emits a single FullReload and clears pending.
/// Otherwise, flushes individual expired events from pending.
fn flush_expired_apps(
    pending: &mut HashMap<PathBuf, (AppReloadEvent, Instant)>,
    full_reload_at: &mut Option<Instant>,
    debounce: Duration,
    out_tx: &async_channel::Sender<AppReloadEvent>,
) {
    let now = Instant::now();

    // Check global full_reload_at first - it supersedes all pending events
    if let Some(reload_time) = *full_reload_at {
        if now.duration_since(reload_time) >= debounce {
            debug!("App FullReload debounce complete, flushing");
            info!(event = ?AppReloadEvent::FullReload, "Emitting app reload event");
            let _ = out_tx.send_blocking(AppReloadEvent::FullReload);
            *full_reload_at = None;
            pending.clear();
            return;
        }
    }

    // Flush individual expired events
    let mut to_send: Vec<AppReloadEvent> = Vec::new();

    pending.retain(|path, (ev, t)| {
        if now.duration_since(*t) >= debounce {
            debug!(path = %path.display(), event = ?ev, "App debounce complete, flushing");
            to_send.push(ev.clone());
            false
        } else {
            true
        }
    });

    for ev in to_send {
        info!(event = ?ev, "Emitting app reload event");
        let _ = out_tx.send_blocking(ev);
    }
}

/// Merge create/delete event pairs for the same path into AppUpdated (app update handling)
///
/// App installers may cause Delete+Create sequences during updates.
/// Within the debounce window, we merge these into AppUpdated.
fn merge_app_event(
    pending: &mut HashMap<PathBuf, (AppReloadEvent, Instant)>,
    path: &PathBuf,
    new_event: AppReloadEvent,
    timestamp: Instant,
) {
    if let Some((existing_event, _existing_time)) = pending.get(path) {
        // Check if we can merge:
        // AppRemoved + AppAdded ‚Üí AppUpdated (app was updated)
        // AppAdded + AppRemoved ‚Üí AppUpdated (temp app dance during install)
        let merged = match (&existing_event, &new_event) {
            (AppReloadEvent::AppRemoved(_), AppReloadEvent::AppAdded(_))
            | (AppReloadEvent::AppAdded(_), AppReloadEvent::AppRemoved(_)) => {
                Some(AppReloadEvent::AppUpdated(path.clone()))
            }
            _ => None,
        };

        if let Some(merged_event) = merged {
            pending.insert(path.clone(), (merged_event, timestamp));
            return;
        }
    }

    // No merge - insert new event
    pending.insert(path.clone(), (new_event, timestamp));
}

/// Watches /Applications and ~/Applications for .app bundle changes
///
/// Uses per-file trailing-edge debounce with storm coalescing.
/// Filters to only .app directories.
/// Properly shuts down via stop flag.
/// Includes supervisor restart with exponential backoff on transient errors.
pub struct AppWatcher {
    tx: Option<async_channel::Sender<AppReloadEvent>>,
    stop_flag: Option<std::sync::Arc<std::sync::atomic::AtomicBool>>,
    watcher_thread: Option<thread::JoinHandle<()>>,
}

impl AppWatcher {
    /// Create a new AppWatcher
    ///
    /// Returns a tuple of (watcher, receiver) where receiver will emit AppReloadEvent
    /// when .app bundles in /Applications or ~/Applications change.
    pub fn new() -> (Self, async_channel::Receiver<AppReloadEvent>) {
        let (tx, rx) = async_channel::bounded(100);
        let watcher = AppWatcher {
            tx: Some(tx),
            stop_flag: None,
            watcher_thread: None,
        };
        (watcher, rx)
    }

    /// Start watching the applications directories for changes
    ///
    /// This spawns a background thread that watches /Applications and ~/Applications
    /// and sends reload events through the receiver when .app bundles are added,
    /// modified, or deleted.
    /// On transient errors, the watcher will retry with exponential backoff.
    pub fn start(&mut self) -> NotifyResult<()> {
        let tx = self
            .tx
            .take()
            .ok_or_else(|| std::io::Error::other("watcher already started"))?;

        let stop_flag = std::sync::Arc::new(std::sync::atomic::AtomicBool::new(false));
        let thread_stop_flag = stop_flag.clone();
        self.stop_flag = Some(stop_flag);

        // Watch paths: /Applications and ~/Applications
        let system_apps_path = PathBuf::from("/Applications");
        let user_apps_path = PathBuf::from(shellexpand::tilde("~/Applications").as_ref());

        let thread_handle = thread::spawn(move || {
            Self::supervisor_loop(system_apps_path, user_apps_path, tx, thread_stop_flag);
        });

        self.watcher_thread = Some(thread_handle);
        Ok(())
    }

    /// Supervisor loop that restarts the watcher on failures with exponential backoff
    fn supervisor_loop(
        system_apps_path: PathBuf,
        user_apps_path: PathBuf,
        out_tx: async_channel::Sender<AppReloadEvent>,
        stop_flag: std::sync::Arc<std::sync::atomic::AtomicBool>,
    ) {
        let mut attempt: u32 = 0;

        loop {
            if stop_flag.load(std::sync::atomic::Ordering::Relaxed) {
                info!(watcher = "apps", "App watcher supervisor stopping");
                break;
            }

            let (control_tx, control_rx) = channel::<ControlMsg>();

            match Self::watch_loop(
                system_apps_path.clone(),
                user_apps_path.clone(),
                out_tx.clone(),
                control_rx,
                control_tx,
                stop_flag.clone(),
            ) {
                Ok(()) => {
                    info!(watcher = "apps", "App watcher completed normally");
                    break;
                }
                Err(e) => {
                    if stop_flag.load(std::sync::atomic::Ordering::Relaxed) {
                        break;
                    }

                    let backoff = compute_backoff(attempt);
                    warn!(
                        error = %e,
                        watcher = "apps",
                        attempt = attempt,
                        backoff_ms = backoff.as_millis(),
                        "App watcher error, retrying with backoff"
                    );

                    if !interruptible_sleep(backoff, &stop_flag) {
                        break;
                    }
                    attempt = attempt.saturating_add(1);
                }
            }
        }

        info!(watcher = "apps", "App watcher supervisor shutting down");
    }

    /// Internal watch loop running in background thread
    fn watch_loop(
        system_apps_path: PathBuf,
        user_apps_path: PathBuf,
        out_tx: async_channel::Sender<AppReloadEvent>,
        control_rx: Receiver<ControlMsg>,
        callback_tx: Sender<ControlMsg>,
        stop_flag: std::sync::Arc<std::sync::atomic::AtomicBool>,
    ) -> NotifyResult<()> {
        let mut watcher: Box<dyn Watcher> = Box::new(recommended_watcher({
            let tx = callback_tx.clone();
            move |res: notify::Result<notify::Event>| {
                let _ = tx.send(ControlMsg::Notify(res));
            }
        })?);

        // Watch /Applications with NonRecursive (apps are top-level .app bundles)
        if system_apps_path.exists() {
            watcher.watch(&system_apps_path, RecursiveMode::NonRecursive)?;
            info!(
                path = %system_apps_path.display(),
                recursive = false,
                "System Applications watcher started"
            );
        } else {
            debug!(
                path = %system_apps_path.display(),
                "System Applications path does not exist, skipping"
            );
        }

        // Watch ~/Applications with NonRecursive
        if user_apps_path.exists() {
            watcher.watch(&user_apps_path, RecursiveMode::NonRecursive)?;
            info!(
                path = %user_apps_path.display(),
                recursive = false,
                "User Applications watcher started"
            );
        } else {
            // Create ~/Applications if it doesn't exist so we can watch it
            // Many users don't have this directory initially
            debug!(
                path = %user_apps_path.display(),
                "User Applications path does not exist, skipping"
            );
        }

        let mut consecutive_errors: u32 = 0;
        let debounce = Duration::from_millis(DEBOUNCE_MS);
        let mut pending: HashMap<PathBuf, (AppReloadEvent, Instant)> = HashMap::new();
        // Global FullReload state: when set, supersedes all per-file events
        let mut full_reload_at: Option<Instant> = None;

        loop {
            if stop_flag.load(std::sync::atomic::Ordering::Relaxed) {
                break;
            }

            // Use a max timeout to periodically check stop flag
            let deadline = next_app_deadline(&pending, full_reload_at, debounce);
            let timeout = deadline
                .map(|dl| dl.saturating_duration_since(Instant::now()))
                .unwrap_or(Duration::from_millis(500));

            let msg = match control_rx.recv_timeout(timeout) {
                Ok(m) => Some(m),
                Err(RecvTimeoutError::Timeout) => {
                    flush_expired_apps(&mut pending, &mut full_reload_at, debounce, &out_tx);
                    continue;
                }
                Err(RecvTimeoutError::Disconnected) => break,
            };

            let Some(msg) = msg else { continue };

            match msg {
                ControlMsg::Stop => {
                    info!(watcher = "apps", "App watcher received stop signal");
                    break;
                }

                ControlMsg::Notify(Err(e)) => {
                    consecutive_errors = consecutive_errors.saturating_add(1);
                    warn!(
                        error = %e,
                        watcher = "apps",
                        consecutive_errors = consecutive_errors,
                        "notify delivered error"
                    );

                    if consecutive_errors >= MAX_NOTIFY_ERRORS {
                        warn!(
                            watcher = "apps",
                            consecutive_errors = consecutive_errors,
                            "Too many consecutive errors, triggering restart"
                        );
                        return Err(notify::Error::generic("Too many consecutive notify errors"));
                    }
                }

                ControlMsg::Notify(Ok(event)) => {
                    consecutive_errors = 0;
                    let kind = &event.kind;

                    for path in event.paths.iter() {
                        // Filter: only .app directories
                        if !is_app_bundle(path) {
                            continue;
                        }

                        let now = Instant::now();

                        // Handle event types
                        match kind {
                            notify::EventKind::Create(_) => {
                                debug!(
                                    path = %path.display(),
                                    event_kind = ?kind,
                                    "App change detected (create), merging event"
                                );
                                merge_app_event(
                                    &mut pending,
                                    path,
                                    AppReloadEvent::AppAdded(path.clone()),
                                    now,
                                );
                            }
                            notify::EventKind::Modify(_) => {
                                debug!(
                                    path = %path.display(),
                                    event_kind = ?kind,
                                    "App change detected (modify), updating pending"
                                );
                                pending.insert(
                                    path.clone(),
                                    (AppReloadEvent::AppUpdated(path.clone()), now),
                                );
                            }
                            notify::EventKind::Remove(_) => {
                                debug!(
                                    path = %path.display(),
                                    event_kind = ?kind,
                                    "App change detected (remove), merging event"
                                );
                                merge_app_event(
                                    &mut pending,
                                    path,
                                    AppReloadEvent::AppRemoved(path.clone()),
                                    now,
                                );
                            }
                            // Access events are not relevant
                            notify::EventKind::Access(_) => continue,
                            // For Other/Any events, trigger global FullReload
                            _ => {
                                debug!(
                                    path = %path.display(),
                                    event_kind = ?kind,
                                    "Unknown event kind, triggering global FullReload"
                                );
                                full_reload_at = Some(now);
                                pending.clear();
                            }
                        }

                        // Storm coalescing: if too many pending events, collapse to FullReload
                        if pending.len() >= STORM_THRESHOLD {
                            warn!(
                                pending_count = pending.len(),
                                threshold = STORM_THRESHOLD,
                                "App event storm detected, collapsing to FullReload"
                            );
                            full_reload_at = Some(Instant::now());
                            pending.clear();
                        }
                    }
                }
            }
        }

        info!(watcher = "apps", "App watcher shutting down");
        Ok(())
    }
}

impl Drop for AppWatcher {
    fn drop(&mut self) {
        if let Some(flag) = self.stop_flag.take() {
            flag.store(true, std::sync::atomic::Ordering::Relaxed);
        }
        if let Some(handle) = self.watcher_thread.take() {
            let _ = handle.join();
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    // ============================================================
    // ISSUE A - FullReload coalescing tests
    // ============================================================

    #[test]
    fn test_full_reload_global_state_single_emission() {
        // Multiple FullReload triggers during debounce window should result in single emission
        let (tx, rx) = channel::<ScriptReloadEvent>();
        let mut pending: HashMap<PathBuf, (ScriptReloadEvent, Instant)> = HashMap::new();
        let mut full_reload_at: Option<Instant> = None;
        let _debounce = Duration::from_millis(500);
        let now = Instant::now();

        // Simulate 3 FullReload triggers from different paths within debounce window
        for i in 0..3 {
            let _path = PathBuf::from(format!("/test/script{}.ts", i));
            // When FullReload is triggered, set global state instead of per-path
            full_reload_at = Some(now);
            // Clear pending events - they're superseded by full reload
            pending.clear();
        }

        // Verify: full_reload_at is set, pending is empty
        assert!(full_reload_at.is_some());
        assert!(pending.is_empty());

        // Simulate debounce expiry - emit single FullReload
        if full_reload_at.is_some() {
            let _ = tx.send(ScriptReloadEvent::FullReload);
            // Reset after emission (in real code)
        }

        // Should only receive one FullReload
        let received = rx.try_recv().unwrap();
        assert_eq!(received, ScriptReloadEvent::FullReload);
        assert!(rx.try_recv().is_err()); // No more events
    }

    #[test]
    fn test_full_reload_clears_pending_events() {
        // When FullReload is triggered, it should clear all pending per-file events
        let mut pending: HashMap<PathBuf, (ScriptReloadEvent, Instant)> = HashMap::new();
        let now = Instant::now();

        // Add some pending per-file events
        pending.insert(
            PathBuf::from("/test/a.ts"),
            (
                ScriptReloadEvent::FileChanged(PathBuf::from("/test/a.ts")),
                now,
            ),
        );
        pending.insert(
            PathBuf::from("/test/b.ts"),
            (
                ScriptReloadEvent::FileCreated(PathBuf::from("/test/b.ts")),
                now,
            ),
        );

        assert_eq!(pending.len(), 2);

        // Trigger FullReload (e.g., from EventKind::Other)
        let full_reload_at: Option<Instant> = Some(now);
        pending.clear();

        // Pending should be empty, full_reload_at should be set
        assert!(pending.is_empty());
        assert!(full_reload_at.is_some());
    }

    // ============================================================
    // ISSUE B - Atomic save event merging tests
    // ============================================================

    #[test]
    fn test_merge_delete_then_create_to_changed() {
        // FileDeleted + FileCreated (same path) ‚Üí FileChanged
        let mut pending: HashMap<PathBuf, (ScriptReloadEvent, Instant)> = HashMap::new();
        let path = PathBuf::from("/test/script.ts");
        let now = Instant::now();

        // First: delete event
        merge_script_event(
            &mut pending,
            &path,
            ScriptReloadEvent::FileDeleted(path.clone()),
            now,
        );
        assert_eq!(pending.len(), 1);
        assert!(matches!(
            pending.get(&path),
            Some((ScriptReloadEvent::FileDeleted(_), _))
        ));

        // Then: create event (atomic save completes)
        let later = now + Duration::from_millis(10);
        merge_script_event(
            &mut pending,
            &path,
            ScriptReloadEvent::FileCreated(path.clone()),
            later,
        );

        // Should be merged to FileChanged
        assert_eq!(pending.len(), 1);
        let (event, _) = pending.get(&path).unwrap();
        assert_eq!(*event, ScriptReloadEvent::FileChanged(path.clone()));
    }

    #[test]
    fn test_merge_create_then_delete_to_changed() {
        // FileCreated + FileDeleted (same path) ‚Üí FileChanged
        // (temp file dance: create temp, delete original, rename temp)
        let mut pending: HashMap<PathBuf, (ScriptReloadEvent, Instant)> = HashMap::new();
        let path = PathBuf::from("/test/script.ts");
        let now = Instant::now();

        // First: create event
        merge_script_event(
            &mut pending,
            &path,
            ScriptReloadEvent::FileCreated(path.clone()),
            now,
        );

        // Then: delete event
        let later = now + Duration::from_millis(10);
        merge_script_event(
            &mut pending,
            &path,
            ScriptReloadEvent::FileDeleted(path.clone()),
            later,
        );

        // Should be merged to FileChanged
        assert_eq!(pending.len(), 1);
        let (event, _) = pending.get(&path).unwrap();
        assert_eq!(*event, ScriptReloadEvent::FileChanged(path.clone()));
    }

    #[test]
    fn test_no_merge_for_different_paths() {
        // Events for different paths should not be merged
        let mut pending: HashMap<PathBuf, (ScriptReloadEvent, Instant)> = HashMap::new();
        let path_a = PathBuf::from("/test/a.ts");
        let path_b = PathBuf::from("/test/b.ts");
        let now = Instant::now();

        // Delete on path A
        merge_script_event(
            &mut pending,
            &path_a,
            ScriptReloadEvent::FileDeleted(path_a.clone()),
            now,
        );

        // Create on path B (different path - no merge)
        merge_script_event(
            &mut pending,
            &path_b,
            ScriptReloadEvent::FileCreated(path_b.clone()),
            now,
        );

        // Should have 2 separate events
        assert_eq!(pending.len(), 2);
        assert!(matches!(
            pending.get(&path_a),
            Some((ScriptReloadEvent::FileDeleted(_), _))
        ));
        assert!(matches!(
            pending.get(&path_b),
            Some((ScriptReloadEvent::FileCreated(_), _))
        ));
    }

    #[test]
    fn test_no_merge_for_modify_events() {
        // FileChanged + FileDeleted should NOT merge to FileChanged
        // (only create/delete pairs merge)
        let mut pending: HashMap<PathBuf, (ScriptReloadEvent, Instant)> = HashMap::new();
        let path = PathBuf::from("/test/script.ts");
        let now = Instant::now();

        // First: modify event
        merge_script_event(
            &mut pending,
            &path,
            ScriptReloadEvent::FileChanged(path.clone()),
            now,
        );

        // Then: delete event
        let later = now + Duration::from_millis(10);
        merge_script_event(
            &mut pending,
            &path,
            ScriptReloadEvent::FileDeleted(path.clone()),
            later,
        );

        // Should NOT merge - delete overwrites
        assert_eq!(pending.len(), 1);
        let (event, _) = pending.get(&path).unwrap();
        assert_eq!(*event, ScriptReloadEvent::FileDeleted(path.clone()));
    }

    // ============================================================
    // Existing tests
    // ============================================================

    #[test]
    fn test_config_watcher_creation() {
        let (_watcher, _rx) = ConfigWatcher::new();
        // Watcher should be created without panicking
    }

    #[test]
    fn test_config_reload_event_clone() {
        let event = ConfigReloadEvent::Reload;
        let _cloned = event.clone();
        // Event should be cloneable
    }

    #[test]
    fn test_theme_watcher_creation() {
        let (_watcher, _rx) = ThemeWatcher::new();
        // Watcher should be created without panicking
    }

    #[test]
    fn test_theme_reload_event_clone() {
        let event = ThemeReloadEvent::Reload;
        let _cloned = event.clone();
        // Event should be cloneable
    }

    #[test]
    fn test_script_watcher_creation() {
        let (_watcher, _rx) = ScriptWatcher::new();
        // Watcher should be created without panicking
    }

    #[test]
    fn test_script_reload_event_clone() {
        let event = ScriptReloadEvent::FullReload;
        let _cloned = event.clone();
        // Event should be cloneable
    }

    #[test]
    fn test_script_reload_event_file_changed() {
        let path = PathBuf::from("/test/path/script.ts");
        let event = ScriptReloadEvent::FileChanged(path.clone());

        // Verify the event contains the correct path
        if let ScriptReloadEvent::FileChanged(event_path) = event {
            assert_eq!(event_path, path);
        } else {
            panic!("Expected FileChanged variant");
        }
    }

    #[test]
    fn test_script_reload_event_file_created() {
        let path = PathBuf::from("/test/path/new-script.ts");
        let event = ScriptReloadEvent::FileCreated(path.clone());

        // Verify the event contains the correct path
        if let ScriptReloadEvent::FileCreated(event_path) = event {
            assert_eq!(event_path, path);
        } else {
            panic!("Expected FileCreated variant");
        }
    }

    #[test]
    fn test_script_reload_event_file_deleted() {
        let path = PathBuf::from("/test/path/deleted-script.ts");
        let event = ScriptReloadEvent::FileDeleted(path.clone());

        // Verify the event contains the correct path
        if let ScriptReloadEvent::FileDeleted(event_path) = event {
            assert_eq!(event_path, path);
        } else {
            panic!("Expected FileDeleted variant");
        }
    }

    #[test]
    fn test_script_reload_event_equality() {
        let path1 = PathBuf::from("/test/path/script.ts");
        let path2 = PathBuf::from("/test/path/script.ts");
        let path3 = PathBuf::from("/test/path/other.ts");

        // Same path should be equal
        assert_eq!(
            ScriptReloadEvent::FileChanged(path1.clone()),
            ScriptReloadEvent::FileChanged(path2.clone())
        );

        // Different paths should not be equal
        assert_ne!(
            ScriptReloadEvent::FileChanged(path1.clone()),
            ScriptReloadEvent::FileChanged(path3.clone())
        );

        // Different event types should not be equal
        assert_ne!(
            ScriptReloadEvent::FileChanged(path1.clone()),
            ScriptReloadEvent::FileCreated(path1.clone())
        );

        // FullReload should equal itself
        assert_eq!(ScriptReloadEvent::FullReload, ScriptReloadEvent::FullReload);
    }

    #[test]
    fn test_extract_file_path_from_event() {
        // Test helper function for extracting paths from notify events
        use notify::event::{CreateKind, ModifyKind, RemoveKind};

        let test_path = PathBuf::from("/Users/test/.scriptkit/scripts/hello.ts");

        // Test Create event
        let create_event = notify::Event {
            kind: notify::EventKind::Create(CreateKind::File),
            paths: vec![test_path.clone()],
            attrs: Default::default(),
        };
        assert_eq!(create_event.paths.first(), Some(&test_path));

        // Test Modify event
        let modify_event = notify::Event {
            kind: notify::EventKind::Modify(ModifyKind::Data(notify::event::DataChange::Content)),
            paths: vec![test_path.clone()],
            attrs: Default::default(),
        };
        assert_eq!(modify_event.paths.first(), Some(&test_path));

        // Test Remove event
        let remove_event = notify::Event {
            kind: notify::EventKind::Remove(RemoveKind::File),
            paths: vec![test_path.clone()],
            attrs: Default::default(),
        };
        assert_eq!(remove_event.paths.first(), Some(&test_path));
    }

    #[test]
    fn test_is_relevant_script_file() {
        use std::path::Path;

        // Test that we correctly identify relevant script files
        let ts_path = Path::new("/Users/test/.scriptkit/scripts/hello.ts");
        let js_path = Path::new("/Users/test/.scriptkit/scripts/hello.js");
        let md_path = Path::new("/Users/test/.scriptkit/scriptlets/hello.md");
        let txt_path = Path::new("/Users/test/.scriptkit/scripts/readme.txt");
        let hidden_path = Path::new("/Users/test/.scriptkit/scripts/.hidden.ts");

        // TypeScript files should be relevant
        assert!(is_relevant_script_file(ts_path));

        // JavaScript files should be relevant
        assert!(is_relevant_script_file(js_path));

        // Markdown files in scriptlets should be relevant
        assert!(is_relevant_script_file(md_path));

        // Other file types should not be relevant
        assert!(!is_relevant_script_file(txt_path));

        // Hidden files should not be relevant
        assert!(!is_relevant_script_file(hidden_path));
    }

    #[test]
    fn test_appearance_change_event_clone() {
        let event_dark = AppearanceChangeEvent::Dark;
        let _cloned = event_dark.clone();
        let event_light = AppearanceChangeEvent::Light;
        let _cloned = event_light.clone();
        // Events should be cloneable
    }

    #[test]
    fn test_appearance_change_event_equality() {
        let dark1 = AppearanceChangeEvent::Dark;
        let dark2 = AppearanceChangeEvent::Dark;
        let light = AppearanceChangeEvent::Light;

        assert_eq!(dark1, dark2);
        assert_ne!(dark1, light);
    }

    #[test]
    fn test_appearance_watcher_creation() {
        let (_watcher, _rx) = AppearanceWatcher::new();
        // Watcher should be created without panicking
    }

    #[test]
    fn test_is_relevant_event_kind() {
        use notify::event::{AccessKind, CreateKind, ModifyKind, RemoveKind};

        // Access events should NOT be relevant
        assert!(!is_relevant_event_kind(&notify::EventKind::Access(
            AccessKind::Read
        )));

        // Create events SHOULD be relevant
        assert!(is_relevant_event_kind(&notify::EventKind::Create(
            CreateKind::File
        )));

        // Modify events SHOULD be relevant
        assert!(is_relevant_event_kind(&notify::EventKind::Modify(
            ModifyKind::Any
        )));

        // Remove events SHOULD be relevant
        assert!(is_relevant_event_kind(&notify::EventKind::Remove(
            RemoveKind::File
        )));

        // Other/Any events SHOULD be relevant (includes renames)
        assert!(is_relevant_event_kind(&notify::EventKind::Other));
        assert!(is_relevant_event_kind(&notify::EventKind::Any));
    }

    #[test]
    fn test_next_deadline_empty() {
        let pending: HashMap<PathBuf, (ScriptReloadEvent, Instant)> = HashMap::new();
        let debounce = Duration::from_millis(500);

        assert!(next_deadline(&pending, None, debounce).is_none());
    }

    #[test]
    fn test_next_deadline_single() {
        let mut pending: HashMap<PathBuf, (ScriptReloadEvent, Instant)> = HashMap::new();
        let now = Instant::now();
        let debounce = Duration::from_millis(500);

        pending.insert(
            PathBuf::from("/test/script.ts"),
            (
                ScriptReloadEvent::FileChanged(PathBuf::from("/test/script.ts")),
                now,
            ),
        );

        let deadline = next_deadline(&pending, None, debounce);
        assert!(deadline.is_some());
        // Deadline should be approximately now + debounce
        let expected = now + debounce;
        let actual = deadline.unwrap();
        // Allow 1ms tolerance for timing
        assert!(actual >= expected && actual <= expected + Duration::from_millis(1));
    }

    #[test]
    fn test_next_deadline_multiple_picks_earliest() {
        let mut pending: HashMap<PathBuf, (ScriptReloadEvent, Instant)> = HashMap::new();
        let now = Instant::now();
        let debounce = Duration::from_millis(500);

        // Add an older event
        let older_time = now - Duration::from_millis(200);
        pending.insert(
            PathBuf::from("/test/old.ts"),
            (
                ScriptReloadEvent::FileChanged(PathBuf::from("/test/old.ts")),
                older_time,
            ),
        );

        // Add a newer event
        pending.insert(
            PathBuf::from("/test/new.ts"),
            (
                ScriptReloadEvent::FileChanged(PathBuf::from("/test/new.ts")),
                now,
            ),
        );

        let deadline = next_deadline(&pending, None, debounce);
        assert!(deadline.is_some());
        // Should pick the older event's deadline (earlier)
        let expected = older_time + debounce;
        let actual = deadline.unwrap();
        assert!(actual >= expected && actual <= expected + Duration::from_millis(1));
    }

    #[test]
    fn test_next_deadline_with_full_reload() {
        let pending: HashMap<PathBuf, (ScriptReloadEvent, Instant)> = HashMap::new();
        let now = Instant::now();
        let debounce = Duration::from_millis(500);

        // Only full_reload_at is set, no pending events
        let deadline = next_deadline(&pending, Some(now), debounce);
        assert!(deadline.is_some());
        let expected = now + debounce;
        let actual = deadline.unwrap();
        assert!(actual >= expected && actual <= expected + Duration::from_millis(1));
    }

    #[test]
    fn test_next_deadline_full_reload_earlier_than_pending() {
        let mut pending: HashMap<PathBuf, (ScriptReloadEvent, Instant)> = HashMap::new();
        let now = Instant::now();
        let debounce = Duration::from_millis(500);

        // Add a fresh pending event (deadline = now + 500ms)
        pending.insert(
            PathBuf::from("/test/script.ts"),
            (
                ScriptReloadEvent::FileChanged(PathBuf::from("/test/script.ts")),
                now,
            ),
        );

        // Add an older full_reload_at (deadline = older + 500ms < now + 500ms)
        let older_reload = now - Duration::from_millis(200);
        let deadline = next_deadline(&pending, Some(older_reload), debounce);
        assert!(deadline.is_some());

        // Should pick the earlier deadline (full_reload)
        let expected = older_reload + debounce;
        let actual = deadline.unwrap();
        assert!(actual >= expected && actual <= expected + Duration::from_millis(1));
    }

    #[test]
    fn test_flush_expired_none_expired() {
        let (tx, _rx) = channel::<ScriptReloadEvent>();
        let mut pending: HashMap<PathBuf, (ScriptReloadEvent, Instant)> = HashMap::new();
        let mut full_reload_at: Option<Instant> = None;
        let now = Instant::now();
        let debounce = Duration::from_millis(500);

        // Add a fresh event (not expired)
        pending.insert(
            PathBuf::from("/test/script.ts"),
            (
                ScriptReloadEvent::FileChanged(PathBuf::from("/test/script.ts")),
                now,
            ),
        );

        flush_expired(&mut pending, &mut full_reload_at, debounce, &tx);

        // Event should still be pending
        assert_eq!(pending.len(), 1);
    }

    #[test]
    fn test_flush_expired_some_expired() {
        let (tx, rx) = channel::<ScriptReloadEvent>();
        let mut pending: HashMap<PathBuf, (ScriptReloadEvent, Instant)> = HashMap::new();
        let mut full_reload_at: Option<Instant> = None;
        let debounce = Duration::from_millis(500);

        // Add an expired event (from 600ms ago)
        let old_time = Instant::now() - Duration::from_millis(600);
        pending.insert(
            PathBuf::from("/test/old.ts"),
            (
                ScriptReloadEvent::FileChanged(PathBuf::from("/test/old.ts")),
                old_time,
            ),
        );

        // Add a fresh event
        pending.insert(
            PathBuf::from("/test/new.ts"),
            (
                ScriptReloadEvent::FileChanged(PathBuf::from("/test/new.ts")),
                Instant::now(),
            ),
        );

        flush_expired(&mut pending, &mut full_reload_at, debounce, &tx);

        // Only fresh event should remain
        assert_eq!(pending.len(), 1);
        assert!(pending.contains_key(&PathBuf::from("/test/new.ts")));

        // Should have received the expired event
        let received = rx.try_recv().unwrap();
        assert_eq!(
            received,
            ScriptReloadEvent::FileChanged(PathBuf::from("/test/old.ts"))
        );
    }

    #[test]
    fn test_flush_expired_full_reload_supersedes_pending() {
        let (tx, rx) = channel::<ScriptReloadEvent>();
        let mut pending: HashMap<PathBuf, (ScriptReloadEvent, Instant)> = HashMap::new();
        let debounce = Duration::from_millis(500);

        // Add some expired pending events
        let old_time = Instant::now() - Duration::from_millis(600);
        pending.insert(
            PathBuf::from("/test/a.ts"),
            (
                ScriptReloadEvent::FileChanged(PathBuf::from("/test/a.ts")),
                old_time,
            ),
        );
        pending.insert(
            PathBuf::from("/test/b.ts"),
            (
                ScriptReloadEvent::FileCreated(PathBuf::from("/test/b.ts")),
                old_time,
            ),
        );

        // Set expired full_reload_at (should supersede pending)
        let mut full_reload_at: Option<Instant> = Some(old_time);

        flush_expired(&mut pending, &mut full_reload_at, debounce, &tx);

        // All pending should be cleared
        assert!(pending.is_empty());
        // full_reload_at should be reset
        assert!(full_reload_at.is_none());

        // Should receive only ONE FullReload (not per-file events)
        let received = rx.try_recv().unwrap();
        assert_eq!(received, ScriptReloadEvent::FullReload);
        // No more events
        assert!(rx.try_recv().is_err());
    }

    #[test]
    fn test_config_watcher_shutdown_no_hang() {
        // Create and start a watcher
        let (mut watcher, _rx) = ConfigWatcher::new();

        // This may fail if the watch directory doesn't exist, but that's fine
        // We're testing that drop doesn't hang, not that watching works
        let _ = watcher.start();

        // Drop should complete within a reasonable time (not hang)
        // The Drop implementation sends Stop and then joins
        drop(watcher);

        // If we get here, the test passed (didn't hang)
    }

    #[test]
    fn test_theme_watcher_shutdown_no_hang() {
        let (mut watcher, _rx) = ThemeWatcher::new();
        let _ = watcher.start();
        drop(watcher);
        // If we get here, the test passed (didn't hang)
    }

    #[test]
    fn test_script_watcher_shutdown_no_hang() {
        let (mut watcher, _rx) = ScriptWatcher::new();
        let _ = watcher.start();
        drop(watcher);
        // If we get here, the test passed (didn't hang)
    }

    #[test]
    fn test_appearance_watcher_shutdown_no_hang() {
        let (mut watcher, _rx) = AppearanceWatcher::new();
        let _ = watcher.start();
        drop(watcher);
        // If we get here, the test passed (didn't hang)
    }

    #[test]
    fn test_storm_threshold_constant() {
        // Verify storm threshold is a reasonable value (compile-time checks)
        const { assert!(STORM_THRESHOLD > 0) };
        const { assert!(STORM_THRESHOLD <= 1000) }; // Not too high
    }

    #[test]
    fn test_debounce_constant() {
        // Verify debounce is a reasonable value (compile-time checks)
        const { assert!(DEBOUNCE_MS >= 100) }; // At least 100ms
        const { assert!(DEBOUNCE_MS <= 2000) }; // At most 2s
    }

    #[test]
    fn test_storm_coalescing_logic() {
        // Test that we properly handle storm coalescing
        // When storm threshold is reached, we should:
        // 1. Clear pending
        // 2. Send FullReload
        // 3. Continue processing (not exit the watcher)

        let (tx, rx) = channel::<ScriptReloadEvent>();
        let mut pending: HashMap<PathBuf, (ScriptReloadEvent, Instant)> = HashMap::new();
        let now = Instant::now();

        // Fill up pending to the storm threshold
        for i in 0..STORM_THRESHOLD {
            let path = PathBuf::from(format!("/test/script{}.ts", i));
            pending.insert(path.clone(), (ScriptReloadEvent::FileCreated(path), now));
        }

        // Verify we're at the threshold
        assert_eq!(pending.len(), STORM_THRESHOLD);

        // Simulate storm coalescing
        if pending.len() >= STORM_THRESHOLD {
            pending.clear();
            let _ = tx.send(ScriptReloadEvent::FullReload);
        }

        // Pending should be cleared
        assert_eq!(pending.len(), 0);

        // FullReload should have been sent
        let received = rx.try_recv().unwrap();
        assert_eq!(received, ScriptReloadEvent::FullReload);
    }

    #[test]
    fn test_compute_backoff_initial() {
        // First attempt should use initial backoff
        let delay = compute_backoff(0);
        assert_eq!(delay, Duration::from_millis(INITIAL_BACKOFF_MS));
    }

    #[test]
    fn test_compute_backoff_exponential() {
        // Each attempt should double the delay
        let delay0 = compute_backoff(0);
        let delay1 = compute_backoff(1);
        let delay2 = compute_backoff(2);
        let delay3 = compute_backoff(3);

        assert_eq!(delay0, Duration::from_millis(100));
        assert_eq!(delay1, Duration::from_millis(200));
        assert_eq!(delay2, Duration::from_millis(400));
        assert_eq!(delay3, Duration::from_millis(800));
    }

    #[test]
    fn test_compute_backoff_capped() {
        // High attempts should be capped at MAX_BACKOFF_MS
        let delay = compute_backoff(20); // 2^20 * 100ms would be huge
        assert_eq!(delay, Duration::from_millis(MAX_BACKOFF_MS));
    }

    #[test]
    fn test_compute_backoff_no_overflow() {
        // Even with u32::MAX attempts, should not panic
        let delay = compute_backoff(u32::MAX);
        assert_eq!(delay, Duration::from_millis(MAX_BACKOFF_MS));
    }

    #[test]
    fn test_interruptible_sleep_completes() {
        use std::sync::atomic::AtomicBool;

        let stop_flag = AtomicBool::new(false);
        let start = Instant::now();

        // Sleep for 50ms
        let completed = interruptible_sleep(Duration::from_millis(50), &stop_flag);

        assert!(completed);
        assert!(start.elapsed() >= Duration::from_millis(50));
    }

    #[test]
    fn test_interruptible_sleep_interrupted() {
        use std::sync::atomic::{AtomicBool, Ordering};
        use std::sync::Arc;

        let stop_flag = Arc::new(AtomicBool::new(false));
        let flag_clone = Arc::clone(&stop_flag);

        // Spawn a thread to set the stop flag after 50ms
        thread::spawn(move || {
            thread::sleep(Duration::from_millis(50));
            flag_clone.store(true, Ordering::Relaxed);
        });

        let start = Instant::now();

        // Try to sleep for 1 second, but should be interrupted
        let completed = interruptible_sleep(Duration::from_millis(1000), &stop_flag);

        assert!(!completed);
        // Should have stopped much sooner than 1 second
        assert!(start.elapsed() < Duration::from_millis(500));
    }

    #[test]
    fn test_backoff_constants() {
        // Verify backoff constants are reasonable
        const { assert!(INITIAL_BACKOFF_MS >= 50) }; // At least 50ms
        const { assert!(INITIAL_BACKOFF_MS <= 1000) }; // At most 1s
        const { assert!(MAX_BACKOFF_MS >= 5000) }; // At least 5s
        const { assert!(MAX_BACKOFF_MS <= 120_000) }; // At most 2 minutes
        const { assert!(MAX_NOTIFY_ERRORS >= 3) }; // At least 3 errors
        const { assert!(MAX_NOTIFY_ERRORS <= 100) }; // At most 100 errors
    }

    // ============================================================
    // AppWatcher tests
    // ============================================================

    #[test]
    fn test_app_watcher_creation() {
        let (_watcher, _rx) = AppWatcher::new();
        // Watcher should be created without panicking
    }

    #[test]
    fn test_app_watcher_shutdown_no_hang() {
        let (mut watcher, _rx) = AppWatcher::new();
        let _ = watcher.start();
        drop(watcher);
        // If we get here, the test passed (didn't hang)
    }

    #[test]
    fn test_app_reload_event_clone() {
        let event = AppReloadEvent::FullReload;
        let _cloned = event.clone();
        // Event should be cloneable
    }

    #[test]
    fn test_app_reload_event_app_added() {
        let path = PathBuf::from("/Applications/MyApp.app");
        let event = AppReloadEvent::AppAdded(path.clone());

        if let AppReloadEvent::AppAdded(event_path) = event {
            assert_eq!(event_path, path);
        } else {
            panic!("Expected AppAdded variant");
        }
    }

    #[test]
    fn test_app_reload_event_app_removed() {
        let path = PathBuf::from("/Applications/OldApp.app");
        let event = AppReloadEvent::AppRemoved(path.clone());

        if let AppReloadEvent::AppRemoved(event_path) = event {
            assert_eq!(event_path, path);
        } else {
            panic!("Expected AppRemoved variant");
        }
    }

    #[test]
    fn test_app_reload_event_app_updated() {
        let path = PathBuf::from("/Applications/UpdatedApp.app");
        let event = AppReloadEvent::AppUpdated(path.clone());

        if let AppReloadEvent::AppUpdated(event_path) = event {
            assert_eq!(event_path, path);
        } else {
            panic!("Expected AppUpdated variant");
        }
    }

    #[test]
    fn test_app_reload_event_equality() {
        let path1 = PathBuf::from("/Applications/App1.app");
        let path2 = PathBuf::from("/Applications/App1.app");
        let path3 = PathBuf::from("/Applications/App2.app");

        // Same path should be equal
        assert_eq!(
            AppReloadEvent::AppAdded(path1.clone()),
            AppReloadEvent::AppAdded(path2.clone())
        );

        // Different paths should not be equal
        assert_ne!(
            AppReloadEvent::AppAdded(path1.clone()),
            AppReloadEvent::AppAdded(path3.clone())
        );

        // Different event types should not be equal
        assert_ne!(
            AppReloadEvent::AppAdded(path1.clone()),
            AppReloadEvent::AppRemoved(path1.clone())
        );

        // FullReload should equal itself
        assert_eq!(AppReloadEvent::FullReload, AppReloadEvent::FullReload);
    }

    #[test]
    fn test_is_app_bundle_valid() {
        use std::path::Path;

        // .app extension should be recognized
        let valid_app = Path::new("/Applications/Safari.app");
        assert!(is_app_bundle(valid_app));

        let user_app = Path::new("/Users/test/Applications/MyApp.app");
        assert!(is_app_bundle(user_app));
    }

    #[test]
    fn test_is_app_bundle_invalid() {
        use std::path::Path;

        // Non-.app files should not be recognized
        let not_app = Path::new("/Applications/readme.txt");
        assert!(!is_app_bundle(not_app));

        let dmg_file = Path::new("/Applications/installer.dmg");
        assert!(!is_app_bundle(dmg_file));

        let ds_store = Path::new("/Applications/.DS_Store");
        assert!(!is_app_bundle(ds_store));

        let hidden = Path::new("/Applications/.Trash");
        assert!(!is_app_bundle(hidden));
    }

    #[test]
    fn test_merge_app_event_remove_then_add() {
        // AppRemoved + AppAdded (same path) ‚Üí AppUpdated
        let mut pending: HashMap<PathBuf, (AppReloadEvent, Instant)> = HashMap::new();
        let path = PathBuf::from("/Applications/MyApp.app");
        let now = Instant::now();

        // First: remove event
        merge_app_event(
            &mut pending,
            &path,
            AppReloadEvent::AppRemoved(path.clone()),
            now,
        );
        assert_eq!(pending.len(), 1);
        assert!(matches!(
            pending.get(&path),
            Some((AppReloadEvent::AppRemoved(_), _))
        ));

        // Then: add event (app reinstalled/updated)
        let later = now + Duration::from_millis(10);
        merge_app_event(
            &mut pending,
            &path,
            AppReloadEvent::AppAdded(path.clone()),
            later,
        );

        // Should be merged to AppUpdated
        assert_eq!(pending.len(), 1);
        let (event, _) = pending.get(&path).unwrap();
        assert_eq!(*event, AppReloadEvent::AppUpdated(path.clone()));
    }

    #[test]
    fn test_merge_app_event_add_then_remove() {
        // AppAdded + AppRemoved (same path) ‚Üí AppUpdated
        let mut pending: HashMap<PathBuf, (AppReloadEvent, Instant)> = HashMap::new();
        let path = PathBuf::from("/Applications/MyApp.app");
        let now = Instant::now();

        // First: add event
        merge_app_event(
            &mut pending,
            &path,
            AppReloadEvent::AppAdded(path.clone()),
            now,
        );

        // Then: remove event
        let later = now + Duration::from_millis(10);
        merge_app_event(
            &mut pending,
            &path,
            AppReloadEvent::AppRemoved(path.clone()),
            later,
        );

        // Should be merged to AppUpdated
        assert_eq!(pending.len(), 1);
        let (event, _) = pending.get(&path).unwrap();
        assert_eq!(*event, AppReloadEvent::AppUpdated(path.clone()));
    }

    #[test]
    fn test_no_merge_app_events_different_paths() {
        // Events for different paths should not be merged
        let mut pending: HashMap<PathBuf, (AppReloadEvent, Instant)> = HashMap::new();
        let path_a = PathBuf::from("/Applications/AppA.app");
        let path_b = PathBuf::from("/Applications/AppB.app");
        let now = Instant::now();

        // Remove on path A
        merge_app_event(
            &mut pending,
            &path_a,
            AppReloadEvent::AppRemoved(path_a.clone()),
            now,
        );

        // Add on path B (different path - no merge)
        merge_app_event(
            &mut pending,
            &path_b,
            AppReloadEvent::AppAdded(path_b.clone()),
            now,
        );

        // Should have 2 separate events
        assert_eq!(pending.len(), 2);
        assert!(matches!(
            pending.get(&path_a),
            Some((AppReloadEvent::AppRemoved(_), _))
        ));
        assert!(matches!(
            pending.get(&path_b),
            Some((AppReloadEvent::AppAdded(_), _))
        ));
    }

    #[test]
    fn test_next_app_deadline_empty() {
        let pending: HashMap<PathBuf, (AppReloadEvent, Instant)> = HashMap::new();
        let debounce = Duration::from_millis(500);

        assert!(next_app_deadline(&pending, None, debounce).is_none());
    }

    #[test]
    fn test_next_app_deadline_single() {
        let mut pending: HashMap<PathBuf, (AppReloadEvent, Instant)> = HashMap::new();
        let now = Instant::now();
        let debounce = Duration::from_millis(500);

        pending.insert(
            PathBuf::from("/Applications/Test.app"),
            (
                AppReloadEvent::AppAdded(PathBuf::from("/Applications/Test.app")),
                now,
            ),
        );

        let deadline = next_app_deadline(&pending, None, debounce);
        assert!(deadline.is_some());
        let expected = now + debounce;
        let actual = deadline.unwrap();
        assert!(actual >= expected && actual <= expected + Duration::from_millis(1));
    }

    #[test]
    fn test_next_app_deadline_with_full_reload() {
        let pending: HashMap<PathBuf, (AppReloadEvent, Instant)> = HashMap::new();
        let now = Instant::now();
        let debounce = Duration::from_millis(500);

        let deadline = next_app_deadline(&pending, Some(now), debounce);
        assert!(deadline.is_some());
        let expected = now + debounce;
        let actual = deadline.unwrap();
        assert!(actual >= expected && actual <= expected + Duration::from_millis(1));
    }

    #[test]
    fn test_flush_expired_apps_none_expired() {
        let (tx, _rx) = async_channel::bounded::<AppReloadEvent>(10);
        let mut pending: HashMap<PathBuf, (AppReloadEvent, Instant)> = HashMap::new();
        let mut full_reload_at: Option<Instant> = None;
        let now = Instant::now();
        let debounce = Duration::from_millis(500);

        // Add a fresh event (not expired)
        pending.insert(
            PathBuf::from("/Applications/Test.app"),
            (
                AppReloadEvent::AppAdded(PathBuf::from("/Applications/Test.app")),
                now,
            ),
        );

        flush_expired_apps(&mut pending, &mut full_reload_at, debounce, &tx);

        // Event should still be pending
        assert_eq!(pending.len(), 1);
    }

    #[test]
    fn test_flush_expired_apps_some_expired() {
        let (tx, rx) = async_channel::bounded::<AppReloadEvent>(10);
        let mut pending: HashMap<PathBuf, (AppReloadEvent, Instant)> = HashMap::new();
        let mut full_reload_at: Option<Instant> = None;
        let debounce = Duration::from_millis(500);

        // Add an expired event (from 600ms ago)
        let old_time = Instant::now() - Duration::from_millis(600);
        pending.insert(
            PathBuf::from("/Applications/Old.app"),
            (
                AppReloadEvent::AppAdded(PathBuf::from("/Applications/Old.app")),
                old_time,
            ),
        );

        // Add a fresh event
        pending.insert(
            PathBuf::from("/Applications/New.app"),
            (
                AppReloadEvent::AppAdded(PathBuf::from("/Applications/New.app")),
                Instant::now(),
            ),
        );

        flush_expired_apps(&mut pending, &mut full_reload_at, debounce, &tx);

        // Only fresh event should remain
        assert_eq!(pending.len(), 1);
        assert!(pending.contains_key(&PathBuf::from("/Applications/New.app")));

        // Should have received the expired event
        let received = rx.try_recv().unwrap();
        assert_eq!(
            received,
            AppReloadEvent::AppAdded(PathBuf::from("/Applications/Old.app"))
        );
    }

    #[test]
    fn test_flush_expired_apps_full_reload_supersedes_pending() {
        let (tx, rx) = async_channel::bounded::<AppReloadEvent>(10);
        let mut pending: HashMap<PathBuf, (AppReloadEvent, Instant)> = HashMap::new();
        let debounce = Duration::from_millis(500);

        // Add some expired pending events
        let old_time = Instant::now() - Duration::from_millis(600);
        pending.insert(
            PathBuf::from("/Applications/A.app"),
            (
                AppReloadEvent::AppAdded(PathBuf::from("/Applications/A.app")),
                old_time,
            ),
        );
        pending.insert(
            PathBuf::from("/Applications/B.app"),
            (
                AppReloadEvent::AppRemoved(PathBuf::from("/Applications/B.app")),
                old_time,
            ),
        );

        // Set expired full_reload_at (should supersede pending)
        let mut full_reload_at: Option<Instant> = Some(old_time);

        flush_expired_apps(&mut pending, &mut full_reload_at, debounce, &tx);

        // All pending should be cleared
        assert!(pending.is_empty());
        // full_reload_at should be reset
        assert!(full_reload_at.is_none());

        // Should receive only ONE FullReload (not per-app events)
        let received = rx.try_recv().unwrap();
        assert_eq!(received, AppReloadEvent::FullReload);
        // No more events
        assert!(rx.try_recv().is_err());
    }
}

</file>

<file path="dev.sh">
#!/bin/bash

# Dev runner script for script-kit-gpui
# Uses cargo-watch to auto-rebuild on Rust file changes
# Clears screen between rebuilds for clean output
#
# Only watches files that are actually included in the main app binary.
# Ignores: storybook, stories, tests, benchmarks, docs, etc.

set -e

# Check if cargo-watch is installed
if ! command -v cargo-watch &> /dev/null; then
    echo "‚ùå cargo-watch is not installed"
    echo ""
    echo "Install it with:"
    echo "  cargo install cargo-watch"
    echo ""
    exit 1
fi

echo "üöÄ Starting dev runner with cargo-watch..."
echo "   Watching: src/ (excluding storybook/stories), scripts/kit-sdk.ts, Cargo.toml, build.rs"
echo "   Ignoring: tests/, storybook, stories, docs, benchmarks, .md files"
echo "   Press Ctrl+C to stop"
echo ""

# Run cargo watch with auto-rebuild
# -x run: Execute 'cargo run' on file changes
# -c: Clear screen between runs for cleaner output
# -w: Only watch specific directories (disables auto-discovery)
# -i: Ignore patterns that shouldn't trigger rebuilds
cargo watch -c -x run \
    -w src/ \
    -w scripts/kit-sdk.ts \
    -w Cargo.toml \
    -w Cargo.lock \
    -w build.rs \
    -i 'src/bin/storybook.rs' \
    -i 'src/bin/smoke-test.rs' \
    -i 'src/storybook/*' \
    -i 'src/stories/*' \
    -i 'src/*_tests.rs' \
    -i 'tests/*' \
    -i '*.md' \
    -i 'docs/*' \
    -i 'expert-bundles/*' \
    -i 'audit-docs/*' \
    -i 'audits/*' \
    -i '.test-screenshots/*' \
    -i 'test-screenshots/*' \
    -i '.hive/*' \
    -i '.mocks/*' \
    -i 'storybook.sh' \
    -i 'tasks/*' \
    -i 'plan/*' \
    -i 'security-audit/*' \
    -i 'ai/*' \
    -i 'hooks/*' \
    -i 'kit-init/*' \
    -i 'rules/*'

</file>

<file path="Cargo.toml">
[package]
name = "script-kit-gpui"
version = "0.1.0"
edition = "2021"
default-run = "script-kit-gpui"

[lib]
name = "script_kit_gpui"
path = "src/lib.rs"

[[bin]]
name = "script-kit-gpui"
path = "src/main.rs"

[[bin]]
name = "smoke-test"
path = "src/bin/smoke-test.rs"

[[bin]]
name = "storybook"
path = "src/bin/storybook.rs"

[dependencies]
gpui = { git = "https://github.com/zed-industries/zed" }
global-hotkey = "0.7"
notify = "6.1"
serde = { version = "1.0", features = ["derive"] }
serde_json = "1.0"
serde_yaml = "0.9"        # YAML frontmatter parsing for scriptlet bundles
shellexpand = "2.1"
core-graphics = "0.24"
cocoa = "0.26"
objc = "0.2"
dirs = "5.0"
smallvec = "1.15"
syntect = { version = "5.2", default-features = false, features = ["default-syntaxes", "default-themes", "regex-onig"] }
anyhow = "1.0"
thiserror = "2.0"
regex = "1.12"
nucleo-matcher = "0.3"         # High-performance fuzzy matching (10-100x faster than bespoke)
tracing = "0.1"
tracing-subscriber = { version = "0.3", features = ["json", "env-filter", "time"] }
time = { version = "0.3", features = ["formatting", "macros"] }
tracing-appender = "0.2"
chrono = { version = "0.4", features = ["serde"] }

# Text buffer for editor (efficient rope data structure)
ropey = "1.6"

# Terminal integration dependencies (Tier 2 - Alacritty)
# Versions chosen to match Zed's current known-working configuration (Dec 2025)
portable-pty = "0.8"           # PTY management for process spawning
alacritty_terminal = "0.25"    # Zed uses 0.25.1-rc1, this gets latest 0.25.x stable
vte = "0.15"                   # ANSI escape sequence parser, required by alacritty_terminal 0.25
bitflags = "2.10"              # For cell attribute flags
async-channel = "2.3"          # Async channel for stdin command listener

# Selected text functionality (getSelectedText/setSelectedText)
get-selected-text = "0.1"      # Hybrid AX + clipboard fallback for reading selected text
arboard = "3.6"                # Clipboard access for setSelectedText fallback
# Note: We use core-graphics directly for Cmd+V simulation (more reliable than enigo on macOS)
macos-accessibility-client = "0.0.1"  # Permission checking for accessibility APIs

# System tray / menu bar integration
tray-icon = "0.21"                    # Cross-platform tray icon (includes muda for menus)
resvg = "0.45"                        # SVG to PNG conversion for tray icon
usvg = "0.45"                         # SVG parsing (used by resvg)
tiny-skia = "0.11"                    # 2D graphics library for SVG rendering

# Clipboard history storage
rusqlite = { version = "0.31", features = ["bundled"] }
uuid = { version = "1.0", features = ["v4"] }
base64 = "0.22"
lru = "0.12"  # LRU cache for clipboard image eviction
sha2 = "0.10"  # SHA-256 for content hash dedup

# Image decoding for app icons
image = { version = "0.25", default-features = false, features = ["png"] }

# Cross-platform window screenshot capture
xcap = "0.8"

# File modification time handling for icon cache
filetime = "0.2"
glob = "0.3.3"
libc = "0.2.178"

# Keyring integration for secure secret storage (env prompt)
keyring = "3"

# Process monitoring for orphan detection and cleanup
sysinfo = "0.33"

# Non-poisoning mutex (doesn't require .unwrap() on lock)
parking_lot = "0.12"

# Open URLs and files with system default handler
open = "5"

# Math expression evaluation for calculate fallback
meval = "0.2"

# Storybook infrastructure (compile-time story registration + CLI)
inventory = "0.3"  # Compile-time story registration (same pattern as Zed)
clap = { version = "4", features = ["derive"] }  # CLI argument parsing

# gpui-component - Community UI component library for GPUI (FORKED)
# Fork adds set_selection() method for programmatic text selection (snippet/template support)
# Original: https://github.com/longbridge/gpui-component
# Fork: https://github.com/johnlindquist/gpui-component
gpui-component = { git = "https://github.com/johnlindquist/gpui-component", package = "gpui-component" }

# i18n support required by gpui-component
rust-i18n = "3"

# Core Foundation for CFRunLoop (keyboard monitoring)
core-foundation = "0.10"
foreign-types = "0.5"

# Cron scheduling support
croner = "3.0"                 # Parse and validate cron expressions
english-to-cron = "0.1"        # Convert natural language schedules to cron

# HTTP client for AI provider API calls
ureq = { version = "3", features = ["json"] }

# macOS launch-at-login via SMAppService
smappservice-rs = "0.1"
which = "8.0.0"
hex = "0.4.3"

[features]
default = ["ocr"]
# Enable tests that interact with system APIs (clipboard, accessibility, hotkeys)
# These tests may have side effects like modifying clipboard, opening dialogs, etc.
# Run with: cargo test --features system-tests
system-tests = []
# OCR support using macOS Vision framework (enabled by default on macOS)
ocr = []
# Performance instrumentation (disabled by default to reduce hot-path overhead)
# Enables key event timing, scroll timing, and rate logging
# Run with: cargo build --features perf
perf = []

[dev-dependencies]
tempfile = "3"

[build-dependencies]
dirs = "5.0"  # For build.rs to copy SDK to ~/.kit/lib/

# macOS bundle metadata for cargo-bundle
# Run: cargo bundle --release
[package.metadata.bundle]
name = "Script Kit"
identifier = "com.scriptkit.app"
icon = ["assets/icon.png", "assets/icon@2x.png", "assets/icon.icns"]
version = "0.1.0"
copyright = "Copyright (c) 2024 Script Kit. All rights reserved."
category = "public.app-category.developer-tools"
short_description = "Automation made simple"
osx_minimum_system_version = "10.15"
osx_url_schemes = ["scriptkit"]
resources = ["assets/*"]
# LSUIElement makes app an "agent app" - no menu bar, no Dock icon (like Raycast)
osx_info_plist_exts = ["assets/Info.plist.ext"]

</file>

<file path="build.rs">
// Build script for script-kit-gpui
//
// This script tells Cargo to rebuild when key files change.
// SDK deployment to ~/.scriptkit is now handled at runtime by setup::ensure_kit_setup()
// rather than at build time, ensuring the SDK is always in sync with the running binary.

fn main() {
    // Trigger rebuild when SDK source changes (it's embedded via include_str!)
    println!("cargo:rerun-if-changed=scripts/kit-sdk.ts");

    // Trigger rebuild when kit-init files change (embedded and shipped to ~/.scriptkit/)
    println!("cargo:rerun-if-changed=kit-init/config-template.ts");
    println!("cargo:rerun-if-changed=kit-init/theme.example.json");
    println!("cargo:rerun-if-changed=kit-init/GUIDE.md");

    // Trigger rebuild when bundled fonts change (embedded via include_bytes!)
    println!("cargo:rerun-if-changed=assets/fonts/JetBrainsMono-Regular.ttf");
    println!("cargo:rerun-if-changed=assets/fonts/JetBrainsMono-Bold.ttf");
    println!("cargo:rerun-if-changed=assets/fonts/JetBrainsMono-Italic.ttf");
    println!("cargo:rerun-if-changed=assets/fonts/JetBrainsMono-BoldItalic.ttf");
    println!("cargo:rerun-if-changed=assets/fonts/JetBrainsMono-Medium.ttf");
    println!("cargo:rerun-if-changed=assets/fonts/JetBrainsMono-SemiBold.ttf");
}

</file>

<file path="DEV.md">
# Development Guide for script-kit-gpui

This guide explains how to set up and use the development environment with hot-reload capabilities.

## Prerequisites

### Required

- **Rust** (1.70+) ‚Äì Install from https://rustup.rs/
- **cargo-watch** ‚Äì Auto-recompiler tool for Rust projects

  ```bash
  cargo install cargo-watch
  ```

### Optional but Recommended

- A terminal with good color support for clear output
- Text editor with Rust support (VS Code, Neovim, etc.)

## Running the Dev Server

Start the development runner with automatic rebuilds:

```bash
./dev.sh
```

Or if you prefer bash explicitly:

```bash
bash dev.sh
```

The script will:
1. Check if `cargo-watch` is installed (offering installation instructions if not)
2. Start the Rust compiler with `cargo watch -c -x run`
3. Clear the screen between rebuilds for clean output
4. Automatically rebuild and restart the app whenever you save a `.rs` file

Press **Ctrl+C** to stop the development runner.

## Hot Reload Workflow

This project supports multiple hot-reload mechanisms for a smooth development experience:

### 1. **Rust Code Changes** (via cargo-watch)
- Editing any `.rs` file triggers `cargo watch` to rebuild and restart the application
- The app instantly reflects your code changes
- No manual restart needed

### 2. **Theme Changes** (via ~/.kit/theme.json)
The app automatically watches `~/.kit/theme.json` for changes:
- Modify colors, fonts, or any theme settings in this file
- The UI refreshes in real-time without restarting the app
- See the "Theme Configuration" section below for details

### 3. **Script List Changes** (via ~/.scriptkit/scripts)
The app automatically detects new or modified scripts:
- Add a new script to `~/.scriptkit/scripts/`
- Remove or rename an existing script
- The app refreshes the script list without restarting
- Changes appear in the UI immediately

## Theme Configuration

To set up hot-reload for UI themes:

### First Time Setup

1. Create the Kit home directory:
   ```bash
   mkdir -p ~/.kit
   ```

2. Create or edit `~/.kit/theme.json`:
   ```json
   {
     "background": "#1e1e1e",
     "foreground": "#e0e0e0",
     "accent": "#007acc",
     "border": "#464647"
   }
   ```

3. Run the dev server - it will automatically watch this file for changes

### Editing Your Theme

Edit `~/.kit/theme.json` in your text editor while the dev server runs. Changes appear instantly in the UI without restarting.

## Global Hotkey Configuration

Script Kit allows you to customize the hotkey used to open/focus the application.

### Setup

The hotkey is configured in `~/.kit/config.ts` (TypeScript):

```typescript
// ~/.kit/config.ts
export default {
  hotkey: {
    modifiers: ['meta'],      // 'meta' = Cmd on macOS, Win on Windows
    key: 'Digit0',            // The key to press (default: 0)
  },
};
```

### How It Works

1. **App Startup**: The Rust app loads `~/.kit/config.ts`
2. **Transpilation**: Uses `bun build` to transpile TypeScript to JavaScript
3. **Extraction**: Runs the JavaScript with `bun` to extract the default export as JSON
4. **Registration**: Converts the JSON config to native hotkey codes and registers them
5. **Listening**: A background thread listens for the hotkey press
6. **Action**: When pressed, sets `HOTKEY_TRIGGERED` flag, which causes the app window to show/hide

### Supported Keys

**Number keys:** `Digit0`, `Digit1`, `Digit2`, ..., `Digit9`

**Letter keys:** `KeyA`, `KeyB`, ..., `KeyZ`

**Special keys:** `Space`, `Enter`, `Semicolon`

### Supported Modifiers

- `meta` - Command (‚åò) on macOS, Windows key on Windows
- `ctrl` - Control key
- `alt` - Option/Alt key  
- `shift` - Shift key

### Examples

```typescript
// Cmd+K (like VSCode command palette)
hotkey: { modifiers: ['meta'], key: 'KeyK' }

// Cmd+Shift+P (like VSCode)
hotkey: { modifiers: ['meta', 'shift'], key: 'KeyP' }

// Ctrl+Alt+Space (like Raycast on Linux)
hotkey: { modifiers: ['ctrl', 'alt'], key: 'Space' }
```

### Debugging Hotkey Issues

If your configured hotkey isn't working:

1. **Check startup logs**: Run the app and look for:
   ```
   [APP] Loaded config: hotkey=["meta"]+Digit0
   [HOTKEY] Registered global hotkey meta+Digit0 (id: 536870917)
   ```

2. **Verify the config is being read**: Check that the hotkey line shows your intended hotkey

3. **Test hotkey press**: Press the hotkey and look for:
   ```
   [HOTKEY] meta+Digit0 pressed (trigger #1)
   ```

4. **Unknown key warning**: If you see `Unknown key code: XYZ`, that key is not supported

5. **Restart after changes**: Configuration file changes are watched, but the hotkey listener needs a restart

## Best Practices for Development

### Terminal Setup

- Use a terminal with **256-color support** for the best visual experience
- **Full-screen terminal** recommended for viewing logs and output
- **Clear scrollback** between dev sessions for cleaner logs

### Workflow Tips

1. **Keep the log panel open** ‚Äì Use `Cmd+L` in the app to toggle the logs panel
   - Shows real-time events: hotkey presses, script executions, filter changes
   - Helpful for debugging configuration issues

2. **Test scripts incrementally**
   - Create test scripts in `~/.scriptkit/scripts/`
   - Run them through the UI to verify behavior
   - Check logs for execution details

3. **Hotkey testing**
    - Configure your hotkey in `~/.kit/config.ts` (TypeScript configuration)
    - The app loads this file, transpiles it with bun, and extracts the hotkey config
    - Press the configured hotkey (default: `Cmd+0`) to toggle the app visibility
    - Watch logs (Cmd+L) for hotkey registration: `[HOTKEY] Registered global hotkey meta+Digit0 (id: ...)`
    - When you press the hotkey, you'll see: `[HOTKEY] meta+Digit0 pressed (trigger #N)`
    - If your configured hotkey isn't working:
      1. Check the startup logs for the registered hotkey (should match your config)
      2. Verify the key code is valid (Digit0-9, KeyA-Z, Space, Enter, Semicolon, etc.)
      3. Verify the modifier is valid (meta=Cmd, ctrl=Control, alt=Option, shift=Shift)
      4. Restart the app after config changes (hot-reload watches for file changes)

4. **Use filtering** ‚Äì Type to search scripts
   - Helps verify the filtering logic is working correctly
   - Type to add characters, Backspace to remove, Escape to clear

### Common Development Tasks

#### Test a Single File Change
```bash
# Dev server is already running with cargo-watch
# Just save your file and wait ~2-5 seconds for recompile
```

#### Check the Build Log
```bash
# Look at the cargo-watch output in your terminal
# It shows compilation errors, warnings, and execution output
```

#### Revert a Change
```bash
# Stop dev server: Ctrl+C
# Run: git checkout path/to/file.rs
# Start dev server again: ./dev.sh
```

#### Clean Build
```bash
# Stop dev server: Ctrl+C
# Run: cargo clean
# Start dev server again: ./dev.sh
# (This will recompile everything from scratch)
```

## Troubleshooting

### Script crashes immediately after startup
- Check the terminal output for panic messages
- Look at the logs panel (Cmd+L) for detailed events
- Verify Rust dependencies are correct: `cargo build`

### cargo-watch not detecting changes
- Ensure files are being saved to disk (check modification timestamps)
- Stop and restart the dev server: Ctrl+C, then `./dev.sh`
- Try `cargo clean && ./dev.sh` for a full rebuild

### Hotkey not registering
- Check the logs panel (Cmd+L) for hotkey registration messages
- Verify your hotkey config in `~/.kit/config.json` is valid
- Some system shortcuts may conflict - try a different key combination

### Theme changes not appearing
- Verify `~/.kit/theme.json` exists and is valid JSON
- Check the logs for file watcher errors
- Restart the dev server if hot-reload doesn't trigger

## Architecture Overview

The dev experience is built on several components:

- **cargo-watch** ‚Äì Detects Rust source changes ‚Üí triggers rebuild/restart
- **notify crate** ‚Äì File system watcher for config and script changes
- **GPUI** ‚Äì The UI framework with reactive rendering
- **Global hotkey listener** ‚Äì Background thread detecting system hotkey press

These work together to provide instant feedback on:
1. Code changes (cargo-watch)
2. Configuration/theme changes (notify)
3. New/modified scripts (notify + file watcher)
4. Hotkey presses (global-hotkey thread)

## Interactive Prompt System (NEW!)

The app now supports Script Kit's v1 API prompts via bidirectional JSONL:

### Testing Interactive Scripts

1. Create a script using `arg()` or `div()`:
   ```typescript
   // ~/.scriptkit/scripts/my-test.ts
   const choice = await arg('Pick one', [
     { name: 'Option A', value: 'a' },
     { name: 'Option B', value: 'b' },
   ]);
   await div(`<h1>You picked: ${choice}</h1>`);
   ```

2. Run via the app UI (type to filter, Enter to execute)

3. Or trigger via test command:
   ```bash
   echo "run:my-test.ts" > /tmp/script-kit-gpui-cmd.txt
   ```

### Architecture

The interactive system uses:
- **Split threads**: Reader (blocks on script stdout) + Writer (sends to stdin)
- **Channels**: `mpsc` for thread-safe UI updates
- **AppView state**: ScriptList ‚Üí ArgPrompt ‚Üí DivPrompt ‚Üí ScriptList

### Key Log Events

Watch for these in the logs (`Cmd+L`):
```
[EXEC] Received message: Arg { ... }     # Script sent prompt
[UI] Showing arg prompt: 1 with 2 choices # UI displaying
[KEY] ArgPrompt key: 'enter'              # User selected
[UI] Submitting response for 1: Some(...) # Sending back
[EXEC] Sending to script: {...}           # Writer thread
[EXEC] Received message: Div { ... }      # Next prompt
```

### Smoke Test

Run the binary smoke test:
```bash
cargo run --bin smoke-test
cargo run --bin smoke-test -- --gui  # With GUI test
```

## Window Focus/Unfocus Theming (NEW!)

The app now supports context-aware theming based on window focus state. When the window loses focus (user clicks another app), the UI automatically transitions to a dimmed theme for visual feedback that it's inactive.

### How It Works

**Automatic Behavior (Default)**
- When window is **focused**: Uses standard, vibrant theme colors
- When window is **unfocused**: Colors are automatically dimmed by ~30% toward gray, reducing brightness and saturation
- This happens seamlessly without any configuration needed

**Custom Focus-Aware Colors**
You can customize the focused/unfocused appearance in `~/.kit/theme.json`:

```json
{
  "colors": {
    "background": { "main": 1980410, ... },
    "text": { "primary": 16777215, ... },
    ...
  },
  "focus_aware": {
    "focused": {
      "background": { "main": 1980410, ... },
      "text": { "primary": 16777215, ... },
      "ui": { "border": 4609607, "success": 65280 },
      "cursor": {
        "color": 65535,
        "blink_interval_ms": 500
      }
    },
    "unfocused": {
      "background": { "main": 1447037, ... },
      "text": { "primary": 11842475, ... },
      "ui": { "border": 3158809, "success": 43008 },
      "cursor": {
        "color": 43605,
        "blink_interval_ms": 1000
      }
    }
  }
}
```

### Fields Reference

- **`focus_aware.focused`** ‚Äì Colors when window has keyboard focus (optional)
- **`focus_aware.unfocused`** ‚Äì Colors when window is in background (optional)
- **`cursor.color`** ‚Äì Cursor color in hex (e.g., 0x00ffff = cyan)
- **`cursor.blink_interval_ms`** ‚Äì Blink speed in milliseconds

If focus-aware colors aren't specified in your theme.json, the app automatically creates a dimmed version of your standard colors when the window loses focus.

### Implementation Details

**Code Structure:**
- `theme.rs::Theme::get_colors(is_focused)` ‚Äì Returns appropriate ColorScheme based on window state
- `theme.rs::Theme::get_cursor_style(is_focused)` ‚Äì Returns cursor styling (only when focused)
- `main.rs::render()` ‚Äì Tracks window focus via `focus_handle.is_focused(window)`
- All render functions use `colors` from focus-aware selection instead of direct `theme.colors`

**Focus Tracking:**
```rust
if self.is_window_focused != is_focused {
    self.is_window_focused = is_focused;
    logging::log("FOCUS", &format!("Window focus state changed: {}", is_focused));
    cx.notify();  // Trigger re-render with new colors
}
```

**Dimming Algorithm:**
The automatic unfocused dimming blends each color channel 30% toward gray (0x808080):
```rust
new_value = (original * 70 + gray * 30) / 100
```
This reduces both brightness and saturation for a muted appearance.

### Testing Focus Behavior

1. Run the app: `./dev.sh`
2. Press your configured hotkey to show the window
3. Click on another application ‚Äì window loses focus
4. Observe the UI colors dim automatically
5. Click back on the Script Kit window ‚Äì colors return to normal
6. Watch the logs (`Cmd+L`) for focus change events:
   ```
   [FOCUS] Window focus state changed: true
   [THEME] Using focused colors (is_focused=true)
   ```

## Scroll Performance Optimization

The application includes a keyboard scroll performance fix that prevents UI hangs during fast keyboard repeat. When users hold down arrow keys to scroll through long lists, events can arrive faster than the UI can render individual updates (up to 100+ events per second).

### The Problem

Without optimization, each key event would trigger:
1. Selection index update
2. Scroll position recalculation
3. Full list re-render
4. Visibility recalculation

At 100 events/second, this creates an unbounded event queue that freezes the UI.

### The Solution: Event Coalescing

The fix implements a **20ms coalescing window** that batches rapid key events:

1. **Direction Tracking**: Tracks whether user is scrolling up or down
2. **Event Counting**: Accumulates events within the coalescing window
3. **Batched Updates**: Single UI update for multiple key events
4. **Delta Movement**: `move_selection_by(delta)` jumps N items at once

Key implementation in `src/main.rs`:
- `ScrollDirection` enum tracks up/down direction
- `process_arrow_key_with_coalescing()` handles event batching
- `flush_pending_scroll()` applies accumulated delta
- `move_selection_by(delta)` moves selection by N items

### Performance Instrumentation

The `src/perf.rs` module provides timing utilities:

- **KeyEventTracker**: Measures key event rates and processing latency
- **ScrollTimer**: Tracks scroll operation timing
- **FrameTimer**: Monitors frame rates and dropped frames
- **TimingGuard**: RAII-style timing with threshold alerts

Usage in code:
```rust
use crate::perf::{start_key_event, end_key_event, log_perf_summary};

let start = start_key_event();
// ... handle key event ...
end_key_event(start);
```

### Performance Logging

The `src/logging.rs` module includes scroll-specific log functions:

- `log_key_event_rate()` - Key events per second
- `log_scroll_queue_depth()` - Pending scroll events
- `log_render_stall()` - Detects UI freezes
- `log_scroll_batch()` - Batched scroll operations
- `log_key_repeat_timing()` - Time between key repeats

View performance logs with `Cmd+L` and filter for:
```
[KEY_PERF], [SCROLL_TIMING], [FRAME_PERF], [PERF_SLOW]
```

### Running Performance Tests

**SDK Test Harness** (`tests/sdk/test-scroll-perf.ts`):
```bash
# Run via bun (requires kit-sdk setup)
bun run tests/sdk/test-scroll-perf.ts
```

Test cases:
1. **scroll-normal**: 200ms interval (baseline)
2. **scroll-fast**: 50ms interval
3. **scroll-rapid**: 10ms interval (simulates key hold)
4. **scroll-burst**: Rapid bursts with pauses

**Benchmark Script** (`scripts/scroll-bench.ts`):
```bash
# Runs multiple iterations and outputs statistics
npx tsx scripts/scroll-bench.ts
```

Benchmark output includes:
- Min/Max/Avg latency per iteration
- P50, P95, P99 percentiles
- Pass/Fail assessment (P95 < 50ms threshold)

### Performance Thresholds

| Metric | Threshold | Description |
|--------|-----------|-------------|
| P95 Latency | < 50ms | 95th percentile key response time |
| Slow Key Event | > 16.67ms | Exceeds 60fps frame budget |
| Slow Scroll | > 8ms | Single scroll operation time |
| Dropped Frame | > 32ms | Below 30fps threshold |

### Interpreting Results

**Good performance:**
```
[KEY_PERF] rate=45.0/s avg=2.50ms slow=0.0% total=100
[SCROLL_TIMING] avg=1.50ms max=5.00ms slow=0 total=50
```

**Performance regression:**
```
[KEY_PERF] rate=45.0/s avg=25.00ms slow=15.0% total=100
[PERF_SLOW] key_event took 35.00ms (threshold: 16.67ms)
```

## Next Steps

1. ‚úÖ Install `cargo-watch`: `cargo install cargo-watch`
2. ‚úÖ Start dev server: `./dev.sh`
3. ‚úÖ Create a test script in `~/.scriptkit/scripts/`
4. ‚úÖ Configure hotkey in `~/.kit/config.json`
5. ‚úÖ Use `Cmd+L` to view logs while developing
6. ‚úÖ (NEW!) Customize focus-aware theme in `~/.kit/theme.json`
7. ‚úÖ (NEW!) Run scroll performance benchmarks to validate UI responsiveness

Happy hacking! üöÄ

</file>

</files>