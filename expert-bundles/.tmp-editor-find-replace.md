This file is a merged representation of the filtered codebase, combined into a single document by packx.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of filtered repository contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<usage_guidelines>
- Treat this file as a snapshot of the repository's state
- Be aware that this file may contain sensitive information
</usage_guidelines>

<notes>
- Files were filtered by packx based on content and extension matching
- Total files included: 4
</notes>
</file_summary>

<directory_structure>
src/prompt_handler.rs
src/syntax.rs
src/prompts/base.rs
src/editor.rs
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="src/prompt_handler.rs">
// Prompt message handling methods - extracted from app_impl.rs
// This file is included via include!() macro in main.rs

impl ScriptListApp {
    /// Handle a prompt message from the script
    fn handle_prompt_message(&mut self, msg: PromptMessage, cx: &mut Context<Self>) {
        match msg {
            PromptMessage::ShowArg {
                id,
                placeholder,
                choices,
                actions,
            } => {
                logging::log(
                    "UI",
                    &format!(
                        "Showing arg prompt: {} with {} choices, {} actions",
                        id,
                        choices.len(),
                        actions.as_ref().map(|a| a.len()).unwrap_or(0)
                    ),
                );
                let choice_count = choices.len();

                // If actions were provided, store them in the SDK actions system
                // so they can be triggered via shortcuts and Cmd+K
                if let Some(ref action_list) = actions {
                    // Store SDK actions for trigger_action_by_name lookup
                    self.sdk_actions = Some(action_list.clone());

                    // Register keyboard shortcuts for SDK actions
                    self.action_shortcuts.clear();
                    for action in action_list {
                        if let Some(shortcut) = &action.shortcut {
                            self.action_shortcuts.insert(
                                shortcuts::normalize_shortcut(shortcut),
                                action.name.clone(),
                            );
                        }
                    }
                } else {
                    // Clear any previous SDK actions
                    self.sdk_actions = None;
                    self.action_shortcuts.clear();
                }

                self.current_view = AppView::ArgPrompt {
                    id,
                    placeholder,
                    choices,
                    actions,
                };
                self.arg_input.clear();
                self.arg_selected_index = 0;
                self.focused_input = FocusedInput::ArgPrompt;
                // Request focus via pending_focus mechanism (will be applied on next render)
                self.pending_focus = Some(FocusTarget::AppRoot); // ArgPrompt uses parent focus
                                                                 // Resize window based on number of choices
                let view_type = if choice_count == 0 {
                    ViewType::ArgPromptNoChoices
                } else {
                    ViewType::ArgPromptWithChoices
                };
                resize_to_view_sync(view_type, choice_count);
                cx.notify();
            }
            PromptMessage::ShowDiv {
                id,
                html,
                container_classes,
                actions,
                placeholder: _placeholder, // TODO: render in header
                hint: _hint,               // TODO: render hint
                footer: _footer,           // TODO: render footer
                container_bg,
                container_padding,
                opacity,
            } => {
                logging::log("UI", &format!("Showing div prompt: {}", id));
                // Store SDK actions for the actions panel (Cmd+K)
                self.sdk_actions = actions;

                // Create submit callback for div prompt
                let response_sender = self.response_sender.clone();
                let submit_callback: std::sync::Arc<dyn Fn(String, Option<String>) + Send + Sync> =
                    std::sync::Arc::new(move |id, value| {
                        if let Some(ref sender) = response_sender {
                            let response = Message::Submit { id, value };
                            // Use try_send to avoid blocking UI thread
                            match sender.try_send(response) {
                                Ok(()) => {}
                                Err(std::sync::mpsc::TrySendError::Full(_)) => {
                                    logging::log(
                                        "WARN",
                                        "Response channel full - div response dropped",
                                    );
                                }
                                Err(std::sync::mpsc::TrySendError::Disconnected(_)) => {
                                    logging::log(
                                        "UI",
                                        "Response channel disconnected - script exited",
                                    );
                                }
                            }
                        }
                    });

                // Create focus handle for div prompt
                let div_focus_handle = cx.focus_handle();

                // Build container options from protocol message
                let container_options = ContainerOptions {
                    background: container_bg,
                    padding: container_padding.and_then(|v| {
                        if v.is_string() && v.as_str() == Some("none") {
                            Some(ContainerPadding::None)
                        } else if let Some(n) = v.as_f64() {
                            Some(ContainerPadding::Pixels(n as f32))
                        } else {
                            v.as_i64().map(|n| ContainerPadding::Pixels(n as f32))
                        }
                    }),
                    opacity,
                    container_classes,
                };

                // Create DivPrompt entity with proper HTML rendering
                let div_prompt = DivPrompt::with_options(
                    id.clone(),
                    html,
                    None, // tailwind param deprecated - use container_classes in options
                    div_focus_handle,
                    submit_callback,
                    std::sync::Arc::new(self.theme.clone()),
                    crate::designs::DesignVariant::Default,
                    container_options,
                );

                let entity = cx.new(|_| div_prompt);
                self.current_view = AppView::DivPrompt { id, entity };
                self.focused_input = FocusedInput::None; // DivPrompt has no text input
                self.pending_focus = Some(FocusTarget::AppRoot); // DivPrompt uses parent focus
                resize_to_view_sync(ViewType::DivPrompt, 0);
                cx.notify();
            }
            PromptMessage::ShowForm { id, html, actions } => {
                logging::log("UI", &format!("Showing form prompt: {}", id));

                // Store SDK actions for the actions panel (Cmd+K)
                self.sdk_actions = actions;

                // Create form field colors from theme
                let colors = FormFieldColors::from_theme(&self.theme);

                // Create FormPromptState entity with parsed fields
                let form_state = FormPromptState::new(id.clone(), html, colors, cx);
                let field_count = form_state.fields.len();
                let entity = cx.new(|_| form_state);

                self.current_view = AppView::FormPrompt { id, entity };
                self.focused_input = FocusedInput::None; // FormPrompt has its own focus handling
                self.pending_focus = Some(FocusTarget::FormPrompt);

                // Resize based on field count (more fields = taller window)
                let view_type = if field_count > 0 {
                    ViewType::ArgPromptWithChoices
                } else {
                    ViewType::DivPrompt
                };
                resize_to_view_sync(view_type, field_count);
                cx.notify();
            }
            PromptMessage::ShowTerm {
                id,
                command,
                actions,
            } => {
                logging::log(
                    "UI",
                    &format!("Showing term prompt: {} (command: {:?})", id, command),
                );

                // Store SDK actions for the actions panel (Cmd+K)
                self.sdk_actions = actions;

                // Create submit callback for terminal
                let response_sender = self.response_sender.clone();
                let submit_callback: std::sync::Arc<dyn Fn(String, Option<String>) + Send + Sync> =
                    std::sync::Arc::new(move |id, value| {
                        if let Some(ref sender) = response_sender {
                            let response = Message::Submit { id, value };
                            // Use try_send to avoid blocking UI thread
                            match sender.try_send(response) {
                                Ok(()) => {}
                                Err(std::sync::mpsc::TrySendError::Full(_)) => {
                                    logging::log(
                                        "WARN",
                                        "Response channel full - terminal response dropped",
                                    );
                                }
                                Err(std::sync::mpsc::TrySendError::Disconnected(_)) => {
                                    logging::log(
                                        "UI",
                                        "Response channel disconnected - script exited",
                                    );
                                }
                            }
                        }
                    });

                // Get the target height for terminal view (subtract footer height)
                let term_height =
                    window_resize::layout::MAX_HEIGHT - px(window_resize::layout::FOOTER_HEIGHT);

                // Create terminal with explicit height - GPUI entities don't inherit parent flex sizing
                match term_prompt::TermPrompt::with_height(
                    id.clone(),
                    command,
                    self.focus_handle.clone(),
                    submit_callback,
                    std::sync::Arc::new(self.theme.clone()),
                    std::sync::Arc::new(self.config.clone()),
                    Some(term_height),
                ) {
                    Ok(term_prompt) => {
                        let entity = cx.new(|_| term_prompt);
                        self.current_view = AppView::TermPrompt { id, entity };
                        self.focused_input = FocusedInput::None; // Terminal handles its own cursor
                        self.pending_focus = Some(FocusTarget::TermPrompt);
                        // DEFERRED RESIZE: Avoid RefCell borrow error by deferring window resize
                        // to after the current GPUI update cycle completes. Synchronous Cocoa
                        // setFrame: calls during render can trigger events that re-borrow GPUI state.
                        cx.spawn(async move |_this, _cx| {
                            resize_to_view_sync(ViewType::TermPrompt, 0);
                        })
                        .detach();
                        cx.notify();
                    }
                    Err(e) => {
                        tracing::error!(error = %e, "Failed to create terminal");
                        logging::log("ERROR", &format!("Failed to create terminal: {}", e));
                    }
                }
            }
            PromptMessage::ShowEditor {
                id,
                content,
                language,
                template,
                actions,
            } => {
                logging::log(
                    "UI",
                    &format!(
                        "Showing editor prompt: {} (language: {:?}, template: {})",
                        id,
                        language,
                        template.is_some()
                    ),
                );

                // Store SDK actions for the actions panel (Cmd+K)
                self.sdk_actions = actions;

                // Create submit callback for editor
                let response_sender = self.response_sender.clone();
                let submit_callback: std::sync::Arc<dyn Fn(String, Option<String>) + Send + Sync> =
                    std::sync::Arc::new(move |id, value| {
                        if let Some(ref sender) = response_sender {
                            let response = Message::Submit { id, value };
                            // Use try_send to avoid blocking UI thread
                            match sender.try_send(response) {
                                Ok(()) => {}
                                Err(std::sync::mpsc::TrySendError::Full(_)) => {
                                    logging::log(
                                        "WARN",
                                        "Response channel full - editor response dropped",
                                    );
                                }
                                Err(std::sync::mpsc::TrySendError::Disconnected(_)) => {
                                    logging::log(
                                        "UI",
                                        "Response channel disconnected - script exited",
                                    );
                                }
                            }
                        }
                    });

                // CRITICAL: Create a SEPARATE focus handle for the editor.
                // Using the parent's focus handle causes keyboard event routing issues
                // because the parent checks is_focused() in its render and both parent
                // and child would be tracking the same handle.
                let editor_focus_handle = cx.focus_handle();

                // Get the target height for editor view (subtract footer height for unified footer)
                let editor_height = px(700.0 - window_resize::layout::FOOTER_HEIGHT);

                // Create editor v2 (gpui-component based with Find/Replace)
                // Default to markdown for all editor content
                let resolved_language = language.unwrap_or_else(|| "markdown".to_string());

                // Use with_template if template provided, or if content contains tabstop patterns
                // This auto-detects VSCode-style templates like ${1:name} or $1
                let content_str = content.unwrap_or_default();
                let has_tabstops = content_str.contains("${")
                    || regex::Regex::new(r"\$\d")
                        .map(|re| re.is_match(&content_str))
                        .unwrap_or(false);

                let editor_prompt = if let Some(template_str) = template {
                    EditorPrompt::with_template(
                        id.clone(),
                        template_str,
                        resolved_language.clone(),
                        editor_focus_handle.clone(),
                        submit_callback,
                        std::sync::Arc::new(self.theme.clone()),
                        std::sync::Arc::new(self.config.clone()),
                        Some(editor_height),
                    )
                } else if has_tabstops {
                    // Auto-detect template in content
                    logging::log(
                        "UI",
                        &format!("Auto-detected template in content: {}", content_str),
                    );
                    EditorPrompt::with_template(
                        id.clone(),
                        content_str,
                        resolved_language.clone(),
                        editor_focus_handle.clone(),
                        submit_callback,
                        std::sync::Arc::new(self.theme.clone()),
                        std::sync::Arc::new(self.config.clone()),
                        Some(editor_height),
                    )
                } else {
                    EditorPrompt::with_height(
                        id.clone(),
                        content_str,
                        resolved_language.clone(),
                        editor_focus_handle.clone(),
                        submit_callback,
                        std::sync::Arc::new(self.theme.clone()),
                        std::sync::Arc::new(self.config.clone()),
                        Some(editor_height),
                    )
                };

                let entity = cx.new(|_| editor_prompt);
                self.current_view = AppView::EditorPrompt {
                    id,
                    entity,
                    focus_handle: editor_focus_handle,
                };
                self.focused_input = FocusedInput::None; // Editor handles its own focus
                self.pending_focus = Some(FocusTarget::EditorPrompt);

                // DEFERRED RESIZE: Avoid RefCell borrow error by deferring window resize
                // to after the current GPUI update cycle completes.
                cx.spawn(async move |_this, _cx| {
                    resize_to_view_sync(ViewType::EditorPrompt, 0);
                })
                .detach();
                cx.notify();
            }
            PromptMessage::ScriptExit => {
                logging::log("VISIBILITY", "=== ScriptExit message received ===");
                let was_visible = script_kit_gpui::is_main_window_visible();
                logging::log(
                    "VISIBILITY",
                    &format!("WINDOW_VISIBLE was: {}", was_visible),
                );

                // CRITICAL: Update visibility state so hotkey toggle works correctly
                script_kit_gpui::set_main_window_visible(false);
                logging::log("VISIBILITY", "WINDOW_VISIBLE set to: false");

                // Set flag so next hotkey show will reset to script list
                NEEDS_RESET.store(true, Ordering::SeqCst);
                logging::log("VISIBILITY", "NEEDS_RESET set to: true");

                self.reset_to_script_list(cx);
                logging::log("VISIBILITY", "reset_to_script_list() called");

                // Hide window when script completes - scripts only stay active while code is running
                cx.hide();
                logging::log(
                    "VISIBILITY",
                    "cx.hide() called - window hidden on script completion",
                );
            }
            PromptMessage::HideWindow => {
                logging::log("VISIBILITY", "=== HideWindow message received ===");
                let was_visible = script_kit_gpui::is_main_window_visible();
                logging::log(
                    "VISIBILITY",
                    &format!("WINDOW_VISIBLE was: {}", was_visible),
                );

                // CRITICAL: Update visibility state so hotkey toggle works correctly
                script_kit_gpui::set_main_window_visible(false);
                logging::log("VISIBILITY", "WINDOW_VISIBLE set to: false");

                // Set flag so next hotkey show will reset to script list
                NEEDS_RESET.store(true, Ordering::SeqCst);
                logging::log("VISIBILITY", "NEEDS_RESET set to: true");

                cx.hide();
                logging::log(
                    "VISIBILITY",
                    "cx.hide() called - window should now be hidden",
                );
            }
            PromptMessage::OpenBrowser { url } => {
                logging::log("UI", &format!("Opening browser: {}", url));
                #[cfg(target_os = "macos")]
                {
                    match std::process::Command::new("open").arg(&url).spawn() {
                        Ok(_) => logging::log(
                            "UI",
                            &format!("Successfully opened URL in browser: {}", url),
                        ),
                        Err(e) => {
                            logging::log("ERROR", &format!("Failed to open URL '{}': {}", url, e))
                        }
                    }
                }
                #[cfg(target_os = "linux")]
                {
                    match std::process::Command::new("xdg-open").arg(&url).spawn() {
                        Ok(_) => logging::log(
                            "UI",
                            &format!("Successfully opened URL in browser: {}", url),
                        ),
                        Err(e) => {
                            logging::log("ERROR", &format!("Failed to open URL '{}': {}", url, e))
                        }
                    }
                }
                #[cfg(target_os = "windows")]
                {
                    match std::process::Command::new("cmd")
                        .args(["/C", "start", &url])
                        .spawn()
                    {
                        Ok(_) => logging::log(
                            "UI",
                            &format!("Successfully opened URL in browser: {}", url),
                        ),
                        Err(e) => {
                            logging::log("ERROR", &format!("Failed to open URL '{}': {}", url, e))
                        }
                    }
                }
            }
            PromptMessage::RunScript { path } => {
                logging::log("EXEC", &format!("RunScript command received: {}", path));

                // Create a Script struct from the path
                let script_path = std::path::PathBuf::from(&path);
                let script_name = script_path
                    .file_stem()
                    .and_then(|s| s.to_str())
                    .unwrap_or("unknown")
                    .to_string();
                let extension = script_path
                    .extension()
                    .and_then(|e| e.to_str())
                    .unwrap_or("ts")
                    .to_string();

                let script = scripts::Script {
                    name: script_name.clone(),
                    description: Some(format!("External script: {}", path)),
                    path: script_path,
                    extension,
                    icon: None,
                    alias: None,
                    shortcut: None,
                    typed_metadata: None,
                    schema: None,
                };

                logging::log("EXEC", &format!("Executing script: {}", script_name));
                self.execute_interactive(&script, cx);
            }
            PromptMessage::ScriptError {
                error_message,
                stderr_output,
                exit_code,
                stack_trace,
                script_path,
                suggestions,
            } => {
                logging::log(
                    "ERROR",
                    &format!(
                        "Script error received: {} (exit code: {:?})",
                        error_message, exit_code
                    ),
                );

                // Create error toast with expandable details
                // Use stderr_output if available, otherwise use stack_trace
                let details_text = stderr_output.clone().or_else(|| stack_trace.clone());
                let toast = Toast::error(error_message.clone(), &self.theme)
                    .details_opt(details_text.clone())
                    .duration_ms(Some(10000)); // 10 seconds for errors

                // Add copy button action if we have stderr/stack trace
                let toast = if let Some(ref trace) = details_text {
                    let trace_clone = trace.clone();
                    toast.action(ToastAction::new(
                        "Copy Error",
                        Box::new(move |_, _, _| {
                            // Copy to clipboard
                            use arboard::Clipboard;
                            if let Ok(mut clipboard) = Clipboard::new() {
                                let _ = clipboard.set_text(trace_clone.clone());
                                logging::log("UI", "Error copied to clipboard");
                            }
                        }),
                    ))
                } else {
                    toast
                };

                // Log suggestions if present
                if !suggestions.is_empty() {
                    logging::log("ERROR", &format!("Suggestions: {:?}", suggestions));
                }

                // Push toast to manager
                let toast_id = self.toast_manager.push(toast);
                logging::log(
                    "UI",
                    &format!(
                        "Toast created for script error: {} (id: {})",
                        script_path, toast_id
                    ),
                );

                cx.notify();
            }
            PromptMessage::ProtocolError {
                correlation_id,
                summary,
                details,
                severity,
                script_path,
            } => {
                tracing::warn!(
                    correlation_id = %correlation_id,
                    script_path = %script_path,
                    summary = %summary,
                    "Protocol parse issue received"
                );

                let mut toast = Toast::from_severity(summary.clone(), severity, &self.theme)
                    .details_opt(details.clone())
                    .duration_ms(Some(8000));

                if let Some(ref detail_text) = details {
                    let detail_clone = detail_text.clone();
                    toast = toast.action(ToastAction::new(
                        "Copy Details",
                        Box::new(move |_, _, _| {
                            use arboard::Clipboard;
                            if let Ok(mut clipboard) = Clipboard::new() {
                                let _ = clipboard.set_text(detail_clone.clone());
                            }
                        }),
                    ));
                }

                self.toast_manager.push(toast);
                cx.notify();
            }
            PromptMessage::UnhandledMessage { message_type } => {
                logging::log(
                    "WARN",
                    &format!("Displaying unhandled message warning: {}", message_type),
                );

                let toast = Toast::warning(
                    format!("'{}' is not yet implemented", message_type),
                    &self.theme,
                )
                .duration_ms(Some(5000));

                self.toast_manager.push(toast);
                cx.notify();
            }
            PromptMessage::GetState { request_id } => {
                logging::log(
                    "UI",
                    &format!("Collecting state for request: {}", request_id),
                );

                // Collect current UI state
                let (
                    prompt_type,
                    prompt_id,
                    placeholder,
                    input_value,
                    choice_count,
                    visible_choice_count,
                    selected_index,
                    selected_value,
                ) = match &self.current_view {
                    AppView::ScriptList => {
                        let filtered_len = self.filtered_results().len();
                        let selected_value = if self.selected_index < filtered_len {
                            self.filtered_results()
                                .get(self.selected_index)
                                .map(|r| match r {
                                    scripts::SearchResult::Script(m) => m.script.name.clone(),
                                    scripts::SearchResult::Scriptlet(m) => m.scriptlet.name.clone(),
                                    scripts::SearchResult::BuiltIn(m) => m.entry.name.clone(),
                                    scripts::SearchResult::App(m) => m.app.name.clone(),
                                    scripts::SearchResult::Window(m) => m.window.title.clone(),
                                    scripts::SearchResult::Agent(m) => m.agent.name.clone(),
                                    scripts::SearchResult::Fallback(m) => {
                                        m.fallback.name().to_string()
                                    }
                                })
                        } else {
                            None
                        };
                        (
                            "none".to_string(),
                            None,
                            None,
                            self.filter_text.clone(),
                            self.scripts.len()
                                + self.scriptlets.len()
                                + self.builtin_entries.len()
                                + self.apps.len(),
                            filtered_len,
                            self.selected_index as i32,
                            selected_value,
                        )
                    }
                    AppView::ArgPrompt {
                        id,
                        placeholder,
                        choices,
                        actions: _,
                    } => {
                        let filtered = self.get_filtered_arg_choices(choices);
                        let selected_value = if self.arg_selected_index < filtered.len() {
                            filtered
                                .get(self.arg_selected_index)
                                .map(|c| c.value.clone())
                        } else {
                            None
                        };
                        (
                            "arg".to_string(),
                            Some(id.clone()),
                            Some(placeholder.clone()),
                            self.arg_input.text().to_string(),
                            choices.len(),
                            filtered.len(),
                            self.arg_selected_index as i32,
                            selected_value,
                        )
                    }
                    AppView::DivPrompt { id, .. } => (
                        "div".to_string(),
                        Some(id.clone()),
                        None,
                        String::new(),
                        0,
                        0,
                        -1,
                        None,
                    ),
                    AppView::FormPrompt { id, .. } => (
                        "form".to_string(),
                        Some(id.clone()),
                        None,
                        String::new(),
                        0,
                        0,
                        -1,
                        None,
                    ),
                    AppView::TermPrompt { id, .. } => (
                        "term".to_string(),
                        Some(id.clone()),
                        None,
                        String::new(),
                        0,
                        0,
                        -1,
                        None,
                    ),
                    AppView::EditorPrompt { id, .. } => (
                        "editor".to_string(),
                        Some(id.clone()),
                        None,
                        String::new(),
                        0,
                        0,
                        -1,
                        None,
                    ),
                    AppView::SelectPrompt { id, .. } => (
                        "select".to_string(),
                        Some(id.clone()),
                        None,
                        String::new(),
                        0,
                        0,
                        -1,
                        None,
                    ),
                    AppView::PathPrompt { id, .. } => (
                        "path".to_string(),
                        Some(id.clone()),
                        None,
                        String::new(),
                        0,
                        0,
                        -1,
                        None,
                    ),
                    AppView::EnvPrompt { id, .. } => (
                        "env".to_string(),
                        Some(id.clone()),
                        None,
                        String::new(),
                        0,
                        0,
                        -1,
                        None,
                    ),
                    AppView::DropPrompt { id, .. } => (
                        "drop".to_string(),
                        Some(id.clone()),
                        None,
                        String::new(),
                        0,
                        0,
                        -1,
                        None,
                    ),
                    AppView::TemplatePrompt { id, .. } => (
                        "template".to_string(),
                        Some(id.clone()),
                        None,
                        String::new(),
                        0,
                        0,
                        -1,
                        None,
                    ),
                    AppView::ActionsDialog => (
                        "actions".to_string(),
                        None,
                        None,
                        String::new(),
                        0,
                        0,
                        -1,
                        None,
                    ),
                    // P0 FIX: View state only - data comes from self.cached_clipboard_entries
                    AppView::ClipboardHistoryView {
                        filter,
                        selected_index,
                    } => {
                        let entries = &self.cached_clipboard_entries;
                        let filtered_count = if filter.is_empty() {
                            entries.len()
                        } else {
                            let filter_lower = filter.to_lowercase();
                            entries
                                .iter()
                                .filter(|e| e.text_preview.to_lowercase().contains(&filter_lower))
                                .count()
                        };
                        (
                            "clipboardHistory".to_string(),
                            None,
                            None,
                            filter.clone(),
                            entries.len(),
                            filtered_count,
                            *selected_index as i32,
                            None,
                        )
                    }
                    // P0 FIX: View state only - data comes from self.apps
                    AppView::AppLauncherView {
                        filter,
                        selected_index,
                    } => {
                        let apps = &self.apps;
                        let filtered_count = if filter.is_empty() {
                            apps.len()
                        } else {
                            let filter_lower = filter.to_lowercase();
                            apps.iter()
                                .filter(|a| a.name.to_lowercase().contains(&filter_lower))
                                .count()
                        };
                        (
                            "appLauncher".to_string(),
                            None,
                            None,
                            filter.clone(),
                            apps.len(),
                            filtered_count,
                            *selected_index as i32,
                            None,
                        )
                    }
                    // P0 FIX: View state only - data comes from self.cached_windows
                    AppView::WindowSwitcherView {
                        filter,
                        selected_index,
                    } => {
                        let windows = &self.cached_windows;
                        let filtered_count = if filter.is_empty() {
                            windows.len()
                        } else {
                            let filter_lower = filter.to_lowercase();
                            windows
                                .iter()
                                .filter(|w| {
                                    w.title.to_lowercase().contains(&filter_lower)
                                        || w.app.to_lowercase().contains(&filter_lower)
                                })
                                .count()
                        };
                        (
                            "windowSwitcher".to_string(),
                            None,
                            None,
                            filter.clone(),
                            windows.len(),
                            filtered_count,
                            *selected_index as i32,
                            None,
                        )
                    }
                    AppView::DesignGalleryView {
                        filter,
                        selected_index,
                    } => {
                        let total_items = designs::separator_variations::SeparatorStyle::count()
                            + designs::icon_variations::total_icon_count()
                            + 8
                            + 6; // headers
                        (
                            "designGallery".to_string(),
                            None,
                            None,
                            filter.clone(),
                            total_items,
                            total_items,
                            *selected_index as i32,
                            None,
                        )
                    }
                    AppView::ScratchPadView { .. } => (
                        "scratchPad".to_string(),
                        Some("scratch-pad".to_string()),
                        None,
                        String::new(),
                        0,
                        0,
                        -1,
                        None,
                    ),
                    AppView::QuickTerminalView { .. } => (
                        "quickTerminal".to_string(),
                        Some("quick-terminal".to_string()),
                        None,
                        String::new(),
                        0,
                        0,
                        -1,
                        None,
                    ),
                    AppView::FileSearchView {
                        ref query,
                        selected_index,
                    } => (
                        "fileSearch".to_string(),
                        Some("file-search".to_string()),
                        None,
                        query.clone(),
                        self.cached_file_results.len(),
                        self.cached_file_results.len(),
                        *selected_index as i32,
                        self.cached_file_results
                            .get(*selected_index)
                            .map(|f| f.name.clone()),
                    ),
                };

                // Focus state: we use focused_input as a proxy since we don't have Window access here.
                // When window is visible and we're tracking an input, we're focused.
                let window_visible = script_kit_gpui::is_main_window_visible();
                let is_focused = window_visible && self.focused_input != FocusedInput::None;

                // Create the response
                let response = Message::state_result(
                    request_id.clone(),
                    prompt_type,
                    prompt_id,
                    placeholder,
                    input_value,
                    choice_count,
                    visible_choice_count,
                    selected_index,
                    selected_value,
                    is_focused,
                    window_visible,
                );

                logging::log(
                    "UI",
                    &format!("Sending state result for request: {}", request_id),
                );

                // Send the response - use try_send to avoid blocking UI
                if let Some(ref sender) = self.response_sender {
                    match sender.try_send(response) {
                        Ok(()) => {}
                        Err(std::sync::mpsc::TrySendError::Full(_)) => {
                            logging::log("WARN", "Response channel full - state result dropped");
                        }
                        Err(std::sync::mpsc::TrySendError::Disconnected(_)) => {
                            logging::log("UI", "Response channel disconnected - script exited");
                        }
                    }
                } else {
                    logging::log("ERROR", "No response sender available for state result");
                }
            }
            PromptMessage::GetLayoutInfo { request_id } => {
                logging::log(
                    "UI",
                    &format!("Collecting layout info for request: {}", request_id),
                );

                // Build layout info from current window state
                let layout_info = self.build_layout_info(cx);

                // Create the response
                let response = Message::layout_info_result(request_id.clone(), layout_info);

                logging::log(
                    "UI",
                    &format!("Sending layout info result for request: {}", request_id),
                );

                // Send the response - use try_send to avoid blocking UI
                if let Some(ref sender) = self.response_sender {
                    match sender.try_send(response) {
                        Ok(()) => {}
                        Err(std::sync::mpsc::TrySendError::Full(_)) => {
                            logging::log("WARN", "Response channel full - layout info dropped");
                        }
                        Err(std::sync::mpsc::TrySendError::Disconnected(_)) => {
                            logging::log("UI", "Response channel disconnected - script exited");
                        }
                    }
                } else {
                    logging::log(
                        "ERROR",
                        "No response sender available for layout info result",
                    );
                }
            }
            PromptMessage::ForceSubmit { value } => {
                logging::log(
                    "UI",
                    &format!("ForceSubmit received with value: {:?}", value),
                );

                // Get the current prompt ID and submit the value
                let prompt_id = match &self.current_view {
                    AppView::ArgPrompt { id, .. } => Some(id.clone()),
                    AppView::DivPrompt { id, .. } => Some(id.clone()),
                    AppView::FormPrompt { id, .. } => Some(id.clone()),
                    AppView::TermPrompt { id, .. } => Some(id.clone()),
                    AppView::EditorPrompt { id, .. } => Some(id.clone()),
                    _ => None,
                };

                if let Some(id) = prompt_id {
                    // Convert serde_json::Value to String for submission
                    let value_str = match &value {
                        serde_json::Value::String(s) => s.clone(),
                        serde_json::Value::Null => String::new(),
                        other => other.to_string(),
                    };

                    logging::log(
                        "UI",
                        &format!(
                            "ForceSubmit: submitting '{}' for prompt '{}'",
                            value_str, id
                        ),
                    );
                    self.submit_prompt_response(id, Some(value_str), cx);
                } else {
                    logging::log(
                        "WARN",
                        "ForceSubmit received but no active prompt to submit to",
                    );
                }
            }
            // ============================================================
            // NEW PROMPT TYPES (scaffolding - TODO: implement full UI)
            // ============================================================
            PromptMessage::ShowPath {
                id,
                start_path,
                hint,
            } => {
                logging::log(
                    "UI",
                    &format!(
                        "Showing path prompt: {} (start: {:?}, hint: {:?})",
                        id, start_path, hint
                    ),
                );

                let response_sender = self.response_sender.clone();
                let submit_callback: std::sync::Arc<dyn Fn(String, Option<String>) + Send + Sync> =
                    std::sync::Arc::new(move |id, value| {
                        logging::log(
                            "UI",
                            &format!(
                                "PathPrompt submit_callback called: id={}, value={:?}",
                                id, value
                            ),
                        );
                        if let Some(ref sender) = response_sender {
                            let response = Message::Submit { id, value };
                            // Use try_send to avoid blocking UI thread
                            match sender.try_send(response) {
                                Ok(()) => {}
                                Err(std::sync::mpsc::TrySendError::Full(_)) => {
                                    logging::log(
                                        "WARN",
                                        "Response channel full - path response dropped",
                                    );
                                }
                                Err(std::sync::mpsc::TrySendError::Disconnected(_)) => {
                                    logging::log(
                                        "UI",
                                        "Response channel disconnected - script exited",
                                    );
                                }
                            }
                        }
                    });

                // Clone the path_actions_showing and search_text Arcs for header display
                let path_actions_showing = self.path_actions_showing.clone();
                let path_actions_search_text = self.path_actions_search_text.clone();

                let focus_handle = cx.focus_handle();
                let path_prompt = PathPrompt::new(
                    id.clone(),
                    start_path,
                    hint,
                    focus_handle.clone(),
                    submit_callback,
                    std::sync::Arc::new(self.theme.clone()),
                )
                // Note: Legacy callbacks are no longer needed - we use events now
                // But we still pass the shared state for header display
                .with_actions_showing(path_actions_showing)
                .with_actions_search_text(path_actions_search_text);

                let entity = cx.new(|_| path_prompt);

                // Subscribe to PathPrompt events for actions dialog control
                // This replaces the mutex-polling pattern with event-driven handling
                cx.subscribe(
                    &entity,
                    |this, _entity, event: &PathPromptEvent, cx| match event {
                        PathPromptEvent::ShowActions(path_info) => {
                            logging::log(
                                "UI",
                                &format!(
                                    "PathPromptEvent::ShowActions received for: {}",
                                    path_info.path
                                ),
                            );
                            this.handle_show_path_actions(path_info.clone(), cx);
                        }
                        PathPromptEvent::CloseActions => {
                            logging::log("UI", "PathPromptEvent::CloseActions received");
                            this.handle_close_path_actions(cx);
                        }
                    },
                )
                .detach();

                self.current_view = AppView::PathPrompt {
                    id,
                    entity,
                    focus_handle,
                };
                self.focused_input = FocusedInput::None;
                self.pending_focus = Some(FocusTarget::PathPrompt);

                // Reset showing state (no more mutex polling needed)
                if let Ok(mut guard) = self.path_actions_showing.lock() {
                    *guard = false;
                }

                resize_to_view_sync(ViewType::ScriptList, 20);
                cx.notify();
            }
            PromptMessage::ShowEnv {
                id,
                key,
                prompt,
                secret,
            } => {
                tracing::info!(id, key, ?prompt, secret, "ShowEnv received");
                logging::log(
                    "UI",
                    &format!(
                        "ShowEnv prompt received: {} (key: {}, secret: {})",
                        id, key, secret
                    ),
                );

                // Create submit callback for env prompt
                let response_sender = self.response_sender.clone();
                let submit_callback: std::sync::Arc<dyn Fn(String, Option<String>) + Send + Sync> =
                    std::sync::Arc::new(move |id, value| {
                        if let Some(ref sender) = response_sender {
                            let response = Message::Submit { id, value };
                            // Use try_send to avoid blocking UI thread
                            match sender.try_send(response) {
                                Ok(()) => {}
                                Err(std::sync::mpsc::TrySendError::Full(_)) => {
                                    logging::log(
                                        "WARN",
                                        "Response channel full - env response dropped",
                                    );
                                }
                                Err(std::sync::mpsc::TrySendError::Disconnected(_)) => {
                                    logging::log(
                                        "UI",
                                        "Response channel disconnected - script exited",
                                    );
                                }
                            }
                        }
                    });

                // Create EnvPrompt entity
                let focus_handle = self.focus_handle.clone();
                let mut env_prompt = prompts::EnvPrompt::new(
                    id.clone(),
                    key,
                    prompt,
                    secret,
                    focus_handle,
                    submit_callback,
                    std::sync::Arc::new(self.theme.clone()),
                );

                // Check keyring first - if value exists, auto-submit without showing UI
                if env_prompt.check_keyring_and_auto_submit() {
                    logging::log("UI", "EnvPrompt: value found in keyring, auto-submitted");
                    // Don't switch view, the callback already submitted
                    cx.notify();
                    return;
                }

                let entity = cx.new(|_| env_prompt);
                self.current_view = AppView::EnvPrompt { id, entity };
                self.focused_input = FocusedInput::None; // EnvPrompt has its own focus handling
                self.pending_focus = Some(FocusTarget::EnvPrompt);

                resize_to_view_sync(ViewType::ArgPromptNoChoices, 0);
                cx.notify();
            }
            PromptMessage::ShowDrop {
                id,
                placeholder,
                hint,
            } => {
                tracing::info!(id, ?placeholder, ?hint, "ShowDrop received");
                logging::log(
                    "UI",
                    &format!(
                        "ShowDrop prompt received: {} (placeholder: {:?})",
                        id, placeholder
                    ),
                );

                // Create submit callback for drop prompt
                let response_sender = self.response_sender.clone();
                let submit_callback: std::sync::Arc<dyn Fn(String, Option<String>) + Send + Sync> =
                    std::sync::Arc::new(move |id, value| {
                        if let Some(ref sender) = response_sender {
                            let response = Message::Submit { id, value };
                            // Use try_send to avoid blocking UI thread
                            match sender.try_send(response) {
                                Ok(()) => {}
                                Err(std::sync::mpsc::TrySendError::Full(_)) => {
                                    logging::log(
                                        "WARN",
                                        "Response channel full - drop response dropped",
                                    );
                                }
                                Err(std::sync::mpsc::TrySendError::Disconnected(_)) => {
                                    logging::log(
                                        "UI",
                                        "Response channel disconnected - script exited",
                                    );
                                }
                            }
                        }
                    });

                // Create DropPrompt entity
                let focus_handle = self.focus_handle.clone();
                let drop_prompt = prompts::DropPrompt::new(
                    id.clone(),
                    placeholder,
                    hint,
                    focus_handle,
                    submit_callback,
                    std::sync::Arc::new(self.theme.clone()),
                );

                let entity = cx.new(|_| drop_prompt);
                self.current_view = AppView::DropPrompt { id, entity };
                self.focused_input = FocusedInput::None;
                self.pending_focus = Some(FocusTarget::DropPrompt);

                resize_to_view_sync(ViewType::DivPrompt, 0);
                cx.notify();
            }
            PromptMessage::ShowTemplate { id, template } => {
                tracing::info!(id, template, "ShowTemplate received");
                logging::log(
                    "UI",
                    &format!(
                        "ShowTemplate prompt received: {} (template: {})",
                        id, template
                    ),
                );

                // Create submit callback for template prompt
                let response_sender = self.response_sender.clone();
                let submit_callback: std::sync::Arc<dyn Fn(String, Option<String>) + Send + Sync> =
                    std::sync::Arc::new(move |id, value| {
                        if let Some(ref sender) = response_sender {
                            let response = Message::Submit { id, value };
                            // Use try_send to avoid blocking UI thread
                            match sender.try_send(response) {
                                Ok(()) => {}
                                Err(std::sync::mpsc::TrySendError::Full(_)) => {
                                    logging::log(
                                        "WARN",
                                        "Response channel full - template response dropped",
                                    );
                                }
                                Err(std::sync::mpsc::TrySendError::Disconnected(_)) => {
                                    logging::log(
                                        "UI",
                                        "Response channel disconnected - script exited",
                                    );
                                }
                            }
                        }
                    });

                // Create TemplatePrompt entity
                let focus_handle = self.focus_handle.clone();
                let template_prompt = prompts::TemplatePrompt::new(
                    id.clone(),
                    template,
                    focus_handle,
                    submit_callback,
                    std::sync::Arc::new(self.theme.clone()),
                );

                let entity = cx.new(|_| template_prompt);
                self.current_view = AppView::TemplatePrompt { id, entity };
                self.focused_input = FocusedInput::None;
                self.pending_focus = Some(FocusTarget::TemplatePrompt);

                resize_to_view_sync(ViewType::DivPrompt, 0);
                cx.notify();
            }
            PromptMessage::ShowSelect {
                id,
                placeholder,
                choices,
                multiple,
            } => {
                tracing::info!(
                    id,
                    ?placeholder,
                    choice_count = choices.len(),
                    multiple,
                    "ShowSelect received"
                );
                logging::log(
                    "UI",
                    &format!(
                        "ShowSelect prompt received: {} ({} choices, multiple: {})",
                        id,
                        choices.len(),
                        multiple
                    ),
                );

                // Create submit callback for select prompt
                let response_sender = self.response_sender.clone();
                let submit_callback: std::sync::Arc<dyn Fn(String, Option<String>) + Send + Sync> =
                    std::sync::Arc::new(move |id, value| {
                        if let Some(ref sender) = response_sender {
                            let response = Message::Submit { id, value };
                            // Use try_send to avoid blocking UI thread
                            match sender.try_send(response) {
                                Ok(()) => {}
                                Err(std::sync::mpsc::TrySendError::Full(_)) => {
                                    logging::log(
                                        "WARN",
                                        "Response channel full - select response dropped",
                                    );
                                }
                                Err(std::sync::mpsc::TrySendError::Disconnected(_)) => {
                                    logging::log(
                                        "UI",
                                        "Response channel disconnected - script exited",
                                    );
                                }
                            }
                        }
                    });

                // Create SelectPrompt entity
                let choice_count = choices.len();
                let select_prompt = prompts::SelectPrompt::new(
                    id.clone(),
                    placeholder,
                    choices,
                    multiple,
                    self.focus_handle.clone(),
                    submit_callback,
                    std::sync::Arc::new(self.theme.clone()),
                );
                let entity = cx.new(|_| select_prompt);
                self.current_view = AppView::SelectPrompt { id, entity };
                self.focused_input = FocusedInput::None; // SelectPrompt has its own focus handling
                self.pending_focus = Some(FocusTarget::SelectPrompt);

                // Resize window based on number of choices
                let view_type = if choice_count == 0 {
                    ViewType::ArgPromptNoChoices
                } else {
                    ViewType::ArgPromptWithChoices
                };
                resize_to_view_sync(view_type, choice_count);
                cx.notify();
            }
            PromptMessage::ShowHud { text, duration_ms } => {
                self.show_hud(text, duration_ms, cx);
            }
            PromptMessage::SetInput { text } => {
                self.set_prompt_input(text, cx);
            }
            PromptMessage::SetActions { actions } => {
                logging::log(
                    "ACTIONS",
                    &format!("Received setActions with {} actions", actions.len()),
                );

                // Store SDK actions for trigger_action_by_name lookup
                self.sdk_actions = Some(actions.clone());

                // Build action shortcuts map for keyboard handling
                self.action_shortcuts.clear();
                for action in &actions {
                    if let Some(ref shortcut) = action.shortcut {
                        let normalized = shortcuts::normalize_shortcut(shortcut);
                        logging::log(
                            "ACTIONS",
                            &format!(
                                "Registering action shortcut: '{}' -> '{}' (normalized: '{}')",
                                shortcut, action.name, normalized
                            ),
                        );
                        self.action_shortcuts
                            .insert(normalized, action.name.clone());
                    }
                }

                // Update ActionsDialog if it exists and is open
                if let Some(ref dialog) = self.actions_dialog {
                    dialog.update(cx, |d, _cx| {
                        d.set_sdk_actions(actions);
                    });
                }

                cx.notify();
            }
            PromptMessage::ShowGrid { options } => {
                logging::log(
                    "DEBUG_GRID",
                    &format!(
                        "ShowGrid from script: size={}, bounds={}, box_model={}, guides={}",
                        options.grid_size,
                        options.show_bounds,
                        options.show_box_model,
                        options.show_alignment_guides
                    ),
                );
                self.show_grid(options, cx);
            }
            PromptMessage::HideGrid => {
                logging::log("DEBUG_GRID", "HideGrid from script");
                self.hide_grid(cx);
            }
        }
    }
}

</file>

<file path="src/syntax.rs">
//! Syntax highlighting module using syntect
//!
//! Provides syntax highlighting for code strings with colors that integrate
//! with the existing theme system. Colors are returned as hex u32 values.
//!
//! NOTE: syntect's default syntax set doesn't include TypeScript, so we use
//! JavaScript syntax for .ts files (which works well for highlighting).

#![allow(dead_code)]

use syntect::easy::HighlightLines;
use syntect::highlighting::{Style, ThemeSet};
use syntect::parsing::SyntaxSet;
use syntect::util::LinesWithEndings;

/// A highlighted span of text with its associated color
#[derive(Debug, Clone, PartialEq)]
pub struct HighlightedSpan {
    /// The text content of this span
    pub text: String,
    /// The color as a hex u32 value (0xRRGGBB format)
    pub color: u32,
    /// Whether this span ends a line (contains newline)
    pub is_line_end: bool,
}

impl HighlightedSpan {
    /// Create a new highlighted span
    pub fn new(text: impl Into<String>, color: u32) -> Self {
        let text_str = text.into();
        let is_line_end = text_str.ends_with('\n');
        Self {
            text: text_str,
            color,
            is_line_end,
        }
    }
}

/// A complete highlighted line with all its spans
#[derive(Debug, Clone)]
pub struct HighlightedLine {
    pub spans: Vec<HighlightedSpan>,
}

/// Convert a syntect Style color to a hex u32 value
fn style_to_hex_color(style: &Style) -> u32 {
    let fg = style.foreground;
    ((fg.r as u32) << 16) | ((fg.g as u32) << 8) | (fg.b as u32)
}

/// Map language name/extension to syntect syntax name
/// NOTE: TypeScript is NOT in syntect defaults, so we map to JavaScript
fn map_language_to_syntax(language: &str) -> &str {
    match language.to_lowercase().as_str() {
        // TypeScript -> JavaScript (syntect doesn't have TypeScript by default)
        "typescript" | "ts" => "JavaScript",
        "javascript" | "js" => "JavaScript",
        "markdown" | "md" => "Markdown",
        "json" => "JSON",
        "rust" | "rs" => "Rust",
        "python" | "py" => "Python",
        "html" => "HTML",
        "css" => "CSS",
        "shell" | "sh" | "bash" => "Bourne Again Shell (bash)",
        "yaml" | "yml" => "YAML",
        // Note: TOML may not be in syntect defaults either
        "toml" => "Makefile", // Fallback - TOML not in defaults
        _ => language,        // Try the language name directly as fallback
    }
}

/// Highlight code with syntax coloring, returning lines of spans
///
/// # Arguments
/// * `code` - The source code to highlight
/// * `language` - The language identifier (e.g., "typescript", "javascript", "markdown", "ts", "js", "md")
///
/// # Returns
/// A vector of `HighlightedLine` structs, each containing spans for one line.
/// This preserves line structure for proper rendering.
pub fn highlight_code_lines(code: &str, language: &str) -> Vec<HighlightedLine> {
    let ps = SyntaxSet::load_defaults_newlines();
    let ts = ThemeSet::load_defaults();

    // Use base16-eighties.dark theme which looks good on dark backgrounds
    let theme = &ts.themes["base16-eighties.dark"];

    // Default foreground color for plain text (light gray)
    let default_color = 0xcccccc_u32;

    let syntax_name = map_language_to_syntax(language);

    // Try to find the syntax by name, or fall back to JavaScript for unknown
    let syntax = ps
        .find_syntax_by_name(syntax_name)
        .or_else(|| ps.find_syntax_by_extension(language))
        .or_else(|| ps.find_syntax_by_name("JavaScript")) // Better fallback than plain text
        .unwrap_or_else(|| ps.find_syntax_plain_text());

    let mut highlighter = HighlightLines::new(syntax, theme);
    let mut result = Vec::new();

    for line in LinesWithEndings::from(code) {
        let mut line_spans = Vec::new();

        match highlighter.highlight_line(line, &ps) {
            Ok(ranges) => {
                for (style, text) in ranges {
                    if !text.is_empty() {
                        // Strip trailing newline for cleaner rendering
                        let clean_text = text.trim_end_matches('\n');
                        if !clean_text.is_empty() {
                            line_spans
                                .push(HighlightedSpan::new(clean_text, style_to_hex_color(&style)));
                        }
                    }
                }
            }
            Err(_) => {
                // On error, push the line as plain text
                let clean_line = line.trim_end_matches('\n');
                if !clean_line.is_empty() {
                    line_spans.push(HighlightedSpan::new(clean_line, default_color));
                }
            }
        }

        result.push(HighlightedLine { spans: line_spans });
    }

    // If no lines were produced, return empty vec
    result
}

/// Highlight code with syntax coloring (flat span list for backward compatibility)
///
/// # Arguments
/// * `code` - The source code to highlight
/// * `language` - The language identifier (e.g., "typescript", "javascript", "markdown", "ts", "js", "md")
///
/// # Returns
/// A vector of `HighlightedSpan` structs, each containing a text segment and its color.
/// If the language is not recognized, returns the code as plain text with default color.
pub fn highlight_code(code: &str, language: &str) -> Vec<HighlightedSpan> {
    let ps = SyntaxSet::load_defaults_newlines();
    let ts = ThemeSet::load_defaults();

    // Use base16-eighties.dark theme which looks good on dark backgrounds
    let theme = &ts.themes["base16-eighties.dark"];

    // Default foreground color for plain text (light gray)
    let default_color = 0xcccccc_u32;

    let syntax_name = map_language_to_syntax(language);

    // Try to find the syntax by name, or fall back to JavaScript for unknown
    let syntax = ps
        .find_syntax_by_name(syntax_name)
        .or_else(|| ps.find_syntax_by_extension(language))
        .or_else(|| ps.find_syntax_by_name("JavaScript")) // Better fallback than plain text
        .unwrap_or_else(|| ps.find_syntax_plain_text());

    let mut highlighter = HighlightLines::new(syntax, theme);
    let mut result = Vec::new();

    for line in LinesWithEndings::from(code) {
        match highlighter.highlight_line(line, &ps) {
            Ok(ranges) => {
                for (style, text) in ranges {
                    if !text.is_empty() {
                        result.push(HighlightedSpan::new(text, style_to_hex_color(&style)));
                    }
                }
            }
            Err(_) => {
                // On error, push the line as plain text
                result.push(HighlightedSpan::new(line, default_color));
            }
        }
    }

    // If no spans were produced, return the original code as plain text
    if result.is_empty() && !code.is_empty() {
        result.push(HighlightedSpan::new(code, default_color));
    }

    result
}

/// Get a list of supported language identifiers
pub fn supported_languages() -> Vec<&'static str> {
    vec![
        "typescript",
        "ts",
        "javascript",
        "js",
        "markdown",
        "md",
        "json",
        "rust",
        "rs",
        "python",
        "py",
        "html",
        "css",
        "shell",
        "sh",
        "bash",
        "yaml",
        "yml",
        "toml",
    ]
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_highlight_typescript() {
        let code = "const x: number = 42;";
        let spans = highlight_code(code, "typescript");

        // Should produce multiple spans with different colors
        assert!(!spans.is_empty());

        // Verify the text content is preserved
        let reconstructed: String = spans.iter().map(|s| s.text.as_str()).collect();
        assert_eq!(reconstructed, code);
    }

    #[test]
    fn test_highlight_javascript() {
        let code = "function hello() { return 'world'; }";
        let spans = highlight_code(code, "javascript");

        assert!(!spans.is_empty());
        let reconstructed: String = spans.iter().map(|s| s.text.as_str()).collect();
        assert_eq!(reconstructed, code);
    }

    #[test]
    fn test_highlight_markdown() {
        let code = "# Hello World\n\nThis is **bold** text.";
        let spans = highlight_code(code, "markdown");

        assert!(!spans.is_empty());
        let reconstructed: String = spans.iter().map(|s| s.text.as_str()).collect();
        assert_eq!(reconstructed, code);
    }

    #[test]
    fn test_highlight_with_extension() {
        let code = "let x = 1;";
        let spans_ts = highlight_code(code, "ts");
        let spans_js = highlight_code(code, "js");

        assert!(!spans_ts.is_empty());
        assert!(!spans_js.is_empty());
    }

    #[test]
    fn test_unknown_language_returns_plain_text() {
        let code = "some random text";
        let spans = highlight_code(code, "unknownlang123");

        // Should return at least one span with the full text
        assert!(!spans.is_empty());
        let reconstructed: String = spans.iter().map(|s| s.text.as_str()).collect();
        assert_eq!(reconstructed, code);
    }

    #[test]
    fn test_empty_code() {
        let spans = highlight_code("", "typescript");
        assert!(spans.is_empty());
    }

    #[test]
    fn test_multiline_code() {
        let code = "const a = 1;\nconst b = 2;\nconst c = a + b;";
        let spans = highlight_code(code, "javascript");

        assert!(!spans.is_empty());
        let reconstructed: String = spans.iter().map(|s| s.text.as_str()).collect();
        assert_eq!(reconstructed, code);
    }

    #[test]
    fn test_color_format() {
        let spans = highlight_code("let x = 42;", "typescript");

        for span in &spans {
            // Colors should be in valid hex range (0x000000 to 0xFFFFFF)
            assert!(
                span.color <= 0xFFFFFF,
                "Color {:06X} out of range",
                span.color
            );
        }
    }

    #[test]
    fn test_highlighted_span_new() {
        let span = HighlightedSpan::new("hello", 0xFF0000);
        assert_eq!(span.text, "hello");
        assert_eq!(span.color, 0xFF0000);
    }

    #[test]
    fn test_supported_languages() {
        let languages = supported_languages();
        assert!(languages.contains(&"typescript"));
        assert!(languages.contains(&"javascript"));
        assert!(languages.contains(&"markdown"));
        assert!(languages.contains(&"ts"));
        assert!(languages.contains(&"js"));
        assert!(languages.contains(&"md"));
    }

    #[test]
    fn test_highlight_lines_preserves_structure() {
        let code = "const a = 1;\nconst b = 2;";
        let lines = highlight_code_lines(code, "js");

        // Should have 2 lines
        assert_eq!(lines.len(), 2);

        // Each line should have spans
        assert!(!lines[0].spans.is_empty());
        assert!(!lines[1].spans.is_empty());
    }

    #[test]
    fn test_highlight_produces_colors() {
        // Use JavaScript which IS in syntect defaults
        let code = "function test() { return 42; }";
        let spans = highlight_code(code, "javascript");

        // Check we have different colors (real syntax highlighting)
        let unique_colors: std::collections::HashSet<u32> = spans.iter().map(|s| s.color).collect();
        assert!(
            unique_colors.len() > 1,
            "Expected syntax highlighting to produce multiple colors"
        );
    }
}

</file>

<file path="src/prompts/base.rs">
//! Shared base infrastructure for all prompt types
//!
//! This module provides:
//! - `PromptBase`: Common fields shared by all prompts (id, focus_handle, on_submit, theme, design_variant)
//! - `DesignContext`: Resolved colors that eliminate variant branching in render code
//! - `impl_focusable_via_base!`: Macro to implement Focusable for prompts with a `base` field
//!
//! # Usage
//!
//! ```rust,ignore
//! use crate::prompts::base::{PromptBase, DesignContext};
//!
//! pub struct MyPrompt {
//!     pub base: PromptBase,
//!     // prompt-specific fields...
//! }
//!
//! impl_focusable_via_base!(MyPrompt, base);
//!
//! impl Render for MyPrompt {
//!     fn render(&mut self, window: &mut Window, cx: &mut Context<Self>) -> impl IntoElement {
//!         let dc = DesignContext::new(&self.base.theme, self.base.design_variant);
//!         // Use dc.bg_main(), dc.text_secondary(), etc.
//!     }
//! }
//! ```

use gpui::{rgb, FocusHandle, Rgba};
use std::sync::Arc;

use crate::designs::{get_tokens, DesignVariant};
use crate::theme;

use super::SubmitCallback;

/// Common fields shared by all prompt types
///
/// This struct centralizes the fields that every prompt needs:
/// - `id`: Unique identifier for the prompt instance
/// - `focus_handle`: GPUI focus handle for keyboard input
/// - `on_submit`: Callback when user submits/cancels
/// - `theme`: Theme for styling (when design_variant is Default)
/// - `design_variant`: Which design system to use
#[derive(Clone)]
pub struct PromptBase {
    /// Unique ID for this prompt instance
    pub id: String,
    /// Focus handle for keyboard input
    pub focus_handle: FocusHandle,
    /// Callback when user submits
    pub on_submit: SubmitCallback,
    /// Theme for styling
    pub theme: Arc<theme::Theme>,
    /// Design variant for styling (defaults to Default for theme-based styling)
    pub design_variant: DesignVariant,
}

impl PromptBase {
    /// Create a new PromptBase with Default design variant
    pub fn new(
        id: String,
        focus_handle: FocusHandle,
        on_submit: SubmitCallback,
        theme: Arc<theme::Theme>,
    ) -> Self {
        Self {
            id,
            focus_handle,
            on_submit,
            theme,
            design_variant: DesignVariant::Default,
        }
    }

    /// Builder method to set the design variant
    pub fn with_design(mut self, variant: DesignVariant) -> Self {
        self.design_variant = variant;
        self
    }

    /// Submit a value through the callback
    #[inline]
    pub fn submit(&self, value: Option<String>) {
        (self.on_submit)(self.id.clone(), value);
    }

    /// Cancel (submit None)
    #[inline]
    pub fn cancel(&self) {
        self.submit(None);
    }
}

/// Resolved color palette for prompt rendering
///
/// This struct provides colors that are resolved based on design_variant,
/// eliminating the need for variant branching in render code.
///
/// When `design_variant == Default`, colors come from the theme.
/// When any other variant, colors come from design tokens.
#[derive(Debug, Clone, Copy)]
pub struct ResolvedColors {
    /// Primary background color
    pub bg_main: u32,
    /// Secondary background (search boxes, panels)
    pub bg_secondary: u32,
    /// Tertiary background (nested elements)
    pub bg_tertiary: u32,
    /// Border color
    pub border: u32,
    /// Primary text color
    pub text_primary: u32,
    /// Secondary text color
    pub text_secondary: u32,
    /// Muted text color (placeholders, hints)
    pub text_muted: u32,
    /// Dimmed text color (disabled, inactive)
    pub text_dimmed: u32,
    /// Accent color (links, highlights)
    pub accent: u32,
    /// Background for selected items
    pub bg_selected: u32,
    /// Text color on accent/selected backgrounds
    pub text_on_accent: u32,
}

/// Design context for prompt rendering
///
/// Provides resolved colors and tokens based on the design variant.
/// Use this in render methods to get consistent colors without branching.
pub struct DesignContext<'a> {
    /// The design variant being used
    pub variant: DesignVariant,
    /// Reference to the theme (for Default variant)
    pub theme: &'a theme::Theme,
    /// Resolved colors (no branching needed when using these)
    pub c: ResolvedColors,
}

impl<'a> DesignContext<'a> {
    /// Create a new DesignContext with resolved colors
    ///
    /// This constructor resolves all colors upfront based on the variant,
    /// so render code doesn't need any variant branching.
    pub fn new(theme: &'a theme::Theme, variant: DesignVariant) -> Self {
        let c = if variant == DesignVariant::Default {
            // Use theme colors for Default variant
            ResolvedColors {
                bg_main: theme.colors.background.main,
                bg_secondary: theme.colors.background.search_box,
                bg_tertiary: theme.colors.background.search_box, // Use search_box as tertiary
                border: theme.colors.ui.border,
                text_primary: theme.colors.text.primary,
                text_secondary: theme.colors.text.secondary,
                text_muted: theme.colors.text.muted,
                text_dimmed: theme.colors.text.dimmed,
                accent: theme.colors.accent.selected,
                bg_selected: theme.colors.accent.selected,
                text_on_accent: theme.colors.text.primary, // Default uses primary on accent
            }
        } else {
            // Use design tokens for non-Default variants
            let tokens = get_tokens(variant);
            let d = tokens.colors();

            ResolvedColors {
                bg_main: d.background,
                bg_secondary: d.background_secondary,
                bg_tertiary: d.background_tertiary,
                border: d.border,
                text_primary: d.text_primary,
                text_secondary: d.text_secondary,
                text_muted: d.text_muted,
                text_dimmed: d.text_dimmed,
                accent: d.accent,
                bg_selected: d.background_selected,
                text_on_accent: d.text_on_accent,
            }
        };

        Self { variant, theme, c }
    }

    // Convenience methods that return GPUI Rgba directly

    /// Get main background color as Rgba
    #[inline]
    pub fn bg_main(&self) -> Rgba {
        rgb(self.c.bg_main)
    }

    /// Get secondary background color as Rgba
    #[inline]
    pub fn bg_secondary(&self) -> Rgba {
        rgb(self.c.bg_secondary)
    }

    /// Get tertiary background color as Rgba
    #[inline]
    pub fn bg_tertiary(&self) -> Rgba {
        rgb(self.c.bg_tertiary)
    }

    /// Get border color as Rgba
    #[inline]
    pub fn border(&self) -> Rgba {
        rgb(self.c.border)
    }

    /// Get primary text color as Rgba
    #[inline]
    pub fn text_primary(&self) -> Rgba {
        rgb(self.c.text_primary)
    }

    /// Get secondary text color as Rgba
    #[inline]
    pub fn text_secondary(&self) -> Rgba {
        rgb(self.c.text_secondary)
    }

    /// Get muted text color as Rgba
    #[inline]
    pub fn text_muted(&self) -> Rgba {
        rgb(self.c.text_muted)
    }

    /// Get dimmed text color as Rgba
    #[inline]
    pub fn text_dimmed(&self) -> Rgba {
        rgb(self.c.text_dimmed)
    }

    /// Get accent color as Rgba
    #[inline]
    pub fn accent(&self) -> Rgba {
        rgb(self.c.accent)
    }

    /// Get selected background color as Rgba
    #[inline]
    pub fn bg_selected(&self) -> Rgba {
        rgb(self.c.bg_selected)
    }

    /// Get text-on-accent color as Rgba
    #[inline]
    pub fn text_on_accent(&self) -> Rgba {
        rgb(self.c.text_on_accent)
    }

    /// Check if using the Default variant
    #[inline]
    pub fn is_default(&self) -> bool {
        self.variant == DesignVariant::Default
    }
}

/// Macro to implement Focusable for prompts with a `base` field
///
/// This eliminates the need for each prompt to manually implement Focusable.
///
/// # Example
///
/// ```rust,ignore
/// pub struct MyPrompt {
///     pub base: PromptBase,
///     // ...
/// }
///
/// impl_focusable_via_base!(MyPrompt, base);
/// ```
#[macro_export]
macro_rules! impl_focusable_via_base {
    ($ty:ty, $field:ident) => {
        impl gpui::Focusable for $ty {
            fn focus_handle(&self, _cx: &gpui::App) -> gpui::FocusHandle {
                self.$field.focus_handle.clone()
            }
        }
    };
}

// Re-export the macro at module level
// Note: This is infrastructure for prompt implementations - will be used when prompts adopt PromptBase
#[allow(unused_imports)]
pub use impl_focusable_via_base;

#[cfg(test)]
mod tests {
    use super::*;

    fn make_test_theme() -> Arc<theme::Theme> {
        Arc::new(theme::Theme::default())
    }

    #[test]
    fn test_resolved_colors_default_uses_theme() {
        let theme = make_test_theme();
        let dc = DesignContext::new(&theme, DesignVariant::Default);

        assert_eq!(dc.c.bg_main, theme.colors.background.main);
        assert_eq!(dc.c.text_primary, theme.colors.text.primary);
        assert_eq!(dc.c.accent, theme.colors.accent.selected);
        assert!(dc.is_default());
    }

    #[test]
    fn test_resolved_colors_minimal_uses_tokens() {
        let theme = make_test_theme();
        let dc = DesignContext::new(&theme, DesignVariant::Minimal);

        let tokens = get_tokens(DesignVariant::Minimal);
        let colors = tokens.colors();

        assert_eq!(dc.c.bg_main, colors.background);
        assert_eq!(dc.c.text_primary, colors.text_primary);
        assert_eq!(dc.c.accent, colors.accent);
        assert!(!dc.is_default());
    }

    #[test]
    fn test_resolved_colors_retro_terminal_uses_tokens() {
        let theme = make_test_theme();
        let dc = DesignContext::new(&theme, DesignVariant::RetroTerminal);

        let tokens = get_tokens(DesignVariant::RetroTerminal);
        let colors = tokens.colors();

        // RetroTerminal has distinctive green colors
        assert_eq!(dc.c.text_primary, colors.text_primary);
        assert_eq!(dc.c.text_primary, 0x00ff00); // Phosphor green
    }

    #[test]
    fn test_design_context_rgba_helpers() {
        let theme = make_test_theme();
        let dc = DesignContext::new(&theme, DesignVariant::Default);

        // The helpers should return Rgba values
        let bg = dc.bg_main();
        let text = dc.text_primary();

        // Just verify they don't panic and return valid Rgba
        assert!(bg.r >= 0.0 && bg.r <= 1.0);
        assert!(text.r >= 0.0 && text.r <= 1.0);
    }

    #[test]
    fn test_all_variants_produce_valid_colors() {
        let theme = make_test_theme();

        for variant in DesignVariant::all() {
            let dc = DesignContext::new(&theme, *variant);

            // All colors should be non-zero (black) unless intentionally so
            // At minimum, text and bg should be different for contrast
            assert_ne!(
                dc.c.bg_main, dc.c.text_primary,
                "Variant {:?} has no contrast between bg and text",
                variant
            );
        }
    }
}

</file>

<file path="src/editor.rs">
//! EditorPrompt - Using gpui-component's Input in code_editor mode
//!
//! Full-featured code editor component using gpui-component which includes:
//! - High-performance editing (200K+ lines)
//! - Built-in Find/Replace with SearchPanel (Cmd+F)
//! - Syntax highlighting via Tree Sitter
//! - Undo/Redo with proper history
//! - Line numbers, soft wrap, indentation
//! - LSP hooks for diagnostics/completion
//! - Template/snippet support with tabstop navigation

use gpui::{
    div, prelude::*, px, rgb, Context, Entity, FocusHandle, Focusable, IntoElement, Render,
    SharedString, Styled, Subscription, Window,
};
use gpui_component::input::{IndentInline, Input, InputEvent, InputState, OutdentInline, Position};
use std::sync::Arc;

use crate::config::Config;
use crate::logging;
use crate::snippet::ParsedSnippet;
use crate::theme::Theme;

/// Convert a character offset to a byte offset.
///
/// CRITICAL: When char_offset equals or exceeds the character count of the text,
/// this returns text.len() (the byte length), NOT 0. This is essential for
/// correct cursor positioning at end-of-document (e.g., $0 tabstops).
///
/// # Arguments
/// * `text` - The string to convert offsets in
/// * `char_offset` - Character index (0-based)
///
/// # Returns
/// The byte offset corresponding to the character offset, or text.len() if
/// the char_offset is at or beyond the end of the string.
fn char_offset_to_byte_offset(text: &str, char_offset: usize) -> usize {
    text.char_indices()
        .nth(char_offset)
        .map(|(i, _)| i)
        .unwrap_or(text.len()) // CRITICAL: Use text.len(), not 0!
}

/// Convert a character offset to a Position (line, column)
///
/// This is needed because gpui-component's InputState uses Position (line, column)
/// for cursor placement, but our snippet parser tracks char offsets.
#[allow(dead_code)]
fn char_offset_to_position(text: &str, char_offset: usize) -> Position {
    let mut line: u32 = 0;
    let mut col: u32 = 0;

    for (current_char, ch) in text.chars().enumerate() {
        if current_char >= char_offset {
            break;
        }
        if ch == '\n' {
            line += 1;
            col = 0;
        } else {
            col += 1;
        }
    }

    Position {
        line,
        character: col,
    }
}

/// Callback for prompt submission
/// Signature: (id: String, value: Option<String>)
pub type SubmitCallback = Arc<dyn Fn(String, Option<String>) + Send + Sync>;

/// Pending initialization state - stored until first render when window is available
struct PendingInit {
    content: String,
    language: String,
}

/// State for template/snippet navigation
///
/// Tracks the current position within a template's tabstops, allowing
/// Tab/Shift+Tab navigation through the placeholders.
#[derive(Debug, Clone)]
pub struct SnippetState {
    /// The parsed snippet with tabstop information
    pub snippet: ParsedSnippet,
    /// Current index into snippet.tabstops (0-based position in navigation order)
    pub current_tabstop_idx: usize,
    /// Current placeholder values (updated when user edits a tabstop)
    /// Index matches snippet.tabstops order
    pub current_values: Vec<String>,
    /// Tracks the last known selection range (char offsets) for each tabstop
    /// Used to detect when user has edited a tabstop and update current_values
    pub last_selection_ranges: Vec<Option<(usize, usize)>>,
}

/// State for the choice dropdown popup
/// Shown when a tabstop has multiple choices (${1|opt1,opt2,opt3|})
#[derive(Debug, Clone)]
pub struct ChoicesPopupState {
    /// The list of choices to display
    pub choices: Vec<String>,
    /// Currently highlighted index in the list
    pub selected_index: usize,
    /// The tabstop index this popup is for
    pub tabstop_idx: usize,
}

/// EditorPrompt - Full-featured code editor using gpui-component
///
/// Uses deferred initialization pattern: the InputState is created on first render
/// when the Window reference is available, not at construction time.
pub struct EditorPrompt {
    // Identity
    pub id: String,

    // gpui-component editor state (created on first render)
    editor_state: Option<Entity<InputState>>,

    // Pending initialization data (consumed on first render)
    pending_init: Option<PendingInit>,

    // Template/snippet state for tabstop navigation
    snippet_state: Option<SnippetState>,

    // Language for syntax highlighting (displayed in footer)
    language: String,

    // GPUI
    focus_handle: FocusHandle,
    on_submit: SubmitCallback,
    theme: Arc<Theme>,
    #[allow(dead_code)]
    config: Arc<Config>,

    // Layout - explicit height for proper sizing
    content_height: Option<gpui::Pixels>,

    // Subscriptions to keep alive
    #[allow(dead_code)]
    subscriptions: Vec<Subscription>,

    // When true, ignore all key events (used when actions panel is open)
    pub suppress_keys: bool,

    // Flag to request focus on next render (used for auto-focus after initialization)
    needs_focus: bool,

    // Flag to indicate we need to select the first tabstop after initialization
    needs_initial_tabstop_selection: bool,

    // Choice dropdown popup state (shown when tabstop has choices)
    choices_popup: Option<ChoicesPopupState>,
}

impl EditorPrompt {
    /// Create a new EditorPrompt with explicit height
    ///
    /// This is the compatible constructor that matches the original EditorPrompt API.
    /// The InputState is created lazily on first render when window is available.
    #[allow(clippy::too_many_arguments)]
    pub fn with_height(
        id: String,
        content: String,
        language: String,
        focus_handle: FocusHandle,
        on_submit: SubmitCallback,
        theme: Arc<Theme>,
        config: Arc<Config>,
        content_height: Option<gpui::Pixels>,
    ) -> Self {
        logging::log(
            "EDITOR",
            &format!(
                "EditorPrompt::with_height id={}, lang={}, content_len={}, height={:?}",
                id,
                language,
                content.len(),
                content_height
            ),
        );

        Self {
            id,
            editor_state: None, // Created on first render
            pending_init: Some(PendingInit {
                content,
                language: language.clone(),
            }),
            snippet_state: None,
            language,
            focus_handle,
            on_submit,
            theme,
            config,
            content_height,
            subscriptions: Vec::new(),
            suppress_keys: false,
            choices_popup: None,
            needs_focus: true, // Auto-focus on first render
            needs_initial_tabstop_selection: false,
        }
    }

    /// Create a new EditorPrompt in template/snippet mode
    ///
    /// Parses the template for VSCode-style tabstops and enables Tab/Shift+Tab navigation.
    /// Template syntax:
    /// - `$1`, `$2`, `$3` - Simple tabstops (numbered positions)
    /// - `${1:default}` - Tabstops with placeholder text
    /// - `${1|a,b,c|}` - Choice tabstops (first choice is used as default)
    /// - `$0` - Final cursor position
    #[allow(clippy::too_many_arguments)]
    pub fn with_template(
        id: String,
        template: String,
        language: String,
        focus_handle: FocusHandle,
        on_submit: SubmitCallback,
        theme: Arc<Theme>,
        config: Arc<Config>,
        content_height: Option<gpui::Pixels>,
    ) -> Self {
        logging::log(
            "EDITOR",
            &format!(
                "EditorPrompt::with_template id={}, lang={}, template_len={}, height={:?}",
                id,
                language,
                template.len(),
                content_height
            ),
        );

        // Parse the template for tabstops
        let snippet = ParsedSnippet::parse(&template);

        logging::log(
            "EDITOR",
            &format!(
                "Template parsed: {} tabstops, expanded_len={}",
                snippet.tabstops.len(),
                snippet.text.len()
            ),
        );

        // If there are tabstops, set up snippet state
        let (content, snippet_state, needs_initial_selection) = if snippet.tabstops.is_empty() {
            // No tabstops - use the expanded text as plain content
            (snippet.text.clone(), None, false)
        } else {
            // Has tabstops - set up navigation state
            // Initialize current_values with the original placeholder text
            let current_values: Vec<String> = snippet
                .tabstops
                .iter()
                .map(|ts| {
                    ts.placeholder
                        .clone()
                        .or_else(|| ts.choices.as_ref().and_then(|c| c.first().cloned()))
                        .unwrap_or_default()
                })
                .collect();

            // Initialize last_selection_ranges from the original ranges
            let last_selection_ranges: Vec<Option<(usize, usize)>> = snippet
                .tabstops
                .iter()
                .map(|ts| ts.ranges.first().copied())
                .collect();

            let state = SnippetState {
                snippet: snippet.clone(),
                current_tabstop_idx: 0, // Start at first tabstop
                current_values,
                last_selection_ranges,
            };
            (snippet.text.clone(), Some(state), true)
        };

        Self {
            id,
            editor_state: None, // Created on first render
            pending_init: Some(PendingInit {
                content,
                language: language.clone(),
            }),
            snippet_state,
            language,
            focus_handle,
            on_submit,
            theme,
            config,
            content_height,
            subscriptions: Vec::new(),
            suppress_keys: false,
            choices_popup: None,
            needs_focus: true, // Auto-focus on first render
            needs_initial_tabstop_selection: needs_initial_selection,
        }
    }

    /// Initialize the editor state (called on first render)
    fn ensure_initialized(&mut self, window: &mut Window, cx: &mut Context<Self>) {
        if self.editor_state.is_some() {
            return; // Already initialized
        }

        let Some(pending) = self.pending_init.take() else {
            logging::log("EDITOR", "Warning: No pending init data");
            return;
        };

        logging::log(
            "EDITOR",
            &format!(
                "Initializing editor state: lang={}, content_len={}",
                pending.language,
                pending.content.len()
            ),
        );

        // Create the gpui-component InputState in code_editor mode
        // Enable tab_navigation mode if we're in snippet mode (Tab moves between tabstops)
        let in_snippet = self.snippet_state.is_some();
        let editor_state = cx.new(|cx| {
            InputState::new(window, cx)
                .code_editor(&pending.language) // Sets up syntax highlighting
                .searchable(true) // Enable Cmd+F find/replace
                .line_number(false) // No line numbers - cleaner UI
                .soft_wrap(false) // Code should not wrap by default
                .default_value(pending.content)
                .tab_navigation(in_snippet) // Propagate Tab when in snippet mode
        });

        // Subscribe to editor changes
        let editor_sub = cx.subscribe_in(&editor_state, window, {
            move |_this, _, ev: &InputEvent, _window, cx| match ev {
                InputEvent::Change => {
                    cx.notify();
                }
                InputEvent::PressEnter { secondary: _ } => {
                    // Multi-line editor handles Enter internally for newlines
                }
                InputEvent::Focus => {
                    logging::log("EDITOR", "Editor focused");
                }
                InputEvent::Blur => {
                    logging::log("EDITOR", "Editor blurred");
                }
            }
        });

        self.subscriptions = vec![editor_sub];
        self.editor_state = Some(editor_state);

        logging::log("EDITOR", "Editor initialized, focus pending");

        // CRITICAL: Notify to trigger re-render after initialization
        // Without this, the layout may not be computed correctly until a focus change
        cx.notify();
    }

    /// Get the current content as a String
    pub fn content(&self, cx: &Context<Self>) -> String {
        self.editor_state
            .as_ref()
            .map(|state| state.read(cx).value().to_string())
            .unwrap_or_else(|| {
                // Fall back to pending content if not yet initialized
                self.pending_init
                    .as_ref()
                    .map(|p| p.content.clone())
                    .unwrap_or_default()
            })
    }

    /// Get the language
    #[allow(dead_code)]
    pub fn language(&self) -> &str {
        &self.language
    }

    /// Set the content and position cursor at end (below last content line)
    ///
    /// If content exists and doesn't end with a newline, appends one so the cursor
    /// starts on a fresh line below the existing content.
    #[allow(dead_code)]
    pub fn set_content(&mut self, content: String, window: &mut Window, cx: &mut Context<Self>) {
        // Ensure content ends with newline so cursor is on line below content
        let content_with_newline = if !content.is_empty() && !content.ends_with('\n') {
            format!("{}\n", content)
        } else {
            content
        };

        if let Some(ref editor_state) = self.editor_state {
            let content_len = content_with_newline.len();
            editor_state.update(cx, |state, cx| {
                state.set_value(content_with_newline, window, cx);
                // Move cursor to end (set selection to end..end = no selection, cursor at end)
                state.set_selection(content_len, content_len, window, cx);
            });
        } else {
            // Update pending content if not yet initialized
            if let Some(ref mut pending) = self.pending_init {
                pending.content = content_with_newline;
            }
        }
    }

    /// Set the language for syntax highlighting
    #[allow(dead_code)]
    pub fn set_language(&mut self, language: String, cx: &mut Context<Self>) {
        self.language = language.clone();
        if let Some(ref editor_state) = self.editor_state {
            editor_state.update(cx, |state, cx| {
                state.set_highlighter(language, cx);
            });
        } else {
            // Update pending language if not yet initialized
            if let Some(ref mut pending) = self.pending_init {
                pending.language = language;
            }
        }
    }

    /// Set the content height (for dynamic resizing)
    #[allow(dead_code)]
    pub fn set_height(&mut self, height: gpui::Pixels) {
        self.content_height = Some(height);
    }

    // -------------------------------------------------------------------------
    // Snippet/Template Navigation
    // -------------------------------------------------------------------------

    /// Check if we're currently in snippet/template navigation mode
    pub fn in_snippet_mode(&self) -> bool {
        self.snippet_state.is_some()
    }

    /// Get the current tabstop index (0-based index into tabstops array)
    #[allow(dead_code)]
    pub fn current_tabstop_index(&self) -> Option<usize> {
        self.snippet_state.as_ref().map(|s| s.current_tabstop_idx)
    }

    /// Get a reference to the snippet state (for footer display)
    pub fn snippet_state(&self) -> Option<&SnippetState> {
        self.snippet_state.as_ref()
    }

    /// Move to the next tabstop (public wrapper for testing via stdin commands)
    pub fn next_tabstop_public(&mut self, window: &mut Window, cx: &mut Context<Self>) -> bool {
        self.next_tabstop(window, cx)
    }

    /// Move to the next tabstop. Returns true if we moved, false if we exited snippet mode.
    fn next_tabstop(&mut self, window: &mut Window, cx: &mut Context<Self>) -> bool {
        logging::log("EDITOR", "next_tabstop called");

        // Guard: don't mutate snippet state until editor is ready
        // This prevents advancing tabstop index before we can actually select the text
        if self.editor_state.is_none() {
            logging::log("EDITOR", "next_tabstop: editor not initialized yet");
            return false;
        }

        // First, capture what the user typed at the current tabstop
        self.capture_current_tabstop_value(cx);

        let Some(ref mut state) = self.snippet_state else {
            logging::log("EDITOR", "next_tabstop: no snippet_state!");
            return false;
        };
        logging::log(
            "EDITOR",
            &format!(
                "next_tabstop: current_idx={}, total_tabstops={}",
                state.current_tabstop_idx,
                state.snippet.tabstops.len()
            ),
        );

        let tabstop_count = state.snippet.tabstops.len();
        if tabstop_count == 0 {
            self.exit_snippet_mode(window, cx);
            return false;
        }

        // Move to next tabstop
        let next_idx = state.current_tabstop_idx + 1;

        if next_idx >= tabstop_count {
            // We've gone past the last tabstop - check if there's a $0 final cursor
            let last_tabstop = &state.snippet.tabstops[tabstop_count - 1];
            if last_tabstop.index == 0 {
                // We were on the $0 tabstop, exit snippet mode
                logging::log("EDITOR", "Snippet: exiting after $0");
                self.exit_snippet_mode(window, cx);
                return false;
            } else {
                // No $0 tabstop - exit snippet mode
                logging::log("EDITOR", "Snippet: exiting after last tabstop");
                self.exit_snippet_mode(window, cx);
                return false;
            }
        }

        state.current_tabstop_idx = next_idx;
        logging::log(
            "EDITOR",
            &format!(
                "Snippet: moved to tabstop {} (index {})",
                state.snippet.tabstops[next_idx].index, next_idx
            ),
        );

        self.select_current_tabstop(window, cx);
        true
    }

    /// Move to the previous tabstop. Returns true if we moved, false if we're at the start.
    fn prev_tabstop(&mut self, window: &mut Window, cx: &mut Context<Self>) -> bool {
        // Guard: don't mutate snippet state until editor is ready
        if self.editor_state.is_none() {
            logging::log("EDITOR", "prev_tabstop: editor not initialized yet");
            return false;
        }

        // First, capture what the user typed at the current tabstop
        self.capture_current_tabstop_value(cx);

        let Some(ref mut state) = self.snippet_state else {
            return false;
        };

        if state.current_tabstop_idx == 0 {
            // Already at first tabstop
            return false;
        }

        state.current_tabstop_idx -= 1;
        logging::log(
            "EDITOR",
            &format!(
                "Snippet: moved to tabstop {} (index {})",
                state.snippet.tabstops[state.current_tabstop_idx].index, state.current_tabstop_idx
            ),
        );

        self.select_current_tabstop(window, cx);
        true
    }

    /// Capture the current tabstop's edited value before moving to another tabstop
    ///
    /// This is called before next_tabstop/prev_tabstop to record what the user typed,
    /// so we can calculate correct offsets for subsequent tabstops.
    ///
    /// The key insight: when the user types to replace a selected placeholder,
    /// the selection disappears and the cursor ends up at the end of what they typed.
    /// We need to read from the ORIGINAL start position of this tabstop to the
    /// current cursor position to capture what they actually typed.
    fn capture_current_tabstop_value(&mut self, cx: &mut Context<Self>) {
        // First, gather all the info we need with immutable borrows
        let (current_idx, tabstop_start_char, old_value) = {
            let Some(ref state) = self.snippet_state else {
                return;
            };
            let current_idx = state.current_tabstop_idx;
            if current_idx >= state.current_values.len() {
                return;
            }

            // Get the last known start position for this tabstop
            let tabstop_start_char = state
                .last_selection_ranges
                .get(current_idx)
                .and_then(|r| r.map(|(start, _)| start));

            let old_value = state.current_values[current_idx].clone();

            (current_idx, tabstop_start_char, old_value)
        };

        let Some(ref editor_state) = self.editor_state else {
            return;
        };

        // Get current editor state
        let (cursor_pos_char, selection_start_char, selection_end_char, full_text): (
            usize,
            usize,
            usize,
            String,
        ) = editor_state.update(cx, |input_state, _cx| {
            let selection = input_state.selection();
            let text = input_state.value();

            // Use cursor position (selection.end when collapsed, or end of selection)
            let cursor_byte = selection.end;
            let cursor_char = text
                .get(..cursor_byte)
                .map(|s| s.chars().count())
                .unwrap_or(0);

            let sel_start_char = text
                .get(..selection.start)
                .map(|s| s.chars().count())
                .unwrap_or(0);
            let sel_end_char = cursor_char;

            (cursor_char, sel_start_char, sel_end_char, text.to_string())
        });

        logging::log(
            "EDITOR",
            &format!(
                "Snippet capture: tabstop_idx={}, tabstop_start={:?}, cursor={}, selection=[{},{}), text='{}'",
                current_idx, tabstop_start_char, cursor_pos_char, selection_start_char, selection_end_char, full_text
            ),
        );

        // Determine the range to capture
        let (capture_start, capture_end) = if let Some(start) = tabstop_start_char {
            // We have a known start position - read from there to cursor
            // This handles the case where user typed to replace the placeholder
            (start, cursor_pos_char)
        } else {
            // Fallback: use original tabstop range adjusted for previous edits
            if let Some((adj_start, adj_end)) = self.calculate_adjusted_offset(current_idx) {
                (adj_start, adj_end)
            } else {
                return;
            }
        };

        // Extract the text at this range (convert char offsets to byte offsets)
        let captured_value: String = {
            let chars: Vec<char> = full_text.chars().collect();
            let start = capture_start.min(chars.len());
            let end = capture_end.min(chars.len());
            if start <= end {
                chars[start..end].iter().collect()
            } else {
                String::new()
            }
        };

        // Only update if we actually have something (could be empty if user deleted all)
        if captured_value != old_value {
            logging::log(
                "EDITOR",
                &format!(
                    "Snippet: captured tabstop {} value '{}' -> '{}' (range [{}, {}))",
                    current_idx, old_value, captured_value, capture_start, capture_end
                ),
            );
            // Now we can mutably borrow
            if let Some(ref mut state) = self.snippet_state {
                state.current_values[current_idx] = captured_value;
                state.last_selection_ranges[current_idx] = Some((capture_start, capture_end));
            }
        }
    }

    /// Calculate the adjusted offset for a tabstop based on edits to previous tabstops
    ///
    /// When a user edits tabstop 1 from "name" (4 chars) to "John Doe" (8 chars),
    /// tabstop 2's offset needs to shift by +4 characters.
    fn calculate_adjusted_offset(&self, tabstop_idx: usize) -> Option<(usize, usize)> {
        let state = self.snippet_state.as_ref()?;

        // Get the original range for this tabstop
        let original_range = state.snippet.tabstops.get(tabstop_idx)?.ranges.first()?;
        let (mut start, mut end) = *original_range;

        // Calculate cumulative offset adjustment from all previous tabstops
        for i in 0..tabstop_idx {
            let original_ts = state.snippet.tabstops.get(i)?;
            let original_placeholder = original_ts
                .placeholder
                .as_deref()
                .or_else(|| {
                    original_ts
                        .choices
                        .as_ref()
                        .and_then(|c| c.first().map(|s| s.as_str()))
                })
                .unwrap_or("");

            let current_value = state
                .current_values
                .get(i)
                .map(|s| s.as_str())
                .unwrap_or("");

            // Calculate the difference in character length
            let original_len = original_placeholder.chars().count();
            let current_len = current_value.chars().count();
            let diff = current_len as isize - original_len as isize;

            // Adjust if this tabstop was before our target (compare start positions)
            if let Some(&(ts_start, _)) = original_ts.ranges.first() {
                let (original_start, _) = *original_range;
                if ts_start < original_start {
                    start = (start as isize + diff).max(0) as usize;
                    end = (end as isize + diff).max(0) as usize;
                }
            }
        }

        Some((start, end))
    }

    /// Select the current tabstop placeholder text using gpui-component's set_selection API
    ///
    /// This method calculates the correct offset based on any edits the user has made
    /// to previous tabstops.
    fn select_current_tabstop(&mut self, window: &mut Window, cx: &mut Context<Self>) {
        // Always clear any existing choice popup before moving to a new tabstop
        // This prevents stale popups from persisting when navigating tabstops
        self.choices_popup = None;

        // First, calculate the adjusted offset (needs immutable borrow)
        let adjusted_range = self.calculate_adjusted_offset_for_current();
        let Some((start, end, tabstop_index)) = adjusted_range else {
            logging::log("EDITOR", "Snippet: could not calculate adjusted offset");
            return;
        };

        let Some(ref editor_state) = self.editor_state else {
            return;
        };

        logging::log(
            "EDITOR",
            &format!(
                "Snippet: selecting tabstop {} adjusted range [{}, {})",
                tabstop_index, start, end
            ),
        );

        // Use gpui-component's set_selection to select the tabstop text
        editor_state.update(cx, |input_state, cx| {
            let text = input_state.value();
            let text_len = text.chars().count();

            // Clamp to valid range
            let start_clamped = start.min(text_len);
            let end_clamped = end.min(text_len);

            // Convert char offsets to byte offsets using the helper function
            // CRITICAL: This correctly handles end-of-document positions (e.g., $0)
            let start_bytes = char_offset_to_byte_offset(&text, start_clamped);
            let end_bytes = char_offset_to_byte_offset(&text, end_clamped);

            // Log what text we're actually selecting
            let selected_text = if start_bytes < end_bytes && end_bytes <= text.len() {
                &text[start_bytes..end_bytes]
            } else {
                ""
            };
            logging::log(
                "EDITOR",
                &format!(
                    "Snippet: setting selection bytes [{}, {}) = '{}' in text len={}, full_text='{}'",
                    start_bytes,
                    end_bytes,
                    selected_text,
                    text.len(),
                    text
                ),
            );

            input_state.set_selection(start_bytes, end_bytes, window, cx);
        });

        // Update the last selection range and check for choices
        if let Some(ref mut state) = self.snippet_state {
            let current_idx = state.current_tabstop_idx;
            if current_idx < state.last_selection_ranges.len() {
                state.last_selection_ranges[current_idx] = Some((start, end));
            }

            // Check if this tabstop has choices - if so, show the dropdown
            if let Some(tabstop) = state.snippet.tabstops.get(current_idx) {
                if let Some(ref choices) = tabstop.choices {
                    if choices.len() > 1 {
                        logging::log(
                            "EDITOR",
                            &format!(
                                "Snippet: tabstop {} has {} choices, showing popup",
                                current_idx,
                                choices.len()
                            ),
                        );
                        self.choices_popup = Some(ChoicesPopupState {
                            choices: choices.clone(),
                            selected_index: 0,
                            tabstop_idx: current_idx,
                        });
                    }
                }
            }
        }

        cx.notify();
    }

    /// Helper to calculate adjusted offset for the current tabstop
    /// Returns (start, end, tabstop_index) or None
    fn calculate_adjusted_offset_for_current(&self) -> Option<(usize, usize, usize)> {
        let state = self.snippet_state.as_ref()?;
        let current_idx = state.current_tabstop_idx;

        if current_idx >= state.snippet.tabstops.len() {
            return None;
        }

        let tabstop_index = state.snippet.tabstops[current_idx].index;
        let (start, end) = self.calculate_adjusted_offset(current_idx)?;
        Some((start, end, tabstop_index))
    }

    /// Exit snippet mode and restore normal Tab behavior
    fn exit_snippet_mode(&mut self, window: &mut Window, cx: &mut Context<Self>) {
        if self.snippet_state.is_some() {
            logging::log("EDITOR", "Exiting snippet mode");
            self.snippet_state = None;
            // Always clear choice popup when exiting snippet mode
            self.choices_popup = None;

            // Disable tab navigation mode so Tab inserts tabs again
            if let Some(ref editor_state) = self.editor_state {
                editor_state.update(cx, |state, cx| {
                    state.set_tab_navigation(false, window, cx);
                });
            }
        }
    }

    /// Submit the current content
    fn submit(&self, cx: &Context<Self>) {
        let content = self.content(cx);
        logging::log("EDITOR", &format!("Submit id={}", self.id));
        (self.on_submit)(self.id.clone(), Some(content));
    }

    /// Cancel - submit None
    #[allow(dead_code)]
    fn cancel(&self) {
        logging::log("EDITOR", &format!("Cancel id={}", self.id));
        (self.on_submit)(self.id.clone(), None);
    }

    /// Focus the editor
    #[allow(dead_code)]
    pub fn focus(&self, window: &mut Window, cx: &mut Context<Self>) {
        if let Some(ref editor_state) = self.editor_state {
            editor_state.update(cx, |state, cx| {
                state.focus(window, cx);
            });
        }
    }

    /// Request focus on next render (useful when called outside of render context)
    #[allow(dead_code)]
    pub fn request_focus(&mut self) {
        self.needs_focus = true;
    }

    // === Choice Popup Methods ===

    /// Check if the choice popup is currently visible
    pub fn is_choice_popup_visible(&self) -> bool {
        self.choices_popup.is_some()
    }

    /// Public wrapper for choice_popup_up (for SimulateKey)
    pub fn choice_popup_up_public(&mut self, cx: &mut Context<Self>) {
        self.choice_popup_up(cx);
    }

    /// Public wrapper for choice_popup_down (for SimulateKey)
    pub fn choice_popup_down_public(&mut self, cx: &mut Context<Self>) {
        self.choice_popup_down(cx);
    }

    /// Public wrapper for choice_popup_confirm (for SimulateKey)
    pub fn choice_popup_confirm_public(&mut self, window: &mut Window, cx: &mut Context<Self>) {
        self.choice_popup_confirm(window, cx);
    }

    /// Public wrapper for choice_popup_cancel (for SimulateKey)
    pub fn choice_popup_cancel_public(&mut self, cx: &mut Context<Self>) {
        self.choice_popup_cancel(cx);
    }

    /// Move selection up in the choice popup
    fn choice_popup_up(&mut self, cx: &mut Context<Self>) {
        if let Some(ref mut popup) = self.choices_popup {
            if popup.selected_index > 0 {
                popup.selected_index -= 1;
                logging::log(
                    "EDITOR",
                    &format!("Choice popup: moved up to index {}", popup.selected_index),
                );
                cx.notify();
            }
        }
    }

    /// Move selection down in the choice popup
    fn choice_popup_down(&mut self, cx: &mut Context<Self>) {
        if let Some(ref mut popup) = self.choices_popup {
            if popup.selected_index + 1 < popup.choices.len() {
                popup.selected_index += 1;
                logging::log(
                    "EDITOR",
                    &format!("Choice popup: moved down to index {}", popup.selected_index),
                );
                cx.notify();
            }
        }
    }

    /// Confirm the current choice and replace the selection
    fn choice_popup_confirm(&mut self, window: &mut Window, cx: &mut Context<Self>) {
        let Some(popup) = self.choices_popup.take() else {
            return;
        };

        let Some(chosen) = popup.choices.get(popup.selected_index).cloned() else {
            return;
        };

        logging::log(
            "EDITOR",
            &format!(
                "Choice popup: confirmed '{}' at index {}",
                chosen, popup.selected_index
            ),
        );

        // Replace the current selection with the chosen text
        // CRITICAL: Use replace() not insert() - insert() only inserts at cursor position
        // (cursor..cursor range), while replace() replaces the current selection (None = use selection)
        if let Some(ref editor_state) = self.editor_state {
            editor_state.update(cx, |input_state, cx| {
                // The current tabstop text should be selected
                // replace() uses the current selection, insert() only inserts at cursor
                input_state.replace(chosen.clone(), window, cx);
            });
        }

        // Update current_values for offset tracking
        if let Some(ref mut state) = self.snippet_state {
            if popup.tabstop_idx < state.current_values.len() {
                state.current_values[popup.tabstop_idx] = chosen.clone();
            }
        }

        cx.notify();
    }

    /// Cancel the choice popup (dismiss without changing selection)
    fn choice_popup_cancel(&mut self, cx: &mut Context<Self>) {
        if self.choices_popup.is_some() {
            logging::log("EDITOR", "Choice popup: cancelled");
            self.choices_popup = None;
            cx.notify();
        }
    }

    /// Render the choice popup overlay
    fn render_choices_popup(&self, _cx: &Context<Self>) -> Option<impl IntoElement> {
        let popup = self.choices_popup.as_ref()?;
        let colors = &self.theme.colors;

        Some(
            div()
                .absolute()
                .top(px(40.)) // Position below the editor toolbar area
                .left(px(16.))
                //.z_index(1000) // Not available in GPUI, using layer order instead
                .min_w(px(200.))
                .max_w(px(400.))
                .bg(rgb(colors.background.main))
                .border_1()
                .border_color(rgb(colors.ui.border))
                .rounded_md()
                .shadow_lg()
                .py(px(4.))
                .children(popup.choices.iter().enumerate().map(|(idx, choice)| {
                    let is_selected = idx == popup.selected_index;
                    let bg_color = if is_selected {
                        rgb(colors.accent.selected)
                    } else {
                        rgb(colors.background.main)
                    };
                    // Use contrasting text color for selected item
                    let text_color = if is_selected {
                        // White text on accent background for better contrast
                        rgb(0xffffff)
                    } else {
                        rgb(colors.text.primary)
                    };

                    div()
                        .px(px(12.))
                        .py(px(6.))
                        .bg(bg_color)
                        .text_color(text_color)
                        .text_sm()
                        .cursor_pointer()
                        .child(choice.clone())
                })),
        )
    }
}

impl Focusable for EditorPrompt {
    fn focus_handle(&self, _cx: &gpui::App) -> FocusHandle {
        self.focus_handle.clone()
    }
}

impl Render for EditorPrompt {
    fn render(&mut self, window: &mut Window, cx: &mut Context<Self>) -> impl IntoElement {
        // Ensure InputState is initialized on first render
        self.ensure_initialized(window, cx);

        // Handle deferred focus - focus the editor's InputState after initialization
        if self.needs_focus {
            if let Some(ref editor_state) = self.editor_state {
                editor_state.update(cx, |state, cx| {
                    state.focus(window, cx);
                });
                self.needs_focus = false;
                logging::log("EDITOR", "Editor focused via deferred focus");
            }
        }

        // Handle initial tabstop selection for templates
        if self.needs_initial_tabstop_selection && self.editor_state.is_some() {
            self.needs_initial_tabstop_selection = false;
            self.select_current_tabstop(window, cx);
            logging::log("EDITOR", "Initial tabstop selected");
        }

        let colors = &self.theme.colors;

        // Key handler for submit/cancel, snippet navigation, and choice popup
        // IMPORTANT: We intercept Tab here BEFORE gpui-component's Input processes it,
        // so we don't get tab characters inserted when navigating snippets.
        let handle_key = cx.listener(move |this, event: &gpui::KeyDownEvent, window, cx| {
            if this.suppress_keys {
                return;
            }

            let key = event.keystroke.key.to_lowercase();
            let cmd = event.keystroke.modifiers.platform;
            let shift = event.keystroke.modifiers.shift;

            // Debug logging for key events
            logging::log(
                "EDITOR",
                &format!(
                    "Key event: key='{}', cmd={}, shift={}, in_snippet_mode={}, choice_popup={}",
                    key,
                    cmd,
                    shift,
                    this.in_snippet_mode(),
                    this.is_choice_popup_visible()
                ),
            );

            // Handle choice popup keys first (takes priority)
            if this.is_choice_popup_visible() {
                match key.as_str() {
                    "up" | "arrowup" => {
                        this.choice_popup_up(cx);
                        return; // Don't propagate
                    }
                    "down" | "arrowdown" => {
                        this.choice_popup_down(cx);
                        return; // Don't propagate
                    }
                    "enter" if !cmd => {
                        this.choice_popup_confirm(window, cx);
                        return; // Don't propagate
                    }
                    "escape" => {
                        this.choice_popup_cancel(cx);
                        return; // Don't propagate
                    }
                    "tab" if !shift => {
                        // Tab confirms the choice and moves to next tabstop
                        this.choice_popup_confirm(window, cx);
                        this.next_tabstop(window, cx);
                        return; // Don't propagate
                    }
                    _ => {
                        // Other keys close the popup and propagate
                        this.choice_popup_cancel(cx);
                        // Fall through to normal handling
                    }
                }
            }

            match (key.as_str(), cmd, shift) {
                // Cmd+Enter submits
                ("enter", true, _) => {
                    this.submit(cx);
                    // Don't propagate - we handled it
                }
                // Cmd+S also submits (save)
                ("s", true, _) => {
                    this.submit(cx);
                    // Don't propagate - we handled it
                }
                // Tab - snippet navigation (when in snippet mode)
                ("tab", false, false) if this.in_snippet_mode() => {
                    logging::log(
                        "EDITOR",
                        "Tab pressed in snippet mode - calling next_tabstop",
                    );
                    this.next_tabstop(window, cx);
                    // Don't propagate - prevents tab character insertion
                }
                // Shift+Tab - snippet navigation backwards (when in snippet mode)
                ("tab", false, true) if this.in_snippet_mode() => {
                    this.prev_tabstop(window, cx);
                    // Don't propagate - prevents tab character insertion
                }
                // Escape - exit snippet mode or let parent handle
                ("escape", false, _) => {
                    if this.in_snippet_mode() {
                        this.exit_snippet_mode(window, cx);
                        cx.notify();
                        // Don't propagate when exiting snippet mode
                    } else {
                        // Let parent handle escape for closing the editor
                        cx.propagate();
                    }
                }
                _ => {
                    // Let other keys propagate to the Input component
                    cx.propagate();
                }
            }
        });

        // Calculate height - use the height passed from parent
        let _height = self.content_height.unwrap_or_else(|| px(500.)); // Default height if not specified

        // Get mono font family for code editor
        let fonts = self.theme.get_fonts();
        let mono_font: SharedString = fonts.mono_family.into();

        // Get font size from config (used for inner container inheritance)
        // KEEP as px() because:
        // 1. User explicitly configured a pixel size in config.ts
        // 2. Editor requires precise character sizing for monospace alignment
        let font_size = self.config.get_editor_font_size();

        // Action handlers for snippet Tab navigation
        // GPUI actions bubble up from focused element to parents, but only if the
        // focused element calls cx.propagate(). Since gpui-component's Input handles
        // IndentInline without propagating, we need to intercept at the Input wrapper level.
        let handle_indent = cx.listener(|this, _: &IndentInline, window, cx| {
            logging::log(
                "EDITOR",
                &format!(
                    "IndentInline action received, in_snippet_mode={}",
                    this.in_snippet_mode()
                ),
            );
            if this.in_snippet_mode() {
                this.next_tabstop(window, cx);
                // Don't propagate - we handled it
            } else {
                cx.propagate(); // Let Input handle normal indent
            }
        });

        let handle_outdent = cx.listener(|this, _: &OutdentInline, window, cx| {
            logging::log(
                "EDITOR",
                &format!(
                    "OutdentInline action received, in_snippet_mode={}",
                    this.in_snippet_mode()
                ),
            );
            if this.in_snippet_mode() {
                this.prev_tabstop(window, cx);
                // Don't propagate - we handled it
            } else {
                cx.propagate(); // Let Input handle normal outdent
            }
        });

        // Build the main container - code editor fills the space completely
        // Note: We don't track focus on the container because the InputState
        // has its own focus handle. Key events will be handled by the Input.
        //
        // Use size_full() to fill the parent container (which controls the actual size).
        // The parent wrapper in render_prompts/editor.rs uses flex_1 to allocate space.
        let mut container = div()
            .id("editor-v2")
            .flex()
            .flex_col()
            .size_full() // Fill parent container instead of explicit height
            .text_color(rgb(colors.text.primary))
            .font_family(mono_font.clone()) // Use monospace font for code
            .text_size(px(font_size)) // Apply configured font size
            .on_key_down(handle_key)
            .on_action(handle_indent)
            .on_action(handle_outdent);

        // Add the editor content if initialized
        if let Some(ref editor_state) = self.editor_state {
            container = container.child(
                div()
                    .size_full() // Fill the entire container
                    .overflow_hidden()
                    .text_size(px(font_size)) // Apply font size to inner container for inheritance
                    .font_family(mono_font.clone()) // Also apply mono font
                    // No padding - editor fills the space completely
                    // The Input component from gpui-component
                    // appearance(false) removes border styling for seamless integration
                    .child(Input::new(editor_state).size_full().appearance(false)),
            );
        } else {
            // Show loading placeholder while initializing
            container = container.child(
                div()
                    .size_full()
                    .flex()
                    .items_center()
                    .justify_center()
                    .child("Loading editor..."),
            );
        }

        // NOTE: Footer rendering has been moved to the unified PromptFooter component
        // in render_prompts/editor.rs. The snippet state and language are passed to that footer.

        // Add relative positioning to container for choices popup overlay
        container = container.relative();

        // Add the choices popup overlay if visible
        if let Some(popup_element) = self.render_choices_popup(cx) {
            container = container.child(popup_element);
        }

        container
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_editor_creation() {
        // Basic smoke test - just verify the struct can be created with expected fields
        // Full integration tests require GPUI context
    }

    #[test]
    fn test_char_offset_to_position_single_line() {
        let text = "Hello World";
        let pos0 = char_offset_to_position(text, 0);
        assert_eq!((pos0.line, pos0.character), (0, 0));

        let pos5 = char_offset_to_position(text, 5);
        assert_eq!((pos5.line, pos5.character), (0, 5));

        let pos11 = char_offset_to_position(text, 11);
        assert_eq!((pos11.line, pos11.character), (0, 11));
    }

    #[test]
    fn test_char_offset_to_position_multi_line() {
        let text = "Hello\nWorld\nTest";
        // Line 0: "Hello" (0-4), newline at 5
        // Line 1: "World" (6-10), newline at 11
        // Line 2: "Test" (12-15)
        let pos0 = char_offset_to_position(text, 0);
        assert_eq!((pos0.line, pos0.character), (0, 0)); // 'H'

        let pos5 = char_offset_to_position(text, 5);
        assert_eq!((pos5.line, pos5.character), (0, 5)); // '\n'

        let pos6 = char_offset_to_position(text, 6);
        assert_eq!((pos6.line, pos6.character), (1, 0)); // 'W'

        let pos11 = char_offset_to_position(text, 11);
        assert_eq!((pos11.line, pos11.character), (1, 5)); // '\n'

        let pos12 = char_offset_to_position(text, 12);
        assert_eq!((pos12.line, pos12.character), (2, 0)); // 'T'

        let pos16 = char_offset_to_position(text, 16);
        assert_eq!((pos16.line, pos16.character), (2, 4)); // past end
    }

    #[test]
    fn test_char_offset_to_position_empty() {
        let text = "";
        let pos = char_offset_to_position(text, 0);
        assert_eq!((pos.line, pos.character), (0, 0));
    }

    #[test]
    fn test_snippet_state_creation() {
        // Test that SnippetState is properly initialized from a template
        let snippet = ParsedSnippet::parse("Hello ${1:name}!");

        let current_values = vec!["name".to_string()];
        let last_selection_ranges = vec![Some((6, 10))];

        let state = SnippetState {
            snippet: snippet.clone(),
            current_tabstop_idx: 0,
            current_values,
            last_selection_ranges,
        };

        assert_eq!(state.current_tabstop_idx, 0);
        assert_eq!(state.snippet.tabstops.len(), 1);
        assert_eq!(state.snippet.tabstops[0].index, 1);
        assert_eq!(state.snippet.text, "Hello name!");
    }

    #[test]
    fn test_snippet_state_multiple_tabstops() {
        let snippet = ParsedSnippet::parse("Hello ${1:name}, welcome to ${2:place}!");

        let current_values = vec!["name".to_string(), "place".to_string()];
        let last_selection_ranges = vec![Some((6, 10)), Some((23, 28))];

        let state = SnippetState {
            snippet,
            current_tabstop_idx: 0,
            current_values,
            last_selection_ranges,
        };

        assert_eq!(state.snippet.tabstops.len(), 2);
        assert_eq!(state.snippet.tabstops[0].index, 1);
        assert_eq!(state.snippet.tabstops[1].index, 2);
        assert_eq!(state.snippet.text, "Hello name, welcome to place!");
    }

    #[test]
    fn test_snippet_state_with_final_cursor() {
        let snippet = ParsedSnippet::parse("Hello ${1:name}!$0");

        let current_values = vec!["name".to_string(), "".to_string()];
        let last_selection_ranges = vec![Some((6, 10)), Some((11, 11))];

        let state = SnippetState {
            snippet,
            current_tabstop_idx: 0,
            current_values,
            last_selection_ranges,
        };

        // Should have 2 tabstops: index 1 first, then index 0 ($0) at end
        assert_eq!(state.snippet.tabstops.len(), 2);
        assert_eq!(state.snippet.tabstops[0].index, 1);
        assert_eq!(state.snippet.tabstops[1].index, 0);
    }

    // =========================================================================
    // char_offset_to_byte_offset tests - CRITICAL for correct cursor placement
    // =========================================================================

    #[test]
    fn test_char_to_byte_offset_basic() {
        let text = "Hello";
        assert_eq!(char_offset_to_byte_offset(text, 0), 0); // 'H'
        assert_eq!(char_offset_to_byte_offset(text, 1), 1); // 'e'
        assert_eq!(char_offset_to_byte_offset(text, 5), 5); // end of string (equals len)
    }

    #[test]
    fn test_char_to_byte_offset_at_end_of_document() {
        // CRITICAL: This is the bug fix - offset at end should NOT return 0
        let text = "Hello";
        // Char offset 5 (end of 5-char string) should return byte offset 5, not 0
        assert_eq!(char_offset_to_byte_offset(text, 5), 5);

        // Beyond end should also return text.len()
        assert_eq!(char_offset_to_byte_offset(text, 100), 5);
    }

    #[test]
    fn test_char_to_byte_offset_empty_string() {
        let text = "";
        // Empty string: any offset should return 0 (which equals text.len())
        assert_eq!(char_offset_to_byte_offset(text, 0), 0);
        assert_eq!(char_offset_to_byte_offset(text, 1), 0);
    }

    #[test]
    fn test_char_to_byte_offset_unicode() {
        // "" = 2 chars, 6 bytes (3 bytes per CJK char)
        let text = "";
        assert_eq!(text.len(), 6); // 6 bytes
        assert_eq!(text.chars().count(), 2); // 2 chars

        assert_eq!(char_offset_to_byte_offset(text, 0), 0); // '' at byte 0
        assert_eq!(char_offset_to_byte_offset(text, 1), 3); // '' at byte 3
        assert_eq!(char_offset_to_byte_offset(text, 2), 6); // end = byte length
    }

    #[test]
    fn test_char_to_byte_offset_mixed_unicode() {
        // "Hi" = 4 chars, 8 bytes
        let text = "Hi";
        assert_eq!(text.len(), 8); // 2 + 3 + 3 = 8 bytes
        assert_eq!(text.chars().count(), 4); // 4 chars

        assert_eq!(char_offset_to_byte_offset(text, 0), 0); // 'H'
        assert_eq!(char_offset_to_byte_offset(text, 1), 1); // 'i'
        assert_eq!(char_offset_to_byte_offset(text, 2), 2); // ''
        assert_eq!(char_offset_to_byte_offset(text, 3), 5); // ''
        assert_eq!(char_offset_to_byte_offset(text, 4), 8); // end
    }

    #[test]
    fn test_char_to_byte_offset_emoji() {
        // "Hello " = 7 chars, but  is 4 bytes
        let text = "Hello ";
        assert_eq!(text.chars().count(), 7);
        assert!(text.len() > 7); // bytes > chars

        assert_eq!(char_offset_to_byte_offset(text, 0), 0); // 'H'
        assert_eq!(char_offset_to_byte_offset(text, 6), 6); // '' starts at byte 6
        assert_eq!(char_offset_to_byte_offset(text, 7), text.len()); // end
    }

    #[test]
    fn test_char_to_byte_offset_snippet_final_cursor() {
        // Simulate $0 at end of "Hello name!"
        // This is the exact scenario that was broken before the fix
        let text = "Hello name!";
        let text_len = text.chars().count(); // 11

        // $0 range is (11, 11) - cursor at very end
        let start_clamped = 11_usize.min(text_len);
        let end_clamped = 11_usize.min(text_len);

        // Both should be 11 (byte length), NOT 0
        let start_bytes = char_offset_to_byte_offset(text, start_clamped);
        let end_bytes = char_offset_to_byte_offset(text, end_clamped);

        assert_eq!(start_bytes, 11, "start_bytes should be 11, not 0!");
        assert_eq!(end_bytes, 11, "end_bytes should be 11");

        // This is a zero-length selection at the end (cursor, not selection)
        assert_eq!(start_bytes, end_bytes);
    }
}

</file>

</files>