This file is a merged representation of the filtered codebase, combined into a single document by packx.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of filtered repository contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<usage_guidelines>
- Treat this file as a snapshot of the repository's state
- Be aware that this file may contain sensitive information
</usage_guidelines>

<notes>
- Files were filtered by packx based on content and extension matching
- Total files included: 6
</notes>
</file_summary>

<directory_structure>
src/scriptlets.rs
src/expand_matcher.rs
src/expand_manager.rs
src/text_injector.rs
src/snippet.rs
src/scriptlet_metadata.rs
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="src/scriptlets.rs">
//! Scriptlet parsing and variable substitution module
//!
//! This module provides comprehensive support for parsing markdown files
//! containing scriptlets (code snippets with metadata) and performing
//! variable substitution in scriptlet content.
//!
//! # Types
//! - `Scriptlet`: Full scriptlet with all metadata
//! - `ScriptletMetadata`: Parsed HTML comment metadata
//!
//! # Features
//! - Parse markdown files with H1 groups and H2 scriptlets
//! - Extract metadata from HTML comments
//! - Handle nested code fences (``` inside ~~~ and vice versa)
//! - Variable substitution with named inputs, positional args, and conditionals

use crate::metadata_parser::TypedMetadata;
use crate::schema_parser::Schema;
use crate::scriptlet_metadata::parse_codefence_metadata;
use serde::{Deserialize, Serialize};
use std::collections::HashMap;
use std::path::PathBuf;
use tracing::debug;

/// Valid tool types that can be used in code fences
pub const VALID_TOOLS: &[&str] = &[
    "bash",
    "python",
    "kit",
    "ts",
    "js",
    "transform",
    "template",
    "open",
    "edit",
    "paste",
    "type",
    "submit",
    "applescript",
    "ruby",
    "perl",
    "php",
    "node",
    "deno",
    "bun",
    // Shell variants
    "zsh",
    "sh",
    "fish",
    "cmd",
    "powershell",
    "pwsh",
];

/// Shell tools (tools that execute in a shell environment)
pub const SHELL_TOOLS: &[&str] = &["bash", "zsh", "sh", "fish", "cmd", "powershell", "pwsh"];

// ============================================================================
// Bundle Frontmatter (YAML at top of markdown files)
// ============================================================================

/// Frontmatter metadata for a scriptlet bundle (markdown file)
/// This is parsed from YAML at the top of the file, delimited by `---`
#[allow(dead_code)] // Public API for future use
#[derive(Clone, Debug, Default, Serialize, Deserialize, PartialEq)]
pub struct BundleFrontmatter {
    /// Bundle name
    pub name: Option<String>,
    /// Bundle description
    pub description: Option<String>,
    /// Author of the bundle
    pub author: Option<String>,
    /// Default icon for scriptlets in this bundle
    pub icon: Option<String>,
    /// Any additional fields
    #[serde(flatten)]
    pub extra: HashMap<String, serde_yaml::Value>,
}

/// Parse YAML frontmatter from the beginning of markdown content
///
/// Frontmatter is delimited by `---` at the start and end:
/// ```markdown
/// ---
/// name: My Bundle
/// icon: Star
/// ---
/// # Content starts here
/// ```
#[allow(dead_code)] // Public API for future use
pub fn parse_bundle_frontmatter(content: &str) -> Option<BundleFrontmatter> {
    let trimmed = content.trim_start();

    // Must start with ---
    if !trimmed.starts_with("---") {
        return None;
    }

    // Find the closing ---
    let after_first = &trimmed[3..];
    let end_pos = after_first.find("\n---")?;

    let yaml_content = &after_first[..end_pos].trim();

    match serde_yaml::from_str::<BundleFrontmatter>(yaml_content) {
        Ok(fm) => Some(fm),
        Err(e) => {
            debug!(error = %e, "Failed to parse bundle frontmatter");
            None
        }
    }
}

/// Get a default icon for a tool type
#[allow(dead_code)] // Public API for future use
pub fn tool_type_to_icon(tool: &str) -> &'static str {
    match tool {
        "bash" | "zsh" | "sh" | "fish" => "terminal",
        "python" => "snake",
        "ruby" => "gem",
        "node" | "js" | "ts" | "kit" => "file-code",
        "open" => "external-link",
        "edit" => "edit",
        "paste" => "clipboard",
        "type" => "keyboard",
        "template" => "file-text",
        "transform" => "refresh-cw",
        "applescript" => "apple",
        "powershell" | "pwsh" | "cmd" => "terminal",
        "perl" => "code",
        "php" => "code",
        "deno" | "bun" => "file-code",
        _ => "file",
    }
}

/// Resolve the icon for a scriptlet using priority order:
/// 1. Scriptlet-level metadata icon
/// 2. Bundle frontmatter default icon
/// 3. Tool-type default icon
#[allow(dead_code)] // Public API for future use
pub fn resolve_scriptlet_icon(
    metadata: &ScriptletMetadata,
    frontmatter: Option<&BundleFrontmatter>,
    tool: &str,
) -> String {
    // Check scriptlet metadata first (via extra field for now)
    if let Some(icon) = metadata.extra.get("icon") {
        return icon.clone();
    }

    // Check bundle frontmatter
    if let Some(fm) = frontmatter {
        if let Some(ref icon) = fm.icon {
            return icon.clone();
        }
    }

    // Fall back to tool default
    tool_type_to_icon(tool).to_string()
}

// ============================================================================
// Validation Error Types
// ============================================================================

/// Error encountered during scriptlet validation.
/// Allows per-scriptlet validation with graceful degradation -
/// valid scriptlets can still be loaded even when others fail.
#[allow(dead_code)] // Public API for future use
#[derive(Clone, Debug, Serialize, Deserialize, PartialEq)]
pub struct ScriptletValidationError {
    /// Path to the source file
    pub file_path: PathBuf,
    /// Name of the scriptlet that failed (if identifiable)
    pub scriptlet_name: Option<String>,
    /// Line number where the error occurred (1-based)
    pub line_number: Option<usize>,
    /// Description of what went wrong
    pub error_message: String,
}

#[allow(dead_code)] // Public API for future use
impl ScriptletValidationError {
    /// Create a new validation error
    pub fn new(
        file_path: impl Into<PathBuf>,
        scriptlet_name: Option<String>,
        line_number: Option<usize>,
        error_message: impl Into<String>,
    ) -> Self {
        Self {
            file_path: file_path.into(),
            scriptlet_name,
            line_number,
            error_message: error_message.into(),
        }
    }
}

impl std::fmt::Display for ScriptletValidationError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.file_path.display())?;
        if let Some(line) = self.line_number {
            write!(f, ":{}", line)?;
        }
        if let Some(ref name) = self.scriptlet_name {
            write!(f, " [{}]", name)?;
        }
        write!(f, ": {}", self.error_message)
    }
}

/// Result of parsing scriptlets from a markdown file with validation.
/// Contains both successfully parsed scriptlets and any validation errors encountered.
#[allow(dead_code)] // Public API for future use
#[derive(Clone, Debug, Default)]
pub struct ScriptletParseResult {
    /// Successfully parsed scriptlets
    pub scriptlets: Vec<Scriptlet>,
    /// Validation errors for scriptlets that failed to parse
    pub errors: Vec<ScriptletValidationError>,
    /// Bundle-level frontmatter (if present)
    pub frontmatter: Option<BundleFrontmatter>,
}

/// Metadata extracted from HTML comments in scriptlets
#[derive(Clone, Debug, Default, Serialize, Deserialize, PartialEq)]
pub struct ScriptletMetadata {
    /// Trigger text that activates this scriptlet
    pub trigger: Option<String>,
    /// Keyboard shortcut (e.g., "cmd shift k")
    pub shortcut: Option<String>,
    /// Raw cron expression (e.g., "*/5 * * * *")
    pub cron: Option<String>,
    /// Natural language schedule (e.g., "every tuesday at 2pm") - converted to cron internally
    pub schedule: Option<String>,
    /// Whether to run in background
    pub background: Option<bool>,
    /// File paths to watch for changes
    pub watch: Option<String>,
    /// System event to trigger on
    pub system: Option<String>,
    /// Description of the scriptlet
    pub description: Option<String>,
    /// Text expansion trigger (e.g., "type,,")
    pub expand: Option<String>,
    /// Alias trigger - when user types alias + space, immediately run script
    pub alias: Option<String>,
    /// Any additional metadata key-value pairs
    #[serde(flatten)]
    pub extra: HashMap<String, String>,
}

/// A scriptlet parsed from a markdown file
#[derive(Clone, Debug, Serialize, Deserialize, PartialEq)]
pub struct Scriptlet {
    /// Name of the scriptlet (from H2 header)
    pub name: String,
    /// Command identifier (slugified name)
    pub command: String,
    /// Tool type (bash, python, ts, etc.)
    pub tool: String,
    /// The actual code content
    pub scriptlet_content: String,
    /// Named input placeholders (e.g., ["variableName", "otherVar"])
    pub inputs: Vec<String>,
    /// Group name (from H1 header)
    pub group: String,
    /// HTML preview content (if any)
    pub preview: Option<String>,
    /// Parsed metadata from HTML comments (legacy format)
    pub metadata: ScriptletMetadata,
    /// Typed metadata from codefence ```metadata block (new format)
    pub typed_metadata: Option<TypedMetadata>,
    /// Schema definition from codefence ```schema block
    pub schema: Option<Schema>,
    /// The kit this scriptlet belongs to
    pub kit: Option<String>,
    /// Source file path
    pub source_path: Option<String>,
}

#[allow(dead_code)]
impl Scriptlet {
    /// Create a new scriptlet with minimal required fields
    pub fn new(name: String, tool: String, content: String) -> Self {
        let command = slugify(&name);
        let inputs = extract_named_inputs(&content);

        Scriptlet {
            name,
            command,
            tool,
            scriptlet_content: content,
            inputs,
            group: String::new(),
            preview: None,
            metadata: ScriptletMetadata::default(),
            typed_metadata: None,
            schema: None,
            kit: None,
            source_path: None,
        }
    }

    /// Check if this scriptlet uses a shell tool
    pub fn is_shell(&self) -> bool {
        SHELL_TOOLS.contains(&self.tool.as_str())
    }

    /// Check if the tool type is valid
    pub fn is_valid_tool(&self) -> bool {
        VALID_TOOLS.contains(&self.tool.as_str())
    }
}

/// Convert a name to a command slug (lowercase, spaces to hyphens)
fn slugify(name: &str) -> String {
    name.to_lowercase()
        .chars()
        .map(|c| if c.is_alphanumeric() { c } else { '-' })
        .collect::<String>()
        .split('-')
        .filter(|s| !s.is_empty())
        .collect::<Vec<_>>()
        .join("-")
}

/// Extract named input placeholders from scriptlet content
/// Finds all {{variableName}} patterns
fn extract_named_inputs(content: &str) -> Vec<String> {
    let mut inputs = Vec::new();
    let mut chars = content.chars().peekable();

    while let Some(c) = chars.next() {
        if c == '{' && chars.peek() == Some(&'{') {
            chars.next(); // consume second {
            let mut name = String::new();

            // Skip if it's a conditional ({{#if, {{else, {{/if)
            if chars.peek() == Some(&'#') || chars.peek() == Some(&'/') {
                continue;
            }

            // Collect the variable name
            while let Some(&ch) = chars.peek() {
                if ch == '}' {
                    break;
                }
                name.push(ch);
                chars.next();
            }

            // Skip closing }}
            if chars.peek() == Some(&'}') {
                chars.next();
                if chars.peek() == Some(&'}') {
                    chars.next();
                }
            }

            // Add if valid identifier and not already present
            let trimmed = name.trim();
            if !trimmed.is_empty()
                && !trimmed.starts_with('#')
                && !trimmed.starts_with('/')
                && trimmed != "else"
                && !inputs.contains(&trimmed.to_string())
            {
                inputs.push(trimmed.to_string());
            }
        }
    }

    inputs
}

/// Parse metadata from HTML comments
/// Supports format: <!-- key: value\nkey2: value2 -->
pub fn parse_html_comment_metadata(text: &str) -> ScriptletMetadata {
    let mut metadata = ScriptletMetadata::default();

    // Find all HTML comment blocks
    let mut remaining = text;
    while let Some(start) = remaining.find("<!--") {
        if let Some(end) = remaining[start..].find("-->") {
            let comment_content = &remaining[start + 4..start + end];

            // Parse key: value pairs
            for line in comment_content.lines() {
                let trimmed = line.trim();
                if trimmed.is_empty() {
                    continue;
                }

                if let Some(colon_pos) = trimmed.find(':') {
                    let key = trimmed[..colon_pos].trim().to_lowercase();
                    let value = trimmed[colon_pos + 1..].trim().to_string();

                    if value.is_empty() {
                        continue;
                    }

                    match key.as_str() {
                        "trigger" => metadata.trigger = Some(value),
                        "shortcut" => metadata.shortcut = Some(value),
                        "cron" => metadata.cron = Some(value),
                        "schedule" => metadata.schedule = Some(value),
                        "background" => {
                            metadata.background =
                                Some(value.to_lowercase() == "true" || value == "1")
                        }
                        "watch" => metadata.watch = Some(value),
                        "system" => metadata.system = Some(value),
                        "description" => metadata.description = Some(value),
                        "expand" => metadata.expand = Some(value),
                        "alias" => metadata.alias = Some(value),
                        _ => {
                            metadata.extra.insert(key, value);
                        }
                    }
                }
            }

            remaining = &remaining[start + end + 3..];
        } else {
            break;
        }
    }

    metadata
}

/// State for parsing code fences
#[derive(Clone, Copy, PartialEq)]
enum FenceType {
    Backticks, // ```
    Tildes,    // ~~~
}

/// Extract code block from text, handling nested fences
/// Returns (tool, code) if found
pub fn extract_code_block_nested(text: &str) -> Option<(String, String)> {
    let lines: Vec<&str> = text.lines().collect();
    let mut in_fence = false;
    let mut fence_type: Option<FenceType> = None;
    let mut fence_count = 0;
    let mut tool = String::new();
    let mut code_lines = Vec::new();
    let mut found = false;

    for line in lines {
        let trimmed = line.trim_start();

        if !in_fence {
            // Check for opening fence
            if let Some(fence_info) = detect_fence_start(trimmed) {
                in_fence = true;
                fence_type = Some(fence_info.0);
                fence_count = fence_info.1;
                tool = fence_info.2;
                continue;
            }
        } else {
            // Check for closing fence (same type, same or more chars)
            if is_matching_fence_end(trimmed, fence_type.unwrap(), fence_count) {
                found = true;
                break;
            }
            code_lines.push(line);
        }
    }

    if found {
        let code = code_lines.join("\n");
        Some((tool, code.trim().to_string()))
    } else if in_fence && !code_lines.is_empty() {
        // Unclosed fence, but we have content
        let code = code_lines.join("\n");
        Some((tool, code.trim().to_string()))
    } else {
        None
    }
}

/// Detect if a line starts a code fence, returns (fence_type, count, language)
fn detect_fence_start(line: &str) -> Option<(FenceType, usize, String)> {
    let backtick_count = line.chars().take_while(|&c| c == '`').count();
    if backtick_count >= 3 {
        let rest = &line[backtick_count..];
        let lang = rest.split_whitespace().next().unwrap_or("").to_string();
        return Some((FenceType::Backticks, backtick_count, lang));
    }

    let tilde_count = line.chars().take_while(|&c| c == '~').count();
    if tilde_count >= 3 {
        let rest = &line[tilde_count..];
        let lang = rest.split_whitespace().next().unwrap_or("").to_string();
        return Some((FenceType::Tildes, tilde_count, lang));
    }

    None
}

/// Check if a line is a closing fence matching the opening
fn is_matching_fence_end(line: &str, fence_type: FenceType, min_count: usize) -> bool {
    let count = match fence_type {
        FenceType::Backticks => line.chars().take_while(|&c| c == '`').count(),
        FenceType::Tildes => line.chars().take_while(|&c| c == '~').count(),
    };

    if count < min_count {
        return false;
    }

    // Rest of line should be empty or whitespace
    let rest = &line[count..];
    rest.chars().all(|c| c.is_whitespace())
}

/// Parse a markdown file into scriptlets
///
/// # Format
/// - H1 headers (`# Group Name`) define groups
/// - H1 can have a code fence that prepends to all scriptlets in that group
/// - H2 headers (`## Scriptlet Name`) define individual scriptlets
/// - HTML comments contain metadata
/// - Code fences contain the scriptlet code
pub fn parse_markdown_as_scriptlets(content: &str, source_path: Option<&str>) -> Vec<Scriptlet> {
    let mut scriptlets = Vec::new();
    let mut current_group = String::new();
    let mut global_prepend = String::new();

    // Split by headers while preserving the header type
    let sections = split_by_headers(content);

    for section in sections {
        let section_text = section.text;
        let first_line = section_text.lines().next().unwrap_or("");

        if first_line.starts_with("## ") {
            // H2: Individual scriptlet
            let name = first_line
                .strip_prefix("## ")
                .unwrap_or("")
                .trim()
                .to_string();

            if name.is_empty() {
                continue;
            }

            // Try codefence metadata first (new format)
            let codefence_result = parse_codefence_metadata(section_text);
            let typed_metadata = codefence_result.metadata;
            let schema = codefence_result.schema;

            // Also parse HTML comment metadata (legacy format, for backward compatibility)
            let metadata = parse_html_comment_metadata(section_text);

            // Extract code block - prefer codefence result if available, else use legacy extraction
            let code_block = if let Some(ref code_block) = codefence_result.code {
                Some((code_block.language.clone(), code_block.content.clone()))
            } else {
                extract_code_block_nested(section_text)
            };

            if let Some((tool_str, mut code)) = code_block {
                // Prepend global code if exists and tool matches
                if !global_prepend.is_empty() {
                    code = format!("{}\n{}", global_prepend, code);
                }

                // Validate tool type
                let tool: String = if tool_str.is_empty() {
                    "ts".to_string()
                } else {
                    tool_str
                };

                // Check if tool is valid, warn if not
                if !VALID_TOOLS.contains(&tool.as_str()) {
                    debug!(tool = %tool, name = %name, "Unknown tool type in scriptlet");
                }

                let inputs = extract_named_inputs(&code);
                let command = slugify(&name);

                scriptlets.push(Scriptlet {
                    name,
                    command,
                    tool,
                    scriptlet_content: code,
                    inputs,
                    group: current_group.clone(),
                    preview: None,
                    metadata,
                    typed_metadata,
                    schema,
                    kit: None,
                    source_path: source_path.map(|s| s.to_string()),
                });
            }
        } else if first_line.starts_with("# ") {
            // H1: Group header
            let group_name = first_line
                .strip_prefix("# ")
                .unwrap_or("")
                .trim()
                .to_string();
            current_group = group_name;

            // Check for global prepend code block
            if let Some((_, code)) = extract_code_block_nested(section_text) {
                global_prepend = code;
            } else {
                global_prepend.clear();
            }
        }
    }

    scriptlets
}

/// Section of markdown content with its header level
struct MarkdownSection<'a> {
    text: &'a str,
}

/// Split markdown content by headers, preserving header lines
fn split_by_headers(content: &str) -> Vec<MarkdownSection<'_>> {
    let mut sections = Vec::new();
    let mut current_start = 0;
    let mut in_fence = false;
    let mut fence_type: Option<FenceType> = None;
    let mut fence_count = 0;

    let lines: Vec<&str> = content.lines().collect();
    let line_starts: Vec<usize> = std::iter::once(0)
        .chain(content.match_indices('\n').map(|(i, _)| i + 1))
        .collect();

    for (i, line) in lines.iter().enumerate() {
        let trimmed = line.trim_start();

        // Track fence state
        if !in_fence {
            if let Some(fence_info) = detect_fence_start(trimmed) {
                in_fence = true;
                fence_type = Some(fence_info.0);
                fence_count = fence_info.1;
                continue;
            }
        } else if is_matching_fence_end(trimmed, fence_type.unwrap(), fence_count) {
            in_fence = false;
            fence_type = None;
            fence_count = 0;
            continue;
        }

        // Only split on headers outside of fences
        if !in_fence && (trimmed.starts_with("# ") || trimmed.starts_with("## ")) {
            if i > 0 {
                let start = line_starts[current_start];
                let end = line_starts[i];
                if end > start {
                    sections.push(MarkdownSection {
                        text: &content[start..end],
                    });
                }
            }
            current_start = i;
        }
    }

    // Add remaining content
    if current_start < lines.len() {
        let start = line_starts[current_start];
        sections.push(MarkdownSection {
            text: &content[start..],
        });
    }

    sections
}

// ============================================================================
// Validation-Aware Parsing
// ============================================================================

/// Parse markdown file into scriptlets with validation and graceful degradation.
///
/// Unlike `parse_markdown_as_scriptlets`, this function:
/// - Returns both valid scriptlets AND validation errors
/// - Continues parsing after individual scriptlet validation failures
/// - Parses bundle-level frontmatter
/// - Resolves icons using the priority order (scriptlet > frontmatter > tool default)
#[allow(dead_code)] // Public API for future use
pub fn parse_scriptlets_with_validation(
    content: &str,
    source_path: Option<&str>,
) -> ScriptletParseResult {
    let mut result = ScriptletParseResult::default();
    let file_path = PathBuf::from(source_path.unwrap_or("<unknown>"));

    // Parse bundle-level frontmatter
    result.frontmatter = parse_bundle_frontmatter(content);

    let mut current_group = String::new();
    let mut global_prepend = String::new();

    // Split by headers while preserving the header type and line numbers
    let sections = split_by_headers_with_line_numbers(content);

    for section in sections {
        let section_text = section.text;
        let section_start_line = section.line_number;
        let first_line = section_text.lines().next().unwrap_or("");

        if first_line.starts_with("## ") {
            // H2: Individual scriptlet
            let name = first_line
                .strip_prefix("## ")
                .unwrap_or("")
                .trim()
                .to_string();

            if name.is_empty() {
                result.errors.push(ScriptletValidationError::new(
                    &file_path,
                    None,
                    Some(section_start_line),
                    "Empty scriptlet name (H2 header with no text)",
                ));
                continue;
            }

            // Try to parse this scriptlet, catching any validation errors
            match parse_single_scriptlet(
                section_text,
                &name,
                &current_group,
                &global_prepend,
                source_path,
                result.frontmatter.as_ref(),
                section_start_line,
                &file_path,
            ) {
                Ok(scriptlet) => result.scriptlets.push(scriptlet),
                Err(error) => result.errors.push(error),
            }
        } else if first_line.starts_with("# ") {
            // H1: Group header
            let group_name = first_line
                .strip_prefix("# ")
                .unwrap_or("")
                .trim()
                .to_string();
            current_group = group_name;

            // Check for global prepend code block
            if let Some((_, code)) = extract_code_block_nested(section_text) {
                global_prepend = code;
            } else {
                global_prepend.clear();
            }
        }
    }

    result
}

/// Parse a single scriptlet from a section, returning either a Scriptlet or a validation error
#[allow(dead_code)] // Used by parse_scriptlets_with_validation
#[allow(clippy::too_many_arguments)]
fn parse_single_scriptlet(
    section_text: &str,
    name: &str,
    current_group: &str,
    global_prepend: &str,
    source_path: Option<&str>,
    frontmatter: Option<&BundleFrontmatter>,
    section_start_line: usize,
    file_path: &PathBuf,
) -> Result<Scriptlet, ScriptletValidationError> {
    // Try codefence metadata first (new format)
    let codefence_result = parse_codefence_metadata(section_text);
    let typed_metadata = codefence_result.metadata;
    let schema = codefence_result.schema;

    // Check for codefence parse errors - log but don't fail
    for error in &codefence_result.errors {
        debug!(error = %error, scriptlet = %name, "Codefence parse warning");
    }

    // Also parse HTML comment metadata (legacy format, for backward compatibility)
    let metadata = parse_html_comment_metadata(section_text);

    // Extract code block - prefer codefence result if available
    let code_block = if let Some(ref code_block) = codefence_result.code {
        Some((code_block.language.clone(), code_block.content.clone()))
    } else {
        extract_code_block_nested(section_text)
    };

    let (tool_str, mut code) = code_block.ok_or_else(|| {
        ScriptletValidationError::new(
            file_path,
            Some(name.to_string()),
            Some(section_start_line),
            "No code block found in scriptlet",
        )
    })?;

    // Prepend global code if exists
    if !global_prepend.is_empty() {
        code = format!("{}\n{}", global_prepend, code);
    }

    // Default tool type to "ts" if empty
    let tool = if tool_str.is_empty() {
        "ts".to_string()
    } else {
        tool_str
    };

    // Check if tool is valid - emit warning but don't fail
    if !VALID_TOOLS.contains(&tool.as_str()) {
        debug!(tool = %tool, name = %name, "Unknown tool type in scriptlet");
    }

    // Resolve icon using priority order
    let _resolved_icon = resolve_scriptlet_icon(&metadata, frontmatter, &tool);

    let inputs = extract_named_inputs(&code);
    let command = slugify(name);

    Ok(Scriptlet {
        name: name.to_string(),
        command,
        tool,
        scriptlet_content: code,
        inputs,
        group: current_group.to_string(),
        preview: None,
        metadata,
        typed_metadata,
        schema,
        kit: None,
        source_path: source_path.map(|s| s.to_string()),
    })
}

/// Section of markdown content with its header level and line number
#[allow(dead_code)] // Used by split_by_headers_with_line_numbers
struct MarkdownSectionWithLine<'a> {
    text: &'a str,
    line_number: usize, // 1-based line number
}

/// Split markdown content by headers, preserving header lines and line numbers
#[allow(dead_code)] // Used by parse_scriptlets_with_validation
fn split_by_headers_with_line_numbers(content: &str) -> Vec<MarkdownSectionWithLine<'_>> {
    let mut sections = Vec::new();
    let mut current_start = 0;
    let mut current_start_line = 1; // 1-based
    let mut in_fence = false;
    let mut fence_type: Option<FenceType> = None;
    let mut fence_count = 0;

    let lines: Vec<&str> = content.lines().collect();
    let line_starts: Vec<usize> = std::iter::once(0)
        .chain(content.match_indices('\n').map(|(i, _)| i + 1))
        .collect();

    for (i, line) in lines.iter().enumerate() {
        let trimmed = line.trim_start();

        // Track fence state
        if !in_fence {
            if let Some(fence_info) = detect_fence_start(trimmed) {
                in_fence = true;
                fence_type = Some(fence_info.0);
                fence_count = fence_info.1;
                continue;
            }
        } else if is_matching_fence_end(trimmed, fence_type.unwrap(), fence_count) {
            in_fence = false;
            fence_type = None;
            fence_count = 0;
            continue;
        }

        // Only split on headers outside of fences
        if !in_fence && (trimmed.starts_with("# ") || trimmed.starts_with("## ")) {
            if i > 0 {
                let start = line_starts[current_start];
                let end = line_starts[i];
                if end > start {
                    sections.push(MarkdownSectionWithLine {
                        text: &content[start..end],
                        line_number: current_start_line,
                    });
                }
            }
            current_start = i;
            current_start_line = i + 1; // Convert to 1-based
        }
    }

    // Add remaining content
    if current_start < lines.len() {
        let start = line_starts[current_start];
        sections.push(MarkdownSectionWithLine {
            text: &content[start..],
            line_number: current_start_line,
        });
    }

    sections
}

// ============================================================================
// Variable Substitution
// ============================================================================

/// Format a scriptlet by substituting variables
///
/// # Variable Types
/// - `{{variableName}}` - Named input, replaced with value from inputs map
/// - `$1`, `$2`, etc. (Unix) or `%1`, `%2`, etc. (Windows) - Positional args
/// - `$@` (Unix) or `%*` (Windows) - All arguments
///
/// # Arguments
/// * `content` - The scriptlet content with placeholders
/// * `inputs` - Map of variable names to values
/// * `positional_args` - List of positional arguments
/// * `windows` - If true, use Windows-style placeholders (%1, %*)
pub fn format_scriptlet(
    content: &str,
    inputs: &HashMap<String, String>,
    positional_args: &[String],
    windows: bool,
) -> String {
    let mut result = content.to_string();

    // Replace named inputs {{variableName}}
    for (name, value) in inputs {
        let placeholder = format!("{{{{{}}}}}", name);
        result = result.replace(&placeholder, value);
    }

    // Replace positional arguments
    if windows {
        // Windows style: %1, %2, etc.
        for (i, arg) in positional_args.iter().enumerate() {
            let placeholder = format!("%{}", i + 1);
            result = result.replace(&placeholder, arg);
        }

        // Replace %* with all args quoted
        let all_args = positional_args
            .iter()
            .map(|a| format!("\"{}\"", a.replace('\"', "\\\"")))
            .collect::<Vec<_>>()
            .join(" ");
        result = result.replace("%*", &all_args);
    } else {
        // Unix style: $1, $2, etc.
        for (i, arg) in positional_args.iter().enumerate() {
            let placeholder = format!("${}", i + 1);
            result = result.replace(&placeholder, arg);
        }

        // Replace $@ with all args quoted
        let all_args = positional_args
            .iter()
            .map(|a| format!("\"{}\"", a.replace('\"', "\\\"")))
            .collect::<Vec<_>>()
            .join(" ");
        result = result.replace("$@", &all_args);
    }

    result
}

/// Process conditional blocks in scriptlet content
///
/// Supports:
/// - `{{#if flag}}...{{/if}}` - Include content if flag is truthy
/// - `{{#if flag}}...{{else}}...{{/if}}` - If-else
/// - `{{#if flag}}...{{else if other}}...{{else}}...{{/if}}` - If-else-if chains
///
/// # Arguments
/// * `content` - The scriptlet content with conditionals
/// * `flags` - Map of flag names to boolean values
pub fn process_conditionals(content: &str, flags: &HashMap<String, bool>) -> String {
    process_conditionals_impl(content, flags)
}

/// Internal implementation that handles the recursive conditional processing
fn process_conditionals_impl(content: &str, flags: &HashMap<String, bool>) -> String {
    let mut result = String::with_capacity(content.len());
    let mut i = 0;
    let bytes = content.as_bytes();

    while i < bytes.len() {
        // Check for {{#if
        if i + 5 < bytes.len() && &bytes[i..i + 3] == b"{{#" {
            // Find the closing }}
            if let Some(end_tag) = find_closing_braces(content, i + 3) {
                let directive = &content[i + 3..end_tag];

                if directive.starts_with("if ") {
                    let flag_name = directive.strip_prefix("if ").unwrap().trim();
                    let remaining = &content[end_tag + 2..];
                    let (processed, consumed) = process_if_block(remaining, flag_name, flags);
                    result.push_str(&processed);
                    i = end_tag + 2 + consumed;
                    continue;
                }
            }
        }

        // Not a conditional, just copy the character
        if i < content.len() {
            result.push(content[i..].chars().next().unwrap());
            i += content[i..].chars().next().unwrap().len_utf8();
        } else {
            break;
        }
    }

    result
}

/// Find the position of closing }} starting from a given position
fn find_closing_braces(content: &str, start: usize) -> Option<usize> {
    let bytes = content.as_bytes();
    let mut i = start;

    while i + 1 < bytes.len() {
        if bytes[i] == b'}' && bytes[i + 1] == b'}' {
            return Some(i);
        }
        i += 1;
    }

    None
}

/// Process a single if block, returning (result, bytes_consumed)
fn process_if_block(
    content: &str,
    flag_name: &str,
    flags: &HashMap<String, bool>,
) -> (String, usize) {
    let flag_value = flags.get(flag_name).copied().unwrap_or(false);

    let mut depth = 1;
    let mut if_content = String::new();
    let mut else_content = String::new();
    let mut else_if_chains: Vec<(String, String)> = Vec::new(); // (flag, content)
    let mut in_else = false;
    let mut current_else_if_flag: Option<String> = None;
    let mut consumed = 0;

    let mut chars = content.chars().peekable();
    let mut pos = 0;

    while let Some(c) = chars.next() {
        pos += c.len_utf8();

        if c == '{' && chars.peek() == Some(&'{') {
            chars.next();
            pos += 1;

            // Read what's inside
            let mut inner = String::new();
            while let Some(&ch) = chars.peek() {
                if ch == '}' {
                    break;
                }
                inner.push(ch);
                chars.next();
                pos += ch.len_utf8();
            }

            // Skip closing }}
            if chars.peek() == Some(&'}') {
                chars.next();
                pos += 1;
                if chars.peek() == Some(&'}') {
                    chars.next();
                    pos += 1;
                }
            }

            let inner_trimmed = inner.trim();

            if inner_trimmed.starts_with("#if ") {
                depth += 1;
                // Add to current content - inner already contains the #
                let tag = format!("{{{{{}}}}}", inner_trimmed);
                if in_else {
                    if current_else_if_flag.is_some() {
                        else_if_chains.last_mut().unwrap().1.push_str(&tag);
                    } else {
                        else_content.push_str(&tag);
                    }
                } else {
                    if_content.push_str(&tag);
                }
            } else if inner_trimmed == "/if" {
                depth -= 1;
                if depth == 0 {
                    consumed = pos;
                    break;
                } else {
                    let tag = "{{/if}}";
                    if in_else {
                        if current_else_if_flag.is_some() {
                            else_if_chains.last_mut().unwrap().1.push_str(tag);
                        } else {
                            else_content.push_str(tag);
                        }
                    } else {
                        if_content.push_str(tag);
                    }
                }
            } else if inner_trimmed == "else" && depth == 1 {
                in_else = true;
                current_else_if_flag = None;
            } else if inner_trimmed.starts_with("else if ") && depth == 1 {
                let else_if_flag = inner_trimmed
                    .strip_prefix("else if ")
                    .unwrap()
                    .trim()
                    .to_string();
                in_else = true;
                current_else_if_flag = Some(else_if_flag.clone());
                else_if_chains.push((else_if_flag, String::new()));
            } else {
                // Some other tag, add to current content
                let tag = format!("{{{{{}}}}}", inner);
                if in_else {
                    if current_else_if_flag.is_some() {
                        else_if_chains.last_mut().unwrap().1.push_str(&tag);
                    } else {
                        else_content.push_str(&tag);
                    }
                } else {
                    if_content.push_str(&tag);
                }
            }
        } else if in_else {
            if current_else_if_flag.is_some() {
                else_if_chains.last_mut().unwrap().1.push(c);
            } else {
                else_content.push(c);
            }
        } else {
            if_content.push(c);
        }
    }

    // Determine which content to use
    let result = if flag_value {
        // Process nested conditionals in if_content
        process_conditionals(&if_content, flags)
    } else {
        // Check else-if chains
        let mut found = false;
        let mut selected_content = String::new();

        for (chain_flag, chain_content) in &else_if_chains {
            if flags.get(chain_flag).copied().unwrap_or(false) {
                selected_content = process_conditionals(chain_content, flags);
                found = true;
                break;
            }
        }

        if !found {
            // Use else content
            process_conditionals(&else_content, flags)
        } else {
            selected_content
        }
    };

    (result, consumed)
}

// ============================================================================
// Interpreter Tool Constants and Error Helpers
// ============================================================================

/// Interpreter tools that require an external interpreter to execute
#[allow(dead_code)] // Infrastructure ready for use in executor.rs
pub const INTERPRETER_TOOLS: &[&str] = &["python", "ruby", "perl", "php", "node"];

/// Get the interpreter command for a given tool
///
/// # Arguments
/// * `tool` - The tool name (e.g., "python", "ruby")
///
/// # Returns
/// The interpreter command to use (e.g., "python3" for "python")
#[allow(dead_code)] // Infrastructure ready for use in executor.rs
pub fn get_interpreter_command(tool: &str) -> String {
    match tool {
        "python" => "python3".to_string(),
        "ruby" => "ruby".to_string(),
        "perl" => "perl".to_string(),
        "php" => "php".to_string(),
        "node" => "node".to_string(),
        _ => tool.to_string(),
    }
}

/// Get platform-specific installation instructions for an interpreter
///
/// # Arguments
/// * `interpreter` - The interpreter name (e.g., "python3", "ruby")
///
/// # Returns
/// A user-friendly error message with installation instructions
#[allow(dead_code)] // Infrastructure ready for use in executor.rs
pub fn interpreter_not_found_message(interpreter: &str) -> String {
    let tool_name = match interpreter {
        "python3" | "python" => "Python",
        "ruby" => "Ruby",
        "perl" => "Perl",
        "php" => "PHP",
        "node" | "nodejs" => "Node.js",
        _ => interpreter,
    };

    let install_instructions = get_platform_install_instructions(interpreter);

    format!(
        "{} interpreter not found.\n\n{}\n\nAfter installation, restart Script Kit.",
        tool_name, install_instructions
    )
}

/// Get platform-specific installation instructions
///
/// # Arguments
/// * `interpreter` - The interpreter name
///
/// # Returns
/// Platform-specific installation command suggestions
#[allow(dead_code)] // Used by interpreter_not_found_message
fn get_platform_install_instructions(interpreter: &str) -> String {
    #[cfg(target_os = "macos")]
    {
        get_macos_install_instructions(interpreter)
    }
    #[cfg(target_os = "linux")]
    {
        get_linux_install_instructions(interpreter)
    }
    #[cfg(target_os = "windows")]
    {
        get_windows_install_instructions(interpreter)
    }
    #[cfg(not(any(target_os = "macos", target_os = "linux", target_os = "windows")))]
    {
        format!(
            "Please install {} using your system's package manager.",
            interpreter
        )
    }
}

/// Get macOS installation instructions (Homebrew)
#[cfg(target_os = "macos")]
#[allow(dead_code)] // Used by get_platform_install_instructions
fn get_macos_install_instructions(interpreter: &str) -> String {
    let brew_package = match interpreter {
        "python3" | "python" => "python",
        "ruby" => "ruby",
        "perl" => "perl",
        "php" => "php",
        "node" | "nodejs" => "node",
        _ => interpreter,
    };

    format!(
        "Install using Homebrew:\n  brew install {}\n\nOr download from the official website.",
        brew_package
    )
}

/// Get Linux installation instructions (apt/dnf)
#[cfg(target_os = "linux")]
fn get_linux_install_instructions(interpreter: &str) -> String {
    let (apt_package, dnf_package) = match interpreter {
        "python3" | "python" => ("python3", "python3"),
        "ruby" => ("ruby", "ruby"),
        "perl" => ("perl", "perl"),
        "php" => ("php", "php-cli"),
        "node" | "nodejs" => ("nodejs", "nodejs"),
        _ => (interpreter, interpreter),
    };

    format!(
        "Install using your package manager:\n\n  Debian/Ubuntu:\n    sudo apt install {}\n\n  Fedora/RHEL:\n    sudo dnf install {}",
        apt_package, dnf_package
    )
}

/// Get Windows installation instructions
#[cfg(target_os = "windows")]
fn get_windows_install_instructions(interpreter: &str) -> String {
    let (choco_package, download_url) = match interpreter {
        "python3" | "python" => ("python", "https://www.python.org/downloads/"),
        "ruby" => ("ruby", "https://rubyinstaller.org/"),
        "perl" => ("strawberryperl", "https://strawberryperl.com/"),
        "php" => ("php", "https://windows.php.net/download/"),
        "node" | "nodejs" => ("nodejs", "https://nodejs.org/"),
        _ => (interpreter, ""),
    };

    if download_url.is_empty() {
        format!(
            "Install using Chocolatey:\n  choco install {}",
            choco_package
        )
    } else {
        format!(
            "Install using Chocolatey:\n  choco install {}\n\nOr download from:\n  {}",
            choco_package, download_url
        )
    }
}

/// Check if a tool is an interpreter tool
///
/// # Arguments
/// * `tool` - The tool name to check
///
/// # Returns
/// `true` if the tool requires an external interpreter
#[allow(dead_code)] // Infrastructure ready for use in executor.rs
pub fn is_interpreter_tool(tool: &str) -> bool {
    INTERPRETER_TOOLS.contains(&tool)
}

/// Get the file extension for a given interpreter tool
///
/// # Arguments
/// * `tool` - The tool name
///
/// # Returns
/// The appropriate file extension for scripts of that type
#[allow(dead_code)] // Infrastructure ready for use in executor.rs
pub fn get_interpreter_extension(tool: &str) -> &'static str {
    match tool {
        "python" => "py",
        "ruby" => "rb",
        "perl" => "pl",
        "php" => "php",
        "node" => "js",
        _ => "txt",
    }
}

/// Validate that a tool name is a known interpreter
///
/// # Arguments
/// * `tool` - The tool name to validate
///
/// # Returns
/// `Ok(())` if valid, `Err` with descriptive message if not
#[allow(dead_code)] // Infrastructure ready for use in executor.rs
pub fn validate_interpreter_tool(tool: &str) -> Result<(), String> {
    if is_interpreter_tool(tool) {
        Ok(())
    } else if VALID_TOOLS.contains(&tool) {
        Err(format!(
            "'{}' is a valid tool but not an interpreter tool",
            tool
        ))
    } else {
        Err(format!("'{}' is not a recognized tool type", tool))
    }
}

// ============================================================================
// Tests
// ============================================================================

#[cfg(test)]
#[path = "scriptlet_tests.rs"]
mod tests;

</file>

<file path="src/expand_matcher.rs">
//! Expand trigger matching module
//!
//! This module provides a trigger detection system that buffers typed characters
//! and matches against registered expand triggers. When a trigger keyword is
//! fully typed, a match is returned with information needed to perform the
//! text expansion.
//!

use std::collections::HashMap;
use std::path::PathBuf;
use tracing::debug;

/// Default maximum buffer size for typed characters
const DEFAULT_MAX_BUFFER_SIZE: usize = 50;

/// Characters that should clear the buffer when typed
const BUFFER_CLEAR_CHARS: &[char] = &[
    '\n',   // Enter/Return
    '\r',   // Carriage return
    '\x1b', // Escape
    '\t',   // Tab (optional, but common delimiter)
];

/// Result of a successful trigger match
#[derive(Debug, Clone, PartialEq, Eq)]
pub struct MatchResult {
    /// The trigger keyword that was matched (e.g., ":sig")
    pub trigger: String,
    /// Path to the scriptlet to execute
    pub scriptlet_path: PathBuf,
    /// Number of characters to delete (length of trigger)
    pub chars_to_delete: usize,
}

/// Trigger detection system for text expansion
///
/// Maintains a rolling buffer of typed characters and checks for matches
/// against registered triggers. Uses immediate matching - the trigger fires
/// as soon as the keyword is fully typed.
#[derive(Debug)]
pub struct ExpandMatcher {
    /// Map of trigger keywords to their scriptlet paths
    triggers: HashMap<String, PathBuf>,
    /// Rolling buffer of recent keystrokes
    buffer: String,
    /// Maximum size of the buffer
    max_buffer_size: usize,
}

impl Default for ExpandMatcher {
    fn default() -> Self {
        Self::new()
    }
}

impl ExpandMatcher {
    /// Create a new ExpandMatcher with default settings
    pub fn new() -> Self {
        Self {
            triggers: HashMap::new(),
            buffer: String::with_capacity(DEFAULT_MAX_BUFFER_SIZE),
            max_buffer_size: DEFAULT_MAX_BUFFER_SIZE,
        }
    }

    /// Create a new ExpandMatcher with a custom buffer size
    #[allow(dead_code)]
    pub fn with_buffer_size(max_size: usize) -> Self {
        Self {
            triggers: HashMap::new(),
            buffer: String::with_capacity(max_size),
            max_buffer_size: max_size,
        }
    }

    /// Register a trigger keyword with its associated scriptlet path
    ///
    /// If the trigger already exists, it will be replaced.
    ///
    /// # Arguments
    /// * `keyword` - The trigger text (e.g., ":sig", "!today", "/date")
    /// * `scriptlet_path` - Path to the scriptlet file to execute on match
    pub fn register_trigger(&mut self, keyword: &str, scriptlet_path: PathBuf) {
        if keyword.is_empty() {
            debug!("Attempted to register empty trigger, ignoring");
            return;
        }

        debug!(
            trigger = %keyword,
            path = %scriptlet_path.display(),
            "Registering expand trigger"
        );

        self.triggers.insert(keyword.to_string(), scriptlet_path);
    }

    /// Unregister a trigger keyword
    ///
    /// # Arguments
    /// * `keyword` - The trigger text to remove
    ///
    /// # Returns
    /// `true` if the trigger was removed, `false` if it didn't exist
    #[allow(dead_code)]
    pub fn unregister_trigger(&mut self, keyword: &str) -> bool {
        let removed = self.triggers.remove(keyword).is_some();

        if removed {
            debug!(trigger = %keyword, "Unregistered expand trigger");
        }

        removed
    }

    /// Process a keystroke and check for trigger matches
    ///
    /// # Arguments
    /// * `c` - The character that was typed
    ///
    /// # Returns
    /// `Some(MatchResult)` if a trigger was matched, `None` otherwise
    pub fn process_keystroke(&mut self, c: char) -> Option<MatchResult> {
        // Check for buffer-clearing characters
        if BUFFER_CLEAR_CHARS.contains(&c) {
            self.clear_buffer();
            return None;
        }

        // Add character to buffer
        self.buffer.push(c);

        // Trim buffer if it exceeds max size (remove from front)
        if self.buffer.len() > self.max_buffer_size {
            let excess = self.buffer.len() - self.max_buffer_size;
            self.buffer = self.buffer.chars().skip(excess).collect();
        }

        // Check for matches - look for triggers at the end of the buffer
        self.check_for_match()
    }

    /// Check if the buffer ends with any registered trigger
    fn check_for_match(&self) -> Option<MatchResult> {
        // Check each trigger to see if the buffer ends with it
        for (trigger, path) in &self.triggers {
            if self.buffer.ends_with(trigger) {
                debug!(
                    trigger = %trigger,
                    buffer = %self.buffer,
                    "Trigger matched"
                );

                return Some(MatchResult {
                    trigger: trigger.clone(),
                    scriptlet_path: path.clone(),
                    chars_to_delete: trigger.chars().count(),
                });
            }
        }

        None
    }

    /// Clear the keystroke buffer
    pub fn clear_buffer(&mut self) {
        self.buffer.clear();
        debug!("Buffer cleared");
    }

    /// Get the current buffer contents (for debugging)
    #[allow(dead_code)]
    pub fn buffer(&self) -> &str {
        &self.buffer
    }

    /// Get the number of registered triggers
    pub fn trigger_count(&self) -> usize {
        self.triggers.len()
    }

    /// Check if a specific trigger is registered
    #[allow(dead_code)]
    pub fn has_trigger(&self, keyword: &str) -> bool {
        self.triggers.contains_key(keyword)
    }

    /// Get all registered triggers
    #[allow(dead_code)]
    pub fn triggers(&self) -> impl Iterator<Item = (&String, &PathBuf)> {
        self.triggers.iter()
    }

    /// Clear all registered triggers
    #[allow(dead_code)]
    pub fn clear_triggers(&mut self) {
        self.triggers.clear();
        debug!("All triggers cleared");
    }

    /// Bulk register triggers from an iterator
    #[allow(dead_code)]
    pub fn register_triggers<I>(&mut self, triggers: I)
    where
        I: IntoIterator<Item = (String, PathBuf)>,
    {
        for (keyword, path) in triggers {
            self.register_trigger(&keyword, path);
        }
    }
}

// ============================================================================
// Tests
// ============================================================================

#[cfg(test)]
mod tests {
    use super::*;

    // ========================================
    // Construction Tests
    // ========================================

    #[test]
    fn test_new_creates_empty_matcher() {
        let matcher = ExpandMatcher::new();
        assert_eq!(matcher.trigger_count(), 0);
        assert!(matcher.buffer().is_empty());
    }

    #[test]
    fn test_default_creates_empty_matcher() {
        let matcher = ExpandMatcher::default();
        assert_eq!(matcher.trigger_count(), 0);
        assert!(matcher.buffer().is_empty());
    }

    #[test]
    fn test_with_buffer_size_sets_custom_size() {
        let matcher = ExpandMatcher::with_buffer_size(100);
        assert_eq!(matcher.max_buffer_size, 100);
    }

    // ========================================
    // Registration Tests
    // ========================================

    #[test]
    fn test_register_trigger_adds_trigger() {
        let mut matcher = ExpandMatcher::new();
        matcher.register_trigger(":sig", PathBuf::from("/test/sig.md"));

        assert_eq!(matcher.trigger_count(), 1);
        assert!(matcher.has_trigger(":sig"));
    }

    #[test]
    fn test_register_multiple_triggers() {
        let mut matcher = ExpandMatcher::new();
        matcher.register_trigger(":sig", PathBuf::from("/test/sig.md"));
        matcher.register_trigger("!today", PathBuf::from("/test/today.md"));
        matcher.register_trigger("/date", PathBuf::from("/test/date.md"));

        assert_eq!(matcher.trigger_count(), 3);
        assert!(matcher.has_trigger(":sig"));
        assert!(matcher.has_trigger("!today"));
        assert!(matcher.has_trigger("/date"));
    }

    #[test]
    fn test_register_empty_trigger_ignored() {
        let mut matcher = ExpandMatcher::new();
        matcher.register_trigger("", PathBuf::from("/test/empty.md"));

        assert_eq!(matcher.trigger_count(), 0);
    }

    #[test]
    fn test_register_trigger_replaces_existing() {
        let mut matcher = ExpandMatcher::new();
        matcher.register_trigger(":sig", PathBuf::from("/test/sig1.md"));
        matcher.register_trigger(":sig", PathBuf::from("/test/sig2.md"));

        assert_eq!(matcher.trigger_count(), 1);

        // Should use the new path
        for c in ":sig".chars() {
            matcher.process_keystroke(c);
        }
        // The last registration should be used
    }

    #[test]
    fn test_unregister_trigger_removes_trigger() {
        let mut matcher = ExpandMatcher::new();
        matcher.register_trigger(":sig", PathBuf::from("/test/sig.md"));

        assert!(matcher.unregister_trigger(":sig"));
        assert_eq!(matcher.trigger_count(), 0);
        assert!(!matcher.has_trigger(":sig"));
    }

    #[test]
    fn test_unregister_nonexistent_returns_false() {
        let mut matcher = ExpandMatcher::new();

        assert!(!matcher.unregister_trigger(":nonexistent"));
    }

    #[test]
    fn test_clear_triggers_removes_all() {
        let mut matcher = ExpandMatcher::new();
        matcher.register_trigger(":sig", PathBuf::from("/test/sig.md"));
        matcher.register_trigger("!today", PathBuf::from("/test/today.md"));

        matcher.clear_triggers();

        assert_eq!(matcher.trigger_count(), 0);
    }

    #[test]
    fn test_bulk_register_triggers() {
        let mut matcher = ExpandMatcher::new();
        let triggers = vec![
            (":sig".to_string(), PathBuf::from("/test/sig.md")),
            ("!today".to_string(), PathBuf::from("/test/today.md")),
        ];

        matcher.register_triggers(triggers);

        assert_eq!(matcher.trigger_count(), 2);
        assert!(matcher.has_trigger(":sig"));
        assert!(matcher.has_trigger("!today"));
    }

    // ========================================
    // Basic Matching Tests
    // ========================================

    #[test]
    fn test_process_keystroke_no_match_without_triggers() {
        let mut matcher = ExpandMatcher::new();

        for c in "hello".chars() {
            assert!(matcher.process_keystroke(c).is_none());
        }
    }

    #[test]
    fn test_process_keystroke_matches_simple_trigger() {
        let mut matcher = ExpandMatcher::new();
        matcher.register_trigger(":sig", PathBuf::from("/test/sig.md"));

        // Type ":sig"
        assert!(matcher.process_keystroke(':').is_none());
        assert!(matcher.process_keystroke('s').is_none());
        assert!(matcher.process_keystroke('i').is_none());

        let result = matcher.process_keystroke('g');
        assert!(result.is_some());

        let result = result.unwrap();
        assert_eq!(result.trigger, ":sig");
        assert_eq!(result.chars_to_delete, 4);
        assert_eq!(result.scriptlet_path, PathBuf::from("/test/sig.md"));
    }

    #[test]
    fn test_match_result_chars_to_delete_counts_chars_not_bytes() {
        let mut matcher = ExpandMatcher::new();
        // Unicode trigger
        matcher.register_trigger("ok", PathBuf::from("/test/ok.md"));

        for c in "ok".chars() {
            matcher.process_keystroke(c);
        }

        // Would have matched on 'k'
        matcher.clear_buffer();

        for c in "o".chars() {
            assert!(matcher.process_keystroke(c).is_none());
        }

        let result = matcher.process_keystroke('k');
        assert!(result.is_some());

        let result = result.unwrap();
        // "ok" is 3 chars (not 5 bytes)
        assert_eq!(result.chars_to_delete, 3);
    }

    #[test]
    fn test_match_fires_immediately_when_complete() {
        let mut matcher = ExpandMatcher::new();
        matcher.register_trigger(":sig", PathBuf::from("/test/sig.md"));

        // Type "Hello :sig" - match should fire right after 'g'
        for c in "Hello :si".chars() {
            assert!(matcher.process_keystroke(c).is_none());
        }

        let result = matcher.process_keystroke('g');
        assert!(result.is_some());
    }

    // ========================================
    // Buffer Behavior Tests
    // ========================================

    #[test]
    fn test_buffer_stores_keystrokes() {
        let mut matcher = ExpandMatcher::new();

        for c in "hello".chars() {
            matcher.process_keystroke(c);
        }

        assert_eq!(matcher.buffer(), "hello");
    }

    #[test]
    fn test_buffer_clears_on_enter() {
        let mut matcher = ExpandMatcher::new();

        for c in "hello".chars() {
            matcher.process_keystroke(c);
        }

        matcher.process_keystroke('\n');

        assert!(matcher.buffer().is_empty());
    }

    #[test]
    fn test_buffer_clears_on_carriage_return() {
        let mut matcher = ExpandMatcher::new();

        for c in "hello".chars() {
            matcher.process_keystroke(c);
        }

        matcher.process_keystroke('\r');

        assert!(matcher.buffer().is_empty());
    }

    #[test]
    fn test_buffer_clears_on_escape() {
        let mut matcher = ExpandMatcher::new();

        for c in "hello".chars() {
            matcher.process_keystroke(c);
        }

        matcher.process_keystroke('\x1b');

        assert!(matcher.buffer().is_empty());
    }

    #[test]
    fn test_buffer_clears_on_tab() {
        let mut matcher = ExpandMatcher::new();

        for c in "hello".chars() {
            matcher.process_keystroke(c);
        }

        matcher.process_keystroke('\t');

        assert!(matcher.buffer().is_empty());
    }

    #[test]
    fn test_buffer_does_not_clear_on_space() {
        let mut matcher = ExpandMatcher::new();

        for c in "hello world".chars() {
            matcher.process_keystroke(c);
        }

        assert_eq!(matcher.buffer(), "hello world");
    }

    #[test]
    fn test_buffer_trims_when_exceeds_max_size() {
        let mut matcher = ExpandMatcher::with_buffer_size(10);

        for c in "12345678901234567890".chars() {
            matcher.process_keystroke(c);
        }

        // Should only keep the last 10 characters
        assert_eq!(matcher.buffer().len(), 10);
        assert_eq!(matcher.buffer(), "1234567890");
    }

    #[test]
    fn test_clear_buffer_empties_buffer() {
        let mut matcher = ExpandMatcher::new();

        for c in "hello".chars() {
            matcher.process_keystroke(c);
        }

        matcher.clear_buffer();

        assert!(matcher.buffer().is_empty());
    }

    // ========================================
    // Trigger Prefix Tests
    // ========================================

    #[test]
    fn test_colon_prefix_trigger() {
        let mut matcher = ExpandMatcher::new();
        matcher.register_trigger(":sig", PathBuf::from("/test/sig.md"));

        for c in "hello :sig".chars() {
            if let Some(result) = matcher.process_keystroke(c) {
                assert_eq!(result.trigger, ":sig");
                return;
            }
        }
        panic!("Expected match for :sig");
    }

    #[test]
    fn test_exclamation_prefix_trigger() {
        let mut matcher = ExpandMatcher::new();
        matcher.register_trigger("!today", PathBuf::from("/test/today.md"));

        for c in "hello !today".chars() {
            if let Some(result) = matcher.process_keystroke(c) {
                assert_eq!(result.trigger, "!today");
                return;
            }
        }
        panic!("Expected match for !today");
    }

    #[test]
    fn test_slash_prefix_trigger() {
        let mut matcher = ExpandMatcher::new();
        matcher.register_trigger("/date", PathBuf::from("/test/date.md"));

        for c in "hello /date".chars() {
            if let Some(result) = matcher.process_keystroke(c) {
                assert_eq!(result.trigger, "/date");
                return;
            }
        }
        panic!("Expected match for /date");
    }

    #[test]
    fn test_double_comma_suffix_trigger() {
        let mut matcher = ExpandMatcher::new();
        matcher.register_trigger("sig,,", PathBuf::from("/test/sig.md"));

        for c in "hello sig,,".chars() {
            if let Some(result) = matcher.process_keystroke(c) {
                assert_eq!(result.trigger, "sig,,");
                assert_eq!(result.chars_to_delete, 5);
                return;
            }
        }
        panic!("Expected match for sig,,");
    }

    #[test]
    fn test_semicolon_suffix_trigger() {
        let mut matcher = ExpandMatcher::new();
        matcher.register_trigger("email;", PathBuf::from("/test/email.md"));

        for c in "email;".chars() {
            if let Some(result) = matcher.process_keystroke(c) {
                assert_eq!(result.trigger, "email;");
                return;
            }
        }
        panic!("Expected match for email;");
    }

    #[test]
    fn test_no_prefix_trigger() {
        let mut matcher = ExpandMatcher::new();
        matcher.register_trigger("btw", PathBuf::from("/test/btw.md"));

        // Should match "btw" even without prefix
        for c in "btw".chars() {
            if let Some(result) = matcher.process_keystroke(c) {
                assert_eq!(result.trigger, "btw");
                return;
            }
        }
        panic!("Expected match for btw");
    }

    // ========================================
    // Edge Cases and Complex Scenarios
    // ========================================

    #[test]
    fn test_partial_match_then_complete_different_trigger() {
        let mut matcher = ExpandMatcher::new();
        matcher.register_trigger(":sig", PathBuf::from("/test/sig.md"));
        matcher.register_trigger(":sign", PathBuf::from("/test/sign.md"));

        // Type ":sig" - should match first
        for c in ":sig".chars() {
            if let Some(result) = matcher.process_keystroke(c) {
                assert_eq!(result.trigger, ":sig");
                return;
            }
        }
        panic!("Expected match for :sig");
    }

    #[test]
    fn test_longer_trigger_preferred_when_both_match() {
        // Note: This test documents current behavior - first match wins
        // If we want longest match, implementation would need to change
        let mut matcher = ExpandMatcher::new();
        matcher.register_trigger(":sig", PathBuf::from("/test/sig.md"));
        matcher.register_trigger(":signature", PathBuf::from("/test/signature.md"));

        // Type ":sig" - matches immediately
        for c in ":sig".chars() {
            if let Some(result) = matcher.process_keystroke(c) {
                assert_eq!(result.trigger, ":sig");
                return;
            }
        }
        panic!("Expected match for :sig");
    }

    #[test]
    fn test_match_after_buffer_clear() {
        let mut matcher = ExpandMatcher::new();
        matcher.register_trigger(":sig", PathBuf::from("/test/sig.md"));

        // Type some text, then Enter (clears buffer), then trigger
        for c in "hello\n:sig".chars() {
            if let Some(result) = matcher.process_keystroke(c) {
                assert_eq!(result.trigger, ":sig");
                return;
            }
        }
        panic!("Expected match for :sig");
    }

    #[test]
    fn test_no_match_when_trigger_split_by_clear() {
        let mut matcher = ExpandMatcher::new();
        matcher.register_trigger(":sig", PathBuf::from("/test/sig.md"));

        // Type ":si", then Enter (clears buffer), then "g"
        for c in ":si".chars() {
            assert!(matcher.process_keystroke(c).is_none());
        }

        matcher.process_keystroke('\n'); // Clear buffer

        // "g" alone shouldn't match
        assert!(matcher.process_keystroke('g').is_none());
    }

    #[test]
    fn test_trigger_in_middle_of_sentence() {
        let mut matcher = ExpandMatcher::new();
        matcher.register_trigger(":sig", PathBuf::from("/test/sig.md"));

        // Type "Please sign here :sig thanks"
        for c in "Please sign here :sig".chars() {
            if let Some(result) = matcher.process_keystroke(c) {
                assert_eq!(result.trigger, ":sig");
                return;
            }
        }
        panic!("Expected match for :sig");
    }

    #[test]
    fn test_multiple_triggers_same_text() {
        let mut matcher = ExpandMatcher::new();
        matcher.register_trigger(":sig", PathBuf::from("/test/sig.md"));

        // Type ":sig" twice - should match twice
        let mut match_count = 0;

        for c in ":sig :sig".chars() {
            if matcher.process_keystroke(c).is_some() {
                match_count += 1;
            }
        }

        assert_eq!(match_count, 2);
    }

    #[test]
    fn test_trigger_with_numbers() {
        let mut matcher = ExpandMatcher::new();
        matcher.register_trigger(":addr1", PathBuf::from("/test/addr1.md"));

        for c in ":addr1".chars() {
            if let Some(result) = matcher.process_keystroke(c) {
                assert_eq!(result.trigger, ":addr1");
                return;
            }
        }
        panic!("Expected match for :addr1");
    }

    #[test]
    fn test_case_sensitive_triggers() {
        let mut matcher = ExpandMatcher::new();
        matcher.register_trigger(":Sig", PathBuf::from("/test/sig.md"));

        // Lowercase should NOT match
        for c in ":sig".chars() {
            assert!(matcher.process_keystroke(c).is_none());
        }

        matcher.clear_buffer();

        // Correct case should match
        for c in ":Si".chars() {
            assert!(matcher.process_keystroke(c).is_none());
        }

        let result = matcher.process_keystroke('g');
        assert!(result.is_some());
        assert_eq!(result.unwrap().trigger, ":Sig");
    }

    // ========================================
    // Iterator and Inspection Tests
    // ========================================

    #[test]
    fn test_triggers_iterator() {
        let mut matcher = ExpandMatcher::new();
        matcher.register_trigger(":sig", PathBuf::from("/test/sig.md"));
        matcher.register_trigger("!today", PathBuf::from("/test/today.md"));

        let triggers: Vec<_> = matcher.triggers().collect();

        assert_eq!(triggers.len(), 2);
    }

    #[test]
    fn test_has_trigger_returns_true_for_registered() {
        let mut matcher = ExpandMatcher::new();
        matcher.register_trigger(":sig", PathBuf::from("/test/sig.md"));

        assert!(matcher.has_trigger(":sig"));
        assert!(!matcher.has_trigger(":nonexistent"));
    }

    // ========================================
    // Integration-style Tests
    // ========================================

    #[test]
    fn test_realistic_usage_scenario() {
        let mut matcher = ExpandMatcher::new();

        // Register common text expansion triggers
        matcher.register_trigger(":sig", PathBuf::from("/scriptlets/signature.md"));
        matcher.register_trigger(":email", PathBuf::from("/scriptlets/email.md"));
        matcher.register_trigger("!date", PathBuf::from("/scriptlets/date.md"));
        matcher.register_trigger("addr,,", PathBuf::from("/scriptlets/address.md"));

        // Simulate typing an email
        let text = "Dear John,\n\nThank you for your :email regarding the project.\n\nHere is my address: addr,,\n\nBest regards,\n:sig";

        let mut matches = Vec::new();

        for c in text.chars() {
            if let Some(result) = matcher.process_keystroke(c) {
                matches.push(result.trigger.clone());
            }
        }

        // Should have matched :email, addr,,, and :sig
        // Note: \n clears buffer, so triggers after newlines still work
        assert!(matches.contains(&":email".to_string()));
        assert!(matches.contains(&"addr,,".to_string()));
        assert!(matches.contains(&":sig".to_string()));
    }

    #[test]
    fn test_buffer_wrapping_preserves_recent_context() {
        let mut matcher = ExpandMatcher::with_buffer_size(20);
        matcher.register_trigger(":sig", PathBuf::from("/test/sig.md"));

        // Type a lot of text to cause buffer trimming
        let long_text = "This is a very long sentence that will definitely exceed the buffer size ";
        for c in long_text.chars() {
            assert!(matcher.process_keystroke(c).is_none());
        }

        // Now type the trigger - should still match because buffer keeps recent chars
        for c in ":sig".chars() {
            if let Some(result) = matcher.process_keystroke(c) {
                assert_eq!(result.trigger, ":sig");
                return;
            }
        }
        panic!("Expected match for :sig after buffer wrap");
    }
}

</file>

<file path="src/expand_manager.rs">
//! Expand Manager - Text expansion system integration
//!
//! This module ties together all the components of the text expansion system:
//! - KeyboardMonitor: Global keystroke capture
//! - ExpandMatcher: Trigger detection with rolling buffer
//! - TextInjector: Backspace deletion + clipboard paste
//! - Scriptlets: Source of expand triggers and replacement text
//!
//! # Architecture
//!
//! The ExpandManager:
//! 1. Loads scriptlets with `expand` metadata from ~/.scriptkit/scriptlets/
//! 2. Registers each expand trigger with the ExpandMatcher
//! 3. Starts the KeyboardMonitor with a callback that feeds keystrokes to the matcher
//! 4. When a match is found, performs the expansion:
//!    a. Stops keyboard monitor (avoid capturing our own keystrokes)
//!    b. Deletes trigger characters with backspaces
//!    c. Pastes replacement text via clipboard
//!    d. Resumes keyboard monitor
//!

use std::collections::{HashMap, HashSet};
use std::path::{Path, PathBuf};
use std::sync::{Arc, Mutex};
use std::thread;
use std::time::Duration;

use anyhow::Result;
use tracing::{debug, error, info, instrument, warn};

// Import from crate (these are declared in main.rs)
use crate::expand_matcher::ExpandMatcher;
use crate::keyboard_monitor::{KeyEvent, KeyboardMonitor, KeyboardMonitorError};
use crate::scripts::read_scriptlets;
use crate::template_variables::substitute_variables;
use crate::text_injector::{TextInjector, TextInjectorConfig};

/// Delay after stopping monitor before performing expansion (ms)
const STOP_DELAY_MS: u64 = 50;

/// Delay after expansion before restarting monitor (ms)
const RESTART_DELAY_MS: u64 = 100;

/// Configuration for the expand manager
#[derive(Debug, Clone)]
pub struct ExpandManagerConfig {
    /// Configuration for text injection timing
    pub injector_config: TextInjectorConfig,
    /// Delay after stopping monitor before expansion (ms)
    pub stop_delay_ms: u64,
    /// Delay after expansion before restarting monitor (ms)
    #[allow(dead_code)]
    pub restart_delay_ms: u64,
}

impl Default for ExpandManagerConfig {
    fn default() -> Self {
        Self {
            injector_config: TextInjectorConfig::default(),
            stop_delay_ms: STOP_DELAY_MS,
            restart_delay_ms: RESTART_DELAY_MS,
        }
    }
}

/// Stored scriptlet information for expansion
#[derive(Debug, Clone)]
#[allow(dead_code)]
struct ExpandScriptlet {
    /// The trigger keyword (e.g., ":sig")
    trigger: String,
    /// The scriptlet name
    name: String,
    /// The replacement text (scriptlet body)
    content: String,
    /// Tool type (for future use - execute vs paste)
    tool: String,
    /// Source file path (for debugging)
    source_path: Option<String>,
}

/// Manages the text expansion system
///
/// Coordinates keyboard monitoring, trigger detection, and text injection
/// to provide system-wide text expansion functionality.
pub struct ExpandManager {
    /// Configuration
    config: ExpandManagerConfig,
    /// Registered scriptlets by trigger keyword
    scriptlets: Arc<Mutex<HashMap<String, ExpandScriptlet>>>,
    /// The expand matcher for trigger detection
    matcher: Arc<Mutex<ExpandMatcher>>,
    /// Reverse lookup: file path -> set of triggers from that file
    /// Used for efficient clearing/updating of triggers when a file changes
    file_triggers: Arc<Mutex<HashMap<PathBuf, HashSet<String>>>>,
    /// The keyboard monitor (optional - created on enable)
    monitor: Option<KeyboardMonitor>,
    /// The text injector (reserved for future direct use)
    #[allow(dead_code)]
    injector: TextInjector,
    /// Whether the expand system is enabled
    enabled: bool,
}

impl ExpandManager {
    /// Create a new ExpandManager with default configuration
    pub fn new() -> Self {
        Self::with_config(ExpandManagerConfig::default())
    }

    /// Create a new ExpandManager with custom configuration
    pub fn with_config(config: ExpandManagerConfig) -> Self {
        let injector = TextInjector::with_config(config.injector_config.clone());

        Self {
            config,
            scriptlets: Arc::new(Mutex::new(HashMap::new())),
            matcher: Arc::new(Mutex::new(ExpandMatcher::new())),
            file_triggers: Arc::new(Mutex::new(HashMap::new())),
            monitor: None,
            injector,
            enabled: false,
        }
    }

    /// Load scriptlets with expand metadata from ~/.scriptkit/scriptlets/
    ///
    /// This scans all markdown files and registers any scriptlet that has
    /// an `expand` metadata field as a trigger.
    #[instrument(skip(self))]
    pub fn load_scriptlets(&mut self) -> Result<usize> {
        info!("Loading scriptlets with expand triggers");

        let scriptlets = read_scriptlets();
        let mut loaded_count = 0;

        for scriptlet in scriptlets {
            // Only process scriptlets with expand metadata
            if let Some(ref expand_trigger) = scriptlet.expand {
                if expand_trigger.is_empty() {
                    debug!(
                        name = %scriptlet.name,
                        "Skipping scriptlet with empty expand trigger"
                    );
                    continue;
                }

                info!(
                    trigger = %expand_trigger,
                    name = %scriptlet.name,
                    tool = %scriptlet.tool,
                    "Registering expand trigger"
                );

                // Store the scriptlet info
                let expand_scriptlet = ExpandScriptlet {
                    trigger: expand_trigger.clone(),
                    name: scriptlet.name.clone(),
                    content: scriptlet.code.clone(),
                    tool: scriptlet.tool.clone(),
                    source_path: scriptlet.file_path.clone(),
                };

                // Register with matcher and scriptlets store
                {
                    let mut scriptlets_guard = self.scriptlets.lock().unwrap();
                    scriptlets_guard.insert(expand_trigger.clone(), expand_scriptlet);
                }

                {
                    let mut matcher_guard = self.matcher.lock().unwrap();
                    // Use a dummy path since we store scriptlet data separately
                    let dummy_path = PathBuf::from(format!("scriptlet:{}", scriptlet.name));
                    matcher_guard.register_trigger(expand_trigger, dummy_path);
                }

                // Track which file this trigger came from for incremental updates
                if let Some(ref file_path) = scriptlet.file_path {
                    let path = PathBuf::from(file_path);
                    let mut file_triggers_guard = self.file_triggers.lock().unwrap();
                    file_triggers_guard
                        .entry(path)
                        .or_default()
                        .insert(expand_trigger.clone());
                }

                loaded_count += 1;
            }
        }

        info!(
            count = loaded_count,
            "Loaded expand triggers from scriptlets"
        );
        Ok(loaded_count)
    }

    /// Register a single expand trigger manually
    ///
    /// This is useful for adding triggers that don't come from scriptlets.
    #[allow(dead_code)]
    pub fn register_trigger(&mut self, trigger: &str, name: &str, content: &str, tool: &str) {
        if trigger.is_empty() {
            debug!("Attempted to register empty trigger, ignoring");
            return;
        }

        info!(
            trigger = %trigger,
            name = %name,
            "Manually registering expand trigger"
        );

        let expand_scriptlet = ExpandScriptlet {
            trigger: trigger.to_string(),
            name: name.to_string(),
            content: content.to_string(),
            tool: tool.to_string(),
            source_path: None,
        };

        {
            let mut scriptlets_guard = self.scriptlets.lock().unwrap();
            scriptlets_guard.insert(trigger.to_string(), expand_scriptlet);
        }

        {
            let mut matcher_guard = self.matcher.lock().unwrap();
            let dummy_path = PathBuf::from(format!("manual:{}", name));
            matcher_guard.register_trigger(trigger, dummy_path);
        }
    }

    /// Enable the expand system (start keyboard monitoring)
    ///
    /// # Errors
    /// - `AccessibilityNotGranted`: Accessibility permissions not enabled
    /// - `EventTapCreationFailed`: Failed to create macOS event tap
    #[instrument(skip(self))]
    pub fn enable(&mut self) -> Result<(), KeyboardMonitorError> {
        if self.enabled {
            debug!("Expand system already enabled");
            return Ok(());
        }

        info!("Enabling expand system");

        // Check trigger count
        let trigger_count = {
            let matcher_guard = self.matcher.lock().unwrap();
            matcher_guard.trigger_count()
        };

        if trigger_count == 0 {
            warn!("No expand triggers registered, keyboard monitoring will be ineffective");
        }

        // Clone Arc references for the closure
        let matcher = Arc::clone(&self.matcher);
        let scriptlets = Arc::clone(&self.scriptlets);
        let config = self.config.clone();
        let injector_config = self.config.injector_config.clone();

        // Create keyboard monitor with callback
        let mut monitor = KeyboardMonitor::new(move |event: KeyEvent| {
            // Log every keystroke for debugging
            debug!(
                character = ?event.character,
                key_code = event.key_code,
                command = event.command,
                control = event.control,
                option = event.option,
                "Keyboard event received"
            );

            // Only process printable characters (ignore modifier keys, etc.)
            if let Some(ref character) = event.character {
                // Skip if any modifier is held (except shift for capitals)
                if event.command || event.control || event.option {
                    debug!(character = %character, "Skipping due to modifier key");
                    return;
                }

                // Process each character in the string (usually just 1)
                for c in character.chars() {
                    debug!(char = ?c, "Processing character");
                    // Feed to matcher
                    let match_result = {
                        let mut matcher_guard = matcher.lock().unwrap();
                        matcher_guard.process_keystroke(c)
                    };

                    // Handle match if found
                    if let Some(result) = match_result {
                        debug!(
                            trigger = %result.trigger,
                            chars_to_delete = result.chars_to_delete,
                            "Trigger matched, performing expansion"
                        );

                        // Get the scriptlet content
                        let scriptlet_opt = {
                            let scriptlets_guard = scriptlets.lock().unwrap();
                            scriptlets_guard.get(&result.trigger).cloned()
                        };

                        if let Some(scriptlet) = scriptlet_opt {
                            // Perform expansion in a separate thread to not block the callback
                            let chars_to_delete = result.chars_to_delete;
                            let content = scriptlet.content.clone();
                            let tool = scriptlet.tool.clone();
                            let name = scriptlet.name.clone();
                            let config_clone = config.clone();
                            let injector_config_clone = injector_config.clone();

                            thread::spawn(move || {
                                // Small delay to let the keyboard event complete
                                thread::sleep(Duration::from_millis(config_clone.stop_delay_ms));

                                // Get raw content based on tool type
                                let raw_content = match tool.as_str() {
                                    "paste" | "type" | "template" => content.clone(),
                                    _ => {
                                        // For other tools, use the content as-is for now
                                        // Future: execute the scriptlet and capture output
                                        info!(
                                            tool = %tool,
                                            name = %name,
                                            "Tool type not yet fully supported for expand, using raw content"
                                        );
                                        content.clone()
                                    }
                                };

                                // Substitute template variables (${clipboard}, ${date}, etc.)
                                // Uses the centralized template_variables module
                                let replacement = substitute_variables(&raw_content);

                                debug!(
                                    original_len = raw_content.len(),
                                    substituted_len = replacement.len(),
                                    had_substitutions = raw_content != replacement,
                                    "Variable substitution completed"
                                );

                                // Create injector and perform expansion
                                let injector = TextInjector::with_config(injector_config_clone);

                                // Delete trigger characters
                                if let Err(e) = injector.delete_chars(chars_to_delete) {
                                    error!(
                                        error = %e,
                                        chars = chars_to_delete,
                                        "Failed to delete trigger characters"
                                    );
                                    return;
                                }

                                // Small delay between delete and paste
                                thread::sleep(Duration::from_millis(50));

                                // Paste replacement text
                                if let Err(e) = injector.paste_text(&replacement) {
                                    error!(
                                        error = %e,
                                        "Failed to paste replacement text"
                                    );
                                    return;
                                }

                                info!(
                                    trigger = %name,
                                    replacement_len = replacement.len(),
                                    "Expansion completed successfully"
                                );
                            });

                            // Clear the buffer after a match to prevent re-triggering
                            let mut matcher_guard = matcher.lock().unwrap();
                            matcher_guard.clear_buffer();
                        } else {
                            warn!(
                                trigger = %result.trigger,
                                "Matched trigger but scriptlet not found in store"
                            );
                        }
                    }
                }
            }
        });

        // Start the monitor
        monitor.start()?;

        self.monitor = Some(monitor);
        self.enabled = true;

        info!("Expand system enabled, keyboard monitoring active");
        Ok(())
    }

    /// Disable the expand system (stop keyboard monitoring)
    #[instrument(skip(self))]
    pub fn disable(&mut self) {
        if !self.enabled {
            debug!("Expand system already disabled");
            return;
        }

        info!("Disabling expand system");

        if let Some(ref mut monitor) = self.monitor {
            monitor.stop();
        }
        self.monitor = None;
        self.enabled = false;

        info!("Expand system disabled");
    }

    /// Check if the expand system is currently enabled
    #[allow(dead_code)]
    pub fn is_enabled(&self) -> bool {
        self.enabled
    }

    /// Get the number of registered triggers
    #[allow(dead_code)]
    pub fn trigger_count(&self) -> usize {
        let matcher_guard = self.matcher.lock().unwrap();
        matcher_guard.trigger_count()
    }

    /// Check if accessibility permissions are granted
    ///
    /// Returns true if the application has accessibility permissions.
    /// These are required for keyboard monitoring and text injection.
    pub fn has_accessibility_permission() -> bool {
        KeyboardMonitor::has_accessibility_permission()
    }

    /// Request accessibility permissions, showing the system dialog if needed
    ///
    /// Returns true if permissions are granted (either already or after user action).
    #[allow(dead_code)]
    pub fn request_accessibility_permission() -> bool {
        KeyboardMonitor::request_accessibility_permission()
    }

    /// Clear all registered triggers
    #[allow(dead_code)]
    pub fn clear_triggers(&mut self) {
        {
            let mut scriptlets_guard = self.scriptlets.lock().unwrap();
            scriptlets_guard.clear();
        }
        {
            let mut matcher_guard = self.matcher.lock().unwrap();
            matcher_guard.clear_triggers();
        }
        {
            let mut file_triggers_guard = self.file_triggers.lock().unwrap();
            file_triggers_guard.clear();
        }

        debug!("All expand triggers cleared");
    }

    /// Reload scriptlets (clear existing and load fresh)
    #[allow(dead_code)]
    #[instrument(skip(self))]
    pub fn reload(&mut self) -> Result<usize> {
        info!("Reloading expand scriptlets");

        self.clear_triggers();
        self.load_scriptlets()
    }

    /// Get list of all registered triggers (for debugging/UI)
    pub fn list_triggers(&self) -> Vec<(String, String)> {
        let scriptlets_guard = self.scriptlets.lock().unwrap();
        scriptlets_guard
            .iter()
            .map(|(trigger, scriptlet)| (trigger.clone(), scriptlet.name.clone()))
            .collect()
    }

    /// Unregister a single trigger by its keyword
    ///
    /// This removes the trigger from the matcher and the scriptlets store.
    ///
    /// # Arguments
    /// * `trigger` - The trigger keyword to remove (e.g., ":sig")
    ///
    /// # Returns
    /// `true` if the trigger was removed, `false` if it didn't exist
    #[allow(dead_code)]
    pub fn unregister_trigger(&mut self, trigger: &str) -> bool {
        let scriptlet_removed = {
            let mut scriptlets_guard = self.scriptlets.lock().unwrap();
            scriptlets_guard.remove(trigger).is_some()
        };

        let matcher_removed = {
            let mut matcher_guard = self.matcher.lock().unwrap();
            matcher_guard.unregister_trigger(trigger)
        };

        // Also remove from file_triggers tracking
        {
            let mut file_triggers_guard = self.file_triggers.lock().unwrap();
            for triggers_set in file_triggers_guard.values_mut() {
                triggers_set.remove(trigger);
            }
            // Clean up empty entries
            file_triggers_guard.retain(|_, triggers| !triggers.is_empty());
        }

        if scriptlet_removed || matcher_removed {
            debug!(trigger = %trigger, "Unregistered expand trigger");
            true
        } else {
            false
        }
    }

    /// Clear all triggers that came from a specific file
    ///
    /// This is useful when a scriptlet file is deleted - all triggers
    /// registered from that file should be removed.
    ///
    /// # Arguments
    /// * `path` - The path to the scriptlet file
    ///
    /// # Returns
    /// The number of triggers that were removed
    #[allow(dead_code)]
    pub fn clear_triggers_for_file(&mut self, path: &Path) -> usize {
        // Get the triggers registered from this file
        let triggers_to_remove: Vec<String> = {
            let file_triggers_guard = self.file_triggers.lock().unwrap();
            file_triggers_guard
                .get(path)
                .map(|set| set.iter().cloned().collect())
                .unwrap_or_default()
        };

        if triggers_to_remove.is_empty() {
            debug!(path = %path.display(), "No triggers to clear for file");
            return 0;
        }

        let count = triggers_to_remove.len();

        // Remove each trigger
        for trigger in &triggers_to_remove {
            {
                let mut scriptlets_guard = self.scriptlets.lock().unwrap();
                scriptlets_guard.remove(trigger);
            }
            {
                let mut matcher_guard = self.matcher.lock().unwrap();
                matcher_guard.unregister_trigger(trigger);
            }
        }

        // Remove the file entry from tracking
        {
            let mut file_triggers_guard = self.file_triggers.lock().unwrap();
            file_triggers_guard.remove(path);
        }

        info!(
            path = %path.display(),
            count = count,
            "Cleared triggers for file"
        );

        count
    }

    /// Get triggers registered for a specific file (for debugging/testing)
    #[allow(dead_code)]
    pub fn get_triggers_for_file(&self, path: &Path) -> Vec<String> {
        let file_triggers_guard = self.file_triggers.lock().unwrap();
        file_triggers_guard
            .get(path)
            .map(|set| set.iter().cloned().collect())
            .unwrap_or_default()
    }

    /// Register a trigger from a specific file
    ///
    /// This is like `register_trigger` but also tracks the source file
    /// for incremental updates.
    ///
    /// # Arguments
    /// * `trigger` - The trigger keyword (e.g., ":sig")
    /// * `name` - The scriptlet name
    /// * `content` - The replacement text
    /// * `tool` - The tool type (e.g., "paste", "type")
    /// * `source_path` - The file this trigger came from
    #[allow(dead_code)]
    pub fn register_trigger_from_file(
        &mut self,
        trigger: &str,
        name: &str,
        content: &str,
        tool: &str,
        source_path: &Path,
    ) {
        if trigger.is_empty() {
            debug!("Attempted to register empty trigger, ignoring");
            return;
        }

        info!(
            trigger = %trigger,
            name = %name,
            source = %source_path.display(),
            "Registering expand trigger from file"
        );

        let expand_scriptlet = ExpandScriptlet {
            trigger: trigger.to_string(),
            name: name.to_string(),
            content: content.to_string(),
            tool: tool.to_string(),
            source_path: Some(source_path.to_string_lossy().into_owned()),
        };

        {
            let mut scriptlets_guard = self.scriptlets.lock().unwrap();
            scriptlets_guard.insert(trigger.to_string(), expand_scriptlet);
        }

        {
            let mut matcher_guard = self.matcher.lock().unwrap();
            let dummy_path = PathBuf::from(format!("manual:{}", name));
            matcher_guard.register_trigger(trigger, dummy_path);
        }

        // Track the file -> trigger mapping
        {
            let mut file_triggers_guard = self.file_triggers.lock().unwrap();
            file_triggers_guard
                .entry(source_path.to_path_buf())
                .or_default()
                .insert(trigger.to_string());
        }
    }

    /// Update triggers for a file with new scriptlet data
    ///
    /// This performs a diff between the existing triggers and the new triggers:
    /// - Triggers that no longer exist are removed
    /// - New triggers are added
    /// - Triggers with changed content are updated
    ///
    /// # Arguments
    /// * `path` - The path to the scriptlet file
    /// * `new_triggers` - The new trigger definitions: (trigger, name, content, tool)
    ///
    /// # Returns
    /// A tuple of (added_count, removed_count, updated_count)
    #[allow(dead_code)]
    pub fn update_triggers_for_file(
        &mut self,
        path: &Path,
        new_triggers: &[(String, String, String, String)],
    ) -> (usize, usize, usize) {
        // Get existing triggers for this file
        let existing_triggers: HashSet<String> = {
            let file_triggers_guard = self.file_triggers.lock().unwrap();
            file_triggers_guard.get(path).cloned().unwrap_or_default()
        };

        // Build set of new trigger keywords
        let new_trigger_keys: HashSet<String> =
            new_triggers.iter().map(|(t, _, _, _)| t.clone()).collect();

        // Find triggers to remove (exist in old but not in new)
        let to_remove: Vec<String> = existing_triggers
            .difference(&new_trigger_keys)
            .cloned()
            .collect();

        // Find triggers to add (exist in new but not in old)
        let to_add: Vec<_> = new_triggers
            .iter()
            .filter(|(t, _, _, _)| !existing_triggers.contains(t))
            .collect();

        // Find triggers to update (exist in both, check if content changed)
        let mut updated_count = 0;
        for (trigger, name, content, tool) in new_triggers {
            if existing_triggers.contains(trigger) {
                // Check if content changed
                let content_changed = {
                    let scriptlets_guard = self.scriptlets.lock().unwrap();
                    if let Some(existing) = scriptlets_guard.get(trigger) {
                        existing.content != *content
                            || existing.name != *name
                            || existing.tool != *tool
                    } else {
                        true // Treat as changed if not found
                    }
                };

                if content_changed {
                    // Update the scriptlet
                    let expand_scriptlet = ExpandScriptlet {
                        trigger: trigger.clone(),
                        name: name.clone(),
                        content: content.clone(),
                        tool: tool.clone(),
                        source_path: Some(path.to_string_lossy().into_owned()),
                    };

                    {
                        let mut scriptlets_guard = self.scriptlets.lock().unwrap();
                        scriptlets_guard.insert(trigger.clone(), expand_scriptlet);
                    }

                    debug!(
                        trigger = %trigger,
                        path = %path.display(),
                        "Updated trigger content"
                    );
                    updated_count += 1;
                }
            }
        }

        // Remove old triggers
        for trigger in &to_remove {
            {
                let mut scriptlets_guard = self.scriptlets.lock().unwrap();
                scriptlets_guard.remove(trigger);
            }
            {
                let mut matcher_guard = self.matcher.lock().unwrap();
                matcher_guard.unregister_trigger(trigger);
            }
            debug!(trigger = %trigger, path = %path.display(), "Removed trigger");
        }

        // Add new triggers
        for (trigger, name, content, tool) in &to_add {
            let expand_scriptlet = ExpandScriptlet {
                trigger: trigger.clone(),
                name: name.clone(),
                content: content.clone(),
                tool: tool.clone(),
                source_path: Some(path.to_string_lossy().into_owned()),
            };

            {
                let mut scriptlets_guard = self.scriptlets.lock().unwrap();
                scriptlets_guard.insert(trigger.clone(), expand_scriptlet);
            }

            {
                let mut matcher_guard = self.matcher.lock().unwrap();
                let dummy_path = PathBuf::from(format!("scriptlet:{}", name));
                matcher_guard.register_trigger(trigger, dummy_path);
            }

            debug!(trigger = %trigger, path = %path.display(), "Added trigger");
        }

        // Update file_triggers tracking
        {
            let mut file_triggers_guard = self.file_triggers.lock().unwrap();
            if new_trigger_keys.is_empty() {
                file_triggers_guard.remove(path);
            } else {
                file_triggers_guard.insert(path.to_path_buf(), new_trigger_keys);
            }
        }

        let added_count = to_add.len();
        let removed_count = to_remove.len();

        info!(
            path = %path.display(),
            added = added_count,
            removed = removed_count,
            updated = updated_count,
            "Updated triggers for file"
        );

        (added_count, removed_count, updated_count)
    }
}

impl Default for ExpandManager {
    fn default() -> Self {
        Self::new()
    }
}

impl Drop for ExpandManager {
    fn drop(&mut self) {
        self.disable();
    }
}

// ============================================================================
// Tests
// ============================================================================

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_new_creates_disabled_manager() {
        let manager = ExpandManager::new();
        assert!(!manager.is_enabled());
        assert_eq!(manager.trigger_count(), 0);
    }

    #[test]
    fn test_default_creates_disabled_manager() {
        let manager = ExpandManager::default();
        assert!(!manager.is_enabled());
        assert_eq!(manager.trigger_count(), 0);
    }

    #[test]
    fn test_custom_config() {
        let config = ExpandManagerConfig {
            stop_delay_ms: 100,
            restart_delay_ms: 200,
            ..Default::default()
        };
        let manager = ExpandManager::with_config(config.clone());
        assert_eq!(manager.config.stop_delay_ms, 100);
        assert_eq!(manager.config.restart_delay_ms, 200);
    }

    #[test]
    fn test_register_trigger_manually() {
        let mut manager = ExpandManager::new();

        manager.register_trigger(":test", "Test Snippet", "Hello, World!", "paste");

        assert_eq!(manager.trigger_count(), 1);

        let triggers = manager.list_triggers();
        assert_eq!(triggers.len(), 1);
        assert_eq!(triggers[0].0, ":test");
        assert_eq!(triggers[0].1, "Test Snippet");
    }

    #[test]
    fn test_register_empty_trigger_ignored() {
        let mut manager = ExpandManager::new();

        manager.register_trigger("", "Empty", "Content", "paste");

        assert_eq!(manager.trigger_count(), 0);
    }

    #[test]
    fn test_clear_triggers() {
        let mut manager = ExpandManager::new();

        manager.register_trigger(":a", "A", "Content A", "paste");
        manager.register_trigger(":b", "B", "Content B", "paste");

        assert_eq!(manager.trigger_count(), 2);

        manager.clear_triggers();

        assert_eq!(manager.trigger_count(), 0);
    }

    #[test]
    fn test_list_triggers() {
        let mut manager = ExpandManager::new();

        manager.register_trigger(":sig", "Signature", "Best regards", "paste");
        manager.register_trigger(":addr", "Address", "123 Main St", "type");

        let triggers = manager.list_triggers();
        assert_eq!(triggers.len(), 2);

        // Check both triggers exist (order not guaranteed due to HashMap)
        let trigger_names: Vec<_> = triggers.iter().map(|(t, _)| t.as_str()).collect();
        assert!(trigger_names.contains(&":sig"));
        assert!(trigger_names.contains(&":addr"));
    }

    #[test]
    fn test_accessibility_check_does_not_panic() {
        // Just verify it doesn't panic - actual result depends on system
        let _ = ExpandManager::has_accessibility_permission();
    }

    // ========================================
    // Unregister Trigger Tests
    // ========================================

    #[test]
    fn test_unregister_trigger() {
        let mut manager = ExpandManager::new();

        manager.register_trigger(":test", "Test Snippet", "Hello, World!", "paste");
        assert_eq!(manager.trigger_count(), 1);

        // Unregister the trigger
        let removed = manager.unregister_trigger(":test");
        assert!(removed);
        assert_eq!(manager.trigger_count(), 0);

        // Verify it's not in the list
        let triggers = manager.list_triggers();
        assert!(triggers.is_empty());
    }

    #[test]
    fn test_unregister_nonexistent_trigger() {
        let mut manager = ExpandManager::new();

        let removed = manager.unregister_trigger(":nonexistent");
        assert!(!removed);
    }

    #[test]
    fn test_unregister_one_of_multiple_triggers() {
        let mut manager = ExpandManager::new();

        manager.register_trigger(":a", "A", "Content A", "paste");
        manager.register_trigger(":b", "B", "Content B", "paste");
        manager.register_trigger(":c", "C", "Content C", "paste");

        assert_eq!(manager.trigger_count(), 3);

        // Unregister just one
        let removed = manager.unregister_trigger(":b");
        assert!(removed);
        assert_eq!(manager.trigger_count(), 2);

        // Verify the right ones remain
        let triggers = manager.list_triggers();
        let trigger_names: Vec<_> = triggers.iter().map(|(t, _)| t.as_str()).collect();
        assert!(trigger_names.contains(&":a"));
        assert!(!trigger_names.contains(&":b"));
        assert!(trigger_names.contains(&":c"));
    }

    // ========================================
    // Clear Triggers For File Tests
    // ========================================

    #[test]
    fn test_clear_triggers_for_file() {
        let mut manager = ExpandManager::new();
        let path = PathBuf::from("/test/scriptlets/test.md");

        // Register triggers from a file
        manager.register_trigger_from_file(":sig", "Signature", "Best regards", "paste", &path);
        manager.register_trigger_from_file(":addr", "Address", "123 Main St", "paste", &path);

        assert_eq!(manager.trigger_count(), 2);
        assert_eq!(manager.get_triggers_for_file(&path).len(), 2);

        // Clear triggers for the file
        let cleared = manager.clear_triggers_for_file(&path);
        assert_eq!(cleared, 2);
        assert_eq!(manager.trigger_count(), 0);
        assert!(manager.get_triggers_for_file(&path).is_empty());
    }

    #[test]
    fn test_clear_triggers_for_file_only_affects_that_file() {
        let mut manager = ExpandManager::new();
        let path1 = PathBuf::from("/test/file1.md");
        let path2 = PathBuf::from("/test/file2.md");

        // Register triggers from two different files
        manager.register_trigger_from_file(":a", "A", "Content A", "paste", &path1);
        manager.register_trigger_from_file(":b", "B", "Content B", "paste", &path1);
        manager.register_trigger_from_file(":c", "C", "Content C", "paste", &path2);

        assert_eq!(manager.trigger_count(), 3);

        // Clear triggers for file1 only
        let cleared = manager.clear_triggers_for_file(&path1);
        assert_eq!(cleared, 2);
        assert_eq!(manager.trigger_count(), 1);

        // Verify file2's trigger is still there
        let triggers = manager.list_triggers();
        assert_eq!(triggers.len(), 1);
        assert_eq!(triggers[0].0, ":c");
    }

    #[test]
    fn test_clear_triggers_for_nonexistent_file() {
        let mut manager = ExpandManager::new();
        let path = PathBuf::from("/test/nonexistent.md");

        let cleared = manager.clear_triggers_for_file(&path);
        assert_eq!(cleared, 0);
    }

    // ========================================
    // Update Triggers For File Tests
    // ========================================

    #[test]
    fn test_update_triggers_add_new() {
        let mut manager = ExpandManager::new();
        let path = PathBuf::from("/test/file.md");

        // Start with no triggers
        assert_eq!(manager.trigger_count(), 0);

        // Add new triggers
        let new_triggers = vec![
            (
                ":a".to_string(),
                "A".to_string(),
                "Content A".to_string(),
                "paste".to_string(),
            ),
            (
                ":b".to_string(),
                "B".to_string(),
                "Content B".to_string(),
                "paste".to_string(),
            ),
        ];

        let (added, removed, updated) = manager.update_triggers_for_file(&path, &new_triggers);

        assert_eq!(added, 2);
        assert_eq!(removed, 0);
        assert_eq!(updated, 0);
        assert_eq!(manager.trigger_count(), 2);
    }

    #[test]
    fn test_update_triggers_remove_old() {
        let mut manager = ExpandManager::new();
        let path = PathBuf::from("/test/file.md");

        // Start with two triggers
        manager.register_trigger_from_file(":a", "A", "Content A", "paste", &path);
        manager.register_trigger_from_file(":b", "B", "Content B", "paste", &path);
        assert_eq!(manager.trigger_count(), 2);

        // Update with only one trigger (removes :b)
        let new_triggers = vec![(
            ":a".to_string(),
            "A".to_string(),
            "Content A".to_string(),
            "paste".to_string(),
        )];

        let (added, removed, updated) = manager.update_triggers_for_file(&path, &new_triggers);

        assert_eq!(added, 0);
        assert_eq!(removed, 1);
        assert_eq!(updated, 0);
        assert_eq!(manager.trigger_count(), 1);

        let triggers = manager.list_triggers();
        assert_eq!(triggers[0].0, ":a");
    }

    #[test]
    fn test_update_triggers_change_content() {
        let mut manager = ExpandManager::new();
        let path = PathBuf::from("/test/file.md");

        // Start with a trigger
        manager.register_trigger_from_file(":sig", "Signature", "Old content", "paste", &path);
        assert_eq!(manager.trigger_count(), 1);

        // Update with changed content
        let new_triggers = vec![(
            ":sig".to_string(),
            "Signature".to_string(),
            "New content".to_string(),
            "paste".to_string(),
        )];

        let (added, removed, updated) = manager.update_triggers_for_file(&path, &new_triggers);

        assert_eq!(added, 0);
        assert_eq!(removed, 0);
        assert_eq!(updated, 1);
        assert_eq!(manager.trigger_count(), 1);
    }

    #[test]
    fn test_update_triggers_mixed_operations() {
        let mut manager = ExpandManager::new();
        let path = PathBuf::from("/test/file.md");

        // Start with triggers :a, :b, :c
        manager.register_trigger_from_file(":a", "A", "Content A", "paste", &path);
        manager.register_trigger_from_file(":b", "B", "Content B", "paste", &path);
        manager.register_trigger_from_file(":c", "C", "Content C", "paste", &path);
        assert_eq!(manager.trigger_count(), 3);

        // Update:
        // - Keep :a unchanged
        // - Remove :b
        // - Change :c content
        // - Add :d
        let new_triggers = vec![
            (
                ":a".to_string(),
                "A".to_string(),
                "Content A".to_string(),
                "paste".to_string(),
            ),
            (
                ":c".to_string(),
                "C".to_string(),
                "New content C".to_string(),
                "paste".to_string(),
            ),
            (
                ":d".to_string(),
                "D".to_string(),
                "Content D".to_string(),
                "paste".to_string(),
            ),
        ];

        let (added, removed, updated) = manager.update_triggers_for_file(&path, &new_triggers);

        assert_eq!(added, 1); // :d
        assert_eq!(removed, 1); // :b
        assert_eq!(updated, 1); // :c
        assert_eq!(manager.trigger_count(), 3);

        let triggers = manager.list_triggers();
        let trigger_names: Vec<_> = triggers.iter().map(|(t, _)| t.as_str()).collect();
        assert!(trigger_names.contains(&":a"));
        assert!(!trigger_names.contains(&":b"));
        assert!(trigger_names.contains(&":c"));
        assert!(trigger_names.contains(&":d"));
    }

    #[test]
    fn test_update_triggers_empty_removes_all() {
        let mut manager = ExpandManager::new();
        let path = PathBuf::from("/test/file.md");

        // Start with triggers
        manager.register_trigger_from_file(":a", "A", "Content A", "paste", &path);
        manager.register_trigger_from_file(":b", "B", "Content B", "paste", &path);
        assert_eq!(manager.trigger_count(), 2);

        // Update with empty list
        let new_triggers: Vec<(String, String, String, String)> = vec![];

        let (added, removed, updated) = manager.update_triggers_for_file(&path, &new_triggers);

        assert_eq!(added, 0);
        assert_eq!(removed, 2);
        assert_eq!(updated, 0);
        assert_eq!(manager.trigger_count(), 0);
    }

    #[test]
    fn test_update_triggers_does_not_affect_other_files() {
        let mut manager = ExpandManager::new();
        let path1 = PathBuf::from("/test/file1.md");
        let path2 = PathBuf::from("/test/file2.md");

        // Register triggers from two files
        manager.register_trigger_from_file(":a", "A", "Content A", "paste", &path1);
        manager.register_trigger_from_file(":b", "B", "Content B", "paste", &path2);
        assert_eq!(manager.trigger_count(), 2);

        // Update file1 to remove its trigger
        let new_triggers: Vec<(String, String, String, String)> = vec![];
        manager.update_triggers_for_file(&path1, &new_triggers);

        // File2's trigger should still exist
        assert_eq!(manager.trigger_count(), 1);
        let triggers = manager.list_triggers();
        assert_eq!(triggers[0].0, ":b");
    }

    // ========================================
    // Register Trigger From File Tests
    // ========================================

    #[test]
    fn test_register_trigger_from_file() {
        let mut manager = ExpandManager::new();
        let path = PathBuf::from("/test/file.md");

        manager.register_trigger_from_file(":test", "Test", "Content", "paste", &path);

        assert_eq!(manager.trigger_count(), 1);
        assert_eq!(
            manager.get_triggers_for_file(&path),
            vec![":test".to_string()]
        );
    }

    #[test]
    fn test_register_trigger_from_file_empty_ignored() {
        let mut manager = ExpandManager::new();
        let path = PathBuf::from("/test/file.md");

        manager.register_trigger_from_file("", "Test", "Content", "paste", &path);

        assert_eq!(manager.trigger_count(), 0);
    }

    #[test]
    fn test_get_triggers_for_file() {
        let mut manager = ExpandManager::new();
        let path = PathBuf::from("/test/file.md");

        manager.register_trigger_from_file(":a", "A", "Content A", "paste", &path);
        manager.register_trigger_from_file(":b", "B", "Content B", "paste", &path);

        let triggers = manager.get_triggers_for_file(&path);
        assert_eq!(triggers.len(), 2);
        assert!(triggers.contains(&":a".to_string()));
        assert!(triggers.contains(&":b".to_string()));
    }

    // Integration tests that require system permissions
    #[test]
    #[ignore = "Requires accessibility permissions"]
    fn test_enable_disable_cycle() {
        let mut manager = ExpandManager::new();
        manager.register_trigger(":test", "Test", "Content", "paste");

        assert!(manager.enable().is_ok());
        assert!(manager.is_enabled());

        manager.disable();
        assert!(!manager.is_enabled());
    }
}

</file>

<file path="src/text_injector.rs">
//! Text Injection Module for macOS
//!
//! Provides text injection functionality for text expansion/snippet systems.
//! Uses the proven Espanso/Raycast pattern:
//! 1. Delete trigger text with simulated backspace key events
//! 2. Insert replacement text via clipboard paste (Cmd+V)
//!
//! ## Architecture
//!
//! - `delete_chars()`: Simulates N backspace key events using CGEventPost
//! - `paste_text()`: Clipboard-based paste with save/restore pattern
//! - `inject_text()`: Convenience function combining both operations
//!
//! ## Configurable Delays
//!
//! All timing is configurable via `TextInjectorConfig`:
//! - `key_delay_ms`: Delay between backspace events (default: 2ms)
//! - `pre_paste_delay_ms`: Delay before paste operation (default: 50ms)
//! - `post_paste_delay_ms`: Delay before restoring clipboard (default: 100ms)
//!
//! ## Permissions
//!
//! Requires Accessibility permission in System Preferences > Privacy & Security > Accessibility

use anyhow::{Context, Result};
use arboard::Clipboard;
use std::thread;
use std::time::Duration;
use tracing::{debug, info, instrument, warn};

// ============================================================================
// Configuration
// ============================================================================

/// Configuration for text injection timing and behavior
#[derive(Debug, Clone)]
pub struct TextInjectorConfig {
    /// Delay in milliseconds between backspace key events (default: 2ms)
    pub key_delay_ms: u64,
    /// Delay in milliseconds before paste operation (default: 50ms)
    pub pre_paste_delay_ms: u64,
    /// Delay in milliseconds before restoring clipboard (default: 100ms)
    pub post_paste_delay_ms: u64,
}

impl Default for TextInjectorConfig {
    fn default() -> Self {
        Self {
            key_delay_ms: 2,
            pre_paste_delay_ms: 50,
            post_paste_delay_ms: 100,
        }
    }
}

// ============================================================================
// Text Injector
// ============================================================================

/// Text injector for deleting trigger text and inserting replacements
///
/// Uses macOS Core Graphics API for key simulation and clipboard for pasting.
/// This is the same reliable pattern used by Espanso and Raycast.
#[derive(Debug, Clone)]
pub struct TextInjector {
    config: TextInjectorConfig,
}

impl Default for TextInjector {
    fn default() -> Self {
        Self::new()
    }
}

impl TextInjector {
    /// Create a new TextInjector with default configuration
    pub fn new() -> Self {
        Self {
            config: TextInjectorConfig::default(),
        }
    }

    /// Create a new TextInjector with custom configuration
    pub fn with_config(config: TextInjectorConfig) -> Self {
        Self { config }
    }

    /// Get the current configuration
    #[allow(dead_code)]
    pub fn config(&self) -> &TextInjectorConfig {
        &self.config
    }

    /// Delete characters by sending backspace key events
    ///
    /// Simulates N backspace keystrokes using CGEventPost to delete
    /// the trigger text that the user typed.
    ///
    /// # Arguments
    /// * `count` - Number of characters to delete (backspace events to send)
    ///
    /// # Errors
    /// Returns error if CGEventPost fails
    ///
    #[instrument(skip(self), fields(count))]
    pub fn delete_chars(&self, count: usize) -> Result<()> {
        if count == 0 {
            debug!("No characters to delete");
            return Ok(());
        }

        debug!(count, "Deleting characters via backspace simulation");

        for i in 0..count {
            simulate_backspace()?;

            // Add delay between keystrokes for reliability
            if i < count - 1 && self.config.key_delay_ms > 0 {
                thread::sleep(Duration::from_millis(self.config.key_delay_ms));
            }
        }

        info!(count, "Deleted characters successfully");
        Ok(())
    }

    /// Paste text using clipboard and Cmd+V simulation
    ///
    /// This function:
    /// 1. Saves the current clipboard contents
    /// 2. Sets the clipboard to the new text
    /// 3. Simulates Cmd+V to paste
    /// 4. Waits for paste to complete
    /// 5. Restores the original clipboard contents
    ///
    /// # Arguments
    /// * `text` - The text to paste
    ///
    /// # Errors
    /// Returns error if clipboard or paste operation fails
    ///
    #[instrument(skip(self, text), fields(text_len = text.len()))]
    pub fn paste_text(&self, text: &str) -> Result<()> {
        if text.is_empty() {
            debug!("Empty text, nothing to paste");
            return Ok(());
        }

        debug!(text_len = text.len(), "Pasting text via clipboard");

        let mut clipboard = Clipboard::new().context("Failed to access clipboard")?;

        // Save original clipboard contents (text only for now)
        let original = clipboard.get_text().ok();
        debug!(
            had_original = original.is_some(),
            "Saved original clipboard"
        );

        // Set new text to clipboard
        clipboard
            .set_text(text)
            .context("Failed to set clipboard text")?;

        // Pre-paste delay to ensure clipboard is ready
        if self.config.pre_paste_delay_ms > 0 {
            thread::sleep(Duration::from_millis(self.config.pre_paste_delay_ms));
        }

        // Simulate Cmd+V using Core Graphics
        simulate_paste()?;

        // Post-paste delay before restoring clipboard
        if self.config.post_paste_delay_ms > 0 {
            thread::sleep(Duration::from_millis(self.config.post_paste_delay_ms));
        }

        // Restore original clipboard (best effort)
        if let Some(original_text) = original {
            if let Err(e) = clipboard.set_text(&original_text) {
                warn!(error = %e, "Failed to restore original clipboard");
            } else {
                debug!("Restored original clipboard");
            }
        }

        info!(text_len = text.len(), "Pasted text successfully");
        Ok(())
    }

    /// Inject text by deleting trigger characters and pasting replacement
    ///
    /// This is a convenience function that combines `delete_chars()` and
    /// `paste_text()` for the common text expansion use case.
    ///
    /// # Arguments
    /// * `delete_count` - Number of characters to delete (trigger length)
    /// * `replacement` - The text to insert
    ///
    /// # Errors
    /// Returns error if delete or paste operation fails
    ///
    #[allow(dead_code)]
    #[instrument(skip(self, replacement), fields(delete_count, replacement_len = replacement.len()))]
    pub fn inject_text(&self, delete_count: usize, replacement: &str) -> Result<()> {
        info!(
            delete_count,
            replacement_len = replacement.len(),
            "Injecting text"
        );

        // Delete trigger characters
        self.delete_chars(delete_count)?;

        // Small delay between delete and paste operations
        if self.config.pre_paste_delay_ms > 0 {
            thread::sleep(Duration::from_millis(self.config.pre_paste_delay_ms));
        }

        // Paste replacement text
        self.paste_text(replacement)?;

        info!("Text injection completed");
        Ok(())
    }
}

// ============================================================================
// Core Graphics Key Simulation
// ============================================================================

/// Simulate a single backspace keypress using Core Graphics
///
/// Sends both key down and key up events for the backspace key.
fn simulate_backspace() -> Result<()> {
    use core_graphics::event::{CGEvent, CGEventTapLocation, CGKeyCode};
    use core_graphics::event_source::{CGEventSource, CGEventSourceStateID};

    // Backspace key is keycode 51 on macOS
    const KEY_BACKSPACE: CGKeyCode = 51;

    let source = CGEventSource::new(CGEventSourceStateID::HIDSystemState)
        .ok()
        .context("Failed to create CGEventSource")?;

    // Key down event
    let key_down = CGEvent::new_keyboard_event(source.clone(), KEY_BACKSPACE, true)
        .ok()
        .context("Failed to create backspace key down event")?;

    // Key up event
    let key_up = CGEvent::new_keyboard_event(source, KEY_BACKSPACE, false)
        .ok()
        .context("Failed to create backspace key up event")?;

    // Post events to HID system
    key_down.post(CGEventTapLocation::HID);
    thread::sleep(Duration::from_millis(1)); // Brief delay between down/up
    key_up.post(CGEventTapLocation::HID);

    Ok(())
}

/// Simulate Cmd+V paste keystroke using Core Graphics
///
/// Sends key down and key up events for 'v' with Command modifier.
fn simulate_paste() -> Result<()> {
    use core_graphics::event::{CGEvent, CGEventFlags, CGEventTapLocation, CGKeyCode};
    use core_graphics::event_source::{CGEventSource, CGEventSourceStateID};

    // 'v' key is keycode 9 on macOS
    const KEY_V: CGKeyCode = 9;

    let source = CGEventSource::new(CGEventSourceStateID::HIDSystemState)
        .ok()
        .context("Failed to create CGEventSource")?;

    // Create key down event for 'v' with Cmd modifier
    let key_down = CGEvent::new_keyboard_event(source.clone(), KEY_V, true)
        .ok()
        .context("Failed to create paste key down event")?;
    key_down.set_flags(CGEventFlags::CGEventFlagCommand);

    // Create key up event for 'v' with Cmd modifier
    let key_up = CGEvent::new_keyboard_event(source, KEY_V, false)
        .ok()
        .context("Failed to create paste key up event")?;
    key_up.set_flags(CGEventFlags::CGEventFlagCommand);

    // Post events
    key_down.post(CGEventTapLocation::HID);
    thread::sleep(Duration::from_millis(5)); // Brief delay between down/up
    key_up.post(CGEventTapLocation::HID);

    debug!("Simulated Cmd+V via Core Graphics");
    Ok(())
}

// ============================================================================
// Tests
// ============================================================================

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_default_config() {
        let config = TextInjectorConfig::default();
        assert_eq!(config.key_delay_ms, 2);
        assert_eq!(config.pre_paste_delay_ms, 50);
        assert_eq!(config.post_paste_delay_ms, 100);
    }

    #[test]
    fn test_custom_config() {
        let config = TextInjectorConfig {
            key_delay_ms: 5,
            pre_paste_delay_ms: 100,
            post_paste_delay_ms: 200,
        };
        let injector = TextInjector::with_config(config.clone());
        assert_eq!(injector.config().key_delay_ms, 5);
        assert_eq!(injector.config().pre_paste_delay_ms, 100);
        assert_eq!(injector.config().post_paste_delay_ms, 200);
    }

    #[test]
    fn test_injector_new() {
        let injector = TextInjector::new();
        assert_eq!(injector.config().key_delay_ms, 2);
    }

    #[test]
    fn test_injector_default() {
        let injector = TextInjector::default();
        assert_eq!(injector.config().key_delay_ms, 2);
    }

    #[test]
    fn test_delete_chars_zero() {
        // Deleting zero chars should succeed without doing anything
        let injector = TextInjector::new();
        // This won't actually simulate keys in tests, but checks the early return
        let result = injector.delete_chars(0);
        assert!(result.is_ok());
    }
}

// ============================================================================
// System Tests (require `cargo test --features system-tests`)
// ============================================================================

#[cfg(all(test, feature = "system-tests"))]
mod system_tests {
    use super::*;

    #[test]
    #[ignore] // Requires accessibility permission and user interaction
    fn test_delete_chars_sends_backspaces() {
        // Instructions:
        // 1. Open TextEdit and type "hello"
        // 2. Run: cargo test --features system-tests test_delete_chars_sends_backspaces -- --ignored
        // 3. The last 2 characters should be deleted, leaving "hel"
        let injector = TextInjector::new();
        injector.delete_chars(2).expect("Should delete chars");
        println!("Deleted 2 characters");
    }

    #[test]
    #[ignore] // Requires accessibility permission and user interaction
    fn test_paste_text() {
        // Instructions:
        // 1. Open TextEdit with cursor positioned
        // 2. Run: cargo test --features system-tests test_paste_text -- --ignored
        // 3. "TEST PASTE" should be inserted
        let injector = TextInjector::new();
        injector.paste_text("TEST PASTE").expect("Should paste");
        println!("Pasted text");
    }

    #[test]
    #[ignore] // Requires accessibility permission and user interaction
    fn test_inject_text() {
        // Instructions:
        // 1. Open TextEdit and type "btw"
        // 2. Run: cargo test --features system-tests test_inject_text -- --ignored
        // 3. "btw" should be replaced with "by the way"
        let injector = TextInjector::new();
        injector
            .inject_text(3, "by the way")
            .expect("Should inject");
        println!("Injected text");
    }

    #[test]
    fn test_empty_paste() {
        // Pasting empty text should succeed
        let injector = TextInjector::new();
        let result = injector.paste_text("");
        assert!(result.is_ok());
    }
}

</file>

<file path="src/snippet.rs">
//! VSCode snippet syntax parser for template() SDK function
//!
//! Parses snippet syntax into a structured data model for tabstop navigation.
//!
//! Supported syntax:
//! - `$1`, `$2`, `$3` - Simple tabstops (numbered positions)
//! - `${1:default}` - Tabstops with placeholder text
//! - `${1|a,b,c|}` - Choice tabstops (dropdown options)
//! - `$0` - Final cursor position
//! - `$$` - Escaped literal dollar sign

/// Represents a parsed part of a snippet template
#[derive(Debug, Clone, PartialEq)]
pub enum SnippetPart {
    /// Literal text (no special meaning)
    Text(String),
    /// A tabstop position
    Tabstop {
        /// Tabstop index: 0 = final cursor, 1+ = navigation order
        index: usize,
        /// Default placeholder text (from `${1:text}` syntax)
        placeholder: Option<String>,
        /// Choice options (from `${1|a,b,c|}` syntax)
        choices: Option<Vec<String>>,
        /// Byte range in the expanded text where this tabstop appears
        range: (usize, usize),
    },
}

/// Information about a tabstop, with all occurrences of the same index merged
#[derive(Debug, Clone, PartialEq)]
pub struct TabstopInfo {
    /// Tabstop index
    pub index: usize,
    /// All byte ranges where this tabstop appears (for linked editing)
    pub ranges: Vec<(usize, usize)>,
    /// Placeholder text (if any)
    pub placeholder: Option<String>,
    /// Choice options (if any)
    pub choices: Option<Vec<String>>,
}

/// A fully parsed snippet with expanded text and tabstop metadata
#[derive(Debug, Clone, PartialEq)]
pub struct ParsedSnippet {
    /// Sequential parts of the snippet (text and tabstops interleaved)
    pub parts: Vec<SnippetPart>,
    /// Fully expanded text with placeholders filled in
    pub text: String,
    /// Tabstops sorted by navigation order (1, 2, 3... then 0)
    pub tabstops: Vec<TabstopInfo>,
}

impl ParsedSnippet {
    /// Parse a VSCode snippet template string into a structured representation
    ///
    /// # Examples
    ///
    /// ```
    /// use script_kit_gpui::snippet::ParsedSnippet;
    ///
    /// let snippet = ParsedSnippet::parse("Hello $1!");
    /// assert_eq!(snippet.text, "Hello !");
    /// assert_eq!(snippet.tabstops.len(), 1);
    /// ```
    pub fn parse(template: &str) -> Self {
        let mut parts = Vec::new();
        let mut text = String::new();
        let mut char_count: usize = 0; // Track char count for char-based indices
        let mut chars = template.chars().peekable();
        let mut current_text = String::new();

        while let Some(c) = chars.next() {
            if c == '$' {
                match chars.peek() {
                    // Escaped dollar: $$ -> $
                    Some('$') => {
                        chars.next();
                        current_text.push('$');
                    }
                    // Tabstop with braces: ${...}
                    Some('{') => {
                        // Flush current text
                        if !current_text.is_empty() {
                            text.push_str(&current_text);
                            char_count += current_text.chars().count();
                            parts.push(SnippetPart::Text(current_text.clone()));
                            current_text.clear();
                        }
                        chars.next(); // consume '{'

                        let tabstop = Self::parse_braced_tabstop(&mut chars, char_count);
                        let placeholder_text = tabstop
                            .placeholder
                            .as_deref()
                            .or(tabstop
                                .choices
                                .as_ref()
                                .and_then(|c| c.first().map(|s| s.as_str())))
                            .unwrap_or("");

                        text.push_str(placeholder_text);
                        char_count += placeholder_text.chars().count();
                        parts.push(SnippetPart::Tabstop {
                            index: tabstop.index,
                            placeholder: tabstop.placeholder,
                            choices: tabstop.choices,
                            range: tabstop.range,
                        });
                    }
                    // Simple tabstop: $N
                    Some(d) if d.is_ascii_digit() => {
                        // Flush current text
                        if !current_text.is_empty() {
                            text.push_str(&current_text);
                            char_count += current_text.chars().count();
                            parts.push(SnippetPart::Text(current_text.clone()));
                            current_text.clear();
                        }

                        let mut num_str = String::new();
                        while let Some(&d) = chars.peek() {
                            if d.is_ascii_digit() {
                                num_str.push(d);
                                chars.next();
                            } else {
                                break;
                            }
                        }

                        let index: usize = num_str.parse().unwrap_or(0);
                        // Simple tabstop has empty placeholder, so range is (char_count, char_count)
                        parts.push(SnippetPart::Tabstop {
                            index,
                            placeholder: None,
                            choices: None,
                            range: (char_count, char_count),
                        });
                    }
                    // Just a lone $ at end or followed by non-special char
                    _ => {
                        current_text.push('$');
                    }
                }
            } else {
                current_text.push(c);
            }
        }

        // Flush remaining text
        if !current_text.is_empty() {
            text.push_str(&current_text);
            parts.push(SnippetPart::Text(current_text));
        }

        // Build tabstop info, merging same indices
        let tabstops = Self::build_tabstop_info(&parts);

        Self {
            parts,
            text,
            tabstops,
        }
    }

    /// Parse a braced tabstop: `{1}`, `{1:default}`, or `{1|a,b,c|}`
    ///
    /// `char_offset` is the current position in char indices (not bytes).
    fn parse_braced_tabstop(
        chars: &mut std::iter::Peekable<std::str::Chars>,
        char_offset: usize,
    ) -> TabstopParseResult {
        let mut index_str = String::new();

        // Parse index number
        while let Some(&c) = chars.peek() {
            if c.is_ascii_digit() {
                index_str.push(c);
                chars.next();
            } else {
                break;
            }
        }

        let index: usize = index_str.parse().unwrap_or(0);

        // Check what follows the index
        match chars.peek() {
            // Placeholder: ${1:text}
            Some(':') => {
                chars.next(); // consume ':'
                let placeholder = Self::parse_until_close_brace(chars);
                // Use char count, not byte length
                let placeholder_char_len = placeholder.chars().count();
                let range = (char_offset, char_offset + placeholder_char_len);
                TabstopParseResult {
                    index,
                    placeholder: Some(placeholder),
                    choices: None,
                    range,
                }
            }
            // Choices: ${1|a,b,c|}
            Some('|') => {
                chars.next(); // consume '|'
                let choices = Self::parse_choices(chars);
                // Use char count of first choice, not byte length
                let first_choice_char_len = choices.first().map(|s| s.chars().count()).unwrap_or(0);
                let range = (char_offset, char_offset + first_choice_char_len);
                TabstopParseResult {
                    index,
                    placeholder: None,
                    choices: Some(choices),
                    range,
                }
            }
            // Simple: ${1}
            Some('}') => {
                chars.next(); // consume '}'
                TabstopParseResult {
                    index,
                    placeholder: None,
                    choices: None,
                    range: (char_offset, char_offset),
                }
            }
            // Unexpected - consume until }
            _ => {
                Self::parse_until_close_brace(chars);
                TabstopParseResult {
                    index,
                    placeholder: None,
                    choices: None,
                    range: (char_offset, char_offset),
                }
            }
        }
    }

    /// Parse content until closing brace, handling nested braces
    #[allow(clippy::while_let_on_iterator)]
    fn parse_until_close_brace(chars: &mut std::iter::Peekable<std::str::Chars>) -> String {
        let mut result = String::new();
        let mut brace_depth = 1;

        while let Some(c) = chars.next() {
            match c {
                '{' => {
                    brace_depth += 1;
                    result.push(c);
                }
                '}' => {
                    brace_depth -= 1;
                    if brace_depth == 0 {
                        break;
                    }
                    result.push(c);
                }
                _ => result.push(c),
            }
        }

        result
    }

    /// Parse choice options: `a,b,c|}`
    fn parse_choices(chars: &mut std::iter::Peekable<std::str::Chars>) -> Vec<String> {
        let mut choices = Vec::new();
        let mut current = String::new();

        #[allow(clippy::while_let_on_iterator)]
        while let Some(c) = chars.next() {
            match c {
                ',' => {
                    choices.push(current.clone());
                    current.clear();
                }
                '|' => {
                    // End of choices, expect }
                    choices.push(current);
                    // Consume the closing }
                    if chars.peek() == Some(&'}') {
                        chars.next();
                    }
                    break;
                }
                '\\' => {
                    // Escaped character in choice
                    if let Some(next) = chars.next() {
                        current.push(next);
                    }
                }
                _ => current.push(c),
            }
        }

        choices
    }

    /// Build TabstopInfo from parts, merging same indices
    fn build_tabstop_info(parts: &[SnippetPart]) -> Vec<TabstopInfo> {
        use std::collections::BTreeMap;

        let mut tabstop_map: BTreeMap<usize, TabstopInfo> = BTreeMap::new();

        for part in parts {
            if let SnippetPart::Tabstop {
                index,
                placeholder,
                choices,
                range,
            } = part
            {
                tabstop_map
                    .entry(*index)
                    .and_modify(|info| {
                        info.ranges.push(*range);
                        // Keep first placeholder/choices found
                        if info.placeholder.is_none() && placeholder.is_some() {
                            info.placeholder = placeholder.clone();
                        }
                        if info.choices.is_none() && choices.is_some() {
                            info.choices = choices.clone();
                        }
                    })
                    .or_insert_with(|| TabstopInfo {
                        index: *index,
                        ranges: vec![*range],
                        placeholder: placeholder.clone(),
                        choices: choices.clone(),
                    });
            }
        }

        // Sort: all non-zero indices in order, then 0 (final cursor) at end
        let mut result: Vec<TabstopInfo> = tabstop_map
            .into_iter()
            .filter(|(idx, _)| *idx != 0)
            .map(|(_, info)| info)
            .collect();

        // Add $0 at the end if it exists
        if let Some(final_cursor) = parts.iter().find_map(|p| {
            if let SnippetPart::Tabstop {
                index: 0,
                placeholder,
                choices,
                range,
            } = p
            {
                Some(TabstopInfo {
                    index: 0,
                    ranges: vec![*range],
                    placeholder: placeholder.clone(),
                    choices: choices.clone(),
                })
            } else {
                None
            }
        }) {
            result.push(final_cursor);
        }

        result
    }

    /// Get tabstop info by index
    #[allow(dead_code)]
    pub fn get_tabstop(&self, index: usize) -> Option<&TabstopInfo> {
        self.tabstops.iter().find(|t| t.index == index)
    }

    /// Get the navigation order of tabstops (1, 2, 3... then 0)
    #[allow(dead_code)]
    pub fn tabstop_order(&self) -> Vec<usize> {
        self.tabstops.iter().map(|t| t.index).collect()
    }

    /// Update tabstop ranges after an edit operation.
    ///
    /// This method adjusts all tabstop ranges to account for text changes in the document.
    /// Ranges are stored as char indices (not byte offsets) to match editor cursor positions.
    ///
    /// # Arguments
    /// * `current_tabstop_idx` - Index into self.tabstops of the tabstop currently being edited.
    ///   Ranges within this tabstop that contain the edit point will be resized.
    ///   Pass `usize::MAX` if editing outside any tabstop.
    /// * `edit_start` - Char index where the edit begins
    /// * `old_len` - Number of chars that were removed
    /// * `new_len` - Number of chars that were inserted
    ///
    /// # Behavior
    /// - Ranges **after** the edit point are shifted by `delta = new_len - old_len`
    /// - Ranges **containing** the edit point (within current tabstop) are resized by `delta`
    /// - Ranges **before** the edit point are unchanged
    ///
    /// Note: This is prepared for linked editing support (when the same tabstop appears
    /// multiple times in a template, edits should sync across all occurrences).
    #[allow(dead_code)]
    pub fn update_tabstops_after_edit(
        &mut self,
        current_tabstop_idx: usize,
        edit_start: usize,
        old_len: usize,
        new_len: usize,
    ) {
        let delta = new_len as isize - old_len as isize;
        if delta == 0 {
            return;
        }

        let edit_end = edit_start + old_len;

        for (tabstop_idx, tabstop) in self.tabstops.iter_mut().enumerate() {
            for range in tabstop.ranges.iter_mut() {
                let (range_start, range_end) = *range;

                // Case 1: Range is entirely before the edit - no change
                if range_end <= edit_start {
                    continue;
                }

                // Case 2: Range is entirely after the edit - shift by delta
                if range_start > edit_end
                    || (range_start == edit_end && tabstop_idx != current_tabstop_idx)
                {
                    *range = (
                        (range_start as isize + delta) as usize,
                        (range_end as isize + delta) as usize,
                    );
                    continue;
                }

                // Case 3: Edit is within or at the boundary of this range
                // For the current tabstop, we resize (keep start, adjust end)
                // For other tabstops, the edit should not overlap (they're not being edited)
                if tabstop_idx == current_tabstop_idx {
                    // Edit is within this range - keep start, resize end
                    *range = (range_start, (range_end as isize + delta) as usize);
                } else {
                    // This range starts at or after the edit point but before edit_end
                    // This means it overlaps with the edit region
                    // Shift the entire range by delta
                    *range = (
                        (range_start as isize + delta).max(0) as usize,
                        (range_end as isize + delta).max(0) as usize,
                    );
                }
            }
        }
    }
}

/// Internal helper for parsing braced tabstops
struct TabstopParseResult {
    index: usize,
    placeholder: Option<String>,
    choices: Option<Vec<String>>,
    range: (usize, usize),
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_parse_simple_tabstop() {
        let snippet = ParsedSnippet::parse("$1");
        assert_eq!(snippet.parts.len(), 1);
        match &snippet.parts[0] {
            SnippetPart::Tabstop { index, .. } => assert_eq!(*index, 1),
            _ => panic!("Expected Tabstop"),
        }
        assert_eq!(snippet.text, "");
    }

    #[test]
    fn test_parse_tabstop_with_placeholder() {
        let snippet = ParsedSnippet::parse("${1:name}");
        assert_eq!(snippet.parts.len(), 1);
        match &snippet.parts[0] {
            SnippetPart::Tabstop {
                index, placeholder, ..
            } => {
                assert_eq!(*index, 1);
                assert_eq!(placeholder.as_deref(), Some("name"));
            }
            _ => panic!("Expected Tabstop"),
        }
        assert_eq!(snippet.text, "name");
    }

    #[test]
    fn test_parse_tabstop_with_choices() {
        let snippet = ParsedSnippet::parse("${1|a,b,c|}");
        assert_eq!(snippet.parts.len(), 1);
        match &snippet.parts[0] {
            SnippetPart::Tabstop { index, choices, .. } => {
                assert_eq!(*index, 1);
                assert_eq!(
                    choices.as_ref().unwrap(),
                    &vec!["a".to_string(), "b".to_string(), "c".to_string()]
                );
            }
            _ => panic!("Expected Tabstop"),
        }
        // First choice is used as expanded text
        assert_eq!(snippet.text, "a");
    }

    #[test]
    fn test_parse_text_and_tabstop() {
        let snippet = ParsedSnippet::parse("Hello $1!");
        assert_eq!(snippet.parts.len(), 3);

        match &snippet.parts[0] {
            SnippetPart::Text(t) => assert_eq!(t, "Hello "),
            _ => panic!("Expected Text"),
        }
        match &snippet.parts[1] {
            SnippetPart::Tabstop { index, .. } => assert_eq!(*index, 1),
            _ => panic!("Expected Tabstop"),
        }
        match &snippet.parts[2] {
            SnippetPart::Text(t) => assert_eq!(t, "!"),
            _ => panic!("Expected Text"),
        }

        assert_eq!(snippet.text, "Hello !");
    }

    #[test]
    fn test_parse_escaped_dollar() {
        let snippet = ParsedSnippet::parse("$$100");
        assert_eq!(snippet.parts.len(), 1);
        match &snippet.parts[0] {
            SnippetPart::Text(t) => assert_eq!(t, "$100"),
            _ => panic!("Expected Text"),
        }
        assert_eq!(snippet.text, "$100");
    }

    #[test]
    fn test_parse_linked_tabstops() {
        let snippet = ParsedSnippet::parse("${1:foo} and ${1:bar}");

        // Should have 3 parts: tabstop, text, tabstop
        assert_eq!(snippet.parts.len(), 3);

        // Both tabstops should have index 1
        let tabstop1 = &snippet.parts[0];
        let tabstop2 = &snippet.parts[2];

        match (tabstop1, tabstop2) {
            (
                SnippetPart::Tabstop {
                    index: idx1,
                    placeholder: p1,
                    ..
                },
                SnippetPart::Tabstop {
                    index: idx2,
                    placeholder: p2,
                    ..
                },
            ) => {
                assert_eq!(*idx1, 1);
                assert_eq!(*idx2, 1);
                assert_eq!(p1.as_deref(), Some("foo"));
                assert_eq!(p2.as_deref(), Some("bar"));
            }
            _ => panic!("Expected two Tabstops"),
        }

        // Should only have one TabstopInfo with two ranges
        assert_eq!(snippet.tabstops.len(), 1);
        assert_eq!(snippet.tabstops[0].index, 1);
        assert_eq!(snippet.tabstops[0].ranges.len(), 2);
        // First placeholder should be kept
        assert_eq!(snippet.tabstops[0].placeholder.as_deref(), Some("foo"));
    }

    #[test]
    fn test_parse_final_cursor() {
        let snippet = ParsedSnippet::parse("$0");
        assert_eq!(snippet.parts.len(), 1);
        match &snippet.parts[0] {
            SnippetPart::Tabstop { index, .. } => assert_eq!(*index, 0),
            _ => panic!("Expected Tabstop"),
        }
    }

    #[test]
    fn test_parse_empty_string() {
        let snippet = ParsedSnippet::parse("");
        assert_eq!(snippet.parts.len(), 0);
        assert_eq!(snippet.text, "");
        assert_eq!(snippet.tabstops.len(), 0);
    }

    #[test]
    fn test_tabstop_order() {
        let snippet = ParsedSnippet::parse("$3 $1 $2 $0");
        let order = snippet.tabstop_order();
        // Should be sorted: 1, 2, 3, then 0 at end
        assert_eq!(order, vec![1, 2, 3, 0]);
    }

    #[test]
    fn test_get_tabstop() {
        let snippet = ParsedSnippet::parse("${1:hello} ${2:world}");

        let t1 = snippet.get_tabstop(1).unwrap();
        assert_eq!(t1.index, 1);
        assert_eq!(t1.placeholder.as_deref(), Some("hello"));

        let t2 = snippet.get_tabstop(2).unwrap();
        assert_eq!(t2.index, 2);
        assert_eq!(t2.placeholder.as_deref(), Some("world"));

        assert!(snippet.get_tabstop(3).is_none());
    }

    #[test]
    fn test_tabstop_ranges() {
        let snippet = ParsedSnippet::parse("Hello ${1:world}!");

        // "Hello " is 6 chars, "world" is 5 chars
        // Range should be (6, 11)
        let t1 = snippet.get_tabstop(1).unwrap();
        assert_eq!(t1.ranges, vec![(6, 11)]);
    }

    #[test]
    fn test_multiple_tabstops_with_text() {
        let snippet = ParsedSnippet::parse("function ${1:name}(${2:args}) { $0 }");

        assert_eq!(snippet.text, "function name(args) {  }");

        let order = snippet.tabstop_order();
        assert_eq!(order, vec![1, 2, 0]);
    }

    #[test]
    fn test_simple_braced_tabstop() {
        let snippet = ParsedSnippet::parse("${1}");
        assert_eq!(snippet.parts.len(), 1);
        match &snippet.parts[0] {
            SnippetPart::Tabstop {
                index, placeholder, ..
            } => {
                assert_eq!(*index, 1);
                assert!(placeholder.is_none());
            }
            _ => panic!("Expected Tabstop"),
        }
    }

    #[test]
    fn test_lone_dollar_preserved() {
        let snippet = ParsedSnippet::parse("$x");
        // $ followed by non-digit/non-brace should be preserved
        assert_eq!(snippet.parts.len(), 1);
        match &snippet.parts[0] {
            SnippetPart::Text(t) => assert_eq!(t, "$x"),
            _ => panic!("Expected Text"),
        }
    }

    #[test]
    fn test_dollar_at_end() {
        let snippet = ParsedSnippet::parse("test$");
        assert_eq!(snippet.parts.len(), 1);
        match &snippet.parts[0] {
            SnippetPart::Text(t) => assert_eq!(t, "test$"),
            _ => panic!("Expected Text"),
        }
    }

    // --- Tests for update_tabstops_after_edit ---

    #[test]
    fn test_update_tabstops_after_insert_first_tabstop() {
        // Template: "${1:hello} ${2:world}"
        // Initial text: "hello world" (char indices)
        // Tabstop 1 at (0, 5), Tabstop 2 at (6, 11)
        //
        // If we type "XX" at position 0 (replacing "hello" with "XXhello"):
        // - Tabstop 1 should expand from (0, 5) to (0, 7)
        // - Tabstop 2 should shift from (6, 11) to (8, 13)
        let mut snippet = ParsedSnippet::parse("${1:hello} ${2:world}");

        // Verify initial state
        assert_eq!(snippet.tabstops.len(), 2);
        assert_eq!(snippet.tabstops[0].ranges, vec![(0, 5)]);
        assert_eq!(snippet.tabstops[1].ranges, vec![(6, 11)]);

        // Simulate inserting "XX" at position 0, which replaces nothing (old_len=0)
        // edit_start=0, old_len=0, new_len=2
        snippet.update_tabstops_after_edit(0, 0, 0, 2);

        // Tabstop 1 was being edited (contains edit point), should expand
        // Original: (0, 5), +2 chars inserted at start -> still (0, 5+2) = (0, 7)
        // But the current tabstop (0) is the one being edited, so its end expands
        assert_eq!(snippet.tabstops[0].ranges, vec![(0, 7)]);
        // Tabstop 2 should shift right by 2
        assert_eq!(snippet.tabstops[1].ranges, vec![(8, 13)]);
    }

    #[test]
    fn test_update_tabstops_after_delete_in_first_tabstop() {
        // Template: "${1:hello} ${2:world}"
        // Initial: Tabstop 1 at (0, 5), Tabstop 2 at (6, 11)
        //
        // If we delete "hel" (positions 0-3), leaving "lo":
        // - Tabstop 1 shrinks from (0, 5) to (0, 2)
        // - Tabstop 2 shifts from (6, 11) to (3, 8)
        let mut snippet = ParsedSnippet::parse("${1:hello} ${2:world}");

        // Delete 3 chars at position 0 (old_len=3, new_len=0)
        snippet.update_tabstops_after_edit(0, 0, 3, 0);

        // Tabstop 1 shrinks by 3 chars
        assert_eq!(snippet.tabstops[0].ranges, vec![(0, 2)]);
        // Tabstop 2 shifts left by 3 chars
        assert_eq!(snippet.tabstops[1].ranges, vec![(3, 8)]);
    }

    #[test]
    fn test_update_tabstops_after_replace_in_first_tabstop() {
        // Template: "${1:hello} ${2:world}"
        // Initial: Tabstop 1 at (0, 5), Tabstop 2 at (6, 11)
        //
        // If we replace "hello" (0-5) with "hi" (delta = 2 - 5 = -3):
        // - Tabstop 1 shrinks from (0, 5) to (0, 2)
        // - Tabstop 2 shifts from (6, 11) to (3, 8)
        let mut snippet = ParsedSnippet::parse("${1:hello} ${2:world}");

        // Replace 5 chars with 2 chars at position 0
        snippet.update_tabstops_after_edit(0, 0, 5, 2);

        assert_eq!(snippet.tabstops[0].ranges, vec![(0, 2)]);
        assert_eq!(snippet.tabstops[1].ranges, vec![(3, 8)]);
    }

    #[test]
    fn test_update_tabstops_no_change_before_edit() {
        // Edits before a tabstop should shift it
        // Template: "prefix ${1:hello}"
        // Initial: Tabstop 1 at (7, 12)
        //
        // If we add "XX" at position 2 (in "prefix"):
        // - Tabstop 1 shifts from (7, 12) to (9, 14)
        let mut snippet = ParsedSnippet::parse("prefix ${1:hello}");

        assert_eq!(snippet.tabstops[0].ranges, vec![(7, 12)]);

        // Insert 2 chars at position 2 (inside "prefix")
        // current_tabstop_idx is irrelevant here since edit is in text, not tabstop
        // But we need to pass it - use a value that won't affect the tabstop
        snippet.update_tabstops_after_edit(usize::MAX, 2, 0, 2);

        // Tabstop 1 shifts right by 2
        assert_eq!(snippet.tabstops[0].ranges, vec![(9, 14)]);
    }

    #[test]
    fn test_update_tabstops_linked_tabstops() {
        // Template: "${1:foo} and ${1:bar}"
        // This creates a single TabstopInfo with multiple ranges
        // Initial ranges: [(0, 3), (8, 11)]
        //
        // If we edit the first occurrence, both should update appropriately
        let mut snippet = ParsedSnippet::parse("${1:foo} and ${1:bar}");

        assert_eq!(snippet.tabstops.len(), 1);
        assert_eq!(snippet.tabstops[0].ranges, vec![(0, 3), (8, 11)]);

        // Insert 2 chars at position 0 (start of first range)
        // Current tabstop is 0 (the only one)
        snippet.update_tabstops_after_edit(0, 0, 0, 2);

        // First range expands, second range shifts
        assert_eq!(snippet.tabstops[0].ranges, vec![(0, 5), (10, 13)]);
    }

    #[test]
    fn test_choices_with_commas() {
        let snippet = ParsedSnippet::parse("${1|apple,banana,cherry|}");
        match &snippet.parts[0] {
            SnippetPart::Tabstop { choices, .. } => {
                let c = choices.as_ref().unwrap();
                assert_eq!(c.len(), 3);
                assert_eq!(c[0], "apple");
                assert_eq!(c[1], "banana");
                assert_eq!(c[2], "cherry");
            }
            _ => panic!("Expected Tabstop"),
        }
    }

    #[test]
    fn test_complex_template() {
        let template = r#"import { ${1:Component} } from '${2:react}';

export default function ${1:Component}() {
    return (
        <div>$0</div>
    );
}"#;

        let snippet = ParsedSnippet::parse(template);

        // Should have Component tabstop (index 1) twice
        let t1 = snippet.get_tabstop(1).unwrap();
        assert_eq!(t1.ranges.len(), 2);
        assert_eq!(t1.placeholder.as_deref(), Some("Component"));

        // Should have react tabstop (index 2) once
        let t2 = snippet.get_tabstop(2).unwrap();
        assert_eq!(t2.ranges.len(), 1);
        assert_eq!(t2.placeholder.as_deref(), Some("react"));

        // Order should be 1, 2, 0
        assert_eq!(snippet.tabstop_order(), vec![1, 2, 0]);
    }

    // =========================================================================
    // $0 (final cursor) edge case tests - CRITICAL for correct positioning
    // =========================================================================

    #[test]
    fn test_final_cursor_at_end_of_text() {
        // Common pattern: $0 at the very end
        let snippet = ParsedSnippet::parse("Hello ${1:name}!$0");

        // The expanded text should be "Hello name!"
        assert_eq!(snippet.text, "Hello name!");
        assert_eq!(snippet.text.chars().count(), 11);

        // $0 should be at position (11, 11) - a zero-length range at the end
        let t0 = snippet.get_tabstop(0).unwrap();
        assert_eq!(t0.ranges, vec![(11, 11)], "$0 should be at end of text");

        // Verify $0 is last in navigation order
        let order = snippet.tabstop_order();
        assert_eq!(order, vec![1, 0]);
        assert_eq!(order.last(), Some(&0), "$0 must be last");
    }

    #[test]
    fn test_final_cursor_empty_range() {
        // $0 without placeholder has zero-length range
        let snippet = ParsedSnippet::parse("$0");

        let t0 = snippet.get_tabstop(0).unwrap();
        assert_eq!(t0.ranges, vec![(0, 0)], "$0 should have zero-length range");
        assert!(t0.placeholder.is_none());
    }

    #[test]
    fn test_final_cursor_with_placeholder() {
        // ${0:done} - $0 with placeholder text
        let snippet = ParsedSnippet::parse("${1:hello} ${0:cursor here}");

        assert_eq!(snippet.text, "hello cursor here");

        let t0 = snippet.get_tabstop(0).unwrap();
        assert_eq!(t0.placeholder.as_deref(), Some("cursor here"));
        // Range should span "cursor here" (6, 17)
        assert_eq!(t0.ranges, vec![(6, 17)]);
    }

    #[test]
    fn test_multiple_tabstops_then_final_cursor() {
        // Real-world pattern: function template
        let snippet = ParsedSnippet::parse("fn ${1:name}(${2:args}) { $0 }");

        assert_eq!(snippet.text, "fn name(args) {  }");

        // Verify tabstop order: 1, 2, then 0
        let order = snippet.tabstop_order();
        assert_eq!(order, vec![1, 2, 0]);

        // $0 should be at position between "{" and "}"
        let t0 = snippet.get_tabstop(0).unwrap();
        // "fn name(args) { " = 16 chars, then $0 is at (16, 16)
        assert_eq!(t0.ranges, vec![(16, 16)]);
    }

    #[test]
    fn test_only_final_cursor() {
        // Edge case: only $0 in template
        let snippet = ParsedSnippet::parse("$0");

        assert_eq!(snippet.tabstops.len(), 1);
        assert_eq!(snippet.tabstop_order(), vec![0]);
    }

    #[test]
    fn test_final_cursor_unicode() {
        // $0 after unicode text - uses char count, not byte count
        let snippet = ParsedSnippet::parse("$0");

        assert_eq!(snippet.text, "");
        assert_eq!(snippet.text.chars().count(), 2); // 2 chars
        assert_eq!(snippet.text.len(), 6); // 6 bytes

        let t0 = snippet.get_tabstop(0).unwrap();
        // IMPORTANT: ranges use CHAR indices (2), not byte indices (6)
        assert_eq!(t0.ranges, vec![(2, 2)]);
    }

    #[test]
    fn test_tabstop_navigation_order_with_gaps() {
        // Tabstop numbers can have gaps: $1, $3, $5, $0
        let snippet = ParsedSnippet::parse("$5 $1 $3 $0");

        // Order should sort numerically: 1, 3, 5, then 0 at end
        let order = snippet.tabstop_order();
        assert_eq!(order, vec![1, 3, 5, 0]);
    }

    #[test]
    fn test_tabstop_navigation_order_reverse_in_template() {
        // Template has tabstops in reverse order
        let snippet = ParsedSnippet::parse("$3 $2 $1 $0");

        // Navigation order should still be 1, 2, 3, 0
        let order = snippet.tabstop_order();
        assert_eq!(order, vec![1, 2, 3, 0]);
    }

    #[test]
    fn test_tabstop_without_zero() {
        // Template without $0 - navigation ends after last numbered tabstop
        let snippet = ParsedSnippet::parse("${1:first} ${2:second}");

        let order = snippet.tabstop_order();
        assert_eq!(order, vec![1, 2]); // No 0
        assert_eq!(snippet.get_tabstop(0), None);
    }
}

</file>

<file path="src/scriptlet_metadata.rs">
//! Scriptlet codefence metadata parser
//!
//! Parses `\`\`\`metadata` and `\`\`\`schema` codefence blocks from markdown scriptlets.
//! These blocks provide an alternative to the HTML comment metadata format, using
//! JSON directly in labeled code fences.
//!
//! # Example scriptlet with codefences:
//! ````markdown
//! # Quick Todo
//!
//! ```metadata
//! { "name": "Quick Todo", "description": "Add a todo item" }
//! ```
//!
//! ```schema
//! { "input": { "item": { "type": "string", "required": true } } }
//! ```
//!
//! ```ts
//! const { item } = await input();
//! await addTodo(item);
//! ```
//! ````

use crate::metadata_parser::TypedMetadata;
use crate::schema_parser::Schema;
use tracing::debug;

/// Result of parsing codefence metadata from a scriptlet
#[derive(Debug, Clone, Default)]
pub struct CodefenceParseResult {
    /// Parsed metadata from ```metadata block
    pub metadata: Option<TypedMetadata>,
    /// Parsed schema from ```schema block
    pub schema: Option<Schema>,
    /// The code content from the main code block (e.g., ```ts)
    pub code: Option<CodeBlock>,
    /// Parse errors encountered
    pub errors: Vec<String>,
}

/// A code block with its language and content
#[derive(Debug, Clone)]
pub struct CodeBlock {
    /// The language identifier (e.g., "ts", "bash", "python")
    pub language: String,
    /// The code content
    pub content: String,
}

/// Parse codefence blocks from markdown scriptlet content
///
/// Looks for:
/// - `\`\`\`metadata\n{...}\n\`\`\`` - JSON metadata block
/// - `\`\`\`schema\n{...}\n\`\`\`` - JSON schema block  
/// - `\`\`\`<lang>\n...\n\`\`\`` - Main code block
///
/// # Arguments
/// * `content` - The markdown content to parse
///
/// # Returns
/// `CodefenceParseResult` with parsed metadata, schema, code, and any errors
pub fn parse_codefence_metadata(content: &str) -> CodefenceParseResult {
    let mut result = CodefenceParseResult::default();

    let blocks = extract_all_codefence_blocks(content);

    for (language, block_content) in blocks {
        match language.as_str() {
            "metadata" => match serde_json::from_str::<TypedMetadata>(&block_content) {
                Ok(metadata) => {
                    debug!(
                        name = ?metadata.name,
                        description = ?metadata.description,
                        "Parsed codefence metadata"
                    );
                    result.metadata = Some(metadata);
                }
                Err(e) => {
                    result
                        .errors
                        .push(format!("Failed to parse metadata JSON: {}", e));
                }
            },
            "schema" => match serde_json::from_str::<Schema>(&block_content) {
                Ok(schema) => {
                    debug!(
                        input_fields = schema.input.len(),
                        output_fields = schema.output.len(),
                        "Parsed codefence schema"
                    );
                    result.schema = Some(schema);
                }
                Err(e) => {
                    result
                        .errors
                        .push(format!("Failed to parse schema JSON: {}", e));
                }
            },
            // Skip empty language specifier
            "" => {}
            // Any other language is treated as code
            lang => {
                // Only capture the first non-metadata/schema code block
                if result.code.is_none() {
                    result.code = Some(CodeBlock {
                        language: lang.to_string(),
                        content: block_content,
                    });
                }
            }
        }
    }

    result
}

/// Extract all codefence blocks from content
/// Returns Vec of (language, content) tuples
fn extract_all_codefence_blocks(content: &str) -> Vec<(String, String)> {
    let mut blocks = Vec::new();
    let lines: Vec<&str> = content.lines().collect();

    let mut i = 0;
    while i < lines.len() {
        let line = lines[i];
        let trimmed = line.trim_start();

        // Check for opening fence (``` or ~~~)
        if let Some((fence_char, fence_count, language)) = detect_fence_opening(trimmed) {
            let mut block_lines = Vec::new();
            i += 1;

            // Collect content until closing fence
            while i < lines.len() {
                let current = lines[i].trim_start();
                if is_closing_fence(current, fence_char, fence_count) {
                    break;
                }
                block_lines.push(lines[i]);
                i += 1;
            }

            let block_content = block_lines.join("\n");
            blocks.push((language, block_content.trim().to_string()));
        }

        i += 1;
    }

    blocks
}

/// Detect opening fence, returns (fence_char, count, language)
fn detect_fence_opening(line: &str) -> Option<(char, usize, String)> {
    // Try backticks
    let backtick_count = line.chars().take_while(|&c| c == '`').count();
    if backtick_count >= 3 {
        let rest = &line[backtick_count..];
        let language = rest.split_whitespace().next().unwrap_or("").to_string();
        return Some(('`', backtick_count, language));
    }

    // Try tildes
    let tilde_count = line.chars().take_while(|&c| c == '~').count();
    if tilde_count >= 3 {
        let rest = &line[tilde_count..];
        let language = rest.split_whitespace().next().unwrap_or("").to_string();
        return Some(('~', tilde_count, language));
    }

    None
}

/// Check if line is a closing fence
fn is_closing_fence(line: &str, fence_char: char, min_count: usize) -> bool {
    let count = line.chars().take_while(|&c| c == fence_char).count();
    if count < min_count {
        return false;
    }

    // Rest of line should be empty or whitespace
    let rest = &line[count..];
    rest.chars().all(|c| c.is_whitespace())
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::schema_parser::FieldType;

    // ========================================
    // Core Test Cases (from requirements)
    // ========================================

    #[test]
    fn test_parse_metadata_codefence() {
        let content = r#"
# Quick Todo

```metadata
{ "name": "Quick Todo", "description": "Add a todo item" }
```

```ts
const item = await arg("Todo item");
```
"#;
        let result = parse_codefence_metadata(content);

        assert!(result.errors.is_empty(), "Errors: {:?}", result.errors);
        assert!(result.metadata.is_some());

        let metadata = result.metadata.unwrap();
        assert_eq!(metadata.name, Some("Quick Todo".to_string()));
        assert_eq!(metadata.description, Some("Add a todo item".to_string()));
    }

    #[test]
    fn test_parse_schema_codefence() {
        let content = r#"
```schema
{
    "input": {
        "item": { "type": "string", "required": true }
    }
}
```

```ts
const { item } = await input();
```
"#;
        let result = parse_codefence_metadata(content);

        assert!(result.errors.is_empty(), "Errors: {:?}", result.errors);
        assert!(result.schema.is_some());

        let schema = result.schema.unwrap();
        assert_eq!(schema.input.len(), 1);
        assert!(schema.input.contains_key("item"));

        let item_field = schema.input.get("item").unwrap();
        assert_eq!(item_field.field_type, FieldType::String);
        assert!(item_field.required);
    }

    #[test]
    fn test_parse_both_metadata_and_schema() {
        let content = r#"
```metadata
{ "name": "Quick Todo", "description": "Add a todo item", "icon": "CheckSquare" }
```

```schema
{
    "input": {
        "item": { "type": "string", "required": true, "description": "The todo item text" }
    },
    "output": {
        "id": { "type": "string" }
    }
}
```

```ts
const { item } = await input();
const id = await addTodo(item);
output({ id });
```
"#;
        let result = parse_codefence_metadata(content);

        assert!(result.errors.is_empty(), "Errors: {:?}", result.errors);

        // Check metadata
        assert!(result.metadata.is_some());
        let metadata = result.metadata.unwrap();
        assert_eq!(metadata.name, Some("Quick Todo".to_string()));
        assert_eq!(metadata.description, Some("Add a todo item".to_string()));
        assert_eq!(metadata.icon, Some("CheckSquare".to_string()));

        // Check schema
        assert!(result.schema.is_some());
        let schema = result.schema.unwrap();
        assert_eq!(schema.input.len(), 1);
        assert_eq!(schema.output.len(), 1);

        let item_field = schema.input.get("item").unwrap();
        assert_eq!(
            item_field.description,
            Some("The todo item text".to_string())
        );

        assert!(schema.output.contains_key("id"));
    }

    #[test]
    fn test_no_codefence_returns_none() {
        let content = r#"
# Just a Regular Markdown

Some text here with no code fences at all.

- List item 1
- List item 2
"#;
        let result = parse_codefence_metadata(content);

        assert!(result.metadata.is_none());
        assert!(result.schema.is_none());
        assert!(result.code.is_none());
        assert!(result.errors.is_empty());
    }

    #[test]
    fn test_malformed_json_returns_error() {
        let content = r#"
```metadata
{ "name": "Bad JSON, "description": missing quote }
```

```ts
console.log("test");
```
"#;
        let result = parse_codefence_metadata(content);

        assert!(result.metadata.is_none());
        assert!(!result.errors.is_empty());
        assert!(result.errors[0].contains("Failed to parse metadata JSON"));
    }

    #[test]
    fn test_code_block_extracted_correctly() {
        let content = r#"
```metadata
{ "name": "Test Script" }
```

```ts
const result = await arg("Pick one");
console.log(result);
```
"#;
        let result = parse_codefence_metadata(content);

        assert!(result.code.is_some());
        let code = result.code.unwrap();
        assert_eq!(code.language, "ts");
        assert!(code.content.contains("const result = await arg"));
        assert!(code.content.contains("console.log(result)"));
    }

    // ========================================
    // Additional Test Cases
    // ========================================

    #[test]
    fn test_multiple_code_blocks_first_wins() {
        let content = r#"
```ts
first code block
```

```ts
second code block
```
"#;
        let result = parse_codefence_metadata(content);

        assert!(result.code.is_some());
        let code = result.code.unwrap();
        assert_eq!(code.content, "first code block");
    }

    #[test]
    fn test_tilde_fences_supported() {
        let content = r#"
~~~metadata
{ "name": "Tilde Test" }
~~~

~~~ts
console.log("tilde fences");
~~~
"#;
        let result = parse_codefence_metadata(content);

        assert!(result.metadata.is_some());
        assert_eq!(
            result.metadata.unwrap().name,
            Some("Tilde Test".to_string())
        );

        assert!(result.code.is_some());
        assert_eq!(result.code.unwrap().language, "ts");
    }

    #[test]
    fn test_mixed_fence_types() {
        let content = r#"
```metadata
{ "name": "Mixed Fences" }
```

~~~ts
const x = 1;
~~~
"#;
        let result = parse_codefence_metadata(content);

        assert!(result.metadata.is_some());
        assert!(result.code.is_some());
        assert_eq!(result.code.unwrap().language, "ts");
    }

    #[test]
    fn test_metadata_with_all_fields() {
        let content = r#"
```metadata
{
    "name": "Full Script",
    "description": "A complete script",
    "author": "Test Author",
    "enter": "Execute",
    "alias": "fs",
    "icon": "Star",
    "shortcut": "cmd shift f",
    "tags": ["productivity", "utility"],
    "hidden": true,
    "placeholder": "Type something...",
    "cron": "0 9 * * *",
    "watch": ["*.ts", "*.js"],
    "background": true,
    "system": false
}
```
"#;
        let result = parse_codefence_metadata(content);

        assert!(result.errors.is_empty(), "Errors: {:?}", result.errors);
        assert!(result.metadata.is_some());

        let meta = result.metadata.unwrap();
        assert_eq!(meta.name, Some("Full Script".to_string()));
        assert_eq!(meta.description, Some("A complete script".to_string()));
        assert_eq!(meta.author, Some("Test Author".to_string()));
        assert_eq!(meta.enter, Some("Execute".to_string()));
        assert_eq!(meta.alias, Some("fs".to_string()));
        assert_eq!(meta.icon, Some("Star".to_string()));
        assert_eq!(meta.shortcut, Some("cmd shift f".to_string()));
        assert_eq!(meta.tags, vec!["productivity", "utility"]);
        assert!(meta.hidden);
        assert_eq!(meta.placeholder, Some("Type something...".to_string()));
        assert_eq!(meta.cron, Some("0 9 * * *".to_string()));
        assert_eq!(meta.watch, vec!["*.ts", "*.js"]);
        assert!(meta.background);
        assert!(!meta.system);
    }

    #[test]
    fn test_schema_with_all_field_types() {
        let content = r#"
```schema
{
    "input": {
        "name": { "type": "string" },
        "count": { "type": "number" },
        "enabled": { "type": "boolean" },
        "items": { "type": "array", "items": "string" },
        "config": { "type": "object" },
        "anything": { "type": "any" }
    }
}
```
"#;
        let result = parse_codefence_metadata(content);

        assert!(result.errors.is_empty(), "Errors: {:?}", result.errors);
        assert!(result.schema.is_some());

        let schema = result.schema.unwrap();
        assert_eq!(
            schema.input.get("name").unwrap().field_type,
            FieldType::String
        );
        assert_eq!(
            schema.input.get("count").unwrap().field_type,
            FieldType::Number
        );
        assert_eq!(
            schema.input.get("enabled").unwrap().field_type,
            FieldType::Boolean
        );
        assert_eq!(
            schema.input.get("items").unwrap().field_type,
            FieldType::Array
        );
        assert_eq!(
            schema.input.get("config").unwrap().field_type,
            FieldType::Object
        );
        assert_eq!(
            schema.input.get("anything").unwrap().field_type,
            FieldType::Any
        );
    }

    #[test]
    fn test_malformed_schema_json_returns_error() {
        let content = r#"
```schema
{ "input": { not valid json } }
```
"#;
        let result = parse_codefence_metadata(content);

        assert!(result.schema.is_none());
        assert!(!result.errors.is_empty());
        assert!(result.errors[0].contains("Failed to parse schema JSON"));
    }

    #[test]
    fn test_different_code_languages() {
        let languages = vec!["bash", "python", "ruby", "js", "kit", "template"];

        for lang in languages {
            let content = format!(
                r#"
```{}
code content
```
"#,
                lang
            );
            let result = parse_codefence_metadata(&content);

            assert!(result.code.is_some(), "Failed for language: {}", lang);
            assert_eq!(result.code.unwrap().language, lang);
        }
    }

    #[test]
    fn test_empty_codefence_blocks() {
        let content = r#"
```metadata
```

```ts
```
"#;
        let result = parse_codefence_metadata(content);

        // Empty metadata should fail to parse as JSON
        assert!(!result.errors.is_empty() || result.metadata.is_none());

        // Empty code block should still be captured
        assert!(result.code.is_some());
        assert_eq!(result.code.unwrap().content, "");
    }

    #[test]
    fn test_whitespace_handling() {
        let content = r#"
```metadata
  { "name": "Whitespace Test" }  
```

```ts
  const x = 1;  
  const y = 2;  
```
"#;
        let result = parse_codefence_metadata(content);

        assert!(result.metadata.is_some());
        assert_eq!(
            result.metadata.unwrap().name,
            Some("Whitespace Test".to_string())
        );

        assert!(result.code.is_some());
        let code = result.code.unwrap();
        // Content should preserve internal whitespace but trim outer
        assert!(code.content.contains("const x = 1"));
        assert!(code.content.contains("const y = 2"));
    }

    #[test]
    fn test_nested_code_in_markdown() {
        // Simulate a scriptlet that contains a markdown code example
        let content = r#"
```metadata
{ "name": "Code Example Generator" }
```

```ts
const example = `
\`\`\`js
console.log("hello");
\`\`\`
`;
```
"#;
        let result = parse_codefence_metadata(content);

        assert!(result.metadata.is_some());
        assert!(result.code.is_some());
        // The code block should contain the nested fence example
        assert!(result.code.unwrap().content.contains("console.log"));
    }

    #[test]
    fn test_order_independence() {
        // Schema before metadata should still work
        let content = r#"
```schema
{ "input": { "x": { "type": "string" } } }
```

```metadata
{ "name": "Order Test" }
```

```ts
code here
```
"#;
        let result = parse_codefence_metadata(content);

        assert!(result.metadata.is_some());
        assert!(result.schema.is_some());
        assert!(result.code.is_some());

        assert_eq!(
            result.metadata.unwrap().name,
            Some("Order Test".to_string())
        );
        assert!(result.schema.unwrap().input.contains_key("x"));
    }

    #[test]
    fn test_code_block_without_metadata_or_schema() {
        let content = r#"
## Simple Script

```bash
echo "Hello World"
```
"#;
        let result = parse_codefence_metadata(content);

        assert!(result.metadata.is_none());
        assert!(result.schema.is_none());
        assert!(result.code.is_some());

        let code = result.code.unwrap();
        assert_eq!(code.language, "bash");
        assert_eq!(code.content, "echo \"Hello World\"");
    }

    #[test]
    fn test_multiple_errors_collected() {
        let content = r#"
```metadata
{ invalid json 1 }
```

```schema
{ invalid json 2 }
```
"#;
        let result = parse_codefence_metadata(content);

        assert_eq!(result.errors.len(), 2);
        assert!(result.errors[0].contains("metadata"));
        assert!(result.errors[1].contains("schema"));
    }
}

</file>

</files>