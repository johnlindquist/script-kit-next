This file is a merged representation of the filtered codebase, combined into a single document by packx.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of filtered repository contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<usage_guidelines>
- Treat this file as a snapshot of the repository's state
- Be aware that this file may contain sensitive information
</usage_guidelines>

<notes>
- Files were filtered by packx based on content and extension matching
- Total files included: 10
</notes>
</file_summary>

<directory_structure>
src/actions/window.rs
src/actions/dialog.rs
src/actions/constants.rs
src/actions/types.rs
src/components/button.rs
src/focus_coordinator.rs
src/confirm/mod.rs
src/confirm/window.rs
src/confirm/dialog.rs
src/confirm/constants.rs
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="src/actions/window.rs">
//! Actions Window - Separate vibrancy window for actions panel
//!
//! This creates a floating popup window with its own vibrancy blur effect,
//! similar to Raycast's actions panel. The window is:
//! - Non-draggable (fixed position relative to main window)
//! - Positioned below the header, at the right edge of main window
//! - Auto-closes when app loses focus
//! - Shares the ActionsDialog entity with the main app for keyboard routing

use crate::platform;
use crate::theme;
use crate::window_resize::layout::FOOTER_HEIGHT;
use gpui::{
    div, prelude::*, px, App, Bounds, Context, DisplayId, Entity, FocusHandle, Focusable, Pixels,
    Point, Render, Size, Window, WindowBounds, WindowHandle, WindowKind, WindowOptions,
};
use gpui_component::Root;
use std::sync::{Mutex, OnceLock};

use super::constants::{
    ACTION_ITEM_HEIGHT, HEADER_HEIGHT, POPUP_MAX_HEIGHT, SEARCH_INPUT_HEIGHT, SECTION_HEADER_HEIGHT,
};
use super::dialog::ActionsDialog;
use super::types::{Action, SectionStyle};

/// Count the number of section headers in the filtered action list
/// A section header appears when an action's section differs from the previous action's section
fn count_section_headers(actions: &[Action], filtered_indices: &[usize]) -> usize {
    if filtered_indices.is_empty() {
        return 0;
    }

    let mut count = 0;
    let mut prev_section: Option<&Option<String>> = None;

    for &idx in filtered_indices {
        if let Some(action) = actions.get(idx) {
            let current_section = &action.section;
            // Count as header if: first item with a section, or section changed
            if current_section.is_some() {
                match prev_section {
                    None => count += 1,                                  // First item with a section
                    Some(prev) if prev != current_section => count += 1, // Section changed
                    _ => {}
                }
            }
            prev_section = Some(current_section);
        }
    }

    count
}

/// Global singleton for the actions window handle
static ACTIONS_WINDOW: OnceLock<Mutex<Option<WindowHandle<Root>>>> = OnceLock::new();

/// Actions window width (height is calculated dynamically based on content)
const ACTIONS_WINDOW_WIDTH: f32 = 320.0;
/// Horizontal margin from main window right edge
const ACTIONS_MARGIN_X: f32 = 8.0;
/// Vertical margin from header/footer
const ACTIONS_MARGIN_Y: f32 = 8.0;
/// Titlebar height (for top-anchored positioning)
#[allow(dead_code)] // Reserved for future TopRight positioning
const TITLEBAR_HEIGHT: f32 = 36.0;

/// Window position relative to the parent window
#[derive(Debug, Clone, Copy, PartialEq, Eq, Default)]
#[allow(dead_code)] // Some variants reserved for future use
pub enum WindowPosition {
    /// Bottom-right, above the footer (default for Cmd+K actions)
    #[default]
    BottomRight,
    /// Top-right, below the titlebar (for new chat dropdown)
    TopRight,
    /// Top-center, below the titlebar, horizontally centered (Raycast-style for Notes)
    TopCenter,
}

/// ActionsWindow wrapper that renders the shared ActionsDialog entity
pub struct ActionsWindow {
    /// The shared dialog entity (created by main app, rendered here)
    pub dialog: Entity<ActionsDialog>,
    /// Focus handle for this window (not actively used - main window keeps focus)
    pub focus_handle: FocusHandle,
}

impl ActionsWindow {
    pub fn new(dialog: Entity<ActionsDialog>, cx: &mut Context<Self>) -> Self {
        let focus_handle = cx.focus_handle();
        Self {
            dialog,
            focus_handle,
        }
    }
}

impl Focusable for ActionsWindow {
    fn focus_handle(&self, _cx: &App) -> FocusHandle {
        self.focus_handle.clone()
    }
}

impl Render for ActionsWindow {
    fn render(&mut self, window: &mut Window, cx: &mut Context<Self>) -> impl IntoElement {
        // Log focus state AND window focus state
        let is_focused = self.focus_handle.is_focused(window);
        let window_is_active = window.is_window_active();
        crate::logging::log(
            "ACTIONS",
            &format!(
                "ActionsWindow render: focus_handle.is_focused={}, window_is_active={}",
                is_focused, window_is_active
            ),
        );

        // NOTE: We intentionally do NOT focus this window's focus_handle.
        // The parent window (AI window, Notes window, etc.) keeps keyboard focus
        // and routes events to us via its capture_key_down handler.
        // This approach works better on macOS where popup windows often don't
        // receive keyboard events reliably.
        //
        // The on_key_down handler below is still registered as a fallback for
        // cases where the popup window does receive focus (e.g., user clicks on it).

        // Key handler for the actions window
        // Since this is a separate window, it needs its own key handling
        // (the parent window can't route events to us)
        let handle_key = cx.listener(move |this, event: &gpui::KeyDownEvent, window, cx| {
            let key = event.keystroke.key.as_str();
            let modifiers = &event.keystroke.modifiers;

            crate::logging::log(
                "ACTIONS",
                &format!(
                    "ActionsWindow on_key_down received: key='{}', modifiers={:?}",
                    key, modifiers
                ),
            );

            match key {
                "up" | "arrowup" => {
                    crate::logging::log("ACTIONS", "ActionsWindow: handling UP arrow");

                    this.dialog.update(cx, |d, cx| d.move_up(cx));
                    cx.notify();
                }
                "down" | "arrowdown" => {
                    crate::logging::log("ACTIONS", "ActionsWindow: handling DOWN arrow");
                    this.dialog.update(cx, |d, cx| d.move_down(cx));
                    cx.notify();
                }
                "enter" | "return" => {
                    // Get selected action and execute via callback
                    let action_id = this.dialog.read(cx).get_selected_action_id();
                    if let Some(action_id) = action_id {
                        // Execute the action's callback
                        let callback = this.dialog.read(cx).on_select.clone();
                        callback(action_id.clone());
                        // Notify main app to restore focus before closing
                        let on_close = this.dialog.read(cx).on_close.clone();
                        if let Some(callback) = on_close {
                            callback(cx);
                        }
                        // Activate the main window so it can receive focus
                        platform::activate_main_window();
                        // Defer window removal to give the main window time to become key
                        window.defer(cx, |window, _cx| {
                            window.remove_window();
                        });
                    }
                }
                "escape" => {
                    // Notify main app to restore focus before closing
                    let on_close = this.dialog.read(cx).on_close.clone();
                    if let Some(callback) = on_close {
                        callback(cx);
                    }
                    // Activate the main window so it can receive focus
                    platform::activate_main_window();
                    // Defer window removal to give the main window time to become key
                    // and process the pending focus. This matches how close_actions_popup
                    // uses cx.spawn() to close the window asynchronously.
                    window.defer(cx, |window, _cx| {
                        window.remove_window();
                    });
                }
                "backspace" | "delete" => {
                    crate::logging::log("ACTIONS", "ActionsWindow: backspace pressed");
                    this.dialog.update(cx, |d, cx| d.handle_backspace(cx));
                    // Schedule resize after filter changes
                    let dialog = this.dialog.clone();
                    window.defer(cx, move |window, cx| {
                        crate::logging::log("ACTIONS", "ActionsWindow: defer - resizing directly");
                        resize_actions_window_direct(window, cx, &dialog);
                    });
                    cx.notify();
                }
                _ => {
                    // Handle printable characters for search (when no modifiers)
                    if !modifiers.platform && !modifiers.control && !modifiers.alt {
                        if let Some(ch) = key.chars().next() {
                            if ch.is_alphanumeric() || ch.is_whitespace() || ch == '-' || ch == '_'
                            {
                                crate::logging::log(
                                    "ACTIONS",
                                    &format!("ActionsWindow: char '{}' pressed", ch),
                                );
                                this.dialog.update(cx, |d, cx| d.handle_char(ch, cx));
                                // Schedule resize after filter changes
                                let dialog = this.dialog.clone();
                                window.defer(cx, move |window, cx| {
                                    crate::logging::log(
                                        "ACTIONS",
                                        "ActionsWindow: defer - resizing directly",
                                    );
                                    resize_actions_window_direct(window, cx, &dialog);
                                });
                                cx.notify();
                            }
                        }
                    }
                }
            }
        });

        // Render the shared dialog entity with key handling
        // Don't use size_full() - the dialog calculates its own dynamic height
        // This prevents unused window space from showing as a dark area
        div()
            .track_focus(&self.focus_handle)
            .on_key_down(handle_key)
            .child(self.dialog.clone())
    }
}

/// Open the actions window as a separate floating window with vibrancy
///
/// The window is positioned at the top-right of the main window, below the header.
/// It does NOT take keyboard focus - the main window keeps focus and routes
/// keyboard events to the shared ActionsDialog entity.
///
/// # Arguments
/// * `cx` - The application context
/// * `main_window_bounds` - The bounds of the main window in SCREEN-RELATIVE coordinates
///   (as returned by GPUI's window.bounds() - top-left origin relative to the window's screen)
/// * `display_id` - The display where the main window is located (actions window will be on same display)
/// * `dialog_entity` - The shared ActionsDialog entity (created by main app)
/// * `position` - Where to position the window relative to the main window
///
/// # Returns
/// The window handle on success
pub fn open_actions_window(
    cx: &mut App,
    main_window_bounds: Bounds<Pixels>,
    display_id: Option<DisplayId>,
    dialog_entity: Entity<ActionsDialog>,
    position: WindowPosition,
) -> anyhow::Result<WindowHandle<Root>> {
    // Close any existing actions window first
    close_actions_window(cx);

    // Load theme for vibrancy settings
    let theme = theme::load_theme();
    let window_background = if theme.is_vibrancy_enabled() {
        gpui::WindowBackgroundAppearance::Blurred
    } else {
        gpui::WindowBackgroundAppearance::Opaque
    };

    // Calculate dynamic window height based on number of actions
    // This ensures the window fits the content without empty dark space
    let dialog = dialog_entity.read(cx);
    let num_actions = dialog.filtered_actions.len();
    let hide_search = dialog.hide_search;
    let has_header = dialog.context_title.is_some();

    // Count section headers when using Headers style
    let section_header_count = if dialog.config.section_style == SectionStyle::Headers {
        count_section_headers(&dialog.actions, &dialog.filtered_actions)
    } else {
        0
    };

    let search_box_height = if hide_search {
        0.0
    } else {
        SEARCH_INPUT_HEIGHT
    };
    let header_height = if has_header { HEADER_HEIGHT } else { 0.0 };
    let section_headers_height = section_header_count as f32 * SECTION_HEADER_HEIGHT;
    let items_height = (num_actions as f32 * ACTION_ITEM_HEIGHT + section_headers_height)
        .min(POPUP_MAX_HEIGHT - search_box_height - header_height);
    let border_height = 2.0; // top + bottom border
    let dynamic_height = items_height + search_box_height + header_height + border_height;

    // Calculate window position:
    // - X: Right edge of main window, minus actions width, minus margin
    // - Y: Depends on position parameter:
    //   - BottomRight: Above footer, aligned to bottom
    //   - TopRight: Below titlebar, aligned to top
    //
    // CRITICAL: main_window_bounds must be in SCREEN-RELATIVE coordinates from GPUI's
    // window.bounds(). These are top-left origin, relative to the window's current screen.
    // When we pass display_id to WindowOptions, GPUI will position this window on the
    // same screen as the main window, using these screen-relative coordinates.
    let window_width = px(ACTIONS_WINDOW_WIDTH);
    let window_height = px(dynamic_height);

    let window_x = main_window_bounds.origin.x + main_window_bounds.size.width
        - window_width
        - px(ACTIONS_MARGIN_X);

    // Calculate Y position based on anchor position
    let window_y = match position {
        WindowPosition::BottomRight => {
            // Position popup above the footer (footer is 40px)
            main_window_bounds.origin.y + main_window_bounds.size.height
                - window_height
                - px(FOOTER_HEIGHT)
                - px(ACTIONS_MARGIN_Y)
        }
        WindowPosition::TopRight => {
            // Position popup below the titlebar
            main_window_bounds.origin.y + px(TITLEBAR_HEIGHT) + px(ACTIONS_MARGIN_Y)
        }
        WindowPosition::TopCenter => {
            // Position popup below the titlebar (same Y as TopRight)
            main_window_bounds.origin.y + px(TITLEBAR_HEIGHT) + px(ACTIONS_MARGIN_Y)
        }
    };

    // Override X position for TopCenter - center horizontally in the parent window
    let window_x = match position {
        WindowPosition::TopCenter => {
            // Center horizontally within the parent window
            main_window_bounds.origin.x + (main_window_bounds.size.width - window_width) / 2.0
        }
        _ => window_x, // Keep the right-aligned X for other positions
    };

    let bounds = Bounds {
        origin: Point {
            x: window_x,
            y: window_y,
        },
        size: Size {
            width: window_width,
            height: window_height,
        },
    };

    crate::logging::log(
        "ACTIONS",
        &format!(
            "Opening actions window at ({:?}, {:?}), size {:?}x{:?}, display_id={:?}",
            window_x, window_y, window_width, window_height, display_id
        ),
    );

    let window_options = WindowOptions {
        window_bounds: Some(WindowBounds::Windowed(bounds)),
        titlebar: None, // No titlebar = no drag affordance
        window_background,
        // DON'T take focus - let the parent AI window keep focus and route keys to us
        // macOS popup windows often don't receive keyboard events properly
        focus: false,
        show: true,
        kind: WindowKind::PopUp, // Floating popup window
        display_id,              // CRITICAL: Position on same display as main window
        ..Default::default()
    };

    // Create the window with the shared dialog entity
    // NOTE: We DON'T focus the ActionsWindow's focus_handle here.
    // The parent window (AI window, Notes window, etc.) keeps focus and routes
    // keyboard events to us via its own capture_key_down handler.
    // This avoids focus conflicts where both windows try to handle keys.
    let handle = cx.open_window(window_options, |window, cx| {
        let actions_window = cx.new(|cx| ActionsWindow::new(dialog_entity, cx));
        // Wrap in Root for gpui-component theming and vibrancy
        cx.new(|cx| Root::new(actions_window, window, cx))
    })?;

    // Configure the window as non-movable on macOS
    // Use window.defer() to avoid RefCell borrow conflicts - GPUI may still have
    // internal state borrowed immediately after open_window returns.
    #[cfg(target_os = "macos")]
    {
        let _ = handle.update(cx, |_root, window, cx| {
            window.defer(cx, |_window, _cx| {
                use cocoa::appkit::NSApp;
                use cocoa::base::nil;
                use objc::{msg_send, sel, sel_impl};

                // Get the NSWindow from the app's windows array
                // The popup window should be the most recently created one
                unsafe {
                    let app: cocoa::base::id = NSApp();
                    let windows: cocoa::base::id = msg_send![app, windows];
                    let count: usize = msg_send![windows, count];
                    if count > 0 {
                        // Get the last window (most recently created)
                        let ns_window: cocoa::base::id = msg_send![windows, lastObject];
                        if ns_window != nil {
                            platform::configure_actions_popup_window(ns_window);
                        }
                    }
                }
            });
        });
    }

    // Store the handle globally
    let window_storage = ACTIONS_WINDOW.get_or_init(|| Mutex::new(None));
    if let Ok(mut guard) = window_storage.lock() {
        *guard = Some(handle);
    }

    crate::logging::log("ACTIONS", "Actions popup window opened with vibrancy");

    Ok(handle)
}

/// Close the actions window if it's open
pub fn close_actions_window(cx: &mut App) {
    if let Some(window_storage) = ACTIONS_WINDOW.get() {
        if let Ok(mut guard) = window_storage.lock() {
            if let Some(handle) = guard.take() {
                crate::logging::log("ACTIONS", "Closing actions popup window");
                // Close the window
                let _ = handle.update(cx, |_root, window, _cx| {
                    window.remove_window();
                });
            }
        }
    }
}

/// Check if the actions window is currently open
pub fn is_actions_window_open() -> bool {
    if let Some(window_storage) = ACTIONS_WINDOW.get() {
        if let Ok(guard) = window_storage.lock() {
            return guard.is_some();
        }
    }
    false
}

/// Get the actions window handle if it exists
pub fn get_actions_window_handle() -> Option<WindowHandle<Root>> {
    if let Some(window_storage) = ACTIONS_WINDOW.get() {
        if let Ok(guard) = window_storage.lock() {
            return *guard;
        }
    }
    None
}

/// Notify the actions window to re-render (call after updating dialog entity)
pub fn notify_actions_window(cx: &mut App) {
    if let Some(handle) = get_actions_window_handle() {
        let _ = handle.update(cx, |_root, _window, cx| {
            cx.notify();
        });
    }
}

/// Resize the actions window directly using the window reference
/// Use this from defer callbacks where we already have access to the window
pub fn resize_actions_window_direct(
    window: &mut Window,
    cx: &mut App,
    dialog_entity: &Entity<ActionsDialog>,
) {
    // Read dialog state to calculate new height
    let dialog = dialog_entity.read(cx);
    let num_actions = dialog.filtered_actions.len();
    let hide_search = dialog.hide_search;
    let has_header = dialog.context_title.is_some();

    crate::logging::log(
        "ACTIONS",
        &format!(
            "resize_actions_window_direct: num_actions={}, hide_search={}, has_header={}",
            num_actions, hide_search, has_header
        ),
    );

    // Count section headers when using Headers style
    let section_header_count = if dialog.config.section_style == SectionStyle::Headers {
        count_section_headers(&dialog.actions, &dialog.filtered_actions)
    } else {
        0
    };

    // Calculate new height
    let search_box_height = if hide_search {
        0.0
    } else {
        SEARCH_INPUT_HEIGHT
    };
    let header_height = if has_header { HEADER_HEIGHT } else { 0.0 };
    let section_headers_height = section_header_count as f32 * SECTION_HEADER_HEIGHT;
    // When no actions, still need space for "No actions match" message (use 1 row height)
    let min_items_height = if num_actions == 0 {
        ACTION_ITEM_HEIGHT
    } else {
        0.0
    };
    let items_height = (num_actions as f32 * ACTION_ITEM_HEIGHT + section_headers_height)
        .max(min_items_height)
        .min(POPUP_MAX_HEIGHT - search_box_height - header_height);
    let border_height = 2.0;
    let new_height_f32 = items_height + search_box_height + header_height + border_height;

    let current_bounds = window.bounds();
    let current_height_f32: f32 = current_bounds.size.height.into();
    let current_width_f32: f32 = current_bounds.size.width.into();

    crate::logging::log(
        "ACTIONS",
        &format!(
            "resize_actions_window_direct: current={:.0}x{:.0}, target_height={:.0}",
            current_width_f32, current_height_f32, new_height_f32
        ),
    );

    // Skip if height hasn't changed
    if (current_height_f32 - new_height_f32).abs() < 1.0 {
        crate::logging::log(
            "ACTIONS",
            "resize_actions_window_direct: skipping - height unchanged",
        );
        return;
    }

    // Resize via NSWindow to keep bottom pinned
    #[cfg(target_os = "macos")]
    {
        use cocoa::appkit::NSScreen;
        use cocoa::base::nil;
        use cocoa::foundation::{NSPoint, NSRect, NSSize};
        use objc::{msg_send, sel, sel_impl};

        unsafe {
            let ns_app: cocoa::base::id = cocoa::appkit::NSApp();
            let windows: cocoa::base::id = msg_send![ns_app, windows];
            let count: usize = msg_send![windows, count];

            crate::logging::log(
                "ACTIONS",
                &format!(
                    "NSWindow search: looking for {:.0}x{:.0} among {} windows",
                    current_width_f32, current_height_f32, count
                ),
            );

            for i in 0..count {
                let ns_window: cocoa::base::id = msg_send![windows, objectAtIndex: i];
                if ns_window == nil {
                    continue;
                }

                let frame: NSRect = msg_send![ns_window, frame];

                // Match by width (actions window has unique width of 320)
                if (frame.size.width - current_width_f32 as f64).abs() < 2.0
                    && (frame.size.height - current_height_f32 as f64).abs() < 2.0
                {
                    let window_screen: cocoa::base::id = msg_send![ns_window, screen];
                    if window_screen == nil {
                        let screens: cocoa::base::id = NSScreen::screens(nil);
                        let _primary: cocoa::base::id = msg_send![screens, objectAtIndex: 0u64];
                    }

                    // Keep bottom fixed by keeping origin.y the same
                    let new_frame = NSRect::new(
                        NSPoint::new(frame.origin.x, frame.origin.y),
                        NSSize::new(frame.size.width, new_height_f32 as f64),
                    );

                    let _: () = msg_send![ns_window, setFrame:new_frame display:true animate:false];

                    crate::logging::log(
                        "ACTIONS",
                        &format!(
                            "Resized actions window (bottom pinned): height {:.0} -> {:.0}",
                            current_height_f32, new_height_f32
                        ),
                    );
                    break;
                }
            }
        }
    }

    // Also tell GPUI about the new size
    window.resize(gpui::Size {
        width: current_bounds.size.width,
        height: px(new_height_f32),
    });

    crate::logging::log(
        "ACTIONS",
        &format!(
            "resize_actions_window_direct complete: {} items, height={:.0}",
            num_actions, new_height_f32
        ),
    );
}

/// Resize the actions window to fit the current number of filtered actions
/// Call this after filtering changes the action count
///
/// The window is "pinned to bottom" - the search input stays in place and
/// the window shrinks/grows from the top.
pub fn resize_actions_window(cx: &mut App, dialog_entity: &Entity<ActionsDialog>) {
    crate::logging::log("ACTIONS", "resize_actions_window called");
    if let Some(handle) = get_actions_window_handle() {
        // Read dialog state to calculate new height
        let dialog = dialog_entity.read(cx);
        let num_actions = dialog.filtered_actions.len();
        let hide_search = dialog.hide_search;
        let has_header = dialog.context_title.is_some();
        crate::logging::log(
            "ACTIONS",
            &format!(
                "resize_actions_window: num_actions={}, hide_search={}, has_header={}",
                num_actions, hide_search, has_header
            ),
        );

        // Count section headers when using Headers style
        let section_header_count = if dialog.config.section_style == SectionStyle::Headers {
            count_section_headers(&dialog.actions, &dialog.filtered_actions)
        } else {
            0
        };

        // Calculate new height (same logic as open_actions_window)
        let search_box_height = if hide_search {
            0.0
        } else {
            SEARCH_INPUT_HEIGHT
        };
        let header_height = if has_header { HEADER_HEIGHT } else { 0.0 };
        let section_headers_height = section_header_count as f32 * SECTION_HEADER_HEIGHT;
        // When no actions, still need space for "No actions match" message
        let min_items_height = if num_actions == 0 {
            ACTION_ITEM_HEIGHT
        } else {
            0.0
        };
        let items_height = (num_actions as f32 * ACTION_ITEM_HEIGHT + section_headers_height)
            .max(min_items_height)
            .min(POPUP_MAX_HEIGHT - search_box_height - header_height);
        let border_height = 2.0; // top + bottom border
        let new_height_f32 = items_height + search_box_height + header_height + border_height;

        let update_result = handle.update(cx, |_root, window, cx| {
            let current_bounds = window.bounds();
            let current_height_f32: f32 = current_bounds.size.height.into();
            let current_width_f32: f32 = current_bounds.size.width.into();

            crate::logging::log(
                "ACTIONS",
                &format!(
                    "resize_actions_window inside update: current={:.0}x{:.0}, target_height={:.0}",
                    current_width_f32, current_height_f32, new_height_f32
                ),
            );

            // Skip if height hasn't changed
            if (current_height_f32 - new_height_f32).abs() < 1.0 {
                crate::logging::log(
                    "ACTIONS",
                    "resize_actions_window: skipping - height unchanged",
                );
                return;
            }

            // "Pin to bottom": keep the bottom edge fixed
            // In macOS screen coords (bottom-left origin), the bottom of the window
            // is at frame.origin.y. When we change height, we keep origin.y the same
            // and only change height - this naturally keeps the bottom fixed.
            #[cfg(target_os = "macos")]
            {
                use cocoa::appkit::NSScreen;
                use cocoa::base::nil;
                use cocoa::foundation::{NSPoint, NSRect, NSSize};
                use objc::{msg_send, sel, sel_impl};

                unsafe {
                    let ns_app: cocoa::base::id = cocoa::appkit::NSApp();
                    let windows: cocoa::base::id = msg_send![ns_app, windows];
                    let count: usize = msg_send![windows, count];

                    crate::logging::log(
                        "ACTIONS",
                        &format!(
                            "NSWindow search: looking for {:.0}x{:.0} among {} windows",
                            current_width_f32, current_height_f32, count
                        ),
                    );

                    // Find our actions window by matching current dimensions
                    let mut found = false;
                    for i in 0..count {
                        let ns_window: cocoa::base::id = msg_send![windows, objectAtIndex: i];
                        if ns_window == nil {
                            continue;
                        }

                        let frame: NSRect = msg_send![ns_window, frame];

                        // Match by width (actions window has unique width)
                        if (frame.size.width - current_width_f32 as f64).abs() < 2.0
                            && (frame.size.height - current_height_f32 as f64).abs() < 2.0
                        {
                            // Get the screen this window is on (NOT primary screen!)
                            let window_screen: cocoa::base::id = msg_send![ns_window, screen];
                            if window_screen == nil {
                                // Fallback to primary if no screen
                                let screens: cocoa::base::id = NSScreen::screens(nil);
                                let _primary: cocoa::base::id =
                                    msg_send![screens, objectAtIndex: 0u64];
                            }

                            // In macOS coords (bottom-left origin):
                            // - frame.origin.y is the BOTTOM of the window
                            // - To keep bottom fixed, we keep origin.y the same
                            // - Only change the height
                            let new_frame = NSRect::new(
                                NSPoint::new(frame.origin.x, frame.origin.y),
                                NSSize::new(frame.size.width, new_height_f32 as f64),
                            );

                            let _: () =
                                msg_send![ns_window, setFrame:new_frame display:true animate:false];

                            crate::logging::log(
                                "ACTIONS",
                                &format!(
                                    "Resized actions window (bottom pinned): height {:.0} -> {:.0}",
                                    current_height_f32, new_height_f32
                                ),
                            );
                            found = true;
                            break;
                        }
                    }
                    if !found {
                        crate::logging::log(
                            "ACTIONS",
                            &format!(
                                "NSWindow NOT FOUND - no window matches {:.0}x{:.0}",
                                current_width_f32, current_height_f32
                            ),
                        );
                    }
                }
            }

            // Also tell GPUI about the new size
            window.resize(Size {
                width: current_bounds.size.width,
                height: px(new_height_f32),
            });
            cx.notify();
        });

        if let Err(e) = update_result {
            crate::logging::log("ACTIONS", &format!("handle.update FAILED: {:?}", e));
        }

        crate::logging::log(
            "ACTIONS",
            &format!(
                "Resized actions window: {} items, height={:.0}",
                num_actions, new_height_f32
            ),
        );
    }
}

</file>

<file path="src/actions/dialog.rs">
//! Actions Dialog
//!
//! The main ActionsDialog struct and its implementation, providing a searchable
//! action menu as a compact overlay popup.

#![allow(dead_code)]

use crate::components::scrollbar::{Scrollbar, ScrollbarColors};
use crate::designs::{get_tokens, DesignColors, DesignVariant};
use crate::logging;
use crate::protocol::ProtocolAction;
use crate::theme;
use gpui::{
    div, list, prelude::*, px, rgb, rgba, svg, App, BoxShadow, Context, ElementId, FocusHandle,
    Focusable, ListAlignment, ListState, Render, SharedString, Window,
};
use std::sync::Arc;

use super::builders::{
    get_chat_context_actions, get_clipboard_history_context_actions, get_file_context_actions,
    get_global_actions, get_path_context_actions, get_script_context_actions,
    get_scriptlet_context_actions_with_custom, ChatPromptInfo, ClipboardEntryInfo,
};
use super::constants::{
    ACTION_ITEM_HEIGHT, ACTION_ROW_INSET, HEADER_HEIGHT, KEYCAP_HEIGHT, KEYCAP_MIN_WIDTH,
    POPUP_MAX_HEIGHT, POPUP_WIDTH, SEARCH_INPUT_HEIGHT, SECTION_HEADER_HEIGHT, SELECTION_RADIUS,
};
use crate::file_search::FileInfo;
use crate::scriptlets::Scriptlet;

// Keep ACCENT_BAR_WIDTH for backwards compatibility during transition
#[allow(unused_imports)]
use super::constants::ACCENT_BAR_WIDTH;
#[allow(unused_imports)] // AnchorPosition reserved for future use
use super::types::{
    Action, ActionCallback, ActionCategory, ActionsDialogConfig, AnchorPosition, CloseCallback,
    ScriptInfo, SearchPosition, SectionStyle,
};
use crate::prompts::PathInfo;

/// Helper function to combine a hex color with an alpha value
/// Delegates to DesignColors::hex_with_alpha for DRY
#[inline]
fn hex_with_alpha(hex: u32, alpha: u8) -> u32 {
    DesignColors::hex_with_alpha(hex, alpha)
}

/// Grouped action item for variable-height list rendering
/// Section headers are 24px, action items are 44px
#[derive(Clone, Debug)]
pub enum GroupedActionItem {
    /// A section header (e.g., "Actions", "Navigation")
    SectionHeader(String),
    /// An action item - usize is the index in filtered_actions
    Item(usize),
}

/// Coerce action selection to skip section headers during navigation
///
/// When the given index lands on a header:
/// 1. First tries searching DOWN to find the next Item
/// 2. If not found, searches UP to find the previous Item
/// 3. If still not found, returns None
fn coerce_action_selection(rows: &[GroupedActionItem], ix: usize) -> Option<usize> {
    if rows.is_empty() {
        return None;
    }

    let ix = ix.min(rows.len() - 1);

    // If already on a selectable item, done
    if matches!(rows[ix], GroupedActionItem::Item(_)) {
        return Some(ix);
    }

    // Search down for next selectable
    for (j, item) in rows.iter().enumerate().skip(ix + 1) {
        if matches!(item, GroupedActionItem::Item(_)) {
            return Some(j);
        }
    }

    // Search up for previous selectable
    for (j, item) in rows.iter().enumerate().take(ix).rev() {
        if matches!(item, GroupedActionItem::Item(_)) {
            return Some(j);
        }
    }

    None
}

/// Build grouped items from actions and filtered_actions
/// This is a static helper used during construction to avoid borrowing issues
fn build_grouped_items_static(
    actions: &[Action],
    filtered_actions: &[usize],
    section_style: SectionStyle,
) -> Vec<GroupedActionItem> {
    let mut grouped = Vec::new();

    if filtered_actions.is_empty() {
        return grouped;
    }

    let mut prev_section: Option<String> = None;
    let mut prev_category: Option<ActionCategory> = None;

    for (filter_idx, &action_idx) in filtered_actions.iter().enumerate() {
        if let Some(action) = actions.get(action_idx) {
            match section_style {
                SectionStyle::Headers => {
                    // Add section header when section changes
                    if let Some(ref section) = action.section {
                        if prev_section.as_ref() != Some(section) {
                            grouped.push(GroupedActionItem::SectionHeader(section.clone()));
                            prev_section = Some(section.clone());
                        }
                    }
                }
                SectionStyle::Separators | SectionStyle::None => {
                    // For separators, we track category changes but don't add headers
                    // (separators are rendered inline in the item renderer)
                    prev_category = Some(action.category.clone());
                }
            }
            grouped.push(GroupedActionItem::Item(filter_idx));
        }
    }

    // Suppress unused variable warning
    let _ = prev_category;

    grouped
}

/// ActionsDialog - Compact overlay popup for quick actions
/// Implements Raycast-style design with individual keycap shortcuts
///
/// # Configuration
/// Use `ActionsDialogConfig` to customize appearance:
/// - `search_position`: Top (AI chat style) or Bottom (main menu style)
/// - `section_style`: Headers (text labels) or Separators (subtle lines)
/// - `anchor`: Top (list grows down) or Bottom (list grows up)
/// - `show_icons`: Display icons next to actions
/// - `show_footer`: Show keyboard hint footer
pub struct ActionsDialog {
    pub actions: Vec<Action>,
    pub filtered_actions: Vec<usize>, // Indices into actions
    pub selected_index: usize,        // Index within grouped_items (visual row index)
    pub search_text: String,
    pub focus_handle: FocusHandle,
    pub on_select: ActionCallback,
    /// Currently focused script for context-aware actions
    pub focused_script: Option<ScriptInfo>,
    /// Currently focused scriptlet (for H3-defined custom actions)
    pub focused_scriptlet: Option<Scriptlet>,
    /// List state for variable-height list (section headers 24px, items 44px)
    pub list_state: ListState,
    /// Grouped items for list rendering (includes section headers)
    pub grouped_items: Vec<GroupedActionItem>,
    /// Theme for consistent color styling
    pub theme: Arc<theme::Theme>,
    /// Design variant for styling (defaults to Default for theme-based styling)
    pub design_variant: DesignVariant,
    /// Cursor visibility for blinking (controlled externally)
    pub cursor_visible: bool,
    /// When true, hide the search input (used when rendered inline in main.rs header)
    pub hide_search: bool,
    /// SDK-provided actions (when present, replaces built-in actions)
    pub sdk_actions: Option<Vec<ProtocolAction>>,
    /// Context title shown in the header (e.g., "Activity Monitor", script name)
    pub context_title: Option<String>,
    /// Configuration for appearance and behavior
    pub config: ActionsDialogConfig,
    /// When true, skip track_focus in render (parent handles focus, e.g., ActionsWindow)
    pub skip_track_focus: bool,
    /// Callback for when the dialog is closed (escape pressed, window dismissed)
    /// Used to notify the main app to restore focus
    pub on_close: Option<CloseCallback>,
}

impl ActionsDialog {
    pub fn new(
        focus_handle: FocusHandle,
        on_select: ActionCallback,
        theme: Arc<theme::Theme>,
    ) -> Self {
        Self::with_script_and_design(focus_handle, on_select, None, theme, DesignVariant::Default)
    }

    pub fn with_script(
        focus_handle: FocusHandle,
        on_select: ActionCallback,
        focused_script: Option<ScriptInfo>,
        theme: Arc<theme::Theme>,
    ) -> Self {
        Self::with_script_and_design(
            focus_handle,
            on_select,
            focused_script,
            theme,
            DesignVariant::Default,
        )
    }

    pub fn with_design(
        focus_handle: FocusHandle,
        on_select: ActionCallback,
        theme: Arc<theme::Theme>,
        design_variant: DesignVariant,
    ) -> Self {
        Self::with_script_and_design(focus_handle, on_select, None, theme, design_variant)
    }

    /// Create ActionsDialog for a path (file/folder) with path-specific actions
    pub fn with_path(
        focus_handle: FocusHandle,
        on_select: ActionCallback,
        path_info: &PathInfo,
        theme: Arc<theme::Theme>,
    ) -> Self {
        let actions = get_path_context_actions(path_info);
        let filtered_actions: Vec<usize> = (0..actions.len()).collect();
        let config = ActionsDialogConfig::default();
        let grouped_items =
            build_grouped_items_static(&actions, &filtered_actions, config.section_style);
        let list_state = ListState::new(grouped_items.len(), ListAlignment::Top, px(100.));

        logging::log(
            "ACTIONS",
            &format!(
                "ActionsDialog created for path: {} (is_dir={}) with {} actions",
                path_info.path,
                path_info.is_dir,
                actions.len()
            ),
        );

        ActionsDialog {
            actions,
            filtered_actions,
            selected_index: 0,
            search_text: String::new(),
            focus_handle,
            on_select,
            focused_script: None,
            focused_scriptlet: None,
            list_state,
            grouped_items,
            theme,
            design_variant: DesignVariant::Default,
            cursor_visible: true,
            hide_search: false,
            sdk_actions: None,
            context_title: Some(path_info.path.clone()),
            config,
            skip_track_focus: false,
            on_close: None,
        }
    }

    /// Create ActionsDialog for a file search result with file-specific actions
    /// Actions: Open, Show in Finder, Quick Look, Open With..., Show Info, Copy Path
    pub fn with_file(
        focus_handle: FocusHandle,
        on_select: ActionCallback,
        file_info: &FileInfo,
        theme: Arc<theme::Theme>,
    ) -> Self {
        let actions = get_file_context_actions(file_info);
        let filtered_actions: Vec<usize> = (0..actions.len()).collect();
        let config = ActionsDialogConfig::default();
        let grouped_items =
            build_grouped_items_static(&actions, &filtered_actions, config.section_style);
        let list_state = ListState::new(grouped_items.len(), ListAlignment::Top, px(100.));

        logging::log(
            "ACTIONS",
            &format!(
                "ActionsDialog created for file: {} (is_dir={}) with {} actions",
                file_info.path,
                file_info.is_dir,
                actions.len()
            ),
        );

        ActionsDialog {
            actions,
            filtered_actions,
            selected_index: 0,
            search_text: String::new(),
            focus_handle,
            on_select,
            focused_script: None,
            focused_scriptlet: None,
            list_state,
            grouped_items,
            theme,
            design_variant: DesignVariant::Default,
            cursor_visible: true,
            hide_search: false,
            sdk_actions: None,
            context_title: Some(file_info.name.clone()),
            config,
            skip_track_focus: false,
            on_close: None,
        }
    }

    /// Create ActionsDialog for a clipboard history entry with clipboard-specific actions
    /// Actions: Paste, Copy, Paste and Keep Open, Share, Attach to AI, Pin/Unpin, Delete, etc.
    pub fn with_clipboard_entry(
        focus_handle: FocusHandle,
        on_select: ActionCallback,
        entry_info: &ClipboardEntryInfo,
        theme: Arc<theme::Theme>,
    ) -> Self {
        let actions = get_clipboard_history_context_actions(entry_info);
        let filtered_actions: Vec<usize> = (0..actions.len()).collect();
        let config = ActionsDialogConfig::default();
        let grouped_items =
            build_grouped_items_static(&actions, &filtered_actions, config.section_style);
        let list_state = ListState::new(grouped_items.len(), ListAlignment::Top, px(100.));

        let context_title = if entry_info.preview.len() > 30 {
            format!("{}...", &entry_info.preview[..27])
        } else {
            entry_info.preview.clone()
        };

        logging::log(
            "ACTIONS",
            &format!(
                "ActionsDialog created for clipboard entry: {} (type={:?}, pinned={}) with {} actions",
                entry_info.id,
                entry_info.content_type,
                entry_info.pinned,
                actions.len()
            ),
        );

        ActionsDialog {
            actions,
            filtered_actions,
            selected_index: 0,
            search_text: String::new(),
            focus_handle,
            on_select,
            focused_script: None,
            focused_scriptlet: None,
            list_state,
            grouped_items,
            theme,
            design_variant: DesignVariant::Default,
            cursor_visible: true,
            hide_search: false,
            sdk_actions: None,
            context_title: Some(context_title),
            config,
            skip_track_focus: false,
            on_close: None,
        }
    }

    /// Create ActionsDialog for a chat prompt with chat-specific actions
    /// Actions: Model selection, Continue in Chat, Copy Response, Clear Conversation
    pub fn with_chat(
        focus_handle: FocusHandle,
        on_select: ActionCallback,
        chat_info: &ChatPromptInfo,
        theme: Arc<theme::Theme>,
    ) -> Self {
        let actions = get_chat_context_actions(chat_info);
        let filtered_actions: Vec<usize> = (0..actions.len()).collect();
        let config = ActionsDialogConfig::default();
        let grouped_items =
            build_grouped_items_static(&actions, &filtered_actions, config.section_style);
        let list_state = ListState::new(grouped_items.len(), ListAlignment::Top, px(100.));

        let context_title = chat_info
            .current_model
            .clone()
            .unwrap_or_else(|| "Chat".to_string());

        logging::log(
            "ACTIONS",
            &format!(
                "ActionsDialog created for chat prompt: model={:?} with {} actions",
                chat_info.current_model,
                actions.len()
            ),
        );

        ActionsDialog {
            actions,
            filtered_actions,
            selected_index: 0,
            search_text: String::new(),
            focus_handle,
            on_select,
            focused_script: None,
            focused_scriptlet: None,
            list_state,
            grouped_items,
            theme,
            design_variant: DesignVariant::Default,
            cursor_visible: true,
            hide_search: false,
            sdk_actions: None,
            context_title: Some(context_title),
            config,
            skip_track_focus: false,
            on_close: None,
        }
    }

    pub fn with_script_and_design(
        focus_handle: FocusHandle,
        on_select: ActionCallback,
        focused_script: Option<ScriptInfo>,
        theme: Arc<theme::Theme>,
        design_variant: DesignVariant,
    ) -> Self {
        let actions = Self::build_actions(&focused_script, &None);
        let filtered_actions: Vec<usize> = (0..actions.len()).collect();
        let config = ActionsDialogConfig::default();
        let grouped_items =
            build_grouped_items_static(&actions, &filtered_actions, config.section_style);
        let list_state = ListState::new(grouped_items.len(), ListAlignment::Top, px(100.));

        logging::log(
            "ACTIONS",
            &format!(
                "ActionsDialog created with {} actions, script: {:?}, design: {:?}",
                actions.len(),
                focused_script.as_ref().map(|s| &s.name),
                design_variant
            ),
        );

        // Log theme color configuration for debugging
        logging::log("ACTIONS_THEME", &format!(
            "Theme colors applied: bg_main=#{:06x}, bg_search=#{:06x}, text_primary=#{:06x}, accent_selected=#{:06x}",
            theme.colors.background.main,
            theme.colors.background.search_box,
            theme.colors.text.primary,
            theme.colors.accent.selected
        ));

        // Extract context title from focused script if available
        let context_title = focused_script.as_ref().map(|s| s.name.clone());

        ActionsDialog {
            actions,
            filtered_actions,
            selected_index: 0,
            search_text: String::new(),
            focus_handle,
            on_select,
            focused_script,
            focused_scriptlet: None,
            list_state,
            grouped_items,
            theme,
            design_variant,
            cursor_visible: true,
            hide_search: false,
            sdk_actions: None,
            context_title,
            config,
            skip_track_focus: false,
            on_close: None,
        }
    }

    /// Update cursor visibility (called from parent's blink timer)
    pub fn set_cursor_visible(&mut self, visible: bool) {
        self.cursor_visible = visible;
    }

    /// Hide the search input (for inline mode where header has search)
    pub fn set_hide_search(&mut self, hide: bool) {
        self.hide_search = hide;
    }

    /// Set the context title shown in the header
    pub fn set_context_title(&mut self, title: Option<String>) {
        self.context_title = title;
    }

    /// Set the configuration for appearance and behavior
    pub fn set_config(&mut self, config: ActionsDialogConfig) {
        self.config = config;
        // Update hide_search based on config for backwards compatibility
        self.hide_search = matches!(self.config.search_position, SearchPosition::Hidden);
    }

    /// Set skip_track_focus to let parent handle focus (used by ActionsWindow)
    pub fn set_skip_track_focus(&mut self, skip: bool) {
        self.skip_track_focus = skip;
    }

    /// Set the callback for when the dialog is closed (escape pressed, window dismissed)
    /// Used to notify the main app to restore focus
    pub fn set_on_close(&mut self, callback: CloseCallback) {
        self.on_close = Some(callback);
    }

    /// Call the on_close callback if set
    /// Returns true if a callback was called, false otherwise
    pub fn trigger_on_close(&self, cx: &mut gpui::App) -> bool {
        if let Some(ref callback) = self.on_close {
            callback(cx);
            true
        } else {
            false
        }
    }

    /// Create ActionsDialog with custom configuration and actions
    ///
    /// Use this for contexts like AI chat that need different appearance:
    /// - Search at top instead of bottom
    /// - Section headers instead of separators
    /// - Icons next to actions
    pub fn with_config(
        focus_handle: FocusHandle,
        on_select: ActionCallback,
        actions: Vec<Action>,
        theme: Arc<theme::Theme>,
        config: ActionsDialogConfig,
    ) -> Self {
        let filtered_actions: Vec<usize> = (0..actions.len()).collect();
        let grouped_items =
            build_grouped_items_static(&actions, &filtered_actions, config.section_style);
        let list_state = ListState::new(grouped_items.len(), ListAlignment::Top, px(100.));

        // Coerce initial selection to skip section headers
        let initial_selection = coerce_action_selection(&grouped_items, 0).unwrap_or(0);

        logging::log(
            "ACTIONS",
            &format!(
                "ActionsDialog created with config: {} actions, search={:?}, section_style={:?}, initial_selection={}",
                actions.len(),
                config.search_position,
                config.section_style,
                initial_selection
            ),
        );

        ActionsDialog {
            actions,
            filtered_actions,
            selected_index: initial_selection,
            search_text: String::new(),
            focus_handle,
            on_select,
            focused_script: None,
            focused_scriptlet: None,
            list_state,
            grouped_items,
            theme,
            design_variant: DesignVariant::Default,
            cursor_visible: true,
            hide_search: matches!(config.search_position, SearchPosition::Hidden),
            sdk_actions: None,
            context_title: None,
            config,
            skip_track_focus: false,
            on_close: None,
        }
    }

    /// Parse a shortcut string into individual keycap characters
    /// e.g., ""  vec!["", ""], "I"  vec!["", "I"]
    fn parse_shortcut_keycaps(shortcut: &str) -> Vec<String> {
        let mut keycaps = Vec::new();

        for ch in shortcut.chars() {
            // Handle modifier symbols (single character)
            match ch {
                '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' | '' =>
                {
                    keycaps.push(ch.to_string());
                }
                // Regular characters (letters, numbers)
                _ => {
                    keycaps.push(ch.to_uppercase().to_string());
                }
            }
        }

        keycaps
    }

    /// Set actions from SDK (replaces built-in actions)
    ///
    /// Converts `ProtocolAction` items to internal `Action` format and updates
    /// the actions list. Filters out actions with `visible: false`.
    /// The `has_action` field on each action determines routing:
    /// - `has_action=true`: Send ActionTriggered back to SDK
    /// - `has_action=false`: Submit value directly
    pub fn set_sdk_actions(&mut self, actions: Vec<ProtocolAction>) {
        let total_count = actions.len();
        let visible_actions: Vec<&ProtocolAction> =
            actions.iter().filter(|a| a.is_visible()).collect();
        let visible_count = visible_actions.len();

        let converted: Vec<Action> = visible_actions
            .iter()
            .map(|pa| Action {
                id: pa.name.clone(),
                title: pa.name.clone(),
                description: pa.description.clone(),
                category: ActionCategory::ScriptContext,
                shortcut: pa.shortcut.as_ref().map(|s| Self::format_shortcut_hint(s)),
                has_action: pa.has_action,
                value: pa.value.clone(),
                icon: None,    // SDK actions don't currently have icons
                section: None, // SDK actions don't currently have sections
            })
            .collect();

        logging::log(
            "ACTIONS",
            &format!(
                "SDK actions set: {} visible of {} total",
                visible_count, total_count
            ),
        );

        self.actions = converted;
        self.filtered_actions = (0..self.actions.len()).collect();
        self.search_text.clear();
        self.sdk_actions = Some(actions);
        // Rebuild grouped items and reset selection
        self.rebuild_grouped_items();
        self.selected_index = coerce_action_selection(&self.grouped_items, 0).unwrap_or(0);
    }

    /// Format a keyboard shortcut for display (e.g., "cmd+c"  "C")
    fn format_shortcut_hint(shortcut: &str) -> String {
        let mut result = String::new();
        let parts: Vec<&str> = shortcut.split('+').collect();

        for (i, part) in parts.iter().enumerate() {
            let part_lower = part.trim().to_lowercase();
            let formatted = match part_lower.as_str() {
                // Modifier keys  symbols
                "cmd" | "command" | "meta" | "super" => "",
                "ctrl" | "control" => "",
                "alt" | "opt" | "option" => "",
                "shift" => "",
                // Special keys
                "enter" | "return" => "",
                "escape" | "esc" => "",
                "tab" => "",
                "backspace" | "delete" => "",
                "space" => "",
                "up" | "arrowup" => "",
                "down" | "arrowdown" => "",
                "left" | "arrowleft" => "",
                "right" | "arrowright" => "",
                // Regular letters/numbers  uppercase
                _ => {
                    // Check if it's the last part (the actual key)
                    if i == parts.len() - 1 {
                        // Uppercase single characters, keep others as-is
                        result.push_str(&part.trim().to_uppercase());
                        continue;
                    }
                    part.trim()
                }
            };
            result.push_str(formatted);
        }

        result
    }

    /// Clear SDK actions and restore built-in actions
    pub fn clear_sdk_actions(&mut self) {
        if self.sdk_actions.is_some() {
            logging::log(
                "ACTIONS",
                "Clearing SDK actions, restoring built-in actions",
            );
            self.sdk_actions = None;
            self.actions = Self::build_actions(&self.focused_script, &self.focused_scriptlet);
            self.filtered_actions = (0..self.actions.len()).collect();
            self.search_text.clear();
            // Rebuild grouped items and reset selection
            self.rebuild_grouped_items();
            self.selected_index = coerce_action_selection(&self.grouped_items, 0).unwrap_or(0);
        }
    }

    /// Check if SDK actions are currently active
    pub fn has_sdk_actions(&self) -> bool {
        self.sdk_actions.is_some()
    }

    /// Get the currently selected action (for external handling)
    pub fn get_selected_action(&self) -> Option<&Action> {
        // Get the filter_idx from grouped_items, then action_idx from filtered_actions
        match self.grouped_items.get(self.selected_index) {
            Some(GroupedActionItem::Item(filter_idx)) => self
                .filtered_actions
                .get(*filter_idx)
                .and_then(|&idx| self.actions.get(idx)),
            _ => None, // Section headers are not selectable
        }
    }

    /// Count the number of section headers in the filtered action list
    /// A section header appears when an action's section differs from the previous action's section
    pub fn count_section_headers(&self) -> usize {
        if self.filtered_actions.is_empty() {
            return 0;
        }

        let mut count = 0;
        let mut prev_section: Option<&Option<String>> = None;

        for &idx in &self.filtered_actions {
            if let Some(action) = self.actions.get(idx) {
                let current_section = &action.section;
                // Count as header if: first item with a section, or section changed
                if current_section.is_some() {
                    match prev_section {
                        None => count += 1,                                  // First item with a section
                        Some(prev) if prev != current_section => count += 1, // Section changed
                        _ => {}
                    }
                }
                prev_section = Some(current_section);
            }
        }

        count
    }

    /// Build the complete actions list based on focused script and optional scriptlet
    fn build_actions(
        focused_script: &Option<ScriptInfo>,
        focused_scriptlet: &Option<Scriptlet>,
    ) -> Vec<Action> {
        let mut actions = Vec::new();

        // Add script-specific actions first if a script is focused
        if let Some(script) = focused_script {
            // If this is a scriptlet with custom actions, use the enhanced builder
            if script.is_scriptlet && focused_scriptlet.is_some() {
                actions.extend(get_scriptlet_context_actions_with_custom(
                    script,
                    focused_scriptlet.as_ref(),
                ));
            } else {
                // Use standard actions for regular scripts
                actions.extend(get_script_context_actions(script));
            }
        }

        // Add global actions
        actions.extend(get_global_actions());

        actions
    }

    /// Update the focused script and rebuild actions
    pub fn set_focused_script(&mut self, script: Option<ScriptInfo>) {
        self.focused_script = script;
        self.focused_scriptlet = None; // Clear scriptlet when only setting script
        self.actions = Self::build_actions(&self.focused_script, &self.focused_scriptlet);
        self.refilter();
    }

    /// Update both the focused script and scriptlet for custom actions
    ///
    /// Use this when the focused item is a scriptlet with H3-defined custom actions.
    /// The scriptlet's actions will appear in the Actions Menu.
    pub fn set_focused_scriptlet(
        &mut self,
        script: Option<ScriptInfo>,
        scriptlet: Option<Scriptlet>,
    ) {
        self.focused_script = script;
        self.focused_scriptlet = scriptlet;
        self.actions = Self::build_actions(&self.focused_script, &self.focused_scriptlet);
        self.refilter();

        logging::log(
            "ACTIONS",
            &format!(
                "Set focused scriptlet with {} custom actions",
                self.focused_scriptlet
                    .as_ref()
                    .map(|s| s.actions.len())
                    .unwrap_or(0)
            ),
        );
    }

    /// Update the theme when hot-reloading
    /// Call this from the parent when theme changes to ensure dialog reflects new colors
    pub fn update_theme(&mut self, theme: Arc<theme::Theme>) {
        logging::log("ACTIONS_THEME", "Theme updated in ActionsDialog");
        self.theme = theme;
    }

    /// Refilter actions based on current search_text using ranked fuzzy matching.
    ///
    /// Scoring system:
    /// - Prefix match on title: +100 (strongest signal)
    /// - Fuzzy match on title: +50 + character bonus
    /// - Contains match on description: +25
    /// - Results are sorted by score (descending)
    fn refilter(&mut self) {
        // Preserve selection if possible (track which action was selected)
        let previously_selected = self
            .filtered_actions
            .get(self.selected_index)
            .and_then(|&idx| self.actions.get(idx).map(|a| a.id.clone()));

        if self.search_text.is_empty() {
            self.filtered_actions = (0..self.actions.len()).collect();
        } else {
            let search_lower = self.search_text.to_lowercase();

            // Score each action and collect (index, score) pairs
            let mut scored: Vec<(usize, i32)> = self
                .actions
                .iter()
                .enumerate()
                .filter_map(|(idx, action)| {
                    let score = Self::score_action(action, &search_lower);
                    if score > 0 {
                        Some((idx, score))
                    } else {
                        None
                    }
                })
                .collect();

            // Sort by score descending
            scored.sort_by(|a, b| b.1.cmp(&a.1));

            // Extract just the indices
            self.filtered_actions = scored.into_iter().map(|(idx, _)| idx).collect();
        }

        // Preserve selection if the same action is still in results
        if let Some(prev_id) = previously_selected {
            if let Some(new_idx) = self.filtered_actions.iter().position(|&idx| {
                self.actions
                    .get(idx)
                    .map(|a| a.id == prev_id)
                    .unwrap_or(false)
            }) {
                self.selected_index = new_idx;
            } else {
                self.selected_index = 0;
            }
        } else {
            self.selected_index = 0;
        }

        // Rebuild grouped items after filter change
        self.rebuild_grouped_items();

        // Coerce selection to skip section headers
        if let Some(valid_idx) = coerce_action_selection(&self.grouped_items, self.selected_index) {
            self.selected_index = valid_idx;
        }

        // Only scroll if we have results
        if !self.grouped_items.is_empty() {
            self.list_state.scroll_to_reveal_item(self.selected_index);
        }

        logging::log_debug(
            "ACTIONS_SCROLL",
            &format!(
                "Filter changed: {} results, selected={}",
                self.filtered_actions.len(),
                self.selected_index
            ),
        );
    }

    /// Rebuild grouped_items from current filtered_actions
    fn rebuild_grouped_items(&mut self) {
        self.grouped_items = build_grouped_items_static(
            &self.actions,
            &self.filtered_actions,
            self.config.section_style,
        );
        // Update list state item count
        let old_count = self.list_state.item_count();
        let new_count = self.grouped_items.len();
        self.list_state.splice(0..old_count, new_count);
    }

    /// Get the filtered_actions index for the current selection
    /// Returns None if selection is on a section header
    pub fn get_selected_filtered_index(&self) -> Option<usize> {
        match self.grouped_items.get(self.selected_index) {
            Some(GroupedActionItem::Item(filter_idx)) => Some(*filter_idx),
            _ => None,
        }
    }

    /// Score an action against a search query.
    /// Returns 0 if no match, higher scores for better matches.
    fn score_action(action: &Action, search_lower: &str) -> i32 {
        let title_lower = action.title.to_lowercase();
        let mut score = 0;

        // Prefix match on title (strongest)
        if title_lower.starts_with(search_lower) {
            score += 100;
        }
        // Contains match on title
        else if title_lower.contains(search_lower) {
            score += 50;
        }
        // Fuzzy match on title (character-by-character subsequence)
        else if Self::fuzzy_match(&title_lower, search_lower) {
            score += 25;
        }

        // Description match (bonus)
        if let Some(ref desc) = action.description {
            let desc_lower = desc.to_lowercase();
            if desc_lower.contains(search_lower) {
                score += 15;
            }
        }

        // Shortcut match (bonus)
        if let Some(ref shortcut) = action.shortcut {
            if shortcut.to_lowercase().contains(search_lower) {
                score += 10;
            }
        }

        score
    }

    /// Simple fuzzy matching: check if all characters in needle appear in haystack in order.
    fn fuzzy_match(haystack: &str, needle: &str) -> bool {
        let mut haystack_chars = haystack.chars();
        for needle_char in needle.chars() {
            loop {
                match haystack_chars.next() {
                    Some(h) if h == needle_char => break,
                    Some(_) => continue,
                    None => return false,
                }
            }
        }
        true
    }

    /// Handle character input
    pub fn handle_char(&mut self, ch: char, cx: &mut Context<Self>) {
        self.search_text.push(ch);
        self.refilter();
        cx.notify();
    }

    /// Handle backspace
    pub fn handle_backspace(&mut self, cx: &mut Context<Self>) {
        if !self.search_text.is_empty() {
            self.search_text.pop();
            self.refilter();
            cx.notify();
        }
    }

    /// Move selection up, skipping section headers
    ///
    /// When moving up and landing on a section header, we must search UPWARD
    /// (not downward) to find the previous selectable item. This ensures
    /// navigation past section headers works correctly.
    pub fn move_up(&mut self, cx: &mut Context<Self>) {
        if self.selected_index == 0 {
            return;
        }

        // Search backwards from current position to find the previous selectable item
        // This correctly skips section headers when moving up
        for i in (0..self.selected_index).rev() {
            if matches!(self.grouped_items.get(i), Some(GroupedActionItem::Item(_))) {
                self.selected_index = i;
                self.list_state.scroll_to_reveal_item(self.selected_index);
                logging::log_debug(
                    "ACTIONS_SCROLL",
                    &format!("Up: selected_index={}", self.selected_index),
                );
                cx.notify();
                return;
            }
        }
    }

    /// Move selection down, skipping section headers
    pub fn move_down(&mut self, cx: &mut Context<Self>) {
        if self.selected_index < self.grouped_items.len().saturating_sub(1) {
            let new_index = self.selected_index + 1;
            // Skip section headers - search forward
            for i in new_index..self.grouped_items.len() {
                if matches!(self.grouped_items.get(i), Some(GroupedActionItem::Item(_))) {
                    self.selected_index = i;
                    self.list_state.scroll_to_reveal_item(self.selected_index);
                    logging::log_debug(
                        "ACTIONS_SCROLL",
                        &format!("Down: selected_index={}", self.selected_index),
                    );
                    cx.notify();
                    break;
                }
            }
        }
    }

    /// Get the currently selected action ID (for external handling)
    pub fn get_selected_action_id(&self) -> Option<String> {
        // Get the filter_idx from grouped_items, then action_idx from filtered_actions
        match self.grouped_items.get(self.selected_index) {
            Some(GroupedActionItem::Item(filter_idx)) => {
                if let Some(&action_idx) = self.filtered_actions.get(*filter_idx) {
                    if let Some(action) = self.actions.get(action_idx) {
                        return Some(action.id.clone());
                    }
                }
                None
            }
            _ => None, // Section headers are not selectable
        }
    }

    /// Get the currently selected ProtocolAction (for checking close behavior)
    /// Returns the original ProtocolAction from sdk_actions if this is an SDK action,
    /// or None for built-in actions.
    pub fn get_selected_protocol_action(&self) -> Option<&ProtocolAction> {
        let action_id = self.get_selected_action_id()?;
        self.sdk_actions
            .as_ref()?
            .iter()
            .find(|a| a.name == action_id)
    }

    /// Check if the currently selected action should close the dialog
    /// Returns true if the action has close: true (or no close field, which defaults to true)
    /// Returns true for built-in actions (they always close)
    pub fn selected_action_should_close(&self) -> bool {
        if let Some(protocol_action) = self.get_selected_protocol_action() {
            protocol_action.should_close()
        } else {
            // Built-in actions always close
            true
        }
    }

    /// Submit the selected action
    pub fn submit_selected(&mut self) {
        // Get action from grouped_items -> filtered_actions -> actions chain
        if let Some(action) = self.get_selected_action() {
            let action_id = action.id.clone();
            logging::log("ACTIONS", &format!("Action selected: {}", action_id));
            (self.on_select)(action_id);
        }
    }

    /// Cancel - close the dialog
    pub fn submit_cancel(&mut self) {
        logging::log("ACTIONS", "Actions dialog cancelled");
        (self.on_select)("__cancel__".to_string());
    }

    /// Dismiss the dialog when user clicks outside its bounds.
    /// This is a public method called from the parent container's click-outside handler.
    /// Logs the event and triggers the cancel callback.
    pub fn dismiss_on_click_outside(&mut self) {
        tracing::info!(
            target: "script_kit::actions",
            "ActionsDialog dismiss-on-click-outside triggered"
        );
        logging::log("ACTIONS", "Actions dialog dismissed (click outside)");
        self.submit_cancel();
    }

    /// Create box shadow for the overlay popup
    /// When rendered in a separate vibrancy window, no shadow is needed
    /// (the window vibrancy provides visual separation)
    pub(super) fn create_popup_shadow() -> Vec<BoxShadow> {
        // No shadow - vibrancy window provides visual separation
        vec![]
    }

    /// Get colors for the search box based on design variant
    /// Returns: (search_box_bg, border_color, muted_text, dimmed_text, secondary_text)
    pub(super) fn get_search_colors(
        &self,
        colors: &crate::designs::DesignColors,
    ) -> (gpui::Rgba, gpui::Rgba, gpui::Rgba, gpui::Rgba, gpui::Rgba) {
        // Use theme opacity for input background to support vibrancy
        let opacity = self.theme.get_opacity();
        let input_alpha = (opacity.input * 255.0) as u8;

        if self.design_variant == DesignVariant::Default {
            (
                rgba(hex_with_alpha(
                    self.theme.colors.background.search_box,
                    input_alpha,
                )),
                rgba(hex_with_alpha(self.theme.colors.ui.border, 0x80)),
                rgb(self.theme.colors.text.muted),
                rgb(self.theme.colors.text.dimmed),
                rgb(self.theme.colors.text.secondary),
            )
        } else {
            (
                rgba(hex_with_alpha(colors.background_secondary, input_alpha)),
                rgba(hex_with_alpha(colors.border, 0x80)),
                rgb(colors.text_muted),
                rgb(colors.text_dimmed),
                rgb(colors.text_secondary),
            )
        }
    }

    /// Get colors for the main container based on design variant
    /// Returns: (main_bg, container_border, container_text)
    pub(super) fn get_container_colors(
        &self,
        colors: &crate::designs::DesignColors,
    ) -> (gpui::Rgba, gpui::Rgba, gpui::Rgba) {
        // Vibrancy-aware dialog background:
        // - When vibrancy enabled: ~50% opacity to show blur but remain visible
        // - When vibrancy disabled: ~95% opacity for near-solid appearance
        let use_vibrancy = self.theme.is_vibrancy_enabled();
        let dialog_alpha = if use_vibrancy {
            // Dialogs need higher opacity than main window (0.37) to stand out
            (0.50 * 255.0) as u8
        } else {
            // Near-opaque when vibrancy disabled
            (0.95 * 255.0) as u8
        };

        if self.design_variant == DesignVariant::Default {
            (
                rgba(hex_with_alpha(
                    self.theme.colors.background.main,
                    dialog_alpha,
                )),
                rgba(hex_with_alpha(self.theme.colors.ui.border, 0x80)),
                rgb(self.theme.colors.text.secondary),
            )
        } else {
            (
                rgba(hex_with_alpha(colors.background, dialog_alpha)),
                rgba(hex_with_alpha(colors.border, 0x80)),
                rgb(colors.text_secondary),
            )
        }
    }
}

impl Focusable for ActionsDialog {
    fn focus_handle(&self, _cx: &App) -> FocusHandle {
        self.focus_handle.clone()
    }
}

impl Render for ActionsDialog {
    fn render(&mut self, _window: &mut Window, cx: &mut Context<Self>) -> impl IntoElement {
        // Get design tokens for the current design variant
        let tokens = get_tokens(self.design_variant);
        let colors = tokens.colors();
        let spacing = tokens.spacing();
        let visual = tokens.visual();

        // NOTE: Key handling is done by the parent (ScriptListApp in main.rs)
        // which routes all keyboard events to this dialog's methods.
        // We do NOT attach our own on_key_down handler to avoid double-processing.

        // Render search input - compact version
        let search_display = if self.search_text.is_empty() {
            SharedString::from("Search actions...")
        } else {
            SharedString::from(self.search_text.clone())
        };

        // Use helper method for design/theme color extraction
        let (search_box_bg, border_color, _muted_text, dimmed_text, _secondary_text) =
            self.get_search_colors(&colors);

        // Get primary text color for cursor (matches main list styling)
        let primary_text = if self.design_variant == DesignVariant::Default {
            rgb(self.theme.colors.text.primary)
        } else {
            rgb(colors.text_primary)
        };

        // Get accent color for the search input focus indicator
        let accent_color_hex = if self.design_variant == DesignVariant::Default {
            self.theme.colors.accent.selected
        } else {
            colors.accent
        };
        let accent_color = rgb(accent_color_hex);

        // Focus border color (accent with transparency)
        let focus_border_color = rgba(hex_with_alpha(accent_color_hex, 0x60));

        // Input container with fixed height and width to prevent any layout shifts
        // The entire row is constrained to prevent resizing when text is entered
        let input_container = div()
            .w(px(POPUP_WIDTH)) // Match parent width exactly
            .min_w(px(POPUP_WIDTH))
            .max_w(px(POPUP_WIDTH))
            .h(px(SEARCH_INPUT_HEIGHT)) // Fixed height for the input row
            .min_h(px(SEARCH_INPUT_HEIGHT))
            .max_h(px(SEARCH_INPUT_HEIGHT))
            .overflow_hidden() // Prevent any content from causing shifts
            .px(px(spacing.item_padding_x))
            .py(px(spacing.item_padding_y + 2.0)) // Slightly more vertical padding
            .bg(search_box_bg)
            .border_t_1() // Border on top since input is now at bottom
            .border_color(border_color)
            .flex()
            .flex_row()
            .items_center()
            .gap(px(spacing.gap_md))
            .child(
                // Search icon or indicator - fixed width to prevent shifts
                div()
                    .w(px(24.0)) // Fixed width for the icon container
                    .min_w(px(24.0))
                    .text_color(dimmed_text)
                    .text_xs()
                    .child("K"),
            )
            .child(
                // Search input field with focus indicator
                // CRITICAL: Use flex_shrink_0 to prevent flexbox from shrinking this container
                // The border/bg MUST stay at fixed width regardless of content
                div()
                    .flex_shrink_0() // PREVENT flexbox from shrinking this!
                    .w(px(240.0))
                    .min_w(px(240.0))
                    .max_w(px(240.0))
                    .h(px(28.0)) // Fixed height too
                    .min_h(px(28.0))
                    .max_h(px(28.0))
                    .overflow_hidden()
                    .px(px(spacing.padding_sm))
                    .py(px(spacing.padding_xs))
                    // ALWAYS show background - just vary intensity
                    .bg(if self.design_variant == DesignVariant::Default {
                        rgba(hex_with_alpha(
                            self.theme.colors.background.main,
                            if self.search_text.is_empty() {
                                0x20
                            } else {
                                0x40
                            },
                        ))
                    } else {
                        rgba(hex_with_alpha(
                            colors.background,
                            if self.search_text.is_empty() {
                                0x20
                            } else {
                                0x40
                            },
                        ))
                    })
                    .rounded(px(visual.radius_sm))
                    .border_1()
                    // ALWAYS show border - just vary intensity
                    .border_color(if !self.search_text.is_empty() {
                        focus_border_color
                    } else {
                        border_color
                    })
                    .flex()
                    .flex_row()
                    .items_center()
                    .text_sm()
                    .text_color(if self.search_text.is_empty() {
                        dimmed_text
                    } else {
                        primary_text
                    })
                    // ALWAYS render cursor div with consistent margin to prevent layout shift
                    // When empty, cursor is at the start before placeholder text
                    .when(self.search_text.is_empty(), |d| {
                        d.child(
                            div()
                                .w(px(2.))
                                .h(px(16.))
                                .mr(px(2.)) // Use consistent 2px margin
                                .rounded(px(1.))
                                .when(self.cursor_visible, |d| d.bg(accent_color)),
                        )
                    })
                    .child(search_display.clone())
                    // When has text, cursor is at the end after the text
                    .when(!self.search_text.is_empty(), |d| {
                        d.child(
                            div()
                                .w(px(2.))
                                .h(px(16.))
                                .ml(px(2.)) // Consistent 2px margin
                                .rounded(px(1.))
                                .when(self.cursor_visible, |d| d.bg(accent_color)),
                        )
                    }),
            );

        // Render action list using list() for variable-height items
        // Section headers are 24px, action items are 44px
        let actions_container = if self.grouped_items.is_empty() {
            // Empty state: fixed height matching one action item row
            div()
                .w_full()
                .h(px(ACTION_ITEM_HEIGHT))
                .flex()
                .items_center()
                .px(px(spacing.item_padding_x))
                .text_color(dimmed_text)
                .text_sm()
                .child("No actions match your search")
                .into_any_element()
        } else {
            // Clone data needed for the list closure
            let grouped_items_clone = self.grouped_items.clone();
            let design_variant = self.design_variant;

            // Calculate scrollbar parameters
            // Container height for actions (excluding search box)
            let search_box_height = if self.hide_search {
                0.0
            } else {
                SEARCH_INPUT_HEIGHT
            };

            // Count section headers and items for accurate height calculation
            let mut header_count = 0_usize;
            let mut item_count = 0_usize;
            for item in &self.grouped_items {
                match item {
                    GroupedActionItem::SectionHeader(_) => header_count += 1,
                    GroupedActionItem::Item(_) => item_count += 1,
                }
            }
            let total_content_height = (header_count as f32 * SECTION_HEADER_HEIGHT)
                + (item_count as f32 * ACTION_ITEM_HEIGHT);
            let container_height = total_content_height.min(POPUP_MAX_HEIGHT - search_box_height);

            // Estimate visible items based on average item height
            let avg_item_height = if self.grouped_items.is_empty() {
                ACTION_ITEM_HEIGHT
            } else {
                total_content_height / self.grouped_items.len() as f32
            };
            let visible_items = (container_height / avg_item_height).ceil() as usize;

            // Get scroll offset from list state
            let scroll_offset = self.list_state.logical_scroll_top().item_ix;

            // Get scrollbar colors from theme for consistent styling
            let scrollbar_colors = ScrollbarColors::from_theme(&self.theme);

            // Create scrollbar (only visible if content overflows)
            let scrollbar = Scrollbar::new(
                self.grouped_items.len(),
                visible_items,
                scroll_offset,
                scrollbar_colors,
            )
            .container_height(container_height);

            // Capture entity handle for use in the render closure
            let entity = cx.entity();

            let variable_height_list = list(self.list_state.clone(), move |ix, _window, cx| {
                // Access entity state inside the closure
                entity.update(cx, |this, _cx| {
                    let current_selected = this.selected_index;

                    if let Some(grouped_item) = grouped_items_clone.get(ix) {
                        match grouped_item {
                            GroupedActionItem::SectionHeader(label) => {
                                // Section header at 24px height
                                let header_text = if this.design_variant == DesignVariant::Default {
                                    rgb(this.theme.colors.text.dimmed)
                                } else {
                                    let tokens = get_tokens(this.design_variant);
                                    rgb(tokens.colors().text_dimmed)
                                };
                                let border_color = if this.design_variant == DesignVariant::Default
                                {
                                    rgba(hex_with_alpha(this.theme.colors.ui.border, 0x40))
                                } else {
                                    let tokens = get_tokens(this.design_variant);
                                    rgba(hex_with_alpha(tokens.colors().border, 0x40))
                                };

                                div()
                                    .id(ElementId::NamedInteger("section-header".into(), ix as u64))
                                    .h(px(SECTION_HEADER_HEIGHT))
                                    .w_full()
                                    .px(px(16.0))
                                    .flex()
                                    .items_center()
                                    .when(ix > 0, |d| d.border_t_1().border_color(border_color))
                                    .child(
                                        div()
                                            .text_xs()
                                            .font_weight(gpui::FontWeight::SEMIBOLD)
                                            .text_color(header_text)
                                            .child(label.clone()),
                                    )
                                    .into_any_element()
                            }
                            GroupedActionItem::Item(filter_idx) => {
                                // Action item at 44px height
                                if let Some(&action_idx) = this.filtered_actions.get(*filter_idx) {
                                    if let Some(action) = this.actions.get(action_idx) {
                                        let is_selected = ix == current_selected;

                                        // Get tokens for styling
                                        let item_tokens = get_tokens(design_variant);
                                        let item_colors = item_tokens.colors();
                                        let item_spacing = item_tokens.spacing();

                                        // Extract colors for list items - use theme opacity for vibrancy
                                        let theme_opacity = this.theme.get_opacity();
                                        let selected_alpha =
                                            (theme_opacity.selected * 255.0) as u32;
                                        let hover_alpha = (theme_opacity.hover * 255.0) as u32;

                                        let (
                                            selected_bg,
                                            hover_bg,
                                            primary_text,
                                            secondary_text,
                                            dimmed_text,
                                        ) = if design_variant == DesignVariant::Default {
                                            (
                                                rgba(
                                                    (this.theme.colors.accent.selected_subtle << 8)
                                                        | selected_alpha,
                                                ),
                                                rgba(
                                                    (this.theme.colors.accent.selected_subtle << 8)
                                                        | hover_alpha,
                                                ),
                                                rgb(this.theme.colors.text.primary),
                                                rgb(this.theme.colors.text.secondary),
                                                rgb(this.theme.colors.text.dimmed),
                                            )
                                        } else {
                                            (
                                                rgba(
                                                    (item_colors.background_selected << 8)
                                                        | selected_alpha,
                                                ),
                                                rgba(
                                                    (item_colors.background_selected << 8)
                                                        | hover_alpha,
                                                ),
                                                rgb(item_colors.text_primary),
                                                rgb(item_colors.text_secondary),
                                                rgb(item_colors.text_dimmed),
                                            )
                                        };

                                        // Title color: bright when selected, secondary when not
                                        let title_color = if is_selected {
                                            primary_text
                                        } else {
                                            secondary_text
                                        };
                                        let shortcut_color = dimmed_text;

                                        // Keycap colors
                                        let keycap_bg = if design_variant == DesignVariant::Default
                                        {
                                            rgba(hex_with_alpha(this.theme.colors.ui.border, 0x80))
                                        } else {
                                            rgba(hex_with_alpha(item_colors.border, 0x80))
                                        };
                                        let keycap_border = if design_variant
                                            == DesignVariant::Default
                                        {
                                            rgba(hex_with_alpha(this.theme.colors.ui.border, 0xA0))
                                        } else {
                                            rgba(hex_with_alpha(item_colors.border, 0xA0))
                                        };

                                        // Inner row with pill-style selection
                                        let inner_row = div()
                                            .w_full()
                                            .flex_1()
                                            .flex()
                                            .flex_row()
                                            .items_center()
                                            .px(px(item_spacing.item_padding_x))
                                            .rounded(px(SELECTION_RADIUS))
                                            .bg(if is_selected {
                                                selected_bg
                                            } else {
                                                rgba(0x00000000)
                                            })
                                            .hover(|s| s.bg(hover_bg))
                                            .cursor_pointer();

                                        // Content: optional icon + label + shortcuts
                                        let show_icons = this.config.show_icons;
                                        let action_icon = action.icon;

                                        let mut left_side =
                                            div().flex().flex_row().items_center().gap(px(12.0));

                                        // Add icon if enabled and present
                                        if show_icons {
                                            if let Some(icon) = action_icon {
                                                left_side = left_side.child(
                                                    svg()
                                                        .external_path(icon.external_path())
                                                        .size(px(16.0))
                                                        .text_color(if is_selected {
                                                            primary_text
                                                        } else {
                                                            dimmed_text
                                                        }),
                                                );
                                            }
                                        }

                                        // Add title
                                        left_side = left_side.child(
                                            div()
                                                .text_color(title_color)
                                                .text_sm()
                                                .font_weight(if is_selected {
                                                    gpui::FontWeight::MEDIUM
                                                } else {
                                                    gpui::FontWeight::NORMAL
                                                })
                                                .child(action.title.clone()),
                                        );

                                        let mut content = div()
                                            .flex_1()
                                            .flex()
                                            .flex_row()
                                            .items_center()
                                            .justify_between()
                                            .child(left_side);

                                        // Right side: keyboard shortcuts as keycaps
                                        if let Some(ref shortcut) = action.shortcut {
                                            let keycaps =
                                                ActionsDialog::parse_shortcut_keycaps(shortcut);
                                            let mut keycap_row =
                                                div().flex().flex_row().items_center().gap(px(3.));

                                            for keycap in keycaps {
                                                keycap_row = keycap_row.child(
                                                    div()
                                                        .min_w(px(KEYCAP_MIN_WIDTH))
                                                        .h(px(KEYCAP_HEIGHT))
                                                        .px(px(6.))
                                                        .flex()
                                                        .items_center()
                                                        .justify_center()
                                                        .bg(keycap_bg)
                                                        .border_1()
                                                        .border_color(keycap_border)
                                                        .rounded(px(5.))
                                                        .text_xs()
                                                        .text_color(shortcut_color)
                                                        .child(keycap),
                                                );
                                            }

                                            content = content.child(keycap_row);
                                        }

                                        div()
                                            .id(ElementId::NamedInteger(
                                                "action-item".into(),
                                                ix as u64,
                                            ))
                                            .h(px(ACTION_ITEM_HEIGHT))
                                            .w_full()
                                            .px(px(ACTION_ROW_INSET))
                                            .py(px(2.0))
                                            .flex()
                                            .flex_col()
                                            .justify_center()
                                            .child(inner_row.child(content))
                                            .into_any_element()
                                    } else {
                                        // Fallback for missing action
                                        div().h(px(ACTION_ITEM_HEIGHT)).into_any_element()
                                    }
                                } else {
                                    // Fallback for missing filtered index
                                    div().h(px(ACTION_ITEM_HEIGHT)).into_any_element()
                                }
                            }
                        }
                    } else {
                        // Fallback for out-of-bounds index
                        div().h(px(ACTION_ITEM_HEIGHT)).into_any_element()
                    }
                })
            })
            .flex_1()
            .w_full();

            // Wrap list in a relative container with scrollbar overlay
            div()
                .relative()
                .flex()
                .flex_col()
                .flex_1()
                .w_full()
                .h_full()
                .overflow_hidden()
                .child(variable_height_list)
                .child(scrollbar)
                .into_any_element()
        };

        // Use helper method for container colors
        let (main_bg, container_border, container_text) = self.get_container_colors(&colors);

        // Calculate dynamic height based on number of items
        // Each item is ACTION_ITEM_HEIGHT, plus search box height (SEARCH_INPUT_HEIGHT), plus padding
        // When hide_search is true, we don't include the search box height
        // Now also includes HEADER_HEIGHT when context_title is set
        // NOTE: Add border_thin * 2 for border (top + bottom from .border_1()) to prevent
        // content from being clipped and causing unnecessary scrolling
        let num_items = self.filtered_actions.len();
        let search_box_height = if self.hide_search {
            0.0
        } else {
            SEARCH_INPUT_HEIGHT
        };
        let header_height = if self.context_title.is_some() {
            HEADER_HEIGHT
        } else {
            0.0
        };
        let border_height = visual.border_thin * 2.0; // top + bottom border
                                                      // When no actions, still need space for "No actions match" message
        let min_items_height = if num_items == 0 {
            ACTION_ITEM_HEIGHT
        } else {
            0.0
        };
        let items_height = (num_items as f32 * ACTION_ITEM_HEIGHT)
            .max(min_items_height)
            .min(POPUP_MAX_HEIGHT - search_box_height - header_height);
        let total_height = items_height + search_box_height + header_height + border_height;

        // Build header row (section header style - non-interactive label)
        // Styled to match render_section_header() from list_item.rs:
        // - Smaller font (text_xs)
        // - Semibold weight
        // - Dimmed color (visually distinct from actionable items)
        let header_container = self.context_title.as_ref().map(|title| {
            let header_text = if self.design_variant == DesignVariant::Default {
                rgb(self.theme.colors.text.dimmed)
            } else {
                rgb(colors.text_dimmed)
            };
            let header_border = if self.design_variant == DesignVariant::Default {
                rgba(hex_with_alpha(self.theme.colors.ui.border, 0x40))
            } else {
                rgba(hex_with_alpha(colors.border, 0x40))
            };

            div()
                .w_full()
                .h(px(HEADER_HEIGHT))
                .px(px(16.0)) // Match section header padding from list_item.rs
                .pt(px(8.0)) // Top padding for visual separation
                .pb(px(4.0)) // Bottom padding
                .flex()
                .flex_col()
                .justify_center()
                .border_b_1()
                .border_color(header_border)
                .child(
                    div()
                        .text_xs() // Smaller font like section headers
                        .font_weight(gpui::FontWeight::SEMIBOLD) // Semibold like section headers
                        .text_color(header_text)
                        .child(title.clone()),
                )
        });

        // Main overlay popup container
        // Fixed width, dynamic height based on content, rounded corners, shadow
        // NOTE: Using visual.radius_lg from design tokens for consistency with child item rounding
        //
        // VIBRANCY: Background is handled in get_container_colors() with vibrancy-aware opacity
        // (~50% when vibrancy enabled, ~95% when disabled)

        // Build footer with keyboard hints (if enabled)
        let footer_height = if self.config.show_footer { 32.0 } else { 0.0 };
        let footer_container = if self.config.show_footer {
            let footer_text = if self.design_variant == DesignVariant::Default {
                rgb(self.theme.colors.text.dimmed)
            } else {
                rgb(colors.text_dimmed)
            };
            let footer_border = if self.design_variant == DesignVariant::Default {
                rgba(hex_with_alpha(self.theme.colors.ui.border, 0x40))
            } else {
                rgba(hex_with_alpha(colors.border, 0x40))
            };

            Some(
                div()
                    .w_full()
                    .h(px(32.0))
                    .px(px(16.0))
                    .border_t_1()
                    .border_color(footer_border)
                    .flex()
                    .items_center()
                    .gap(px(16.0))
                    .text_xs()
                    .text_color(footer_text)
                    .child(
                        div()
                            .flex()
                            .items_center()
                            .gap(px(4.0))
                            .child("")
                            .child("Navigate"),
                    )
                    .child(
                        div()
                            .flex()
                            .items_center()
                            .gap(px(4.0))
                            .child("")
                            .child("Select"),
                    )
                    .child(
                        div()
                            .flex()
                            .items_center()
                            .gap(px(4.0))
                            .child("esc")
                            .child("Close"),
                    ),
            )
        } else {
            None
        };

        // Recalculate total height including footer
        let total_height = total_height + footer_height;

        // Get search position from config
        let search_at_top = matches!(self.config.search_position, SearchPosition::Top);
        let show_search =
            !matches!(self.config.search_position, SearchPosition::Hidden) && !self.hide_search;

        // Modify input_container for top position (border at bottom instead of top)
        let input_container_top = if search_at_top && show_search {
            Some(
                div()
                    .w(px(POPUP_WIDTH))
                    .min_w(px(POPUP_WIDTH))
                    .max_w(px(POPUP_WIDTH))
                    .h(px(SEARCH_INPUT_HEIGHT))
                    .min_h(px(SEARCH_INPUT_HEIGHT))
                    .max_h(px(SEARCH_INPUT_HEIGHT))
                    .overflow_hidden()
                    .px(px(spacing.item_padding_x))
                    .py(px(spacing.item_padding_y + 2.0))
                    .bg(search_box_bg)
                    .border_b_1() // Border at bottom for top-positioned search
                    .border_color(border_color)
                    .flex()
                    .flex_row()
                    .items_center()
                    .gap(px(spacing.gap_md))
                    .child(
                        div()
                            .w(px(24.0))
                            .min_w(px(24.0))
                            .text_color(dimmed_text)
                            .text_xs()
                            .child("K"),
                    )
                    .child(
                        div()
                            .flex_shrink_0()
                            .w(px(240.0))
                            .min_w(px(240.0))
                            .max_w(px(240.0))
                            .h(px(28.0))
                            .min_h(px(28.0))
                            .max_h(px(28.0))
                            .overflow_hidden()
                            .px(px(spacing.padding_sm))
                            .py(px(spacing.padding_xs))
                            .bg(if self.design_variant == DesignVariant::Default {
                                rgba(hex_with_alpha(
                                    self.theme.colors.background.main,
                                    if self.search_text.is_empty() {
                                        0x20
                                    } else {
                                        0x40
                                    },
                                ))
                            } else {
                                rgba(hex_with_alpha(
                                    colors.background,
                                    if self.search_text.is_empty() {
                                        0x20
                                    } else {
                                        0x40
                                    },
                                ))
                            })
                            .rounded(px(visual.radius_sm))
                            .border_1()
                            .border_color(if !self.search_text.is_empty() {
                                focus_border_color
                            } else {
                                border_color
                            })
                            .flex()
                            .flex_row()
                            .items_center()
                            .text_sm()
                            .text_color(if self.search_text.is_empty() {
                                dimmed_text
                            } else {
                                primary_text
                            })
                            .when(self.search_text.is_empty(), |d| {
                                d.child(
                                    div()
                                        .w(px(2.))
                                        .h(px(16.))
                                        .mr(px(2.))
                                        .rounded(px(1.))
                                        .when(self.cursor_visible, |d| d.bg(accent_color)),
                                )
                            })
                            .child(search_display.clone())
                            .when(!self.search_text.is_empty(), |d| {
                                d.child(
                                    div()
                                        .w(px(2.))
                                        .h(px(16.))
                                        .ml(px(2.))
                                        .rounded(px(1.))
                                        .when(self.cursor_visible, |d| d.bg(accent_color)),
                                )
                            }),
                    ),
            )
        } else {
            None
        };

        div()
            .flex()
            .flex_col()
            .w(px(POPUP_WIDTH))
            .h(px(total_height)) // Use calculated height including footer
            .bg(main_bg) // Always apply background with vibrancy-aware opacity
            .rounded(px(visual.radius_lg))
            .shadow(Self::create_popup_shadow())
            .border_1()
            .border_color(container_border)
            .overflow_hidden()
            .text_color(container_text)
            .key_context("actions_dialog")
            // Only track focus if not delegated to parent (ActionsWindow sets skip_track_focus=true)
            .when(!self.skip_track_focus, |d| {
                d.track_focus(&self.focus_handle)
            })
            // NOTE: No on_key_down here - parent handles all keyboard input
            // Search input at top (if config.search_position == Top)
            .when_some(input_container_top, |d, input| d.child(input))
            // Header row (if context_title is set)
            .when_some(header_container, |d, header| d.child(header))
            // Actions list
            .child(actions_container)
            // Search input at bottom (if config.search_position == Bottom)
            .when(show_search && !search_at_top, |d| d.child(input_container))
            // Footer with keyboard hints (if config.show_footer)
            .when_some(footer_container, |d, footer| d.child(footer))
    }
}

</file>

<file path="src/actions/constants.rs">
//! Actions dialog constants
//!
//! Overlay popup dimensions and styling constants used by the ActionsDialog.

/// Popup width for the actions dialog
pub const POPUP_WIDTH: f32 = 320.0;

/// Maximum height for the actions dialog popup
pub const POPUP_MAX_HEIGHT: f32 = 400.0;

/// Fixed height for action items (required for uniform_list virtualization)
/// Compact height at 36px for visual consistency with main menu list items
pub const ACTION_ITEM_HEIGHT: f32 = 36.0;

/// Fixed height for the search input row (matches Notes panel PANEL_SEARCH_HEIGHT)
pub const SEARCH_INPUT_HEIGHT: f32 = 44.0;

/// Width of the left accent bar for selected items (legacy, kept for reference)
pub const ACCENT_BAR_WIDTH: f32 = 3.0;

/// Height for the header row showing context title (matches section header style)
pub const HEADER_HEIGHT: f32 = 24.0;

/// Height for section headers within the action list (used when SectionStyle::Headers is enabled)
/// This includes the text (~12px) + top padding (4-8px) + bottom padding (2px)
pub const SECTION_HEADER_HEIGHT: f32 = 22.0;

/// Horizontal inset for action rows (creates rounded pill appearance)
pub const ACTION_ROW_INSET: f32 = 6.0;

/// Corner radius for selected row background (pill style)
pub const SELECTION_RADIUS: f32 = 8.0;

/// Minimum width for keycap badges
pub const KEYCAP_MIN_WIDTH: f32 = 22.0;

/// Height for keycap badges
pub const KEYCAP_HEIGHT: f32 = 22.0;

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_popup_constants() {
        assert_eq!(POPUP_WIDTH, 320.0);
        assert_eq!(POPUP_MAX_HEIGHT, 400.0);
    }

    #[test]
    fn test_action_item_height_constant() {
        // Fixed height is required for uniform_list virtualization
        // Compact height at 36px for visual consistency with main menu list items
        assert_eq!(ACTION_ITEM_HEIGHT, 36.0);
        // Ensure item height is positive and reasonable
        const _: () = assert!(ACTION_ITEM_HEIGHT > 0.0);
        const _: () = assert!(ACTION_ITEM_HEIGHT < POPUP_MAX_HEIGHT);
    }

    #[test]
    fn test_max_visible_items() {
        // Calculate max visible items that can fit in the popup
        // This helps verify scroll virtualization is worthwhile
        let max_visible = (POPUP_MAX_HEIGHT / ACTION_ITEM_HEIGHT) as usize;
        // With 400px max height and 44px items, ~9 items fit
        assert!(max_visible >= 8, "Should fit at least 8 items");
        assert!(max_visible <= 15, "Sanity check on max visible");
    }
}

</file>

<file path="src/actions/types.rs">
//! Action types and data structures
//!
//! Core types for the actions system including Action, ActionCategory, and ScriptInfo.
//!
//! # Architecture Overview
//!
//! The actions system is **intentionally decoupled** from the standard selection callbacks:
//!
//! - **on_select callback is bypassed by design** for keyboard navigation
//! - Actions route through `handle_action()` in the main app via keyboard events
//! - This enables consistent keyboard-driven action execution across all contexts
//!
//! ## Key Types
//!
//! - [`Action`]: Represents a single action item with id, title, category, and optional shortcut
//! - [`ActionCategory`]: Categorizes actions (ScriptContext, ScriptOps, GlobalOps)
//! - [`ScriptInfo`]: Context about the focused script/item for building context-specific actions
//!
//! ## Action ID Conventions
//!
//! All built-in action IDs use **snake_case** format:
//! - `run_script`, `edit_script`, `copy_path`, `reveal_in_finder`
//! - `add_shortcut`, `update_shortcut`, `remove_shortcut`
//! - `add_alias`, `update_alias`, `remove_alias`
//! - `copy_deeplink`, `reset_ranking`
//!
//! SDK-provided actions (from ProtocolAction) use their `name` field as-is for the ID.
//!
//! ## has_action Field
//!
//! The `has_action` field determines routing:
//! - `has_action=true`: Send ActionTriggered event to SDK, let SDK handle the action
//! - `has_action=false`: Submit value directly via protocol (built-in actions)
//!
//! Built-in actions (from `builders.rs`) have `has_action=false` by default.
//! SDK actions with handlers should set `has_action=true`.

use crate::designs::icon_variations::IconName;
use std::sync::Arc;

/// Callback for action selection
/// Signature: (action_id: String)
pub type ActionCallback = Arc<dyn Fn(String) + Send + Sync>;

/// Callback for dialog close (escape pressed, window dismissed)
/// Used to notify the main app to restore focus
/// Takes &mut App so the callback can update the main app entity
pub type CloseCallback = Arc<dyn Fn(&mut gpui::App) + Send + Sync>;

/// Information about the currently focused/selected script
/// Used for context-aware actions in the actions dialog
#[derive(Debug, Clone)]
pub struct ScriptInfo {
    /// Display name of the script
    pub name: String,
    // Note: path is written during construction for completeness but currently
    // action handlers read directly from ProtocolAction. Kept for API consistency.
    #[allow(dead_code)]
    /// Full path to the script file
    pub path: String,
    /// Whether this is a real script file (true) or a built-in command (false)
    /// Built-in commands (like Clipboard History, App Launcher) have limited actions
    pub is_script: bool,
    /// Whether this is a scriptlet (snippet from markdown file)
    /// Scriptlets have their own actions (Edit Scriptlet, etc.) that work with the markdown file
    pub is_scriptlet: bool,
    /// The verb to use for the primary action (e.g., "Run", "Launch", "Switch to")
    /// Defaults to "Run" for scripts
    pub action_verb: String,
    /// Current keyboard shortcut assigned to this script/item (if any)
    /// Used to determine which shortcut actions to show in the actions menu
    pub shortcut: Option<String>,
    /// Current alias assigned to this script/item (if any)
    /// Used to determine which alias actions to show in the actions menu
    pub alias: Option<String>,
    /// Whether this item appears in the "Suggested" section (has frecency data)
    /// Used to show/hide the "Reset Ranking" action
    pub is_suggested: bool,
    /// The frecency path used to track this item's usage
    /// Used by "Reset Ranking" to know which frecency entry to remove
    pub frecency_path: Option<String>,
    /// Whether this is an agent file (.claude.md or similar)
    /// Agents have their own actions (Edit Agent, Copy Content, etc.)
    pub is_agent: bool,
}

impl ScriptInfo {
    /// Create a ScriptInfo for a real script file
    pub fn new(name: impl Into<String>, path: impl Into<String>) -> Self {
        ScriptInfo {
            name: name.into(),
            path: path.into(),
            is_script: true,
            is_scriptlet: false,
            is_agent: false,
            action_verb: "Run".to_string(),
            shortcut: None,
            alias: None,
            is_suggested: false,
            frecency_path: None,
        }
    }

    /// Create a ScriptInfo for a real script file with shortcut info
    #[allow(dead_code)]
    pub fn with_shortcut(
        name: impl Into<String>,
        path: impl Into<String>,
        shortcut: Option<String>,
    ) -> Self {
        ScriptInfo {
            name: name.into(),
            path: path.into(),
            is_script: true,
            is_scriptlet: false,
            is_agent: false,
            action_verb: "Run".to_string(),
            shortcut,
            alias: None,
            is_suggested: false,
            frecency_path: None,
        }
    }

    /// Create a ScriptInfo for a scriptlet (snippet from markdown file)
    /// Scriptlets have their own actions that work with the source markdown file
    pub fn scriptlet(
        name: impl Into<String>,
        markdown_path: impl Into<String>,
        shortcut: Option<String>,
        alias: Option<String>,
    ) -> Self {
        ScriptInfo {
            name: name.into(),
            path: markdown_path.into(),
            is_script: false,
            is_scriptlet: true,
            is_agent: false,
            action_verb: "Run".to_string(),
            shortcut,
            alias,
            is_suggested: false,
            frecency_path: None,
        }
    }

    /// Create a ScriptInfo for a real script file with shortcut and alias info
    #[allow(dead_code)]
    pub fn with_shortcut_and_alias(
        name: impl Into<String>,
        path: impl Into<String>,
        shortcut: Option<String>,
        alias: Option<String>,
    ) -> Self {
        ScriptInfo {
            name: name.into(),
            path: path.into(),
            is_script: true,
            is_scriptlet: false,
            is_agent: false,
            action_verb: "Run".to_string(),
            shortcut,
            alias,
            is_suggested: false,
            frecency_path: None,
        }
    }

    /// Create a ScriptInfo for a built-in command (not a real script)
    /// Built-ins have limited actions (no edit, view logs, reveal in finder, copy path, configure shortcut)
    #[allow(dead_code)]
    pub fn builtin(name: impl Into<String>) -> Self {
        ScriptInfo {
            name: name.into(),
            path: String::new(),
            is_script: false,
            is_scriptlet: false,
            is_agent: false,
            action_verb: "Run".to_string(),
            shortcut: None,
            alias: None,
            is_suggested: false,
            frecency_path: None,
        }
    }

    /// Create a ScriptInfo with explicit is_script flag and custom action verb
    #[allow(dead_code)]
    pub fn with_is_script(
        name: impl Into<String>,
        path: impl Into<String>,
        is_script: bool,
    ) -> Self {
        ScriptInfo {
            name: name.into(),
            path: path.into(),
            is_script,
            is_scriptlet: false,
            is_agent: false,
            action_verb: "Run".to_string(),
            shortcut: None,
            alias: None,
            is_suggested: false,
            frecency_path: None,
        }
    }

    /// Create a ScriptInfo with all options including custom action verb
    pub fn with_action_verb(
        name: impl Into<String>,
        path: impl Into<String>,
        is_script: bool,
        action_verb: impl Into<String>,
    ) -> Self {
        ScriptInfo {
            name: name.into(),
            path: path.into(),
            is_script,
            is_scriptlet: false,
            is_agent: false,
            action_verb: action_verb.into(),
            shortcut: None,
            alias: None,
            is_suggested: false,
            frecency_path: None,
        }
    }

    /// Create a ScriptInfo with all options including custom action verb and shortcut
    #[allow(dead_code)]
    pub fn with_action_verb_and_shortcut(
        name: impl Into<String>,
        path: impl Into<String>,
        is_script: bool,
        action_verb: impl Into<String>,
        shortcut: Option<String>,
    ) -> Self {
        ScriptInfo {
            name: name.into(),
            path: path.into(),
            is_script,
            is_scriptlet: false,
            is_agent: false,
            action_verb: action_verb.into(),
            shortcut,
            alias: None,
            is_suggested: false,
            frecency_path: None,
        }
    }

    /// Create a ScriptInfo with all options including custom action verb, shortcut, and alias
    #[allow(dead_code)]
    pub fn with_all(
        name: impl Into<String>,
        path: impl Into<String>,
        is_script: bool,
        action_verb: impl Into<String>,
        shortcut: Option<String>,
        alias: Option<String>,
    ) -> Self {
        ScriptInfo {
            name: name.into(),
            path: path.into(),
            is_script,
            is_scriptlet: false,
            is_agent: false,
            action_verb: action_verb.into(),
            shortcut,
            alias,
            is_suggested: false,
            frecency_path: None,
        }
    }

    /// Set whether this item is suggested (has frecency data) and its frecency path
    pub fn with_frecency(mut self, is_suggested: bool, frecency_path: Option<String>) -> Self {
        self.is_suggested = is_suggested;
        self.frecency_path = frecency_path;
        self
    }
}

/// Represents a single action item in the actions menu.
///
/// Actions are created by builder functions in `builders.rs` or converted from
/// SDK-provided `ProtocolAction` messages. Each action has a unique identifier,
/// display title, and category for grouping.
///
/// # Action ID Convention
///
/// - Built-in actions: snake_case IDs (`edit_script`, `copy_path`, etc.)
/// - SDK actions: Use the `name` field from ProtocolAction as-is
/// - Scriptlet actions: Prefixed with `scriptlet_action:` followed by command
///
/// # Routing via has_action
///
/// The `has_action` field determines how actions are executed:
/// - `false` (default for built-ins): Handle locally in Rust via `handle_action()`
/// - `true` (SDK actions): Send `ActionTriggered` message to script for handling
///
/// Note: The routing logic in `handle_action()` may also read from the original
/// `ProtocolAction` for SDK-provided actions to ensure consistency.
///
/// # Examples
///
/// ```ignore
/// // Built-in action (has_action defaults to false)
/// let action = Action::new(
///     "edit_script",
///     "Edit Script",
///     Some("Open in $EDITOR".to_string()),
///     ActionCategory::ScriptContext,
/// ).with_shortcut("E");
///
/// // Scriptlet action (has_action=true for SDK handling)
/// let mut action = Action::new(
///     "scriptlet_action:copy-to-clipboard",
///     "Copy to Clipboard",
///     None,
///     ActionCategory::ScriptContext,
/// );
/// action.has_action = true;
/// action.value = Some("copy-to-clipboard".to_string());
/// ```
#[derive(Debug, Clone)]
pub struct Action {
    /// Unique identifier for action routing.
    /// Built-in IDs use snake_case (e.g., `edit_script`, `copy_path`).
    /// SDK action IDs match the ProtocolAction name.
    pub id: String,

    /// Display title shown in the actions menu
    pub title: String,

    /// Optional description shown below the title
    pub description: Option<String>,

    /// Category for grouping actions in the menu
    pub category: ActionCategory,

    /// Optional keyboard shortcut hint (e.g., "E", "K")
    /// Displayed as a badge next to the action title
    pub shortcut: Option<String>,

    /// Routing flag: if true, send ActionTriggered to SDK; if false, handle locally.
    /// Built-in actions default to false. SDK actions with handlers set this to true.
    #[allow(dead_code)]
    pub has_action: bool,

    /// Optional value to submit when action is triggered.
    /// For scriptlet actions, this contains the command to execute.
    #[allow(dead_code)]
    pub value: Option<String>,

    /// Optional icon to display next to the action title
    pub icon: Option<IconName>,

    /// Section/group name for display (used with SectionStyle::Headers)
    pub section: Option<String>,
}

/// Configuration for how the search input is positioned
#[allow(dead_code)] // Public API - will be used by AI window integration
#[derive(Debug, Clone, Copy, PartialEq, Eq, Default)]
pub enum SearchPosition {
    /// Search input at top (AI chat style - list grows downward)
    Top,
    /// Search input at bottom (main menu style - list grows upward)
    #[default]
    Bottom,
    /// No search input (external search handling)
    Hidden,
}

/// Configuration for how sections/categories are displayed
#[allow(dead_code)] // Public API - will be used by AI window integration
#[derive(Debug, Clone, Copy, PartialEq, Eq, Default)]
pub enum SectionStyle {
    /// Show text headers for sections (AI chat style)
    Headers,
    /// Show subtle separators between categories (main menu style)
    #[default]
    Separators,
    /// No section indicators
    None,
}

/// Configuration for dialog anchor position during resize
#[allow(dead_code)] // Public API - will be used by AI window integration
#[derive(Debug, Clone, Copy, PartialEq, Eq, Default)]
pub enum AnchorPosition {
    /// Dialog grows/shrinks from top (content pinned to top)
    Top,
    /// Dialog grows/shrinks from bottom (content pinned to bottom)
    #[default]
    Bottom,
}

/// Complete configuration for ActionsDialog appearance and behavior
#[allow(dead_code)] // Public API - will be used by AI window integration
#[derive(Debug, Clone, Default)]
pub struct ActionsDialogConfig {
    /// Position of search input
    pub search_position: SearchPosition,
    /// How to display section/category divisions
    pub section_style: SectionStyle,
    /// Which edge the dialog anchors to during resize
    pub anchor: AnchorPosition,
    /// Whether to show icons for actions (if available)
    pub show_icons: bool,
    /// Whether to show the footer with keyboard hints
    pub show_footer: bool,
}

/// Category for grouping actions in the actions menu.
///
/// Actions are organized by category to help users find relevant options:
/// - `ScriptContext`: Actions specific to the currently focused script/item
/// - `ScriptOps`: Script management operations (reserved for future use)
/// - `GlobalOps`: Application-wide actions like Settings, Quit (reserved)
///
/// Currently, most actions are `ScriptContext` since they operate on the
/// focused list item. The other categories are reserved for future expansion.
#[derive(Debug, Clone, PartialEq)]
pub enum ActionCategory {
    /// Actions specific to the currently focused script/item.
    /// Examples: Run, Edit, Copy Path, Configure Shortcut, Reset Ranking
    ScriptContext,

    /// Script management operations (reserved for future use).
    /// Intended for: Create Script, Delete Script, Duplicate Script
    #[allow(dead_code)]
    ScriptOps,

    /// Application-wide actions (reserved for future use).
    /// Intended for: Open Settings, Quit App, Check for Updates
    #[allow(dead_code)]
    GlobalOps,
}

impl Action {
    pub fn new(
        id: impl Into<String>,
        title: impl Into<String>,
        description: Option<String>,
        category: ActionCategory,
    ) -> Self {
        Action {
            id: id.into(),
            title: title.into(),
            description,
            category,
            shortcut: None,
            has_action: false,
            value: None,
            icon: None,
            section: None,
        }
    }

    pub fn with_shortcut(mut self, shortcut: impl Into<String>) -> Self {
        self.shortcut = Some(shortcut.into());
        self
    }

    #[allow(dead_code)] // Public API - used by get_ai_command_bar_actions
    pub fn with_icon(mut self, icon: IconName) -> Self {
        self.icon = Some(icon);
        self
    }

    #[allow(dead_code)] // Public API - used by get_ai_command_bar_actions
    pub fn with_section(mut self, section: impl Into<String>) -> Self {
        self.section = Some(section.into());
        self
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_script_info_creation() {
        let script = ScriptInfo::new("test-script", "/path/to/test-script.ts");
        assert_eq!(script.name, "test-script");
        assert_eq!(script.path, "/path/to/test-script.ts");
        assert!(script.is_script);
        assert!(!script.is_scriptlet);
        assert!(script.shortcut.is_none());
        assert!(script.alias.is_none());
    }

    #[test]
    fn test_script_info_with_shortcut() {
        let script = ScriptInfo::with_shortcut(
            "test-script",
            "/path/to/test-script.ts",
            Some("cmd+shift+t".to_string()),
        );
        assert_eq!(script.name, "test-script");
        assert!(script.is_script);
        assert!(!script.is_scriptlet);
        assert_eq!(script.shortcut, Some("cmd+shift+t".to_string()));
    }

    #[test]
    fn test_script_info_scriptlet() {
        let scriptlet = ScriptInfo::scriptlet(
            "Open GitHub",
            "/path/to/url.md#open-github",
            Some("cmd+g".to_string()),
            Some("gh".to_string()),
        );
        assert_eq!(scriptlet.name, "Open GitHub");
        assert_eq!(scriptlet.path, "/path/to/url.md#open-github");
        assert!(!scriptlet.is_script);
        assert!(scriptlet.is_scriptlet);
        assert_eq!(scriptlet.shortcut, Some("cmd+g".to_string()));
        assert_eq!(scriptlet.alias, Some("gh".to_string()));
        assert_eq!(scriptlet.action_verb, "Run");
    }

    #[test]
    fn test_script_info_builtin() {
        let builtin = ScriptInfo::builtin("Clipboard History");
        assert_eq!(builtin.name, "Clipboard History");
        assert_eq!(builtin.path, "");
        assert!(!builtin.is_script);
        assert!(!builtin.is_scriptlet);
        assert!(builtin.shortcut.is_none());
        assert!(builtin.alias.is_none());
    }

    #[test]
    fn test_script_info_with_is_script() {
        let script = ScriptInfo::with_is_script("my-script", "/path/to/script.ts", true);
        assert!(script.is_script);
        assert!(!script.is_scriptlet);
        assert!(script.shortcut.is_none());

        let builtin = ScriptInfo::with_is_script("App Launcher", "", false);
        assert!(!builtin.is_script);
        assert!(!builtin.is_scriptlet);
    }

    #[test]
    fn test_script_info_with_action_verb_and_shortcut() {
        let script = ScriptInfo::with_action_verb_and_shortcut(
            "test",
            "/path",
            true,
            "Launch",
            Some("cmd+k".to_string()),
        );
        assert_eq!(script.action_verb, "Launch");
        assert!(!script.is_scriptlet);
        assert_eq!(script.shortcut, Some("cmd+k".to_string()));
    }

    #[test]
    fn test_action_with_shortcut() {
        let action =
            Action::new("test", "Test Action", None, ActionCategory::GlobalOps).with_shortcut("T");
        assert_eq!(action.shortcut, Some("T".to_string()));
    }

    #[test]
    fn test_action_new_defaults() {
        let action = Action::new(
            "id",
            "title",
            Some("desc".to_string()),
            ActionCategory::ScriptContext,
        );
        assert_eq!(action.id, "id");
        assert_eq!(action.title, "title");
        assert_eq!(action.description, Some("desc".to_string()));
        assert_eq!(action.category, ActionCategory::ScriptContext);
        assert!(action.shortcut.is_none());
    }

    #[test]
    fn test_script_info_with_shortcut_and_alias() {
        let script = ScriptInfo::with_shortcut_and_alias(
            "test-script",
            "/path/to/test-script.ts",
            Some("cmd+shift+t".to_string()),
            Some("ts".to_string()),
        );
        assert_eq!(script.name, "test-script");
        assert_eq!(script.shortcut, Some("cmd+shift+t".to_string()));
        assert_eq!(script.alias, Some("ts".to_string()));
    }

    #[test]
    fn test_script_info_with_all() {
        let script = ScriptInfo::with_all(
            "App Launcher",
            "builtin:app-launcher",
            false,
            "Open",
            Some("cmd+space".to_string()),
            Some("apps".to_string()),
        );
        assert_eq!(script.name, "App Launcher");
        assert_eq!(script.path, "builtin:app-launcher");
        assert!(!script.is_script);
        assert_eq!(script.action_verb, "Open");
        assert_eq!(script.shortcut, Some("cmd+space".to_string()));
        assert_eq!(script.alias, Some("apps".to_string()));
    }

    #[test]
    fn test_script_info_with_frecency() {
        // Test with_frecency builder method
        let script = ScriptInfo::new("test-script", "/path/to/script.ts")
            .with_frecency(true, Some("/path/to/script.ts".to_string()));

        assert!(script.is_suggested);
        assert_eq!(script.frecency_path, Some("/path/to/script.ts".to_string()));
    }

    #[test]
    fn test_script_info_default_frecency_values() {
        // Test that default values are correct (not suggested, no frecency path)
        let script = ScriptInfo::new("test-script", "/path/to/script.ts");
        assert!(!script.is_suggested);
        assert!(script.frecency_path.is_none());

        let scriptlet = ScriptInfo::scriptlet("Open GitHub", "/path/to/url.md", None, None);
        assert!(!scriptlet.is_suggested);
        assert!(scriptlet.frecency_path.is_none());

        let builtin = ScriptInfo::builtin("Clipboard History");
        assert!(!builtin.is_suggested);
        assert!(builtin.frecency_path.is_none());
    }

    #[test]
    fn test_script_info_frecency_chaining() {
        // Test that with_frecency can be chained with other constructors
        let script = ScriptInfo::with_shortcut_and_alias(
            "test-script",
            "/path/to/test.ts",
            Some("cmd+t".to_string()),
            Some("ts".to_string()),
        )
        .with_frecency(true, Some("frecency:path".to_string()));

        // Original fields preserved
        assert_eq!(script.shortcut, Some("cmd+t".to_string()));
        assert_eq!(script.alias, Some("ts".to_string()));

        // Frecency fields set
        assert!(script.is_suggested);
        assert_eq!(script.frecency_path, Some("frecency:path".to_string()));
    }
}

</file>

<file path="src/components/button.rs">
//! Reusable Button component for GPUI Script Kit
//!
//! This module provides a theme-aware button component with multiple variants
//! and support for hover states, click handlers, and keyboard shortcuts.

#![allow(dead_code)]

use gpui::*;
use std::rc::Rc;

/// Button variant determines the visual style
#[derive(Debug, Clone, Copy, PartialEq, Eq, Default)]
pub enum ButtonVariant {
    /// Primary button with filled background (accent color)
    #[default]
    Primary,
    /// Ghost button with text only (no background)
    Ghost,
    /// Icon button (compact, for icons)
    Icon,
}

/// Pre-computed colors for Button rendering
///
/// This struct holds the primitive color values needed for button rendering,
/// allowing efficient use in closures without cloning the full theme.
#[derive(Clone, Copy, Debug)]
pub struct ButtonColors {
    /// Text color for the button label
    pub text_color: u32,
    /// Text color when hovering (reserved for future use)
    #[allow(dead_code)]
    pub text_hover: u32,
    /// Background color (for Primary variant)
    pub background: u32,
    /// Background color when hovering
    pub background_hover: u32,
    /// Accent color for highlights
    pub accent: u32,
    /// Border color
    pub border: u32,
    /// Focus ring color (shown when button is focused)
    pub focus_ring: u32,
    /// Subtle background tint when focused
    pub focus_tint: u32,
}

impl ButtonColors {
    /// Create ButtonColors from theme reference
    /// Uses accent.selected (yellow/gold) to match logo and selected item highlights
    pub fn from_theme(theme: &crate::theme::Theme) -> Self {
        Self {
            text_color: theme.colors.accent.selected, // Yellow/gold - matches logo & highlights
            text_hover: theme.colors.text.primary,
            background: theme.colors.accent.selected_subtle,
            background_hover: theme.colors.accent.selected_subtle,
            accent: theme.colors.accent.selected, // Yellow/gold - matches logo & highlights
            border: theme.colors.ui.border,
            focus_ring: theme.colors.accent.selected, // Accent color for focus ring
            focus_tint: theme.colors.accent.selected_subtle, // Subtle tint when focused
        }
    }

    /// Create ButtonColors from design colors for design system support
    /// Uses the primary accent color to match the design's brand
    pub fn from_design(colors: &crate::designs::DesignColors) -> Self {
        Self {
            text_color: colors.accent, // Primary accent (yellow/gold for default)
            text_hover: colors.text_primary,
            background: colors.background_selected,
            background_hover: colors.background_hover,
            accent: colors.accent, // Primary accent (yellow/gold for default)
            border: colors.border,
            focus_ring: colors.accent, // Accent color for focus ring
            focus_tint: colors.background_selected, // Subtle tint when focused
        }
    }
}

impl Default for ButtonColors {
    fn default() -> Self {
        Self {
            text_color: 0xfbbf24,       // Yellow/gold (Script Kit brand color)
            text_hover: 0xffffff,       // White
            background: 0x2a2a2a,       // Dark gray
            background_hover: 0x323232, // Slightly lighter
            accent: 0xfbbf24,           // Yellow/gold (Script Kit brand color)
            border: 0x464647,           // Border color
            focus_ring: 0xfbbf24,       // Yellow/gold for focus ring
            focus_tint: 0x2a2a2a,       // Subtle tint when focused
        }
    }
}

/// Callback type for button click events
pub type OnClickCallback = Box<dyn Fn(&ClickEvent, &mut Window, &mut App) + 'static>;

/// A reusable button component for interactive actions
///
/// Supports:
/// - Label text (required)
/// - Keyboard shortcut display (optional)
/// - Three variants: Primary, Ghost, Icon
/// - Hover states with themed colors
/// - Focus ring styling
/// - Click callback
///
#[derive(IntoElement)]
pub struct Button {
    label: SharedString,
    colors: ButtonColors,
    variant: ButtonVariant,
    shortcut: Option<String>,
    disabled: bool,
    focused: bool,
    on_click: Option<Rc<OnClickCallback>>,
}

impl Button {
    /// Create a new button with the given label and pre-computed colors
    pub fn new(label: impl Into<SharedString>, colors: ButtonColors) -> Self {
        Self {
            label: label.into(),
            colors,
            variant: ButtonVariant::default(),
            shortcut: None,
            disabled: false,
            focused: false,
            on_click: None,
        }
    }

    /// Set the button variant (Primary, Ghost, Icon)
    pub fn variant(mut self, variant: ButtonVariant) -> Self {
        self.variant = variant;
        self
    }

    /// Set the keyboard shortcut display text
    pub fn shortcut(mut self, shortcut: impl Into<String>) -> Self {
        self.shortcut = Some(shortcut.into());
        self
    }

    /// Set an optional shortcut (convenience for Option<String>)
    pub fn shortcut_opt(mut self, shortcut: Option<String>) -> Self {
        self.shortcut = shortcut;
        self
    }

    /// Set whether the button is disabled
    pub fn disabled(mut self, disabled: bool) -> Self {
        self.disabled = disabled;
        self
    }

    /// Set whether the button is focused (shows focus ring)
    pub fn focused(mut self, focused: bool) -> Self {
        self.focused = focused;
        self
    }

    /// Set the click callback
    pub fn on_click(mut self, callback: OnClickCallback) -> Self {
        self.on_click = Some(Rc::new(callback));
        self
    }

    /// Set the label text
    pub fn label(mut self, label: impl Into<SharedString>) -> Self {
        self.label = label.into();
        self
    }
}

/// Focus ring border width
const FOCUS_BORDER_WIDTH: f32 = 2.0;

impl RenderOnce for Button {
    fn render(self, _window: &mut Window, _cx: &mut App) -> impl IntoElement {
        let colors = self.colors;
        let variant = self.variant;
        let disabled = self.disabled;
        let focused = self.focused;
        let on_click_callback = self.on_click;
        let label_for_log = self.label.clone();

        // Calculate colors based on variant
        // Hover uses white at ~15% alpha - universal "lift" effect that works on any dark bg
        let hover_overlay = rgba(0xffffff26); // white at ~15% alpha (0x26 = 38/255  15%)

        // Focus styling colors
        // 0xA0 = 62.5% opacity for visible focus ring
        let focus_ring_color = rgba((colors.focus_ring << 8) | 0xA0);
        // 0x20 = 12.5% opacity for subtle background tint
        let focus_tint = rgba((colors.focus_tint << 8) | 0x20);
        // 0x40 = 25% opacity for unfocused border
        let unfocused_border = rgba((colors.border << 8) | 0x40);

        let (text_color, bg_color, hover_bg) = match variant {
            ButtonVariant::Primary => {
                // Primary: filled background with accent color
                // When focused, add subtle tint on top
                let base_bg = rgba((colors.background << 8) | 0x80);
                let bg = if focused {
                    // Brighter when focused
                    rgba((colors.background << 8) | 0xA0)
                } else {
                    base_bg
                };
                (
                    rgb(colors.accent),
                    bg,
                    rgba((colors.background_hover << 8) | 0xB0),
                )
            }
            ButtonVariant::Ghost => {
                // Ghost: text only (accent color), white overlay on hover
                // When focused, add subtle tint
                let bg = if focused {
                    focus_tint
                } else {
                    rgba(0x00000000)
                };
                (rgb(colors.accent), bg, hover_overlay)
            }
            ButtonVariant::Icon => {
                // Icon: compact, accent color, white overlay on hover
                let bg = if focused {
                    focus_tint
                } else {
                    rgba(0x00000000)
                };
                (rgb(colors.accent), bg, hover_overlay)
            }
        };

        // Build shortcut element if present - smaller than label, same accent color
        // Use flex + items_center to ensure vertical alignment with the label
        let shortcut_element = if let Some(sc) = self.shortcut {
            div()
                .flex()
                .items_center()
                .text_xs()
                .ml(rems(0.25))
                .child(sc)
        } else {
            div()
        };

        // Determine padding based on variant (rem-relative for consistent scaling)
        let (px_val, py_val) = match variant {
            ButtonVariant::Primary => (rems(0.75), rems(0.375)), // 12px, 6px at 16px base
            ButtonVariant::Ghost => (rems(0.5), rems(0.25)),     // 8px, 4px at 16px base
            ButtonVariant::Icon => (rems(0.375), rems(0.375)),   // 6px, 6px at 16px base
        };

        // Build the button element
        let mut button = div()
            .id(ElementId::Name(self.label.clone()))
            .flex()
            .flex_row()
            .items_center()
            .justify_center()
            .gap(rems(0.125))
            .px(px_val)
            .py(py_val)
            .rounded(px(6.))
            .bg(bg_color)
            .text_color(text_color)
            .text_sm()
            .font_weight(FontWeight::MEDIUM)
            .font_family(".AppleSystemUIFont")
            .cursor_pointer()
            .child(self.label)
            .child(shortcut_element);

        // Apply focus ring styling
        if focused {
            button = button
                .border(px(FOCUS_BORDER_WIDTH))
                .border_color(focus_ring_color);
        } else {
            button = button.border_1().border_color(unfocused_border);
        }

        // Apply hover styles unless disabled
        // Keep text color the same, just add subtle background lift
        if !disabled {
            button = button.hover(move |s| s.bg(hover_bg));
        } else {
            button = button.opacity(0.5).cursor_default();
        }

        // Add click handler if provided
        if let Some(callback) = on_click_callback {
            if !disabled {
                button = button.on_click(move |event, window, cx| {
                    tracing::debug!(button = %label_for_log, "Button clicked");
                    callback(event, window, cx);
                });
            }
        }

        button
    }
}

// Note: Tests omitted for this module due to GPUI macro recursion limit issues.
// The Button component is integration-tested via the main application's
// actions dialog and prompt button rendering.
//
// Verified traits:
// - ButtonColors: Copy, Clone, Debug, Default
// - ButtonVariant: Copy, Clone, Debug, PartialEq, Eq, Default
// - Button: builder pattern with .variant(), .shortcut(), .on_click(), .disabled(), .label()

</file>

<file path="src/focus_coordinator.rs">
//! Focus Coordinator - Centralized focus management for Script Kit GPUI
//!
//! This module provides a single control plane for focus management, replacing
//! the scattered `focused_input` + `pending_focus` pattern with a unified system.
//!
//! # Architecture
//!
//! The FocusCoordinator owns:
//! - **pending**: The next focus request to apply (applied once in render, then cleared)
//! - **restore_stack**: Stack of focus states for overlay push/pop semantics
//! - **current_cursor_owner**: Single source of truth for cursor blink ownership
//!
//! # Key Concepts
//!
//! - **FocusTarget**: Where focus should go (MainFilter, ActionsDialog, specific prompts)
//! - **CursorOwner**: Which input gets the blinking cursor (for text input UX)
//! - **FocusRequest**: Complete focus intent (target + cursor owner)
//!
//! # Usage Patterns
//!
//! ```rust,ignore
//! // Request focus to main filter with cursor
//! coordinator.request(FocusRequest::main_filter());
//!
//! // Push overlay (actions dialog) - saves current state for restore
//! coordinator.push_overlay(FocusRequest::actions_dialog());
//!
//! // Pop overlay - restores previous focus state
//! coordinator.pop_overlay();
//!
//! // Apply pending focus (called once per render when appropriate)
//! if let Some(request) = coordinator.take_pending() {
//!     // ... apply focus based on request.target
//! }
//! ```

use crate::logging;

/// Tracks which input field currently owns the blinking cursor.
///
/// This is separate from GPUI focus - an input can be "focused" for GPUI purposes
/// (receiving keyboard events) but not be the cursor owner (not showing a blinking cursor).
///
/// Replaces the old `FocusedInput` enum with clearer semantics.
#[derive(Debug, Clone, Copy, PartialEq, Eq, Default)]
pub enum CursorOwner {
    /// Main script list filter input
    MainFilter,
    /// Actions dialog search input
    ActionsSearch,
    /// Arg prompt input (when running a script)
    ArgPrompt,
    /// Chat prompt input
    ChatPrompt,
    /// No input owns the cursor (e.g., terminal, editor with own cursor)
    #[default]
    None,
}

/// Identifies the target element that should receive GPUI focus.
///
/// Unlike the old FocusTarget, this enum does NOT include "AppRoot" as a magic
/// indirection. Each variant maps directly to the actual focus destination.
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
#[allow(dead_code)] // All variants are part of the API for gradual migration
pub enum FocusTarget {
    /// Focus the main filter input (gpui_input_state)
    MainFilter,
    /// Focus the actions dialog's search input
    ActionsDialog,
    /// Focus the arg prompt (uses main app's focus_handle + ArgPrompt cursor)
    ArgPrompt,
    /// Focus the path prompt's focus handle
    PathPrompt,
    /// Focus the form prompt (delegates to active field)
    FormPrompt,
    /// Focus the editor prompt
    EditorPrompt,
    /// Focus the select prompt
    SelectPrompt,
    /// Focus the env prompt
    EnvPrompt,
    /// Focus the drop prompt
    DropPrompt,
    /// Focus the template prompt
    TemplatePrompt,
    /// Focus the term prompt
    TermPrompt,
    /// Focus the chat prompt
    ChatPrompt,
    /// Focus the div prompt (uses app root, no cursor)
    DivPrompt,
    /// Focus the scratchpad editor
    ScratchPad,
    /// Focus the quick terminal
    QuickTerminal,
}

impl FocusTarget {
    /// Returns the default cursor owner for this focus target.
    ///
    /// Most prompts own their own cursor (None), but some delegate to the
    /// main app's input system.
    pub fn default_cursor_owner(self) -> CursorOwner {
        match self {
            FocusTarget::MainFilter => CursorOwner::MainFilter,
            FocusTarget::ActionsDialog => CursorOwner::ActionsSearch,
            FocusTarget::ArgPrompt => CursorOwner::ArgPrompt,
            FocusTarget::ChatPrompt => CursorOwner::ChatPrompt,
            // These prompts have their own cursor management
            FocusTarget::PathPrompt
            | FocusTarget::FormPrompt
            | FocusTarget::EditorPrompt
            | FocusTarget::SelectPrompt
            | FocusTarget::EnvPrompt
            | FocusTarget::DropPrompt
            | FocusTarget::TemplatePrompt
            | FocusTarget::TermPrompt
            | FocusTarget::DivPrompt
            | FocusTarget::ScratchPad
            | FocusTarget::QuickTerminal => CursorOwner::None,
        }
    }
}

/// A complete focus request: where to focus + who owns the cursor.
///
/// This replaces the old pattern of setting `focused_input` and `pending_focus`
/// separately with hidden coupling between them.
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub struct FocusRequest {
    /// The element that should receive GPUI focus
    pub target: FocusTarget,
    /// Which input gets the blinking cursor (can differ from focus target)
    pub cursor: CursorOwner,
}

impl FocusRequest {
    /// Create a new focus request with explicit target and cursor owner.
    #[allow(dead_code)]
    pub fn new(target: FocusTarget, cursor: CursorOwner) -> Self {
        Self { target, cursor }
    }

    /// Create a focus request with default cursor owner for the target.
    pub fn with_default_cursor(target: FocusTarget) -> Self {
        Self {
            target,
            cursor: target.default_cursor_owner(),
        }
    }

    // === Convenience constructors ===

    /// Focus main filter with cursor
    pub fn main_filter() -> Self {
        Self::with_default_cursor(FocusTarget::MainFilter)
    }

    /// Focus actions dialog with cursor in search
    pub fn actions_dialog() -> Self {
        Self::with_default_cursor(FocusTarget::ActionsDialog)
    }

    /// Focus arg prompt with cursor
    pub fn arg_prompt() -> Self {
        Self::with_default_cursor(FocusTarget::ArgPrompt)
    }

    /// Focus chat prompt with cursor
    pub fn chat_prompt() -> Self {
        Self::with_default_cursor(FocusTarget::ChatPrompt)
    }

    /// Focus div prompt (no cursor)
    #[allow(dead_code)]
    pub fn div_prompt() -> Self {
        Self::with_default_cursor(FocusTarget::DivPrompt)
    }

    /// Focus form prompt (delegates to active field)
    #[allow(dead_code)]
    pub fn form_prompt() -> Self {
        Self::with_default_cursor(FocusTarget::FormPrompt)
    }

    /// Focus path prompt
    #[allow(dead_code)]
    pub fn path_prompt() -> Self {
        Self::with_default_cursor(FocusTarget::PathPrompt)
    }

    /// Focus editor prompt
    #[allow(dead_code)]
    pub fn editor_prompt() -> Self {
        Self::with_default_cursor(FocusTarget::EditorPrompt)
    }

    /// Focus select prompt
    #[allow(dead_code)]
    pub fn select_prompt() -> Self {
        Self::with_default_cursor(FocusTarget::SelectPrompt)
    }

    /// Focus env prompt
    #[allow(dead_code)]
    pub fn env_prompt() -> Self {
        Self::with_default_cursor(FocusTarget::EnvPrompt)
    }

    /// Focus drop prompt
    #[allow(dead_code)]
    pub fn drop_prompt() -> Self {
        Self::with_default_cursor(FocusTarget::DropPrompt)
    }

    /// Focus template prompt
    #[allow(dead_code)]
    pub fn template_prompt() -> Self {
        Self::with_default_cursor(FocusTarget::TemplatePrompt)
    }

    /// Focus term prompt
    #[allow(dead_code)]
    pub fn term_prompt() -> Self {
        Self::with_default_cursor(FocusTarget::TermPrompt)
    }

    /// Focus scratchpad
    #[allow(dead_code)]
    pub fn scratchpad() -> Self {
        Self::with_default_cursor(FocusTarget::ScratchPad)
    }

    /// Focus quick terminal
    #[allow(dead_code)]
    pub fn quick_terminal() -> Self {
        Self::with_default_cursor(FocusTarget::QuickTerminal)
    }
}

/// Centralized focus coordinator for the application.
///
/// This is the single source of truth for:
/// - What should be focused next (pending request)
/// - What was focused before an overlay opened (restore stack)
/// - Which input currently owns the cursor
///
/// # Focus Application
///
/// Focus is applied at a single choke point: `render()` calls `take_pending()`
/// and applies focus exactly once, then the pending request is cleared.
/// This prevents "perpetual focus enforcement" thrash.
///
/// # Overlay Semantics
///
/// Overlays (actions dialog, shortcut recorder, etc.) use push/pop:
/// - `push_overlay()`: Save current state, set new focus
/// - `pop_overlay()`: Restore previous state
///
/// This eliminates scattered restoration logic and "forgot to restore" bugs.
#[derive(Debug, Default)]
pub struct FocusCoordinator {
    /// Next focus request to apply (consumed once, then None)
    pending: Option<FocusRequest>,
    /// Stack of saved focus states for overlay restoration
    restore_stack: Vec<FocusRequest>,
    /// Current cursor owner (single source of truth)
    current_cursor_owner: CursorOwner,
}

impl FocusCoordinator {
    /// Create a new focus coordinator with default state.
    #[allow(dead_code)]
    pub fn new() -> Self {
        Self::default()
    }

    /// Create a coordinator with initial focus on main filter.
    pub fn with_main_filter_focus() -> Self {
        Self {
            pending: Some(FocusRequest::main_filter()),
            restore_stack: Vec::new(),
            current_cursor_owner: CursorOwner::MainFilter,
        }
    }

    // === Request Management ===

    /// Request focus to a target with its default cursor owner.
    ///
    /// This is the primary API for non-overlay focus changes.
    pub fn request(&mut self, request: FocusRequest) {
        logging::log(
            "FOCUS",
            &format!(
                "Focus request: target={:?}, cursor={:?}",
                request.target, request.cursor
            ),
        );
        self.pending = Some(request);
    }

    /// Request focus to a target with default cursor owner.
    #[allow(dead_code)]
    pub fn request_target(&mut self, target: FocusTarget) {
        self.request(FocusRequest::with_default_cursor(target));
    }

    /// Take the pending focus request (called once per render).
    ///
    /// Returns the request and clears pending. The caller is responsible
    /// for actually applying focus based on the request.
    #[allow(dead_code)]
    pub fn take_pending(&mut self) -> Option<FocusRequest> {
        let request = self.pending.take();
        if let Some(ref req) = request {
            // Update cursor owner when focus is applied
            self.current_cursor_owner = req.cursor;
            logging::log(
                "FOCUS",
                &format!(
                    "Applying pending focus: target={:?}, cursor={:?}",
                    req.target, req.cursor
                ),
            );
        }
        request
    }

    /// Check if there's a pending focus request.
    #[allow(dead_code)]
    pub fn has_pending(&self) -> bool {
        self.pending.is_some()
    }

    /// Peek at the pending request without consuming it.
    pub fn peek_pending(&self) -> Option<&FocusRequest> {
        self.pending.as_ref()
    }

    // === Overlay Push/Pop ===

    /// Push an overlay onto the stack and request its focus.
    ///
    /// Saves the current focus state (based on cursor owner) so it can be
    /// restored when `pop_overlay()` is called.
    pub fn push_overlay(&mut self, overlay_request: FocusRequest) {
        // Save current state for restoration
        let saved = self.infer_current_request();
        logging::log(
            "FOCUS",
            &format!(
                "Pushing overlay: {:?} (saving: {:?})",
                overlay_request.target, saved.target
            ),
        );
        self.restore_stack.push(saved);
        self.request(overlay_request);
    }

    /// Pop the overlay and restore previous focus.
    ///
    /// If the stack is empty, falls back to main filter focus.
    pub fn pop_overlay(&mut self) {
        let restored = self.restore_stack.pop().unwrap_or_else(|| {
            logging::log("FOCUS", "Restore stack empty, falling back to MainFilter");
            FocusRequest::main_filter()
        });
        logging::log(
            "FOCUS",
            &format!("Popping overlay, restoring to: {:?}", restored.target),
        );
        self.request(restored);
    }

    /// Clear all overlays and restore to main filter.
    ///
    /// Useful for "escape all" or error recovery.
    pub fn clear_overlays(&mut self) {
        if !self.restore_stack.is_empty() {
            logging::log(
                "FOCUS",
                &format!(
                    "Clearing {} overlay(s) from stack",
                    self.restore_stack.len()
                ),
            );
        }
        self.restore_stack.clear();
        self.request(FocusRequest::main_filter());
    }

    /// Get the current overlay depth.
    #[allow(dead_code)]
    pub fn overlay_depth(&self) -> usize {
        self.restore_stack.len()
    }

    /// Check if any overlay is active.
    #[allow(dead_code)]
    pub fn has_overlay(&self) -> bool {
        !self.restore_stack.is_empty()
    }

    // === Cursor Management ===

    /// Get the current cursor owner.
    pub fn cursor_owner(&self) -> CursorOwner {
        self.current_cursor_owner
    }

    /// Directly set cursor owner without changing focus target.
    ///
    /// Use sparingly - prefer `request()` which sets both consistently.
    #[allow(dead_code)]
    pub fn set_cursor_owner(&mut self, owner: CursorOwner) {
        self.current_cursor_owner = owner;
    }

    // === Internal Helpers ===

    /// Infer the current focus request from cursor owner.
    ///
    /// Used to save state when pushing overlays.
    fn infer_current_request(&self) -> FocusRequest {
        match self.current_cursor_owner {
            CursorOwner::MainFilter => FocusRequest::main_filter(),
            CursorOwner::ActionsSearch => FocusRequest::actions_dialog(),
            CursorOwner::ArgPrompt => FocusRequest::arg_prompt(),
            CursorOwner::ChatPrompt => FocusRequest::chat_prompt(),
            CursorOwner::None => {
                // When no cursor owner, we can't infer the exact target.
                // Default to main filter as the safest fallback.
                FocusRequest::main_filter()
            }
        }
    }
}

// === Legacy Compatibility ===
// These types help with gradual migration from the old system.

/// Maps old FocusedInput to new CursorOwner.
///
/// Use this during migration, then remove.
impl CursorOwner {
    /// Convert from old FocusedInput string representation.
    #[allow(dead_code)]
    pub fn from_legacy(s: &str) -> Self {
        match s {
            "MainFilter" => CursorOwner::MainFilter,
            "ActionsSearch" => CursorOwner::ActionsSearch,
            "ArgPrompt" => CursorOwner::ArgPrompt,
            "None" => CursorOwner::None,
            _ => CursorOwner::None,
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_focus_request_defaults() {
        let req = FocusRequest::main_filter();
        assert_eq!(req.target, FocusTarget::MainFilter);
        assert_eq!(req.cursor, CursorOwner::MainFilter);

        let req = FocusRequest::div_prompt();
        assert_eq!(req.target, FocusTarget::DivPrompt);
        assert_eq!(req.cursor, CursorOwner::None);
    }

    #[test]
    fn test_coordinator_request() {
        let mut coord = FocusCoordinator::new();
        assert!(!coord.has_pending());

        coord.request(FocusRequest::main_filter());
        assert!(coord.has_pending());

        let req = coord.take_pending();
        assert!(req.is_some());
        assert!(!coord.has_pending());
        assert_eq!(coord.cursor_owner(), CursorOwner::MainFilter);
    }

    #[test]
    fn test_overlay_push_pop() {
        let mut coord = FocusCoordinator::with_main_filter_focus();

        // Apply initial focus
        coord.take_pending();
        assert_eq!(coord.cursor_owner(), CursorOwner::MainFilter);
        assert_eq!(coord.overlay_depth(), 0);

        // Push overlay
        coord.push_overlay(FocusRequest::actions_dialog());
        assert_eq!(coord.overlay_depth(), 1);

        // Apply overlay focus
        let req = coord.take_pending().unwrap();
        assert_eq!(req.target, FocusTarget::ActionsDialog);
        assert_eq!(coord.cursor_owner(), CursorOwner::ActionsSearch);

        // Pop overlay
        coord.pop_overlay();
        let req = coord.take_pending().unwrap();
        assert_eq!(req.target, FocusTarget::MainFilter);
        assert_eq!(coord.overlay_depth(), 0);
    }

    #[test]
    fn test_overlay_clear() {
        let mut coord = FocusCoordinator::with_main_filter_focus();
        coord.take_pending();

        // Push multiple overlays
        coord.push_overlay(FocusRequest::actions_dialog());
        coord.take_pending();
        coord.push_overlay(FocusRequest::arg_prompt());
        coord.take_pending();

        assert_eq!(coord.overlay_depth(), 2);

        // Clear all
        coord.clear_overlays();
        assert_eq!(coord.overlay_depth(), 0);

        let req = coord.take_pending().unwrap();
        assert_eq!(req.target, FocusTarget::MainFilter);
    }

    #[test]
    fn test_pop_empty_stack_fallback() {
        let mut coord = FocusCoordinator::new();
        coord.pop_overlay();

        let req = coord.take_pending().unwrap();
        assert_eq!(req.target, FocusTarget::MainFilter);
    }
}

</file>

<file path="src/confirm/mod.rs">
//! Confirm Module
//!
//! A modal confirmation dialog that appears as a floating window.
//! Used by the SDK `confirm()` function to get user confirmation for actions.
//!
//! # Example Usage (SDK)
//! ```typescript
//! const confirmed = await confirm("Are you sure you want to delete this?");
//! if (confirmed) {
//!     // proceed with deletion
//! }
//!
//! // With custom button text
//! const proceed = await confirm({
//!     message: "Overwrite existing file?",
//!     confirmText: "Overwrite",
//!     cancelText: "Keep Original"
//! });
//! ```

mod constants;
mod dialog;
mod window;

pub use dialog::ConfirmCallback;
pub use window::{
    close_confirm_window, dispatch_confirm_key, init_confirm_bindings, is_confirm_window_open,
    open_confirm_window,
};

</file>

<file path="src/confirm/window.rs">
//! Confirm Window - Separate vibrancy window for confirmation dialog
//!
//! This creates a floating popup window with its own vibrancy blur effect,
//! similar to the actions panel. The window is:
//! - Non-draggable (fixed position relative to main window)
//! - Centered over the main window
//! - Auto-closes when choice is made
//!
//! Uses the same pattern as ActionsWindow:
//! - `track_focus` + `on_key_down` for direct key handling
//! - No actions/key bindings needed

use crate::platform;
use crate::theme;
use gpui::{
    div, prelude::*, px, App, Bounds, Context, DisplayId, Entity, FocusHandle, Focusable, Pixels,
    Point, Render, Size, Window, WindowBounds, WindowHandle, WindowKind, WindowOptions,
};
use gpui_component::Root;
use std::sync::{Mutex, OnceLock};

use super::constants::{CONFIRM_HEIGHT, CONFIRM_WIDTH};
use super::dialog::{ConfirmCallback, ConfirmDialog};

/// Global singleton for the confirm window handle
static CONFIRM_WINDOW: OnceLock<Mutex<Option<WindowHandle<Root>>>> = OnceLock::new();

/// Global singleton for the confirm dialog entity (for keyboard event dispatch)
static CONFIRM_DIALOG: OnceLock<Mutex<Option<Entity<ConfirmDialog>>>> = OnceLock::new();

/// ConfirmWindow wrapper that renders the ConfirmDialog entity
pub struct ConfirmWindow {
    /// The dialog entity
    pub dialog: Entity<ConfirmDialog>,
    /// Focus handle for this window
    pub focus_handle: FocusHandle,
}

impl ConfirmWindow {
    pub fn new(dialog: Entity<ConfirmDialog>, cx: &mut Context<Self>) -> Self {
        let focus_handle = cx.focus_handle();
        Self {
            dialog,
            focus_handle,
        }
    }
}

impl Focusable for ConfirmWindow {
    fn focus_handle(&self, _cx: &App) -> FocusHandle {
        self.focus_handle.clone()
    }
}

impl Render for ConfirmWindow {
    fn render(&mut self, window: &mut Window, cx: &mut Context<Self>) -> impl IntoElement {
        // Ensure we have focus for key events (same pattern as ActionsWindow)
        if !self.focus_handle.is_focused(window) {
            crate::logging::log(
                "CONFIRM",
                "ConfirmWindow: focus_handle NOT focused, re-focusing",
            );
            self.focus_handle.focus(window, cx);
        }

        // Key handler - same simple pattern as ActionsWindow
        // Direct on_key_down with string matching, no actions/key bindings needed
        let handle_key = cx.listener(move |this, event: &gpui::KeyDownEvent, _window, cx| {
            let key = event.keystroke.key.as_str();

            crate::logging::log(
                "CONFIRM",
                &format!("ConfirmWindow on_key_down received: key='{}'", key),
            );

            match key {
                // Enter/Return = submit current selection
                "enter" | "return" => {
                    crate::logging::log("CONFIRM", "Enter pressed - submitting");
                    this.dialog.update(cx, |d, _cx| d.submit());
                }
                // Space = submit current selection
                " " | "space" => {
                    crate::logging::log("CONFIRM", "Space pressed - submitting");
                    this.dialog.update(cx, |d, _cx| d.submit());
                }
                // Escape = cancel
                "escape" => {
                    crate::logging::log("CONFIRM", "Escape pressed - cancelling");
                    this.dialog.update(cx, |d, _cx| d.cancel());
                }
                // Tab = toggle between buttons
                "tab" => {
                    this.dialog.update(cx, |d, cx| {
                        d.toggle_focus(cx);
                        crate::logging::log(
                            "CONFIRM",
                            &format!("Tab pressed, focused_button now: {}", d.focused_button),
                        );
                    });
                    cx.notify();
                }
                // Left arrow = focus cancel button (index 0)
                "left" | "arrowleft" => {
                    crate::logging::log("CONFIRM", "Left arrow - focusing cancel");
                    this.dialog.update(cx, |d, cx| d.focus_cancel(cx));
                    cx.notify();
                }
                // Right arrow = focus confirm button (index 1)
                "right" | "arrowright" => {
                    crate::logging::log("CONFIRM", "Right arrow - focusing confirm");
                    this.dialog.update(cx, |d, cx| d.focus_confirm(cx));
                    cx.notify();
                }
                _ => {}
            }
        });

        // Render with focus tracking and key handler (same pattern as ActionsWindow)
        div()
            .track_focus(&self.focus_handle)
            .on_key_down(handle_key)
            .child(self.dialog.clone())
    }
}

/// Initialize confirm bindings (currently a no-op, key handling done via on_key_down)
///
/// This function exists for API compatibility. The ConfirmWindow handles
/// keyboard events directly via on_key_down rather than through action bindings.
pub fn init_confirm_bindings(_cx: &mut App) {
    crate::logging::log(
        "CONFIRM",
        "init_confirm_bindings called (no-op, keys handled via on_key_down)",
    );
}

/// Open the confirm window as a separate floating window with vibrancy
///
/// The window is centered over the main window.
///
/// # Arguments
/// * `cx` - The application context
/// * `main_window_bounds` - The bounds of the main window in SCREEN-RELATIVE coordinates
/// * `display_id` - The display where the main window is located
/// * `message` - The confirmation message
/// * `confirm_text` - Optional text for the confirm button
/// * `cancel_text` - Optional text for the cancel button
/// * `on_choice` - Callback when user makes a choice
///
/// # Returns
/// The window handle and dialog entity on success
pub fn open_confirm_window(
    cx: &mut App,
    main_window_bounds: Bounds<Pixels>,
    display_id: Option<DisplayId>,
    message: String,
    confirm_text: Option<String>,
    cancel_text: Option<String>,
    on_choice: ConfirmCallback,
) -> anyhow::Result<(WindowHandle<Root>, Entity<ConfirmDialog>)> {
    // Close any existing confirm window first
    close_confirm_window(cx);

    // Load theme for vibrancy settings
    let theme = theme::load_theme();
    let window_background = if theme.is_vibrancy_enabled() {
        gpui::WindowBackgroundAppearance::Blurred
    } else {
        gpui::WindowBackgroundAppearance::Opaque
    };

    // Calculate window position: centered over main window
    let window_width = px(CONFIRM_WIDTH);
    let window_height = px(CONFIRM_HEIGHT);

    let window_x =
        main_window_bounds.origin.x + (main_window_bounds.size.width - window_width) / 2.0;
    let window_y =
        main_window_bounds.origin.y + (main_window_bounds.size.height - window_height) / 2.0;

    let bounds = Bounds {
        origin: Point {
            x: window_x,
            y: window_y,
        },
        size: Size {
            width: window_width,
            height: window_height,
        },
    };

    crate::logging::log(
        "CONFIRM",
        &format!(
            "Opening confirm window at ({:?}, {:?}), size {:?}x{:?}",
            window_x, window_y, window_width, window_height
        ),
    );

    let window_options = WindowOptions {
        window_bounds: Some(WindowBounds::Windowed(bounds)),
        titlebar: None,
        window_background,
        focus: true, // Confirm window handles its own key events
        show: true,
        kind: WindowKind::PopUp,
        display_id,
        ..Default::default()
    };

    // Create the dialog entity first, then the window
    let theme_arc = std::sync::Arc::new(theme);
    let mut dialog_entity_holder: Option<Entity<ConfirmDialog>> = None;

    let handle = cx.open_window(window_options, |window, cx| {
        // Create the dialog entity
        let dialog = cx.new(|cx| {
            ConfirmDialog::new(
                message,
                confirm_text,
                cancel_text,
                cx.focus_handle(),
                on_choice,
                theme_arc.clone(),
            )
        });

        dialog_entity_holder = Some(dialog.clone());

        // Create the window wrapper
        let confirm_window = cx.new(|cx| {
            let cw = ConfirmWindow::new(dialog, cx);
            // Focus the confirm window so it receives keyboard events
            cw.focus_handle.focus(window, cx);
            cw
        });

        // Wrap in Root for gpui-component theming and vibrancy
        cx.new(|cx| Root::new(confirm_window, window, cx))
    })?;

    // Configure the window as non-movable on macOS
    // Use window.defer() to avoid RefCell borrow conflicts - GPUI may still have
    // internal state borrowed immediately after open_window returns.
    #[cfg(target_os = "macos")]
    {
        let _ = handle.update(cx, |_root, window, cx| {
            window.defer(cx, |_window, _cx| {
                use cocoa::appkit::NSApp;
                use cocoa::base::nil;
                use objc::{msg_send, sel, sel_impl};

                // Get the NSWindow from the app's windows array
                // The popup window should be the most recently created one
                unsafe {
                    let app: cocoa::base::id = NSApp();
                    let windows: cocoa::base::id = msg_send![app, windows];
                    let count: usize = msg_send![windows, count];
                    if count > 0 {
                        // Get the last window (most recently created)
                        let ns_window: cocoa::base::id = msg_send![windows, lastObject];
                        if ns_window != nil {
                            platform::configure_actions_popup_window(ns_window);
                        }
                    }
                }
            });
        });
    }

    // Store the handle globally
    let window_storage = CONFIRM_WINDOW.get_or_init(|| Mutex::new(None));
    if let Ok(mut guard) = window_storage.lock() {
        *guard = Some(handle);
    }

    let dialog_entity = dialog_entity_holder.expect("Dialog entity should have been created");

    // Store the dialog entity globally for keyboard event dispatch
    let dialog_storage = CONFIRM_DIALOG.get_or_init(|| Mutex::new(None));
    if let Ok(mut guard) = dialog_storage.lock() {
        *guard = Some(dialog_entity.clone());
    }

    crate::logging::log("CONFIRM", "Confirm popup window opened with vibrancy");

    Ok((handle, dialog_entity))
}

/// Close the confirm window if it's open
pub fn close_confirm_window(cx: &mut App) {
    // Clear the dialog entity first
    if let Some(dialog_storage) = CONFIRM_DIALOG.get() {
        if let Ok(mut guard) = dialog_storage.lock() {
            *guard = None;
        }
    }

    // Then close the window
    if let Some(window_storage) = CONFIRM_WINDOW.get() {
        if let Ok(mut guard) = window_storage.lock() {
            if let Some(handle) = guard.take() {
                crate::logging::log("CONFIRM", "Closing confirm popup window");
                let _ = handle.update(cx, |_root, window, _cx| {
                    window.remove_window();
                });
            }
        }
    }
}

/// Check if the confirm window is currently open
#[allow(dead_code)]
pub fn is_confirm_window_open() -> bool {
    if let Some(window_storage) = CONFIRM_WINDOW.get() {
        if let Ok(guard) = window_storage.lock() {
            return guard.is_some();
        }
    }
    false
}

/// Get the confirm window handle if it exists
#[allow(dead_code)]
pub fn get_confirm_window_handle() -> Option<WindowHandle<Root>> {
    if let Some(window_storage) = CONFIRM_WINDOW.get() {
        if let Ok(guard) = window_storage.lock() {
            return *guard;
        }
    }
    None
}

/// Notify the confirm window to re-render
#[allow(dead_code)]
pub fn notify_confirm_window(cx: &mut App) {
    if let Some(handle) = get_confirm_window_handle() {
        let _ = handle.update(cx, |_root, _window, cx| {
            cx.notify();
        });
    }
}

/// Dispatch a keyboard event to the confirm dialog
/// Returns true if the event was handled, false otherwise
pub fn dispatch_confirm_key(key: &str, cx: &mut App) -> bool {
    // Get the dialog entity from global storage
    let dialog_opt = if let Some(storage) = CONFIRM_DIALOG.get() {
        if let Ok(guard) = storage.lock() {
            guard.clone()
        } else {
            None
        }
    } else {
        None
    };

    let Some(dialog) = dialog_opt else {
        return false;
    };

    crate::logging::log(
        "CONFIRM",
        &format!("Dispatching key to confirm dialog: {}", key),
    );

    match key {
        // Enter = submit current selection and close
        "enter" | "Enter" => {
            dialog.update(cx, |d, _cx| d.submit());
            close_confirm_window(cx);
            true
        }
        // Space = activate focused button (standard HTML UX)
        "space" | "Space" | " " => {
            dialog.update(cx, |d, _cx| d.submit());
            close_confirm_window(cx);
            true
        }
        // Escape = cancel and close
        "escape" | "Escape" => {
            dialog.update(cx, |d, _cx| d.cancel());
            close_confirm_window(cx);
            true
        }
        // Tab = toggle focus between buttons
        "tab" | "Tab" => {
            dialog.update(cx, |d, cx| {
                d.toggle_focus(cx);
                crate::logging::log(
                    "CONFIRM",
                    &format!("Tab pressed, focused_button now: {}", d.focused_button),
                );
            });
            notify_confirm_window(cx);
            true
        }
        // Left arrow = focus cancel button
        "left" | "arrowleft" | "Left" | "ArrowLeft" => {
            dialog.update(cx, |d, cx| d.focus_cancel(cx));
            notify_confirm_window(cx);
            true
        }
        // Right arrow = focus confirm button
        "right" | "arrowright" | "Right" | "ArrowRight" => {
            dialog.update(cx, |d, cx| d.focus_confirm(cx));
            notify_confirm_window(cx);
            true
        }
        _ => false,
    }
}

</file>

<file path="src/confirm/dialog.rs">
//! Confirm Dialog
//!
//! A simple confirmation dialog with a message and two buttons (Cancel/Confirm).
//! Supports keyboard shortcuts: Enter = confirm, Escape = cancel.
//! Tab/Arrow keys navigate between buttons with visual focus indication.

use crate::logging;
use crate::theme;
use gpui::{
    div, prelude::*, px, rgb, rgba, App, Context, FocusHandle, Focusable, FontWeight, Render,
    SharedString, Window,
};
use std::sync::Arc;

use super::constants::{BUTTON_GAP, CONFIRM_PADDING, CONFIRM_WIDTH, DIALOG_RADIUS};

/// Callback for confirm/cancel selection
/// Signature: (confirmed: bool)
pub type ConfirmCallback = Arc<dyn Fn(bool) + Send + Sync>;

/// Helper function to combine a hex color with an alpha value
#[inline]
fn hex_with_alpha(hex: u32, alpha: u8) -> u32 {
    (hex << 8) | (alpha as u32)
}

/// ConfirmDialog - Simple confirmation modal with message and two buttons
pub struct ConfirmDialog {
    /// The message to display
    pub message: String,
    /// Text for the confirm button (default: "OK")
    pub confirm_text: String,
    /// Text for the cancel button (default: "Cancel")
    pub cancel_text: String,
    /// Focus handle for keyboard events
    pub focus_handle: FocusHandle,
    /// Callback when user makes a choice
    pub on_choice: ConfirmCallback,
    /// Theme for consistent styling
    pub theme: Arc<theme::Theme>,
    /// Which button is currently focused (0 = cancel, 1 = confirm)
    pub focused_button: usize,
}

impl ConfirmDialog {
    pub fn new(
        message: impl Into<String>,
        confirm_text: Option<String>,
        cancel_text: Option<String>,
        focus_handle: FocusHandle,
        on_choice: ConfirmCallback,
        theme: Arc<theme::Theme>,
    ) -> Self {
        let message_str = message.into();
        logging::log(
            "CONFIRM",
            &format!("ConfirmDialog created: {:?}", message_str),
        );

        Self {
            message: message_str,
            confirm_text: confirm_text.unwrap_or_else(|| "OK".to_string()),
            cancel_text: cancel_text.unwrap_or_else(|| "Cancel".to_string()),
            focus_handle,
            on_choice,
            theme,
            focused_button: 1, // Default focus on confirm button
        }
    }

    /// Handle left arrow key - move focus to cancel button
    pub fn focus_cancel(&mut self, cx: &mut Context<Self>) {
        if self.focused_button != 0 {
            self.focused_button = 0;
            cx.notify();
        }
    }

    /// Handle right arrow key - move focus to confirm button
    pub fn focus_confirm(&mut self, cx: &mut Context<Self>) {
        if self.focused_button != 1 {
            self.focused_button = 1;
            cx.notify();
        }
    }

    /// Handle Tab key - toggle between buttons
    pub fn toggle_focus(&mut self, cx: &mut Context<Self>) {
        self.focused_button = 1 - self.focused_button;
        cx.notify();
    }

    /// Submit the current selection (Enter key or clicking focused button)
    pub fn submit(&mut self) {
        let confirmed = self.focused_button == 1;
        logging::log(
            "CONFIRM",
            &format!(
                "User chose: {}",
                if confirmed { "confirm" } else { "cancel" }
            ),
        );
        (self.on_choice)(confirmed);
    }

    /// Cancel the dialog (Escape key)
    pub fn cancel(&mut self) {
        logging::log("CONFIRM", "User cancelled");
        (self.on_choice)(false);
    }

    /// Direct confirm (clicking confirm button)
    pub fn confirm(&mut self) {
        logging::log("CONFIRM", "User confirmed");
        (self.on_choice)(true);
    }
}

impl Focusable for ConfirmDialog {
    fn focus_handle(&self, _cx: &App) -> FocusHandle {
        self.focus_handle.clone()
    }
}

impl Render for ConfirmDialog {
    fn render(&mut self, _window: &mut Window, cx: &mut Context<Self>) -> impl IntoElement {
        // Log render with focus state for debugging
        logging::log(
            "CONFIRM",
            &format!(
                "ConfirmDialog::render() called, focused_button={}",
                self.focused_button
            ),
        );

        // Get theme colors
        let colors = &self.theme.colors;

        // Background with vibrancy support
        // Use the theme's opacity setting to match the main window's vibrancy look
        let use_vibrancy = self.theme.is_vibrancy_enabled();
        let dialog_alpha = if use_vibrancy {
            // Use theme's opacity setting (typically 0.30-0.37) for consistent vibrancy
            // This allows the blur to show through the dialog
            let opacity = self
                .theme
                .opacity
                .as_ref()
                .map(|o| o.main)
                .unwrap_or(0.37)
                .clamp(0.25, 0.50);
            (opacity * 255.0) as u8
        } else {
            // Near-opaque when vibrancy disabled
            (0.95 * 255.0) as u8
        };
        let main_bg = rgba(hex_with_alpha(colors.background.main, dialog_alpha));

        // Text colors
        let primary_text = rgb(colors.text.primary);

        // Border color for dialog
        let border_color = rgba(hex_with_alpha(colors.ui.border, 0x60));

        let message_str: SharedString = self.message.clone().into();

        let is_cancel_focused = self.focused_button == 0;
        let is_confirm_focused = self.focused_button == 1;

        // Button styling with OBVIOUS focus indication
        // Focused button gets accent background + bright border (like macOS default button)
        // Unfocused button is subtle/transparent
        let accent_hex = colors.accent.selected;
        let accent_color = rgb(accent_hex);

        // Focused: accent background at 40% opacity (very visible), white text
        let focused_bg = rgba(hex_with_alpha(accent_hex, 0x66)); // 40% accent
        let focused_text = rgb(0xFFFFFF); // White text on accent

        // Unfocused: barely visible, accent text
        let unfocused_bg = rgba(0xffffff10); // 6% white
        let hover_bg = rgba(0xffffff20); // 12% white on hover

        // Focus ring: bright accent border, unfocused gets subtle border
        let focus_border = rgba(hex_with_alpha(accent_hex, 0xFF)); // 100% accent
        let unfocused_border = rgba(0xffffff30); // 19% white

        // Cancel button
        let cancel_button = div()
            .id("cancel-btn")
            .flex_1()
            .h(px(44.0))
            .flex()
            .items_center()
            .justify_center()
            .rounded(px(8.0))
            .cursor_pointer()
            .font_weight(FontWeight::MEDIUM)
            // Focused: accent bg + white text, Unfocused: transparent + accent text
            .bg(if is_cancel_focused {
                focused_bg
            } else {
                unfocused_bg
            })
            .text_color(if is_cancel_focused {
                focused_text
            } else {
                accent_color
            })
            .border_2() // Thick border for visibility
            .border_color(if is_cancel_focused {
                focus_border
            } else {
                unfocused_border
            })
            .hover(|style| style.bg(hover_bg))
            .on_click(cx.listener(|this, _e, _window, _cx| {
                this.cancel();
            }))
            .child(self.cancel_text.clone());

        // Confirm button - same styling pattern
        let confirm_button = div()
            .id("confirm-btn")
            .flex_1()
            .h(px(44.0))
            .flex()
            .items_center()
            .justify_center()
            .rounded(px(8.0))
            .cursor_pointer()
            .font_weight(FontWeight::MEDIUM)
            // Focused: accent bg + white text, Unfocused: transparent + accent text
            .bg(if is_confirm_focused {
                focused_bg
            } else {
                unfocused_bg
            })
            .text_color(if is_confirm_focused {
                focused_text
            } else {
                accent_color
            })
            .border_2() // Thick border for visibility
            .border_color(if is_confirm_focused {
                focus_border
            } else {
                unfocused_border
            })
            .hover(|style| style.bg(hover_bg))
            .on_click(cx.listener(|this, _e, _window, _cx| {
                this.confirm();
            }))
            .child(self.confirm_text.clone());

        // Button row
        let button_row = div()
            .w_full()
            .flex()
            .flex_row()
            .gap(px(BUTTON_GAP))
            .child(cancel_button)
            .child(confirm_button);

        // Main dialog container
        // NOTE: No background - let window vibrancy show through
        let _ = main_bg; // Suppress unused warning
        div()
            .w(px(CONFIRM_WIDTH))
            .flex()
            .flex_col()
            .p(px(CONFIRM_PADDING))
            .gap(px(CONFIRM_PADDING))
            // No .bg() - vibrancy comes from the window
            .rounded(px(DIALOG_RADIUS))
            .border_1()
            .border_color(border_color)
            .overflow_hidden()
            // NOTE: Key handling is done by ConfirmWindow, not here
            // Message
            .child(
                div()
                    .w_full()
                    .text_color(primary_text)
                    .text_base()
                    .text_center()
                    .child(message_str),
            )
            // Buttons
            .child(button_row)
    }
}

</file>

<file path="src/confirm/constants.rs">
//! Confirm dialog constants
//!
//! Dimensions and styling constants for the confirm modal window.
//! Button styling now comes from the shared Button component.

/// Width of the confirm dialog
pub const CONFIRM_WIDTH: f32 = 340.0;

/// Height of the confirm dialog (message + buttons + padding)
pub const CONFIRM_HEIGHT: f32 = 140.0;

/// Padding around the dialog content
pub const CONFIRM_PADDING: f32 = 20.0;

/// Gap between buttons
pub const BUTTON_GAP: f32 = 12.0;

/// Dialog corner radius
pub const DIALOG_RADIUS: f32 = 12.0;

</file>

</files>