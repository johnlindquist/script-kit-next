This file is a merged representation of the filtered codebase, combined into a single document by packx.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of filtered repository contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<usage_guidelines>
- Treat this file as a snapshot of the repository's state
- Be aware that this file may contain sensitive information
</usage_guidelines>

<notes>
- Files were filtered by packx based on content and extension matching
- Total files included: 9
</notes>
</file_summary>

<directory_structure>
src/actions/mod.rs
src/actions/builders.rs
src/actions/window.rs
src/actions/dialog.rs
src/actions/constants.rs
src/actions/types.rs
src/shortcuts/registry.rs
src/shortcuts/types.rs
src/app_actions.rs
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="src/actions/mod.rs">
//! Actions Dialog Module
//!
//! Provides a searchable action menu as a compact overlay popup for quick access
//! to script management and global actions (edit, create, settings, quit, etc.)
//!
//! The dialog can be rendered in two ways:
//! 1. As an inline overlay within the main window (legacy)
//! 2. As a separate floating window with its own vibrancy blur (preferred)
//!
//! ## Module Structure
//! - `types`: Core types (Action, ActionCategory, ScriptInfo)
//! - `builders`: Factory functions for creating action lists
//! - `constants`: Popup dimensions and styling constants
//! - `dialog`: ActionsDialog struct and implementation
//! - `window`: Separate vibrancy window for actions panel

mod builders;
mod constants;
mod dialog;
mod types;
mod window;

// Re-export only the public API that is actually used externally:
// - ScriptInfo: used by main.rs for action context
// - ActionsDialog: the main dialog component
// - Window functions for separate vibrancy window

pub use dialog::ActionsDialog;
pub use types::ScriptInfo;

// Window functions for separate vibrancy window
pub use window::{
    close_actions_window, is_actions_window_open, notify_actions_window, open_actions_window,
    resize_actions_window,
};
// get_actions_window_handle available but not re-exported (use window:: directly if needed)

#[cfg(test)]
mod tests {
    // Import from submodules directly - these are only used in tests
    use super::builders::{get_global_actions, get_script_context_actions};
    use super::constants::{ACTION_ITEM_HEIGHT, POPUP_MAX_HEIGHT};
    use super::types::{Action, ActionCategory, ScriptInfo};
    use crate::protocol::ProtocolAction;

    #[test]
    fn test_actions_exceed_visible_space() {
        // Verify script context actions count
        // Global actions are now empty (Settings/Quit in main menu only)
        let script = ScriptInfo::new("test-script", "/path/to/test.ts");
        let script_actions = get_script_context_actions(&script);
        let global_actions = get_global_actions();
        let total_actions = script_actions.len() + global_actions.len();

        let max_visible = (POPUP_MAX_HEIGHT / ACTION_ITEM_HEIGHT) as usize;

        // Script context actions: run, edit, add_shortcut (or update+remove),
        // view_logs, reveal_in_finder, copy_path, copy_deeplink = 7 actions
        assert!(
            total_actions >= 7,
            "Should have at least 7 script context actions"
        );
        assert!(global_actions.is_empty(), "Global actions should be empty");

        // Log for visibility
        println!(
            "Total actions: {}, Max visible: {}",
            total_actions, max_visible
        );
    }

    #[test]
    fn test_protocol_action_to_action_conversion() {
        let protocol_action = ProtocolAction {
            name: "Copy".to_string(),
            description: Some("Copy to clipboard".to_string()),
            shortcut: Some("cmd+c".to_string()),
            value: Some("copy-value".to_string()),
            has_action: true,
            visible: None,
            close: None,
        };

        // Test that ProtocolAction fields are accessible for conversion
        // The actual conversion in dialog.rs copies these to Action struct
        assert_eq!(protocol_action.name, "Copy");
        assert_eq!(
            protocol_action.description,
            Some("Copy to clipboard".to_string())
        );
        assert_eq!(protocol_action.shortcut, Some("cmd+c".to_string()));
        assert_eq!(protocol_action.value, Some("copy-value".to_string()));
        assert!(protocol_action.has_action);

        // Create Action using builder pattern (used by get_*_actions)
        let action = Action::new(
            protocol_action.name.clone(),
            protocol_action.name.clone(),
            protocol_action.description.clone(),
            ActionCategory::ScriptContext,
        );
        assert_eq!(action.id, "Copy");
        assert_eq!(action.title, "Copy");
    }

    #[test]
    fn test_protocol_action_has_action_routing() {
        // Action with has_action=true should trigger ActionTriggered to SDK
        let action_with_handler = ProtocolAction {
            name: "Custom Action".to_string(),
            description: None,
            shortcut: None,
            value: Some("custom-value".to_string()),
            has_action: true,
            visible: None,
            close: None,
        };
        assert!(action_with_handler.has_action);

        // Action with has_action=false should submit value directly
        let action_without_handler = ProtocolAction {
            name: "Simple Action".to_string(),
            description: None,
            shortcut: None,
            value: Some("simple-value".to_string()),
            has_action: false,
            visible: None,
            close: None,
        };
        assert!(!action_without_handler.has_action);
    }
}

</file>

<file path="src/actions/builders.rs">
//! Action builders
//!
//! Factory functions for creating context-specific action lists.

use super::types::{Action, ActionCategory, ScriptInfo};
use crate::file_search::FileInfo;
use crate::prompts::PathInfo;

/// Get actions specific to a file search result
/// Actions: Open (default), Show in Finder, Quick Look, Open With..., Show Info
pub fn get_file_context_actions(file_info: &FileInfo) -> Vec<Action> {
    let mut actions = Vec::new();

    // Primary action - Open file
    if file_info.is_dir {
        actions.push(
            Action::new(
                "open_directory",
                format!("Open \"{}\"", file_info.name),
                Some("Open this folder".to_string()),
                ActionCategory::ScriptContext,
            )
            .with_shortcut("↵"),
        );
    } else {
        actions.push(
            Action::new(
                "open_file",
                format!("Open \"{}\"", file_info.name),
                Some("Open with default application".to_string()),
                ActionCategory::ScriptContext,
            )
            .with_shortcut("↵"),
        );
    }

    // Show in Finder (Cmd+Enter)
    actions.push(
        Action::new(
            "reveal_in_finder",
            "Show in Finder",
            Some("Reveal in Finder".to_string()),
            ActionCategory::ScriptContext,
        )
        .with_shortcut("⌘↵"),
    );

    // Quick Look (Cmd+Y) - macOS only
    #[cfg(target_os = "macos")]
    if !file_info.is_dir {
        actions.push(
            Action::new(
                "quick_look",
                "Quick Look",
                Some("Preview with Quick Look".to_string()),
                ActionCategory::ScriptContext,
            )
            .with_shortcut("⌘Y"),
        );
    }

    // Open With... (Cmd+O) - macOS only
    #[cfg(target_os = "macos")]
    actions.push(
        Action::new(
            "open_with",
            "Open With...",
            Some("Choose application to open with".to_string()),
            ActionCategory::ScriptContext,
        )
        .with_shortcut("⌘O"),
    );

    // Show Info in Finder (Cmd+I) - macOS only
    #[cfg(target_os = "macos")]
    actions.push(
        Action::new(
            "show_info",
            "Get Info",
            Some("Show file information in Finder".to_string()),
            ActionCategory::ScriptContext,
        )
        .with_shortcut("⌘I"),
    );

    // Copy Path
    actions.push(
        Action::new(
            "copy_path",
            "Copy Path",
            Some("Copy the full path to clipboard".to_string()),
            ActionCategory::ScriptContext,
        )
        .with_shortcut("⌘⇧C"),
    );

    // Copy Filename
    actions.push(
        Action::new(
            "copy_filename",
            "Copy Filename",
            Some("Copy just the filename to clipboard".to_string()),
            ActionCategory::ScriptContext,
        )
        .with_shortcut("⌘C"),
    );

    actions
}

/// Get actions specific to a file/folder path
pub fn get_path_context_actions(path_info: &PathInfo) -> Vec<Action> {
    let mut actions = vec![
        Action::new(
            "copy_path",
            "Copy Path",
            Some("Copy the full path to clipboard".to_string()),
            ActionCategory::ScriptContext,
        )
        .with_shortcut("⌘⇧C"),
        Action::new(
            "open_in_finder",
            "Open in Finder",
            Some("Reveal in Finder".to_string()),
            ActionCategory::ScriptContext,
        )
        .with_shortcut("⌘⇧F"),
        Action::new(
            "open_in_editor",
            "Open in Editor",
            Some("Open in $EDITOR".to_string()),
            ActionCategory::ScriptContext,
        )
        .with_shortcut("⌘E"),
        Action::new(
            "open_in_terminal",
            "Open in Terminal",
            Some("Open terminal at this location".to_string()),
            ActionCategory::ScriptContext,
        )
        .with_shortcut("⌘T"),
        Action::new(
            "copy_filename",
            "Copy Filename",
            Some("Copy just the filename".to_string()),
            ActionCategory::ScriptContext,
        ),
        Action::new(
            "move_to_trash",
            "Move to Trash",
            Some(format!(
                "Delete {}",
                if path_info.is_dir { "folder" } else { "file" }
            )),
            ActionCategory::ScriptContext,
        )
        .with_shortcut("⌘⌫"),
    ];

    // Add directory-specific action for navigating into
    if path_info.is_dir {
        actions.insert(
            0,
            Action::new(
                "open_directory",
                format!("Open \"{}\"", path_info.name),
                Some("Navigate into this directory".to_string()),
                ActionCategory::ScriptContext,
            )
            .with_shortcut("↵"),
        );
    } else {
        actions.insert(
            0,
            Action::new(
                "select_file",
                format!("Select \"{}\"", path_info.name),
                Some("Submit this file".to_string()),
                ActionCategory::ScriptContext,
            )
            .with_shortcut("↵"),
        );
    }

    actions
}

/// Convert a script name to a deeplink-safe format (lowercase, hyphenated)
fn to_deeplink_name(name: &str) -> String {
    name.to_lowercase()
        .chars()
        .map(|c| if c.is_alphanumeric() { c } else { '-' })
        .collect::<String>()
        .split('-')
        .filter(|s| !s.is_empty())
        .collect::<Vec<_>>()
        .join("-")
}

/// Get actions specific to the focused script
/// Actions are filtered based on whether this is a real script or a built-in command
pub fn get_script_context_actions(script: &ScriptInfo) -> Vec<Action> {
    let mut actions = Vec::new();

    // Primary action - always available for both scripts and built-ins
    // Uses the action_verb from ScriptInfo (e.g., "Run", "Launch", "Switch to")
    actions.push(
        Action::new(
            "run_script",
            format!("{} \"{}\"", script.action_verb, script.name),
            Some(format!("{} this item", script.action_verb)),
            ActionCategory::ScriptContext,
        )
        .with_shortcut("↵"),
    );

    // Dynamic shortcut actions based on whether a shortcut already exists
    // If NO shortcut: Show "Add Keyboard Shortcut"
    // If HAS shortcut: Show "Update Keyboard Shortcut" and "Remove Keyboard Shortcut"
    if script.shortcut.is_some() {
        // Has existing shortcut - show Update and Remove options
        actions.push(
            Action::new(
                "update_shortcut",
                "Update Keyboard Shortcut",
                Some("Change the keyboard shortcut".to_string()),
                ActionCategory::ScriptContext,
            )
            .with_shortcut("⌘⇧K"),
        );
        actions.push(
            Action::new(
                "remove_shortcut",
                "Remove Keyboard Shortcut",
                Some("Remove the current keyboard shortcut".to_string()),
                ActionCategory::ScriptContext,
            )
            .with_shortcut("⌘⌥K"),
        );
    } else {
        // No shortcut - show Add option
        actions.push(
            Action::new(
                "add_shortcut",
                "Add Keyboard Shortcut",
                Some("Set a keyboard shortcut".to_string()),
                ActionCategory::ScriptContext,
            )
            .with_shortcut("⌘⇧K"),
        );
    }

    // Script-only actions (not available for built-ins, apps, windows)
    if script.is_script {
        actions.push(
            Action::new(
                "edit_script",
                "Edit Script",
                Some("Open in $EDITOR".to_string()),
                ActionCategory::ScriptContext,
            )
            .with_shortcut("⌘E"),
        );

        actions.push(
            Action::new(
                "view_logs",
                "View Logs",
                Some("Show script execution logs".to_string()),
                ActionCategory::ScriptContext,
            )
            .with_shortcut("⌘L"),
        );

        actions.push(
            Action::new(
                "reveal_in_finder",
                "Reveal in Finder",
                Some("Show script file in Finder".to_string()),
                ActionCategory::ScriptContext,
            )
            .with_shortcut("⌘⇧F"),
        );

        actions.push(
            Action::new(
                "copy_path",
                "Copy Path",
                Some("Copy script path to clipboard".to_string()),
                ActionCategory::ScriptContext,
            )
            .with_shortcut("⌘⇧C"),
        );
    }

    // Copy deeplink - available for both scripts and built-ins
    let deeplink_name = to_deeplink_name(&script.name);
    actions.push(
        Action::new(
            "copy_deeplink",
            "Copy Deeplink",
            Some(format!(
                "Copy scriptkit://run/{} URL to clipboard",
                deeplink_name
            )),
            ActionCategory::ScriptContext,
        )
        .with_shortcut("⌘⇧D"),
    );

    actions
}

/// Predefined global actions
/// Note: Settings and Quit are available from the main menu, not shown in actions dialog
pub fn get_global_actions() -> Vec<Action> {
    vec![]
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_get_script_context_actions_no_shortcut() {
        // Script without shortcut should show "Add Keyboard Shortcut"
        let script = ScriptInfo::new("my-script", "/path/to/my-script.ts");
        let actions = get_script_context_actions(&script);

        assert!(!actions.is_empty());
        // Script-specific actions should be present
        assert!(actions.iter().any(|a| a.id == "edit_script"));
        assert!(actions.iter().any(|a| a.id == "view_logs"));
        assert!(actions.iter().any(|a| a.id == "reveal_in_finder"));
        assert!(actions.iter().any(|a| a.id == "copy_path"));
        assert!(actions.iter().any(|a| a.id == "run_script"));
        // Dynamic shortcut action - no shortcut means "Add"
        assert!(actions.iter().any(|a| a.id == "add_shortcut"));
        assert!(!actions.iter().any(|a| a.id == "update_shortcut"));
        assert!(!actions.iter().any(|a| a.id == "remove_shortcut"));
        assert!(actions.iter().any(|a| a.id == "copy_deeplink"));
    }

    #[test]
    fn test_get_script_context_actions_with_shortcut() {
        // Script with shortcut should show "Update" and "Remove" options
        let script = ScriptInfo::with_shortcut(
            "my-script",
            "/path/to/my-script.ts",
            Some("cmd+shift+m".to_string()),
        );
        let actions = get_script_context_actions(&script);

        // Dynamic shortcut actions - has shortcut means "Update" and "Remove"
        assert!(!actions.iter().any(|a| a.id == "add_shortcut"));
        assert!(actions.iter().any(|a| a.id == "update_shortcut"));
        assert!(actions.iter().any(|a| a.id == "remove_shortcut"));
    }

    #[test]
    fn test_get_builtin_context_actions() {
        // Built-in commands should have limited actions
        let builtin = ScriptInfo::builtin("Clipboard History");
        let actions = get_script_context_actions(&builtin);

        // Should have run, copy_deeplink, and add_shortcut (no shortcut by default)
        assert!(actions.iter().any(|a| a.id == "run_script"));
        assert!(actions.iter().any(|a| a.id == "copy_deeplink"));
        assert!(actions.iter().any(|a| a.id == "add_shortcut"));

        // Should NOT have script-only actions
        assert!(!actions.iter().any(|a| a.id == "edit_script"));
        assert!(!actions.iter().any(|a| a.id == "view_logs"));
        assert!(!actions.iter().any(|a| a.id == "reveal_in_finder"));
        assert!(!actions.iter().any(|a| a.id == "copy_path"));
    }

    #[test]
    fn test_to_deeplink_name() {
        // Test the deeplink name conversion
        assert_eq!(to_deeplink_name("My Script"), "my-script");
        assert_eq!(to_deeplink_name("Clipboard History"), "clipboard-history");
        assert_eq!(to_deeplink_name("hello_world"), "hello-world");
        assert_eq!(
            to_deeplink_name("Test  Multiple   Spaces"),
            "test-multiple-spaces"
        );
        assert_eq!(to_deeplink_name("special!@#chars"), "special-chars");
    }

    #[test]
    fn test_get_global_actions() {
        let actions = get_global_actions();
        // Global actions are now empty - Settings/Quit available from main menu
        assert!(actions.is_empty());
    }

    #[test]
    fn test_built_in_actions_have_no_has_action() {
        // All built-in actions should have has_action=false
        let script = ScriptInfo::new("test-script", "/path/to/test.ts");
        let script_actions = get_script_context_actions(&script);
        let global_actions = get_global_actions();

        for action in script_actions.iter() {
            assert!(
                !action.has_action,
                "Built-in action '{}' should have has_action=false",
                action.id
            );
        }

        for action in global_actions.iter() {
            assert!(
                !action.has_action,
                "Built-in action '{}' should have has_action=false",
                action.id
            );
        }
    }

    #[test]
    fn test_copy_deeplink_description_format() {
        // Verify the deeplink description shows the correct URL format
        let script = ScriptInfo::new("My Cool Script", "/path/to/script.ts");
        let actions = get_script_context_actions(&script);

        let deeplink_action = actions.iter().find(|a| a.id == "copy_deeplink").unwrap();
        assert!(deeplink_action
            .description
            .as_ref()
            .unwrap()
            .contains("scriptkit://run/my-cool-script"));
    }

    #[test]
    fn test_get_file_context_actions_file() {
        // Test file actions for a regular file
        let file_info = FileInfo {
            path: "/Users/test/document.pdf".to_string(),
            name: "document.pdf".to_string(),
            file_type: crate::file_search::FileType::Document,
            is_dir: false,
        };
        let actions = get_file_context_actions(&file_info);

        // Should have open_file as primary action
        assert!(actions.iter().any(|a| a.id == "open_file"));
        assert!(actions.iter().any(|a| a.id == "reveal_in_finder"));
        assert!(actions.iter().any(|a| a.id == "copy_path"));
        assert!(actions.iter().any(|a| a.id == "copy_filename"));

        // Should NOT have open_directory (not a directory)
        assert!(!actions.iter().any(|a| a.id == "open_directory"));

        // On macOS, should have Quick Look, Open With, Get Info
        #[cfg(target_os = "macos")]
        {
            assert!(actions.iter().any(|a| a.id == "quick_look"));
            assert!(actions.iter().any(|a| a.id == "open_with"));
            assert!(actions.iter().any(|a| a.id == "show_info"));
        }
    }

    #[test]
    fn test_get_file_context_actions_directory() {
        // Test file actions for a directory
        let file_info = FileInfo {
            path: "/Users/test/Documents".to_string(),
            name: "Documents".to_string(),
            file_type: crate::file_search::FileType::Directory,
            is_dir: true,
        };
        let actions = get_file_context_actions(&file_info);

        // Should have open_directory as primary action
        assert!(actions.iter().any(|a| a.id == "open_directory"));
        assert!(actions.iter().any(|a| a.id == "reveal_in_finder"));
        assert!(actions.iter().any(|a| a.id == "copy_path"));
        assert!(actions.iter().any(|a| a.id == "copy_filename"));

        // Should NOT have open_file (it's a directory)
        assert!(!actions.iter().any(|a| a.id == "open_file"));

        // Directory should NOT have quick_look (only files)
        #[cfg(target_os = "macos")]
        {
            assert!(!actions.iter().any(|a| a.id == "quick_look"));
            // But should have Open With and Get Info
            assert!(actions.iter().any(|a| a.id == "open_with"));
            assert!(actions.iter().any(|a| a.id == "show_info"));
        }
    }

    #[test]
    fn test_file_context_actions_shortcuts() {
        // Verify the keyboard shortcuts are correct
        let file_info = FileInfo {
            path: "/test/file.txt".to_string(),
            name: "file.txt".to_string(),
            file_type: crate::file_search::FileType::File,
            is_dir: false,
        };
        let actions = get_file_context_actions(&file_info);

        // Check specific shortcuts
        let open_action = actions.iter().find(|a| a.id == "open_file").unwrap();
        assert_eq!(open_action.shortcut.as_ref().unwrap(), "↵");

        let reveal_action = actions.iter().find(|a| a.id == "reveal_in_finder").unwrap();
        assert_eq!(reveal_action.shortcut.as_ref().unwrap(), "⌘↵");

        #[cfg(target_os = "macos")]
        {
            let quick_look_action = actions.iter().find(|a| a.id == "quick_look").unwrap();
            assert_eq!(quick_look_action.shortcut.as_ref().unwrap(), "⌘Y");

            let show_info_action = actions.iter().find(|a| a.id == "show_info").unwrap();
            assert_eq!(show_info_action.shortcut.as_ref().unwrap(), "⌘I");
        }
    }
}

</file>

<file path="src/actions/window.rs">
//! Actions Window - Separate vibrancy window for actions panel
//!
//! This creates a floating popup window with its own vibrancy blur effect,
//! similar to Raycast's actions panel. The window is:
//! - Non-draggable (fixed position relative to main window)
//! - Positioned below the header, at the right edge of main window
//! - Auto-closes when app loses focus
//! - Shares the ActionsDialog entity with the main app for keyboard routing

use crate::platform;
use crate::theme;
use crate::window_resize::layout::FOOTER_HEIGHT;
use gpui::{
    div, prelude::*, px, App, Bounds, Context, DisplayId, Entity, FocusHandle, Focusable, Pixels,
    Point, Render, Size, Window, WindowBounds, WindowHandle, WindowKind, WindowOptions,
};
use gpui_component::Root;
use std::sync::{Mutex, OnceLock};

use super::constants::{ACTION_ITEM_HEIGHT, HEADER_HEIGHT, POPUP_MAX_HEIGHT, SEARCH_INPUT_HEIGHT};
use super::dialog::ActionsDialog;

/// Global singleton for the actions window handle
static ACTIONS_WINDOW: OnceLock<Mutex<Option<WindowHandle<Root>>>> = OnceLock::new();

/// Actions window width (height is calculated dynamically based on content)
const ACTIONS_WINDOW_WIDTH: f32 = 320.0;
/// Horizontal margin from main window right edge
const ACTIONS_MARGIN_X: f32 = 8.0;
/// Vertical margin from header
const ACTIONS_MARGIN_Y: f32 = 8.0;

/// ActionsWindow wrapper that renders the shared ActionsDialog entity
pub struct ActionsWindow {
    /// The shared dialog entity (created by main app, rendered here)
    pub dialog: Entity<ActionsDialog>,
    /// Focus handle for this window (not actively used - main window keeps focus)
    pub focus_handle: FocusHandle,
}

impl ActionsWindow {
    pub fn new(dialog: Entity<ActionsDialog>, cx: &mut Context<Self>) -> Self {
        let focus_handle = cx.focus_handle();
        Self {
            dialog,
            focus_handle,
        }
    }
}

impl Focusable for ActionsWindow {
    fn focus_handle(&self, _cx: &App) -> FocusHandle {
        self.focus_handle.clone()
    }
}

impl Render for ActionsWindow {
    fn render(&mut self, _window: &mut Window, _cx: &mut Context<Self>) -> impl IntoElement {
        // Render the shared dialog entity - it handles its own sizing
        // Don't use size_full() - the dialog calculates its own dynamic height
        // This prevents unused window space from showing as a dark area
        div().child(self.dialog.clone())
    }
}

/// Open the actions window as a separate floating window with vibrancy
///
/// The window is positioned at the top-right of the main window, below the header.
/// It does NOT take keyboard focus - the main window keeps focus and routes
/// keyboard events to the shared ActionsDialog entity.
///
/// # Arguments
/// * `cx` - The application context
/// * `main_window_bounds` - The bounds of the main window in SCREEN-RELATIVE coordinates
///   (as returned by GPUI's window.bounds() - top-left origin relative to the window's screen)
/// * `display_id` - The display where the main window is located (actions window will be on same display)
/// * `dialog_entity` - The shared ActionsDialog entity (created by main app)
///
/// # Returns
/// The window handle on success
pub fn open_actions_window(
    cx: &mut App,
    main_window_bounds: Bounds<Pixels>,
    display_id: Option<DisplayId>,
    dialog_entity: Entity<ActionsDialog>,
) -> anyhow::Result<WindowHandle<Root>> {
    // Close any existing actions window first
    close_actions_window(cx);

    // Load theme for vibrancy settings
    let theme = theme::load_theme();
    let window_background = if theme.is_vibrancy_enabled() {
        gpui::WindowBackgroundAppearance::Blurred
    } else {
        gpui::WindowBackgroundAppearance::Opaque
    };

    // Calculate dynamic window height based on number of actions
    // This ensures the window fits the content without empty dark space
    let dialog = dialog_entity.read(cx);
    let num_actions = dialog.filtered_actions.len();
    let hide_search = dialog.hide_search;
    let has_header = dialog.context_title.is_some();

    let search_box_height = if hide_search {
        0.0
    } else {
        SEARCH_INPUT_HEIGHT
    };
    let header_height = if has_header { HEADER_HEIGHT } else { 0.0 };
    let items_height = (num_actions as f32 * ACTION_ITEM_HEIGHT)
        .min(POPUP_MAX_HEIGHT - search_box_height - header_height);
    let border_height = 2.0; // top + bottom border
    let dynamic_height = items_height + search_box_height + header_height + border_height;

    // Calculate window position:
    // - X: Right edge of main window, minus actions width, minus margin
    // - Y: Bottom-aligned with main window (above footer), minus margin
    //
    // CRITICAL: main_window_bounds must be in SCREEN-RELATIVE coordinates from GPUI's
    // window.bounds(). These are top-left origin, relative to the window's current screen.
    // When we pass display_id to WindowOptions, GPUI will position this window on the
    // same screen as the main window, using these screen-relative coordinates.
    let window_width = px(ACTIONS_WINDOW_WIDTH);
    let window_height = px(dynamic_height);

    let window_x = main_window_bounds.origin.x + main_window_bounds.size.width
        - window_width
        - px(ACTIONS_MARGIN_X);
    // Position popup above the footer (footer is 40px)
    let window_y = main_window_bounds.origin.y + main_window_bounds.size.height
        - window_height
        - px(FOOTER_HEIGHT)
        - px(ACTIONS_MARGIN_Y);

    let bounds = Bounds {
        origin: Point {
            x: window_x,
            y: window_y,
        },
        size: Size {
            width: window_width,
            height: window_height,
        },
    };

    crate::logging::log(
        "ACTIONS",
        &format!(
            "Opening actions window at ({:?}, {:?}), size {:?}x{:?}, display_id={:?}",
            window_x, window_y, window_width, window_height, display_id
        ),
    );

    let window_options = WindowOptions {
        window_bounds: Some(WindowBounds::Windowed(bounds)),
        titlebar: None, // No titlebar = no drag affordance
        window_background,
        focus: false, // CRITICAL: Don't take focus - main window keeps it
        show: true,
        kind: WindowKind::PopUp, // Floating popup window
        display_id,              // CRITICAL: Position on same display as main window
        ..Default::default()
    };

    // Create the window with the shared dialog entity
    let handle = cx.open_window(window_options, |window, cx| {
        let actions_window = cx.new(|cx| ActionsWindow::new(dialog_entity, cx));
        // Wrap in Root for gpui-component theming and vibrancy
        cx.new(|cx| Root::new(actions_window, window, cx))
    })?;

    // Configure the window as non-movable on macOS
    #[cfg(target_os = "macos")]
    {
        use cocoa::appkit::NSApp;
        use cocoa::base::nil;
        use objc::{msg_send, sel, sel_impl};

        // Get the NSWindow from the app's windows array
        // The popup window should be the most recently created one
        unsafe {
            let app: cocoa::base::id = NSApp();
            let windows: cocoa::base::id = msg_send![app, windows];
            let count: usize = msg_send![windows, count];
            if count > 0 {
                // Get the last window (most recently created)
                let ns_window: cocoa::base::id = msg_send![windows, lastObject];
                if ns_window != nil {
                    platform::configure_actions_popup_window(ns_window);
                }
            }
        }
    }

    // Store the handle globally
    let window_storage = ACTIONS_WINDOW.get_or_init(|| Mutex::new(None));
    if let Ok(mut guard) = window_storage.lock() {
        *guard = Some(handle);
    }

    crate::logging::log("ACTIONS", "Actions popup window opened with vibrancy");

    Ok(handle)
}

/// Close the actions window if it's open
pub fn close_actions_window(cx: &mut App) {
    if let Some(window_storage) = ACTIONS_WINDOW.get() {
        if let Ok(mut guard) = window_storage.lock() {
            if let Some(handle) = guard.take() {
                crate::logging::log("ACTIONS", "Closing actions popup window");
                // Close the window
                let _ = handle.update(cx, |_root, window, _cx| {
                    window.remove_window();
                });
            }
        }
    }
}

/// Check if the actions window is currently open
pub fn is_actions_window_open() -> bool {
    if let Some(window_storage) = ACTIONS_WINDOW.get() {
        if let Ok(guard) = window_storage.lock() {
            return guard.is_some();
        }
    }
    false
}

/// Get the actions window handle if it exists
pub fn get_actions_window_handle() -> Option<WindowHandle<Root>> {
    if let Some(window_storage) = ACTIONS_WINDOW.get() {
        if let Ok(guard) = window_storage.lock() {
            return *guard;
        }
    }
    None
}

/// Notify the actions window to re-render (call after updating dialog entity)
pub fn notify_actions_window(cx: &mut App) {
    if let Some(handle) = get_actions_window_handle() {
        let _ = handle.update(cx, |_root, _window, cx| {
            cx.notify();
        });
    }
}

/// Resize the actions window to fit the current number of filtered actions
/// Call this after filtering changes the action count
///
/// The window is "pinned to bottom" - the search input stays in place and
/// the window shrinks/grows from the top.
pub fn resize_actions_window(cx: &mut App, dialog_entity: &Entity<ActionsDialog>) {
    if let Some(handle) = get_actions_window_handle() {
        // Read dialog state to calculate new height
        let dialog = dialog_entity.read(cx);
        let num_actions = dialog.filtered_actions.len();
        let hide_search = dialog.hide_search;
        let has_header = dialog.context_title.is_some();

        // Calculate new height (same logic as open_actions_window)
        let search_box_height = if hide_search {
            0.0
        } else {
            SEARCH_INPUT_HEIGHT
        };
        let header_height = if has_header { HEADER_HEIGHT } else { 0.0 };
        let items_height = (num_actions as f32 * ACTION_ITEM_HEIGHT)
            .min(POPUP_MAX_HEIGHT - search_box_height - header_height);
        let border_height = 2.0; // top + bottom border
        let new_height_f32 = items_height + search_box_height + header_height + border_height;

        let _ = handle.update(cx, |_root, window, cx| {
            let current_bounds = window.bounds();
            let current_height_f32: f32 = current_bounds.size.height.into();
            let current_width_f32: f32 = current_bounds.size.width.into();

            // Skip if height hasn't changed
            if (current_height_f32 - new_height_f32).abs() < 1.0 {
                return;
            }

            // "Pin to bottom": keep the bottom edge fixed
            // In macOS screen coords (bottom-left origin), the bottom of the window
            // is at frame.origin.y. When we change height, we keep origin.y the same
            // and only change height - this naturally keeps the bottom fixed.
            #[cfg(target_os = "macos")]
            {
                use cocoa::appkit::NSScreen;
                use cocoa::base::nil;
                use cocoa::foundation::{NSPoint, NSRect, NSSize};
                use objc::{msg_send, sel, sel_impl};

                unsafe {
                    let ns_app: cocoa::base::id = cocoa::appkit::NSApp();
                    let windows: cocoa::base::id = msg_send![ns_app, windows];
                    let count: usize = msg_send![windows, count];

                    // Find our actions window by matching current dimensions
                    for i in 0..count {
                        let ns_window: cocoa::base::id = msg_send![windows, objectAtIndex: i];
                        if ns_window == nil {
                            continue;
                        }

                        let frame: NSRect = msg_send![ns_window, frame];

                        // Match by width (actions window has unique width)
                        if (frame.size.width - current_width_f32 as f64).abs() < 2.0
                            && (frame.size.height - current_height_f32 as f64).abs() < 2.0
                        {
                            // Get the screen this window is on (NOT primary screen!)
                            let window_screen: cocoa::base::id = msg_send![ns_window, screen];
                            if window_screen == nil {
                                // Fallback to primary if no screen
                                let screens: cocoa::base::id = NSScreen::screens(nil);
                                let _primary: cocoa::base::id =
                                    msg_send![screens, objectAtIndex: 0u64];
                            }

                            // In macOS coords (bottom-left origin):
                            // - frame.origin.y is the BOTTOM of the window
                            // - To keep bottom fixed, we keep origin.y the same
                            // - Only change the height
                            let new_frame = NSRect::new(
                                NSPoint::new(frame.origin.x, frame.origin.y),
                                NSSize::new(frame.size.width, new_height_f32 as f64),
                            );

                            let _: () =
                                msg_send![ns_window, setFrame:new_frame display:true animate:false];

                            crate::logging::log(
                                "ACTIONS",
                                &format!(
                                    "Resized actions window (bottom pinned): height {:.0} -> {:.0}",
                                    current_height_f32, new_height_f32
                                ),
                            );
                            break;
                        }
                    }
                }
            }

            // Also tell GPUI about the new size
            window.resize(Size {
                width: current_bounds.size.width,
                height: px(new_height_f32),
            });
            cx.notify();
        });

        crate::logging::log(
            "ACTIONS",
            &format!(
                "Resized actions window: {} items, height={:.0}",
                num_actions, new_height_f32
            ),
        );
    }
}

</file>

<file path="src/actions/dialog.rs">
//! Actions Dialog
//!
//! The main ActionsDialog struct and its implementation, providing a searchable
//! action menu as a compact overlay popup.

#![allow(dead_code)]

use crate::components::scrollbar::{Scrollbar, ScrollbarColors};
use crate::designs::{get_tokens, DesignColors, DesignVariant};
use crate::logging;
use crate::protocol::ProtocolAction;
use crate::theme;
use gpui::{
    div, prelude::*, px, rgb, rgba, uniform_list, App, BoxShadow, Context, FocusHandle, Focusable,
    Render, ScrollStrategy, SharedString, UniformListScrollHandle, Window,
};
use std::sync::Arc;

use super::builders::{
    get_file_context_actions, get_global_actions, get_path_context_actions,
    get_script_context_actions,
};
use super::constants::{
    ACTION_ITEM_HEIGHT, ACTION_ROW_INSET, HEADER_HEIGHT, KEYCAP_HEIGHT, KEYCAP_MIN_WIDTH,
    POPUP_MAX_HEIGHT, POPUP_WIDTH, SEARCH_INPUT_HEIGHT, SELECTION_RADIUS,
};
use crate::file_search::FileInfo;

// Keep ACCENT_BAR_WIDTH for backwards compatibility during transition
#[allow(unused_imports)]
use super::constants::ACCENT_BAR_WIDTH;
use super::types::{Action, ActionCallback, ActionCategory, ScriptInfo};
use crate::prompts::PathInfo;

/// Helper function to combine a hex color with an alpha value
/// Delegates to DesignColors::hex_with_alpha for DRY
#[inline]
fn hex_with_alpha(hex: u32, alpha: u8) -> u32 {
    DesignColors::hex_with_alpha(hex, alpha)
}

/// ActionsDialog - Compact overlay popup for quick actions
/// Implements Raycast-style design with individual keycap shortcuts
pub struct ActionsDialog {
    pub actions: Vec<Action>,
    pub filtered_actions: Vec<usize>, // Indices into actions
    pub selected_index: usize,        // Index within filtered_actions
    pub search_text: String,
    pub focus_handle: FocusHandle,
    pub on_select: ActionCallback,
    /// Currently focused script for context-aware actions
    pub focused_script: Option<ScriptInfo>,
    /// Scroll handle for uniform_list virtualization
    pub scroll_handle: UniformListScrollHandle,
    /// Theme for consistent color styling
    pub theme: Arc<theme::Theme>,
    /// Design variant for styling (defaults to Default for theme-based styling)
    pub design_variant: DesignVariant,
    /// Cursor visibility for blinking (controlled externally)
    pub cursor_visible: bool,
    /// When true, hide the search input (used when rendered inline in main.rs header)
    pub hide_search: bool,
    /// SDK-provided actions (when present, replaces built-in actions)
    pub sdk_actions: Option<Vec<ProtocolAction>>,
    /// Context title shown in the header (e.g., "Activity Monitor", script name)
    pub context_title: Option<String>,
}

impl ActionsDialog {
    pub fn new(
        focus_handle: FocusHandle,
        on_select: ActionCallback,
        theme: Arc<theme::Theme>,
    ) -> Self {
        Self::with_script_and_design(focus_handle, on_select, None, theme, DesignVariant::Default)
    }

    pub fn with_script(
        focus_handle: FocusHandle,
        on_select: ActionCallback,
        focused_script: Option<ScriptInfo>,
        theme: Arc<theme::Theme>,
    ) -> Self {
        Self::with_script_and_design(
            focus_handle,
            on_select,
            focused_script,
            theme,
            DesignVariant::Default,
        )
    }

    pub fn with_design(
        focus_handle: FocusHandle,
        on_select: ActionCallback,
        theme: Arc<theme::Theme>,
        design_variant: DesignVariant,
    ) -> Self {
        Self::with_script_and_design(focus_handle, on_select, None, theme, design_variant)
    }

    /// Create ActionsDialog for a path (file/folder) with path-specific actions
    pub fn with_path(
        focus_handle: FocusHandle,
        on_select: ActionCallback,
        path_info: &PathInfo,
        theme: Arc<theme::Theme>,
    ) -> Self {
        let actions = get_path_context_actions(path_info);
        let filtered_actions: Vec<usize> = (0..actions.len()).collect();

        logging::log(
            "ACTIONS",
            &format!(
                "ActionsDialog created for path: {} (is_dir={}) with {} actions",
                path_info.path,
                path_info.is_dir,
                actions.len()
            ),
        );

        ActionsDialog {
            actions,
            filtered_actions,
            selected_index: 0,
            search_text: String::new(),
            focus_handle,
            on_select,
            focused_script: None,
            scroll_handle: UniformListScrollHandle::new(),
            theme,
            design_variant: DesignVariant::Default,
            cursor_visible: true,
            hide_search: false,
            sdk_actions: None,
            context_title: Some(path_info.path.clone()),
        }
    }

    /// Create ActionsDialog for a file search result with file-specific actions
    /// Actions: Open, Show in Finder, Quick Look, Open With..., Show Info, Copy Path
    pub fn with_file(
        focus_handle: FocusHandle,
        on_select: ActionCallback,
        file_info: &FileInfo,
        theme: Arc<theme::Theme>,
    ) -> Self {
        let actions = get_file_context_actions(file_info);
        let filtered_actions: Vec<usize> = (0..actions.len()).collect();

        logging::log(
            "ACTIONS",
            &format!(
                "ActionsDialog created for file: {} (is_dir={}) with {} actions",
                file_info.path,
                file_info.is_dir,
                actions.len()
            ),
        );

        ActionsDialog {
            actions,
            filtered_actions,
            selected_index: 0,
            search_text: String::new(),
            focus_handle,
            on_select,
            focused_script: None,
            scroll_handle: UniformListScrollHandle::new(),
            theme,
            design_variant: DesignVariant::Default,
            cursor_visible: true,
            hide_search: false,
            sdk_actions: None,
            context_title: Some(file_info.name.clone()),
        }
    }

    pub fn with_script_and_design(
        focus_handle: FocusHandle,
        on_select: ActionCallback,
        focused_script: Option<ScriptInfo>,
        theme: Arc<theme::Theme>,
        design_variant: DesignVariant,
    ) -> Self {
        let actions = Self::build_actions(&focused_script);
        let filtered_actions: Vec<usize> = (0..actions.len()).collect();

        logging::log(
            "ACTIONS",
            &format!(
                "ActionsDialog created with {} actions, script: {:?}, design: {:?}",
                actions.len(),
                focused_script.as_ref().map(|s| &s.name),
                design_variant
            ),
        );

        // Log theme color configuration for debugging
        logging::log("ACTIONS_THEME", &format!(
            "Theme colors applied: bg_main=#{:06x}, bg_search=#{:06x}, text_primary=#{:06x}, accent_selected=#{:06x}",
            theme.colors.background.main,
            theme.colors.background.search_box,
            theme.colors.text.primary,
            theme.colors.accent.selected
        ));

        // Extract context title from focused script if available
        let context_title = focused_script.as_ref().map(|s| s.name.clone());

        ActionsDialog {
            actions,
            filtered_actions,
            selected_index: 0,
            search_text: String::new(),
            focus_handle,
            on_select,
            focused_script,
            scroll_handle: UniformListScrollHandle::new(),
            theme,
            design_variant,
            cursor_visible: true,
            hide_search: false,
            sdk_actions: None,
            context_title,
        }
    }

    /// Update cursor visibility (called from parent's blink timer)
    pub fn set_cursor_visible(&mut self, visible: bool) {
        self.cursor_visible = visible;
    }

    /// Hide the search input (for inline mode where header has search)
    pub fn set_hide_search(&mut self, hide: bool) {
        self.hide_search = hide;
    }

    /// Set the context title shown in the header
    pub fn set_context_title(&mut self, title: Option<String>) {
        self.context_title = title;
    }

    /// Parse a shortcut string into individual keycap characters
    /// e.g., "⌘↵" → vec!["⌘", "↵"], "⌘I" → vec!["⌘", "I"]
    fn parse_shortcut_keycaps(shortcut: &str) -> Vec<String> {
        let mut keycaps = Vec::new();

        for ch in shortcut.chars() {
            // Handle modifier symbols (single character)
            match ch {
                '⌘' | '⌃' | '⌥' | '⇧' | '↵' | '⎋' | '⇥' | '⌫' | '␣' | '↑' | '↓' | '←' | '→' =>
                {
                    keycaps.push(ch.to_string());
                }
                // Regular characters (letters, numbers)
                _ => {
                    keycaps.push(ch.to_uppercase().to_string());
                }
            }
        }

        keycaps
    }

    /// Set actions from SDK (replaces built-in actions)
    ///
    /// Converts `ProtocolAction` items to internal `Action` format and updates
    /// the actions list. Filters out actions with `visible: false`.
    /// The `has_action` field on each action determines routing:
    /// - `has_action=true`: Send ActionTriggered back to SDK
    /// - `has_action=false`: Submit value directly
    pub fn set_sdk_actions(&mut self, actions: Vec<ProtocolAction>) {
        let total_count = actions.len();
        let visible_actions: Vec<&ProtocolAction> =
            actions.iter().filter(|a| a.is_visible()).collect();
        let visible_count = visible_actions.len();

        let converted: Vec<Action> = visible_actions
            .iter()
            .map(|pa| Action {
                id: pa.name.clone(),
                title: pa.name.clone(),
                description: pa.description.clone(),
                category: ActionCategory::ScriptContext,
                shortcut: pa.shortcut.as_ref().map(|s| Self::format_shortcut_hint(s)),
                has_action: pa.has_action,
                value: pa.value.clone(),
            })
            .collect();

        logging::log(
            "ACTIONS",
            &format!(
                "SDK actions set: {} visible of {} total",
                visible_count, total_count
            ),
        );

        self.actions = converted;
        self.filtered_actions = (0..self.actions.len()).collect();
        self.selected_index = 0;
        self.search_text.clear();
        self.sdk_actions = Some(actions);
    }

    /// Format a keyboard shortcut for display (e.g., "cmd+c" → "⌘C")
    fn format_shortcut_hint(shortcut: &str) -> String {
        let mut result = String::new();
        let parts: Vec<&str> = shortcut.split('+').collect();

        for (i, part) in parts.iter().enumerate() {
            let part_lower = part.trim().to_lowercase();
            let formatted = match part_lower.as_str() {
                // Modifier keys → symbols
                "cmd" | "command" | "meta" | "super" => "⌘",
                "ctrl" | "control" => "⌃",
                "alt" | "opt" | "option" => "⌥",
                "shift" => "⇧",
                // Special keys
                "enter" | "return" => "↵",
                "escape" | "esc" => "⎋",
                "tab" => "⇥",
                "backspace" | "delete" => "⌫",
                "space" => "␣",
                "up" | "arrowup" => "↑",
                "down" | "arrowdown" => "↓",
                "left" | "arrowleft" => "←",
                "right" | "arrowright" => "→",
                // Regular letters/numbers → uppercase
                _ => {
                    // Check if it's the last part (the actual key)
                    if i == parts.len() - 1 {
                        // Uppercase single characters, keep others as-is
                        result.push_str(&part.trim().to_uppercase());
                        continue;
                    }
                    part.trim()
                }
            };
            result.push_str(formatted);
        }

        result
    }

    /// Clear SDK actions and restore built-in actions
    pub fn clear_sdk_actions(&mut self) {
        if self.sdk_actions.is_some() {
            logging::log(
                "ACTIONS",
                "Clearing SDK actions, restoring built-in actions",
            );
            self.sdk_actions = None;
            self.actions = Self::build_actions(&self.focused_script);
            self.filtered_actions = (0..self.actions.len()).collect();
            self.selected_index = 0;
            self.search_text.clear();
        }
    }

    /// Check if SDK actions are currently active
    pub fn has_sdk_actions(&self) -> bool {
        self.sdk_actions.is_some()
    }

    /// Get the currently selected action (for external handling)
    pub fn get_selected_action(&self) -> Option<&Action> {
        self.filtered_actions
            .get(self.selected_index)
            .and_then(|&idx| self.actions.get(idx))
    }

    /// Build the complete actions list based on focused script
    fn build_actions(focused_script: &Option<ScriptInfo>) -> Vec<Action> {
        let mut actions = Vec::new();

        // Add script-specific actions first if a script is focused
        if let Some(script) = focused_script {
            actions.extend(get_script_context_actions(script));
        }

        // Add global actions
        actions.extend(get_global_actions());

        actions
    }

    /// Update the focused script and rebuild actions
    pub fn set_focused_script(&mut self, script: Option<ScriptInfo>) {
        self.focused_script = script;
        self.actions = Self::build_actions(&self.focused_script);
        self.refilter();
    }

    /// Update the theme when hot-reloading
    /// Call this from the parent when theme changes to ensure dialog reflects new colors
    pub fn update_theme(&mut self, theme: Arc<theme::Theme>) {
        logging::log("ACTIONS_THEME", "Theme updated in ActionsDialog");
        self.theme = theme;
    }

    /// Refilter actions based on current search_text using ranked fuzzy matching.
    ///
    /// Scoring system:
    /// - Prefix match on title: +100 (strongest signal)
    /// - Fuzzy match on title: +50 + character bonus
    /// - Contains match on description: +25
    /// - Results are sorted by score (descending)
    fn refilter(&mut self) {
        // Preserve selection if possible (track which action was selected)
        let previously_selected = self
            .filtered_actions
            .get(self.selected_index)
            .and_then(|&idx| self.actions.get(idx).map(|a| a.id.clone()));

        if self.search_text.is_empty() {
            self.filtered_actions = (0..self.actions.len()).collect();
        } else {
            let search_lower = self.search_text.to_lowercase();

            // Score each action and collect (index, score) pairs
            let mut scored: Vec<(usize, i32)> = self
                .actions
                .iter()
                .enumerate()
                .filter_map(|(idx, action)| {
                    let score = Self::score_action(action, &search_lower);
                    if score > 0 {
                        Some((idx, score))
                    } else {
                        None
                    }
                })
                .collect();

            // Sort by score descending
            scored.sort_by(|a, b| b.1.cmp(&a.1));

            // Extract just the indices
            self.filtered_actions = scored.into_iter().map(|(idx, _)| idx).collect();
        }

        // Preserve selection if the same action is still in results
        if let Some(prev_id) = previously_selected {
            if let Some(new_idx) = self.filtered_actions.iter().position(|&idx| {
                self.actions
                    .get(idx)
                    .map(|a| a.id == prev_id)
                    .unwrap_or(false)
            }) {
                self.selected_index = new_idx;
            } else {
                self.selected_index = 0;
            }
        } else {
            self.selected_index = 0;
        }

        // Only scroll if we have results
        if !self.filtered_actions.is_empty() {
            self.scroll_handle
                .scroll_to_item(self.selected_index, ScrollStrategy::Nearest);
        }

        logging::log_debug(
            "ACTIONS_SCROLL",
            &format!(
                "Filter changed: {} results, selected={}",
                self.filtered_actions.len(),
                self.selected_index
            ),
        );
    }

    /// Score an action against a search query.
    /// Returns 0 if no match, higher scores for better matches.
    fn score_action(action: &Action, search_lower: &str) -> i32 {
        let title_lower = action.title.to_lowercase();
        let mut score = 0;

        // Prefix match on title (strongest)
        if title_lower.starts_with(search_lower) {
            score += 100;
        }
        // Contains match on title
        else if title_lower.contains(search_lower) {
            score += 50;
        }
        // Fuzzy match on title (character-by-character subsequence)
        else if Self::fuzzy_match(&title_lower, search_lower) {
            score += 25;
        }

        // Description match (bonus)
        if let Some(ref desc) = action.description {
            let desc_lower = desc.to_lowercase();
            if desc_lower.contains(search_lower) {
                score += 15;
            }
        }

        // Shortcut match (bonus)
        if let Some(ref shortcut) = action.shortcut {
            if shortcut.to_lowercase().contains(search_lower) {
                score += 10;
            }
        }

        score
    }

    /// Simple fuzzy matching: check if all characters in needle appear in haystack in order.
    fn fuzzy_match(haystack: &str, needle: &str) -> bool {
        let mut haystack_chars = haystack.chars();
        for needle_char in needle.chars() {
            loop {
                match haystack_chars.next() {
                    Some(h) if h == needle_char => break,
                    Some(_) => continue,
                    None => return false,
                }
            }
        }
        true
    }

    /// Handle character input
    pub fn handle_char(&mut self, ch: char, cx: &mut Context<Self>) {
        self.search_text.push(ch);
        self.refilter();
        cx.notify();
    }

    /// Handle backspace
    pub fn handle_backspace(&mut self, cx: &mut Context<Self>) {
        if !self.search_text.is_empty() {
            self.search_text.pop();
            self.refilter();
            cx.notify();
        }
    }

    /// Move selection up
    pub fn move_up(&mut self, cx: &mut Context<Self>) {
        if self.selected_index > 0 {
            self.selected_index -= 1;
            self.scroll_handle
                .scroll_to_item(self.selected_index, ScrollStrategy::Nearest);
            logging::log_debug(
                "ACTIONS_SCROLL",
                &format!("Up: selected_index={}", self.selected_index),
            );
            cx.notify();
        }
    }

    /// Move selection down
    pub fn move_down(&mut self, cx: &mut Context<Self>) {
        if self.selected_index < self.filtered_actions.len().saturating_sub(1) {
            self.selected_index += 1;
            self.scroll_handle
                .scroll_to_item(self.selected_index, ScrollStrategy::Nearest);
            logging::log_debug(
                "ACTIONS_SCROLL",
                &format!("Down: selected_index={}", self.selected_index),
            );
            cx.notify();
        }
    }

    /// Get the currently selected action ID (for external handling)
    pub fn get_selected_action_id(&self) -> Option<String> {
        if let Some(&action_idx) = self.filtered_actions.get(self.selected_index) {
            if let Some(action) = self.actions.get(action_idx) {
                return Some(action.id.clone());
            }
        }
        None
    }

    /// Get the currently selected ProtocolAction (for checking close behavior)
    /// Returns the original ProtocolAction from sdk_actions if this is an SDK action,
    /// or None for built-in actions.
    pub fn get_selected_protocol_action(&self) -> Option<&ProtocolAction> {
        let action_id = self.get_selected_action_id()?;
        self.sdk_actions
            .as_ref()?
            .iter()
            .find(|a| a.name == action_id)
    }

    /// Check if the currently selected action should close the dialog
    /// Returns true if the action has close: true (or no close field, which defaults to true)
    /// Returns true for built-in actions (they always close)
    pub fn selected_action_should_close(&self) -> bool {
        if let Some(protocol_action) = self.get_selected_protocol_action() {
            protocol_action.should_close()
        } else {
            // Built-in actions always close
            true
        }
    }

    /// Submit the selected action
    pub fn submit_selected(&mut self) {
        if let Some(&action_idx) = self.filtered_actions.get(self.selected_index) {
            if let Some(action) = self.actions.get(action_idx) {
                logging::log("ACTIONS", &format!("Action selected: {}", action.id));
                (self.on_select)(action.id.clone());
            }
        }
    }

    /// Cancel - close the dialog
    pub fn submit_cancel(&mut self) {
        logging::log("ACTIONS", "Actions dialog cancelled");
        (self.on_select)("__cancel__".to_string());
    }

    /// Dismiss the dialog when user clicks outside its bounds.
    /// This is a public method called from the parent container's click-outside handler.
    /// Logs the event and triggers the cancel callback.
    pub fn dismiss_on_click_outside(&mut self) {
        tracing::info!(
            target: "script_kit::actions",
            "ActionsDialog dismiss-on-click-outside triggered"
        );
        logging::log("ACTIONS", "Actions dialog dismissed (click outside)");
        self.submit_cancel();
    }

    /// Create box shadow for the overlay popup
    /// When rendered in a separate vibrancy window, no shadow is needed
    /// (the window vibrancy provides visual separation)
    pub(super) fn create_popup_shadow() -> Vec<BoxShadow> {
        // No shadow - vibrancy window provides visual separation
        vec![]
    }

    /// Get colors for the search box based on design variant
    /// Returns: (search_box_bg, border_color, muted_text, dimmed_text, secondary_text)
    pub(super) fn get_search_colors(
        &self,
        colors: &crate::designs::DesignColors,
    ) -> (gpui::Rgba, gpui::Rgba, gpui::Rgba, gpui::Rgba, gpui::Rgba) {
        // Use theme opacity for input background to support vibrancy
        let opacity = self.theme.get_opacity();
        let input_alpha = (opacity.input * 255.0) as u8;

        if self.design_variant == DesignVariant::Default {
            (
                rgba(hex_with_alpha(
                    self.theme.colors.background.search_box,
                    input_alpha,
                )),
                rgba(hex_with_alpha(self.theme.colors.ui.border, 0x80)),
                rgb(self.theme.colors.text.muted),
                rgb(self.theme.colors.text.dimmed),
                rgb(self.theme.colors.text.secondary),
            )
        } else {
            (
                rgba(hex_with_alpha(colors.background_secondary, input_alpha)),
                rgba(hex_with_alpha(colors.border, 0x80)),
                rgb(colors.text_muted),
                rgb(colors.text_dimmed),
                rgb(colors.text_secondary),
            )
        }
    }

    /// Get colors for the main container based on design variant
    /// Returns: (main_bg, container_border, container_text)
    pub(super) fn get_container_colors(
        &self,
        colors: &crate::designs::DesignColors,
    ) -> (gpui::Rgba, gpui::Rgba, gpui::Rgba) {
        // Use theme opacity for dialog background to support vibrancy
        // The theme's opacity.dialog controls how transparent the popup is
        let opacity = self.theme.get_opacity();
        let dialog_alpha = (opacity.dialog * 255.0) as u8;

        if self.design_variant == DesignVariant::Default {
            (
                rgba(hex_with_alpha(
                    self.theme.colors.background.main,
                    dialog_alpha,
                )),
                rgba(hex_with_alpha(self.theme.colors.ui.border, 0x80)),
                rgb(self.theme.colors.text.secondary),
            )
        } else {
            (
                rgba(hex_with_alpha(colors.background, dialog_alpha)),
                rgba(hex_with_alpha(colors.border, 0x80)),
                rgb(colors.text_secondary),
            )
        }
    }
}

impl Focusable for ActionsDialog {
    fn focus_handle(&self, _cx: &App) -> FocusHandle {
        self.focus_handle.clone()
    }
}

impl Render for ActionsDialog {
    fn render(&mut self, _window: &mut Window, cx: &mut Context<Self>) -> impl IntoElement {
        // Get design tokens for the current design variant
        let tokens = get_tokens(self.design_variant);
        let colors = tokens.colors();
        let spacing = tokens.spacing();
        let visual = tokens.visual();

        // NOTE: Key handling is done by the parent (ScriptListApp in main.rs)
        // which routes all keyboard events to this dialog's methods.
        // We do NOT attach our own on_key_down handler to avoid double-processing.

        // Render search input - compact version
        let search_display = if self.search_text.is_empty() {
            SharedString::from("Search actions...")
        } else {
            SharedString::from(self.search_text.clone())
        };

        // Use helper method for design/theme color extraction
        let (search_box_bg, border_color, _muted_text, dimmed_text, _secondary_text) =
            self.get_search_colors(&colors);

        // Get primary text color for cursor (matches main list styling)
        let primary_text = if self.design_variant == DesignVariant::Default {
            rgb(self.theme.colors.text.primary)
        } else {
            rgb(colors.text_primary)
        };

        // Get accent color for the search input focus indicator
        let accent_color_hex = if self.design_variant == DesignVariant::Default {
            self.theme.colors.accent.selected
        } else {
            colors.accent
        };
        let accent_color = rgb(accent_color_hex);

        // Focus border color (accent with transparency)
        let focus_border_color = rgba(hex_with_alpha(accent_color_hex, 0x60));

        // Input container with fixed height and width to prevent any layout shifts
        // The entire row is constrained to prevent resizing when text is entered
        let input_container = div()
            .w(px(POPUP_WIDTH)) // Match parent width exactly
            .min_w(px(POPUP_WIDTH))
            .max_w(px(POPUP_WIDTH))
            .h(px(SEARCH_INPUT_HEIGHT)) // Fixed height for the input row
            .min_h(px(SEARCH_INPUT_HEIGHT))
            .max_h(px(SEARCH_INPUT_HEIGHT))
            .overflow_hidden() // Prevent any content from causing shifts
            .px(px(spacing.item_padding_x))
            .py(px(spacing.item_padding_y + 2.0)) // Slightly more vertical padding
            .bg(search_box_bg)
            .border_t_1() // Border on top since input is now at bottom
            .border_color(border_color)
            .flex()
            .flex_row()
            .items_center()
            .gap(px(spacing.gap_md))
            .child(
                // Search icon or indicator - fixed width to prevent shifts
                div()
                    .w(px(24.0)) // Fixed width for the icon container
                    .min_w(px(24.0))
                    .text_color(dimmed_text)
                    .text_xs()
                    .child("⌘K"),
            )
            .child(
                // Search input field with focus indicator
                // CRITICAL: Use flex_shrink_0 to prevent flexbox from shrinking this container
                // The border/bg MUST stay at fixed width regardless of content
                div()
                    .flex_shrink_0() // PREVENT flexbox from shrinking this!
                    .w(px(240.0))
                    .min_w(px(240.0))
                    .max_w(px(240.0))
                    .h(px(28.0)) // Fixed height too
                    .min_h(px(28.0))
                    .max_h(px(28.0))
                    .overflow_hidden()
                    .px(px(spacing.padding_sm))
                    .py(px(spacing.padding_xs))
                    // ALWAYS show background - just vary intensity
                    .bg(if self.design_variant == DesignVariant::Default {
                        rgba(hex_with_alpha(
                            self.theme.colors.background.main,
                            if self.search_text.is_empty() {
                                0x20
                            } else {
                                0x40
                            },
                        ))
                    } else {
                        rgba(hex_with_alpha(
                            colors.background,
                            if self.search_text.is_empty() {
                                0x20
                            } else {
                                0x40
                            },
                        ))
                    })
                    .rounded(px(visual.radius_sm))
                    .border_1()
                    // ALWAYS show border - just vary intensity
                    .border_color(if !self.search_text.is_empty() {
                        focus_border_color
                    } else {
                        border_color
                    })
                    .flex()
                    .flex_row()
                    .items_center()
                    .text_sm()
                    .text_color(if self.search_text.is_empty() {
                        dimmed_text
                    } else {
                        primary_text
                    })
                    // ALWAYS render cursor div with consistent margin to prevent layout shift
                    // When empty, cursor is at the start before placeholder text
                    .when(self.search_text.is_empty(), |d| {
                        d.child(
                            div()
                                .w(px(2.))
                                .h(px(16.))
                                .mr(px(2.)) // Use consistent 2px margin
                                .rounded(px(1.))
                                .when(self.cursor_visible, |d| d.bg(accent_color)),
                        )
                    })
                    .child(search_display)
                    // When has text, cursor is at the end after the text
                    .when(!self.search_text.is_empty(), |d| {
                        d.child(
                            div()
                                .w(px(2.))
                                .h(px(16.))
                                .ml(px(2.)) // Consistent 2px margin
                                .rounded(px(1.))
                                .when(self.cursor_visible, |d| d.bg(accent_color)),
                        )
                    }),
            );

        // Render action list using uniform_list for virtualized scrolling
        let actions_container = if self.filtered_actions.is_empty() {
            div()
                .flex()
                .flex_col()
                .flex_1()
                .w_full()
                .child(
                    div()
                        .w_full()
                        .py(px(spacing.padding_lg))
                        .px(px(spacing.item_padding_x))
                        .text_color(dimmed_text)
                        .text_sm()
                        .child("No actions match your search"),
                )
                .into_any_element()
        } else {
            // Clone data needed for the uniform_list closure
            let selected_index = self.selected_index;
            let filtered_len = self.filtered_actions.len();
            let design_variant = self.design_variant;

            logging::log_debug(
                "ACTIONS_SCROLL",
                &format!(
                    "Rendering uniform_list: {} items, selected={}",
                    filtered_len, selected_index
                ),
            );

            // Calculate scrollbar parameters
            // Container height for actions (excluding search box)
            let search_box_height = if self.hide_search {
                0.0
            } else {
                SEARCH_INPUT_HEIGHT
            };
            let container_height = (filtered_len as f32 * ACTION_ITEM_HEIGHT)
                .min(POPUP_MAX_HEIGHT - search_box_height);
            let visible_items = (container_height / ACTION_ITEM_HEIGHT) as usize;

            // Use selected_index as approximate scroll offset
            // When scrolling, the selected item should be visible, so this gives a reasonable estimate
            let scroll_offset = if selected_index > visible_items.saturating_sub(1) {
                selected_index.saturating_sub(visible_items / 2)
            } else {
                0
            };

            // Get scrollbar colors from theme or design
            let scrollbar_colors = if self.design_variant == DesignVariant::Default {
                ScrollbarColors::from_theme(&self.theme)
            } else {
                ScrollbarColors::from_design(&colors)
            };

            // Create scrollbar (only visible if content overflows)
            let scrollbar =
                Scrollbar::new(filtered_len, visible_items, scroll_offset, scrollbar_colors)
                    .container_height(container_height);

            let list = uniform_list(
                "actions-list",
                filtered_len,
                cx.processor(
                    move |this: &mut ActionsDialog, visible_range, _window, _cx| {
                        logging::log_debug(
                            "ACTIONS_SCROLL",
                            &format!(
                                "Actions visible range: {:?} (total={})",
                                visible_range,
                                this.filtered_actions.len()
                            ),
                        );

                        // Get tokens for list item rendering
                        let item_tokens = get_tokens(design_variant);
                        let item_colors = item_tokens.colors();
                        let item_spacing = item_tokens.spacing();
                        let item_visual = item_tokens.visual();

                        // Extract colors for list items - use theme opacity for vibrancy
                        let theme_opacity = this.theme.get_opacity();
                        let selected_alpha = (theme_opacity.selected * 255.0) as u32;
                        let hover_alpha = (theme_opacity.hover * 255.0) as u32;

                        let (selected_bg, hover_bg, primary_text, secondary_text, dimmed_text) =
                            if design_variant == DesignVariant::Default {
                                (
                                    rgba(
                                        (this.theme.colors.accent.selected_subtle << 8)
                                            | selected_alpha,
                                    ),
                                    rgba(
                                        (this.theme.colors.accent.selected_subtle << 8)
                                            | hover_alpha,
                                    ),
                                    rgb(this.theme.colors.text.primary),
                                    rgb(this.theme.colors.text.secondary),
                                    rgb(this.theme.colors.text.dimmed),
                                )
                            } else {
                                (
                                    rgba((item_colors.background_selected << 8) | selected_alpha),
                                    rgba((item_colors.background_selected << 8) | hover_alpha),
                                    rgb(item_colors.text_primary),
                                    rgb(item_colors.text_secondary),
                                    rgb(item_colors.text_dimmed),
                                )
                            };

                        let mut items = Vec::new();

                        // Get border color for category separators
                        let separator_color = if design_variant == DesignVariant::Default {
                            rgba(hex_with_alpha(this.theme.colors.ui.border, 0x40))
                        } else {
                            rgba(hex_with_alpha(item_colors.border_subtle, 0x40))
                        };

                        for idx in visible_range {
                            if let Some(&action_idx) = this.filtered_actions.get(idx) {
                                if let Some(action) = this.actions.get(action_idx) {
                                    let action: &Action = action; // Explicit type annotation
                                    let is_selected = idx == selected_index;

                                    // Check if this is the first item of a new category
                                    // (for adding a subtle separator line)
                                    let is_category_start = if idx > 0 {
                                        if let Some(&prev_action_idx) =
                                            this.filtered_actions.get(idx - 1)
                                        {
                                            if let Some(prev_action) =
                                                this.actions.get(prev_action_idx)
                                            {
                                                let prev_action: &Action = prev_action;
                                                prev_action.category != action.category
                                            } else {
                                                false
                                            }
                                        } else {
                                            false
                                        }
                                    } else {
                                        false
                                    };

                                    // Match main list styling: bright text when selected, secondary when not
                                    let title_color = if is_selected {
                                        primary_text
                                    } else {
                                        secondary_text
                                    };

                                    let shortcut_color = dimmed_text;

                                    // Clone strings for SharedString conversion
                                    let title_str: String = action.title.clone();
                                    let shortcut_opt: Option<String> = action.shortcut.clone();

                                    // Note: First/last item rounding is handled by the outer container's overflow_hidden
                                    // Keeping these vars commented for reference in case we need them later
                                    // let is_first_item = idx == 0;
                                    // let is_last_item = idx == filtered_len - 1;
                                    let _ = item_visual.radius_lg; // Suppress unused warning

                                    // Get keycap colors for Raycast-style shortcuts
                                    let keycap_bg = if design_variant == DesignVariant::Default {
                                        rgba(hex_with_alpha(this.theme.colors.ui.border, 0x80))
                                    } else {
                                        rgba(hex_with_alpha(item_colors.border, 0x80))
                                    };
                                    let keycap_border = if design_variant == DesignVariant::Default
                                    {
                                        rgba(hex_with_alpha(this.theme.colors.ui.border, 0xA0))
                                    } else {
                                        rgba(hex_with_alpha(item_colors.border, 0xA0))
                                    };

                                    // Raycast-style: compact rows with pill-style selection
                                    // No left accent bar - using rounded background instead
                                    let mut action_item = div()
                                        .id(idx)
                                        .w_full()
                                        .h(px(ACTION_ITEM_HEIGHT)) // Fixed height for uniform_list
                                        .px(px(ACTION_ROW_INSET)) // Horizontal inset for pill effect
                                        .py(px(2.0)) // Minimal vertical padding for tight spacing
                                        .flex()
                                        .flex_col()
                                        .justify_center();

                                    // Add top border for category separator (non-first items only)
                                    if is_category_start {
                                        action_item =
                                            action_item.border_t_1().border_color(separator_color);
                                    }

                                    // Inner row fills available height (minus 4px for py(2) top+bottom)
                                    let inner_row = div()
                                        .w_full()
                                        .flex_1() // Fill available height instead of fixed
                                        .flex()
                                        .flex_row()
                                        .items_center()
                                        .px(px(item_spacing.item_padding_x))
                                        .rounded(px(SELECTION_RADIUS)) // Pill-style rounded corners
                                        .bg(if is_selected {
                                            selected_bg
                                        } else {
                                            rgba(0x00000000)
                                        })
                                        .hover(|s| s.bg(hover_bg))
                                        .cursor_pointer();

                                    // Content row: label + shortcuts
                                    let content = div()
                                        .flex_1()
                                        .flex()
                                        .flex_row()
                                        .items_center()
                                        .justify_between()
                                        .child(
                                            // Left side: title only (no icons)
                                            div()
                                                .text_color(title_color)
                                                .text_sm()
                                                .font_weight(if is_selected {
                                                    gpui::FontWeight::MEDIUM
                                                } else {
                                                    gpui::FontWeight::NORMAL
                                                })
                                                .child(title_str),
                                        );

                                    // Right side: keyboard shortcuts as individual keycaps (Raycast-style)
                                    let content = if let Some(shortcut) = shortcut_opt {
                                        // Parse shortcut into individual keycaps
                                        let keycaps =
                                            ActionsDialog::parse_shortcut_keycaps(&shortcut);

                                        // Build keycap row
                                        let mut keycap_row =
                                            div().flex().flex_row().items_center().gap(px(3.));

                                        for keycap in keycaps {
                                            keycap_row = keycap_row.child(
                                                div()
                                                    .min_w(px(KEYCAP_MIN_WIDTH))
                                                    .h(px(KEYCAP_HEIGHT))
                                                    .px(px(6.))
                                                    .flex()
                                                    .items_center()
                                                    .justify_center()
                                                    .bg(keycap_bg)
                                                    .border_1()
                                                    .border_color(keycap_border)
                                                    .rounded(px(5.))
                                                    .text_xs()
                                                    .text_color(shortcut_color)
                                                    .child(keycap),
                                            );
                                        }

                                        content.child(keycap_row)
                                    } else {
                                        content
                                    };

                                    // Build final action item with inner row
                                    action_item = action_item.child(inner_row.child(content));

                                    items.push(action_item);
                                }
                            }
                        }
                        items
                    },
                ),
            )
            .flex_1()
            .w_full()
            .track_scroll(&self.scroll_handle);

            // Wrap uniform_list in a relative container with scrollbar overlay
            // NOTE: The wrapper needs flex + h_full for uniform_list to properly calculate visible range
            // overflow_hidden clips children to parent bounds (including rounded corners)
            div()
                .relative()
                .flex()
                .flex_col()
                .flex_1()
                .w_full()
                .h_full()
                .overflow_hidden()
                .child(list)
                .child(scrollbar)
                .into_any_element()
        };

        // Use helper method for container colors
        let (main_bg, container_border, container_text) = self.get_container_colors(&colors);

        // Calculate dynamic height based on number of items
        // Each item is ACTION_ITEM_HEIGHT, plus search box height (SEARCH_INPUT_HEIGHT), plus padding
        // When hide_search is true, we don't include the search box height
        // Now also includes HEADER_HEIGHT when context_title is set
        // NOTE: Add border_thin * 2 for border (top + bottom from .border_1()) to prevent
        // content from being clipped and causing unnecessary scrolling
        let num_items = self.filtered_actions.len();
        let search_box_height = if self.hide_search {
            0.0
        } else {
            SEARCH_INPUT_HEIGHT
        };
        let header_height = if self.context_title.is_some() {
            HEADER_HEIGHT
        } else {
            0.0
        };
        let border_height = visual.border_thin * 2.0; // top + bottom border
        let items_height = (num_items as f32 * ACTION_ITEM_HEIGHT)
            .min(POPUP_MAX_HEIGHT - search_box_height - header_height);
        let total_height = items_height + search_box_height + header_height + border_height;

        // Build header row (Raycast-style context title)
        let header_container = self.context_title.as_ref().map(|title| {
            let header_text = if self.design_variant == DesignVariant::Default {
                rgb(self.theme.colors.text.primary)
            } else {
                rgb(colors.text_primary)
            };
            let header_border = if self.design_variant == DesignVariant::Default {
                rgba(hex_with_alpha(self.theme.colors.ui.border, 0x40))
            } else {
                rgba(hex_with_alpha(colors.border, 0x40))
            };

            div()
                .w_full()
                .h(px(HEADER_HEIGHT))
                .px(px(spacing.item_padding_x))
                .flex()
                .items_center()
                .border_b_1()
                .border_color(header_border)
                .child(
                    div()
                        .text_sm()
                        .font_weight(gpui::FontWeight::MEDIUM)
                        .text_color(header_text)
                        .child(title.clone()),
                )
        });

        // Main overlay popup container
        // Fixed width, dynamic height based on content, rounded corners, shadow
        // NOTE: Using visual.radius_lg from design tokens for consistency with child item rounding
        //
        // VIBRANCY: When vibrancy is enabled, do NOT apply a background here.
        // The window's native vibrancy blur provides the frosted glass effect.
        // Only apply a background when vibrancy is disabled for a solid fallback.
        let use_vibrancy = self.theme.is_vibrancy_enabled();

        div()
            .flex()
            .flex_col()
            .w(px(POPUP_WIDTH))
            .h(px(total_height)) // Use calculated height instead of max_h
            .when(!use_vibrancy, |d| d.bg(main_bg)) // Only apply bg when vibrancy disabled
            .rounded(px(visual.radius_lg))
            .shadow(Self::create_popup_shadow())
            .border_1()
            .border_color(container_border)
            .overflow_hidden()
            .text_color(container_text)
            .key_context("actions_dialog")
            .track_focus(&self.focus_handle)
            // NOTE: No on_key_down here - parent handles all keyboard input
            // Header row (if context_title is set)
            .when_some(header_container, |d, header| d.child(header))
            .child(actions_container)
            .when(!self.hide_search, |d| d.child(input_container))
    }
}

</file>

<file path="src/actions/constants.rs">
//! Actions dialog constants
//!
//! Overlay popup dimensions and styling constants used by the ActionsDialog.

/// Popup width for the actions dialog
pub const POPUP_WIDTH: f32 = 320.0;

/// Maximum height for the actions dialog popup
pub const POPUP_MAX_HEIGHT: f32 = 400.0;

/// Fixed height for action items (required for uniform_list virtualization)
/// Standardized to 44px for consistent touch targets (matches iOS guidelines, Notes panel)
pub const ACTION_ITEM_HEIGHT: f32 = 44.0;

/// Fixed height for the search input row (matches Notes panel PANEL_SEARCH_HEIGHT)
pub const SEARCH_INPUT_HEIGHT: f32 = 44.0;

/// Width of the left accent bar for selected items (legacy, kept for reference)
pub const ACCENT_BAR_WIDTH: f32 = 3.0;

/// Height for the header row showing context title
pub const HEADER_HEIGHT: f32 = 44.0;

/// Horizontal inset for action rows (creates rounded pill appearance)
pub const ACTION_ROW_INSET: f32 = 6.0;

/// Corner radius for selected row background (pill style)
pub const SELECTION_RADIUS: f32 = 8.0;

/// Minimum width for keycap badges
pub const KEYCAP_MIN_WIDTH: f32 = 22.0;

/// Height for keycap badges
pub const KEYCAP_HEIGHT: f32 = 22.0;

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_popup_constants() {
        assert_eq!(POPUP_WIDTH, 320.0);
        assert_eq!(POPUP_MAX_HEIGHT, 400.0);
    }

    #[test]
    fn test_action_item_height_constant() {
        // Fixed height is required for uniform_list virtualization
        // Standardized to 44px for consistent touch targets (matches iOS guidelines)
        assert_eq!(ACTION_ITEM_HEIGHT, 44.0);
        // Ensure item height is positive and reasonable
        const _: () = assert!(ACTION_ITEM_HEIGHT > 0.0);
        const _: () = assert!(ACTION_ITEM_HEIGHT < POPUP_MAX_HEIGHT);
    }

    #[test]
    fn test_max_visible_items() {
        // Calculate max visible items that can fit in the popup
        // This helps verify scroll virtualization is worthwhile
        let max_visible = (POPUP_MAX_HEIGHT / ACTION_ITEM_HEIGHT) as usize;
        // With 400px max height and 44px items, ~9 items fit
        assert!(max_visible >= 8, "Should fit at least 8 items");
        assert!(max_visible <= 15, "Sanity check on max visible");
    }
}

</file>

<file path="src/actions/types.rs">
//! Action types and data structures
//!
//! Core types for the actions system including Action, ActionCategory, and ScriptInfo.

use std::sync::Arc;

/// Callback for action selection
/// Signature: (action_id: String)
pub type ActionCallback = Arc<dyn Fn(String) + Send + Sync>;

/// Information about the currently focused/selected script
/// Used for context-aware actions in the actions dialog
#[derive(Debug, Clone)]
pub struct ScriptInfo {
    /// Display name of the script
    pub name: String,
    // Note: path is written during construction for completeness but currently
    // action handlers read directly from ProtocolAction. Kept for API consistency.
    #[allow(dead_code)]
    /// Full path to the script file
    pub path: String,
    /// Whether this is a real script file (true) or a built-in command (false)
    /// Built-in commands (like Clipboard History, App Launcher) have limited actions
    pub is_script: bool,
    /// The verb to use for the primary action (e.g., "Run", "Launch", "Switch to")
    /// Defaults to "Run" for scripts
    pub action_verb: String,
    /// Current keyboard shortcut assigned to this script/item (if any)
    /// Used to determine which shortcut actions to show in the actions menu
    pub shortcut: Option<String>,
}

impl ScriptInfo {
    /// Create a ScriptInfo for a real script file
    pub fn new(name: impl Into<String>, path: impl Into<String>) -> Self {
        ScriptInfo {
            name: name.into(),
            path: path.into(),
            is_script: true,
            action_verb: "Run".to_string(),
            shortcut: None,
        }
    }

    /// Create a ScriptInfo for a real script file with shortcut info
    #[allow(dead_code)]
    pub fn with_shortcut(
        name: impl Into<String>,
        path: impl Into<String>,
        shortcut: Option<String>,
    ) -> Self {
        ScriptInfo {
            name: name.into(),
            path: path.into(),
            is_script: true,
            action_verb: "Run".to_string(),
            shortcut,
        }
    }

    /// Create a ScriptInfo for a built-in command (not a real script)
    /// Built-ins have limited actions (no edit, view logs, reveal in finder, copy path, configure shortcut)
    #[allow(dead_code)]
    pub fn builtin(name: impl Into<String>) -> Self {
        ScriptInfo {
            name: name.into(),
            path: String::new(),
            is_script: false,
            action_verb: "Run".to_string(),
            shortcut: None,
        }
    }

    /// Create a ScriptInfo with explicit is_script flag and custom action verb
    #[allow(dead_code)]
    pub fn with_is_script(
        name: impl Into<String>,
        path: impl Into<String>,
        is_script: bool,
    ) -> Self {
        ScriptInfo {
            name: name.into(),
            path: path.into(),
            is_script,
            action_verb: "Run".to_string(),
            shortcut: None,
        }
    }

    /// Create a ScriptInfo with all options including custom action verb
    pub fn with_action_verb(
        name: impl Into<String>,
        path: impl Into<String>,
        is_script: bool,
        action_verb: impl Into<String>,
    ) -> Self {
        ScriptInfo {
            name: name.into(),
            path: path.into(),
            is_script,
            action_verb: action_verb.into(),
            shortcut: None,
        }
    }

    /// Create a ScriptInfo with all options including custom action verb and shortcut
    #[allow(dead_code)]
    pub fn with_action_verb_and_shortcut(
        name: impl Into<String>,
        path: impl Into<String>,
        is_script: bool,
        action_verb: impl Into<String>,
        shortcut: Option<String>,
    ) -> Self {
        ScriptInfo {
            name: name.into(),
            path: path.into(),
            is_script,
            action_verb: action_verb.into(),
            shortcut,
        }
    }
}

/// Available actions in the actions menu
///
/// Note: The `has_action` and `value` fields are populated from ProtocolAction
/// for consistency, but the actual routing logic reads from the original
/// ProtocolAction. These fields are kept for future use cases where Action
/// might need independent behavior.
#[derive(Debug, Clone)]
pub struct Action {
    pub id: String,
    pub title: String,
    pub description: Option<String>,
    pub category: ActionCategory,
    /// Optional keyboard shortcut hint (e.g., "⌘E")
    pub shortcut: Option<String>,
    /// If true, send ActionTriggered to SDK; if false, submit value directly
    #[allow(dead_code)]
    pub has_action: bool,
    /// Optional value to submit when action is triggered
    #[allow(dead_code)]
    pub value: Option<String>,
}

#[derive(Debug, Clone, PartialEq)]
pub enum ActionCategory {
    ScriptContext, // Actions specific to the focused script
    #[allow(dead_code)]
    ScriptOps, // Edit, Create, Delete script operations (reserved for future use)
    #[allow(dead_code)]
    GlobalOps, // Settings, Quit, etc.
}

impl Action {
    pub fn new(
        id: impl Into<String>,
        title: impl Into<String>,
        description: Option<String>,
        category: ActionCategory,
    ) -> Self {
        Action {
            id: id.into(),
            title: title.into(),
            description,
            category,
            shortcut: None,
            has_action: false,
            value: None,
        }
    }

    pub fn with_shortcut(mut self, shortcut: impl Into<String>) -> Self {
        self.shortcut = Some(shortcut.into());
        self
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_script_info_creation() {
        let script = ScriptInfo::new("test-script", "/path/to/test-script.ts");
        assert_eq!(script.name, "test-script");
        assert_eq!(script.path, "/path/to/test-script.ts");
        assert!(script.is_script);
        assert!(script.shortcut.is_none());
    }

    #[test]
    fn test_script_info_with_shortcut() {
        let script = ScriptInfo::with_shortcut(
            "test-script",
            "/path/to/test-script.ts",
            Some("cmd+shift+t".to_string()),
        );
        assert_eq!(script.name, "test-script");
        assert_eq!(script.shortcut, Some("cmd+shift+t".to_string()));
    }

    #[test]
    fn test_script_info_builtin() {
        let builtin = ScriptInfo::builtin("Clipboard History");
        assert_eq!(builtin.name, "Clipboard History");
        assert_eq!(builtin.path, "");
        assert!(!builtin.is_script);
        assert!(builtin.shortcut.is_none());
    }

    #[test]
    fn test_script_info_with_is_script() {
        let script = ScriptInfo::with_is_script("my-script", "/path/to/script.ts", true);
        assert!(script.is_script);
        assert!(script.shortcut.is_none());

        let builtin = ScriptInfo::with_is_script("App Launcher", "", false);
        assert!(!builtin.is_script);
    }

    #[test]
    fn test_script_info_with_action_verb_and_shortcut() {
        let script = ScriptInfo::with_action_verb_and_shortcut(
            "test",
            "/path",
            true,
            "Launch",
            Some("cmd+k".to_string()),
        );
        assert_eq!(script.action_verb, "Launch");
        assert_eq!(script.shortcut, Some("cmd+k".to_string()));
    }

    #[test]
    fn test_action_with_shortcut() {
        let action =
            Action::new("test", "Test Action", None, ActionCategory::GlobalOps).with_shortcut("⌘T");
        assert_eq!(action.shortcut, Some("⌘T".to_string()));
    }

    #[test]
    fn test_action_new_defaults() {
        let action = Action::new(
            "id",
            "title",
            Some("desc".to_string()),
            ActionCategory::ScriptContext,
        );
        assert_eq!(action.id, "id");
        assert_eq!(action.title, "title");
        assert_eq!(action.description, Some("desc".to_string()));
        assert_eq!(action.category, ActionCategory::ScriptContext);
        assert!(action.shortcut.is_none());
    }
}

</file>

<file path="src/shortcuts/registry.rs">
//! Deterministic shortcut registry with Vec storage.
//!
//! Uses Vec for deterministic iteration order and HashMap for O(1) lookup.

#![allow(dead_code)]

use std::collections::{HashMap, HashSet};

use super::context::ShortcutContext;
use super::types::{ConflictInfo, Shortcut};

/// Source of a shortcut binding.
///
/// Priority order (highest first): user_override > Builtin > Script
/// This ensures built-in shortcuts aren't silently stolen by scripts.
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord)]
pub enum BindingSource {
    /// Built-in app shortcut (highest priority)
    Builtin = 0,
    /// Script-defined shortcut (lower priority)
    Script = 1,
}

impl BindingSource {
    /// Get the priority value (lower = higher priority).
    pub fn priority(&self) -> u8 {
        match self {
            Self::Builtin => 0,
            Self::Script => 1,
        }
    }
}

/// Scope in which a shortcut operates.
#[derive(Clone, Copy, Debug, Default, PartialEq, Eq, Hash)]
pub enum ShortcutScope {
    #[default]
    App,
    Global,
}

/// Category for organizing shortcuts in UI.
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub enum ShortcutCategory {
    Navigation,
    Actions,
    Edit,
    View,
    Scripts,
    System,
}

/// A shortcut binding with metadata.
#[derive(Clone, Debug)]
pub struct ShortcutBinding {
    pub id: String,
    pub name: String,
    pub default_shortcut: Shortcut,
    pub context: ShortcutContext,
    pub scope: ShortcutScope,
    pub category: ShortcutCategory,
    pub source: BindingSource,
    pub customizable: bool,
}

impl ShortcutBinding {
    pub fn builtin(
        id: impl Into<String>,
        name: impl Into<String>,
        shortcut: Shortcut,
        context: ShortcutContext,
        category: ShortcutCategory,
    ) -> Self {
        Self {
            id: id.into(),
            name: name.into(),
            default_shortcut: shortcut,
            context,
            scope: ShortcutScope::App,
            category,
            source: BindingSource::Builtin,
            customizable: true,
        }
    }

    pub fn script(id: impl Into<String>, name: impl Into<String>, shortcut: Shortcut) -> Self {
        Self {
            id: id.into(),
            name: name.into(),
            default_shortcut: shortcut,
            context: ShortcutContext::Global,
            scope: ShortcutScope::App,
            category: ShortcutCategory::Scripts,
            source: BindingSource::Script,
            customizable: false,
        }
    }

    pub fn non_customizable(mut self) -> Self {
        self.customizable = false;
        self
    }

    pub fn global(mut self) -> Self {
        self.scope = ShortcutScope::Global;
        self
    }
}

/// Central registry of all keyboard shortcuts.
pub struct ShortcutRegistry {
    bindings: Vec<ShortcutBinding>,
    id_to_index: HashMap<String, usize>,
    user_overrides: HashMap<String, Option<Shortcut>>,
    disabled: HashSet<String>,
}

impl Default for ShortcutRegistry {
    fn default() -> Self {
        Self::new()
    }
}

impl ShortcutRegistry {
    pub fn new() -> Self {
        Self {
            bindings: Vec::new(),
            id_to_index: HashMap::new(),
            user_overrides: HashMap::new(),
            disabled: HashSet::new(),
        }
    }

    pub fn register(&mut self, binding: ShortcutBinding) {
        let id = binding.id.clone();
        if let Some(&existing_index) = self.id_to_index.get(&id) {
            self.bindings[existing_index] = binding;
        } else {
            let index = self.bindings.len();
            self.bindings.push(binding);
            self.id_to_index.insert(id, index);
        }
    }

    pub fn unregister(&mut self, id: &str) {
        self.disabled.insert(id.to_string());
    }

    pub fn get(&self, id: &str) -> Option<&ShortcutBinding> {
        self.id_to_index.get(id).and_then(|&i| self.bindings.get(i))
    }

    pub fn get_shortcut(&self, id: &str) -> Option<Shortcut> {
        if self.disabled.contains(id) {
            return None;
        }
        if let Some(override_opt) = self.user_overrides.get(id) {
            return override_opt.clone();
        }
        self.get(id).map(|b| b.default_shortcut.clone())
    }

    pub fn set_override(&mut self, id: &str, shortcut: Option<Shortcut>) {
        if shortcut.is_none() {
            self.disabled.insert(id.to_string());
        } else {
            self.disabled.remove(id);
        }
        self.user_overrides.insert(id.to_string(), shortcut);
    }

    pub fn clear_override(&mut self, id: &str) {
        self.user_overrides.remove(id);
        self.disabled.remove(id);
    }

    pub fn is_disabled(&self, id: &str) -> bool {
        self.disabled.contains(id)
    }

    /// Find a matching binding for a keystroke in the given context stack.
    ///
    /// Within each context, priority order is:
    /// 1. User overrides (always win if present)
    /// 2. Builtins (win over scripts)
    /// 3. Scripts (lowest priority)
    pub fn find_match(
        &self,
        keystroke: &gpui::Keystroke,
        contexts: &[ShortcutContext],
    ) -> Option<&str> {
        for context in contexts {
            // Collect all matches in this context
            let mut matches: Vec<(&ShortcutBinding, bool)> = Vec::new();

            for binding in &self.bindings {
                if binding.context != *context || self.disabled.contains(&binding.id) {
                    continue;
                }

                let has_user_override = self.user_overrides.contains_key(&binding.id);
                let shortcut = if let Some(override_opt) = self.user_overrides.get(&binding.id) {
                    match override_opt {
                        Some(s) => s.clone(),
                        None => continue, // Disabled via override
                    }
                } else {
                    binding.default_shortcut.clone()
                };

                if shortcut.matches_keystroke(keystroke) {
                    matches.push((binding, has_user_override));
                }
            }

            // If we have matches, return the highest priority one
            if !matches.is_empty() {
                // Sort by: user_override first, then source priority, then registration order
                matches.sort_by(|(a, a_override), (b, b_override)| {
                    // User override always wins
                    match (a_override, b_override) {
                        (true, false) => std::cmp::Ordering::Less,
                        (false, true) => std::cmp::Ordering::Greater,
                        _ => {
                            // Same override status: compare source priority
                            a.source.priority().cmp(&b.source.priority())
                        }
                    }
                });

                return Some(&matches[0].0.id);
            }
        }
        None
    }

    /// Check if a script shortcut would conflict with a builtin.
    ///
    /// Returns the ID of the conflicting builtin if one exists.
    pub fn check_builtin_conflict(
        &self,
        shortcut: &Shortcut,
        context: ShortcutContext,
    ) -> Option<&str> {
        for binding in &self.bindings {
            if binding.source != BindingSource::Builtin {
                continue;
            }
            if binding.context != context && binding.context != ShortcutContext::Global {
                continue;
            }
            if self.disabled.contains(&binding.id) {
                continue;
            }

            let effective = self
                .user_overrides
                .get(&binding.id)
                .cloned()
                .unwrap_or_else(|| Some(binding.default_shortcut.clone()));

            if let Some(builtin_shortcut) = effective {
                if builtin_shortcut == *shortcut {
                    return Some(&binding.id);
                }
            }
        }
        None
    }

    pub fn bindings(&self) -> &[ShortcutBinding] {
        &self.bindings
    }

    pub fn bindings_by_category(&self, category: ShortcutCategory) -> Vec<&ShortcutBinding> {
        self.bindings
            .iter()
            .filter(|b| b.category == category && !self.disabled.contains(&b.id))
            .collect()
    }

    pub fn bindings_by_context(&self, context: ShortcutContext) -> Vec<&ShortcutBinding> {
        self.bindings
            .iter()
            .filter(|b| b.context == context && !self.disabled.contains(&b.id))
            .collect()
    }

    pub fn active_count(&self) -> usize {
        self.bindings
            .iter()
            .filter(|b| !self.disabled.contains(&b.id))
            .count()
    }

    /// Get all user overrides as a map of binding_id -> Option<Shortcut>.
    ///
    /// Returns None for disabled shortcuts, Some(shortcut) for overridden shortcuts.
    pub fn get_overrides(&self) -> &HashMap<String, Option<Shortcut>> {
        &self.user_overrides
    }

    /// Export user overrides as canonical strings for persistence.
    ///
    /// Returns a map of binding_id -> Option<String> where:
    /// - Some(string) = override shortcut as canonical string
    /// - None = shortcut is disabled
    pub fn export_overrides(&self) -> HashMap<String, Option<String>> {
        self.user_overrides
            .iter()
            .map(|(id, opt)| (id.clone(), opt.as_ref().map(|s| s.to_canonical_string())))
            .collect()
    }

    /// Find all conflicts in the registry.
    ///
    /// Returns a list of conflicts, each containing:
    /// - The type of conflict
    /// - The IDs of the conflicting bindings
    /// - The conflicting shortcut
    pub fn find_conflicts(&self) -> Vec<ShortcutConflict> {
        let mut conflicts = Vec::new();

        // Build a map of effective shortcuts to bindings
        let mut shortcut_map: HashMap<(String, ShortcutContext), Vec<&ShortcutBinding>> =
            HashMap::new();

        for binding in &self.bindings {
            if self.disabled.contains(&binding.id) {
                continue;
            }

            let effective = self
                .user_overrides
                .get(&binding.id)
                .cloned()
                .unwrap_or_else(|| Some(binding.default_shortcut.clone()));

            if let Some(shortcut) = effective {
                let key = (shortcut.to_canonical_string(), binding.context);
                shortcut_map.entry(key).or_default().push(binding);
            }
        }

        // Check for hard conflicts (same shortcut + same context)
        for ((shortcut_str, context), bindings) in &shortcut_map {
            if bindings.len() > 1 {
                // Sort by priority to determine winner/loser
                let mut sorted: Vec<_> = bindings.iter().collect();
                sorted.sort_by_key(|b| b.source.priority());

                let winner = sorted[0];
                for loser in &sorted[1..] {
                    let conflict_type = if winner.source == loser.source {
                        ConflictType::Hard
                    } else {
                        // Different sources: higher priority shadows lower
                        ConflictType::Shadowed
                    };

                    conflicts.push(ShortcutConflict {
                        conflict_type,
                        winner_id: winner.id.clone(),
                        loser_id: loser.id.clone(),
                        shortcut: shortcut_str.clone(),
                        context: *context,
                    });
                }
            }
        }

        // Check for shadowing across context specificity
        for binding in &self.bindings {
            if self.disabled.contains(&binding.id) {
                continue;
            }

            let effective = self
                .user_overrides
                .get(&binding.id)
                .cloned()
                .unwrap_or_else(|| Some(binding.default_shortcut.clone()));

            if let Some(shortcut) = effective {
                let shortcut_str = shortcut.to_canonical_string();

                // Check if this binding is shadowed by a more specific context
                for other in &self.bindings {
                    if other.id == binding.id || self.disabled.contains(&other.id) {
                        continue;
                    }

                    // Skip if not same shortcut
                    let other_effective = self
                        .user_overrides
                        .get(&other.id)
                        .cloned()
                        .unwrap_or_else(|| Some(other.default_shortcut.clone()));

                    let other_shortcut = match other_effective {
                        Some(s) => s,
                        None => continue,
                    };

                    if other_shortcut.to_canonical_string() != shortcut_str {
                        continue;
                    }

                    // Check context specificity: other shadows binding if other is more specific
                    if other.context.specificity() > binding.context.specificity()
                        && binding.context.contains(&other.context)
                    {
                        // Already covered by same-context check
                        continue;
                    }
                }
            }
        }

        // Check for OS-reserved shortcuts (unreachable)
        let os_reserved = Self::get_os_reserved_shortcuts();
        for binding in &self.bindings {
            if self.disabled.contains(&binding.id) {
                continue;
            }

            let effective = self
                .user_overrides
                .get(&binding.id)
                .cloned()
                .unwrap_or_else(|| Some(binding.default_shortcut.clone()));

            if let Some(shortcut) = effective {
                let canonical = shortcut.to_canonical_string();
                if os_reserved.contains(&canonical.as_str()) {
                    conflicts.push(ShortcutConflict {
                        conflict_type: ConflictType::Unreachable,
                        winner_id: "system".to_string(),
                        loser_id: binding.id.clone(),
                        shortcut: canonical,
                        context: binding.context,
                    });
                }
            }
        }

        conflicts
    }

    /// Get list of OS-reserved shortcuts that cannot be overridden.
    ///
    /// These are typically system-level shortcuts that apps cannot intercept.
    fn get_os_reserved_shortcuts() -> HashSet<&'static str> {
        let mut reserved = HashSet::new();

        #[cfg(target_os = "macos")]
        {
            // macOS system shortcuts
            reserved.insert("cmd+tab"); // App switcher
            reserved.insert("cmd+shift+tab"); // Reverse app switcher
            reserved.insert("cmd+space"); // Spotlight (often)
            reserved.insert("cmd+ctrl+q"); // Lock screen
            reserved.insert("cmd+shift+3"); // Screenshot full
            reserved.insert("cmd+shift+4"); // Screenshot selection
            reserved.insert("cmd+shift+5"); // Screenshot/record options
            reserved.insert("ctrl+up"); // Mission Control
            reserved.insert("ctrl+down"); // App windows
            reserved.insert("ctrl+left"); // Move space left
            reserved.insert("ctrl+right"); // Move space right
        }

        #[cfg(target_os = "windows")]
        {
            // Windows system shortcuts
            reserved.insert("cmd+tab"); // Alt+Tab (cmd maps to Win)
            reserved.insert("cmd+d"); // Show desktop
            reserved.insert("cmd+l"); // Lock
            reserved.insert("cmd+e"); // File Explorer
            reserved.insert("ctrl+alt+delete"); // Security options
        }

        #[cfg(target_os = "linux")]
        {
            // Common Linux shortcuts (vary by DE)
            reserved.insert("alt+tab"); // Window switcher
            reserved.insert("cmd+tab"); // Super+Tab
            reserved.insert("ctrl+alt+t"); // Terminal (common)
            reserved.insert("ctrl+alt+delete"); // System
        }

        reserved
    }

    /// Get conflicts for a specific binding.
    pub fn conflicts_for(&self, id: &str) -> Vec<ShortcutConflict> {
        self.find_conflicts()
            .into_iter()
            .filter(|c| c.winner_id == id || c.loser_id == id)
            .collect()
    }

    /// Check if adding a shortcut would create conflicts.
    ///
    /// Returns the conflicts that would be created if this shortcut were added.
    pub fn would_conflict(
        &self,
        shortcut: &Shortcut,
        context: ShortcutContext,
        source: BindingSource,
    ) -> Vec<PotentialConflict> {
        let mut conflicts = Vec::new();
        let canonical = shortcut.to_canonical_string();

        // Check OS reserved
        let os_reserved = Self::get_os_reserved_shortcuts();
        if os_reserved.contains(&canonical.as_str()) {
            conflicts.push(PotentialConflict {
                conflict_type: ConflictType::Unreachable,
                existing_id: "system".to_string(),
                existing_name: "System Shortcut".to_string(),
            });
        }

        // Check existing bindings
        for binding in &self.bindings {
            if self.disabled.contains(&binding.id) {
                continue;
            }

            let effective = self
                .user_overrides
                .get(&binding.id)
                .cloned()
                .unwrap_or_else(|| Some(binding.default_shortcut.clone()));

            if let Some(existing_shortcut) = effective {
                if existing_shortcut.to_canonical_string() != canonical {
                    continue;
                }

                // Same shortcut - check context overlap
                let contexts_overlap = binding.context == context
                    || binding.context == ShortcutContext::Global
                    || context == ShortcutContext::Global
                    || binding.context.contains(&context)
                    || context.contains(&binding.context);

                if contexts_overlap {
                    let conflict_type = if binding.context == context
                        && source.priority() == binding.source.priority()
                    {
                        ConflictType::Hard // Same context + same priority = hard conflict
                    } else {
                        ConflictType::Shadowed // Different priority or context = shadowing
                    };

                    conflicts.push(PotentialConflict {
                        conflict_type,
                        existing_id: binding.id.clone(),
                        existing_name: binding.name.clone(),
                    });
                }
            }
        }

        conflicts
    }

    /// Find a conflict for a proposed shortcut.
    ///
    /// This is the primary API for the ShortcutRecorder UI. It checks if the given
    /// shortcut is already registered (either as a default or user override) and
    /// returns conflict information suitable for displaying to the user.
    ///
    /// # Arguments
    /// * `shortcut` - The shortcut to check for conflicts
    ///
    /// # Returns
    /// * `Some(ConflictInfo)` if the shortcut conflicts with an existing binding
    /// * `None` if the shortcut is available
    ///
    /// # Example
    /// ```ignore
    /// let shortcut = Shortcut::parse("cmd+k").unwrap();
    /// if let Some(conflict) = registry.find_conflict(&shortcut) {
    ///     println!("Conflict with: {} ({})", conflict.command_name, conflict.command_type);
    /// }
    /// ```
    pub fn find_conflict(&self, shortcut: &Shortcut) -> Option<ConflictInfo> {
        let canonical = shortcut.to_canonical_string();

        // Check OS reserved shortcuts first
        let os_reserved = Self::get_os_reserved_shortcuts();
        if os_reserved.contains(&canonical.as_str()) {
            return Some(ConflictInfo::system());
        }

        // Check all registered bindings (both defaults and user overrides)
        for binding in &self.bindings {
            if self.disabled.contains(&binding.id) {
                continue;
            }

            // Get the effective shortcut (user override or default)
            let effective = self
                .user_overrides
                .get(&binding.id)
                .cloned()
                .unwrap_or_else(|| Some(binding.default_shortcut.clone()));

            if let Some(existing_shortcut) = effective {
                if existing_shortcut.to_canonical_string() == canonical {
                    // Found a conflict
                    let command_type = match binding.source {
                        BindingSource::Builtin => "builtin",
                        BindingSource::Script => "script",
                    };

                    return Some(ConflictInfo {
                        conflicting_command_id: binding.id.clone(),
                        command_name: binding.name.clone(),
                        command_type: command_type.to_string(),
                    });
                }
            }
        }

        None
    }

    /// Find a conflict for a shortcut, excluding a specific command ID.
    ///
    /// This is useful when editing an existing shortcut - you want to check
    /// for conflicts but not report a conflict with the command being edited.
    ///
    /// # Arguments
    /// * `shortcut` - The shortcut to check for conflicts
    /// * `exclude_id` - The command ID to exclude from conflict checking
    ///
    /// # Returns
    /// * `Some(ConflictInfo)` if the shortcut conflicts with another binding
    /// * `None` if the shortcut is available (or only conflicts with excluded ID)
    pub fn find_conflict_excluding(
        &self,
        shortcut: &Shortcut,
        exclude_id: &str,
    ) -> Option<ConflictInfo> {
        let canonical = shortcut.to_canonical_string();

        // Check OS reserved shortcuts first
        let os_reserved = Self::get_os_reserved_shortcuts();
        if os_reserved.contains(&canonical.as_str()) {
            return Some(ConflictInfo::system());
        }

        // Check all registered bindings (both defaults and user overrides)
        for binding in &self.bindings {
            // Skip the excluded binding
            if binding.id == exclude_id {
                continue;
            }
            if self.disabled.contains(&binding.id) {
                continue;
            }

            // Get the effective shortcut (user override or default)
            let effective = self
                .user_overrides
                .get(&binding.id)
                .cloned()
                .unwrap_or_else(|| Some(binding.default_shortcut.clone()));

            if let Some(existing_shortcut) = effective {
                if existing_shortcut.to_canonical_string() == canonical {
                    // Found a conflict
                    let command_type = match binding.source {
                        BindingSource::Builtin => "builtin",
                        BindingSource::Script => "script",
                    };

                    return Some(ConflictInfo {
                        conflicting_command_id: binding.id.clone(),
                        command_name: binding.name.clone(),
                        command_type: command_type.to_string(),
                    });
                }
            }
        }

        None
    }

    /// Get the human-readable name for a command ID.
    ///
    /// # Arguments
    /// * `id` - The command ID to look up
    ///
    /// # Returns
    /// * `Some(&str)` with the command name if found
    /// * `None` if the command ID is not registered
    pub fn get_command_name(&self, id: &str) -> Option<&str> {
        self.get(id).map(|binding| binding.name.as_str())
    }

    /// Get full binding info for a command ID, useful for UI display.
    ///
    /// Returns the binding along with its effective shortcut (considering overrides).
    pub fn get_binding_info(&self, id: &str) -> Option<(&ShortcutBinding, Option<Shortcut>)> {
        self.get(id).map(|binding| {
            let effective = self
                .user_overrides
                .get(&binding.id)
                .cloned()
                .unwrap_or_else(|| Some(binding.default_shortcut.clone()));
            (binding, effective)
        })
    }
}

/// Type of shortcut conflict.
#[derive(Clone, Copy, Debug, PartialEq, Eq)]
pub enum ConflictType {
    /// Same shortcut + same context + same priority.
    /// One must be changed or disabled.
    Hard,
    /// Shortcut exists but is intentionally shadowed by context specificity
    /// or source priority. The more specific/higher priority binding wins.
    Shadowed,
    /// Shortcut is reserved by the OS and cannot be overridden.
    Unreachable,
}

/// A conflict between two shortcut bindings.
#[derive(Clone, Debug)]
pub struct ShortcutConflict {
    pub conflict_type: ConflictType,
    pub winner_id: String,
    pub loser_id: String,
    pub shortcut: String,
    pub context: ShortcutContext,
}

/// A potential conflict that would occur if a shortcut were added.
#[derive(Clone, Debug)]
pub struct PotentialConflict {
    pub conflict_type: ConflictType,
    pub existing_id: String,
    pub existing_name: String,
}

</file>

<file path="src/shortcuts/types.rs">
//! Core shortcut types with proper error handling and platform-aware display.
//!
//! This module provides:
//! - `Shortcut` - A keyboard shortcut (modifiers + key)
//! - `Modifiers` - Modifier key flags (cmd, ctrl, alt, shift)
//! - `ShortcutParseError` - Detailed parse errors for user feedback
//! - Platform-aware display (⌘⇧K on macOS, Ctrl+Shift+K on Windows/Linux)

// Allow dead code during incremental development - these types will be used
// by the context stack (task 2) and registry (task 3).
#![allow(dead_code)]

use serde::{Deserialize, Serialize};
use std::fmt;
use thiserror::Error;

/// Errors that can occur when parsing a shortcut string.
#[derive(Error, Debug, Clone, PartialEq, Eq)]
pub enum ShortcutParseError {
    #[error("shortcut string is empty")]
    Empty,
    #[error("shortcut has no key, only modifiers")]
    MissingKey,
    #[error("unknown token '{0}' in shortcut")]
    UnknownToken(String),
    #[error("unknown key '{0}'")]
    UnknownKey(String),
}

/// Modifier keys for a shortcut.
///
/// Note on `cmd` (platform accelerator):
/// - On macOS: Command (⌘)
/// - On Windows/Linux: Ctrl
#[derive(Clone, Copy, Debug, Default, PartialEq, Eq, Hash, Serialize, Deserialize)]
pub struct Modifiers {
    #[serde(default)]
    pub cmd: bool,
    #[serde(default)]
    pub ctrl: bool,
    #[serde(default)]
    pub alt: bool,
    #[serde(default)]
    pub shift: bool,
}

impl Modifiers {
    pub fn cmd() -> Self {
        Self {
            cmd: true,
            ..Default::default()
        }
    }
    pub fn shift() -> Self {
        Self {
            shift: true,
            ..Default::default()
        }
    }
    pub fn any(&self) -> bool {
        self.cmd || self.ctrl || self.alt || self.shift
    }
    pub fn none(&self) -> bool {
        !self.any()
    }
}

/// Platform enum for display formatting.
#[derive(Clone, Copy, Debug, PartialEq, Eq)]
pub enum Platform {
    MacOS,
    Windows,
    Linux,
}

impl Platform {
    pub fn current() -> Self {
        #[cfg(target_os = "macos")]
        {
            Platform::MacOS
        }
        #[cfg(target_os = "windows")]
        {
            Platform::Windows
        }
        #[cfg(target_os = "linux")]
        {
            Platform::Linux
        }
        #[cfg(not(any(target_os = "macos", target_os = "windows", target_os = "linux")))]
        {
            Platform::Linux
        }
    }
}

/// A keyboard shortcut consisting of modifier keys and a main key.
#[derive(Clone, Debug, PartialEq, Eq, Hash, Serialize, Deserialize)]
pub struct Shortcut {
    pub key: String,
    pub modifiers: Modifiers,
}

impl Shortcut {
    pub fn new(key: impl Into<String>, modifiers: Modifiers) -> Self {
        Self {
            key: canonicalize_key(&key.into()),
            modifiers,
        }
    }

    pub fn parse(s: &str) -> Result<Self, ShortcutParseError> {
        let s = s.trim();
        if s.is_empty() {
            return Err(ShortcutParseError::Empty);
        }

        let normalized = s.replace('+', " ");
        let parts: Vec<&str> = normalized.split_whitespace().collect();
        if parts.is_empty() {
            return Err(ShortcutParseError::Empty);
        }

        let mut modifiers = Modifiers::default();
        let mut key_part: Option<&str> = None;

        for part in &parts {
            let part_lower = part.to_lowercase();
            match part_lower.as_str() {
                "cmd" | "command" | "meta" | "super" | "win" | "⌘" | "mod" => {
                    modifiers.cmd = true
                }
                "ctrl" | "control" | "ctl" | "^" => modifiers.ctrl = true,
                "alt" | "opt" | "option" | "⌥" => modifiers.alt = true,
                "shift" | "shft" | "⇧" => modifiers.shift = true,
                _ => {
                    if key_part.is_some() {
                        return Err(ShortcutParseError::UnknownToken(part.to_string()));
                    }
                    key_part = Some(part);
                }
            }
        }

        let key = key_part.ok_or(ShortcutParseError::MissingKey)?;
        let canonical_key = canonicalize_key(key);
        if !is_known_key(&canonical_key) {
            return Err(ShortcutParseError::UnknownKey(key.to_string()));
        }

        Ok(Self {
            key: canonical_key,
            modifiers,
        })
    }

    pub fn display(&self) -> String {
        self.display_for_platform(Platform::current())
    }

    pub fn display_for_platform(&self, platform: Platform) -> String {
        match platform {
            Platform::MacOS => self.display_macos(),
            Platform::Windows | Platform::Linux => self.display_other(),
        }
    }

    fn display_macos(&self) -> String {
        let mut s = String::new();
        if self.modifiers.ctrl {
            s.push('⌃');
        }
        if self.modifiers.alt {
            s.push('⌥');
        }
        if self.modifiers.shift {
            s.push('⇧');
        }
        if self.modifiers.cmd {
            s.push('⌘');
        }
        s.push_str(&self.key_display());
        s
    }

    fn display_other(&self) -> String {
        let mut parts: Vec<String> = Vec::new();
        if self.modifiers.ctrl {
            parts.push("Ctrl".to_string());
        }
        if self.modifiers.alt {
            parts.push("Alt".to_string());
        }
        if self.modifiers.shift {
            parts.push("Shift".to_string());
        }
        if self.modifiers.cmd {
            parts.push("Super".to_string());
        }
        parts.push(self.key_display_text());
        parts.join("+")
    }

    fn key_display(&self) -> String {
        match self.key.as_str() {
            "enter" => "↵",
            "escape" => "⎋",
            "tab" => "⇥",
            "space" => "␣",
            "backspace" => "⌫",
            "delete" => "⌦",
            "up" => "↑",
            "down" => "↓",
            "left" => "←",
            "right" => "→",
            "home" => "↖",
            "end" => "↘",
            "pageup" => "⇞",
            "pagedown" => "⇟",
            k => return k.to_uppercase(),
        }
        .to_string()
    }

    fn key_display_text(&self) -> String {
        match self.key.as_str() {
            "enter" => "Enter",
            "escape" => "Esc",
            "tab" => "Tab",
            "space" => "Space",
            "backspace" => "Backspace",
            "delete" => "Delete",
            "up" => "Up",
            "down" => "Down",
            "left" => "Left",
            "right" => "Right",
            "home" => "Home",
            "end" => "End",
            "pageup" => "PageUp",
            "pagedown" => "PageDown",
            k => return k.to_uppercase(),
        }
        .to_string()
    }

    pub fn to_canonical_string(&self) -> String {
        let mut parts: Vec<&str> = Vec::new();
        if self.modifiers.alt {
            parts.push("alt");
        }
        if self.modifiers.cmd {
            parts.push("cmd");
        }
        if self.modifiers.ctrl {
            parts.push("ctrl");
        }
        if self.modifiers.shift {
            parts.push("shift");
        }
        parts.push(&self.key);
        parts.join("+")
    }

    pub fn matches_keystroke(&self, keystroke: &gpui::Keystroke) -> bool {
        let canonical = canonicalize_key(&keystroke.key.to_lowercase());
        canonical == self.key
            && keystroke.modifiers.platform == self.modifiers.cmd
            && keystroke.modifiers.control == self.modifiers.ctrl
            && keystroke.modifiers.alt == self.modifiers.alt
            && keystroke.modifiers.shift == self.modifiers.shift
    }
}

impl fmt::Display for Shortcut {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        write!(f, "{}", self.display())
    }
}

/// Canonicalize a key name to the internal standard form.
pub fn canonicalize_key(key: &str) -> String {
    let key_lower = key.to_lowercase();
    match key_lower.as_str() {
        "arrowup" | "uparrow" => "up",
        "arrowdown" | "downarrow" => "down",
        "arrowleft" | "leftarrow" => "left",
        "arrowright" | "rightarrow" => "right",
        "return" => "enter",
        "esc" => "escape",
        "back" => "backspace",
        "del" => "delete",
        "/" | "forwardslash" => "slash",
        "\\" => "backslash",
        ";" => "semicolon",
        "'" | "apostrophe" => "quote",
        "," => "comma",
        "." | "dot" => "period",
        "[" | "leftbracket" => "bracketleft",
        "]" | "rightbracket" => "bracketright",
        "-" | "dash" | "hyphen" => "minus",
        "=" | "equals" => "equal",
        "`" | "backtick" | "grave" => "backquote",
        "pgup" => "pageup",
        "pgdn" | "pgdown" => "pagedown",
        _ => return key_lower,
    }
    .to_string()
}

/// Information about a shortcut conflict.
///
/// This struct provides UI-friendly information about a conflict between
/// a proposed shortcut and an existing one. Used by ShortcutRecorder to
/// display warnings before saving.
#[derive(Clone, Debug, PartialEq, Eq)]
pub struct ConflictInfo {
    /// The ID of the command that already has this shortcut
    pub conflicting_command_id: String,
    /// Human-readable name of the conflicting command (e.g., "Move Selection Up")
    pub command_name: String,
    /// Type of command: "builtin", "script", or "system"
    pub command_type: String,
}

impl ConflictInfo {
    /// Create a new ConflictInfo for a builtin command
    pub fn builtin(id: impl Into<String>, name: impl Into<String>) -> Self {
        Self {
            conflicting_command_id: id.into(),
            command_name: name.into(),
            command_type: "builtin".to_string(),
        }
    }

    /// Create a new ConflictInfo for a script command
    pub fn script(id: impl Into<String>, name: impl Into<String>) -> Self {
        Self {
            conflicting_command_id: id.into(),
            command_name: name.into(),
            command_type: "script".to_string(),
        }
    }

    /// Create a new ConflictInfo for a system/OS reserved shortcut
    pub fn system() -> Self {
        Self {
            conflicting_command_id: "system".to_string(),
            command_name: "System Shortcut".to_string(),
            command_type: "system".to_string(),
        }
    }
}

/// Check if a key name is known/valid.
pub fn is_known_key(key: &str) -> bool {
    matches!(
        key,
        "a" | "b"
            | "c"
            | "d"
            | "e"
            | "f"
            | "g"
            | "h"
            | "i"
            | "j"
            | "k"
            | "l"
            | "m"
            | "n"
            | "o"
            | "p"
            | "q"
            | "r"
            | "s"
            | "t"
            | "u"
            | "v"
            | "w"
            | "x"
            | "y"
            | "z"
            | "0"
            | "1"
            | "2"
            | "3"
            | "4"
            | "5"
            | "6"
            | "7"
            | "8"
            | "9"
            | "f1"
            | "f2"
            | "f3"
            | "f4"
            | "f5"
            | "f6"
            | "f7"
            | "f8"
            | "f9"
            | "f10"
            | "f11"
            | "f12"
            | "f13"
            | "f14"
            | "f15"
            | "f16"
            | "f17"
            | "f18"
            | "f19"
            | "f20"
            | "f21"
            | "f22"
            | "f23"
            | "f24"
            | "space"
            | "enter"
            | "tab"
            | "escape"
            | "backspace"
            | "delete"
            | "up"
            | "down"
            | "left"
            | "right"
            | "home"
            | "end"
            | "pageup"
            | "pagedown"
            | "semicolon"
            | "quote"
            | "comma"
            | "period"
            | "slash"
            | "backslash"
            | "bracketleft"
            | "bracketright"
            | "minus"
            | "equal"
            | "backquote"
    )
}

</file>

<file path="src/app_actions.rs">
// Actions handling methods - extracted from app_impl.rs
// This file is included via include!() macro in main.rs
// Contains: handle_action, trigger_action_by_name

impl ScriptListApp {
    /// Helper to hide main window and set reset flag
    fn hide_main_and_reset(&self, cx: &mut Context<Self>) {
        set_main_window_visible(false);
        NEEDS_RESET.store(true, Ordering::SeqCst);
        cx.hide();
    }

    /// Helper to reveal a path in Finder (macOS)
    fn reveal_in_finder(&self, path: &std::path::Path) {
        let path_str = path.to_string_lossy().to_string();
        std::thread::spawn(move || {
            use std::process::Command;
            match Command::new("open").arg("-R").arg(&path_str).spawn() {
                Ok(_) => logging::log("UI", &format!("Revealed in Finder: {}", path_str)),
                Err(e) => logging::log("ERROR", &format!("Failed to reveal in Finder: {}", e)),
            }
        });
    }

    /// Copy text to clipboard using pbcopy on macOS.
    /// Critical: This properly closes stdin before waiting to prevent hangs.
    #[cfg(target_os = "macos")]
    fn pbcopy(&self, text: &str) -> Result<(), std::io::Error> {
        use std::io::Write;
        use std::process::{Command, Stdio};

        let mut child = Command::new("pbcopy").stdin(Stdio::piped()).spawn()?;

        // Take ownership of stdin, write, then drop to signal EOF
        if let Some(mut stdin) = child.stdin.take() {
            stdin.write_all(text.as_bytes())?;
            // stdin is dropped here => EOF delivered to pbcopy
        }

        // Now it's safe to wait - pbcopy has received EOF
        child.wait()?;
        Ok(())
    }

    /// Handle action selection from the actions dialog
    fn handle_action(&mut self, action_id: String, cx: &mut Context<Self>) {
        logging::log("UI", &format!("Action selected: {}", action_id));

        // Close the dialog and return to script list
        self.current_view = AppView::ScriptList;
        self.pending_focus = Some(FocusTarget::MainFilter);

        match action_id.as_str() {
            "create_script" => {
                logging::log("UI", "Create script action - opening scripts folder");
                let scripts_dir = shellexpand::tilde("~/.scriptkit/scripts").to_string();
                std::thread::spawn(move || {
                    use std::process::Command;
                    match Command::new("open").arg(&scripts_dir).spawn() {
                        Ok(_) => {
                            logging::log("UI", &format!("Opened scripts folder: {}", scripts_dir))
                        }
                        Err(e) => {
                            logging::log("ERROR", &format!("Failed to open scripts folder: {}", e))
                        }
                    }
                });
                self.last_output = Some(SharedString::from("Opened scripts folder"));
                self.hide_main_and_reset(cx);
            }
            "run_script" => {
                logging::log("UI", "Run script action");
                self.execute_selected(cx);
            }
            "view_logs" => {
                logging::log("UI", "View logs action");
                self.toggle_logs(cx);
            }
            "reveal_in_finder" => {
                logging::log("UI", "Reveal in Finder action");
                if let Some(result) = self.get_selected_result() {
                    let path_opt = match result {
                        scripts::SearchResult::Script(m) => Some(m.script.path.clone()),
                        scripts::SearchResult::App(m) => Some(m.app.path.clone()),
                        scripts::SearchResult::Agent(m) => Some(m.agent.path.clone()),
                        scripts::SearchResult::Scriptlet(_) => {
                            self.last_output =
                                Some(SharedString::from("Cannot reveal scriptlets in Finder"));
                            None
                        }
                        scripts::SearchResult::BuiltIn(_) => {
                            self.last_output =
                                Some(SharedString::from("Cannot reveal built-in features"));
                            None
                        }
                        scripts::SearchResult::Window(_) => {
                            self.last_output =
                                Some(SharedString::from("Cannot reveal windows in Finder"));
                            None
                        }
                        scripts::SearchResult::Fallback(_) => {
                            self.last_output = Some(SharedString::from(
                                "Cannot reveal fallback commands in Finder",
                            ));
                            None
                        }
                    };

                    if let Some(path) = path_opt {
                        self.reveal_in_finder(&path);
                        self.last_output = Some(SharedString::from("Revealed in Finder"));
                        self.hide_main_and_reset(cx);
                    }
                } else {
                    self.last_output = Some(SharedString::from("No item selected"));
                }
            }
            "copy_path" => {
                logging::log("UI", "Copy path action");
                if let Some(result) = self.get_selected_result() {
                    let path_opt = match result {
                        scripts::SearchResult::Script(m) => Some(m.script.path.clone()),
                        scripts::SearchResult::App(m) => Some(m.app.path.clone()),
                        scripts::SearchResult::Agent(m) => Some(m.agent.path.clone()),
                        scripts::SearchResult::Scriptlet(_) => {
                            self.last_output =
                                Some(SharedString::from("Cannot copy scriptlet path"));
                            None
                        }
                        scripts::SearchResult::BuiltIn(_) => {
                            self.last_output =
                                Some(SharedString::from("Cannot copy built-in path"));
                            None
                        }
                        scripts::SearchResult::Window(_) => {
                            self.last_output = Some(SharedString::from("Cannot copy window path"));
                            None
                        }
                        scripts::SearchResult::Fallback(_) => {
                            self.last_output =
                                Some(SharedString::from("Cannot copy fallback command path"));
                            None
                        }
                    };

                    if let Some(path) = path_opt {
                        let path_str = path.to_string_lossy().to_string();

                        #[cfg(target_os = "macos")]
                        {
                            match self.pbcopy(&path_str) {
                                Ok(_) => {
                                    logging::log(
                                        "UI",
                                        &format!("Copied path to clipboard: {}", path_str),
                                    );
                                    self.last_output =
                                        Some(SharedString::from(format!("Copied: {}", path_str)));
                                }
                                Err(e) => {
                                    logging::log("ERROR", &format!("pbcopy failed: {}", e));
                                    self.last_output =
                                        Some(SharedString::from("Failed to copy path"));
                                }
                            }
                        }

                        #[cfg(not(target_os = "macos"))]
                        {
                            use arboard::Clipboard;
                            match Clipboard::new().and_then(|mut c| c.set_text(&path_str)) {
                                Ok(_) => {
                                    logging::log(
                                        "UI",
                                        &format!("Copied path to clipboard: {}", path_str),
                                    );
                                    self.last_output =
                                        Some(SharedString::from(format!("Copied: {}", path_str)));
                                }
                                Err(e) => {
                                    logging::log("ERROR", &format!("Failed to copy path: {}", e));
                                    self.last_output =
                                        Some(SharedString::from("Failed to copy path"));
                                }
                            }
                        }
                    }
                } else {
                    self.last_output = Some(SharedString::from("No item selected"));
                }
            }
            // Handle both legacy "configure_shortcut" and new dynamic actions
            // "add_shortcut" and "update_shortcut" open the shortcut recorder
            "configure_shortcut" | "add_shortcut" | "update_shortcut" => {
                logging::log("UI", &format!("{} action", action_id));
                if let Some(result) = self.get_selected_result() {
                    match result {
                        // Scripts: open the script file to edit // Shortcut: comment
                        scripts::SearchResult::Script(m) => {
                            self.edit_script(&m.script.path);
                            self.hide_main_and_reset(cx);
                        }
                        scripts::SearchResult::Agent(m) => {
                            self.edit_script(&m.agent.path);
                            self.hide_main_and_reset(cx);
                        }
                        // Non-scripts: show inline shortcut recorder
                        scripts::SearchResult::Scriptlet(m) => {
                            let command_id = format!("scriptlet/{}", m.scriptlet.name);
                            let command_name = m.scriptlet.name.clone();
                            self.show_shortcut_recorder(command_id, command_name, cx);
                        }
                        scripts::SearchResult::BuiltIn(m) => {
                            let command_id = format!("builtin/{}", m.entry.id);
                            let command_name = m.entry.name.clone();
                            self.show_shortcut_recorder(command_id, command_name, cx);
                        }
                        scripts::SearchResult::App(m) => {
                            // Use bundle ID if available, otherwise use name
                            let command_id = if let Some(ref bundle_id) = m.app.bundle_id {
                                format!("app/{}", bundle_id)
                            } else {
                                format!("app/{}", m.app.name.to_lowercase().replace(' ', "-"))
                            };
                            let command_name = m.app.name.clone();
                            self.show_shortcut_recorder(command_id, command_name, cx);
                        }
                        scripts::SearchResult::Window(_) => {
                            self.last_output = Some(SharedString::from(
                                "Window shortcuts not supported - windows are transient",
                            ));
                        }
                        scripts::SearchResult::Fallback(m) => {
                            match &m.fallback {
                                crate::fallbacks::collector::FallbackItem::Builtin(b) => {
                                    let command_id = format!("fallback/{}", m.fallback.name());
                                    let command_name = b.name.to_string();
                                    self.show_shortcut_recorder(command_id, command_name, cx);
                                }
                                crate::fallbacks::collector::FallbackItem::Script(s) => {
                                    // Script-based fallback - open the script
                                    self.edit_script(&s.script.path);
                                    self.hide_main_and_reset(cx);
                                }
                            }
                        }
                    }
                } else {
                    self.last_output = Some(SharedString::from("No item selected"));
                }
            }
            // "remove_shortcut" removes the existing shortcut from the registry
            "remove_shortcut" => {
                logging::log("UI", "Remove shortcut action");
                if let Some(result) = self.get_selected_result() {
                    let command_id_opt = match result {
                        scripts::SearchResult::Script(m) => {
                            Some(format!("script/{}", m.script.name))
                        }
                        scripts::SearchResult::Scriptlet(m) => {
                            Some(format!("scriptlet/{}", m.scriptlet.name))
                        }
                        scripts::SearchResult::BuiltIn(m) => {
                            Some(format!("builtin/{}", m.entry.id))
                        }
                        scripts::SearchResult::App(m) => {
                            if let Some(ref bundle_id) = m.app.bundle_id {
                                Some(format!("app/{}", bundle_id))
                            } else {
                                Some(format!(
                                    "app/{}",
                                    m.app.name.to_lowercase().replace(' ', "-")
                                ))
                            }
                        }
                        scripts::SearchResult::Agent(m) => Some(format!("agent/{}", m.agent.name)),
                        scripts::SearchResult::Window(_) => {
                            self.last_output =
                                Some(SharedString::from("Window shortcuts not supported"));
                            None
                        }
                        scripts::SearchResult::Fallback(m) => {
                            Some(format!("fallback/{}", m.fallback.name()))
                        }
                    };

                    if let Some(command_id) = command_id_opt {
                        // Remove the shortcut override from persistence
                        match crate::shortcuts::remove_shortcut_override(&command_id) {
                            Ok(()) => {
                                logging::log(
                                    "SHORTCUT",
                                    &format!("Removed shortcut for: {}", command_id),
                                );
                                self.last_output = Some(SharedString::from("Shortcut removed"));
                                // Refresh scripts to update shortcut display
                                self.refresh_scripts(cx);
                            }
                            Err(e) => {
                                logging::log("ERROR", &format!("Failed to remove shortcut: {}", e));
                                self.last_output = Some(SharedString::from(format!(
                                    "Failed to remove shortcut: {}",
                                    e
                                )));
                            }
                        }
                    }
                    self.hide_main_and_reset(cx);
                } else {
                    self.last_output = Some(SharedString::from("No item selected"));
                }
            }
            "edit_script" => {
                logging::log("UI", "Edit script action");
                if let Some(result) = self.get_selected_result() {
                    let path_opt = match result {
                        scripts::SearchResult::Script(m) => Some(m.script.path.clone()),
                        scripts::SearchResult::Agent(m) => Some(m.agent.path.clone()),
                        scripts::SearchResult::Scriptlet(_) => {
                            self.last_output = Some(SharedString::from("Cannot edit scriptlets"));
                            None
                        }
                        scripts::SearchResult::BuiltIn(_) => {
                            self.last_output =
                                Some(SharedString::from("Cannot edit built-in features"));
                            None
                        }
                        scripts::SearchResult::App(_) => {
                            self.last_output = Some(SharedString::from("Cannot edit applications"));
                            None
                        }
                        scripts::SearchResult::Window(_) => {
                            self.last_output = Some(SharedString::from("Cannot edit windows"));
                            None
                        }
                        scripts::SearchResult::Fallback(_) => {
                            self.last_output =
                                Some(SharedString::from("Cannot edit fallback commands"));
                            None
                        }
                    };

                    if let Some(path) = path_opt {
                        self.edit_script(&path);
                        self.hide_main_and_reset(cx);
                    }
                } else {
                    self.last_output = Some(SharedString::from("No script selected"));
                }
            }
            "reload_scripts" => {
                logging::log("UI", "Reload scripts action");
                self.refresh_scripts(cx);
                self.last_output = Some(SharedString::from("Scripts reloaded"));
            }
            "settings" => {
                logging::log("UI", "Settings action");
                self.last_output = Some(SharedString::from("Settings (TODO)"));
            }
            "quit" => {
                logging::log("UI", "Quit action");
                PROCESS_MANAGER.kill_all_processes();
                PROCESS_MANAGER.remove_main_pid();
                cx.quit();
                return; // Early return after quit - no notify needed
            }
            "__cancel__" => {
                logging::log("UI", "Actions dialog cancelled");
                // Clear file search actions path on cancel
                self.file_search_actions_path = None;
            }
            // File search specific actions
            "open_file" | "open_directory" => {
                if let Some(ref path) = self.file_search_actions_path {
                    logging::log("UI", &format!("Opening file: {}", path));
                    let _ = crate::file_search::open_file(path);
                    self.file_search_actions_path = None;
                    self.close_and_reset_window(cx);
                }
            }
            "quick_look" => {
                if let Some(ref path) = self.file_search_actions_path {
                    logging::log("UI", &format!("Quick Look: {}", path));
                    let _ = crate::file_search::quick_look(path);
                    self.file_search_actions_path = None;
                    // Don't close window for Quick Look - user may want to continue
                }
            }
            "open_with" => {
                if let Some(ref path) = self.file_search_actions_path {
                    logging::log("UI", &format!("Open With: {}", path));
                    let _ = crate::file_search::open_with(path);
                    self.file_search_actions_path = None;
                }
            }
            "show_info" => {
                if let Some(ref path) = self.file_search_actions_path {
                    logging::log("UI", &format!("Show Info: {}", path));
                    let _ = crate::file_search::show_info(path);
                    self.file_search_actions_path = None;
                }
            }
            "copy_filename" => {
                if let Some(ref path) = self.file_search_actions_path {
                    let filename = std::path::Path::new(path)
                        .file_name()
                        .and_then(|n| n.to_str())
                        .unwrap_or("");
                    logging::log("UI", &format!("Copy filename: {}", filename));
                    #[cfg(target_os = "macos")]
                    {
                        let _ = self.pbcopy(filename);
                    }
                    #[cfg(not(target_os = "macos"))]
                    {
                        use arboard::Clipboard;
                        let _ = Clipboard::new().and_then(|mut c| c.set_text(filename));
                    }
                    self.last_output = Some(SharedString::from(format!("Copied: {}", filename)));
                    self.file_search_actions_path = None;
                }
            }
            _ => {
                // Check if this is a file search action with reveal_in_finder or copy_path
                // (these actions exist both for scripts and file search)
                if let Some(path) = self.file_search_actions_path.clone() {
                    match action_id.as_str() {
                        "reveal_in_finder" => {
                            logging::log(
                                "UI",
                                &format!("Reveal in Finder (file search): {}", path),
                            );
                            self.reveal_in_finder(std::path::Path::new(&path));
                            self.file_search_actions_path = None;
                            cx.notify();
                            return;
                        }
                        "copy_path" => {
                            logging::log("UI", &format!("Copy path (file search): {}", path));
                            #[cfg(target_os = "macos")]
                            {
                                let _ = self.pbcopy(&path);
                            }
                            #[cfg(not(target_os = "macos"))]
                            {
                                use arboard::Clipboard;
                                let _ = Clipboard::new().and_then(|mut c| c.set_text(&path));
                            }
                            self.last_output =
                                Some(SharedString::from(format!("Copied: {}", path)));
                            self.file_search_actions_path = None;
                            cx.notify();
                            return;
                        }
                        _ => {}
                    }
                }
                // Handle SDK actions using shared helper
                self.trigger_sdk_action_internal(&action_id);
            }
        }

        cx.notify();
    }

    /// Internal helper for triggering SDK actions - used by both handle_action and trigger_action_by_name
    fn trigger_sdk_action_internal(&mut self, action_name: &str) {
        if let Some(ref actions) = self.sdk_actions {
            if let Some(action) = actions.iter().find(|a| a.name == action_name) {
                let send_result = if action.has_action {
                    logging::log(
                        "ACTIONS",
                        &format!(
                            "SDK action with handler: '{}' (has_action=true), sending ActionTriggered",
                            action_name
                        ),
                    );
                    if let Some(ref sender) = self.response_sender {
                        let msg = protocol::Message::action_triggered(
                            action_name.to_string(),
                            action.value.clone(),
                            self.arg_input.text().to_string(),
                        );
                        Some(sender.try_send(msg))
                    } else {
                        None
                    }
                } else if let Some(ref value) = action.value {
                    logging::log(
                        "ACTIONS",
                        &format!(
                            "SDK action without handler: '{}' (has_action=false), submitting value: {:?}",
                            action_name, value
                        ),
                    );
                    if let Some(ref sender) = self.response_sender {
                        let msg = protocol::Message::Submit {
                            id: "action".to_string(),
                            value: Some(value.clone()),
                        };
                        Some(sender.try_send(msg))
                    } else {
                        None
                    }
                } else {
                    logging::log(
                        "ACTIONS",
                        &format!(
                            "SDK action '{}' has no value and has_action=false",
                            action_name
                        ),
                    );
                    None
                };

                // Log any send errors
                if let Some(result) = send_result {
                    match result {
                        Ok(()) => {}
                        Err(std::sync::mpsc::TrySendError::Full(_)) => {
                            logging::log(
                                "WARN",
                                &format!(
                                    "Response channel full - action '{}' dropped",
                                    action_name
                                ),
                            );
                        }
                        Err(std::sync::mpsc::TrySendError::Disconnected(_)) => {
                            logging::log("UI", "Response channel disconnected - script exited");
                        }
                    }
                }
            } else {
                logging::log("UI", &format!("Unknown action: {}", action_name));
            }
        } else {
            logging::log("UI", &format!("Unknown action: {}", action_name));
        }
    }

    /// Trigger an SDK action by name
    /// Returns true if the action was found and triggered
    fn trigger_action_by_name(&mut self, action_name: &str, cx: &mut Context<Self>) -> bool {
        if let Some(ref actions) = self.sdk_actions {
            if actions.iter().any(|a| a.name == action_name) {
                logging::log(
                    "ACTIONS",
                    &format!("Triggering SDK action '{}' via shortcut", action_name),
                );
                self.trigger_sdk_action_internal(action_name);
                cx.notify();
                return true;
            }
        }
        false
    }
}

</file>

</files>