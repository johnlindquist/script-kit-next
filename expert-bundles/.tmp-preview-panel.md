This file is a merged representation of the filtered codebase, combined into a single document by packx.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of filtered repository contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<usage_guidelines>
- Treat this file as a snapshot of the repository's state
- Be aware that this file may contain sensitive information
</usage_guidelines>

<notes>
- Files were filtered by packx based on content and extension matching
- Total files included: 5
</notes>
</file_summary>

<directory_structure>
src/syntax.rs
src/render_script_list.rs
src/app_render.rs
src/render_builtins.rs
src/ui_foundation.rs
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="src/syntax.rs">
//! Syntax highlighting module using syntect
//!
//! Provides syntax highlighting for code strings with colors that integrate
//! with the existing theme system. Colors are returned as hex u32 values.
//!
//! NOTE: syntect's default syntax set doesn't include TypeScript, so we use
//! JavaScript syntax for .ts files (which works well for highlighting).

#![allow(dead_code)]

use syntect::easy::HighlightLines;
use syntect::highlighting::{Style, ThemeSet};
use syntect::parsing::SyntaxSet;
use syntect::util::LinesWithEndings;

/// A highlighted span of text with its associated color
#[derive(Debug, Clone, PartialEq)]
pub struct HighlightedSpan {
    /// The text content of this span
    pub text: String,
    /// The color as a hex u32 value (0xRRGGBB format)
    pub color: u32,
    /// Whether this span ends a line (contains newline)
    pub is_line_end: bool,
}

impl HighlightedSpan {
    /// Create a new highlighted span
    pub fn new(text: impl Into<String>, color: u32) -> Self {
        let text_str = text.into();
        let is_line_end = text_str.ends_with('\n');
        Self {
            text: text_str,
            color,
            is_line_end,
        }
    }
}

/// A complete highlighted line with all its spans
#[derive(Debug, Clone)]
pub struct HighlightedLine {
    pub spans: Vec<HighlightedSpan>,
}

/// Convert a syntect Style color to a hex u32 value
fn style_to_hex_color(style: &Style) -> u32 {
    let fg = style.foreground;
    ((fg.r as u32) << 16) | ((fg.g as u32) << 8) | (fg.b as u32)
}

/// Map language name/extension to syntect syntax name
/// NOTE: TypeScript is NOT in syntect defaults, so we map to JavaScript
fn map_language_to_syntax(language: &str) -> &str {
    match language.to_lowercase().as_str() {
        // TypeScript -> JavaScript (syntect doesn't have TypeScript by default)
        "typescript" | "ts" => "JavaScript",
        "javascript" | "js" => "JavaScript",
        "markdown" | "md" => "Markdown",
        "json" => "JSON",
        "rust" | "rs" => "Rust",
        "python" | "py" => "Python",
        "html" => "HTML",
        "css" => "CSS",
        "shell" | "sh" | "bash" => "Bourne Again Shell (bash)",
        "yaml" | "yml" => "YAML",
        // Note: TOML may not be in syntect defaults either
        "toml" => "Makefile", // Fallback - TOML not in defaults
        _ => language,        // Try the language name directly as fallback
    }
}

/// Highlight code with syntax coloring, returning lines of spans
///
/// # Arguments
/// * `code` - The source code to highlight
/// * `language` - The language identifier (e.g., "typescript", "javascript", "markdown", "ts", "js", "md")
///
/// # Returns
/// A vector of `HighlightedLine` structs, each containing spans for one line.
/// This preserves line structure for proper rendering.
pub fn highlight_code_lines(code: &str, language: &str) -> Vec<HighlightedLine> {
    let ps = SyntaxSet::load_defaults_newlines();
    let ts = ThemeSet::load_defaults();

    // Use base16-eighties.dark theme which looks good on dark backgrounds
    let theme = &ts.themes["base16-eighties.dark"];

    // Default foreground color for plain text (light gray)
    let default_color = 0xcccccc_u32;

    let syntax_name = map_language_to_syntax(language);

    // Try to find the syntax by name, or fall back to JavaScript for unknown
    let syntax = ps
        .find_syntax_by_name(syntax_name)
        .or_else(|| ps.find_syntax_by_extension(language))
        .or_else(|| ps.find_syntax_by_name("JavaScript")) // Better fallback than plain text
        .unwrap_or_else(|| ps.find_syntax_plain_text());

    let mut highlighter = HighlightLines::new(syntax, theme);
    let mut result = Vec::new();

    for line in LinesWithEndings::from(code) {
        let mut line_spans = Vec::new();

        match highlighter.highlight_line(line, &ps) {
            Ok(ranges) => {
                for (style, text) in ranges {
                    if !text.is_empty() {
                        // Strip trailing newline for cleaner rendering
                        let clean_text = text.trim_end_matches('\n');
                        if !clean_text.is_empty() {
                            line_spans
                                .push(HighlightedSpan::new(clean_text, style_to_hex_color(&style)));
                        }
                    }
                }
            }
            Err(_) => {
                // On error, push the line as plain text
                let clean_line = line.trim_end_matches('\n');
                if !clean_line.is_empty() {
                    line_spans.push(HighlightedSpan::new(clean_line, default_color));
                }
            }
        }

        result.push(HighlightedLine { spans: line_spans });
    }

    // If no lines were produced, return empty vec
    result
}

/// Highlight code with syntax coloring (flat span list for backward compatibility)
///
/// # Arguments
/// * `code` - The source code to highlight
/// * `language` - The language identifier (e.g., "typescript", "javascript", "markdown", "ts", "js", "md")
///
/// # Returns
/// A vector of `HighlightedSpan` structs, each containing a text segment and its color.
/// If the language is not recognized, returns the code as plain text with default color.
pub fn highlight_code(code: &str, language: &str) -> Vec<HighlightedSpan> {
    let ps = SyntaxSet::load_defaults_newlines();
    let ts = ThemeSet::load_defaults();

    // Use base16-eighties.dark theme which looks good on dark backgrounds
    let theme = &ts.themes["base16-eighties.dark"];

    // Default foreground color for plain text (light gray)
    let default_color = 0xcccccc_u32;

    let syntax_name = map_language_to_syntax(language);

    // Try to find the syntax by name, or fall back to JavaScript for unknown
    let syntax = ps
        .find_syntax_by_name(syntax_name)
        .or_else(|| ps.find_syntax_by_extension(language))
        .or_else(|| ps.find_syntax_by_name("JavaScript")) // Better fallback than plain text
        .unwrap_or_else(|| ps.find_syntax_plain_text());

    let mut highlighter = HighlightLines::new(syntax, theme);
    let mut result = Vec::new();

    for line in LinesWithEndings::from(code) {
        match highlighter.highlight_line(line, &ps) {
            Ok(ranges) => {
                for (style, text) in ranges {
                    if !text.is_empty() {
                        result.push(HighlightedSpan::new(text, style_to_hex_color(&style)));
                    }
                }
            }
            Err(_) => {
                // On error, push the line as plain text
                result.push(HighlightedSpan::new(line, default_color));
            }
        }
    }

    // If no spans were produced, return the original code as plain text
    if result.is_empty() && !code.is_empty() {
        result.push(HighlightedSpan::new(code, default_color));
    }

    result
}

/// Get a list of supported language identifiers
pub fn supported_languages() -> Vec<&'static str> {
    vec![
        "typescript",
        "ts",
        "javascript",
        "js",
        "markdown",
        "md",
        "json",
        "rust",
        "rs",
        "python",
        "py",
        "html",
        "css",
        "shell",
        "sh",
        "bash",
        "yaml",
        "yml",
        "toml",
    ]
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_highlight_typescript() {
        let code = "const x: number = 42;";
        let spans = highlight_code(code, "typescript");

        // Should produce multiple spans with different colors
        assert!(!spans.is_empty());

        // Verify the text content is preserved
        let reconstructed: String = spans.iter().map(|s| s.text.as_str()).collect();
        assert_eq!(reconstructed, code);
    }

    #[test]
    fn test_highlight_javascript() {
        let code = "function hello() { return 'world'; }";
        let spans = highlight_code(code, "javascript");

        assert!(!spans.is_empty());
        let reconstructed: String = spans.iter().map(|s| s.text.as_str()).collect();
        assert_eq!(reconstructed, code);
    }

    #[test]
    fn test_highlight_markdown() {
        let code = "# Hello World\n\nThis is **bold** text.";
        let spans = highlight_code(code, "markdown");

        assert!(!spans.is_empty());
        let reconstructed: String = spans.iter().map(|s| s.text.as_str()).collect();
        assert_eq!(reconstructed, code);
    }

    #[test]
    fn test_highlight_with_extension() {
        let code = "let x = 1;";
        let spans_ts = highlight_code(code, "ts");
        let spans_js = highlight_code(code, "js");

        assert!(!spans_ts.is_empty());
        assert!(!spans_js.is_empty());
    }

    #[test]
    fn test_unknown_language_returns_plain_text() {
        let code = "some random text";
        let spans = highlight_code(code, "unknownlang123");

        // Should return at least one span with the full text
        assert!(!spans.is_empty());
        let reconstructed: String = spans.iter().map(|s| s.text.as_str()).collect();
        assert_eq!(reconstructed, code);
    }

    #[test]
    fn test_empty_code() {
        let spans = highlight_code("", "typescript");
        assert!(spans.is_empty());
    }

    #[test]
    fn test_multiline_code() {
        let code = "const a = 1;\nconst b = 2;\nconst c = a + b;";
        let spans = highlight_code(code, "javascript");

        assert!(!spans.is_empty());
        let reconstructed: String = spans.iter().map(|s| s.text.as_str()).collect();
        assert_eq!(reconstructed, code);
    }

    #[test]
    fn test_color_format() {
        let spans = highlight_code("let x = 42;", "typescript");

        for span in &spans {
            // Colors should be in valid hex range (0x000000 to 0xFFFFFF)
            assert!(
                span.color <= 0xFFFFFF,
                "Color {:06X} out of range",
                span.color
            );
        }
    }

    #[test]
    fn test_highlighted_span_new() {
        let span = HighlightedSpan::new("hello", 0xFF0000);
        assert_eq!(span.text, "hello");
        assert_eq!(span.color, 0xFF0000);
    }

    #[test]
    fn test_supported_languages() {
        let languages = supported_languages();
        assert!(languages.contains(&"typescript"));
        assert!(languages.contains(&"javascript"));
        assert!(languages.contains(&"markdown"));
        assert!(languages.contains(&"ts"));
        assert!(languages.contains(&"js"));
        assert!(languages.contains(&"md"));
    }

    #[test]
    fn test_highlight_lines_preserves_structure() {
        let code = "const a = 1;\nconst b = 2;";
        let lines = highlight_code_lines(code, "js");

        // Should have 2 lines
        assert_eq!(lines.len(), 2);

        // Each line should have spans
        assert!(!lines[0].spans.is_empty());
        assert!(!lines[1].spans.is_empty());
    }

    #[test]
    fn test_highlight_produces_colors() {
        // Use JavaScript which IS in syntect defaults
        let code = "function test() { return 42; }";
        let spans = highlight_code(code, "javascript");

        // Check we have different colors (real syntax highlighting)
        let unique_colors: std::collections::HashSet<u32> = spans.iter().map(|s| s.color).collect();
        assert!(
            unique_colors.len() > 1,
            "Expected syntax highlighting to produce multiple colors"
        );
    }
}

</file>

<file path="src/render_script_list.rs">
// Script list render method - extracted from app_render.rs
// This file is included via include!() macro in main.rs

impl ScriptListApp {
    fn render_script_list(&mut self, cx: &mut Context<Self>) -> AnyElement {
        // Get grouped or flat results based on filter state (cached) - MUST come first
        // to avoid borrow conflicts with theme access below
        // When filter is empty, use frecency-grouped results with RECENT/MAIN sections
        // When filtering, use flat fuzzy search results
        let (grouped_items, flat_results) = self.get_grouped_results_cached();
        // Clone for use in closures and to avoid borrow issues
        let grouped_items = grouped_items.clone();
        let flat_results = flat_results.clone();

        // Get design tokens for current design variant
        let tokens = get_tokens(self.current_design);
        let design_colors = tokens.colors();
        let design_spacing = tokens.spacing();
        let design_visual = tokens.visual();
        let design_typography = tokens.typography();

        // For Default design, use theme.colors for backward compatibility
        // For other designs, use design tokens
        let is_default_design = self.current_design == DesignVariant::Default;

        let item_count = grouped_items.len();
        let _total_len = self.scripts.len() + self.scriptlets.len();

        // ============================================================
        // MUTABLE OPERATIONS BLOCK - do all &mut self calls here BEFORE
        // taking immutable borrows of theme for UI building
        // ============================================================

        // Handle edge cases - keep selected_index in valid bounds
        // Use coerce_selection which tries down first, then up, handles all edge cases
        //
        // Note: Fallbacks now flow through GroupedListItem from get_grouped_results().
        // When filter_text is non-empty, fallbacks are appended to the results, so
        // item_count > 0 even when there are no regular matches. The old fallback_mode
        // logic (separate rendering path) is kept for backwards compatibility but
        // should rarely be triggered now.
        if item_count > 0 {
            // We have results (may include fallbacks) - exit legacy fallback mode
            self.fallback_mode = false;
            self.cached_fallbacks.clear();

            if let Some(valid_idx) =
                list_item::coerce_selection(&grouped_items, self.selected_index)
            {
                self.selected_index = valid_idx;
            } else {
                // No selectable items (list is all headers) - set to 0 as fallback
                self.selected_index = 0;
            }
        } else {
            // Empty list - reset selection state to avoid stale indices
            // This path is hit when filter is empty AND there are truly no items,
            // or in edge cases where even fallbacks aren't available
            self.selected_index = 0;
            self.hovered_index = None;
            self.last_scrolled_index = None;

            // Legacy fallback mode: only used if grouping.rs doesn't include fallbacks
            // (This is a safety net - normally grouping.rs appends fallbacks to results)
            self.fallback_mode = false;
            self.cached_fallbacks.clear();
        }

        // Update list state if item count changed
        // Use splice instead of reset to preserve scroll events and measurement cache
        // reset() drops scroll events until the list is painted, which can break scroll-driven UI
        let old_list_count = self.main_list_state.item_count();
        if old_list_count != item_count {
            self.main_list_state.splice(0..old_list_count, item_count);
            // Invalidate last_scrolled_index since list structure changed
            self.last_scrolled_index = None;
        }

        // Only scroll to reveal selection when selection actually changed
        // This prevents fighting trackpad/wheel scrolling and reduces redundant scroll calls
        self.scroll_to_selected_if_needed("render_list");

        // Get scroll offset AFTER updates for scrollbar
        let scroll_offset = self.main_list_state.logical_scroll_top().item_ix;

        // ============================================================
        // IMMUTABLE BORROWS BLOCK - extract theme values for UI building
        // ============================================================

        // Extract theme values as owned copies for UI building
        let log_panel_bg = self.theme.colors.background.log_panel;
        let log_panel_border = self.theme.colors.ui.border;
        let log_panel_success = self.theme.colors.ui.success;

        // Pre-compute scrollbar colors (Copy type)
        let scrollbar_colors = if is_default_design {
            ScrollbarColors::from_theme(&self.theme)
        } else {
            ScrollbarColors::from_design(&design_colors)
        };
        // Pre-compute list item colors for closure (Copy type)
        let theme_colors = ListItemColors::from_theme(&self.theme);

        let theme = &self.theme;

        logging::log_debug("PERF", "P4: Using ListItemColors for render closure");

        // Build script list using uniform_list for proper virtualized scrolling
        // Use design tokens for empty state styling
        let empty_text_color = if is_default_design {
            theme.colors.text.muted
        } else {
            design_colors.text_muted
        };
        let empty_font_family = if is_default_design {
            ".AppleSystemUIFont"
        } else {
            design_typography.font_family
        };

        let list_element: AnyElement = if item_count == 0 {
            // When there's no filter text, show "No scripts or snippets found"
            // When filtering, show Raycast-style fallback list instead of "No results"
            // Empty list handling:
            // - When filter is empty: "No scripts or snippets found"
            // - When filter has text: "No results match '...'" (rare - fallbacks usually exist)
            //
            // Note: This branch is rarely hit when filtering because grouping.rs now
            // appends fallbacks to the results. We only get here if there are truly
            // no results at all (including no fallbacks).
            if self.filter_text.is_empty() {
                div()
                    .w_full()
                    .h_full()
                    .flex()
                    .items_center()
                    .justify_center()
                    .text_color(rgb(empty_text_color))
                    .font_family(empty_font_family)
                    .child("No scripts or snippets found")
                    .into_any_element()
            } else {
                // Filtering but no results (including no fallbacks) - shouldn't normally happen
                div()
                    .w_full()
                    .h_full()
                    .flex()
                    .items_center()
                    .justify_center()
                    .text_color(rgb(empty_text_color))
                    .font_family(empty_font_family)
                    .child(format!("No results match '{}'", self.filter_text))
                    .into_any_element()
            }
        } else {
            // Use GPUI's list() component for variable-height items
            // Section headers render at 24px, regular items at 48px
            // This gives true visual compression for headers without the uniform_list hack

            // Clone grouped_items and flat_results for the closure
            let grouped_items_clone = grouped_items.clone();
            let flat_results_clone = flat_results.clone();

            // Calculate scrollbar parameters for variable-height items
            // Count section headers vs regular items to get true content height
            let mut header_count = 0_usize;
            let mut item_count_regular = 0_usize;
            for item in grouped_items.iter() {
                match item {
                    GroupedListItem::SectionHeader(_) => header_count += 1,
                    GroupedListItem::Item(_) => item_count_regular += 1,
                }
            }

            // Calculate true content height: headers at 24px, items at 48px
            let total_content_height = (header_count as f32 * SECTION_HEADER_HEIGHT)
                + (item_count_regular as f32 * LIST_ITEM_HEIGHT);

            // Estimated visible container height
            // Window is 500px, header is ~60px, remaining ~440px for list area
            // Use a slightly higher estimate to ensure scrollbar thumb reaches bottom
            // (underestimating visible items causes thumb to not reach bottom)
            let estimated_container_height = 440.0_f32;

            // Calculate visible items as a ratio of container to total content
            // This gives a more accurate thumb size for the scrollbar
            let visible_ratio = if total_content_height > 0.0 {
                (estimated_container_height / total_content_height).min(1.0)
            } else {
                1.0
            };
            let visible_items = ((item_count as f32) * visible_ratio).ceil() as usize;

            // Note: list state updates and scroll_to_selected_if_needed already done above
            // before the theme borrow section

            // Create scrollbar using pre-computed scrollbar_colors and scroll_offset
            let scrollbar =
                Scrollbar::new(item_count, visible_items, scroll_offset, scrollbar_colors)
                    .container_height(estimated_container_height)
                    .visible(self.is_scrolling);

            // Capture entity handle for use in the render closure
            let entity = cx.entity();

            // theme_colors was pre-computed above to avoid borrow conflicts
            let current_design = self.current_design;

            let variable_height_list =
                list(self.main_list_state.clone(), move |ix, _window, cx| {
                    // Access entity state inside the closure
                    entity.update(cx, |this, cx| {
                        let current_selected = this.selected_index;
                        let current_hovered = this.hovered_index;

                        if let Some(grouped_item) = grouped_items_clone.get(ix) {
                            match grouped_item {
                                GroupedListItem::SectionHeader(label) => {
                                    // Section header at 24px height (SECTION_HEADER_HEIGHT)
                                    div()
                                        .id(ElementId::NamedInteger(
                                            "section-header".into(),
                                            ix as u64,
                                        ))
                                        .h(px(SECTION_HEADER_HEIGHT))
                                        .child(render_section_header(label, theme_colors))
                                        .into_any_element()
                                }
                                GroupedListItem::Item(result_idx) => {
                                    // Regular item at 48px height (LIST_ITEM_HEIGHT)
                                    if let Some(result) = flat_results_clone.get(*result_idx) {
                                        let is_selected = ix == current_selected;
                                        let is_hovered = current_hovered == Some(ix);

                                        // Create hover handler
                                        let hover_handler = cx.listener(
                                            move |this: &mut ScriptListApp,
                                                  hovered: &bool,
                                                  _window,
                                                  cx| {
                                                let now = std::time::Instant::now();
                                                const HOVER_DEBOUNCE_MS: u64 = 16;

                                                if *hovered {
                                                    // Mouse entered - set hovered_index with debounce
                                                    if this.hovered_index != Some(ix)
                                                        && now
                                                            .duration_since(this.last_hover_notify)
                                                            .as_millis()
                                                            >= HOVER_DEBOUNCE_MS as u128
                                                    {
                                                        this.hovered_index = Some(ix);
                                                        this.last_hover_notify = now;
                                                        cx.notify();
                                                    }
                                                } else if this.hovered_index == Some(ix) {
                                                    // Mouse left - clear hovered_index if it was this item
                                                    this.hovered_index = None;
                                                    this.last_hover_notify = now;
                                                    cx.notify();
                                                }
                                            },
                                        );

                                        // Create click handler with double-click support
                                        let click_handler = cx.listener(
                                            move |this: &mut ScriptListApp,
                                                  event: &gpui::ClickEvent,
                                                  _window,
                                                  cx| {
                                                // Always select the item on any click
                                                if this.selected_index != ix {
                                                    this.selected_index = ix;
                                                    cx.notify();
                                                }

                                                // Check for double-click (mouse clicks only)
                                                if let gpui::ClickEvent::Mouse(mouse_event) = event
                                                {
                                                    if mouse_event.down.click_count == 2 {
                                                        logging::log(
                                                            "UI",
                                                            &format!(
                                                                "Double-click on item {}, executing",
                                                                ix
                                                            ),
                                                        );
                                                        this.execute_selected(cx);
                                                    }
                                                }
                                            },
                                        );

                                        // Check if this item requires confirmation and is pending
                                        let pending_id = this.pending_confirmation.clone();
                                        let is_pending_confirmation = match result {
                                            scripts::SearchResult::BuiltIn(bm) => {
                                                pending_id.as_ref() == Some(&bm.entry.id)
                                            }
                                            _ => false,
                                        };

                                        // Dispatch to design-specific item renderer
                                        let item_element = render_design_item(
                                            current_design,
                                            result,
                                            ix,
                                            is_selected,
                                            is_hovered,
                                            theme_colors,
                                        );

                                        // Wrap with confirmation overlay if pending
                                        let final_element = if is_pending_confirmation && is_selected {
                                            // Create confirmation overlay
                                            let warning_bg = rgb(0xB85C00); // Orange/warning background
                                            let confirm_name = match result {
                                                scripts::SearchResult::BuiltIn(bm) => {
                                                    format!("⚠️ Confirm {}? (Enter)", bm.entry.name)
                                                }
                                                _ => "⚠️ Confirm? (Enter)".to_string(),
                                            };

                                            div()
                                                .w_full()
                                                .h(px(LIST_ITEM_HEIGHT))
                                                .flex()
                                                .items_center()
                                                .px(px(16.))
                                                .bg(warning_bg)
                                                .rounded_md()
                                                .child(
                                                    div()
                                                        .text_color(gpui::white())
                                                        .font_weight(gpui::FontWeight::SEMIBOLD)
                                                        .text_size(px(14.))
                                                        .child(confirm_name)
                                                )
                                                .into_any_element()
                                        } else {
                                            item_element
                                        };

                                        div()
                                            .id(ElementId::NamedInteger(
                                                "script-item".into(),
                                                ix as u64,
                                            ))
                                            .h(px(LIST_ITEM_HEIGHT)) // Explicit 48px height
                                            .on_hover(hover_handler)
                                            .on_click(click_handler)
                                            .child(final_element)
                                            .into_any_element()
                                    } else {
                                        // Fallback for missing result
                                        div().h(px(LIST_ITEM_HEIGHT)).into_any_element()
                                    }
                                }
                            }
                        } else {
                            // Fallback for out-of-bounds index
                            div().h(px(LIST_ITEM_HEIGHT)).into_any_element()
                        }
                    })
                })
                // Enable proper scroll handling for mouse wheel/trackpad
                // ListSizingBehavior::Infer sets overflow.y = Overflow::Scroll internally
                // which is required for the list's hitbox to capture scroll wheel events
                .with_sizing_behavior(ListSizingBehavior::Infer)
                .h_full();

            // Wrap list in a relative container with scrollbar overlay
            // CUSTOM SCROLL HANDLER: GPUI's list() component has issues measuring unmeasured items
            // (they appear as 0px height). This causes mouse scroll to fail to reach all items.
            // Solution: Intercept scroll wheel events and convert to index-based scrolling,
            // which works correctly like keyboard navigation does.
            //
            // Average item height for delta-to-index conversion:
            // Most items are LIST_ITEM_HEIGHT (48px), headers are SECTION_HEADER_HEIGHT (24px)
            // Use 44px as a reasonable average that feels natural for scrolling
            let avg_item_height = 44.0_f32;

            // Capture item count for scroll handler logging
            let scroll_item_count = item_count;

            div()
                .relative()
                .flex()
                .flex_col()
                .flex_1()
                .w_full()
                .h_full()
                .on_scroll_wheel(cx.listener(
                    move |this, event: &gpui::ScrollWheelEvent, _window, cx| {
                        // Convert scroll delta to lines/items
                        // Lines: direct item count, Pixels: convert based on average item height
                        let delta_lines: f32 = match event.delta {
                            gpui::ScrollDelta::Lines(point) => point.y,
                            gpui::ScrollDelta::Pixels(point) => {
                                // Convert pixels to items using average item height
                                let pixels: f32 = point.y.into();
                                pixels / avg_item_height
                            }
                        };

                        // Accumulate smoothly for high-resolution trackpads
                        // Invert so scroll down (negative delta) moves selection down (positive)
                        this.wheel_accum += -delta_lines;

                        // Only apply integer steps when magnitude crosses 1.0
                        // This preserves smooth scrolling feel on trackpads
                        let steps = this.wheel_accum.trunc() as i32;
                        if steps != 0 {
                            // Subtract the applied steps from accumulator
                            this.wheel_accum -= steps as f32;

                            // Use the existing move_selection_by which handles section headers
                            // and properly updates scroll via scroll_to_selected_if_needed
                            this.move_selection_by(steps, cx);

                            // Log for observability
                            tracing::trace!(
                                delta = steps,
                                accum = this.wheel_accum,
                                new_index = this.selected_index,
                                total_items = scroll_item_count,
                                "Mouse wheel scroll - accumulated"
                            );
                        }
                    },
                ))
                .child(variable_height_list)
                .child(scrollbar)
                .into_any_element()
        };

        // Log panel - uses pre-extracted theme values to avoid borrow conflicts
        let log_panel = if self.show_logs {
            let logs = logging::get_last_logs(10);
            let mut log_container = div()
                .flex()
                .flex_col()
                .w_full()
                .bg(rgb(log_panel_bg))
                .border_t_1()
                .border_color(rgb(log_panel_border))
                .p(px(design_spacing.padding_md))
                .max_h(px(120.))
                .font_family("SF Mono");

            for log_line in logs.iter().rev() {
                log_container = log_container.child(
                    div()
                        .text_color(rgb(log_panel_success))
                        .text_xs()
                        .child(log_line.clone()),
                );
            }
            Some(log_container)
        } else {
            None
        };

        let handle_key = cx.listener(
            move |this: &mut Self,
                  event: &gpui::KeyDownEvent,
                  window: &mut Window,
                  cx: &mut Context<Self>| {
                // If the shortcut recorder is active, don't process any key events.
                // The recorder has its own key handlers and should receive all key events.
                if this.shortcut_recorder_state.is_some() {
                    return;
                }

                // Global shortcuts (Cmd+W only - ScriptList has special ESC handling below)
                if this.handle_global_shortcut_with_options(event, false, cx) {
                    return;
                }

                let key_str = event.keystroke.key.to_lowercase();
                let has_cmd = event.keystroke.modifiers.platform;

                // Check SDK action shortcuts FIRST (before built-in shortcuts)
                // This allows scripts to override default shortcuts via setActions()
                if !this.action_shortcuts.is_empty() {
                    let key_combo =
                        shortcuts::keystroke_to_shortcut(&key_str, &event.keystroke.modifiers);
                    if let Some(action_name) = this.action_shortcuts.get(&key_combo).cloned() {
                        logging::log(
                            "ACTIONS",
                            &format!(
                                "SDK action shortcut matched: '{}' -> '{}'",
                                key_combo, action_name
                            ),
                        );
                        if this.trigger_action_by_name(&action_name, cx) {
                            return;
                        }
                    }
                }

                if has_cmd {
                    let has_shift = event.keystroke.modifiers.shift;

                    match key_str.as_str() {
                        "l" => {
                            this.toggle_logs(cx);
                            return;
                        }
                        "k" => {
                            this.toggle_actions(cx, window);
                            return;
                        }
                        // Cmd+1 cycles through all designs
                        "1" => {
                            this.cycle_design(cx);
                            return;
                        }
                        // Script context shortcuts (require a selected script)
                        "e" => {
                            // Cmd+E - Edit Script
                            this.handle_action("edit_script".to_string(), cx);
                            return;
                        }
                        "f" if has_shift => {
                            // Cmd+Shift+F - Reveal in Finder
                            this.handle_action("reveal_in_finder".to_string(), cx);
                            return;
                        }
                        "c" if has_shift => {
                            // Cmd+Shift+C - Copy Path
                            this.handle_action("copy_path".to_string(), cx);
                            return;
                        }
                        // Global shortcuts
                        "n" => {
                            // Cmd+N - Create Script
                            this.handle_action("create_script".to_string(), cx);
                            return;
                        }
                        "r" => {
                            // Cmd+R - Reload Scripts
                            this.handle_action("reload_scripts".to_string(), cx);
                            return;
                        }
                        "," => {
                            // Cmd+, - Settings
                            this.handle_action("settings".to_string(), cx);
                            return;
                        }
                        "q" => {
                            // Cmd+Q - Quit
                            this.handle_action("quit".to_string(), cx);
                            return;
                        }
                        _ => {}
                    }
                }

                // If actions popup is open, route keyboard events to it
                if this.show_actions_popup {
                    if let Some(ref dialog) = this.actions_dialog {
                        match key_str.as_str() {
                            "up" | "arrowup" => {
                                dialog.update(cx, |d, cx| d.move_up(cx));
                                // Notify actions window to re-render
                                cx.spawn(async move |_this, cx| {
                                    cx.update(notify_actions_window).ok();
                                })
                                .detach();
                                return;
                            }
                            "down" | "arrowdown" => {
                                dialog.update(cx, |d, cx| d.move_down(cx));
                                // Notify actions window to re-render
                                cx.spawn(async move |_this, cx| {
                                    cx.update(notify_actions_window).ok();
                                })
                                .detach();
                                return;
                            }
                            "enter" => {
                                // Get the selected action and execute it
                                let action_id = dialog.read(cx).get_selected_action_id();
                                let should_close = dialog.read(cx).selected_action_should_close();
                                if let Some(action_id) = action_id {
                                    logging::log(
                                        "ACTIONS",
                                        &format!(
                                            "Executing action: {} (close={})",
                                            action_id, should_close
                                        ),
                                    );
                                    // Only close if action has close: true (default)
                                    if should_close {
                                        this.show_actions_popup = false;
                                        this.actions_dialog = None;
                                        // Close the actions window
                                        cx.spawn(async move |_this, cx| {
                                            cx.update(close_actions_window).ok();
                                        })
                                        .detach();
                                        this.focus_main_filter(window, cx);
                                    }
                                    this.handle_action(action_id, cx);
                                }
                                // Notify to update UI state after closing popup
                                cx.notify();
                                return;
                            }
                            "escape" => {
                                this.show_actions_popup = false;
                                this.actions_dialog = None;
                                // Close the actions window
                                cx.spawn(async move |_this, cx| {
                                    cx.update(close_actions_window).ok();
                                })
                                .detach();
                                this.focus_main_filter(window, cx);
                                cx.notify();
                                return;
                            }
                            "backspace" => {
                                dialog.update(cx, |d, cx| d.handle_backspace(cx));
                                // Resize and notify actions window to re-render
                                let dialog_for_resize = dialog.clone();
                                cx.spawn(async move |_this, cx| {
                                    cx.update(|cx| {
                                        resize_actions_window(cx, &dialog_for_resize);
                                    })
                                    .ok();
                                })
                                .detach();
                                return;
                            }
                            _ => {
                                // Route character input to the dialog for search
                                if let Some(ref key_char) = event.keystroke.key_char {
                                    if let Some(ch) = key_char.chars().next() {
                                        if !ch.is_control() {
                                            dialog.update(cx, |d, cx| d.handle_char(ch, cx));
                                            // Resize and notify actions window to re-render
                                            let dialog_for_resize = dialog.clone();
                                            cx.spawn(async move |_this, cx| {
                                                cx.update(|cx| {
                                                    resize_actions_window(cx, &dialog_for_resize);
                                                })
                                                .ok();
                                            })
                                            .detach();
                                        }
                                    }
                                }
                                return;
                            }
                        }
                    }
                }

                // LEGACY: Check if we're in fallback mode (no script matches, showing fallback commands)
                // Note: This is legacy code that handled a separate fallback rendering path.
                // Now fallbacks flow through GroupedListItem from grouping.rs, so this
                // branch should rarely (if ever) be triggered. The normal navigation below
                // handles fallback items in the unified list.
                if this.fallback_mode && !this.cached_fallbacks.is_empty() {
                    match key_str.as_str() {
                        "up" | "arrowup" => {
                            if this.fallback_selected_index > 0 {
                                this.fallback_selected_index -= 1;
                                cx.notify();
                            }
                        }
                        "down" | "arrowdown" => {
                            if this.fallback_selected_index
                                < this.cached_fallbacks.len().saturating_sub(1)
                            {
                                this.fallback_selected_index += 1;
                                cx.notify();
                            }
                        }
                        "enter" => {
                            if !this.gpui_input_focused {
                                this.execute_selected_fallback(cx);
                            }
                        }
                        "escape" => {
                            // Clear filter to exit fallback mode
                            this.clear_filter(window, cx);
                        }
                        _ => {}
                    }
                    return;
                }

                // Normal script list navigation
                match key_str.as_str() {
                    "up" | "arrowup" => {
                        // Input history navigation: Up arrow when filter is empty
                        if this.filter_text.is_empty() {
                            if let Some(text) = this.input_history.navigate_up() {
                                tracing::debug!(entry = %text, "Input history: navigate up");
                                this.filter_text = text.clone();
                                let text_for_input = text.clone();
                                this.gpui_input_state.update(cx, |state, input_cx| {
                                    state.set_value(text_for_input, window, input_cx);
                                });
                                // Reset selection since results will change
                                this.selected_index = 0;
                                this.last_scrolled_index = None;
                                this.invalidate_grouped_cache();
                                cx.notify();
                                return;
                            }
                        }
                        let _key_perf = crate::perf::KeyEventPerfGuard::new();
                        match this.nav_coalescer.record(NavDirection::Up) {
                            NavRecord::ApplyImmediate => this.move_selection_up(cx),
                            NavRecord::Coalesced => {}
                            NavRecord::FlushOld { dir, delta } => {
                                if delta != 0 {
                                    this.apply_nav_delta(dir, delta, cx);
                                }
                                this.move_selection_up(cx);
                            }
                        }
                        this.ensure_nav_flush_task(cx);
                    }
                    "down" | "arrowdown" => {
                        // Input history navigation: Down arrow when navigating history
                        if this.input_history.current_index().is_some() {
                            if let Some(text) = this.input_history.navigate_down() {
                                tracing::debug!(entry = %text, "Input history: navigate down");
                                this.filter_text = text.clone();
                                let text_for_input = text.clone();
                                this.gpui_input_state.update(cx, |state, input_cx| {
                                    state.set_value(text_for_input, window, input_cx);
                                });
                                // Reset selection since results will change
                                this.selected_index = 0;
                                this.last_scrolled_index = None;
                                this.invalidate_grouped_cache();
                                cx.notify();
                                return;
                            } else {
                                // Went past newest entry - clear input and reset to empty state
                                tracing::debug!("Input history: past newest, clearing input");
                                this.input_history.reset_navigation();
                                this.filter_text.clear();
                                this.gpui_input_state.update(cx, |state, input_cx| {
                                    state.set_value(String::new(), window, input_cx);
                                });
                                // Reset selection since results will change
                                this.selected_index = 0;
                                this.last_scrolled_index = None;
                                this.invalidate_grouped_cache();
                                cx.notify();
                                return;
                            }
                        }
                        let _key_perf = crate::perf::KeyEventPerfGuard::new();
                        match this.nav_coalescer.record(NavDirection::Down) {
                            NavRecord::ApplyImmediate => this.move_selection_down(cx),
                            NavRecord::Coalesced => {}
                            NavRecord::FlushOld { dir, delta } => {
                                if delta != 0 {
                                    this.apply_nav_delta(dir, delta, cx);
                                }
                                this.move_selection_down(cx);
                            }
                        }
                        this.ensure_nav_flush_task(cx);
                    }
                    "enter" => {
                        if !this.gpui_input_focused {
                            this.execute_selected(cx);
                        }
                    }
                    "escape" => {
                        // First check if we have a pending confirmation to clear
                        if this.pending_confirmation.is_some() {
                            logging::log("KEY", "ESC - clearing pending confirmation");
                            this.pending_confirmation = None;
                            cx.notify();
                        } else if !this.filter_text.is_empty() {
                            // Clear filter first if there's text
                            this.clear_filter(window, cx);
                        } else {
                            // Filter is empty - close window
                            this.close_and_reset_window(cx);
                        }
                    }
                    // Tab key: Send query to AI chat if filter has text
                    // Note: This is a fallback - primary Tab handling is in app_impl.rs via intercept_keystrokes
                    "tab" | "Tab" => {
                        if !this.filter_text.is_empty() {
                            let query = this.filter_text.clone();

                            // Open AI window first
                            if let Err(e) = ai::open_ai_window(cx) {
                                logging::log("ERROR", &format!("Failed to open AI window: {}", e));
                            } else {
                                // Set input and submit to AI
                                ai::set_ai_input(cx, &query, true);
                            }

                            // Clear filter and close main window
                            this.clear_filter(window, cx);
                            this.close_and_reset_window(cx);
                        }
                    }
                    _ => {}
                }
            },
        );

        // Main container with system font and transparency
        // Use theme opacity settings for background transparency
        let opacity = self.theme.get_opacity();

        // Use design tokens for background color (or theme for Default design)
        let bg_hex = if is_default_design {
            theme.colors.background.main
        } else {
            design_colors.background
        };

        // Create box shadows from theme
        let box_shadows = self.create_box_shadows();

        // Use design tokens for border radius
        let border_radius = if is_default_design {
            12.0 // Default radius
        } else {
            design_visual.radius_lg
        };

        // Use design tokens for text color
        let text_primary = if is_default_design {
            theme.colors.text.primary
        } else {
            design_colors.text_primary
        };

        // Use design tokens for font family
        let font_family = if is_default_design {
            ".AppleSystemUIFont"
        } else {
            design_typography.font_family
        };

        // Extract footer colors BEFORE render_preview_panel (borrow checker)
        let footer_accent = if is_default_design {
            theme.colors.accent.selected
        } else {
            design_colors.accent
        };
        let footer_text_muted = if is_default_design {
            theme.colors.text.muted
        } else {
            design_colors.text_muted
        };
        let footer_border = if is_default_design {
            theme.colors.ui.border
        } else {
            design_colors.border
        };
        let footer_background = if is_default_design {
            theme.colors.accent.selected_subtle // Match selected item bg
        } else {
            design_colors.background_selected
        };

        // VIBRANCY: Remove background from content div - let gpui-component Root's
        // semi-transparent background handle vibrancy effect. Content areas should NOT
        // have their own backgrounds to allow blur to show through.
        let _bg_with_alpha = crate::ui_foundation::hex_to_rgba_with_opacity(bg_hex, opacity.main);

        let mut main_div = div()
            .flex()
            .flex_col()
            // Removed: .bg(rgba(bg_with_alpha)) - let vibrancy show through from Root
            .shadow(box_shadows)
            .w_full()
            .h_full()
            .rounded(px(border_radius))
            .text_color(rgb(text_primary))
            .font_family(font_family)
            .key_context("script_list")
            .track_focus(&self.focus_handle)
            .on_key_down(handle_key)
            // Header: Search Input + Run + Actions + Logo
            // Use shared header layout constants for consistency with all prompts
            .child({
                // Use shared header constants for default design, design tokens for others
                let header_padding_x = if is_default_design {
                    HEADER_PADDING_X
                } else {
                    design_spacing.padding_lg
                };
                let header_padding_y = if is_default_design {
                    HEADER_PADDING_Y
                } else {
                    design_spacing.padding_sm
                };
                let header_gap = if is_default_design {
                    HEADER_GAP
                } else {
                    design_spacing.gap_md
                };
                let text_muted = if is_default_design {
                    theme.colors.text.muted
                } else {
                    design_colors.text_muted
                };
                let _text_dimmed = if is_default_design {
                    theme.colors.text.dimmed
                } else {
                    design_colors.text_dimmed
                };
                let accent_color = if is_default_design {
                    theme.colors.accent.selected
                } else {
                    design_colors.accent
                };
                let search_box_bg = if is_default_design {
                    theme.colors.background.search_box
                } else {
                    design_colors.background_secondary
                };
                let input_height = CURSOR_HEIGHT_LG + (CURSOR_MARGIN_Y * 2.0);

                div()
                    .w_full()
                    .px(px(header_padding_x))
                    .py(px(header_padding_y))
                    .flex()
                    .flex_row()
                    .items_center()
                    .gap(px(header_gap))
                    // Search input with cursor and selection support
                    .child(
                        div().flex_1().flex().flex_row().items_center().child(
                            Input::new(&self.gpui_input_state)
                                .w_full()
                                .h(px(input_height))
                                .px(px(0.))
                                .py(px(0.))
                                .with_size(Size::Size(px(design_typography.font_size_xl)))
                                .appearance(false)
                                .bordered(false)
                                .focus_bordered(false),
                        ),
                    )
                    // "Ask AI [Tab]" button - yellow text, grey badge, hover state
                    .child({
                        // Hover background: accent color at 15% opacity
                        let hover_bg = (accent_color << 8) | 0x26;
                        let tab_bg = (search_box_bg << 8) | 0x4D; // 30% opacity
                        div()
                            .id("ask-ai-button")
                            .flex()
                            .flex_row()
                            .items_center()
                            .gap(px(6.))
                            .px(px(6.))
                            .py(px(4.))
                            .rounded(px(4.))
                            .cursor_pointer()
                            .hover(move |s| s.bg(rgba(hover_bg)))
                            // "Ask AI" text - YELLOW (accent)
                            .child(
                                div()
                                    .text_sm()
                                    .text_color(rgb(accent_color))
                                    .child("Ask AI"),
                            )
                            // "Tab" badge - grey background at 30% opacity (no border)
                            .child(
                                div()
                                    .px(px(6.))
                                    .py(px(2.))
                                    .rounded(px(4.))
                                    .bg(rgba(tab_bg))
                                    .text_xs()
                                    .text_color(rgb(text_muted))
                                    .child("Tab"),
                            )
                    })
            })
            // Subtle divider - semi-transparent
            // Use design tokens for border color and spacing
            .child({
                let divider_margin = if is_default_design {
                    16.0
                } else {
                    design_spacing.margin_lg
                };
                let border_color = if is_default_design {
                    theme.colors.ui.border
                } else {
                    design_colors.border
                };
                let border_width = if is_default_design {
                    1.0
                } else {
                    design_visual.border_thin
                };

                div()
                    .mx(px(divider_margin))
                    .h(px(border_width))
                    .bg(rgba((border_color << 8) | 0x60))
            });

        // Main content area - 50/50 split: List on left, Preview on right
        main_div = main_div
            // Uses min_h(px(0.)) to prevent flex children from overflowing
            .child(
                div()
                    .flex()
                    .flex_row()
                    .flex_1()
                    .min_h(px(0.)) // Critical: allows flex container to shrink properly
                    .w_full()
                    .overflow_hidden()
                    // Left side: Script list (50% width) - uses uniform_list for auto-scrolling
                    .child(
                        div()
                            .w_1_2() // 50% width
                            .h_full() // Take full height
                            .min_h(px(0.)) // Allow shrinking
                            .child(list_element),
                    )
                    // Right side: Preview panel (50% width) with actions overlay
                    // Preview ALWAYS renders, actions panel overlays on top when visible
                    .child(
                        div()
                            .relative() // Enable absolute positioning for overlay
                            .w_1_2() // 50% width
                            .h_full() // Take full height
                            .min_h(px(0.)) // Allow shrinking
                            .overflow_hidden()
                            // Preview panel ALWAYS renders
                            // NOTE: Actions dialog is now rendered in a separate popup window
                            // (see actions/window.rs) - no inline overlay needed here
                            .child(self.render_preview_panel(cx)),
                    ),
            );

        // Footer: Logo left | Run Script ↵ | divider | Actions ⌘K right
        // Raycast-style footer with Script Kit branding using reusable PromptFooter component
        // Note: footer colors extracted earlier to avoid borrow conflict with render_preview_panel
        main_div = main_div.child({
            let handle_run = cx.entity().downgrade();
            let handle_actions = cx.entity().downgrade();

            let footer_colors = PromptFooterColors {
                accent: footer_accent,
                text_muted: footer_text_muted,
                border: footer_border,
                background: footer_background,
            };

            // Get the primary action label from the selected item
            // Falls back to "Run" if no item selected or not a regular item
            let primary_label = grouped_items
                .get(self.selected_index)
                .and_then(|item| match item {
                    GroupedListItem::Item(idx) => flat_results.get(*idx),
                    GroupedListItem::SectionHeader(_) => None,
                })
                .map(|result| result.get_default_action_text())
                .unwrap_or("Run");

            PromptFooter::new(
                PromptFooterConfig::default().primary_label(primary_label),
                footer_colors,
            )
            .on_primary_click(Box::new(move |_, _window, cx| {
                if let Some(app) = handle_run.upgrade() {
                    app.update(cx, |this, cx| {
                        this.execute_selected(cx);
                    });
                }
            }))
            .on_secondary_click(Box::new(move |_, window, cx| {
                if let Some(app) = handle_actions.upgrade() {
                    app.update(cx, |this, cx| {
                        this.toggle_actions(cx, window);
                    });
                }
            }))
        });

        if let Some(panel) = log_panel {
            main_div = main_div.child(panel);
        }

        // Note: Toast notifications are now handled by gpui-component's NotificationList
        // via the Root wrapper. Toasts are flushed in render() via flush_pending_toasts().

        // Note: HUD overlay is added at the top-level render() method for all views

        main_div.into_any_element()
    }
}

</file>

<file path="src/app_render.rs">
impl ScriptListApp {
    /// Read the first N lines of a script file for preview
    #[allow(dead_code)]
    fn read_script_preview(path: &std::path::Path, max_lines: usize) -> String {
        match std::fs::read_to_string(path) {
            Ok(content) => {
                let preview: String = content
                    .lines()
                    .take(max_lines)
                    .collect::<Vec<_>>()
                    .join("\n");
                logging::log(
                    "UI",
                    &format!(
                        "Preview loaded: {} ({} lines read)",
                        path.file_name().unwrap_or_default().to_string_lossy(),
                        content.lines().count().min(max_lines)
                    ),
                );
                preview
            }
            Err(e) => {
                logging::log("UI", &format!("Preview error: {} - {}", path.display(), e));
                format!("Error reading file: {}", e)
            }
        }
    }

    // NOTE: render_toasts() removed - now using gpui-component's NotificationList
    // via the Root wrapper. Toasts are flushed via flush_pending_toasts() in render().
    // See toast_manager.rs for the queue and main.rs for the flush logic.

    /// Get the command ID for a search result, used for config lookups (shortcuts, etc.)
    fn get_command_id_for_result(result: &scripts::SearchResult) -> Option<String> {
        match result {
            scripts::SearchResult::Script(m) => {
                // Script command ID: "script/{name}" (without extension)
                Some(format!("script/{}", m.script.name))
            }
            scripts::SearchResult::Scriptlet(m) => {
                // Scriptlet command ID: "scriptlet/{name}"
                Some(format!("scriptlet/{}", m.scriptlet.name))
            }
            scripts::SearchResult::BuiltIn(m) => {
                // Built-in command ID: "builtin/{id}"
                Some(format!("builtin/{}", m.entry.id))
            }
            scripts::SearchResult::App(m) => {
                // App command ID: "app/{bundle_id}" or "app/{name}"
                if let Some(ref bundle_id) = m.app.bundle_id {
                    Some(format!("app/{}", bundle_id))
                } else {
                    Some(format!(
                        "app/{}",
                        m.app.name.to_lowercase().replace(' ', "-")
                    ))
                }
            }
            // Window, Agent, and Fallback don't support shortcuts
            _ => None,
        }
    }

    /// Render the preview panel showing details of the selected script/scriptlet
    fn render_preview_panel(&mut self, _cx: &mut Context<Self>) -> impl IntoElement {
        // Get grouped results to map from selected_index to actual result (cached)
        // Clone to avoid borrow issues with self.selected_index access
        let selected_index = self.selected_index;
        let (grouped_items, flat_results) = self.get_grouped_results_cached();
        let grouped_items = grouped_items.clone();
        let flat_results = flat_results.clone();

        // Get the result index from the grouped item
        let selected_result = match grouped_items.get(selected_index) {
            Some(GroupedListItem::Item(idx)) => flat_results.get(*idx).cloned(),
            _ => None,
        };

        // Use design tokens for GLOBAL theming - design applies to ALL components
        let tokens = get_tokens(self.current_design);
        let colors = tokens.colors();
        let spacing = tokens.spacing();
        let typography = tokens.typography();
        let visual = tokens.visual();

        // Map design tokens to local variables (all designs use tokens now)
        let bg_main = colors.background;
        let ui_border = colors.border;
        let text_primary = colors.text_primary;
        let text_muted = colors.text_muted;
        let text_secondary = colors.text_secondary;
        let bg_search_box = colors.background_tertiary;
        let border_radius = visual.radius_md;
        let font_family = typography.font_family;

        // Get shortcut display string for the selected item (if any)
        // Check BOTH config.ts commands AND shortcut overrides file
        let shortcut_display: Option<String> = selected_result.as_ref().and_then(|result| {
            Self::get_command_id_for_result(result).and_then(|command_id| {
                // First check config.ts commands
                if let Some(hotkey) = self.config.get_command_shortcut(&command_id) {
                    return Some(hotkey.to_display_string());
                }
                // Then check shortcut overrides file (where ShortcutRecorder saves)
                if let Ok(overrides) = crate::shortcuts::load_shortcut_overrides() {
                    if let Some(shortcut) = overrides.get(&command_id) {
                        return Some(shortcut.to_string());
                    }
                }
                None
            })
        });

        // Get opacity for vibrancy support from theme
        let opacity = self.theme.get_opacity();

        // Preview panel container with left border separator
        // Uses theme.opacity.preview to control background opacity (default 0 = transparent)
        let preview_alpha = (opacity.preview * 255.0) as u32;
        let mut panel = div()
            .w_full()
            .h_full()
            .when(preview_alpha > 0, |d| {
                d.bg(rgba((bg_main << 8) | preview_alpha))
            })
            .border_l_1()
            .border_color(rgba((ui_border << 8) | 0x80))
            .p(px(spacing.padding_lg))
            .flex()
            .flex_col()
            .overflow_y_hidden()
            .font_family(font_family);

        // P4: Compute match indices lazily for visible preview (only one result at a time)
        let computed_filter = self.computed_filter_text.clone();

        match selected_result {
            Some(ref result) => {
                // P4: Lazy match indices computation for preview panel
                let match_indices =
                    scripts::compute_match_indices_for_result(result, &computed_filter);

                match result {
                    scripts::SearchResult::Script(script_match) => {
                        let script = &script_match.script;

                        // Source indicator with match highlighting (e.g., "script: foo.ts")
                        let filename = &script_match.filename;
                        // P4: Use lazily computed indices instead of stored (empty) ones
                        let filename_indices = &match_indices.filename_indices;

                        // Render filename with highlighted matched characters
                        let path_segments =
                            render_path_with_highlights(filename, filename, filename_indices);
                        let accent_color = colors.accent;

                        let mut path_div = div()
                            .flex()
                            .flex_row()
                            .text_xs()
                            .font_family(typography.font_family_mono)
                            .pb(px(spacing.padding_xs))
                            .overflow_x_hidden()
                            .child(
                                div()
                                    .text_color(rgba((text_muted << 8) | 0x99))
                                    .child("script: "),
                            );

                        for (text, is_highlighted) in path_segments {
                            let color = if is_highlighted {
                                rgb(accent_color)
                            } else {
                                rgba((text_muted << 8) | 0x99)
                            };
                            path_div = path_div.child(div().text_color(color).child(text));
                        }

                        panel = panel.child(path_div);

                        // Script name header
                        panel = panel.child(
                            div()
                                .text_lg()
                                .font_weight(gpui::FontWeight::SEMIBOLD)
                                .text_color(rgb(text_primary))
                                .pb(px(spacing.padding_sm))
                                .child(format!("{}.{}", script.name, script.extension)),
                        );

                        // Keyboard shortcut: prefer script metadata shortcut, fall back to config-based
                        let effective_shortcut =
                            script.shortcut.clone().or_else(|| shortcut_display.clone());
                        if let Some(shortcut_str) = effective_shortcut {
                            panel = panel.child(
                                div()
                                    .flex()
                                    .flex_col()
                                    .pb(px(spacing.padding_md))
                                    .child(
                                        div()
                                            .text_xs()
                                            .text_color(rgb(text_muted))
                                            .pb(px(spacing.padding_xs / 2.0))
                                            .child("Keyboard Shortcut"),
                                    )
                                    .child(
                                        div()
                                            .flex()
                                            .flex_row()
                                            .items_center()
                                            .gap(px(spacing.gap_sm))
                                            .child(
                                                div()
                                                    .text_sm()
                                                    .font_weight(gpui::FontWeight::MEDIUM)
                                                    .text_color(rgb(colors.accent))
                                                    .child(shortcut_str),
                                            ),
                                    ),
                            );
                        }

                        // Description (if present)
                        if let Some(desc) = &script.description {
                            panel = panel.child(
                                div()
                                    .flex()
                                    .flex_col()
                                    .pb(px(spacing.padding_md))
                                    .child(
                                        div()
                                            .text_xs()
                                            .text_color(rgb(text_muted))
                                            .pb(px(spacing.padding_xs / 2.0))
                                            .child("Description"),
                                    )
                                    .child(
                                        div()
                                            .text_sm()
                                            .text_color(rgb(text_secondary))
                                            .child(desc.clone()),
                                    ),
                            );
                        }

                        // Divider
                        panel = panel.child(
                            div()
                                .w_full()
                                .h(px(visual.border_thin))
                                .bg(rgba((ui_border << 8) | 0x60))
                                .my(px(spacing.padding_sm)),
                        );

                        // Code preview header
                        panel = panel.child(
                            div()
                                .text_xs()
                                .text_color(rgb(text_muted))
                                .pb(px(spacing.padding_sm))
                                .child("Code Preview"),
                        );

                        // Use cached syntax-highlighted lines (avoids file I/O and highlighting on every render)
                        let script_path = script.path.to_string_lossy().to_string();
                        let lang = script.extension.clone();
                        let lines = self
                            .get_or_update_preview_cache(&script_path, &lang)
                            .to_vec();

                        // Build code container - render line by line with monospace font
                        let mut code_container = div()
                            .w_full()
                            .min_w(px(280.))
                            .p(px(spacing.padding_md))
                            .rounded(px(border_radius))
                            .bg(rgba((bg_search_box << 8) | 0x80))
                            .overflow_hidden()
                            .flex()
                            .flex_col();

                        // Render each line as a row of spans with monospace font
                        for line in lines {
                            let mut line_div = div()
                                .flex()
                                .flex_row()
                                .w_full()
                                .font_family(typography.font_family_mono)
                                .text_xs()
                                .min_h(px(spacing.padding_lg)); // Line height

                            if line.spans.is_empty() {
                                // Empty line - add a space to preserve height
                                line_div = line_div.child(" ");
                            } else {
                                for span in line.spans {
                                    line_div = line_div
                                        .child(div().text_color(rgb(span.color)).child(span.text));
                                }
                            }

                            code_container = code_container.child(line_div);
                        }

                        panel = panel.child(code_container);
                    }
                    scripts::SearchResult::Scriptlet(scriptlet_match) => {
                        let scriptlet = &scriptlet_match.scriptlet;

                        // Source indicator with match highlighting (e.g., "scriptlet: foo.md")
                        if let Some(ref display_file_path) = scriptlet_match.display_file_path {
                            // P4: Use lazily computed indices instead of stored (empty) ones
                            let filename_indices = &match_indices.filename_indices;

                            // Render filename with highlighted matched characters
                            let path_segments = render_path_with_highlights(
                                display_file_path,
                                display_file_path,
                                filename_indices,
                            );
                            let accent_color = colors.accent;

                            let mut path_div = div()
                                .flex()
                                .flex_row()
                                .text_xs()
                                .font_family(typography.font_family_mono)
                                .pb(px(spacing.padding_xs))
                                .overflow_x_hidden()
                                .child(
                                    div()
                                        .text_color(rgba((text_muted << 8) | 0x99))
                                        .child("scriptlet: "),
                                );

                            for (text, is_highlighted) in path_segments {
                                let color = if is_highlighted {
                                    rgb(accent_color)
                                } else {
                                    rgba((text_muted << 8) | 0x99)
                                };
                                path_div = path_div.child(div().text_color(color).child(text));
                            }

                            panel = panel.child(path_div);
                        }

                        // Scriptlet name header
                        panel = panel.child(
                            div()
                                .text_lg()
                                .font_weight(gpui::FontWeight::SEMIBOLD)
                                .text_color(rgb(text_primary))
                                .pb(px(spacing.padding_sm))
                                .child(scriptlet.name.clone()),
                        );

                        // Description (if present)
                        if let Some(desc) = &scriptlet.description {
                            panel = panel.child(
                                div()
                                    .flex()
                                    .flex_col()
                                    .pb(px(spacing.padding_md))
                                    .child(
                                        div()
                                            .text_xs()
                                            .text_color(rgb(text_muted))
                                            .pb(px(spacing.padding_xs / 2.0))
                                            .child("Description"),
                                    )
                                    .child(
                                        div()
                                            .text_sm()
                                            .text_color(rgb(text_secondary))
                                            .child(desc.clone()),
                                    ),
                            );
                        }

                        // Shortcut: prefer inline shortcut from scriptlet, fall back to config-based
                        let effective_shortcut = scriptlet
                            .shortcut
                            .clone()
                            .or_else(|| shortcut_display.clone());
                        if let Some(shortcut) = effective_shortcut {
                            panel = panel.child(
                                div()
                                    .flex()
                                    .flex_col()
                                    .pb(px(spacing.padding_md))
                                    .child(
                                        div()
                                            .text_xs()
                                            .text_color(rgb(text_muted))
                                            .pb(px(spacing.padding_xs / 2.0))
                                            .child("Keyboard Shortcut"),
                                    )
                                    .child(
                                        div()
                                            .flex()
                                            .flex_row()
                                            .items_center()
                                            .gap(px(spacing.gap_sm))
                                            .child(
                                                div()
                                                    .text_sm()
                                                    .font_weight(gpui::FontWeight::MEDIUM)
                                                    .text_color(rgb(colors.accent))
                                                    .child(shortcut),
                                            ),
                                    ),
                            );
                        }

                        // Divider
                        panel = panel.child(
                            div()
                                .w_full()
                                .h(px(visual.border_thin))
                                .bg(rgba((ui_border << 8) | 0x60))
                                .my(px(spacing.padding_sm)),
                        );

                        // Content preview header
                        panel = panel.child(
                            div()
                                .text_xs()
                                .text_color(rgb(text_muted))
                                .pb(px(spacing.padding_sm))
                                .child("Content Preview"),
                        );

                        // Display scriptlet code with syntax highlighting (first 15 lines)
                        // Note: Scriptlets store code in memory, no file I/O needed (no cache benefit)
                        let code_preview: String = scriptlet
                            .code
                            .lines()
                            .take(15)
                            .collect::<Vec<_>>()
                            .join("\n");

                        // Determine language from tool (bash, js, etc.)
                        let lang = match scriptlet.tool.as_str() {
                            "bash" | "zsh" | "sh" => "bash",
                            "node" | "bun" => "js",
                            _ => &scriptlet.tool,
                        };
                        let lines = highlight_code_lines(&code_preview, lang);

                        // Build code container - render line by line with monospace font
                        let mut code_container = div()
                            .w_full()
                            .min_w(px(280.))
                            .p(px(spacing.padding_md))
                            .rounded(px(border_radius))
                            .bg(rgba((bg_search_box << 8) | 0x80))
                            .overflow_hidden()
                            .flex()
                            .flex_col();

                        // Render each line as a row of spans with monospace font
                        for line in lines {
                            let mut line_div = div()
                                .flex()
                                .flex_row()
                                .w_full()
                                .font_family(typography.font_family_mono)
                                .text_xs()
                                .min_h(px(spacing.padding_lg)); // Line height

                            if line.spans.is_empty() {
                                // Empty line - add a space to preserve height
                                line_div = line_div.child(" ");
                            } else {
                                for span in line.spans {
                                    line_div = line_div
                                        .child(div().text_color(rgb(span.color)).child(span.text));
                                }
                            }

                            code_container = code_container.child(line_div);
                        }

                        panel = panel.child(code_container);
                    }
                    scripts::SearchResult::BuiltIn(builtin_match) => {
                        let builtin = &builtin_match.entry;

                        // Built-in name header
                        panel = panel.child(
                            div()
                                .text_lg()
                                .font_weight(gpui::FontWeight::SEMIBOLD)
                                .text_color(rgb(text_primary))
                                .pb(px(spacing.padding_sm))
                                .child(builtin.name.clone()),
                        );

                        // Keyboard shortcut (if assigned via config.commands)
                        if let Some(ref shortcut_str) = shortcut_display {
                            panel = panel.child(
                                div()
                                    .flex()
                                    .flex_col()
                                    .pb(px(spacing.padding_md))
                                    .child(
                                        div()
                                            .text_xs()
                                            .text_color(rgb(text_muted))
                                            .pb(px(spacing.padding_xs / 2.0))
                                            .child("Keyboard Shortcut"),
                                    )
                                    .child(
                                        div()
                                            .flex()
                                            .flex_row()
                                            .items_center()
                                            .gap(px(spacing.gap_sm))
                                            .child(
                                                div()
                                                    .text_sm()
                                                    .font_weight(gpui::FontWeight::MEDIUM)
                                                    .text_color(rgb(colors.accent))
                                                    .child(shortcut_str.clone()),
                                            ),
                                    ),
                            );
                        }

                        // Description
                        panel = panel.child(
                            div()
                                .flex()
                                .flex_col()
                                .pb(px(spacing.padding_md))
                                .child(
                                    div()
                                        .text_xs()
                                        .text_color(rgb(text_muted))
                                        .pb(px(spacing.padding_xs / 2.0))
                                        .child("Description"),
                                )
                                .child(
                                    div()
                                        .text_sm()
                                        .text_color(rgb(text_secondary))
                                        .child(builtin.description.clone()),
                                ),
                        );

                        // Keywords
                        if !builtin.keywords.is_empty() {
                            panel = panel.child(
                                div()
                                    .flex()
                                    .flex_col()
                                    .pb(px(spacing.padding_md))
                                    .child(
                                        div()
                                            .text_xs()
                                            .text_color(rgb(text_muted))
                                            .pb(px(spacing.padding_xs / 2.0))
                                            .child("Keywords"),
                                    )
                                    .child(
                                        div()
                                            .text_sm()
                                            .text_color(rgb(text_secondary))
                                            .child(builtin.keywords.join(", ")),
                                    ),
                            );
                        }

                        // Divider
                        panel = panel.child(
                            div()
                                .w_full()
                                .h(px(visual.border_thin))
                                .bg(rgba((ui_border << 8) | 0x60))
                                .my(px(spacing.padding_sm)),
                        );

                        // Feature type indicator
                        let feature_type: String = match &builtin.feature {
                            builtins::BuiltInFeature::ClipboardHistory => {
                                "Clipboard History Manager".to_string()
                            }
                            builtins::BuiltInFeature::AppLauncher => {
                                "Application Launcher".to_string()
                            }
                            builtins::BuiltInFeature::App(name) => name.clone(),
                            builtins::BuiltInFeature::WindowSwitcher => {
                                "Window Manager".to_string()
                            }
                            builtins::BuiltInFeature::DesignGallery => "Design Gallery".to_string(),
                            builtins::BuiltInFeature::AiChat => "AI Assistant".to_string(),
                            builtins::BuiltInFeature::Notes => "Notes & Scratchpad".to_string(),
                            builtins::BuiltInFeature::MenuBarAction(_) => {
                                "Menu Bar Action".to_string()
                            }
                            builtins::BuiltInFeature::SystemAction(_) => {
                                "System Action".to_string()
                            }
                            builtins::BuiltInFeature::WindowAction(_) => {
                                "Window Action".to_string()
                            }
                            builtins::BuiltInFeature::NotesCommand(_) => {
                                "Notes Command".to_string()
                            }
                            builtins::BuiltInFeature::AiCommand(_) => "AI Command".to_string(),
                            builtins::BuiltInFeature::ScriptCommand(_) => {
                                "Script Creation".to_string()
                            }
                            builtins::BuiltInFeature::PermissionCommand(_) => {
                                "Permission Management".to_string()
                            }
                            builtins::BuiltInFeature::FrecencyCommand(_) => {
                                "Suggested Items".to_string()
                            }
                            builtins::BuiltInFeature::UtilityCommand(_) => {
                                "Quick Utility".to_string()
                            }
                            builtins::BuiltInFeature::SettingsCommand(_) => "Settings".to_string(),
                            builtins::BuiltInFeature::FileSearch => "File Browser".to_string(),
                        };
                        panel = panel.child(
                            div()
                                .flex()
                                .flex_col()
                                .child(
                                    div()
                                        .text_xs()
                                        .text_color(rgb(text_muted))
                                        .pb(px(spacing.padding_xs / 2.0))
                                        .child("Feature Type"),
                                )
                                .child(
                                    div()
                                        .text_sm()
                                        .text_color(rgb(text_secondary))
                                        .child(feature_type),
                                ),
                        );
                    }
                    scripts::SearchResult::App(app_match) => {
                        let app = &app_match.app;

                        // App name header
                        panel = panel.child(
                            div()
                                .text_lg()
                                .font_weight(gpui::FontWeight::SEMIBOLD)
                                .text_color(rgb(text_primary))
                                .pb(px(spacing.padding_sm))
                                .child(app.name.clone()),
                        );

                        // Keyboard shortcut (if assigned via config.commands)
                        if let Some(ref shortcut_str) = shortcut_display {
                            panel = panel.child(
                                div()
                                    .flex()
                                    .flex_col()
                                    .pb(px(spacing.padding_md))
                                    .child(
                                        div()
                                            .text_xs()
                                            .text_color(rgb(text_muted))
                                            .pb(px(spacing.padding_xs / 2.0))
                                            .child("Keyboard Shortcut"),
                                    )
                                    .child(
                                        div()
                                            .flex()
                                            .flex_row()
                                            .items_center()
                                            .gap(px(spacing.gap_sm))
                                            .child(
                                                div()
                                                    .text_sm()
                                                    .font_weight(gpui::FontWeight::MEDIUM)
                                                    .text_color(rgb(colors.accent))
                                                    .child(shortcut_str.clone()),
                                            ),
                                    ),
                            );
                        }

                        // Path
                        panel = panel.child(
                            div()
                                .flex()
                                .flex_col()
                                .pb(px(spacing.padding_md))
                                .child(
                                    div()
                                        .text_xs()
                                        .text_color(rgb(text_muted))
                                        .pb(px(spacing.padding_xs / 2.0))
                                        .child("Path"),
                                )
                                .child(
                                    div()
                                        .text_sm()
                                        .text_color(rgb(text_secondary))
                                        .child(app.path.to_string_lossy().to_string()),
                                ),
                        );

                        // Bundle ID (if available)
                        if let Some(bundle_id) = &app.bundle_id {
                            panel = panel.child(
                                div()
                                    .flex()
                                    .flex_col()
                                    .pb(px(spacing.padding_md))
                                    .child(
                                        div()
                                            .text_xs()
                                            .text_color(rgb(text_muted))
                                            .pb(px(spacing.padding_xs / 2.0))
                                            .child("Bundle ID"),
                                    )
                                    .child(
                                        div()
                                            .text_sm()
                                            .text_color(rgb(text_secondary))
                                            .child(bundle_id.clone()),
                                    ),
                            );
                        }

                        // Divider
                        panel = panel.child(
                            div()
                                .w_full()
                                .h(px(visual.border_thin))
                                .bg(rgba((ui_border << 8) | 0x60))
                                .my(px(spacing.padding_sm)),
                        );

                        // Type indicator
                        panel = panel.child(
                            div()
                                .flex()
                                .flex_col()
                                .child(
                                    div()
                                        .text_xs()
                                        .text_color(rgb(text_muted))
                                        .pb(px(spacing.padding_xs / 2.0))
                                        .child("Type"),
                                )
                                .child(
                                    div()
                                        .text_sm()
                                        .text_color(rgb(text_secondary))
                                        .child("Application"),
                                ),
                        );
                    }
                    scripts::SearchResult::Window(window_match) => {
                        let window = &window_match.window;

                        // Window title header
                        panel = panel.child(
                            div()
                                .text_lg()
                                .font_weight(gpui::FontWeight::SEMIBOLD)
                                .text_color(rgb(text_primary))
                                .pb(px(spacing.padding_sm))
                                .child(window.title.clone()),
                        );

                        // App name
                        panel = panel.child(
                            div()
                                .flex()
                                .flex_col()
                                .pb(px(spacing.padding_md))
                                .child(
                                    div()
                                        .text_xs()
                                        .text_color(rgb(text_muted))
                                        .pb(px(spacing.padding_xs / 2.0))
                                        .child("Application"),
                                )
                                .child(
                                    div()
                                        .text_sm()
                                        .text_color(rgb(text_secondary))
                                        .child(window.app.clone()),
                                ),
                        );

                        // Bounds
                        panel = panel.child(
                            div()
                                .flex()
                                .flex_col()
                                .pb(px(spacing.padding_md))
                                .child(
                                    div()
                                        .text_xs()
                                        .text_color(rgb(text_muted))
                                        .pb(px(spacing.padding_xs / 2.0))
                                        .child("Position & Size"),
                                )
                                .child(div().text_sm().text_color(rgb(text_secondary)).child(
                                    format!(
                                        "{}×{} at ({}, {})",
                                        window.bounds.width,
                                        window.bounds.height,
                                        window.bounds.x,
                                        window.bounds.y
                                    ),
                                )),
                        );

                        // Divider
                        panel = panel.child(
                            div()
                                .w_full()
                                .h(px(visual.border_thin))
                                .bg(rgba((ui_border << 8) | 0x60))
                                .my(px(spacing.padding_sm)),
                        );

                        // Type indicator
                        panel = panel.child(
                            div()
                                .flex()
                                .flex_col()
                                .child(
                                    div()
                                        .text_xs()
                                        .text_color(rgb(text_muted))
                                        .pb(px(spacing.padding_xs / 2.0))
                                        .child("Type"),
                                )
                                .child(
                                    div()
                                        .text_sm()
                                        .text_color(rgb(text_secondary))
                                        .child("Window"),
                                ),
                        );
                    }
                    scripts::SearchResult::Agent(agent_match) => {
                        let agent = &agent_match.agent;

                        // Source indicator with agent path
                        let filename = agent
                            .path
                            .file_name()
                            .map(|s| s.to_string_lossy().to_string())
                            .unwrap_or_else(|| "agent".to_string());

                        let mut path_div = div()
                            .flex()
                            .flex_row()
                            .text_xs()
                            .font_family(typography.font_family_mono)
                            .pb(px(spacing.padding_xs))
                            .overflow_x_hidden()
                            .child(
                                div()
                                    .text_color(rgba((text_muted << 8) | 0x99))
                                    .child("agent: "),
                            );

                        path_div = path_div.child(
                            div()
                                .text_color(rgba((text_muted << 8) | 0x99))
                                .child(filename),
                        );

                        panel = panel.child(path_div);

                        // Agent name header
                        panel = panel.child(
                            div()
                                .text_lg()
                                .font_weight(gpui::FontWeight::SEMIBOLD)
                                .text_color(rgb(text_primary))
                                .pb(px(spacing.padding_sm))
                                .child(agent.name.clone()),
                        );

                        // Description
                        if let Some(desc) = &agent.description {
                            panel = panel.child(
                                div()
                                    .text_sm()
                                    .text_color(rgb(text_secondary))
                                    .pb(px(spacing.padding_md))
                                    .child(desc.clone()),
                            );
                        }

                        // Backend info
                        panel = panel.child(
                            div()
                                .flex()
                                .flex_col()
                                .pb(px(spacing.padding_md))
                                .child(
                                    div()
                                        .text_xs()
                                        .text_color(rgb(text_muted))
                                        .pb(px(spacing.padding_xs / 2.0))
                                        .child("Backend"),
                                )
                                .child(
                                    div()
                                        .text_sm()
                                        .text_color(rgb(text_secondary))
                                        .child(format!("{:?}", agent.backend)),
                                ),
                        );

                        // Kit info if available
                        if let Some(kit) = &agent.kit {
                            panel = panel.child(
                                div()
                                    .flex()
                                    .flex_col()
                                    .pb(px(spacing.padding_md))
                                    .child(
                                        div()
                                            .text_xs()
                                            .text_color(rgb(text_muted))
                                            .pb(px(spacing.padding_xs / 2.0))
                                            .child("Kit"),
                                    )
                                    .child(
                                        div()
                                            .text_sm()
                                            .text_color(rgb(text_secondary))
                                            .child(kit.clone()),
                                    ),
                            );
                        }

                        // Divider
                        panel = panel.child(
                            div()
                                .w_full()
                                .h(px(visual.border_thin))
                                .bg(rgba((ui_border << 8) | 0x60))
                                .my(px(spacing.padding_sm)),
                        );

                        // Type indicator
                        panel = panel.child(
                            div()
                                .flex()
                                .flex_col()
                                .child(
                                    div()
                                        .text_xs()
                                        .text_color(rgb(text_muted))
                                        .pb(px(spacing.padding_xs / 2.0))
                                        .child("Type"),
                                )
                                .child(
                                    div()
                                        .text_sm()
                                        .text_color(rgb(text_secondary))
                                        .child("Agent"),
                                ),
                        );
                    }

                    scripts::SearchResult::Fallback(fallback_match) => {
                        // Fallback command preview
                        let fallback = &fallback_match.fallback;

                        // Header showing "Fallback"
                        let mut path_div = div()
                            .flex()
                            .flex_row()
                            .text_xs()
                            .font_family(typography.font_family_mono)
                            .pb(px(spacing.padding_xs))
                            .overflow_x_hidden()
                            .child(
                                div()
                                    .text_color(rgba((text_muted << 8) | 0x99))
                                    .child("fallback: "),
                            );

                        path_div = path_div.child(
                            div()
                                .text_color(rgba((text_muted << 8) | 0x99))
                                .child(fallback.name().to_string()),
                        );

                        panel = panel.child(path_div);

                        // Fallback name header
                        panel = panel.child(
                            div()
                                .text_lg()
                                .font_weight(gpui::FontWeight::SEMIBOLD)
                                .text_color(rgb(text_primary))
                                .pb(px(spacing.padding_sm))
                                .child(fallback.label().to_string()),
                        );

                        // Description
                        panel = panel.child(
                            div()
                                .text_sm()
                                .text_color(rgb(text_secondary))
                                .pb(px(spacing.padding_md))
                                .child(fallback.description().to_string()),
                        );

                        // Divider
                        panel = panel.child(
                            div()
                                .w_full()
                                .h(px(visual.border_thin))
                                .bg(rgba((ui_border << 8) | 0x60))
                                .my(px(spacing.padding_sm)),
                        );

                        // Type indicator
                        panel = panel.child(
                            div()
                                .flex()
                                .flex_col()
                                .child(
                                    div()
                                        .text_xs()
                                        .text_color(rgb(text_muted))
                                        .pb(px(spacing.padding_xs / 2.0))
                                        .child("Type"),
                                )
                                .child(
                                    div()
                                        .text_sm()
                                        .text_color(rgb(text_secondary))
                                        .child("Fallback"),
                                ),
                        );
                    }
                }
            }
            None => {
                logging::log("UI", "Preview panel: No selection");
                // Empty state
                panel = panel.child(
                    div()
                        .w_full()
                        .h_full()
                        .flex()
                        .items_center()
                        .justify_center()
                        .text_color(rgb(text_muted))
                        .child(
                            if self.filter_text.is_empty()
                                && self.scripts.is_empty()
                                && self.scriptlets.is_empty()
                            {
                                "No scripts or snippets found"
                            } else if !self.filter_text.is_empty() {
                                "No matching scripts"
                            } else {
                                "Select a script to preview"
                            },
                        ),
                );
            }
        }

        panel
    }

    /// Get the ScriptInfo for the currently focused/selected script
    fn get_focused_script_info(&mut self) -> Option<ScriptInfo> {
        // Get grouped results to map from selected_index to actual result (cached)
        let (grouped_items, flat_results) = self.get_grouped_results_cached();
        // Clone to avoid borrow issues
        let grouped_items = grouped_items.clone();
        let flat_results = flat_results.clone();

        // Get the result index from the grouped item
        let result_idx = match grouped_items.get(self.selected_index) {
            Some(GroupedListItem::Item(idx)) => Some(*idx),
            _ => None,
        };

        if let Some(idx) = result_idx {
            if let Some(result) = flat_results.get(idx) {
                match result {
                    scripts::SearchResult::Script(m) => Some(ScriptInfo::with_shortcut(
                        &m.script.name,
                        m.script.path.to_string_lossy(),
                        m.script.shortcut.clone(),
                    )),
                    scripts::SearchResult::Scriptlet(m) => {
                        // Scriptlets don't have a path, use name as identifier
                        // Pass shortcut info for dynamic action menu
                        Some(ScriptInfo::with_shortcut(
                            &m.scriptlet.name,
                            format!("scriptlet:{}", &m.scriptlet.name),
                            m.scriptlet.shortcut.clone(),
                        ))
                    }
                    scripts::SearchResult::BuiltIn(m) => {
                        // Built-ins use their id as identifier
                        // is_script=false: no editable file, hide "Edit Script" etc.
                        // Look up shortcut from overrides for dynamic action menu
                        let command_id = format!("builtin/{}", &m.entry.id);
                        let shortcut = crate::shortcuts::load_shortcut_overrides()
                            .ok()
                            .and_then(|o| o.get(&command_id).map(|s| s.to_string()));
                        Some(ScriptInfo::with_action_verb_and_shortcut(
                            &m.entry.name,
                            format!("builtin:{}", &m.entry.id),
                            false,
                            "Run",
                            shortcut,
                        ))
                    }
                    scripts::SearchResult::App(m) => {
                        // Apps use their path as identifier
                        // is_script=false: apps aren't editable scripts
                        // Look up shortcut from overrides for dynamic action menu
                        let command_id = if let Some(ref bundle_id) = m.app.bundle_id {
                            format!("app/{}", bundle_id)
                        } else {
                            format!("app/{}", m.app.name.to_lowercase().replace(' ', "-"))
                        };
                        let shortcut = crate::shortcuts::load_shortcut_overrides()
                            .ok()
                            .and_then(|o| o.get(&command_id).map(|s| s.to_string()));
                        Some(ScriptInfo::with_action_verb_and_shortcut(
                            &m.app.name,
                            m.app.path.to_string_lossy().to_string(),
                            false,
                            "Launch",
                            shortcut,
                        ))
                    }
                    scripts::SearchResult::Window(m) => {
                        // Windows use their id as identifier
                        // is_script=false: windows aren't editable scripts
                        Some(ScriptInfo::with_action_verb(
                            &m.window.title,
                            format!("window:{}", m.window.id),
                            false,
                            "Switch to",
                        ))
                    }
                    scripts::SearchResult::Agent(m) => {
                        // Agents use their path as identifier
                        Some(ScriptInfo::new(
                            &m.agent.name,
                            format!("agent:{}", m.agent.path.to_string_lossy()),
                        ))
                    }
                    scripts::SearchResult::Fallback(m) => {
                        // Fallbacks use their name as identifier
                        // is_script depends on whether it's a built-in fallback or script-based
                        Some(ScriptInfo::with_action_verb(
                            m.fallback.name(),
                            format!("fallback:{}", m.fallback.name()),
                            !m.fallback.is_builtin(),
                            "Run",
                        ))
                    }
                }
            } else {
                None
            }
        } else {
            None
        }
    }

    fn render_actions_dialog(&mut self, cx: &mut Context<Self>) -> AnyElement {
        // Use design tokens for GLOBAL theming
        let tokens = get_tokens(self.current_design);
        let design_colors = tokens.colors();
        let design_spacing = tokens.spacing();
        let design_typography = tokens.typography();
        let design_visual = tokens.visual();

        // Use design tokens for global theming
        let opacity = self.theme.get_opacity();
        let bg_hex = design_colors.background;
        let bg_with_alpha = crate::ui_foundation::hex_to_rgba_with_opacity(bg_hex, opacity.main);
        let box_shadows = self.create_box_shadows();

        // Key handler for actions dialog
        let handle_key = cx.listener(
            move |this: &mut Self,
                  event: &gpui::KeyDownEvent,
                  _window: &mut Window,
                  cx: &mut Context<Self>| {
                // Global shortcuts (Cmd+W, ESC closes window from ActionsDialog too)
                // ActionsDialog has no other key handling, so we just call the global handler
                let _ = this.handle_global_shortcut_with_options(event, true, cx);
            },
        );

        // Simple actions dialog stub with design tokens
        div()
            .flex()
            .flex_col()
            .w_full()
            .h_full()
            .bg(rgba(bg_with_alpha))
            .shadow(box_shadows)
            .rounded(px(design_visual.radius_lg))
            .p(px(design_spacing.padding_xl))
            .text_color(rgb(design_colors.text_primary))
            .font_family(design_typography.font_family)
            .key_context("actions_dialog")
            .track_focus(&self.focus_handle)
            .on_key_down(handle_key)
            .child(div().text_lg().child("Actions (Cmd+K)"))
            .child(
                div()
                    .text_sm()
                    .text_color(rgb(design_colors.text_muted))
                    .mt(px(design_spacing.margin_md))
                    .child("• Create script\n• Edit script\n• Reload\n• Settings\n• Quit"),
            )
            .child(
                div()
                    .mt(px(design_spacing.margin_lg))
                    .text_xs()
                    .text_color(rgb(design_colors.text_dimmed))
                    .child("Press Esc to close"),
            )
            .into_any_element()
    }
}

/// Helper function to render a group header style item with actual visual styling
fn render_group_header_item(
    ix: usize,
    is_selected: bool,
    style: &designs::group_header_variations::GroupHeaderStyle,
    spacing: &designs::DesignSpacing,
    typography: &designs::DesignTypography,
    visual: &designs::DesignVisual,
    colors: &designs::DesignColors,
) -> AnyElement {
    use designs::group_header_variations::GroupHeaderStyle;

    let name_owned = style.name().to_string();
    let desc_owned = style.description().to_string();

    let mut item_div = div()
        .id(ElementId::NamedInteger("gallery-header".into(), ix as u64))
        .w_full()
        .h(px(LIST_ITEM_HEIGHT))
        .px(px(spacing.padding_lg))
        .flex()
        .flex_row()
        .items_center()
        .gap(px(spacing.gap_md));

    if is_selected {
        item_div = item_div.bg(rgb(colors.background_selected));
    }

    // Create the preview element based on the style
    let preview = match style {
        // Text Only styles - vary font weight and style
        GroupHeaderStyle::UppercaseLeft => div()
            .w(px(140.0))
            .h(px(28.0))
            .rounded(px(visual.radius_sm))
            .bg(rgba((colors.background_secondary << 8) | 0x60))
            .flex()
            .items_center()
            .px(px(8.0))
            .text_xs()
            .font_weight(gpui::FontWeight::SEMIBOLD)
            .text_color(rgb(colors.text_secondary))
            .child("MAIN"),
        GroupHeaderStyle::UppercaseCenter => div()
            .w(px(140.0))
            .h(px(28.0))
            .rounded(px(visual.radius_sm))
            .bg(rgba((colors.background_secondary << 8) | 0x60))
            .flex()
            .items_center()
            .justify_center()
            .text_xs()
            .font_weight(gpui::FontWeight::SEMIBOLD)
            .text_color(rgb(colors.text_secondary))
            .child("MAIN"),
        GroupHeaderStyle::SmallCapsLeft => {
            div()
                .w(px(140.0))
                .h(px(28.0))
                .rounded(px(visual.radius_sm))
                .bg(rgba((colors.background_secondary << 8) | 0x60))
                .flex()
                .items_center()
                .px(px(8.0))
                .text_xs()
                .font_weight(gpui::FontWeight::MEDIUM)
                .text_color(rgb(colors.text_secondary))
                .child("MAIN") // Would use font-variant: small-caps if available
        }
        GroupHeaderStyle::BoldLeft => div()
            .w(px(140.0))
            .h(px(28.0))
            .rounded(px(visual.radius_sm))
            .bg(rgba((colors.background_secondary << 8) | 0x60))
            .flex()
            .items_center()
            .px(px(8.0))
            .text_xs()
            .font_weight(gpui::FontWeight::BOLD)
            .text_color(rgb(colors.text_primary))
            .child("MAIN"),
        GroupHeaderStyle::LightLeft => div()
            .w(px(140.0))
            .h(px(28.0))
            .rounded(px(visual.radius_sm))
            .bg(rgba((colors.background_secondary << 8) | 0x60))
            .flex()
            .items_center()
            .px(px(8.0))
            .text_xs()
            .font_weight(gpui::FontWeight::LIGHT)
            .text_color(rgb(colors.text_muted))
            .child("MAIN"),
        GroupHeaderStyle::MonospaceLeft => div()
            .w(px(140.0))
            .h(px(28.0))
            .rounded(px(visual.radius_sm))
            .bg(rgba((colors.background_secondary << 8) | 0x60))
            .flex()
            .items_center()
            .px(px(8.0))
            .text_xs()
            .font_family(typography.font_family_mono)
            .text_color(rgb(colors.text_secondary))
            .child("MAIN"),

        // With Lines styles
        GroupHeaderStyle::LineLeft => div()
            .w(px(140.0))
            .h(px(28.0))
            .rounded(px(visual.radius_sm))
            .bg(rgba((colors.background_secondary << 8) | 0x60))
            .flex()
            .flex_row()
            .items_center()
            .gap(px(6.0))
            .px(px(8.0))
            .child(div().w(px(24.0)).h(px(1.0)).bg(rgb(colors.border)))
            .child(
                div()
                    .text_xs()
                    .font_weight(gpui::FontWeight::MEDIUM)
                    .text_color(rgb(colors.text_secondary))
                    .child("MAIN"),
            ),
        GroupHeaderStyle::LineRight => div()
            .w(px(140.0))
            .h(px(28.0))
            .rounded(px(visual.radius_sm))
            .bg(rgba((colors.background_secondary << 8) | 0x60))
            .flex()
            .flex_row()
            .items_center()
            .gap(px(6.0))
            .px(px(8.0))
            .child(
                div()
                    .text_xs()
                    .font_weight(gpui::FontWeight::MEDIUM)
                    .text_color(rgb(colors.text_secondary))
                    .child("MAIN"),
            )
            .child(div().flex_1().h(px(1.0)).bg(rgb(colors.border))),
        GroupHeaderStyle::LineBothSides => div()
            .w(px(140.0))
            .h(px(28.0))
            .rounded(px(visual.radius_sm))
            .bg(rgba((colors.background_secondary << 8) | 0x60))
            .flex()
            .flex_row()
            .items_center()
            .gap(px(6.0))
            .px(px(8.0))
            .child(div().flex_1().h(px(1.0)).bg(rgb(colors.border)))
            .child(
                div()
                    .text_xs()
                    .font_weight(gpui::FontWeight::MEDIUM)
                    .text_color(rgb(colors.text_secondary))
                    .child("MAIN"),
            )
            .child(div().flex_1().h(px(1.0)).bg(rgb(colors.border))),
        GroupHeaderStyle::LineBelow => div()
            .w(px(140.0))
            .h(px(28.0))
            .rounded(px(visual.radius_sm))
            .bg(rgba((colors.background_secondary << 8) | 0x60))
            .flex()
            .flex_col()
            .justify_center()
            .px(px(8.0))
            .gap(px(2.0))
            .child(
                div()
                    .text_xs()
                    .font_weight(gpui::FontWeight::MEDIUM)
                    .text_color(rgb(colors.text_secondary))
                    .child("MAIN"),
            )
            .child(div().w(px(40.0)).h(px(1.0)).bg(rgb(colors.border))),
        GroupHeaderStyle::LineAbove => div()
            .w(px(140.0))
            .h(px(28.0))
            .rounded(px(visual.radius_sm))
            .bg(rgba((colors.background_secondary << 8) | 0x60))
            .flex()
            .flex_col()
            .justify_center()
            .px(px(8.0))
            .gap(px(2.0))
            .child(div().w(px(40.0)).h(px(1.0)).bg(rgb(colors.border)))
            .child(
                div()
                    .text_xs()
                    .font_weight(gpui::FontWeight::MEDIUM)
                    .text_color(rgb(colors.text_secondary))
                    .child("MAIN"),
            ),
        GroupHeaderStyle::DoubleLine => div()
            .w(px(140.0))
            .h(px(28.0))
            .rounded(px(visual.radius_sm))
            .bg(rgba((colors.background_secondary << 8) | 0x60))
            .flex()
            .flex_col()
            .justify_center()
            .items_center()
            .gap(px(1.0))
            .child(div().w(px(100.0)).h(px(1.0)).bg(rgb(colors.border)))
            .child(
                div()
                    .text_xs()
                    .font_weight(gpui::FontWeight::MEDIUM)
                    .text_color(rgb(colors.text_secondary))
                    .child("MAIN"),
            )
            .child(div().w(px(100.0)).h(px(1.0)).bg(rgb(colors.border))),

        // With Background styles
        GroupHeaderStyle::PillBackground => div()
            .w(px(140.0))
            .h(px(28.0))
            .rounded(px(visual.radius_sm))
            .bg(rgba((colors.background_secondary << 8) | 0x60))
            .flex()
            .items_center()
            .px(px(8.0))
            .child(
                div()
                    .px(px(8.0))
                    .py(px(2.0))
                    .rounded(px(10.0))
                    .bg(rgba((colors.accent << 8) | 0x30))
                    .text_xs()
                    .font_weight(gpui::FontWeight::MEDIUM)
                    .text_color(rgb(colors.accent))
                    .child("MAIN"),
            ),
        GroupHeaderStyle::FullWidthBackground => div()
            .w(px(140.0))
            .h(px(28.0))
            .rounded(px(visual.radius_sm))
            .bg(rgba((colors.accent << 8) | 0x20))
            .flex()
            .items_center()
            .px(px(8.0))
            .text_xs()
            .font_weight(gpui::FontWeight::SEMIBOLD)
            .text_color(rgb(colors.text_primary))
            .child("MAIN"),
        GroupHeaderStyle::SubtleBackground => div()
            .w(px(140.0))
            .h(px(28.0))
            .rounded(px(visual.radius_sm))
            .bg(rgba((colors.background_secondary << 8) | 0x90))
            .flex()
            .items_center()
            .px(px(8.0))
            .text_xs()
            .font_weight(gpui::FontWeight::MEDIUM)
            .text_color(rgb(colors.text_secondary))
            .child("MAIN"),
        GroupHeaderStyle::GradientFade => {
            // Simulated with opacity fade
            div()
                .w(px(140.0))
                .h(px(28.0))
                .rounded(px(visual.radius_sm))
                .bg(rgba((colors.background_secondary << 8) | 0x60))
                .flex()
                .items_center()
                .px(px(8.0))
                .child(
                    div()
                        .px(px(16.0))
                        .text_xs()
                        .font_weight(gpui::FontWeight::MEDIUM)
                        .text_color(rgb(colors.text_secondary))
                        .child("~  MAIN  ~"),
                )
        }
        GroupHeaderStyle::BorderedBox => div()
            .w(px(140.0))
            .h(px(28.0))
            .rounded(px(visual.radius_sm))
            .bg(rgba((colors.background_secondary << 8) | 0x60))
            .flex()
            .items_center()
            .px(px(8.0))
            .child(
                div()
                    .px(px(8.0))
                    .py(px(2.0))
                    .border_1()
                    .border_color(rgb(colors.border))
                    .rounded(px(2.0))
                    .text_xs()
                    .font_weight(gpui::FontWeight::MEDIUM)
                    .text_color(rgb(colors.text_secondary))
                    .child("MAIN"),
            ),

        // Minimal styles
        GroupHeaderStyle::DotPrefix => div()
            .w(px(140.0))
            .h(px(28.0))
            .rounded(px(visual.radius_sm))
            .bg(rgba((colors.background_secondary << 8) | 0x60))
            .flex()
            .flex_row()
            .items_center()
            .gap(px(6.0))
            .px(px(8.0))
            .child(
                div()
                    .w(px(4.0))
                    .h(px(4.0))
                    .rounded(px(2.0))
                    .bg(rgb(colors.text_muted)),
            )
            .child(
                div()
                    .text_xs()
                    .text_color(rgb(colors.text_secondary))
                    .child("MAIN"),
            ),
        GroupHeaderStyle::DashPrefix => div()
            .w(px(140.0))
            .h(px(28.0))
            .rounded(px(visual.radius_sm))
            .bg(rgba((colors.background_secondary << 8) | 0x60))
            .flex()
            .items_center()
            .px(px(8.0))
            .text_xs()
            .text_color(rgb(colors.text_secondary))
            .child("- MAIN"),
        GroupHeaderStyle::BulletPrefix => div()
            .w(px(140.0))
            .h(px(28.0))
            .rounded(px(visual.radius_sm))
            .bg(rgba((colors.background_secondary << 8) | 0x60))
            .flex()
            .flex_row()
            .items_center()
            .gap(px(6.0))
            .px(px(8.0))
            .child(
                div()
                    .w(px(6.0))
                    .h(px(6.0))
                    .rounded(px(3.0))
                    .bg(rgb(colors.accent)),
            )
            .child(
                div()
                    .text_xs()
                    .text_color(rgb(colors.text_secondary))
                    .child("MAIN"),
            ),
        GroupHeaderStyle::ArrowPrefix => div()
            .w(px(140.0))
            .h(px(28.0))
            .rounded(px(visual.radius_sm))
            .bg(rgba((colors.background_secondary << 8) | 0x60))
            .flex()
            .items_center()
            .px(px(8.0))
            .text_xs()
            .text_color(rgb(colors.text_secondary))
            .child("\u{25B8} MAIN"),
        GroupHeaderStyle::ChevronPrefix => div()
            .w(px(140.0))
            .h(px(28.0))
            .rounded(px(visual.radius_sm))
            .bg(rgba((colors.background_secondary << 8) | 0x60))
            .flex()
            .items_center()
            .px(px(8.0))
            .text_xs()
            .text_color(rgb(colors.text_secondary))
            .child("\u{203A} MAIN"),
        GroupHeaderStyle::Dimmed => div()
            .w(px(140.0))
            .h(px(28.0))
            .rounded(px(visual.radius_sm))
            .bg(rgba((colors.background_secondary << 8) | 0x60))
            .flex()
            .items_center()
            .px(px(8.0))
            .text_xs()
            .opacity(0.5)
            .text_color(rgb(colors.text_muted))
            .child("MAIN"),

        // Decorative styles
        GroupHeaderStyle::Bracketed => div()
            .w(px(140.0))
            .h(px(28.0))
            .rounded(px(visual.radius_sm))
            .bg(rgba((colors.background_secondary << 8) | 0x60))
            .flex()
            .items_center()
            .px(px(8.0))
            .text_xs()
            .text_color(rgb(colors.text_secondary))
            .child("[MAIN]"),
        GroupHeaderStyle::Quoted => div()
            .w(px(140.0))
            .h(px(28.0))
            .rounded(px(visual.radius_sm))
            .bg(rgba((colors.background_secondary << 8) | 0x60))
            .flex()
            .items_center()
            .px(px(8.0))
            .text_xs()
            .text_color(rgb(colors.text_secondary))
            .child("\"MAIN\""),
        GroupHeaderStyle::Tagged => div()
            .w(px(140.0))
            .h(px(28.0))
            .rounded(px(visual.radius_sm))
            .bg(rgba((colors.background_secondary << 8) | 0x60))
            .flex()
            .items_center()
            .px(px(8.0))
            .child(
                div()
                    .px(px(6.0))
                    .py(px(1.0))
                    .bg(rgba((colors.accent << 8) | 0x40))
                    .rounded(px(2.0))
                    .text_xs()
                    .font_weight(gpui::FontWeight::MEDIUM)
                    .text_color(rgb(colors.accent))
                    .child("MAIN"),
            ),
        GroupHeaderStyle::Numbered => div()
            .w(px(140.0))
            .h(px(28.0))
            .rounded(px(visual.radius_sm))
            .bg(rgba((colors.background_secondary << 8) | 0x60))
            .flex()
            .flex_row()
            .items_center()
            .gap(px(6.0))
            .px(px(8.0))
            .child(
                div()
                    .text_xs()
                    .font_weight(gpui::FontWeight::BOLD)
                    .text_color(rgb(colors.accent))
                    .child("01."),
            )
            .child(
                div()
                    .text_xs()
                    .text_color(rgb(colors.text_secondary))
                    .child("MAIN"),
            ),
        GroupHeaderStyle::IconPrefix => div()
            .w(px(140.0))
            .h(px(28.0))
            .rounded(px(visual.radius_sm))
            .bg(rgba((colors.background_secondary << 8) | 0x60))
            .flex()
            .flex_row()
            .items_center()
            .gap(px(6.0))
            .px(px(8.0))
            .child(
                div()
                    .w(px(8.0))
                    .h(px(8.0))
                    .bg(rgb(colors.accent))
                    .rounded(px(1.0)),
            )
            .child(
                div()
                    .text_xs()
                    .text_color(rgb(colors.text_secondary))
                    .child("MAIN"),
            ),
    };

    item_div
        // Preview element
        .child(preview)
        // Name and description
        .child(
            div()
                .flex_1()
                .flex()
                .flex_col()
                .gap(px(2.0))
                .child(
                    div()
                        .text_sm()
                        .font_weight(gpui::FontWeight::MEDIUM)
                        .text_color(rgb(colors.text_primary))
                        .child(name_owned),
                )
                .child(
                    div()
                        .text_xs()
                        .text_color(rgb(colors.text_muted))
                        .child(desc_owned),
                ),
        )
        .into_any_element()
}

</file>

<file path="src/render_builtins.rs">
// Builtin view render methods - extracted from app_render.rs
// This file is included via include!() macro in main.rs
// Contains: render_clipboard_history, render_app_launcher, render_window_switcher, render_design_gallery

impl ScriptListApp {
    /// Toggle the actions dialog for file search results
    /// Opens a popup with file-specific actions: Open, Show in Finder, Quick Look, etc.
    fn toggle_file_search_actions(
        &mut self,
        file: &file_search::FileResult,
        window: &mut Window,
        cx: &mut Context<Self>,
    ) {
        logging::log("KEY", "Toggling file search actions popup");

        if self.show_actions_popup || is_actions_window_open() {
            // Close the actions popup
            self.show_actions_popup = false;
            self.actions_dialog = None;
            self.file_search_actions_path = None;

            // Restore focus state - file search uses the main filter input
            self.focused_input = FocusedInput::MainFilter;
            self.gpui_input_focused = true;

            // Close the actions window via spawn
            cx.spawn(async move |_this, cx| {
                cx.update(|cx| {
                    close_actions_window(cx);
                })
                .ok();
            })
            .detach();

            // Refocus the file search input
            self.focus_main_filter(window, cx);
            logging::log(
                "FOCUS",
                "File search actions closed, focus returned to file search input",
            );
        } else {
            // Open actions popup for the selected file
            self.show_actions_popup = true;

            // CRITICAL: Transfer focus from Input to main focus_handle
            // This prevents the Input from receiving text (which would go to file search filter)
            // while keeping keyboard focus in main window for routing to actions dialog
            self.focus_handle.focus(window, cx);
            self.gpui_input_focused = false;
            self.focused_input = FocusedInput::ActionsSearch;

            // Store the file path for action handling
            self.file_search_actions_path = Some(file.path.clone());

            // Create file info from the result
            let file_info = file_search::FileInfo::from_result(file);

            // Create the dialog entity
            let theme_arc = std::sync::Arc::new(self.theme.clone());
            let dialog = cx.new(|cx| {
                let focus_handle = cx.focus_handle();
                ActionsDialog::with_file(
                    focus_handle,
                    std::sync::Arc::new(|_action_id| {}), // Callback handled via main app
                    &file_info,
                    theme_arc,
                )
            });

            // Store the dialog entity for keyboard routing
            self.actions_dialog = Some(dialog.clone());

            // Get main window bounds and display_id for positioning
            let main_bounds = window.bounds();
            let display_id = window.display(cx).map(|d| d.id());

            logging::log(
                "ACTIONS",
                &format!(
                    "Opening file search actions for: {} (is_dir={})",
                    file_info.name, file_info.is_dir
                ),
            );

            // Open the actions window
            cx.spawn(async move |_this, cx| {
                cx.update(
                    |cx| match open_actions_window(cx, main_bounds, display_id, dialog) {
                        Ok(_handle) => {
                            logging::log("ACTIONS", "File search actions popup window opened");
                        }
                        Err(e) => {
                            logging::log("ERROR", &format!("Failed to open actions window: {}", e));
                        }
                    },
                )
                .ok();
            })
            .detach();
        }
        cx.notify();
    }

    /// Render clipboard history view
    /// P0 FIX: Data comes from self.cached_clipboard_entries, view passes only state
    fn render_clipboard_history(
        &mut self,
        filter: String,
        selected_index: usize,
        cx: &mut Context<Self>,
    ) -> AnyElement {
        // Use design tokens for GLOBAL theming
        let tokens = get_tokens(self.current_design);
        let design_colors = tokens.colors();
        let design_spacing = tokens.spacing();
        let design_typography = tokens.typography();
        let design_visual = tokens.visual();

        // Use design tokens for global theming
        let opacity = self.theme.get_opacity();
        let bg_hex = design_colors.background;
        let bg_with_alpha = crate::ui_foundation::hex_to_rgba_with_opacity(bg_hex, opacity.main);
        let box_shadows = self.create_box_shadows();

        // P0 FIX: Reference data from self instead of taking ownership
        // P1 FIX: NEVER do synchronous SQLite queries or image decoding in render loop!
        // Only copy from global cache (populated async by background prewarm thread).
        // Images not yet cached will show placeholder with dimensions from metadata.
        for entry in &self.cached_clipboard_entries {
            if entry.content_type == clipboard_history::ContentType::Image {
                // Only use already-cached images - NO synchronous fetch/decode
                if !self.clipboard_image_cache.contains_key(&entry.id) {
                    if let Some(cached) = clipboard_history::get_cached_image(&entry.id) {
                        self.clipboard_image_cache.insert(entry.id.clone(), cached);
                    }
                    // If not in global cache yet, background thread will populate it.
                    // We'll show placeholder with dimensions until then.
                }
            }
        }

        // Clone the cache for use in closures
        let image_cache = self.clipboard_image_cache.clone();

        // Filter entries based on current filter
        let filtered_entries: Vec<_> = if filter.is_empty() {
            self.cached_clipboard_entries.iter().enumerate().collect()
        } else {
            let filter_lower = filter.to_lowercase();
            self.cached_clipboard_entries
                .iter()
                .enumerate()
                .filter(|(_, e)| e.text_preview.to_lowercase().contains(&filter_lower))
                .collect()
        };
        let filtered_len = filtered_entries.len();

        // Key handler for clipboard history
        let handle_key = cx.listener(
            move |this: &mut Self,
                  event: &gpui::KeyDownEvent,
                  _window: &mut Window,
                  cx: &mut Context<Self>| {
                // If the shortcut recorder is active, don't process any key events.
                // The recorder has its own key handlers and should receive all key events.
                if this.shortcut_recorder_state.is_some() {
                    return;
                }

                // Global shortcuts (Cmd+W, ESC for dismissable views)
                if this.handle_global_shortcut_with_options(event, true, cx) {
                    return;
                }

                let key_str = event.keystroke.key.to_lowercase();
                logging::log("KEY", &format!("ClipboardHistory key: '{}'", key_str));

                // P0 FIX: View state only - data comes from this.cached_clipboard_entries
                if let AppView::ClipboardHistoryView {
                    filter,
                    selected_index,
                } = &mut this.current_view
                {
                    // Apply filter to get current filtered list
                    // P0 FIX: Reference cached_clipboard_entries from self
                    let filtered_entries: Vec<_> = if filter.is_empty() {
                        this.cached_clipboard_entries.iter().enumerate().collect()
                    } else {
                        let filter_lower = filter.to_lowercase();
                        this.cached_clipboard_entries
                            .iter()
                            .enumerate()
                            .filter(|(_, e)| e.text_preview.to_lowercase().contains(&filter_lower))
                            .collect()
                    };
                    let filtered_len = filtered_entries.len();

                    match key_str.as_str() {
                        "up" | "arrowup" => {
                            if *selected_index > 0 {
                                *selected_index -= 1;
                                // Scroll to keep selection visible
                                this.clipboard_list_scroll_handle
                                    .scroll_to_item(*selected_index, ScrollStrategy::Nearest);
                                cx.notify();
                            }
                        }
                        "down" | "arrowdown" => {
                            if *selected_index < filtered_len.saturating_sub(1) {
                                *selected_index += 1;
                                // Scroll to keep selection visible
                                this.clipboard_list_scroll_handle
                                    .scroll_to_item(*selected_index, ScrollStrategy::Nearest);
                                cx.notify();
                            }
                        }
                        "enter" => {
                            // Copy selected entry to clipboard, hide window, then paste
                            if let Some((_, entry)) = filtered_entries.get(*selected_index) {
                                logging::log(
                                    "EXEC",
                                    &format!("Copying clipboard entry: {}", entry.id),
                                );
                                if let Err(e) =
                                    clipboard_history::copy_entry_to_clipboard(&entry.id)
                                {
                                    logging::log("ERROR", &format!("Failed to copy entry: {}", e));
                                } else {
                                    logging::log("EXEC", "Entry copied to clipboard");
                                    // Hide window first
                                    script_kit_gpui::set_main_window_visible(false);
                                    cx.hide();
                                    NEEDS_RESET.store(true, Ordering::SeqCst);

                                    // Simulate Cmd+V paste after a brief delay to let focus return
                                    std::thread::spawn(|| {
                                        std::thread::sleep(std::time::Duration::from_millis(100));
                                        if let Err(e) = selected_text::simulate_paste_with_cg() {
                                            logging::log(
                                                "ERROR",
                                                &format!("Failed to simulate paste: {}", e),
                                            );
                                        } else {
                                            logging::log("EXEC", "Simulated Cmd+V paste");
                                        }
                                    });
                                }
                            }
                        }
                        // Note: "escape" is handled by handle_global_shortcut_with_options above
                        // Text input (backspace, characters) is handled by the shared Input component
                        // which syncs via handle_filter_input_change()
                        _ => {}
                    }
                }
            },
        );

        // Pre-compute colors
        let list_colors = ListItemColors::from_design(&design_colors);
        let text_primary = design_colors.text_primary;
        #[allow(unused_variables)]
        let text_muted = design_colors.text_muted;
        let text_dimmed = design_colors.text_dimmed;
        let ui_border = design_colors.border;

        // Build virtualized list
        let list_element: AnyElement = if filtered_len == 0 {
            div()
                .w_full()
                .py(px(design_spacing.padding_xl))
                .text_center()
                .text_color(rgb(design_colors.text_muted))
                .font_family(design_typography.font_family)
                .child(if filter.is_empty() {
                    "No clipboard history"
                } else {
                    "No entries match your filter"
                })
                .into_any_element()
        } else {
            // Clone data for the closure
            let entries_for_closure: Vec<_> = filtered_entries
                .iter()
                .map(|(i, e)| (*i, (*e).clone()))
                .collect();
            let selected = selected_index;
            let image_cache_for_list = image_cache.clone();

            uniform_list(
                "clipboard-history",
                filtered_len,
                move |visible_range, _window, _cx| {
                    visible_range
                        .map(|ix| {
                            if let Some((_, entry)) = entries_for_closure.get(ix) {
                                let is_selected = ix == selected;

                                // Get cached thumbnail for images
                                let cached_image = if entry.content_type
                                    == clipboard_history::ContentType::Image
                                {
                                    image_cache_for_list.get(&entry.id).cloned()
                                } else {
                                    None
                                };

                                // Use display_preview() from ClipboardEntryMeta
                                let display_content = entry.display_preview();

                                // Format relative time (entry.timestamp is in milliseconds)
                                let now_ms = chrono::Utc::now().timestamp_millis();
                                let age_secs = (now_ms - entry.timestamp) / 1000;
                                let relative_time = if age_secs < 60 {
                                    "just now".to_string()
                                } else if age_secs < 3600 {
                                    format!("{}m ago", age_secs / 60)
                                } else if age_secs < 86400 {
                                    format!("{}h ago", age_secs / 3600)
                                } else {
                                    format!("{}d ago", age_secs / 86400)
                                };

                                // Add pin indicator
                                let name = if entry.pinned {
                                    format!("📌 {}", display_content)
                                } else {
                                    display_content
                                };

                                // Build list item with optional thumbnail
                                let mut item = ListItem::new(name, list_colors)
                                    .description_opt(Some(relative_time))
                                    .selected(is_selected)
                                    .with_accent_bar(true);

                                // Add thumbnail for images, text icon for text entries
                                if let Some(render_image) = cached_image {
                                    item = item.icon_image(render_image);
                                } else if entry.content_type == clipboard_history::ContentType::Text
                                {
                                    item = item.icon("📄");
                                }

                                div().id(ix).child(item)
                            } else {
                                div().id(ix).h(px(LIST_ITEM_HEIGHT))
                            }
                        })
                        .collect()
                },
            )
            .h_full()
            .track_scroll(&self.clipboard_list_scroll_handle)
            .into_any_element()
        };

        // Build preview panel for selected entry
        let selected_entry = filtered_entries
            .get(selected_index)
            .map(|(_, e)| (*e).clone());
        let preview_panel = self.render_clipboard_preview_panel(
            &selected_entry,
            &image_cache,
            &design_colors,
            &design_spacing,
            &design_typography,
            &design_visual,
        );

        div()
            .flex()
            .flex_col()
            .bg(rgba(bg_with_alpha))
            .shadow(box_shadows)
            .w_full()
            .h_full()
            .rounded(px(design_visual.radius_lg))
            .text_color(rgb(text_primary))
            .font_family(design_typography.font_family)
            .key_context("clipboard_history")
            .track_focus(&self.focus_handle)
            .on_key_down(handle_key)
            // Header with input - uses shared gpui_input_state for consistent cursor/selection
            .child(
                div()
                    .w_full()
                    .px(px(design_spacing.padding_lg))
                    .py(px(design_spacing.padding_md))
                    .flex()
                    .flex_row()
                    .items_center()
                    .gap_3()
                    // Search input - shared component with main menu
                    .child(
                        div().flex_1().flex().flex_row().items_center().child(
                            Input::new(&self.gpui_input_state)
                                .w_full()
                                .h(px(28.))
                                .px(px(0.))
                                .py(px(0.))
                                .with_size(Size::Size(px(design_typography.font_size_xl)))
                                .appearance(false)
                                .bordered(false)
                                .focus_bordered(false),
                        ),
                    )
                    .child(
                        div()
                            .text_sm()
                            .text_color(rgb(text_dimmed))
                            .child(format!("{} entries", self.cached_clipboard_entries.len())),
                    ),
            )
            // Divider
            .child(
                div()
                    .mx(px(design_spacing.padding_lg))
                    .h(px(design_visual.border_thin))
                    .bg(rgba((ui_border << 8) | 0x60)),
            )
            // Main content area - 50/50 split: List on left, Preview on right
            .child(
                div()
                    .flex()
                    .flex_row()
                    .flex_1()
                    .min_h(px(0.))
                    .w_full()
                    .overflow_hidden()
                    // Left side: Clipboard list (50% width)
                    .child(
                        div()
                            .w_1_2()
                            .h_full()
                            .min_h(px(0.))
                            .py(px(design_spacing.padding_xs))
                            .child(list_element),
                    )
                    // Right side: Preview panel (50% width)
                    .child(
                        div()
                            .w_1_2()
                            .h_full()
                            .min_h(px(0.))
                            .overflow_hidden()
                            .child(preview_panel),
                    ),
            )
            // Footer
            .child(PromptFooter::new(
                PromptFooterConfig::new()
                    .primary_label("Paste")
                    .primary_shortcut("↵")
                    .show_secondary(false),
                PromptFooterColors::from_design(&design_colors),
            ))
            .into_any_element()
    }

    /// Render the preview panel for clipboard history
    fn render_clipboard_preview_panel(
        &self,
        selected_entry: &Option<clipboard_history::ClipboardEntryMeta>,
        image_cache: &std::collections::HashMap<String, Arc<gpui::RenderImage>>,
        colors: &designs::DesignColors,
        spacing: &designs::DesignSpacing,
        typography: &designs::DesignTypography,
        visual: &designs::DesignVisual,
    ) -> impl IntoElement {
        let bg_main = colors.background;
        let ui_border = colors.border;
        let text_primary = colors.text_primary;
        let text_muted = colors.text_muted;
        let text_secondary = colors.text_secondary;
        let bg_search_box = colors.background_tertiary;

        let mut panel = div()
            .w_full()
            .h_full()
            .bg(rgb(bg_main))
            .border_l_1()
            .border_color(rgba((ui_border << 8) | 0x80))
            .p(px(spacing.padding_lg))
            .flex()
            .flex_col()
            .overflow_y_hidden()
            .font_family(typography.font_family);

        match selected_entry {
            Some(entry) => {
                // Header with content type
                let content_type_label = match entry.content_type {
                    clipboard_history::ContentType::Text => "Text",
                    clipboard_history::ContentType::Image => "Image",
                };

                panel = panel.child(
                    div()
                        .flex()
                        .flex_row()
                        .items_center()
                        .gap_2()
                        .pb(px(spacing.padding_sm))
                        // Content type badge
                        .child(
                            div()
                                .px(px(spacing.padding_sm))
                                .py(px(spacing.padding_xs / 2.0))
                                .rounded(px(visual.radius_sm))
                                .bg(rgba((colors.accent << 8) | 0x30))
                                .text_xs()
                                .text_color(rgb(colors.accent))
                                .child(content_type_label),
                        )
                        // Pin indicator
                        .when(entry.pinned, |d| {
                            d.child(
                                div()
                                    .px(px(spacing.padding_sm))
                                    .py(px(spacing.padding_xs / 2.0))
                                    .rounded(px(visual.radius_sm))
                                    .bg(rgba((colors.accent << 8) | 0x20))
                                    .text_xs()
                                    .text_color(rgb(colors.accent))
                                    .child("📌 Pinned"),
                            )
                        }),
                );

                // Timestamp
                let now = chrono::Utc::now().timestamp();
                let age_secs = now - entry.timestamp;
                let relative_time = if age_secs < 60 {
                    "just now".to_string()
                } else if age_secs < 3600 {
                    format!("{} minutes ago", age_secs / 60)
                } else if age_secs < 86400 {
                    format!("{} hours ago", age_secs / 3600)
                } else {
                    format!("{} days ago", age_secs / 86400)
                };

                panel = panel.child(
                    div()
                        .text_xs()
                        .text_color(rgb(text_muted))
                        .pb(px(spacing.padding_md))
                        .child(relative_time),
                );

                // Divider
                panel = panel.child(
                    div()
                        .w_full()
                        .h(px(visual.border_thin))
                        .bg(rgba((ui_border << 8) | 0x60))
                        .my(px(spacing.padding_sm)),
                );

                // Content preview
                panel = panel.child(
                    div()
                        .text_xs()
                        .text_color(rgb(text_muted))
                        .pb(px(spacing.padding_sm))
                        .child("Content Preview"),
                );

                match entry.content_type {
                    clipboard_history::ContentType::Text => {
                        // Fetch full content on-demand for preview
                        let content = clipboard_history::get_entry_content(&entry.id)
                            .unwrap_or_else(|| entry.text_preview.clone());
                        let char_count = content.chars().count();
                        let line_count = content.lines().count();

                        panel = panel
                            .child(
                                div()
                                    .w_full()
                                    .flex_1()
                                    .p(px(spacing.padding_md))
                                    .rounded(px(visual.radius_md))
                                    .bg(rgba((bg_search_box << 8) | 0x80))
                                    .overflow_hidden()
                                    .font_family(typography.font_family_mono)
                                    .text_sm()
                                    .text_color(rgb(text_primary))
                                    .child(content),
                            )
                            // Stats footer
                            .child(
                                div()
                                    .pt(px(spacing.padding_sm))
                                    .text_xs()
                                    .text_color(rgb(text_secondary))
                                    .child(format!(
                                        "{} characters • {} lines",
                                        char_count, line_count
                                    )),
                            );
                    }
                    clipboard_history::ContentType::Image => {
                        // Get image dimensions from metadata
                        let width = entry.image_width.unwrap_or(0);
                        let height = entry.image_height.unwrap_or(0);

                        // Try to get cached render image
                        let cached_image = image_cache.get(&entry.id).cloned();

                        let image_container = if let Some(render_image) = cached_image {
                            // Calculate display size that fits in the preview panel
                            // Max size is 300x300, maintain aspect ratio
                            let max_size: f32 = 300.0;
                            let (display_w, display_h) = if width > 0 && height > 0 {
                                let w = width as f32;
                                let h = height as f32;
                                let scale = (max_size / w).min(max_size / h).min(1.0);
                                (w * scale, h * scale)
                            } else {
                                (max_size, max_size)
                            };

                            div()
                                .flex()
                                .flex_col()
                                .items_center()
                                .gap_2()
                                // Actual image thumbnail
                                .child(
                                    gpui::img(move |_window: &mut Window, _cx: &mut App| {
                                        Some(Ok(render_image.clone()))
                                    })
                                    .w(px(display_w))
                                    .h(px(display_h))
                                    .object_fit(gpui::ObjectFit::Contain)
                                    .rounded(px(visual.radius_sm)),
                                )
                                // Dimensions label below image
                                .child(
                                    div()
                                        .text_sm()
                                        .text_color(rgb(text_secondary))
                                        .child(format!("{}×{} pixels", width, height)),
                                )
                        } else {
                            // Fallback if image not in cache (shouldn't happen)
                            div()
                                .flex()
                                .flex_col()
                                .items_center()
                                .gap_2()
                                .child(div().text_2xl().child("🖼️"))
                                .child(
                                    div()
                                        .text_lg()
                                        .font_weight(gpui::FontWeight::SEMIBOLD)
                                        .text_color(rgb(text_primary))
                                        .child(format!("{}×{}", width, height)),
                                )
                                .child(
                                    div()
                                        .text_sm()
                                        .text_color(rgb(text_muted))
                                        .child("Loading image..."),
                                )
                        };

                        panel = panel.child(
                            div()
                                .w_full()
                                .flex_1()
                                .p(px(spacing.padding_lg))
                                .rounded(px(visual.radius_md))
                                .bg(rgba((bg_search_box << 8) | 0x80))
                                .flex()
                                .items_center()
                                .justify_center()
                                .overflow_hidden()
                                .child(image_container),
                        );
                    }
                }
            }
            None => {
                // Empty state
                panel = panel.child(
                    div()
                        .w_full()
                        .h_full()
                        .flex()
                        .items_center()
                        .justify_center()
                        .text_color(rgb(text_muted))
                        .child("No entry selected"),
                );
            }
        }

        panel
    }

    /// Render app launcher view
    /// P0 FIX: Data comes from self.apps, view passes only state
    fn render_app_launcher(
        &mut self,
        filter: String,
        selected_index: usize,
        cx: &mut Context<Self>,
    ) -> AnyElement {
        // Use design tokens for GLOBAL theming
        let tokens = get_tokens(self.current_design);
        let design_colors = tokens.colors();
        let design_spacing = tokens.spacing();
        let design_typography = tokens.typography();
        let design_visual = tokens.visual();

        // Use design tokens for global theming
        let opacity = self.theme.get_opacity();
        let bg_hex = design_colors.background;
        let bg_with_alpha = crate::ui_foundation::hex_to_rgba_with_opacity(bg_hex, opacity.main);
        let box_shadows = self.create_box_shadows();

        // P0 FIX: Filter apps from self.apps instead of taking ownership
        let filtered_apps: Vec<_> = if filter.is_empty() {
            self.apps.iter().enumerate().collect()
        } else {
            let filter_lower = filter.to_lowercase();
            self.apps
                .iter()
                .enumerate()
                .filter(|(_, a)| a.name.to_lowercase().contains(&filter_lower))
                .collect()
        };
        let filtered_len = filtered_apps.len();

        // Key handler for app launcher
        let handle_key = cx.listener(
            move |this: &mut Self,
                  event: &gpui::KeyDownEvent,
                  _window: &mut Window,
                  cx: &mut Context<Self>| {
                // If the shortcut recorder is active, don't process any key events.
                // The recorder has its own key handlers and should receive all key events.
                if this.shortcut_recorder_state.is_some() {
                    return;
                }

                // Global shortcuts (Cmd+W) - handled first regardless of view state
                // Global shortcuts (Cmd+W, ESC for dismissable views)
                if this.handle_global_shortcut_with_options(event, true, cx) {
                    return;
                }

                let key_str = event.keystroke.key.to_lowercase();
                logging::log("KEY", &format!("AppLauncher key: '{}'", key_str));

                // P0 FIX: View state only - data comes from this.apps
                if let AppView::AppLauncherView {
                    filter,
                    selected_index,
                } = &mut this.current_view
                {
                    // Apply filter to get current filtered list
                    // P0 FIX: Reference apps from self
                    let filtered_apps: Vec<_> = if filter.is_empty() {
                        this.apps.iter().enumerate().collect()
                    } else {
                        let filter_lower = filter.to_lowercase();
                        this.apps
                            .iter()
                            .enumerate()
                            .filter(|(_, a)| a.name.to_lowercase().contains(&filter_lower))
                            .collect()
                    };
                    let filtered_len = filtered_apps.len();

                    match key_str.as_str() {
                        "up" | "arrowup" => {
                            if *selected_index > 0 {
                                *selected_index -= 1;
                                cx.notify();
                            }
                        }
                        "down" | "arrowdown" => {
                            if *selected_index < filtered_len.saturating_sub(1) {
                                *selected_index += 1;
                                cx.notify();
                            }
                        }
                        "enter" => {
                            // Launch selected app and hide window
                            if let Some((_, app)) = filtered_apps.get(*selected_index) {
                                logging::log("EXEC", &format!("Launching app: {}", app.name));
                                if let Err(e) = app_launcher::launch_application(app) {
                                    logging::log("ERROR", &format!("Failed to launch app: {}", e));
                                } else {
                                    logging::log("EXEC", &format!("Launched: {}", app.name));
                                    // Hide window after launching
                                    script_kit_gpui::set_main_window_visible(false);
                                    cx.hide();
                                    NEEDS_RESET.store(true, Ordering::SeqCst);
                                }
                            }
                        }
                        // Note: "escape" is handled by handle_global_shortcut_with_options above
                        "backspace" => {
                            if !filter.is_empty() {
                                filter.pop();
                                *selected_index = 0;
                                cx.notify();
                            }
                        }
                        _ => {
                            if let Some(ref key_char) = event.keystroke.key_char {
                                if let Some(ch) = key_char.chars().next() {
                                    if !ch.is_control() {
                                        filter.push(ch);
                                        *selected_index = 0;
                                        cx.notify();
                                    }
                                }
                            }
                        }
                    }
                }
            },
        );

        let input_display = if filter.is_empty() {
            SharedString::from("Search applications...")
        } else {
            SharedString::from(filter.clone())
        };
        let input_is_empty = filter.is_empty();

        // Pre-compute colors
        let list_colors = ListItemColors::from_design(&design_colors);
        let text_primary = design_colors.text_primary;
        let text_muted = design_colors.text_muted;
        let text_dimmed = design_colors.text_dimmed;
        let ui_border = design_colors.border;

        // Build virtualized list
        let list_element: AnyElement = if filtered_len == 0 {
            div()
                .w_full()
                .py(px(design_spacing.padding_xl))
                .text_center()
                .text_color(rgb(design_colors.text_muted))
                .font_family(design_typography.font_family)
                .child(if filter.is_empty() {
                    "No applications found"
                } else {
                    "No apps match your filter"
                })
                .into_any_element()
        } else {
            // Clone data for the closure
            let apps_for_closure: Vec<_> = filtered_apps
                .iter()
                .map(|(i, a)| (*i, (*a).clone()))
                .collect();
            let selected = selected_index;

            uniform_list(
                "app-launcher",
                filtered_len,
                move |visible_range, _window, _cx| {
                    visible_range
                        .map(|ix| {
                            if let Some((_, app)) = apps_for_closure.get(ix) {
                                let is_selected = ix == selected;

                                // Format app path for description
                                let path_str = app.path.to_string_lossy();
                                let description = if path_str.starts_with("/Applications") {
                                    None // No need to show path for standard apps
                                } else {
                                    Some(path_str.to_string())
                                };

                                // Use pre-decoded icon if available, fallback to emoji
                                let icon = match &app.icon {
                                    Some(img) => list_item::IconKind::Image(img.clone()),
                                    None => list_item::IconKind::Emoji("📱".to_string()),
                                };

                                div().id(ix).child(
                                    ListItem::new(app.name.clone(), list_colors)
                                        .icon_kind(icon)
                                        .description_opt(description)
                                        .selected(is_selected)
                                        .with_accent_bar(true),
                                )
                            } else {
                                div().id(ix).h(px(LIST_ITEM_HEIGHT))
                            }
                        })
                        .collect()
                },
            )
            .h_full()
            .track_scroll(&self.list_scroll_handle)
            .into_any_element()
        };

        div()
            .flex()
            .flex_col()
            .bg(rgba(bg_with_alpha))
            .shadow(box_shadows)
            .w_full()
            .h_full()
            .rounded(px(design_visual.radius_lg))
            .text_color(rgb(text_primary))
            .font_family(design_typography.font_family)
            .key_context("app_launcher")
            .track_focus(&self.focus_handle)
            .on_key_down(handle_key)
            // Header with input
            .child(
                div()
                    .w_full()
                    .px(px(design_spacing.padding_lg))
                    .py(px(design_spacing.padding_md))
                    .flex()
                    .flex_row()
                    .items_center()
                    .gap_3()
                    // Title
                    .child(
                        div()
                            .text_sm()
                            .text_color(rgb(text_dimmed))
                            .child("🚀 Apps"),
                    )
                    // Search input with blinking cursor
                    // ALIGNMENT FIX: Uses canonical cursor constants and negative margin for placeholder
                    .child(
                        div()
                            .flex_1()
                            .flex()
                            .flex_row()
                            .items_center()
                            .text_lg()
                            .text_color(if input_is_empty {
                                rgb(text_muted)
                            } else {
                                rgb(text_primary)
                            })
                            .when(input_is_empty, |d| {
                                d.child(
                                    div()
                                        .w(px(CURSOR_WIDTH))
                                        .h(px(CURSOR_HEIGHT_LG))
                                        .my(px(CURSOR_MARGIN_Y))
                                        .mr(px(CURSOR_GAP_X))
                                        .when(self.cursor_visible, |d| d.bg(rgb(text_primary))),
                                )
                            })
                            .when(input_is_empty, |d| {
                                d.child(
                                    div()
                                        .ml(px(-(CURSOR_WIDTH + CURSOR_GAP_X)))
                                        .child(input_display.clone()),
                                )
                            })
                            .when(!input_is_empty, |d| d.child(input_display.clone()))
                            .when(!input_is_empty, |d| {
                                d.child(
                                    div()
                                        .w(px(CURSOR_WIDTH))
                                        .h(px(CURSOR_HEIGHT_LG))
                                        .my(px(CURSOR_MARGIN_Y))
                                        .ml(px(CURSOR_GAP_X))
                                        .when(self.cursor_visible, |d| d.bg(rgb(text_primary))),
                                )
                            }),
                    )
                    .child(
                        div()
                            .text_sm()
                            .text_color(rgb(text_dimmed))
                            .child(format!("{} apps", self.apps.len())),
                    ),
            )
            // Divider
            .child(
                div()
                    .mx(px(design_spacing.padding_lg))
                    .h(px(design_visual.border_thin))
                    .bg(rgba((ui_border << 8) | 0x60)),
            )
            // App list
            .child(
                div()
                    .flex()
                    .flex_col()
                    .flex_1()
                    .min_h(px(0.))
                    .w_full()
                    .py(px(design_spacing.padding_xs))
                    .child(list_element),
            )
            // Footer
            .child(PromptFooter::new(
                PromptFooterConfig::new()
                    .primary_label("Launch")
                    .primary_shortcut("↵")
                    .show_secondary(false),
                PromptFooterColors::from_design(&design_colors),
            ))
            .into_any_element()
    }

    /// Render window switcher view with 50/50 split layout
    /// P0 FIX: Data comes from self.cached_windows, view passes only state
    fn render_window_switcher(
        &mut self,
        filter: String,
        selected_index: usize,
        cx: &mut Context<Self>,
    ) -> AnyElement {
        // Use design tokens for GLOBAL theming
        let tokens = get_tokens(self.current_design);
        let design_colors = tokens.colors();
        let design_spacing = tokens.spacing();
        let design_typography = tokens.typography();
        let design_visual = tokens.visual();

        // Use design tokens for global theming
        let opacity = self.theme.get_opacity();
        let bg_hex = design_colors.background;
        let bg_with_alpha = crate::ui_foundation::hex_to_rgba_with_opacity(bg_hex, opacity.main);
        let box_shadows = self.create_box_shadows();

        // P0 FIX: Filter windows from self.cached_windows instead of taking ownership
        let filtered_windows: Vec<_> = if filter.is_empty() {
            self.cached_windows.iter().enumerate().collect()
        } else {
            let filter_lower = filter.to_lowercase();
            self.cached_windows
                .iter()
                .enumerate()
                .filter(|(_, w)| {
                    w.title.to_lowercase().contains(&filter_lower)
                        || w.app.to_lowercase().contains(&filter_lower)
                })
                .collect()
        };
        let filtered_len = filtered_windows.len();

        // Key handler for window switcher
        let handle_key = cx.listener(
            move |this: &mut Self,
                  event: &gpui::KeyDownEvent,
                  _window: &mut Window,
                  cx: &mut Context<Self>| {
                // If the shortcut recorder is active, don't process any key events.
                // The recorder has its own key handlers and should receive all key events.
                if this.shortcut_recorder_state.is_some() {
                    return;
                }

                // Global shortcuts (Cmd+W, ESC for dismissable views)
                if this.handle_global_shortcut_with_options(event, true, cx) {
                    return;
                }

                let key_str = event.keystroke.key.to_lowercase();
                logging::log("KEY", &format!("WindowSwitcher key: '{}'", key_str));

                // P0 FIX: View state only - data comes from this.cached_windows
                if let AppView::WindowSwitcherView {
                    filter,
                    selected_index,
                } = &mut this.current_view
                {
                    // Apply filter to get current filtered list
                    // P0 FIX: Reference cached_windows from self
                    let filtered_windows: Vec<_> = if filter.is_empty() {
                        this.cached_windows.iter().enumerate().collect()
                    } else {
                        let filter_lower = filter.to_lowercase();
                        this.cached_windows
                            .iter()
                            .enumerate()
                            .filter(|(_, w)| {
                                w.title.to_lowercase().contains(&filter_lower)
                                    || w.app.to_lowercase().contains(&filter_lower)
                            })
                            .collect()
                    };
                    let filtered_len = filtered_windows.len();

                    match key_str.as_str() {
                        "up" | "arrowup" => {
                            if *selected_index > 0 {
                                *selected_index -= 1;
                                this.window_list_scroll_handle
                                    .scroll_to_item(*selected_index, ScrollStrategy::Nearest);
                                cx.notify();
                            }
                        }
                        "down" | "arrowdown" => {
                            if *selected_index < filtered_len.saturating_sub(1) {
                                *selected_index += 1;
                                this.window_list_scroll_handle
                                    .scroll_to_item(*selected_index, ScrollStrategy::Nearest);
                                cx.notify();
                            }
                        }
                        "enter" => {
                            // Focus selected window and hide Script Kit
                            if let Some((_, window_info)) = filtered_windows.get(*selected_index) {
                                logging::log(
                                    "EXEC",
                                    &format!("Focusing window: {}", window_info.title),
                                );
                                if let Err(e) = window_control::focus_window(window_info.id) {
                                    logging::log(
                                        "ERROR",
                                        &format!("Failed to focus window: {}", e),
                                    );
                                    this.toast_manager.push(
                                        components::toast::Toast::error(
                                            format!("Failed to focus window: {}", e),
                                            &this.theme,
                                        )
                                        .duration_ms(Some(5000)),
                                    );
                                    cx.notify();
                                } else {
                                    logging::log(
                                        "EXEC",
                                        &format!("Focused window: {}", window_info.title),
                                    );
                                    script_kit_gpui::set_main_window_visible(false);
                                    cx.hide();
                                    NEEDS_RESET.store(true, Ordering::SeqCst);
                                }
                            }
                        }
                        // Note: "escape" is handled by handle_global_shortcut_with_options above
                        // Text input (backspace, characters) is handled by the shared Input component
                        // which syncs via handle_filter_input_change()
                        _ => {}
                    }
                }
            },
        );

        // Pre-compute colors
        let list_colors = ListItemColors::from_design(&design_colors);
        let text_primary = design_colors.text_primary;
        #[allow(unused_variables)]
        let text_muted = design_colors.text_muted;
        let text_dimmed = design_colors.text_dimmed;
        let ui_border = design_colors.border;

        // Build virtualized list
        let list_element: AnyElement = if filtered_len == 0 {
            div()
                .w_full()
                .py(px(design_spacing.padding_xl))
                .text_center()
                .text_color(rgb(design_colors.text_muted))
                .font_family(design_typography.font_family)
                .child(if filter.is_empty() {
                    "No windows found"
                } else {
                    "No windows match your filter"
                })
                .into_any_element()
        } else {
            // Clone data for the closure
            let windows_for_closure: Vec<_> = filtered_windows
                .iter()
                .map(|(i, w)| (*i, (*w).clone()))
                .collect();
            let selected = selected_index;

            uniform_list(
                "window-switcher",
                filtered_len,
                move |visible_range, _window, _cx| {
                    visible_range
                        .map(|ix| {
                            if let Some((_, window_info)) = windows_for_closure.get(ix) {
                                let is_selected = ix == selected;

                                // Format: "AppName: Window Title"
                                let name = format!("{}: {}", window_info.app, window_info.title);

                                // Format bounds as description
                                let description = format!(
                                    "{}×{} at ({}, {})",
                                    window_info.bounds.width,
                                    window_info.bounds.height,
                                    window_info.bounds.x,
                                    window_info.bounds.y
                                );

                                div().id(ix).child(
                                    ListItem::new(name, list_colors)
                                        .description_opt(Some(description))
                                        .selected(is_selected)
                                        .with_accent_bar(true),
                                )
                            } else {
                                div().id(ix).h(px(LIST_ITEM_HEIGHT))
                            }
                        })
                        .collect()
                },
            )
            .h_full()
            .track_scroll(&self.window_list_scroll_handle)
            .into_any_element()
        };

        // Build actions panel for selected window
        let selected_window = filtered_windows
            .get(selected_index)
            .map(|(_, w)| (*w).clone());
        let actions_panel = self.render_window_actions_panel(
            &selected_window,
            &design_colors,
            &design_spacing,
            &design_typography,
            &design_visual,
            cx,
        );

        div()
            .flex()
            .flex_col()
            .bg(rgba(bg_with_alpha))
            .shadow(box_shadows)
            .w_full()
            .h_full()
            .rounded(px(design_visual.radius_lg))
            .text_color(rgb(text_primary))
            .font_family(design_typography.font_family)
            .key_context("window_switcher")
            .track_focus(&self.focus_handle)
            .on_key_down(handle_key)
            // Header with input
            .child(
                div()
                    .w_full()
                    .px(px(design_spacing.padding_lg))
                    .py(px(design_spacing.padding_md))
                    .flex()
                    .flex_row()
                    .items_center()
                    .gap_3()
                    // Search input - uses shared gpui_input_state for consistent cursor/selection
                    .child(
                        div().flex_1().flex().flex_row().items_center().child(
                            Input::new(&self.gpui_input_state)
                                .w_full()
                                .h(px(28.))
                                .px(px(0.))
                                .py(px(0.))
                                .with_size(Size::Size(px(design_typography.font_size_xl)))
                                .appearance(false)
                                .bordered(false)
                                .focus_bordered(false),
                        ),
                    )
                    .child(
                        div()
                            .text_sm()
                            .text_color(rgb(text_dimmed))
                            .child(format!("{} windows", self.cached_windows.len())),
                    ),
            )
            // Divider
            .child(
                div()
                    .mx(px(design_spacing.padding_lg))
                    .h(px(design_visual.border_thin))
                    .bg(rgba((ui_border << 8) | 0x60)),
            )
            // Main content area - 50/50 split: Window list on left, Actions on right
            .child(
                div()
                    .flex()
                    .flex_row()
                    .flex_1()
                    .min_h(px(0.))
                    .w_full()
                    .overflow_hidden()
                    // Left side: Window list (50% width)
                    .child(
                        div()
                            .w_1_2()
                            .h_full()
                            .min_h(px(0.))
                            .py(px(design_spacing.padding_xs))
                            .child(list_element),
                    )
                    // Right side: Actions panel (50% width)
                    .child(
                        div()
                            .w_1_2()
                            .h_full()
                            .min_h(px(0.))
                            .overflow_hidden()
                            .child(actions_panel),
                    ),
            )
            // Footer
            .child(PromptFooter::new(
                PromptFooterConfig::new()
                    .primary_label("Switch")
                    .primary_shortcut("↵")
                    .show_secondary(false),
                PromptFooterColors::from_design(&design_colors),
            ))
            .into_any_element()
    }

    /// Render the actions panel for window switcher
    fn render_window_actions_panel(
        &self,
        selected_window: &Option<window_control::WindowInfo>,
        colors: &designs::DesignColors,
        spacing: &designs::DesignSpacing,
        typography: &designs::DesignTypography,
        visual: &designs::DesignVisual,
        _cx: &mut Context<Self>,
    ) -> impl IntoElement {
        let bg_main = colors.background;
        let ui_border = colors.border;
        let text_primary = colors.text_primary;
        let text_muted = colors.text_muted;
        let text_secondary = colors.text_secondary;

        let mut panel = div()
            .w_full()
            .h_full()
            .bg(rgb(bg_main))
            .border_l_1()
            .border_color(rgba((ui_border << 8) | 0x80))
            .p(px(spacing.padding_lg))
            .flex()
            .flex_col()
            .overflow_y_hidden()
            .font_family(typography.font_family);

        match selected_window {
            Some(window) => {
                // Window info header
                panel = panel.child(
                    div()
                        .text_lg()
                        .font_weight(gpui::FontWeight::SEMIBOLD)
                        .text_color(rgb(text_primary))
                        .pb(px(spacing.padding_sm))
                        .child(window.title.clone()),
                );

                // App name
                panel = panel.child(
                    div()
                        .text_sm()
                        .text_color(rgb(text_secondary))
                        .pb(px(spacing.padding_md))
                        .child(window.app.clone()),
                );

                // Bounds info
                panel = panel.child(
                    div()
                        .text_xs()
                        .text_color(rgb(text_muted))
                        .pb(px(spacing.padding_lg))
                        .child(format!(
                            "{}×{} at ({}, {})",
                            window.bounds.width,
                            window.bounds.height,
                            window.bounds.x,
                            window.bounds.y
                        )),
                );

                // Divider
                panel = panel.child(
                    div()
                        .w_full()
                        .h(px(visual.border_thin))
                        .bg(rgba((ui_border << 8) | 0x60))
                        .mb(px(spacing.padding_lg)),
                );

                // Actions header
                panel = panel.child(
                    div()
                        .text_xs()
                        .text_color(rgb(text_muted))
                        .pb(px(spacing.padding_md))
                        .child("Press Enter to focus window"),
                );
            }
            None => {
                // Empty state
                panel = panel.child(
                    div()
                        .w_full()
                        .h_full()
                        .flex()
                        .items_center()
                        .justify_center()
                        .text_color(rgb(text_muted))
                        .child("No window selected"),
                );
            }
        }

        panel
    }

    /// Execute a window action (tile, maximize, minimize, close)
    /// NOTE: Currently unused - kept for future when we add action buttons to the actions panel
    #[allow(dead_code)]
    fn execute_window_action(&mut self, window_id: u32, action: &str, cx: &mut Context<Self>) {
        logging::log(
            "EXEC",
            &format!("Window action: {} on window {}", action, window_id),
        );

        let result = match action {
            "tile_left" => {
                window_control::tile_window(window_id, window_control::TilePosition::LeftHalf)
            }
            "tile_right" => {
                window_control::tile_window(window_id, window_control::TilePosition::RightHalf)
            }
            "tile_top" => {
                window_control::tile_window(window_id, window_control::TilePosition::TopHalf)
            }
            "tile_bottom" => {
                window_control::tile_window(window_id, window_control::TilePosition::BottomHalf)
            }
            "maximize" => window_control::maximize_window(window_id),
            "minimize" => window_control::minimize_window(window_id),
            "close" => window_control::close_window(window_id),
            "focus" => window_control::focus_window(window_id),
            _ => {
                logging::log("ERROR", &format!("Unknown window action: {}", action));
                return;
            }
        };

        match result {
            Ok(()) => {
                logging::log("EXEC", &format!("Window action {} succeeded", action));

                // Show success toast
                self.toast_manager.push(
                    components::toast::Toast::success(
                        format!("Window {}", action.replace("_", " ")),
                        &self.theme,
                    )
                    .duration_ms(Some(2000)),
                );

                // P0 FIX: Refresh window list in self.cached_windows
                if let AppView::WindowSwitcherView { selected_index, .. } = &mut self.current_view {
                    match window_control::list_windows() {
                        Ok(new_windows) => {
                            self.cached_windows = new_windows;
                            // Adjust selected index if needed
                            if *selected_index >= self.cached_windows.len()
                                && !self.cached_windows.is_empty()
                            {
                                *selected_index = self.cached_windows.len() - 1;
                            }
                        }
                        Err(e) => {
                            logging::log("ERROR", &format!("Failed to refresh windows: {}", e));
                        }
                    }
                }
            }
            Err(e) => {
                logging::log("ERROR", &format!("Window action {} failed: {}", action, e));

                // Show error toast
                self.toast_manager.push(
                    components::toast::Toast::error(
                        format!("Failed to {}: {}", action.replace("_", " "), e),
                        &self.theme,
                    )
                    .duration_ms(Some(5000)),
                );
            }
        }

        cx.notify();
    }

    /// Render design gallery view with group header and icon variations
    fn render_design_gallery(
        &mut self,
        filter: String,
        selected_index: usize,
        cx: &mut Context<Self>,
    ) -> AnyElement {
        use designs::group_header_variations::{GroupHeaderCategory, GroupHeaderStyle};
        use designs::icon_variations::{IconCategory, IconName, IconStyle};

        // Use design tokens for GLOBAL theming
        let tokens = get_tokens(self.current_design);
        let design_colors = tokens.colors();
        let design_spacing = tokens.spacing();
        let design_typography = tokens.typography();
        let design_visual = tokens.visual();

        // Use design tokens for global theming
        let opacity = self.theme.get_opacity();
        let bg_hex = design_colors.background;
        let bg_with_alpha = crate::ui_foundation::hex_to_rgba_with_opacity(bg_hex, opacity.main);
        let box_shadows = self.create_box_shadows();

        // Build gallery items: group headers grouped by category, then icons grouped by category
        #[derive(Clone)]
        enum GalleryItem {
            GroupHeaderCategory(GroupHeaderCategory),
            GroupHeader(GroupHeaderStyle),
            IconCategoryHeader(IconCategory),
            Icon(IconName, IconStyle),
        }

        let mut gallery_items: Vec<GalleryItem> = Vec::new();

        // Add group headers by category
        for category in GroupHeaderCategory::all() {
            gallery_items.push(GalleryItem::GroupHeaderCategory(*category));
            for style in category.styles() {
                gallery_items.push(GalleryItem::GroupHeader(*style));
            }
        }

        // Add icons by category, showing each icon with default style
        for category in IconCategory::all() {
            gallery_items.push(GalleryItem::IconCategoryHeader(*category));
            for icon in category.icons() {
                gallery_items.push(GalleryItem::Icon(icon, IconStyle::Default));
            }
        }

        // Filter items based on current filter
        let filtered_items: Vec<(usize, GalleryItem)> = if filter.is_empty() {
            gallery_items
                .iter()
                .enumerate()
                .map(|(i, item)| (i, item.clone()))
                .collect()
        } else {
            let filter_lower = filter.to_lowercase();
            gallery_items
                .iter()
                .enumerate()
                .filter(|(_, item)| match item {
                    GalleryItem::GroupHeaderCategory(cat) => {
                        cat.name().to_lowercase().contains(&filter_lower)
                    }
                    GalleryItem::GroupHeader(style) => {
                        style.name().to_lowercase().contains(&filter_lower)
                            || style.description().to_lowercase().contains(&filter_lower)
                    }
                    GalleryItem::IconCategoryHeader(cat) => {
                        cat.name().to_lowercase().contains(&filter_lower)
                    }
                    GalleryItem::Icon(icon, _) => {
                        icon.name().to_lowercase().contains(&filter_lower)
                            || icon.description().to_lowercase().contains(&filter_lower)
                    }
                })
                .map(|(i, item)| (i, item.clone()))
                .collect()
        };
        let filtered_len = filtered_items.len();

        // Key handler for design gallery
        let handle_key = cx.listener(
            move |this: &mut Self,
                  event: &gpui::KeyDownEvent,
                  _window: &mut Window,
                  cx: &mut Context<Self>| {
                // If the shortcut recorder is active, don't process any key events.
                // The recorder has its own key handlers and should receive all key events.
                if this.shortcut_recorder_state.is_some() {
                    return;
                }

                // Global shortcuts (Cmd+W) - handled first regardless of view state
                // Global shortcuts (Cmd+W, ESC for dismissable views)
                if this.handle_global_shortcut_with_options(event, true, cx) {
                    return;
                }

                let key_str = event.keystroke.key.to_lowercase();
                logging::log("KEY", &format!("DesignGallery key: '{}'", key_str));

                if let AppView::DesignGalleryView {
                    filter,
                    selected_index,
                } = &mut this.current_view
                {
                    // Re-compute filtered_len for this scope
                    let total_items = GroupHeaderStyle::count()
                        + IconName::count()
                        + GroupHeaderCategory::all().len()
                        + IconCategory::all().len();
                    let current_filtered_len = total_items;

                    match key_str.as_str() {
                        "up" | "arrowup" => {
                            if *selected_index > 0 {
                                *selected_index -= 1;
                                this.design_gallery_scroll_handle
                                    .scroll_to_item(*selected_index, ScrollStrategy::Nearest);
                                cx.notify();
                            }
                        }
                        "down" | "arrowdown" => {
                            if *selected_index < current_filtered_len.saturating_sub(1) {
                                *selected_index += 1;
                                this.design_gallery_scroll_handle
                                    .scroll_to_item(*selected_index, ScrollStrategy::Nearest);
                                cx.notify();
                            }
                        }
                        // Note: "escape" is handled by handle_global_shortcut_with_options above
                        "backspace" => {
                            if !filter.is_empty() {
                                filter.pop();
                                *selected_index = 0;
                                this.design_gallery_scroll_handle
                                    .scroll_to_item(0, ScrollStrategy::Top);
                                cx.notify();
                            }
                        }
                        _ => {
                            if let Some(ref key_char) = event.keystroke.key_char {
                                if let Some(ch) = key_char.chars().next() {
                                    if !ch.is_control() {
                                        filter.push(ch);
                                        *selected_index = 0;
                                        this.design_gallery_scroll_handle
                                            .scroll_to_item(0, ScrollStrategy::Top);
                                        cx.notify();
                                    }
                                }
                            }
                        }
                    }
                }
            },
        );

        let input_display = if filter.is_empty() {
            SharedString::from("Search design variations...")
        } else {
            SharedString::from(filter.clone())
        };
        let input_is_empty = filter.is_empty();

        // Pre-compute colors
        let list_colors = ListItemColors::from_design(&design_colors);
        let text_primary = design_colors.text_primary;
        let text_muted = design_colors.text_muted;
        let text_dimmed = design_colors.text_dimmed;
        let ui_border = design_colors.border;
        let _accent = design_colors.accent;

        // Build virtualized list
        let list_element: AnyElement = if filtered_len == 0 {
            div()
                .w_full()
                .py(px(design_spacing.padding_xl))
                .text_center()
                .text_color(rgb(design_colors.text_muted))
                .font_family(design_typography.font_family)
                .child("No items match your filter")
                .into_any_element()
        } else {
            // Clone data for the closure
            let items_for_closure = filtered_items.clone();
            let selected = selected_index;
            let _list_colors_clone = list_colors; // Kept for future use
            let design_spacing_clone = design_spacing;
            let design_typography_clone = design_typography;
            let design_visual_clone = design_visual;
            let design_colors_clone = design_colors;

            uniform_list(
                "design-gallery",
                filtered_len,
                move |visible_range, _window, _cx| {
                    visible_range
                        .map(|ix| {
                            if let Some((_, item)) = items_for_closure.get(ix) {
                                let is_selected = ix == selected;

                                let element: AnyElement = match item {
                                    GalleryItem::GroupHeaderCategory(category) => {
                                        // Category header - styled as section header
                                        div()
                                            .id(ElementId::NamedInteger(
                                                "gallery-header-cat".into(),
                                                ix as u64,
                                            ))
                                            .w_full()
                                            .h(px(32.0))
                                            .px(px(design_spacing_clone.padding_lg))
                                            .flex()
                                            .items_center()
                                            .bg(rgba(
                                                (design_colors_clone.background_secondary << 8)
                                                    | 0x80,
                                            ))
                                            .child(
                                                div()
                                                    .text_sm()
                                                    .font_weight(gpui::FontWeight::BOLD)
                                                    .text_color(rgb(design_colors_clone.accent))
                                                    .child(format!(
                                                        "── Group Headers: {} ──",
                                                        category.name()
                                                    )),
                                            )
                                            .into_any_element()
                                    }
                                    GalleryItem::GroupHeader(style) => render_group_header_item(
                                        ix,
                                        is_selected,
                                        style,
                                        &design_spacing_clone,
                                        &design_typography_clone,
                                        &design_visual_clone,
                                        &design_colors_clone,
                                    ),
                                    GalleryItem::IconCategoryHeader(category) => {
                                        // Icon category header
                                        div()
                                            .id(ElementId::NamedInteger(
                                                "gallery-icon-cat".into(),
                                                ix as u64,
                                            ))
                                            .w_full()
                                            .h(px(32.0))
                                            .px(px(design_spacing_clone.padding_lg))
                                            .flex()
                                            .items_center()
                                            .bg(rgba(
                                                (design_colors_clone.background_secondary << 8)
                                                    | 0x80,
                                            ))
                                            .child(
                                                div()
                                                    .text_sm()
                                                    .font_weight(gpui::FontWeight::BOLD)
                                                    .text_color(rgb(design_colors_clone.accent))
                                                    .child(format!(
                                                        "── Icons: {} ──",
                                                        category.name()
                                                    )),
                                            )
                                            .into_any_element()
                                    }
                                    GalleryItem::Icon(icon, _style) => {
                                        // Render icon item with SVG
                                        let icon_path = icon.external_path();
                                        let name_owned = icon.name().to_string();
                                        let desc_owned = icon.description().to_string();

                                        let mut item_div = div()
                                            .id(ElementId::NamedInteger(
                                                "gallery-icon".into(),
                                                ix as u64,
                                            ))
                                            .w_full()
                                            .h(px(LIST_ITEM_HEIGHT))
                                            .px(px(design_spacing_clone.padding_lg))
                                            .flex()
                                            .flex_row()
                                            .items_center()
                                            .gap(px(design_spacing_clone.gap_md));

                                        if is_selected {
                                            item_div = item_div
                                                .bg(rgb(design_colors_clone.background_selected));
                                        }

                                        item_div
                                            // Icon preview with SVG
                                            .child(
                                                div()
                                                    .w(px(32.0))
                                                    .h(px(32.0))
                                                    .rounded(px(4.0))
                                                    .bg(rgba(
                                                        (design_colors_clone.background_secondary
                                                            << 8)
                                                            | 0x60,
                                                    ))
                                                    .flex()
                                                    .items_center()
                                                    .justify_center()
                                                    .child(
                                                        svg()
                                                            .external_path(icon_path)
                                                            .size(px(16.0))
                                                            .text_color(rgb(
                                                                design_colors_clone.text_primary
                                                            )),
                                                    ),
                                            )
                                            // Name and description
                                            .child(
                                                div()
                                                    .flex_1()
                                                    .flex()
                                                    .flex_col()
                                                    .gap(px(2.0))
                                                    .child(
                                                        div()
                                                            .text_sm()
                                                            .font_weight(gpui::FontWeight::MEDIUM)
                                                            .text_color(rgb(
                                                                design_colors_clone.text_primary
                                                            ))
                                                            .child(name_owned),
                                                    )
                                                    .child(
                                                        div()
                                                            .text_xs()
                                                            .text_color(rgb(
                                                                design_colors_clone.text_muted
                                                            ))
                                                            .overflow_x_hidden()
                                                            .child(desc_owned),
                                                    ),
                                            )
                                            .into_any_element()
                                    }
                                };
                                element
                            } else {
                                div()
                                    .id(ElementId::NamedInteger("gallery-empty".into(), ix as u64))
                                    .h(px(LIST_ITEM_HEIGHT))
                                    .into_any_element()
                            }
                        })
                        .collect()
                },
            )
            .w_full()
            .h_full()
            .track_scroll(&self.design_gallery_scroll_handle)
            .into_any_element()
        };

        // Build the full view
        div()
            .flex()
            .flex_col()
            .bg(rgba(bg_with_alpha))
            .shadow(box_shadows)
            .w_full()
            .h_full()
            .rounded(px(design_visual.radius_lg))
            .text_color(rgb(text_primary))
            .font_family(design_typography.font_family)
            .key_context("design_gallery")
            .track_focus(&self.focus_handle)
            .on_key_down(handle_key)
            // Header with input
            .child(
                div()
                    .w_full()
                    .px(px(design_spacing.padding_lg))
                    .py(px(design_spacing.padding_md))
                    .flex()
                    .flex_row()
                    .items_center()
                    .gap_3()
                    // Gallery icon
                    .child(div().text_xl().child("🎨"))
                    // Search input with blinking cursor
                    // ALIGNMENT FIX: Uses canonical cursor constants and negative margin for placeholder
                    .child(
                        div()
                            .flex_1()
                            .flex()
                            .flex_row()
                            .items_center()
                            .text_lg()
                            .text_color(if input_is_empty {
                                rgb(text_muted)
                            } else {
                                rgb(text_primary)
                            })
                            .when(input_is_empty, |d| {
                                d.child(
                                    div()
                                        .w(px(CURSOR_WIDTH))
                                        .h(px(CURSOR_HEIGHT_LG))
                                        .my(px(CURSOR_MARGIN_Y))
                                        .mr(px(CURSOR_GAP_X))
                                        .when(self.cursor_visible, |d| d.bg(rgb(text_primary))),
                                )
                            })
                            .when(input_is_empty, |d| {
                                d.child(
                                    div()
                                        .ml(px(-(CURSOR_WIDTH + CURSOR_GAP_X)))
                                        .child(input_display.clone()),
                                )
                            })
                            .when(!input_is_empty, |d| d.child(input_display.clone()))
                            .when(!input_is_empty, |d| {
                                d.child(
                                    div()
                                        .w(px(CURSOR_WIDTH))
                                        .h(px(CURSOR_HEIGHT_LG))
                                        .my(px(CURSOR_MARGIN_Y))
                                        .ml(px(CURSOR_GAP_X))
                                        .when(self.cursor_visible, |d| d.bg(rgb(text_primary))),
                                )
                            }),
                    )
                    .child(
                        div()
                            .text_sm()
                            .text_color(rgb(text_dimmed))
                            .child(format!("{} items", filtered_len)),
                    ),
            )
            // Divider
            .child(
                div()
                    .mx(px(design_spacing.padding_lg))
                    .h(px(design_visual.border_thin))
                    .bg(rgba((ui_border << 8) | 0x60)),
            )
            // Main content area - just the list (no preview panel for gallery)
            .child(
                div()
                    .flex_1()
                    .w_full()
                    .h_full()
                    .min_h(px(0.))
                    .overflow_hidden()
                    .py(px(design_spacing.padding_xs))
                    .child(list_element),
            )
            // Footer
            .child(PromptFooter::new(
                PromptFooterConfig::new()
                    .primary_label("Select")
                    .primary_shortcut("↵")
                    .show_secondary(false),
                PromptFooterColors::from_design(&design_colors),
            ))
            .into_any_element()
    }

    /// Render file search view with 50/50 split (list + preview)
    pub(crate) fn render_file_search(
        &mut self,
        query: &str,
        selected_index: usize,
        cx: &mut Context<Self>,
    ) -> AnyElement {
        use crate::file_search::{self, FileType};

        // Use design tokens for theming
        let tokens = get_tokens(self.current_design);
        let design_colors = tokens.colors();
        let design_spacing = tokens.spacing();
        let _design_typography = tokens.typography();
        let design_visual = tokens.visual();

        let _opacity = self.theme.get_opacity();
        // bg_with_alpha removed - let vibrancy show through from Root (matches main menu)
        let box_shadows = self.create_box_shadows();

        // Color values for use in closures
        let text_primary = design_colors.text_primary;
        let text_muted = design_colors.text_muted;
        let text_dimmed = design_colors.text_dimmed;
        let ui_border = design_colors.border;
        let _accent_color = design_colors.accent;
        let list_hover = design_colors.background_hover;
        let list_selected = design_colors.background_selected;

        // Filter results based on query
        // When query is a directory path, extract the filter component for instant filtering
        // e.g., ~/dev/fin -> filter by "fin" on directory contents
        let filter_pattern = if let Some(parsed) = crate::file_search::parse_directory_path(query) {
            parsed.filter // Some("fin") or None
        } else if !query.is_empty() {
            // Not a directory path - use query as filter for search results
            Some(query.to_string())
        } else {
            None
        };

        // Use Nucleo fuzzy matching for filtering - gives better match quality ranking
        let filtered_results: Vec<_> = if let Some(ref pattern) = filter_pattern {
            file_search::filter_results_nucleo_simple(&self.cached_file_results, pattern)
        } else {
            // No filter - show all results
            self.cached_file_results.iter().enumerate().collect()
        };
        let filtered_len = filtered_results.len();

        // Get selected file for preview (if any)
        let selected_file = filtered_results
            .get(selected_index)
            .map(|(_, r)| (*r).clone());

        // Key handler for file search
        let handle_key = cx.listener(
            move |this: &mut Self,
                  event: &gpui::KeyDownEvent,
                  window: &mut Window,
                  cx: &mut Context<Self>| {
                // If the shortcut recorder is active, don't process any key events.
                // The recorder has its own key handlers and should receive all key events.
                if this.shortcut_recorder_state.is_some() {
                    return;
                }

                let key_str = event.keystroke.key.to_lowercase();
                let key_char = event.keystroke.key_char.as_deref();
                let has_cmd = event.keystroke.modifiers.platform;

                // Route keys to actions dialog first if it's open
                match this.route_key_to_actions_dialog(
                    &key_str,
                    key_char,
                    ActionsDialogHost::FileSearch,
                    window,
                    cx,
                ) {
                    ActionsRoute::NotHandled => {
                        // Actions dialog not open - continue to file search key handling
                    }
                    ActionsRoute::Handled => {
                        // Key was consumed by actions dialog
                        return;
                    }
                    ActionsRoute::Execute { action_id } => {
                        // User selected an action - execute it
                        // Use handle_action instead of trigger_action_by_name to support
                        // both built-in actions (open_file, quick_look, etc.) and SDK actions
                        this.handle_action(action_id, cx);
                        return;
                    }
                }

                // ESC goes back to main menu (not close window)
                if key_str == "escape" {
                    logging::log("KEY", "ESC in FileSearch - returning to main menu");
                    // Cancel any pending search
                    this.file_search_debounce_task = None;
                    this.file_search_loading = false;
                    // Clear cached results
                    this.cached_file_results.clear();
                    // Return to main menu
                    this.current_view = AppView::ScriptList;
                    this.filter_text.clear();
                    this.selected_index = 0;
                    // Sync input and reset placeholder to default
                    this.gpui_input_state.update(cx, |state, cx| {
                        state.set_value("", window, cx);
                        state.set_placeholder(DEFAULT_PLACEHOLDER.to_string(), window, cx);
                    });
                    this.update_window_size();
                    cx.notify();
                    return;
                }

                // Cmd+W closes window
                if has_cmd && key_str == "w" {
                    logging::log("KEY", "Cmd+W - closing window");
                    this.close_and_reset_window(cx);
                    return;
                }

                if let AppView::FileSearchView {
                    query,
                    selected_index,
                } = &mut this.current_view
                {
                    // Apply filter to get current filtered list
                    // Use parse_directory_path to extract filter pattern
                    let filter_pattern =
                        if let Some(parsed) = crate::file_search::parse_directory_path(query) {
                            parsed.filter
                        } else if !query.is_empty() {
                            Some(query.clone())
                        } else {
                            None
                        };

                    // Use Nucleo fuzzy matching for filtering
                    let filtered_results: Vec<_> = if let Some(ref pattern) = filter_pattern {
                        crate::file_search::filter_results_nucleo_simple(
                            &this.cached_file_results,
                            pattern,
                        )
                    } else {
                        this.cached_file_results.iter().enumerate().collect()
                    };
                    let filtered_len = filtered_results.len();

                    match key_str.as_str() {
                        "up" | "arrowup" => {
                            if *selected_index > 0 {
                                *selected_index -= 1;
                                this.file_search_scroll_handle
                                    .scroll_to_item(*selected_index, ScrollStrategy::Nearest);
                                cx.notify();
                            }
                        }
                        "down" | "arrowdown" => {
                            if *selected_index + 1 < filtered_len {
                                *selected_index += 1;
                                this.file_search_scroll_handle
                                    .scroll_to_item(*selected_index, ScrollStrategy::Nearest);
                                cx.notify();
                            }
                        }
                        // Tab/Shift+Tab handled by intercept_keystrokes in app_impl.rs
                        // (interceptor fires BEFORE input component can capture Tab)
                        "enter" => {
                            // Check for Cmd+Enter (reveal in finder) first
                            if has_cmd {
                                if let Some((_, file)) = filtered_results.get(*selected_index) {
                                    let _ = file_search::reveal_in_finder(&file.path);
                                }
                            } else {
                                // Open file with default app
                                if let Some((_, file)) = filtered_results.get(*selected_index) {
                                    let _ = file_search::open_file(&file.path);
                                    // Close window after opening file
                                    this.close_and_reset_window(cx);
                                }
                            }
                        }
                        _ => {
                            // Handle Cmd+K (toggle actions)
                            if has_cmd && key_str == "k" {
                                if let Some((_, file)) = filtered_results.get(*selected_index) {
                                    // Clone the file to avoid borrow issues
                                    let file_clone = (*file).clone();
                                    this.toggle_file_search_actions(&file_clone, window, cx);
                                }
                                return;
                            }
                            // Handle Cmd+Y (Quick Look) - macOS only
                            #[cfg(target_os = "macos")]
                            if has_cmd && key_str == "y" {
                                if let Some((_, file)) = filtered_results.get(*selected_index) {
                                    let _ = file_search::quick_look(&file.path);
                                }
                                return;
                            }
                            // Handle Cmd+I (Show Info) - macOS only
                            #[cfg(target_os = "macos")]
                            if has_cmd && key_str == "i" {
                                if let Some((_, file)) = filtered_results.get(*selected_index) {
                                    let _ = file_search::show_info(&file.path);
                                }
                            }
                            // Handle Cmd+O (Open With) - macOS only
                            #[cfg(target_os = "macos")]
                            if has_cmd && key_str == "o" {
                                if let Some((_, file)) = filtered_results.get(*selected_index) {
                                    let _ = file_search::open_with(&file.path);
                                }
                            }
                        }
                    }
                }
            },
        );

        // Clone data for the uniform_list closure
        let files_for_closure: Vec<_> = filtered_results
            .iter()
            .map(|(_, file)| (*file).clone())
            .collect();
        let current_selected = selected_index;
        let is_loading = self.file_search_loading;

        // Use uniform_list for virtualized scrolling
        // Show appropriate state based on loading and results
        let list_element = if is_loading && filtered_len == 0 {
            // Loading state - show "Searching..." instead of empty list
            div()
                .w_full()
                .py(px(design_spacing.padding_xl))
                .text_center()
                .text_color(rgb(text_dimmed))
                .child("Searching...")
                .into_any_element()
        } else if filtered_len == 0 {
            // No results and not loading
            div()
                .w_full()
                .py(px(design_spacing.padding_xl))
                .text_center()
                .text_color(rgb(text_dimmed))
                .child(if query.is_empty() {
                    "Type to search files"
                } else {
                    "No files found"
                })
                .into_any_element()
        } else {
            uniform_list(
                "file-search-list",
                filtered_len,
                move |visible_range, _window, _cx| {
                    visible_range
                        .map(|ix| {
                            if let Some(file) = files_for_closure.get(ix) {
                                let is_selected = ix == current_selected;
                                let bg = if is_selected {
                                    rgba((list_selected << 8) | 0xFF)
                                } else {
                                    rgba(0x00000000)
                                };
                                let hover_bg = rgba((list_hover << 8) | 0x80);

                                div()
                                    .id(ix)
                                    .w_full()
                                    .h(px(52.))
                                    .flex()
                                    .flex_row()
                                    .items_center()
                                    .px(px(12.))
                                    .gap(px(12.))
                                    .bg(bg)
                                    .hover(move |s| s.bg(hover_bg))
                                    .child(
                                        div()
                                            .text_lg()
                                            .text_color(rgb(text_muted))
                                            .child(file_search::file_type_icon(file.file_type)),
                                    )
                                    .child(
                                        div()
                                            .flex_1()
                                            .flex()
                                            .flex_col()
                                            .gap(px(2.))
                                            .child(
                                                div()
                                                    .text_sm()
                                                    .text_color(rgb(text_primary))
                                                    .child(file.name.clone()),
                                            )
                                            .child(
                                                div()
                                                    .text_xs()
                                                    .text_color(rgb(text_dimmed))
                                                    .child(file_search::shorten_path(&file.path)),
                                            ),
                                    )
                                    .child(
                                        div()
                                            .flex()
                                            .flex_col()
                                            .items_end()
                                            .gap(px(2.))
                                            .child(
                                                div().text_xs().text_color(rgb(text_dimmed)).child(
                                                    file_search::format_file_size(file.size),
                                                ),
                                            )
                                            .child(
                                                div().text_xs().text_color(rgb(text_dimmed)).child(
                                                    file_search::format_relative_time(
                                                        file.modified,
                                                    ),
                                                ),
                                            ),
                                    )
                            } else {
                                div().id(ix).h(px(52.))
                            }
                        })
                        .collect()
                },
            )
            .h_full()
            .track_scroll(&self.file_search_scroll_handle)
            .into_any_element()
        };

        // Build preview panel content - matching main menu labeled section pattern
        let preview_content = if let Some(file) = &selected_file {
            let file_type_str = match file.file_type {
                FileType::Directory => "Folder",
                FileType::Image => "Image",
                FileType::Audio => "Audio",
                FileType::Video => "Video",
                FileType::Document => "Document",
                FileType::Application => "Application",
                FileType::File => "File",
                FileType::Other => "File",
            };

            div()
                .flex_1()
                .flex()
                .flex_col()
                .p(px(design_spacing.padding_lg))
                .gap(px(design_spacing.gap_md))
                .overflow_y_hidden()
                // Name section (labeled like main menu)
                .child(
                    div()
                        .flex()
                        .flex_col()
                        .pb(px(design_spacing.padding_md))
                        .child(
                            div()
                                .text_xs()
                                .text_color(rgb(text_muted))
                                .pb(px(design_spacing.padding_xs / 2.0))
                                .child("Name"),
                        )
                        .child(
                            div()
                                .flex()
                                .flex_row()
                                .items_center()
                                .gap(px(design_spacing.gap_sm))
                                .child(
                                    div()
                                        .text_lg()
                                        .font_weight(gpui::FontWeight::SEMIBOLD)
                                        .text_color(rgb(text_primary))
                                        .child(file.name.clone()),
                                )
                                .child(
                                    div()
                                        .px(px(6.))
                                        .py(px(2.))
                                        .rounded(px(4.))
                                        .bg(rgba((ui_border << 8) | 0x40))
                                        .text_xs()
                                        .text_color(rgb(text_muted))
                                        .child(file_type_str),
                                ),
                        ),
                )
                // Path section (labeled)
                .child(
                    div()
                        .flex()
                        .flex_col()
                        .pb(px(design_spacing.padding_md))
                        .child(
                            div()
                                .text_xs()
                                .text_color(rgb(text_muted))
                                .pb(px(design_spacing.padding_xs / 2.0))
                                .child("Path"),
                        )
                        .child(
                            div()
                                .text_sm()
                                .text_color(rgb(text_dimmed))
                                .child(file.path.clone()),
                        ),
                )
                // Divider (like main menu)
                .child(
                    div()
                        .w_full()
                        .h(px(design_visual.border_thin))
                        .bg(rgba((ui_border << 8) | 0x60))
                        .my(px(design_spacing.padding_sm)),
                )
                // Details section (labeled)
                .child(
                    div()
                        .flex()
                        .flex_col()
                        .child(
                            div()
                                .text_xs()
                                .text_color(rgb(text_muted))
                                .pb(px(design_spacing.padding_xs / 2.0))
                                .child("Details"),
                        )
                        .child(
                            div()
                                .flex()
                                .flex_col()
                                .gap(px(design_spacing.gap_sm))
                                .child(div().text_sm().text_color(rgb(text_dimmed)).child(format!(
                                    "Size: {}",
                                    file_search::format_file_size(file.size)
                                )))
                                .child(div().text_sm().text_color(rgb(text_dimmed)).child(format!(
                                    "Modified: {}",
                                    file_search::format_relative_time(file.modified)
                                )))
                                .child(
                                    div()
                                        .text_sm()
                                        .text_color(rgb(text_dimmed))
                                        .child(format!("Type: {}", file_type_str)),
                                ),
                        ),
                )
        } else {
            div().flex_1().flex().items_center().justify_center().child(
                div()
                    .text_sm()
                    .text_color(rgb(text_dimmed))
                    .child("No file selected"),
            )
        };

        // Main container - styled to match main menu exactly
        // NOTE: No border to match main menu (border adds visual padding/shift)
        div()
            .key_context("FileSearchView")
            .track_focus(&self.focus_handle)
            .on_key_down(handle_key)
            .w_full()
            .h_full()
            .flex()
            .flex_col()
            // Removed: .bg(rgba(bg_with_alpha)) - let vibrancy show through from Root
            .shadow(box_shadows)
            .rounded(px(design_visual.radius_lg))
            // Header with search input - styled to match main menu exactly
            // Uses shared header constants (HEADER_PADDING_X/Y, CURSOR_HEIGHT_LG) for visual consistency.
            // The right-side element uses same py(4px) padding as main menu's "Ask AI" button
            // to ensure identical flex row height (28px) and input vertical centering.
            .child({
                // Calculate input height using same formula as main menu
                let input_height = CURSOR_HEIGHT_LG + (CURSOR_MARGIN_Y * 2.0);

                div()
                    .w_full()
                    .px(px(HEADER_PADDING_X))
                    .py(px(HEADER_PADDING_Y))
                    .flex()
                    .flex_row()
                    .items_center()
                    .gap(px(HEADER_GAP))
                    // Search input - matches main menu Input styling for visual consistency
                    // NOTE: Removed search icon to match main menu alignment exactly
                    .child(
                        div().flex_1().flex().flex_row().items_center().child(
                            Input::new(&self.gpui_input_state)
                                .w_full()
                                .h(px(input_height))
                                .px(px(0.))
                                .py(px(0.))
                                .with_size(Size::Size(px(_design_typography.font_size_xl)))
                                .appearance(false)
                                .bordered(false)
                                .focus_bordered(false),
                        ),
                    )
                    // Right-side element styled to match main menu's "Ask AI" button height
                    // Using same py(4px) padding ensures consistent flex row height (28px)
                    .child(
                        div().flex().flex_row().items_center().py(px(4.)).child(
                            div()
                                .text_sm()
                                .text_color(rgb(text_dimmed))
                                .child(if is_loading {
                                    "Searching...".to_string()
                                } else {
                                    format!("{} files", filtered_len)
                                }),
                        ),
                    )
            })
            // Divider
            .child(
                div()
                    .mx(px(design_spacing.padding_lg))
                    .h(px(design_visual.border_thin))
                    .bg(rgba((ui_border << 8) | 0x60)),
            )
            // Main content: centered empty state OR 50/50 split
            .child(if filtered_len == 0 && !is_loading {
                // Empty state: single centered message (no awkward 50/50 split)
                div()
                    .flex_1()
                    .w_full()
                    .flex()
                    .items_center()
                    .justify_center()
                    .min_h(px(0.))
                    .child(
                        div().flex().flex_col().items_center().gap(px(8.)).child(
                            div()
                                .text_color(rgb(text_dimmed))
                                .child(if query.is_empty() {
                                    "Type to search files"
                                } else {
                                    "No files found"
                                }),
                        ),
                    )
            } else {
                // Normal state: 50/50 split with list and preview
                div()
                    .flex_1()
                    .w_full()
                    .flex()
                    .flex_row()
                    .min_h(px(0.))
                    .overflow_hidden()
                    // Left panel: file list (50%)
                    .child(
                        div()
                            .flex_1()
                            .h_full()
                            .overflow_hidden()
                            .border_r(px(design_visual.border_thin))
                            .border_color(rgba((ui_border << 8) | 0x40))
                            .child(list_element),
                    )
                    // Right panel: preview (50%)
                    .child(
                        div()
                            .flex_1()
                            .h_full()
                            .overflow_hidden()
                            .child(preview_content),
                    )
            })
            // Footer
            .child(PromptFooter::new(
                PromptFooterConfig::new()
                    .primary_label("Open")
                    .primary_shortcut("↵"),
                // Default config already has secondary_label="Actions", secondary_shortcut="⌘K", show_secondary=true
                PromptFooterColors::from_design(&design_colors),
            ))
            .into_any_element()
    }
}

</file>

<file path="src/ui_foundation.rs">
//! UI Foundation - Shared UI patterns for consistent vibrancy and layout
//!
//! This module extracts common UI patterns from the main menu (render_script_list.rs)
//! into reusable helpers. The main menu is the "gold standard" for vibrancy support.
//!
//! NOTE: Many items are currently unused as this is a foundation module.
//! They will be used as other modules are refactored to use the shared patterns.
#![allow(dead_code)]
//!
//! # Key Vibrancy Pattern (from render_script_list.rs:699-707)
//!
//! ```ignore
//! // VIBRANCY: Remove background from content div - let gpui-component Root's
//! // semi-transparent background handle vibrancy effect. Content areas should NOT
//! // have their own backgrounds to allow blur to show through.
//! let _bg_with_alpha = self.hex_to_rgba_with_opacity(bg_hex, opacity.main);
//!
//! let mut main_div = div()
//!     .flex()
//!     .flex_col()
//!     // Removed: .bg(rgba(bg_with_alpha)) - let vibrancy show through from Root
//!     .shadow(box_shadows)
//! ```
//!
//! # Usage
//!
//! ```ignore
//! use crate::ui_foundation::{get_vibrancy_background, container_div, content_div};
//!
//! // In your render function:
//! let bg = get_vibrancy_background(&theme);
//! let container = container_div()
//!     .when_some(bg, |d, bg| d.bg(bg))
//!     .child(content_div().child(...));
//! ```

use gpui::{px, Div, Hsla, Rgba, Styled};

use crate::designs::{get_tokens, DesignColors, DesignSpacing, DesignVariant};
use crate::theme::{ColorScheme, Theme};

/// Convert a hex color (u32) to RGBA with specified opacity.
///
/// This is the standard way to create semi-transparent colors for vibrancy support.
/// The hex color provides RGB values, and opacity controls the alpha channel.
///
/// # Arguments
/// * `hex` - A u32 hex color (e.g., 0x1E1E1E for dark gray)
/// * `opacity` - Alpha value from 0.0 (transparent) to 1.0 (opaque)
///
/// # Returns
/// A u32 suitable for use with `gpui::rgba()` - format is 0xRRGGBBAA
///
/// # Example (from main menu)
/// ```ignore
/// let bg_hex = theme.colors.background.main; // 0x1E1E1E
/// let opacity = theme.get_opacity().main;     // 0.30
/// let bg_with_alpha = hex_to_rgba_with_opacity(bg_hex, opacity);
/// // Result: 0x1E1E1E4D (30% opacity)
/// ```
#[inline]
pub fn hex_to_rgba_with_opacity(hex: u32, opacity: f32) -> u32 {
    // Convert opacity (0.0-1.0) to alpha byte (0x00-0xFF)
    let alpha = (opacity.clamp(0.0, 1.0) * 255.0) as u32;
    // Shift hex left 8 bits and add alpha
    (hex << 8) | alpha
}

/// Convert a hex color to HSLA with specified alpha.
///
/// Used when GPUI components expect Hsla instead of Rgba.
///
/// # Arguments
/// * `hex` - A u32 hex color
/// * `alpha` - Alpha value from 0.0 to 1.0
///
/// # Returns
/// An Hsla color with the specified alpha
#[inline]
pub fn hex_to_hsla_with_alpha(hex: u32, alpha: f32) -> Hsla {
    let rgba = gpui::rgb(hex);
    let hsla: Hsla = rgba.into();
    Hsla {
        h: hsla.h,
        s: hsla.s,
        l: hsla.l,
        a: alpha.clamp(0.0, 1.0),
    }
}

/// Get the background color for vibrancy-aware containers.
///
/// **CRITICAL VIBRANCY PATTERN:** When vibrancy is enabled, content divs should NOT
/// have their own backgrounds. Instead, they rely on the gpui-component Root wrapper
/// to provide a semi-transparent background that allows blur to show through.
///
/// # Arguments
/// * `theme` - The current theme
///
/// # Returns
/// * `None` when vibrancy is enabled (let Root handle the background)
/// * `Some(Rgba)` when vibrancy is disabled (use solid background)
///
/// # Example (from main menu render_script_list.rs)
/// ```ignore
/// let bg = get_vibrancy_background(&self.theme);
/// let main_div = div()
///     .flex()
///     .flex_col()
///     .when_some(bg, |d, bg| d.bg(bg)) // Only apply bg when vibrancy disabled
///     .shadow(box_shadows);
/// ```
pub fn get_vibrancy_background(theme: &Theme) -> Option<Rgba> {
    if theme.is_vibrancy_enabled() {
        // VIBRANCY: Let Root's semi-transparent background handle blur
        None
    } else {
        // No vibrancy: use solid background
        Some(gpui::rgb(theme.colors.background.main))
    }
}

/// Get container background with optional opacity for semi-transparent areas.
///
/// Use this for inner containers that need subtle backgrounds even with vibrancy.
/// For example, log panels or input fields that need slight visual separation.
///
/// # Arguments
/// * `theme` - The current theme
/// * `opacity` - Opacity to apply (0.0-1.0)
///
/// # Returns
/// An Rgba color with the specified opacity applied
///
/// # Example
/// ```ignore
/// let log_bg = get_container_background(&theme, theme.get_opacity().log_panel);
/// div().bg(log_bg).child(logs)
/// ```
pub fn get_container_background(theme: &Theme, opacity: f32) -> Rgba {
    let hex = theme.colors.background.main;
    let rgba_u32 = hex_to_rgba_with_opacity(hex, opacity);
    gpui::rgba(rgba_u32)
}

/// Design colors extracted from tokens, ready for use in UI rendering.
///
/// This provides a consistent interface whether using the Default design
/// (which uses theme.colors) or other design variants (which use design tokens).
#[derive(Clone, Copy)]
pub struct UIDesignColors {
    /// Background color (hex)
    pub background: u32,
    /// Primary text color (hex)
    pub text_primary: u32,
    /// Secondary/muted text color (hex)
    pub text_muted: u32,
    /// Dimmed text color (hex)
    pub text_dimmed: u32,
    /// Accent/highlight color (hex)
    pub accent: u32,
    /// Border color (hex)
    pub border: u32,
}

impl UIDesignColors {
    /// Create design colors from theme (for Default design variant)
    pub fn from_theme(theme: &Theme) -> Self {
        Self {
            background: theme.colors.background.main,
            text_primary: theme.colors.text.primary,
            text_muted: theme.colors.text.muted,
            text_dimmed: theme.colors.text.dimmed,
            accent: theme.colors.accent.selected,
            border: theme.colors.ui.border,
        }
    }

    /// Create design colors from design tokens
    pub fn from_design(colors: &DesignColors) -> Self {
        Self {
            background: colors.background,
            text_primary: colors.text_primary,
            text_muted: colors.text_muted,
            text_dimmed: colors.text_dimmed,
            accent: colors.accent,
            border: colors.border,
        }
    }

    /// Get design colors based on variant - uses theme for Default, tokens for others
    pub fn for_variant(variant: DesignVariant, theme: &Theme) -> Self {
        if variant == DesignVariant::Default {
            Self::from_theme(theme)
        } else {
            let tokens = get_tokens(variant);
            Self::from_design(&tokens.colors())
        }
    }
}

/// Get design colors for the current design variant.
///
/// This abstracts the pattern of choosing between theme.colors (Default design)
/// and design tokens (other designs).
///
/// # Arguments
/// * `variant` - The current design variant
/// * `theme` - The current theme
///
/// # Returns
/// Design colors appropriate for the variant
///
/// # Example (from main menu)
/// ```ignore
/// let design_colors = get_design_colors(self.current_design, &self.theme);
/// let text_color = rgb(design_colors.text_primary);
/// ```
pub fn get_design_colors(variant: DesignVariant, theme: &Theme) -> UIDesignColors {
    UIDesignColors::for_variant(variant, theme)
}

/// Get design spacing values for the current design variant.
///
/// # Arguments
/// * `variant` - The current design variant
///
/// # Returns
/// Design spacing tokens
pub fn get_design_spacing(variant: DesignVariant) -> DesignSpacing {
    let tokens = get_tokens(variant);
    tokens.spacing()
}

/// Opacity configuration extracted from theme, with helper methods.
///
/// This wraps the theme's BackgroundOpacity with convenient accessors.
#[derive(Clone, Copy)]
pub struct OpacityConfig {
    /// Main background opacity
    pub main: f32,
    /// Title bar opacity
    pub title_bar: f32,
    /// Search box/input opacity
    pub search_box: f32,
    /// Log panel opacity
    pub log_panel: f32,
    /// Selected item opacity
    pub selected: f32,
    /// Hovered item opacity
    pub hover: f32,
    /// Preview panel opacity
    pub preview: f32,
    /// Dialog/popup opacity
    pub dialog: f32,
    /// Input field opacity
    pub input: f32,
    /// Panel/container opacity
    pub panel: f32,
    /// Input inactive state opacity
    pub input_inactive: f32,
    /// Input active state opacity
    pub input_active: f32,
    /// Border inactive state opacity
    pub border_inactive: f32,
    /// Border active state opacity
    pub border_active: f32,
}

impl OpacityConfig {
    /// Create from theme
    pub fn from_theme(theme: &Theme) -> Self {
        let o = theme.get_opacity();
        Self {
            main: o.main,
            title_bar: o.title_bar,
            search_box: o.search_box,
            log_panel: o.log_panel,
            selected: o.selected,
            hover: o.hover,
            preview: o.preview,
            dialog: o.dialog,
            input: o.input,
            panel: o.panel,
            input_inactive: o.input_inactive,
            input_active: o.input_active,
            border_inactive: o.border_inactive,
            border_active: o.border_active,
        }
    }
}

/// Get opacity configuration from theme.
///
/// # Example
/// ```ignore
/// let opacity = get_opacity_config(&theme);
/// let bg = hex_to_rgba_with_opacity(bg_hex, opacity.main);
/// ```
pub fn get_opacity_config(theme: &Theme) -> OpacityConfig {
    OpacityConfig::from_theme(theme)
}

// ============================================================================
// Layout Primitives
// ============================================================================

/// Create a standard container div with flex column layout.
///
/// This is the base pattern for main content containers, matching the
/// main menu's structure.
///
/// # Returns
/// A `Div` configured with:
/// - `flex()` - Enable flexbox
/// - `flex_col()` - Column direction
/// - `w_full()` - Full width
/// - `h_full()` - Full height
///
/// # Example (from main menu)
/// ```ignore
/// let main_div = container_div()
///     .shadow(box_shadows)
///     .rounded(px(border_radius))
///     .child(...);
/// ```
pub fn container_div() -> Div {
    gpui::div().flex().flex_col().w_full().h_full()
}

/// Create a content area div with proper overflow handling.
///
/// Use this for content areas that may need scrolling or contain lists.
/// The `min_h(px(0.))` is critical for proper flex shrinking.
///
/// # Returns
/// A `Div` configured with:
/// - `flex()` - Enable flexbox
/// - `flex_col()` - Column direction
/// - `flex_1()` - Grow to fill available space
/// - `w_full()` - Full width
/// - `min_h(px(0.))` - Critical: allows flex container to shrink properly
/// - `overflow_hidden()` - Clip overflow content
///
/// # Example (from main menu)
/// ```ignore
/// main_div = main_div.child(
///     content_div()
///         .flex_row() // Override to row for split layout
///         .child(list_panel)
///         .child(preview_panel)
/// );
/// ```
pub fn content_div() -> Div {
    gpui::div()
        .flex()
        .flex_col()
        .flex_1()
        .w_full()
        .min_h(px(0.)) // Critical: allows flex container to shrink properly
        .overflow_hidden()
}

/// Create a panel div for split-view layouts (like list/preview).
///
/// # Arguments
/// * `width_fraction` - The width as a fraction (e.g., 0.5 for half width)
///
/// # Returns
/// A `Div` configured for panel layout with proper shrinking
pub fn panel_div() -> Div {
    gpui::div()
        .h_full()
        .min_h(px(0.)) // Allow shrinking
        .overflow_hidden()
}

// ============================================================================
// Color Scheme Helpers
// ============================================================================

/// Extension trait for ColorScheme to provide convenient color access.
pub trait ColorSchemeExt {
    /// Get text color for selection state
    fn text_for_selection(&self, is_selected: bool) -> u32;

    /// Get description color for selection state
    fn description_for_selection(&self, is_selected: bool) -> u32;
}

impl ColorSchemeExt for ColorScheme {
    fn text_for_selection(&self, is_selected: bool) -> u32 {
        if is_selected {
            self.text.primary
        } else {
            self.text.secondary
        }
    }

    fn description_for_selection(&self, is_selected: bool) -> u32 {
        if is_selected {
            self.accent.selected // Use accent color for selected item description
        } else {
            self.text.secondary
        }
    }
}

// ============================================================================
// HexColorExt - Extension trait for u32 hex colors
// ============================================================================

/// Extension trait for u32 hex colors to provide convenient color conversion.
///
/// This eliminates the need for manual `rgb(colors.*)` calls and `<< 8 | alpha`
/// packing throughout the codebase.
///
/// # Example
/// ```ignore
/// use crate::ui_foundation::HexColorExt;
///
/// let colors = theme.colors;
/// // Instead of: rgb(colors.text.primary)
/// // Use: colors.text.primary.to_rgb()
///
/// // Instead of: rgba((colors.border << 8) | 0x80)
/// // Use: colors.border.rgba8(0x80)
///
/// // Instead of manual opacity calculation:
/// // Use: colors.background.with_opacity(0.5)
/// ```
pub trait HexColorExt {
    /// Convert hex color to GPUI Hsla (fully opaque).
    ///
    /// Replaces `rgb(color)` calls.
    fn to_rgb(self) -> Hsla;

    /// Convert hex color to GPUI Hsla with alpha byte (0-255).
    ///
    /// Replaces `rgba((color << 8) | alpha)` patterns.
    fn rgba8(self, alpha: u8) -> Hsla;

    /// Convert hex color to GPUI Hsla with opacity float (0.0-1.0).
    ///
    /// More readable than manual alpha calculation.
    fn with_opacity(self, opacity: f32) -> Hsla;
}

impl HexColorExt for u32 {
    #[inline]
    fn to_rgb(self) -> Hsla {
        gpui::rgb(self).into()
    }

    #[inline]
    fn rgba8(self, alpha: u8) -> Hsla {
        gpui::rgba((self << 8) | alpha as u32).into()
    }

    #[inline]
    fn with_opacity(self, opacity: f32) -> Hsla {
        let alpha = (opacity.clamp(0.0, 1.0) * 255.0) as u8;
        gpui::rgba((self << 8) | alpha as u32).into()
    }
}

// ============================================================================
// Layout Primitives - Free functions for common patterns
// ============================================================================

/// Create a vertical stack (flex column).
///
/// Replaces `div().flex().flex_col()` pattern.
#[inline]
pub fn vstack() -> Div {
    gpui::div().flex().flex_col()
}

/// Create a horizontal stack (flex row with centered items).
///
/// Replaces `div().flex().flex_row().items_center()` pattern.
#[inline]
pub fn hstack() -> Div {
    gpui::div().flex().flex_row().items_center()
}

/// Create a centered container (items centered both axes).
///
/// Replaces `div().flex().items_center().justify_center()` pattern.
#[inline]
pub fn centered() -> Div {
    gpui::div().flex().items_center().justify_center()
}

/// Create a flexible spacer that fills available space.
///
/// Replaces `div().flex_1()` pattern.
#[inline]
pub fn spacer() -> Div {
    gpui::div().flex_1()
}

// ============================================================================
// Key Normalization - Allocation-free key matching
// ============================================================================
//
// IMPORTANT: These helpers use eq_ignore_ascii_case() instead of to_lowercase()
// to avoid allocations on every keystroke. This is a hot path optimization.

/// Check if key is an up arrow (handles both "up" and "arrowup" formats).
///
/// Uses allocation-free ASCII case-insensitive comparison.
#[inline]
pub fn is_key_up(key: &str) -> bool {
    key.eq_ignore_ascii_case("up") || key.eq_ignore_ascii_case("arrowup")
}

/// Check if key is a down arrow (handles both "down" and "arrowdown" formats).
///
/// Uses allocation-free ASCII case-insensitive comparison.
#[inline]
pub fn is_key_down(key: &str) -> bool {
    key.eq_ignore_ascii_case("down") || key.eq_ignore_ascii_case("arrowdown")
}

/// Check if key is a left arrow (handles both "left" and "arrowleft" formats).
///
/// Uses allocation-free ASCII case-insensitive comparison.
#[inline]
pub fn is_key_left(key: &str) -> bool {
    key.eq_ignore_ascii_case("left") || key.eq_ignore_ascii_case("arrowleft")
}

/// Check if key is a right arrow (handles both "right" and "arrowright" formats).
///
/// Uses allocation-free ASCII case-insensitive comparison.
#[inline]
pub fn is_key_right(key: &str) -> bool {
    key.eq_ignore_ascii_case("right") || key.eq_ignore_ascii_case("arrowright")
}

/// Check if key is Enter/Return.
///
/// Uses allocation-free ASCII case-insensitive comparison.
#[inline]
pub fn is_key_enter(key: &str) -> bool {
    key.eq_ignore_ascii_case("enter") || key.eq_ignore_ascii_case("return")
}

/// Check if key is Escape.
///
/// Uses allocation-free ASCII case-insensitive comparison.
#[inline]
pub fn is_key_escape(key: &str) -> bool {
    key.eq_ignore_ascii_case("escape") || key.eq_ignore_ascii_case("esc")
}

/// Check if key is Backspace.
///
/// Uses allocation-free ASCII case-insensitive comparison.
#[inline]
pub fn is_key_backspace(key: &str) -> bool {
    key.eq_ignore_ascii_case("backspace")
}

/// Check if key is the "k" key (for Cmd+K shortcut).
///
/// Uses allocation-free ASCII case-insensitive comparison.
#[inline]
pub fn is_key_k(key: &str) -> bool {
    key.eq_ignore_ascii_case("k")
}

/// Extract printable character from a KeyDownEvent's key_char field.
///
/// Returns Some(char) if the key_char contains a non-control character,
/// None otherwise (for special keys like arrows, escape, etc.).
#[inline]
pub fn printable_char(key_char: Option<&str>) -> Option<char> {
    key_char
        .and_then(|s| s.chars().next())
        .filter(|ch| !ch.is_control())
}

#[cfg(test)]
mod tests {
    use super::*;

    // ========================================================================
    // HexColorExt Tests
    // ========================================================================

    #[test]
    fn test_hex_color_to_rgb() {
        // White should convert correctly
        let white = 0xFFFFFFu32.to_rgb();
        assert!(
            (white.l - 1.0).abs() < 0.01,
            "White should have lightness ~1.0"
        );

        // Black should convert correctly
        let black = 0x000000u32.to_rgb();
        assert!(black.l < 0.01, "Black should have lightness ~0.0");

        // Alpha should be 1.0 (fully opaque)
        assert!(
            (white.a - 1.0).abs() < 0.001,
            "to_rgb should be fully opaque"
        );
        assert!(
            (black.a - 1.0).abs() < 0.001,
            "to_rgb should be fully opaque"
        );
    }

    #[test]
    fn test_hex_color_rgba8() {
        // Test with 50% alpha (0x80 = 128)
        let semi = 0xFFFFFFu32.rgba8(0x80);
        // Alpha should be approximately 128/255 = 0.502
        assert!(
            (semi.a - 0.502).abs() < 0.01,
            "rgba8(0x80) should have ~50% alpha, got {}",
            semi.a
        );

        // Test with 0 alpha
        let transparent = 0xFFFFFFu32.rgba8(0x00);
        assert!(
            transparent.a < 0.01,
            "rgba8(0x00) should be fully transparent"
        );

        // Test with full alpha
        let opaque = 0xFFFFFFu32.rgba8(0xFF);
        assert!(
            (opaque.a - 1.0).abs() < 0.01,
            "rgba8(0xFF) should be fully opaque"
        );
    }

    #[test]
    fn test_hex_color_with_opacity() {
        // 50% opacity
        let half = 0xFFFFFFu32.with_opacity(0.5);
        assert!(
            (half.a - 0.5).abs() < 0.02,
            "with_opacity(0.5) should have ~50% alpha, got {}",
            half.a
        );

        // 0% opacity
        let transparent = 0xFFFFFFu32.with_opacity(0.0);
        assert!(
            transparent.a < 0.01,
            "with_opacity(0.0) should be fully transparent"
        );

        // 100% opacity
        let opaque = 0xFFFFFFu32.with_opacity(1.0);
        assert!(
            (opaque.a - 1.0).abs() < 0.01,
            "with_opacity(1.0) should be fully opaque"
        );
    }

    #[test]
    fn test_hex_color_opacity_clamping() {
        // Opacity > 1.0 should clamp to 1.0
        let over = 0xFFFFFFu32.with_opacity(1.5);
        assert!(
            (over.a - 1.0).abs() < 0.01,
            "with_opacity(1.5) should clamp to 1.0"
        );

        // Opacity < 0.0 should clamp to 0.0
        let under = 0xFFFFFFu32.with_opacity(-0.5);
        assert!(under.a < 0.01, "with_opacity(-0.5) should clamp to 0.0");
    }

    // ========================================================================
    // Key Normalization Tests (Allocation-free helpers)
    // ========================================================================

    #[test]
    fn test_is_key_up() {
        // All valid forms
        assert!(is_key_up("up"));
        assert!(is_key_up("Up"));
        assert!(is_key_up("UP"));
        assert!(is_key_up("arrowup"));
        assert!(is_key_up("ArrowUp"));
        assert!(is_key_up("ARROWUP"));
        // Invalid
        assert!(!is_key_up("down"));
        assert!(!is_key_up("left"));
        assert!(!is_key_up("enter"));
    }

    #[test]
    fn test_is_key_down() {
        assert!(is_key_down("down"));
        assert!(is_key_down("Down"));
        assert!(is_key_down("DOWN"));
        assert!(is_key_down("arrowdown"));
        assert!(is_key_down("ArrowDown"));
        assert!(is_key_down("ARROWDOWN"));
        assert!(!is_key_down("up"));
        assert!(!is_key_down("right"));
    }

    #[test]
    fn test_is_key_left() {
        assert!(is_key_left("left"));
        assert!(is_key_left("Left"));
        assert!(is_key_left("arrowleft"));
        assert!(is_key_left("ArrowLeft"));
        assert!(!is_key_left("right"));
        assert!(!is_key_left("up"));
    }

    #[test]
    fn test_is_key_right() {
        assert!(is_key_right("right"));
        assert!(is_key_right("Right"));
        assert!(is_key_right("arrowright"));
        assert!(is_key_right("ArrowRight"));
        assert!(!is_key_right("left"));
        assert!(!is_key_right("down"));
    }

    #[test]
    fn test_is_key_enter() {
        assert!(is_key_enter("enter"));
        assert!(is_key_enter("Enter"));
        assert!(is_key_enter("ENTER"));
        assert!(is_key_enter("return"));
        assert!(is_key_enter("Return"));
        assert!(!is_key_enter("escape"));
        assert!(!is_key_enter("space"));
    }

    #[test]
    fn test_is_key_escape() {
        assert!(is_key_escape("escape"));
        assert!(is_key_escape("Escape"));
        assert!(is_key_escape("ESCAPE"));
        assert!(is_key_escape("esc"));
        assert!(is_key_escape("Esc"));
        assert!(!is_key_escape("enter"));
    }

    #[test]
    fn test_is_key_backspace() {
        assert!(is_key_backspace("backspace"));
        assert!(is_key_backspace("Backspace"));
        assert!(is_key_backspace("BACKSPACE"));
        assert!(!is_key_backspace("delete"));
        assert!(!is_key_backspace("enter"));
    }

    #[test]
    fn test_is_key_k() {
        assert!(is_key_k("k"));
        assert!(is_key_k("K"));
        assert!(!is_key_k("j"));
        assert!(!is_key_k("enter"));
    }

    #[test]
    fn test_printable_char() {
        // Normal printable chars
        assert_eq!(printable_char(Some("a")), Some('a'));
        assert_eq!(printable_char(Some("A")), Some('A'));
        assert_eq!(printable_char(Some("1")), Some('1'));
        assert_eq!(printable_char(Some("!")), Some('!'));
        assert_eq!(printable_char(Some(" ")), Some(' '));

        // Control characters should return None
        assert_eq!(printable_char(Some("\n")), None);
        assert_eq!(printable_char(Some("\t")), None);
        assert_eq!(printable_char(Some("\x1b")), None); // ESC

        // Empty/None cases
        assert_eq!(printable_char(None), None);
        assert_eq!(printable_char(Some("")), None);
    }

    // ========================================================================
    // Original Tests
    // ========================================================================

    #[test]
    fn test_hex_to_rgba_with_opacity() {
        // Test 30% opacity (0.30 * 255 = 76.5 -> truncates to 76 = 0x4C)
        let result = hex_to_rgba_with_opacity(0x1E1E1E, 0.30);
        assert_eq!(result, 0x1E1E1E4C);

        // Test full opacity
        let result = hex_to_rgba_with_opacity(0xFFFFFF, 1.0);
        assert_eq!(result, 0xFFFFFFFF);

        // Test zero opacity
        let result = hex_to_rgba_with_opacity(0x000000, 0.0);
        assert_eq!(result, 0x00000000);

        // Test 50% opacity (0.5 * 255 = 127.5 -> truncates to 127 = 0x7F)
        let result = hex_to_rgba_with_opacity(0xABCDEF, 0.5);
        assert_eq!(result, 0xABCDEF7F);
    }

    #[test]
    fn test_opacity_clamping() {
        // Test opacity > 1.0 gets clamped
        let result = hex_to_rgba_with_opacity(0x123456, 1.5);
        assert_eq!(result, 0x123456FF);

        // Test opacity < 0.0 gets clamped
        let result = hex_to_rgba_with_opacity(0x123456, -0.5);
        assert_eq!(result, 0x12345600);
    }

    #[test]
    fn test_vibrancy_background_with_default_theme() {
        let theme = Theme::default();
        // Default theme has vibrancy enabled
        let bg = get_vibrancy_background(&theme);
        // Should return None when vibrancy is enabled
        assert!(bg.is_none());
    }
}

</file>

</files>