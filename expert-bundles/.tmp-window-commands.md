This file is a merged representation of the filtered codebase, combined into a single document by packx.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of filtered repository contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<usage_guidelines>
- Treat this file as a snapshot of the repository's state
- Be aware that this file may contain sensitive information
</usage_guidelines>

<notes>
- Files were filtered by packx based on content and extension matching
- Total files included: 12
</notes>
</file_summary>

<directory_structure>
src/window_control.rs
src/window_control_enhanced/capabilities.rs
src/window_control_enhanced/mod.rs
src/window_control_enhanced/bounds.rs
src/window_control_enhanced/coords.rs
src/window_control_enhanced/spaces.rs
src/window_control_enhanced/display.rs
src/window_state.rs
src/window_resize.rs
src/window_ops.rs
src/window_manager.rs
src/system_actions.rs
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="src/window_control.rs">
//! Window Control module using macOS Accessibility APIs
//!
//! This module provides window management functionality including:
//! - Listing all visible windows with their properties
//! - Moving, resizing, minimizing, maximizing, and closing windows
//! - Tiling windows to predefined positions (halves, quadrants, fullscreen)
//!
//! ## Architecture
//!
//! Uses macOS Accessibility APIs (AXUIElement) to control windows across applications.
//! The accessibility framework allows querying and modifying window properties for any
//! application, provided the user has granted accessibility permissions.
//!
//! ## Permissions
//!
//! Requires Accessibility permission in System Preferences > Privacy & Security > Accessibility
//!

#![allow(non_upper_case_globals)]
#![allow(dead_code)]

use anyhow::{bail, Context, Result};
use core_graphics::display::{CGDisplay, CGRect};
use macos_accessibility_client::accessibility;
use std::ffi::c_void;
use tracing::{debug, info, instrument, warn};

// ============================================================================
// CoreFoundation FFI bindings
// ============================================================================

#[link(name = "CoreFoundation", kind = "framework")]
extern "C" {
    fn CFRelease(cf: *const c_void);
    fn CFRetain(cf: *const c_void) -> *const c_void;
}

// ============================================================================
// ApplicationServices (Accessibility) FFI bindings
// ============================================================================

#[link(name = "ApplicationServices", kind = "framework")]
extern "C" {
    fn AXUIElementCreateSystemWide() -> AXUIElementRef;
    fn AXUIElementCreateApplication(pid: i32) -> AXUIElementRef;
    fn AXUIElementCopyAttributeValue(
        element: AXUIElementRef,
        attribute: CFStringRef,
        value: *mut CFTypeRef,
    ) -> i32;
    fn AXUIElementSetAttributeValue(
        element: AXUIElementRef,
        attribute: CFStringRef,
        value: CFTypeRef,
    ) -> i32;
    fn AXUIElementPerformAction(element: AXUIElementRef, action: CFStringRef) -> i32;
    fn AXValueCreate(value_type: i32, value: *const c_void) -> AXValueRef;
    fn AXValueGetValue(value: AXValueRef, value_type: i32, value_out: *mut c_void) -> bool;
    fn AXValueGetType(value: AXValueRef) -> i32;
}

// AXValue types
const kAXValueTypeCGPoint: i32 = 1;
const kAXValueTypeCGSize: i32 = 2;

// AXError codes
const kAXErrorSuccess: i32 = 0;
const kAXErrorAPIDisabled: i32 = -25211;
const kAXErrorNoValue: i32 = -25212;

type AXUIElementRef = *const c_void;
type AXValueRef = *const c_void;
type CFTypeRef = *const c_void;
type CFStringRef = *const c_void;
type CFArrayRef = *const c_void;

// ============================================================================
// CoreFoundation String FFI bindings
// ============================================================================

#[link(name = "CoreFoundation", kind = "framework")]
extern "C" {
    fn CFStringCreateWithCString(
        alloc: *const c_void,
        c_str: *const i8,
        encoding: u32,
    ) -> CFStringRef;
    fn CFStringGetCString(
        string: CFStringRef,
        buffer: *mut i8,
        buffer_size: i64,
        encoding: u32,
    ) -> bool;
    fn CFStringGetLength(string: CFStringRef) -> i64;
    fn CFArrayGetCount(array: CFArrayRef) -> i64;
    fn CFArrayGetValueAtIndex(array: CFArrayRef, index: i64) -> CFTypeRef;
    fn CFGetTypeID(cf: CFTypeRef) -> u64;
    fn CFStringGetTypeID() -> u64;
    fn CFNumberGetValue(number: CFTypeRef, number_type: i32, value_ptr: *mut c_void) -> bool;
}

const kCFStringEncodingUTF8: u32 = 0x08000100;
const kCFNumberSInt32Type: i32 = 3;

// ============================================================================
// AppKit (NSWorkspace/NSRunningApplication) FFI bindings
// ============================================================================

#[link(name = "AppKit", kind = "framework")]
extern "C" {
    // We'll use objc crate for AppKit access instead of direct FFI
}

// ============================================================================
// Public Types
// ============================================================================

/// Represents the bounds (position and size) of a window
#[derive(Debug, Clone, Copy, PartialEq)]
pub struct Bounds {
    pub x: i32,
    pub y: i32,
    pub width: u32,
    pub height: u32,
}

impl Bounds {
    /// Create a new Bounds
    pub fn new(x: i32, y: i32, width: u32, height: u32) -> Self {
        Self {
            x,
            y,
            width,
            height,
        }
    }

    /// Create bounds from CoreGraphics CGRect
    fn from_cg_rect(rect: CGRect) -> Self {
        Self {
            x: rect.origin.x as i32,
            y: rect.origin.y as i32,
            width: rect.size.width as u32,
            height: rect.size.height as u32,
        }
    }
}

/// Information about a window
#[derive(Debug, Clone)]
pub struct WindowInfo {
    /// Unique window identifier (process ID << 16 | window index)
    pub id: u32,
    /// Application name
    pub app: String,
    /// Window title
    pub title: String,
    /// Window position and size
    pub bounds: Bounds,
    /// Process ID of the owning application
    pub pid: i32,
    /// The AXUIElement reference (internal, for operations)
    #[doc(hidden)]
    ax_window: Option<usize>, // Store as usize to avoid lifetime issues
}

impl WindowInfo {
    /// Get the internal window reference for operations
    fn window_ref(&self) -> Option<AXUIElementRef> {
        self.ax_window.map(|ptr| ptr as AXUIElementRef)
    }
}

/// Tiling positions for windows
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum TilePosition {
    /// Left half of the screen
    LeftHalf,
    /// Right half of the screen
    RightHalf,
    /// Top half of the screen
    TopHalf,
    /// Bottom half of the screen
    BottomHalf,
    /// Top-left quadrant
    TopLeft,
    /// Top-right quadrant
    TopRight,
    /// Bottom-left quadrant
    BottomLeft,
    /// Bottom-right quadrant
    BottomRight,
    /// Fullscreen (covers entire display)
    Fullscreen,
}

// ============================================================================
// Helper Functions
// ============================================================================

/// Create a CFString from a Rust string
fn create_cf_string(s: &str) -> CFStringRef {
    unsafe {
        let c_str = std::ffi::CString::new(s).unwrap();
        CFStringCreateWithCString(std::ptr::null(), c_str.as_ptr(), kCFStringEncodingUTF8)
    }
}

/// Convert a CFString to a Rust String
fn cf_string_to_string(cf_string: CFStringRef) -> Option<String> {
    if cf_string.is_null() {
        return None;
    }

    unsafe {
        let length = CFStringGetLength(cf_string);
        if length <= 0 {
            return Some(String::new());
        }

        // Allocate buffer with extra space for UTF-8 expansion
        let buffer_size = (length * 4 + 1) as usize;
        let mut buffer: Vec<i8> = vec![0; buffer_size];

        if CFStringGetCString(
            cf_string,
            buffer.as_mut_ptr(),
            buffer_size as i64,
            kCFStringEncodingUTF8,
        ) {
            let c_str = std::ffi::CStr::from_ptr(buffer.as_ptr());
            c_str.to_str().ok().map(|s| s.to_string())
        } else {
            None
        }
    }
}

/// Release a CoreFoundation object
fn cf_release(cf: CFTypeRef) {
    if !cf.is_null() {
        unsafe {
            CFRelease(cf);
        }
    }
}

/// Retain a CoreFoundation object (increment reference count)
/// Returns the same pointer for convenience
fn cf_retain(cf: CFTypeRef) -> CFTypeRef {
    if !cf.is_null() {
        unsafe { CFRetain(cf) }
    } else {
        cf
    }
}

/// Get an attribute value from an AXUIElement
fn get_ax_attribute(element: AXUIElementRef, attribute: &str) -> Result<CFTypeRef> {
    let attr_str = create_cf_string(attribute);
    let mut value: CFTypeRef = std::ptr::null();

    let result =
        unsafe { AXUIElementCopyAttributeValue(element, attr_str, &mut value as *mut CFTypeRef) };

    cf_release(attr_str);

    match result {
        kAXErrorSuccess => Ok(value),
        kAXErrorAPIDisabled => bail!("Accessibility API is disabled"),
        kAXErrorNoValue => bail!("No value for attribute: {}", attribute),
        _ => bail!("Failed to get attribute {}: error {}", attribute, result),
    }
}

/// Set an attribute value on an AXUIElement
fn set_ax_attribute(element: AXUIElementRef, attribute: &str, value: CFTypeRef) -> Result<()> {
    let attr_str = create_cf_string(attribute);

    let result = unsafe { AXUIElementSetAttributeValue(element, attr_str, value) };

    cf_release(attr_str);

    match result {
        kAXErrorSuccess => Ok(()),
        kAXErrorAPIDisabled => bail!("Accessibility API is disabled"),
        _ => bail!("Failed to set attribute {}: error {}", attribute, result),
    }
}

/// Perform an action on an AXUIElement
fn perform_ax_action(element: AXUIElementRef, action: &str) -> Result<()> {
    let action_str = create_cf_string(action);

    let result = unsafe { AXUIElementPerformAction(element, action_str) };

    cf_release(action_str);

    match result {
        kAXErrorSuccess => Ok(()),
        kAXErrorAPIDisabled => bail!("Accessibility API is disabled"),
        _ => bail!("Failed to perform action {}: error {}", action, result),
    }
}

/// Get the position of a window
fn get_window_position(window: AXUIElementRef) -> Result<(i32, i32)> {
    let value = get_ax_attribute(window, "AXPosition")?;

    let mut point = core_graphics::geometry::CGPoint::new(0.0, 0.0);
    let success = unsafe {
        AXValueGetValue(
            value,
            kAXValueTypeCGPoint,
            &mut point as *mut _ as *mut c_void,
        )
    };

    cf_release(value);

    if success {
        Ok((point.x as i32, point.y as i32))
    } else {
        bail!("Failed to extract position value")
    }
}

/// Get the size of a window
fn get_window_size(window: AXUIElementRef) -> Result<(u32, u32)> {
    let value = get_ax_attribute(window, "AXSize")?;

    let mut size = core_graphics::geometry::CGSize::new(0.0, 0.0);
    let success = unsafe {
        AXValueGetValue(
            value,
            kAXValueTypeCGSize,
            &mut size as *mut _ as *mut c_void,
        )
    };

    cf_release(value);

    if success {
        Ok((size.width as u32, size.height as u32))
    } else {
        bail!("Failed to extract size value")
    }
}

/// Set the position of a window
fn set_window_position(window: AXUIElementRef, x: i32, y: i32) -> Result<()> {
    let point = core_graphics::geometry::CGPoint::new(x as f64, y as f64);
    let value = unsafe { AXValueCreate(kAXValueTypeCGPoint, &point as *const _ as *const c_void) };

    if value.is_null() {
        bail!("Failed to create AXValue for position");
    }

    let result = set_ax_attribute(window, "AXPosition", value);
    cf_release(value);
    result
}

/// Set the size of a window
fn set_window_size(window: AXUIElementRef, width: u32, height: u32) -> Result<()> {
    let size = core_graphics::geometry::CGSize::new(width as f64, height as f64);
    let value = unsafe { AXValueCreate(kAXValueTypeCGSize, &size as *const _ as *const c_void) };

    if value.is_null() {
        bail!("Failed to create AXValue for size");
    }

    let result = set_ax_attribute(window, "AXSize", value);
    cf_release(value);
    result
}

/// Get the string value of a window attribute
fn get_window_string_attribute(window: AXUIElementRef, attribute: &str) -> Option<String> {
    match get_ax_attribute(window, attribute) {
        Ok(value) => {
            // Check if it's a CFString
            let type_id = unsafe { CFGetTypeID(value) };
            let string_type_id = unsafe { CFStringGetTypeID() };

            let result = if type_id == string_type_id {
                cf_string_to_string(value as CFStringRef)
            } else {
                None
            };

            cf_release(value);
            result
        }
        Err(_) => None,
    }
}

/// Get the main display bounds
fn get_main_display_bounds() -> Bounds {
    let main_display = CGDisplay::main();
    let rect = main_display.bounds();
    Bounds::from_cg_rect(rect)
}

/// Get the display bounds for the display containing a point
fn get_display_bounds_at_point(_x: i32, _y: i32) -> Bounds {
    // For simplicity, we'll use the main display
    // A more complete implementation would find the display containing the point
    get_main_display_bounds()
}

// ============================================================================
// Window Cache for lookups
// ============================================================================

use std::collections::HashMap;
use std::sync::{Mutex, OnceLock};

/// Global window cache using OnceLock (std alternative to lazy_static)
static WINDOW_CACHE: OnceLock<Mutex<HashMap<u32, usize>>> = OnceLock::new();

/// Get or initialize the window cache
fn get_cache() -> &'static Mutex<HashMap<u32, usize>> {
    WINDOW_CACHE.get_or_init(|| Mutex::new(HashMap::new()))
}

fn cache_window(id: u32, window_ref: AXUIElementRef) {
    if let Ok(mut cache) = get_cache().lock() {
        cache.insert(id, window_ref as usize);
    }
}

fn get_cached_window(id: u32) -> Option<AXUIElementRef> {
    get_cache()
        .lock()
        .ok()
        .and_then(|cache| cache.get(&id).map(|&ptr| ptr as AXUIElementRef))
}

fn clear_window_cache() {
    if let Ok(mut cache) = get_cache().lock() {
        // Release all retained window refs before clearing
        for &window_ptr in cache.values() {
            cf_release(window_ptr as CFTypeRef);
        }
        cache.clear();
    }
}

// ============================================================================
// Public API
// ============================================================================

/// Check if accessibility permissions are granted.
///
/// Window control operations require the application to have accessibility
/// permissions granted by the user.
///
/// # Returns
/// `true` if permission is granted, `false` otherwise.
#[instrument]
pub fn has_accessibility_permission() -> bool {
    let result = accessibility::application_is_trusted();
    debug!(granted = result, "Checked accessibility permission");
    result
}

/// Request accessibility permissions (opens System Preferences).
///
/// # Returns
/// `true` if permission is granted after the request, `false` otherwise.
#[instrument]
pub fn request_accessibility_permission() -> bool {
    info!("Requesting accessibility permission for window control");
    accessibility::application_is_trusted_with_prompt()
}

/// List all visible windows across all applications.
///
/// Returns a vector of `WindowInfo` structs containing window metadata.
/// Windows are filtered to only include visible, standard windows.
///
/// # Returns
/// A vector of window information structs.
///
/// # Errors
/// Returns error if accessibility permission is not granted.
///
#[instrument]
pub fn list_windows() -> Result<Vec<WindowInfo>> {
    if !has_accessibility_permission() {
        bail!("Accessibility permission required for window control");
    }

    // Clear the cache before listing
    clear_window_cache();

    let mut windows = Vec::new();

    // Get list of running applications using objc
    unsafe {
        use objc::runtime::{Class, Object};
        use objc::{msg_send, sel, sel_impl};

        let workspace_class = Class::get("NSWorkspace").context("Failed to get NSWorkspace")?;
        let workspace: *mut Object = msg_send![workspace_class, sharedWorkspace];
        let running_apps: *mut Object = msg_send![workspace, runningApplications];
        let app_count: usize = msg_send![running_apps, count];

        for i in 0..app_count {
            let app: *mut Object = msg_send![running_apps, objectAtIndex: i];

            // Check activation policy (skip background apps)
            let activation_policy: i64 = msg_send![app, activationPolicy];
            if activation_policy != 0 {
                // 0 = NSApplicationActivationPolicyRegular
                continue;
            }

            // Get app name
            let app_name: *mut Object = msg_send![app, localizedName];
            let app_name_str = if !app_name.is_null() {
                let utf8: *const i8 = msg_send![app_name, UTF8String];
                if !utf8.is_null() {
                    std::ffi::CStr::from_ptr(utf8)
                        .to_str()
                        .unwrap_or("Unknown")
                        .to_string()
                } else {
                    "Unknown".to_string()
                }
            } else {
                "Unknown".to_string()
            };

            // Get PID
            let pid: i32 = msg_send![app, processIdentifier];

            // Create AXUIElement for this application
            let ax_app = AXUIElementCreateApplication(pid);
            if ax_app.is_null() {
                continue;
            }

            // Get windows for this app
            if let Ok(windows_value) = get_ax_attribute(ax_app, "AXWindows") {
                let window_count = CFArrayGetCount(windows_value as CFArrayRef);

                for j in 0..window_count {
                    // CFArrayGetValueAtIndex returns a borrowed reference - we must retain
                    // if we want to keep it beyond the array's lifetime
                    let ax_window = CFArrayGetValueAtIndex(windows_value as CFArrayRef, j);

                    // Get window title
                    let title = get_window_string_attribute(ax_window as AXUIElementRef, "AXTitle")
                        .unwrap_or_default();

                    // Skip windows without titles (often utility windows)
                    if title.is_empty() {
                        continue;
                    }

                    // Get window position and size
                    let (x, y) = get_window_position(ax_window as AXUIElementRef).unwrap_or((0, 0));
                    let (width, height) =
                        get_window_size(ax_window as AXUIElementRef).unwrap_or((0, 0));

                    // Skip very small windows (likely invisible or popups)
                    if width < 50 || height < 50 {
                        continue;
                    }

                    // Create a unique window ID: (pid << 16) | window_index
                    let window_id = ((pid as u32) << 16) | (j as u32);

                    // Retain the window ref before caching - CFArrayGetValueAtIndex returns
                    // a borrowed reference, so we need to retain it to extend its lifetime
                    // beyond when we release windows_value
                    let retained_window = cf_retain(ax_window);
                    cache_window(window_id, retained_window as AXUIElementRef);

                    windows.push(WindowInfo {
                        id: window_id,
                        app: app_name_str.clone(),
                        title,
                        bounds: Bounds::new(x, y, width, height),
                        pid,
                        ax_window: Some(retained_window as usize),
                    });
                }

                // Release windows_value - AXUIElementCopyAttributeValue returns an owned
                // CF object that we must release (the "Copy" in the name means we own it)
                cf_release(windows_value);
            }

            // Release ax_app - AXUIElementCreateApplication returns an owned CF object
            cf_release(ax_app);
        }
    }

    info!(window_count = windows.len(), "Listed windows");
    Ok(windows)
}

/// Get the PID of the application that owns the menu bar.
///
/// When Script Kit (an accessory/LSUIElement app) is active, it does NOT take
/// menu bar ownership. The previously active "regular" app still owns the menu bar.
/// This is exactly what we need for window actions - we want to act on the
/// window that was focused before Script Kit was shown.
///
/// # Returns
/// The process identifier (PID) of the menu bar owning application.
///
/// # Errors
/// Returns error if no menu bar owner is found or if the PID is invalid.
#[instrument]
pub fn get_menu_bar_owner_pid() -> Result<i32> {
    unsafe {
        use objc::runtime::{Class, Object};
        use objc::{msg_send, sel, sel_impl};

        let workspace_class = Class::get("NSWorkspace").context("Failed to get NSWorkspace")?;
        let workspace: *mut Object = msg_send![workspace_class, sharedWorkspace];
        let menu_owner: *mut Object = msg_send![workspace, menuBarOwningApplication];

        if menu_owner.is_null() {
            bail!("No menu bar owning application found");
        }

        let pid: i32 = msg_send![menu_owner, processIdentifier];

        if pid <= 0 {
            bail!("Invalid process identifier for menu bar owner");
        }

        // Log for debugging
        let name: *mut Object = msg_send![menu_owner, localizedName];
        let name_str = if !name.is_null() {
            let utf8: *const i8 = msg_send![name, UTF8String];
            if !utf8.is_null() {
                std::ffi::CStr::from_ptr(utf8).to_str().unwrap_or("unknown")
            } else {
                "unknown"
            }
        } else {
            "unknown"
        };

        info!(pid, app_name = name_str, "Got menu bar owner");
        Ok(pid)
    }
}

/// Get the frontmost window of the menu bar owning application.
///
/// This is the key function for window actions from Script Kit. When the user
/// executes "Tile Window Left" etc., we want to act on the window they were
/// using before invoking Script Kit, not Script Kit's own window.
///
/// Since Script Kit is an LSUIElement (accessory app), it doesn't take menu bar
/// ownership. The menu bar owner is the previously active app.
///
/// # Window Selection Strategy
///
/// 1. First try AXFocusedWindow - the actual focused window of the app
/// 2. If that fails, try AXMainWindow - the app's designated "main" window
/// 3. Fall back to first window in AXWindows array if neither works
///
/// This is more accurate than just picking the first window with matching pid,
/// which can return the wrong window if the app has multiple windows open.
///
/// # Returns
/// The focused/main window of the menu bar owning application, or None if
/// no windows are found.
#[instrument]
pub fn get_frontmost_window_of_previous_app() -> Result<Option<WindowInfo>> {
    let target_pid = get_menu_bar_owner_pid()?;

    unsafe {
        // Create AX element for the target application
        let ax_app = AXUIElementCreateApplication(target_pid);
        if ax_app.is_null() {
            warn!(target_pid, "Failed to create AXUIElement for app");
            return Ok(None);
        }

        // Strategy 1: Try to get the focused window (most accurate)
        let focused_window = get_ax_attribute(ax_app as AXUIElementRef, "AXFocusedWindow")
            .ok()
            .filter(|&w| !w.is_null());

        // Strategy 2: Fall back to main window
        let target_window = focused_window.or_else(|| {
            get_ax_attribute(ax_app as AXUIElementRef, "AXMainWindow")
                .ok()
                .filter(|&w| !w.is_null())
        });

        // Strategy 3: Fall back to first window in AXWindows list
        let target_window = target_window.or_else(|| {
            if let Ok(windows_value) = get_ax_attribute(ax_app as AXUIElementRef, "AXWindows") {
                let count = CFArrayGetCount(windows_value as CFArrayRef);
                if count > 0 {
                    let window = CFArrayGetValueAtIndex(windows_value as CFArrayRef, 0);
                    // Retain the window ref since CFArrayGetValueAtIndex returns borrowed
                    let retained = cf_retain(window);
                    cf_release(windows_value);
                    Some(retained)
                } else {
                    cf_release(windows_value);
                    None
                }
            } else {
                None
            }
        });

        // Release ax_app - we're done with it
        cf_release(ax_app);

        // If we found a target window, build WindowInfo for it
        if let Some(window_ref) = target_window {
            let ax_window = window_ref as AXUIElementRef;

            // Get window attributes
            let title = get_window_string_attribute(ax_window, "AXTitle").unwrap_or_default();
            let (x, y) = get_window_position(ax_window).unwrap_or((0, 0));
            let (width, height) = get_window_size(ax_window).unwrap_or((0, 0));

            // Get app name for logging
            let app_name = get_app_name_for_pid(target_pid);

            // Create a window ID (focused window uses index 0)
            let window_id = (target_pid as u32) << 16;

            // Cache the window reference for subsequent operations
            cache_window(window_id, ax_window);

            let window_info = WindowInfo {
                id: window_id,
                app: app_name.clone(),
                title: title.clone(),
                bounds: Bounds::new(x, y, width, height),
                pid: target_pid,
                ax_window: Some(window_ref as usize),
            };

            info!(
                window_id = window_info.id,
                app = %app_name,
                title = %title,
                "Found focused/main window of previous app via AX"
            );

            Ok(Some(window_info))
        } else {
            warn!(
                target_pid,
                "No focused or main window found for menu bar owner"
            );
            Ok(None)
        }
    }
}

/// Get the localized app name for a given PID.
fn get_app_name_for_pid(pid: i32) -> String {
    unsafe {
        use objc::runtime::{Class, Object};
        use objc::{msg_send, sel, sel_impl};

        if let Some(workspace_class) = Class::get("NSWorkspace") {
            let workspace: *mut Object = msg_send![workspace_class, sharedWorkspace];
            let running_apps: *mut Object = msg_send![workspace, runningApplications];
            let app_count: usize = msg_send![running_apps, count];

            for i in 0..app_count {
                let app: *mut Object = msg_send![running_apps, objectAtIndex: i];
                let app_pid: i32 = msg_send![app, processIdentifier];

                if app_pid == pid {
                    let app_name: *mut Object = msg_send![app, localizedName];
                    if !app_name.is_null() {
                        let utf8: *const i8 = msg_send![app_name, UTF8String];
                        if !utf8.is_null() {
                            return std::ffi::CStr::from_ptr(utf8)
                                .to_str()
                                .unwrap_or("Unknown")
                                .to_string();
                        }
                    }
                    break;
                }
            }
        }

        "Unknown".to_string()
    }
}

/// Move a window to a new position.
///
/// # Arguments
/// * `window_id` - The unique window identifier from `list_windows()`
/// * `x` - The new X coordinate (screen pixels from left)
/// * `y` - The new Y coordinate (screen pixels from top)
///
/// # Errors
/// Returns error if window not found or operation fails.
#[instrument]
pub fn move_window(window_id: u32, x: i32, y: i32) -> Result<()> {
    let window = get_cached_window(window_id)
        .or_else(|| {
            // Try to refresh the cache
            let _ = list_windows();
            get_cached_window(window_id)
        })
        .context("Window not found")?;

    set_window_position(window, x, y)?;
    info!(window_id, x, y, "Moved window");
    Ok(())
}

/// Resize a window to new dimensions.
///
/// # Arguments
/// * `window_id` - The unique window identifier from `list_windows()`
/// * `width` - The new width in pixels
/// * `height` - The new height in pixels
///
/// # Errors
/// Returns error if window not found or operation fails.
#[instrument]
pub fn resize_window(window_id: u32, width: u32, height: u32) -> Result<()> {
    let window = get_cached_window(window_id)
        .or_else(|| {
            let _ = list_windows();
            get_cached_window(window_id)
        })
        .context("Window not found")?;

    set_window_size(window, width, height)?;
    info!(window_id, width, height, "Resized window");
    Ok(())
}

/// Set the complete bounds (position and size) of a window.
///
/// # Arguments
/// * `window_id` - The unique window identifier from `list_windows()`
/// * `bounds` - The new bounds for the window
///
/// # Errors
/// Returns error if window not found or operation fails.
#[instrument]
pub fn set_window_bounds(window_id: u32, bounds: Bounds) -> Result<()> {
    let window = get_cached_window(window_id)
        .or_else(|| {
            let _ = list_windows();
            get_cached_window(window_id)
        })
        .context("Window not found")?;

    // Set position first, then size
    set_window_position(window, bounds.x, bounds.y)?;
    set_window_size(window, bounds.width, bounds.height)?;

    info!(
        window_id,
        x = bounds.x,
        y = bounds.y,
        width = bounds.width,
        height = bounds.height,
        "Set window bounds"
    );
    Ok(())
}

/// Minimize a window.
///
/// # Arguments
/// * `window_id` - The unique window identifier from `list_windows()`
///
/// # Errors
/// Returns error if window not found or operation fails.
#[instrument]
pub fn minimize_window(window_id: u32) -> Result<()> {
    let window = get_cached_window(window_id)
        .or_else(|| {
            let _ = list_windows();
            get_cached_window(window_id)
        })
        .context("Window not found")?;

    // Use AXMinimized attribute to minimize
    let true_value = create_cf_string("1");
    let minimize_attr = create_cf_string("AXMinimized");

    // AXMinimized expects a CFBoolean, so we need to use the attribute differently
    // Actually, we should perform the press action on the minimize button
    // or set the AXMinimized attribute to true

    // Try setting AXMinimized directly with a boolean value
    unsafe {
        #[link(name = "CoreFoundation", kind = "framework")]
        extern "C" {
            static kCFBooleanTrue: CFTypeRef;
        }

        let result = AXUIElementSetAttributeValue(window, minimize_attr, kCFBooleanTrue);

        cf_release(minimize_attr);
        cf_release(true_value);

        if result != kAXErrorSuccess {
            bail!("Failed to minimize window: error {}", result);
        }
    }

    info!(window_id, "Minimized window");
    Ok(())
}

/// Maximize a window (fills the display without entering fullscreen mode).
///
/// This positions the window to fill the available display area (excluding
/// dock and menu bar) without entering macOS fullscreen mode.
///
/// # Arguments
/// * `window_id` - The unique window identifier from `list_windows()`
///
/// # Errors
/// Returns error if window not found or operation fails.
#[instrument]
pub fn maximize_window(window_id: u32) -> Result<()> {
    let window = get_cached_window(window_id)
        .or_else(|| {
            let _ = list_windows();
            get_cached_window(window_id)
        })
        .context("Window not found")?;

    // Get current position to determine which display the window is on
    let (current_x, current_y) = get_window_position(window).unwrap_or((0, 0));

    // Get the display bounds (accounting for menu bar and dock)
    let display_bounds = get_visible_display_bounds(current_x, current_y);

    // Set the window to fill the visible area
    set_window_position(window, display_bounds.x, display_bounds.y)?;
    set_window_size(window, display_bounds.width, display_bounds.height)?;

    info!(window_id, "Maximized window");
    Ok(())
}

/// Tile a window to a predefined position on the screen.
///
/// # Arguments
/// * `window_id` - The unique window identifier from `list_windows()`
/// * `position` - The tiling position (half, quadrant, or fullscreen)
///
/// # Errors
/// Returns error if window not found or operation fails.
///
#[instrument]
pub fn tile_window(window_id: u32, position: TilePosition) -> Result<()> {
    let window = get_cached_window(window_id)
        .or_else(|| {
            let _ = list_windows();
            get_cached_window(window_id)
        })
        .context("Window not found")?;

    // Get current position to determine which display the window is on
    let (current_x, current_y) = get_window_position(window).unwrap_or((0, 0));

    // Get the visible display bounds (accounting for menu bar and dock)
    let display = get_visible_display_bounds(current_x, current_y);

    let bounds = calculate_tile_bounds(&display, position);

    set_window_position(window, bounds.x, bounds.y)?;
    set_window_size(window, bounds.width, bounds.height)?;

    info!(window_id, ?position, "Tiled window");
    Ok(())
}

/// Close a window.
///
/// Note: This performs the close action on the window, which may prompt
/// the user to save unsaved changes depending on the application.
///
/// # Arguments
/// * `window_id` - The unique window identifier from `list_windows()`
///
/// # Errors
/// Returns error if window not found or operation fails.
#[instrument]
pub fn close_window(window_id: u32) -> Result<()> {
    let window = get_cached_window(window_id)
        .or_else(|| {
            let _ = list_windows();
            get_cached_window(window_id)
        })
        .context("Window not found")?;

    // Get the close button and press it
    if let Ok(close_button) = get_ax_attribute(window, "AXCloseButton") {
        perform_ax_action(close_button as AXUIElementRef, "AXPress")?;
        cf_release(close_button);
    } else {
        bail!("Window does not have a close button");
    }

    info!(window_id, "Closed window");
    Ok(())
}

/// Focus (bring to front) a window.
///
/// # Arguments
/// * `window_id` - The unique window identifier from `list_windows()`
///
/// # Errors
/// Returns error if window not found or operation fails.
#[instrument]
pub fn focus_window(window_id: u32) -> Result<()> {
    let window = get_cached_window(window_id)
        .or_else(|| {
            let _ = list_windows();
            get_cached_window(window_id)
        })
        .context("Window not found")?;

    // Raise the window
    perform_ax_action(window, "AXRaise")?;

    // Also activate the owning application
    let pid = (window_id >> 16) as i32;

    unsafe {
        use objc::runtime::{Class, Object};
        use objc::{msg_send, sel, sel_impl};

        let workspace_class = Class::get("NSWorkspace").context("Failed to get NSWorkspace")?;
        let workspace: *mut Object = msg_send![workspace_class, sharedWorkspace];
        let running_apps: *mut Object = msg_send![workspace, runningApplications];
        let app_count: usize = msg_send![running_apps, count];

        for i in 0..app_count {
            let app: *mut Object = msg_send![running_apps, objectAtIndex: i];
            let app_pid: i32 = msg_send![app, processIdentifier];

            if app_pid == pid {
                let _: bool = msg_send![app, activateWithOptions: 1u64]; // NSApplicationActivateIgnoringOtherApps
                break;
            }
        }
    }

    info!(window_id, "Focused window");
    Ok(())
}

// ============================================================================
// Helper Functions for Display Bounds
// ============================================================================

/// Get the visible display bounds (excluding menu bar and dock) for the display
/// containing the given point.
///
/// Uses NSScreen.visibleFrame to get accurate bounds that account for:
/// - Menu bar (on main display)
/// - Dock (on any edge, any display)
/// - Notch area (on newer MacBooks)
fn get_visible_display_bounds(x: i32, y: i32) -> Bounds {
    // Use NSScreen to get accurate visible frame
    unsafe {
        use objc::runtime::{Class, Object};
        use objc::{msg_send, sel, sel_impl};

        let nsscreen_class = match Class::get("NSScreen") {
            Some(c) => c,
            None => return get_visible_display_bounds_fallback(x, y),
        };

        // Get all screens
        let screens: *mut Object = msg_send![nsscreen_class, screens];
        if screens.is_null() {
            return get_visible_display_bounds_fallback(x, y);
        }

        let screen_count: usize = msg_send![screens, count];

        // Find the screen containing the point
        for i in 0..screen_count {
            let screen: *mut Object = msg_send![screens, objectAtIndex: i];
            if screen.is_null() {
                continue;
            }

            // Get the full frame (in Cocoa coordinates - origin at bottom-left)
            let frame: CGRect = msg_send![screen, frame];

            // Convert point to Cocoa coordinates for comparison
            // Cocoa Y increases upward, CoreGraphics Y increases downward
            // For the main screen, Cocoa origin.y is 0 at bottom
            // We need to check if (x, y) in CG coords falls within this screen

            // Get the main screen height for coordinate conversion
            let main_screen: *mut Object = msg_send![nsscreen_class, mainScreen];
            let main_frame: CGRect = msg_send![main_screen, frame];
            let main_height = main_frame.size.height;

            // Convert CG y to Cocoa y
            let cocoa_y = main_height - y as f64;

            // Check if point is within this screen's frame
            if (x as f64) >= frame.origin.x
                && (x as f64) < frame.origin.x + frame.size.width
                && cocoa_y >= frame.origin.y
                && cocoa_y < frame.origin.y + frame.size.height
            {
                // Get the visible frame (excludes menu bar and dock)
                let visible_frame: CGRect = msg_send![screen, visibleFrame];

                // Convert Cocoa coordinates back to CoreGraphics coordinates
                // CG origin is at top-left of main screen
                // Cocoa origin.y is distance from bottom of main screen
                // CG y = main_height - (cocoa_y + height)
                let cg_y = main_height - (visible_frame.origin.y + visible_frame.size.height);

                debug!(
                    screen_index = i,
                    frame_x = frame.origin.x,
                    frame_y = frame.origin.y,
                    frame_w = frame.size.width,
                    frame_h = frame.size.height,
                    visible_x = visible_frame.origin.x,
                    visible_y = visible_frame.origin.y,
                    visible_w = visible_frame.size.width,
                    visible_h = visible_frame.size.height,
                    cg_y = cg_y,
                    "Found screen for point ({}, {})",
                    x,
                    y
                );

                return Bounds {
                    x: visible_frame.origin.x as i32,
                    y: cg_y as i32,
                    width: visible_frame.size.width as u32,
                    height: visible_frame.size.height as u32,
                };
            }
        }
    }

    // Fallback if no screen found
    get_visible_display_bounds_fallback(x, y)
}

/// Fallback method using CGDisplay when NSScreen is unavailable
fn get_visible_display_bounds_fallback(x: i32, y: i32) -> Bounds {
    // Get all displays
    if let Ok(display_ids) = CGDisplay::active_displays() {
        for display_id in display_ids {
            let display = CGDisplay::new(display_id);
            let frame = display.bounds();

            // Check if point is within this display
            if x >= frame.origin.x as i32
                && x < (frame.origin.x + frame.size.width) as i32
                && y >= frame.origin.y as i32
                && y < (frame.origin.y + frame.size.height) as i32
            {
                let is_main = display_id == CGDisplay::main().id;

                // Conservative estimates for menu bar and dock
                let menu_bar_height = if is_main { 25 } else { 0 };
                let dock_height = if is_main { 70 } else { 0 };

                return Bounds {
                    x: frame.origin.x as i32,
                    y: frame.origin.y as i32 + menu_bar_height,
                    width: frame.size.width as u32,
                    height: (frame.size.height as i32 - menu_bar_height - dock_height) as u32,
                };
            }
        }
    }

    // Final fallback to main display
    let main = CGDisplay::main();
    let frame = main.bounds();
    Bounds {
        x: frame.origin.x as i32,
        y: frame.origin.y as i32 + 25,
        width: frame.size.width as u32,
        height: (frame.size.height - 95.0) as u32,
    }
}

/// Calculate the bounds for a tiling position within a display.
fn calculate_tile_bounds(display: &Bounds, position: TilePosition) -> Bounds {
    let half_width = display.width / 2;
    let half_height = display.height / 2;

    match position {
        TilePosition::LeftHalf => Bounds {
            x: display.x,
            y: display.y,
            width: half_width,
            height: display.height,
        },
        TilePosition::RightHalf => Bounds {
            x: display.x + half_width as i32,
            y: display.y,
            width: half_width,
            height: display.height,
        },
        TilePosition::TopHalf => Bounds {
            x: display.x,
            y: display.y,
            width: display.width,
            height: half_height,
        },
        TilePosition::BottomHalf => Bounds {
            x: display.x,
            y: display.y + half_height as i32,
            width: display.width,
            height: half_height,
        },
        TilePosition::TopLeft => Bounds {
            x: display.x,
            y: display.y,
            width: half_width,
            height: half_height,
        },
        TilePosition::TopRight => Bounds {
            x: display.x + half_width as i32,
            y: display.y,
            width: half_width,
            height: half_height,
        },
        TilePosition::BottomLeft => Bounds {
            x: display.x,
            y: display.y + half_height as i32,
            width: half_width,
            height: half_height,
        },
        TilePosition::BottomRight => Bounds {
            x: display.x + half_width as i32,
            y: display.y + half_height as i32,
            width: half_width,
            height: half_height,
        },
        TilePosition::Fullscreen => *display,
    }
}

// ============================================================================
// Tests
// ============================================================================

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_bounds_new() {
        let bounds = Bounds::new(10, 20, 100, 200);
        assert_eq!(bounds.x, 10);
        assert_eq!(bounds.y, 20);
        assert_eq!(bounds.width, 100);
        assert_eq!(bounds.height, 200);
    }

    #[test]
    fn test_calculate_tile_bounds_left_half() {
        let display = Bounds::new(0, 25, 1920, 1055);
        let bounds = calculate_tile_bounds(&display, TilePosition::LeftHalf);

        assert_eq!(bounds.x, 0);
        assert_eq!(bounds.y, 25);
        assert_eq!(bounds.width, 960);
        assert_eq!(bounds.height, 1055);
    }

    #[test]
    fn test_calculate_tile_bounds_right_half() {
        let display = Bounds::new(0, 25, 1920, 1055);
        let bounds = calculate_tile_bounds(&display, TilePosition::RightHalf);

        assert_eq!(bounds.x, 960);
        assert_eq!(bounds.y, 25);
        assert_eq!(bounds.width, 960);
        assert_eq!(bounds.height, 1055);
    }

    #[test]
    fn test_calculate_tile_bounds_top_left() {
        let display = Bounds::new(0, 25, 1920, 1080);
        let bounds = calculate_tile_bounds(&display, TilePosition::TopLeft);

        assert_eq!(bounds.x, 0);
        assert_eq!(bounds.y, 25);
        assert_eq!(bounds.width, 960);
        assert_eq!(bounds.height, 540);
    }

    #[test]
    fn test_calculate_tile_bounds_fullscreen() {
        let display = Bounds::new(0, 25, 1920, 1055);
        let bounds = calculate_tile_bounds(&display, TilePosition::Fullscreen);

        assert_eq!(bounds, display);
    }

    #[test]
    fn test_tile_position_equality() {
        assert_eq!(TilePosition::LeftHalf, TilePosition::LeftHalf);
        assert_ne!(TilePosition::LeftHalf, TilePosition::RightHalf);
    }

    #[test]
    fn test_permission_check_does_not_panic() {
        // This test verifies the permission check doesn't panic
        let _has_permission = has_accessibility_permission();
    }

    #[test]
    #[ignore] // Requires accessibility permission
    fn test_list_windows() {
        let windows = list_windows().expect("Should list windows");
        println!("Found {} windows:", windows.len());
        for window in &windows {
            println!(
                "  [{:08x}] {}: {} ({:?})",
                window.id, window.app, window.title, window.bounds
            );
        }
    }

    #[test]
    #[ignore] // Requires accessibility permission and a visible window
    fn test_tile_window_left_half() {
        let windows = list_windows().expect("Should list windows");
        if let Some(window) = windows.first() {
            tile_window(window.id, TilePosition::LeftHalf).expect("Should tile window");
            println!("Tiled '{}' to left half", window.title);
        } else {
            panic!("No windows found to test with");
        }
    }
}

</file>

<file path="src/window_control_enhanced/capabilities.rs">
//! Window capability detection via AXUIElementIsAttributeSettable

#![allow(non_upper_case_globals)]

use super::bounds::{SizeConstraints, WindowBounds};
use std::ffi::c_void;

/// Capabilities of a window, determined by querying Accessibility APIs
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub struct WindowCapabilities {
    /// Whether the window position can be changed (AXPosition is settable)
    pub can_move: bool,
    /// Whether the window size can be changed (AXSize is settable)
    pub can_resize: bool,
    /// Whether the window can be minimized
    pub can_minimize: bool,
    /// Whether the window can be closed
    pub can_close: bool,
    /// Whether the window can enter fullscreen mode
    pub can_fullscreen: bool,
    /// Whether moving to different Spaces is supported (requires external backend)
    pub supports_space_move: bool,
}

impl Default for WindowCapabilities {
    fn default() -> Self {
        Self {
            can_move: true,
            can_resize: true,
            can_minimize: true,
            can_close: true,
            can_fullscreen: true,
            supports_space_move: false, // Always false by default
        }
    }
}

/// Enhanced window information with capabilities
#[derive(Debug, Clone)]
pub struct EnhancedWindowInfo {
    /// Unique window identifier
    pub id: u32,
    /// Application name
    pub app: String,
    /// Bundle identifier of the owning application
    pub bundle_id: Option<String>,
    /// Window title
    pub title: String,
    /// Process ID of the owning application
    pub pid: i32,
    /// Window bounds in AX coordinates
    pub bounds: WindowBounds,
    /// Window capabilities
    pub capabilities: WindowCapabilities,
    /// Size constraints (if available)
    pub size_constraints: SizeConstraints,
    /// Internal AX element reference (stored as usize for Send/Sync)
    #[allow(dead_code)]
    ax_element: Option<usize>,
}

impl EnhancedWindowInfo {
    /// Create new enhanced window info
    pub fn new(
        id: u32,
        app: String,
        title: String,
        pid: i32,
        bounds: WindowBounds,
        capabilities: WindowCapabilities,
    ) -> Self {
        Self {
            id,
            app,
            bundle_id: None,
            title,
            pid,
            bounds,
            capabilities,
            size_constraints: SizeConstraints::default(),
            ax_element: None,
        }
    }

    /// Check if this window can be resized to the given dimensions
    pub fn can_resize_to(&self, width: f64, height: f64) -> bool {
        if !self.capabilities.can_resize {
            return false;
        }

        let (clamped_w, clamped_h) = self.size_constraints.clamp_size(width, height);
        (clamped_w - width).abs() < 1.0 && (clamped_h - height).abs() < 1.0
    }
}

// ============================================================================
// FFI Bindings for AXUIElementIsAttributeSettable
// ============================================================================

#[cfg(target_os = "macos")]
mod ax_ffi {
    use std::ffi::c_void;

    pub type AXUIElementRef = *const c_void;
    pub type CFStringRef = *const c_void;
    pub type CFTypeRef = *const c_void;

    #[link(name = "ApplicationServices", kind = "framework")]
    extern "C" {
        pub fn AXUIElementIsAttributeSettable(
            element: AXUIElementRef,
            attribute: CFStringRef,
            settable: *mut bool,
        ) -> i32;

        pub fn AXUIElementCopyAttributeValue(
            element: AXUIElementRef,
            attribute: CFStringRef,
            value: *mut CFTypeRef,
        ) -> i32;
    }

    #[link(name = "CoreFoundation", kind = "framework")]
    extern "C" {
        pub fn CFStringCreateWithCString(
            alloc: *const c_void,
            c_str: *const i8,
            encoding: u32,
        ) -> CFStringRef;
        pub fn CFRelease(cf: *const c_void);
    }

    pub const kCFStringEncodingUTF8: u32 = 0x08000100;
    pub const kAXErrorSuccess: i32 = 0;

    /// Create a CFString from a Rust string
    pub fn create_cf_string(s: &str) -> CFStringRef {
        unsafe {
            let c_str = std::ffi::CString::new(s).unwrap();
            CFStringCreateWithCString(std::ptr::null(), c_str.as_ptr(), kCFStringEncodingUTF8)
        }
    }

    /// Release a CoreFoundation object
    pub fn cf_release(cf: CFTypeRef) {
        if !cf.is_null() {
            unsafe {
                CFRelease(cf);
            }
        }
    }

    /// Check if an AX attribute is settable
    pub fn is_attribute_settable(element: AXUIElementRef, attribute: &str) -> bool {
        if element.is_null() {
            return false;
        }

        let attr_str = create_cf_string(attribute);
        let mut settable = false;

        let result = unsafe {
            AXUIElementIsAttributeSettable(element, attr_str, &mut settable as *mut bool)
        };

        cf_release(attr_str);

        result == kAXErrorSuccess && settable
    }

    /// Check if an AX attribute exists (has a value)
    pub fn has_attribute(element: AXUIElementRef, attribute: &str) -> bool {
        if element.is_null() {
            return false;
        }

        let attr_str = create_cf_string(attribute);
        let mut value: CFTypeRef = std::ptr::null();

        let result = unsafe {
            AXUIElementCopyAttributeValue(element, attr_str, &mut value as *mut CFTypeRef)
        };

        cf_release(attr_str);

        if result == kAXErrorSuccess && !value.is_null() {
            cf_release(value);
            true
        } else {
            false
        }
    }
}

// ============================================================================
// Public API - Capability Detection (macOS)
// ============================================================================

/// Check if a window's position can be changed
#[cfg(target_os = "macos")]
pub fn can_move_window(ax_element: *const c_void) -> bool {
    ax_ffi::is_attribute_settable(ax_element, "AXPosition")
}

/// Check if a window's size can be changed
#[cfg(target_os = "macos")]
pub fn can_resize_window(ax_element: *const c_void) -> bool {
    ax_ffi::is_attribute_settable(ax_element, "AXSize")
}

/// Check if a window has a minimize button
#[cfg(target_os = "macos")]
pub fn can_minimize_window(ax_element: *const c_void) -> bool {
    ax_ffi::has_attribute(ax_element, "AXMinimizeButton")
}

/// Check if a window has a close button
#[cfg(target_os = "macos")]
pub fn can_close_window(ax_element: *const c_void) -> bool {
    ax_ffi::has_attribute(ax_element, "AXCloseButton")
}

/// Check if a window has a fullscreen button
#[cfg(target_os = "macos")]
pub fn can_fullscreen_window(ax_element: *const c_void) -> bool {
    ax_ffi::has_attribute(ax_element, "AXFullScreenButton")
}

/// Detect all capabilities for a window
#[cfg(target_os = "macos")]
pub fn detect_window_capabilities(ax_element: *const c_void) -> WindowCapabilities {
    WindowCapabilities {
        can_move: can_move_window(ax_element),
        can_resize: can_resize_window(ax_element),
        can_minimize: can_minimize_window(ax_element),
        can_close: can_close_window(ax_element),
        can_fullscreen: can_fullscreen_window(ax_element),
        supports_space_move: false, // Always false without external backend
    }
}

// ============================================================================
// Non-macOS stubs
// ============================================================================

#[cfg(not(target_os = "macos"))]
pub fn can_move_window(_ax_element: *const c_void) -> bool {
    true
}

#[cfg(not(target_os = "macos"))]
pub fn can_resize_window(_ax_element: *const c_void) -> bool {
    true
}

#[cfg(not(target_os = "macos"))]
pub fn can_minimize_window(_ax_element: *const c_void) -> bool {
    true
}

#[cfg(not(target_os = "macos"))]
pub fn can_close_window(_ax_element: *const c_void) -> bool {
    true
}

#[cfg(not(target_os = "macos"))]
pub fn can_fullscreen_window(_ax_element: *const c_void) -> bool {
    true
}

#[cfg(not(target_os = "macos"))]
pub fn detect_window_capabilities(_ax_element: *const c_void) -> WindowCapabilities {
    WindowCapabilities::default()
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_default_capabilities() {
        let caps = WindowCapabilities::default();
        assert!(caps.can_move);
        assert!(caps.can_resize);
        assert!(caps.can_minimize);
        assert!(caps.can_close);
        assert!(caps.can_fullscreen);
        assert!(!caps.supports_space_move);
    }

    #[test]
    fn test_enhanced_window_info_can_resize_to() {
        let mut info = EnhancedWindowInfo::new(
            1,
            "Test".to_string(),
            "Window".to_string(),
            123,
            WindowBounds::new(0.0, 0.0, 800.0, 600.0),
            WindowCapabilities::default(),
        );

        // No constraints, should always allow
        assert!(info.can_resize_to(500.0, 400.0));

        // With constraints
        info.size_constraints = SizeConstraints {
            min_width: Some(200.0),
            min_height: Some(200.0),
            max_width: Some(1000.0),
            max_height: Some(800.0),
        };

        assert!(info.can_resize_to(500.0, 400.0));
        assert!(!info.can_resize_to(100.0, 100.0)); // Below min
        assert!(!info.can_resize_to(2000.0, 1000.0)); // Above max

        // Can't resize if capability says no
        info.capabilities.can_resize = false;
        assert!(!info.can_resize_to(500.0, 400.0));
    }
}

</file>

<file path="src/window_control_enhanced/mod.rs">
//! Enhanced Window Control Module
//!
//! This module builds on the base `window_control` module to provide:
//! - **Coordinate foundation**: Standardized WindowBounds in AX coordinates (top-left origin)
//! - **Capability detection**: Settability checks via AXUIElementIsAttributeSettable
//! - **Enhanced window info**: EnhancedWindowInfo with capabilities (can_move/can_resize)
//! - **Multi-monitor support**: DisplayInfo with proper overlap-based display detection
//! - **Spaces backend**: Optional SpaceManager trait (defaults to Unsupported)
//!
//! ## Coordinate System
//!
//! Internally, all bounds use **AX coordinates** (top-left origin, Y grows downward).
//! This matches what `kAXPositionAttribute` get/set operations expect.
//!
//! AppKit's `NSScreen.visibleFrame` uses bottom-left origin, so we convert it
//! to AX coordinates when building `DisplayInfo`.

mod bounds;
mod capabilities;
mod coords;
mod display;
mod spaces;

pub use bounds::{SizeConstraints, WindowBounds};
pub use capabilities::{
    can_close_window, can_fullscreen_window, can_minimize_window, can_move_window,
    can_resize_window, detect_window_capabilities, EnhancedWindowInfo, WindowCapabilities,
};
pub use coords::{appkit_to_ax, ax_to_appkit, bounds_to_nsrect, nsrect_to_bounds};
pub use display::{get_all_displays, get_display_for_window, DisplayInfo};
pub use spaces::{
    get_space_manager, set_space_manager, SpaceError, SpaceInfo, SpaceManager, SpaceType,
    UnsupportedSpaceBackend,
};

</file>

<file path="src/window_control_enhanced/bounds.rs">
//! WindowBounds type and size constraints

/// Window bounds in AX coordinate system (top-left origin, Y grows downward).
///
/// This is the canonical coordinate system used internally by this module.
/// All bounds returned from queries and accepted by setters use AX coords.
#[derive(Debug, Clone, Copy, PartialEq)]
pub struct WindowBounds {
    /// X coordinate (pixels from left edge of primary display)
    pub x: f64,
    /// Y coordinate (pixels from top edge of primary display, grows downward)
    pub y: f64,
    /// Width in pixels
    pub width: f64,
    /// Height in pixels
    pub height: f64,
}

impl WindowBounds {
    /// Create new bounds
    pub fn new(x: f64, y: f64, width: f64, height: f64) -> Self {
        Self {
            x,
            y,
            width,
            height,
        }
    }

    /// Create bounds from integer values (convenience for legacy Bounds compatibility)
    pub fn from_ints(x: i32, y: i32, width: u32, height: u32) -> Self {
        Self {
            x: x as f64,
            y: y as f64,
            width: width as f64,
            height: height as f64,
        }
    }

    /// Get the center point of these bounds
    pub fn center(&self) -> (f64, f64) {
        (self.x + self.width / 2.0, self.y + self.height / 2.0)
    }

    /// Get the right edge X coordinate
    pub fn right(&self) -> f64 {
        self.x + self.width
    }

    /// Get the bottom edge Y coordinate
    pub fn bottom(&self) -> f64 {
        self.y + self.height
    }

    /// Check if a point is within these bounds
    pub fn contains_point(&self, x: f64, y: f64) -> bool {
        x >= self.x && x < self.right() && y >= self.y && y < self.bottom()
    }

    /// Calculate the intersection area with another bounds
    pub fn intersection_area(&self, other: &WindowBounds) -> f64 {
        let left = self.x.max(other.x);
        let top = self.y.max(other.y);
        let right = self.right().min(other.right());
        let bottom = self.bottom().min(other.bottom());

        if right > left && bottom > top {
            (right - left) * (bottom - top)
        } else {
            0.0
        }
    }

    /// Total area of these bounds
    pub fn area(&self) -> f64 {
        self.width * self.height
    }

    /// Clamp these bounds to fit within container bounds
    pub fn clamp_to(&self, container: &WindowBounds) -> WindowBounds {
        let mut result = *self;

        // Clamp width/height to container
        result.width = result.width.min(container.width);
        result.height = result.height.min(container.height);

        // Clamp position so window stays within container
        result.x = result.x.max(container.x);
        result.y = result.y.max(container.y);

        if result.right() > container.right() {
            result.x = container.right() - result.width;
        }
        if result.bottom() > container.bottom() {
            result.y = container.bottom() - result.height;
        }

        result
    }
}

impl Default for WindowBounds {
    fn default() -> Self {
        Self::new(0.0, 0.0, 0.0, 0.0)
    }
}

/// Optional size constraints for a window
#[derive(Debug, Clone, Copy, PartialEq, Default)]
pub struct SizeConstraints {
    /// Minimum width (if available)
    pub min_width: Option<f64>,
    /// Minimum height (if available)
    pub min_height: Option<f64>,
    /// Maximum width (if available)
    pub max_width: Option<f64>,
    /// Maximum height (if available)
    pub max_height: Option<f64>,
}

impl SizeConstraints {
    /// Clamp a size to these constraints
    pub fn clamp_size(&self, width: f64, height: f64) -> (f64, f64) {
        let w = width
            .max(self.min_width.unwrap_or(0.0))
            .min(self.max_width.unwrap_or(f64::MAX));
        let h = height
            .max(self.min_height.unwrap_or(0.0))
            .min(self.max_height.unwrap_or(f64::MAX));
        (w, h)
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_new_and_default() {
        let bounds = WindowBounds::new(100.0, 200.0, 800.0, 600.0);
        assert_eq!(bounds.x, 100.0);
        assert_eq!(bounds.y, 200.0);
        assert_eq!(bounds.width, 800.0);
        assert_eq!(bounds.height, 600.0);

        let default = WindowBounds::default();
        assert_eq!(default.x, 0.0);
        assert_eq!(default.y, 0.0);
    }

    #[test]
    fn test_from_ints() {
        let bounds = WindowBounds::from_ints(10, 20, 100, 200);
        assert_eq!(bounds.x, 10.0);
        assert_eq!(bounds.y, 20.0);
        assert_eq!(bounds.width, 100.0);
        assert_eq!(bounds.height, 200.0);
    }

    #[test]
    fn test_center() {
        let bounds = WindowBounds::new(100.0, 200.0, 800.0, 600.0);
        let (cx, cy) = bounds.center();
        assert_eq!(cx, 500.0);
        assert_eq!(cy, 500.0);
    }

    #[test]
    fn test_right_and_bottom() {
        let bounds = WindowBounds::new(100.0, 200.0, 800.0, 600.0);
        assert_eq!(bounds.right(), 900.0);
        assert_eq!(bounds.bottom(), 800.0);
    }

    #[test]
    fn test_contains_point() {
        let bounds = WindowBounds::new(100.0, 100.0, 200.0, 200.0);
        assert!(bounds.contains_point(150.0, 150.0));
        assert!(bounds.contains_point(100.0, 100.0));
        assert!(!bounds.contains_point(99.0, 150.0));
        assert!(!bounds.contains_point(300.0, 150.0));
    }

    #[test]
    fn test_intersection_area() {
        let a = WindowBounds::new(0.0, 0.0, 100.0, 100.0);
        let b = WindowBounds::new(50.0, 50.0, 100.0, 100.0);
        assert_eq!(a.intersection_area(&b), 2500.0);

        let c = WindowBounds::new(200.0, 200.0, 50.0, 50.0);
        assert_eq!(a.intersection_area(&c), 0.0);
    }

    #[test]
    fn test_clamp_to() {
        let container = WindowBounds::new(0.0, 0.0, 1920.0, 1080.0);
        let window = WindowBounds::new(1800.0, 100.0, 200.0, 200.0);
        let clamped = window.clamp_to(&container);
        assert_eq!(clamped.x, 1720.0);
        assert_eq!(clamped.y, 100.0);
    }

    #[test]
    fn test_size_constraints_clamp() {
        let constraints = SizeConstraints {
            min_width: Some(100.0),
            min_height: Some(100.0),
            max_width: Some(1000.0),
            max_height: Some(800.0),
        };

        let (w, h) = constraints.clamp_size(500.0, 400.0);
        assert_eq!(w, 500.0);
        assert_eq!(h, 400.0);

        let (w, h) = constraints.clamp_size(50.0, 50.0);
        assert_eq!(w, 100.0);
        assert_eq!(h, 100.0);

        let (w, h) = constraints.clamp_size(2000.0, 1500.0);
        assert_eq!(w, 1000.0);
        assert_eq!(h, 800.0);
    }
}

</file>

<file path="src/window_control_enhanced/coords.rs">
//! Coordinate conversion utilities between AX (top-left) and AppKit (bottom-left)

use super::bounds::WindowBounds;

/// Convert AppKit coordinates (origin at bottom-left of main screen) to AX coordinates
/// (origin at top-left of main screen).
///
/// # Arguments
/// * `x` - X coordinate in AppKit space
/// * `y` - Y coordinate in AppKit space (distance from bottom)
/// * `height` - Height of the rect being converted
/// * `main_screen_height` - Total height of the main screen
pub fn appkit_to_ax(x: f64, y: f64, height: f64, main_screen_height: f64) -> (f64, f64) {
    // In AppKit, y is distance from bottom of main screen
    // In AX, y is distance from top of main screen
    // AX_y = main_height - (appkit_y + rect_height)
    let ax_y = main_screen_height - (y + height);
    (x, ax_y)
}

/// Convert AX coordinates to AppKit coordinates
///
/// # Arguments
/// * `x` - X coordinate in AX space
/// * `y` - Y coordinate in AX space (distance from top)
/// * `height` - Height of the rect being converted
/// * `main_screen_height` - Total height of the main screen
pub fn ax_to_appkit(x: f64, y: f64, height: f64, main_screen_height: f64) -> (f64, f64) {
    // Inverse of appkit_to_ax
    // appkit_y = main_height - (ax_y + rect_height)
    let appkit_y = main_screen_height - (y + height);
    (x, appkit_y)
}

/// Convert an AppKit NSRect (origin at bottom-left) to WindowBounds (AX coords)
pub fn nsrect_to_bounds(
    origin_x: f64,
    origin_y: f64,
    width: f64,
    height: f64,
    main_screen_height: f64,
) -> WindowBounds {
    let (ax_x, ax_y) = appkit_to_ax(origin_x, origin_y, height, main_screen_height);
    WindowBounds::new(ax_x, ax_y, width, height)
}

/// Convert WindowBounds (AX coords) to AppKit coordinates
/// Returns (origin_x, origin_y, width, height) in AppKit space
pub fn bounds_to_nsrect(bounds: &WindowBounds, main_screen_height: f64) -> (f64, f64, f64, f64) {
    let (appkit_x, appkit_y) = ax_to_appkit(bounds.x, bounds.y, bounds.height, main_screen_height);
    (appkit_x, appkit_y, bounds.width, bounds.height)
}

#[cfg(test)]
mod tests {
    use super::*;

    const MAIN_HEIGHT: f64 = 1080.0;

    #[test]
    fn test_appkit_to_ax_top_of_screen() {
        // A window at AppKit coords (0, 555) with height 500 should be near top
        // AX_y = 1080 - (555 + 500) = 25
        let (ax_x, ax_y) = appkit_to_ax(0.0, 555.0, 500.0, MAIN_HEIGHT);
        assert_eq!(ax_x, 0.0);
        assert_eq!(ax_y, 25.0);
    }

    #[test]
    fn test_appkit_to_ax_bottom_of_screen() {
        // A window at AppKit coords (0, 0) with height 500
        // AX_y = 1080 - (0 + 500) = 580
        let (ax_x, ax_y) = appkit_to_ax(0.0, 0.0, 500.0, MAIN_HEIGHT);
        assert_eq!(ax_x, 0.0);
        assert_eq!(ax_y, 580.0);
    }

    #[test]
    fn test_ax_to_appkit_roundtrip() {
        let original_x = 100.0;
        let original_y = 200.0;
        let height = 400.0;

        let (ax_x, ax_y) = appkit_to_ax(original_x, original_y, height, MAIN_HEIGHT);
        let (back_x, back_y) = ax_to_appkit(ax_x, ax_y, height, MAIN_HEIGHT);

        assert!((back_x - original_x).abs() < 0.001);
        assert!((back_y - original_y).abs() < 0.001);
    }

    #[test]
    fn test_nsrect_to_bounds() {
        let bounds = nsrect_to_bounds(100.0, 50.0, 800.0, 600.0, MAIN_HEIGHT);
        assert_eq!(bounds.x, 100.0);
        assert_eq!(bounds.width, 800.0);
        assert_eq!(bounds.height, 600.0);
        // AX_y = 1080 - (50 + 600) = 430
        assert_eq!(bounds.y, 430.0);
    }

    #[test]
    fn test_bounds_to_nsrect() {
        let bounds = WindowBounds::new(100.0, 430.0, 800.0, 600.0);
        let (x, y, w, h) = bounds_to_nsrect(&bounds, MAIN_HEIGHT);
        assert_eq!(x, 100.0);
        assert_eq!(w, 800.0);
        assert_eq!(h, 600.0);
        // AppKit_y = 1080 - (430 + 600) = 50
        assert_eq!(y, 50.0);
    }
}

</file>

<file path="src/window_control_enhanced/spaces.rs">
//! Space (virtual desktop) management backend

use std::sync::{Arc, RwLock};

/// Information about a macOS Space (virtual desktop)
#[derive(Debug, Clone)]
pub struct SpaceInfo {
    /// Space identifier
    pub id: u64,
    /// Space index (1-based, as shown in Mission Control)
    pub index: u32,
    /// Whether this is the currently active space
    pub is_active: bool,
    /// Space type (regular desktop, fullscreen app, etc.)
    pub space_type: SpaceType,
}

/// Type of Space
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum SpaceType {
    /// Regular desktop space
    Desktop,
    /// Fullscreen application space
    Fullscreen,
    /// Unknown type
    Unknown,
}

/// Error type for Space operations
#[derive(Debug, Clone)]
pub enum SpaceError {
    /// Space operations are not supported on this system/configuration
    NotSupported(String),
    /// The requested space was not found
    SpaceNotFound(u64),
    /// The window cannot be moved to a space
    WindowNotMovable(u32),
    /// External tool (e.g., yabai) is not available
    ExternalToolNotAvailable(String),
    /// Other error
    Other(String),
}

impl std::fmt::Display for SpaceError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            SpaceError::NotSupported(msg) => write!(f, "Space operations not supported: {}", msg),
            SpaceError::SpaceNotFound(id) => write!(f, "Space not found: {}", id),
            SpaceError::WindowNotMovable(id) => {
                write!(f, "Window {} cannot be moved to a space", id)
            }
            SpaceError::ExternalToolNotAvailable(tool) => {
                write!(f, "External tool not available: {}", tool)
            }
            SpaceError::Other(msg) => write!(f, "Space error: {}", msg),
        }
    }
}

impl std::error::Error for SpaceError {}

/// Backend trait for Space management operations
///
/// Default implementation returns "unsupported" for all operations.
/// Alternative implementations can integrate with external tools (yabai)
/// or private APIs (experimental, not recommended).
pub trait SpaceManager: Send + Sync {
    /// Get all spaces on all displays
    fn get_all_spaces(&self) -> Result<Vec<SpaceInfo>, SpaceError>;

    /// Get the currently active space
    fn get_active_space(&self) -> Result<SpaceInfo, SpaceError>;

    /// Move a window to a specific space
    fn move_window_to_space(&self, window_id: u32, space_id: u64) -> Result<(), SpaceError>;

    /// Check if space operations are supported
    fn is_supported(&self) -> bool;

    /// Get a description of why spaces aren't supported (if not supported)
    fn unsupported_reason(&self) -> Option<String>;
}

/// Default "unsupported" Space backend
///
/// This is the default backend that returns clear "not supported" errors
/// for all space operations. This is the safe default since moving windows
/// between Spaces requires either:
/// - Private WindowServer/Dock APIs (fragile, requires SIP disable)
/// - External tools like yabai (requires user setup)
pub struct UnsupportedSpaceBackend;

impl SpaceManager for UnsupportedSpaceBackend {
    fn get_all_spaces(&self) -> Result<Vec<SpaceInfo>, SpaceError> {
        Err(SpaceError::NotSupported(
            "Space enumeration requires private macOS APIs or external tools like yabai. \
             This feature is not enabled by default."
                .to_string(),
        ))
    }

    fn get_active_space(&self) -> Result<SpaceInfo, SpaceError> {
        Err(SpaceError::NotSupported(
            "Getting active space requires private macOS APIs. \
             This feature is not enabled by default."
                .to_string(),
        ))
    }

    fn move_window_to_space(&self, _window_id: u32, _space_id: u64) -> Result<(), SpaceError> {
        Err(SpaceError::NotSupported(
            "Moving windows between Spaces requires private macOS APIs or external tools. \
             Consider using yabai (https://github.com/koekeishiya/yabai) if you need this feature."
                .to_string(),
        ))
    }

    fn is_supported(&self) -> bool {
        false
    }

    fn unsupported_reason(&self) -> Option<String> {
        Some(
            "Space management requires private macOS APIs or external tools like yabai. \
             This feature is not enabled by default for stability and compatibility."
                .to_string(),
        )
    }
}

// ============================================================================
// Global Space Manager
// ============================================================================

/// Global space manager instance
static SPACE_MANAGER: RwLock<Option<Arc<dyn SpaceManager>>> = RwLock::new(None);

/// Get the current space manager, or create the default unsupported backend
pub fn get_space_manager() -> Arc<dyn SpaceManager> {
    let read_guard = SPACE_MANAGER.read().unwrap();
    if let Some(ref manager) = *read_guard {
        return Arc::clone(manager);
    }
    drop(read_guard);

    // Create default backend
    let mut write_guard = SPACE_MANAGER.write().unwrap();
    if write_guard.is_none() {
        *write_guard = Some(Arc::new(UnsupportedSpaceBackend));
    }
    Arc::clone(write_guard.as_ref().unwrap())
}

/// Set a custom space manager backend
pub fn set_space_manager(manager: Arc<dyn SpaceManager>) {
    let mut write_guard = SPACE_MANAGER.write().unwrap();
    *write_guard = Some(manager);
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_unsupported_backend() {
        let backend = UnsupportedSpaceBackend;

        assert!(!backend.is_supported());
        assert!(backend.unsupported_reason().is_some());

        let result = backend.get_all_spaces();
        assert!(matches!(result, Err(SpaceError::NotSupported(_))));

        let result = backend.get_active_space();
        assert!(matches!(result, Err(SpaceError::NotSupported(_))));

        let result = backend.move_window_to_space(123, 1);
        assert!(matches!(result, Err(SpaceError::NotSupported(_))));
    }

    #[test]
    fn test_space_error_display() {
        let err = SpaceError::NotSupported("test reason".to_string());
        let msg = format!("{}", err);
        assert!(msg.contains("not supported"));
        assert!(msg.contains("test reason"));

        let err = SpaceError::SpaceNotFound(42);
        let msg = format!("{}", err);
        assert!(msg.contains("42"));

        let err = SpaceError::WindowNotMovable(123);
        let msg = format!("{}", err);
        assert!(msg.contains("123"));
    }

    #[test]
    fn test_global_space_manager() {
        let manager = get_space_manager();
        assert!(!manager.is_supported());

        let result = manager.get_all_spaces();
        assert!(result.is_err());
    }
}

</file>

<file path="src/window_control_enhanced/display.rs">
//! Display/monitor detection and management

use super::bounds::WindowBounds;
use super::coords::nsrect_to_bounds;
use anyhow::{bail, Context, Result};
use tracing::{info, instrument};

/// Information about a display/monitor
#[derive(Debug, Clone)]
pub struct DisplayInfo {
    /// Display identifier
    pub id: u32,
    /// Display name (if available)
    pub name: Option<String>,
    /// Full display bounds in AX coordinates
    pub frame: WindowBounds,
    /// Visible bounds (excluding dock, menu bar) in AX coordinates
    pub visible_bounds: WindowBounds,
    /// Whether this is the main (primary) display
    pub is_main: bool,
}

impl DisplayInfo {
    /// Calculate relative position within this display
    ///
    /// Returns (relative_x, relative_y) as fractions [0.0, 1.0]
    pub fn relative_position(&self, bounds: &WindowBounds) -> (f64, f64) {
        let rel_x = (bounds.x - self.visible_bounds.x) / self.visible_bounds.width;
        let rel_y = (bounds.y - self.visible_bounds.y) / self.visible_bounds.height;
        (rel_x, rel_y)
    }

    /// Apply relative position to get absolute bounds on this display
    pub fn apply_relative_position(
        &self,
        rel_x: f64,
        rel_y: f64,
        width: f64,
        height: f64,
    ) -> WindowBounds {
        WindowBounds {
            x: self.visible_bounds.x + rel_x * self.visible_bounds.width,
            y: self.visible_bounds.y + rel_y * self.visible_bounds.height,
            width,
            height,
        }
    }
}

/// Get information about all connected displays
#[cfg(target_os = "macos")]
#[instrument]
pub fn get_all_displays() -> Result<Vec<DisplayInfo>> {
    use core_graphics::display::CGDisplay;

    let display_ids = CGDisplay::active_displays()
        .map_err(|e| anyhow::anyhow!("Failed to get active displays: error code {}", e))?;
    let main_screen_height = get_main_screen_height()?;

    let mut displays = Vec::with_capacity(display_ids.len());

    for display_id in display_ids {
        let display = CGDisplay::new(display_id);
        let frame = display.bounds();
        let is_main = display_id == CGDisplay::main().id;

        // Get visible frame from NSScreen
        let visible_bounds = get_nsscreen_visible_frame(display_id, main_screen_height)
            .unwrap_or_else(|| {
                // Fallback: estimate visible area
                let menu_bar = if is_main { 25.0 } else { 0.0 };
                let dock = if is_main { 70.0 } else { 0.0 };
                WindowBounds::new(
                    frame.origin.x,
                    frame.origin.y + menu_bar,
                    frame.size.width,
                    frame.size.height - menu_bar - dock,
                )
            });

        displays.push(DisplayInfo {
            id: display_id,
            name: None,
            frame: WindowBounds::new(
                frame.origin.x,
                frame.origin.y,
                frame.size.width,
                frame.size.height,
            ),
            visible_bounds,
            is_main,
        });
    }

    info!(display_count = displays.len(), "Got all displays");
    Ok(displays)
}

#[cfg(not(target_os = "macos"))]
pub fn get_all_displays() -> Result<Vec<DisplayInfo>> {
    Ok(vec![DisplayInfo {
        id: 0,
        name: Some("Primary Display".to_string()),
        frame: WindowBounds::new(0.0, 0.0, 1920.0, 1080.0),
        visible_bounds: WindowBounds::new(0.0, 25.0, 1920.0, 1055.0),
        is_main: true,
    }])
}

/// Get the display that contains the largest portion of a window
#[instrument(skip(displays))]
pub fn get_display_for_window<'a>(
    window_bounds: &WindowBounds,
    displays: &'a [DisplayInfo],
) -> Option<&'a DisplayInfo> {
    displays
        .iter()
        .max_by(|a, b| {
            let area_a = window_bounds.intersection_area(&a.visible_bounds);
            let area_b = window_bounds.intersection_area(&b.visible_bounds);
            area_a
                .partial_cmp(&area_b)
                .unwrap_or(std::cmp::Ordering::Equal)
        })
        .filter(|d| window_bounds.intersection_area(&d.visible_bounds) > 0.0)
}

/// Get the main screen height for coordinate conversion
#[cfg(target_os = "macos")]
fn get_main_screen_height() -> Result<f64> {
    unsafe {
        use objc::runtime::{Class, Object};
        use objc::{msg_send, sel, sel_impl};

        let nsscreen = Class::get("NSScreen").context("Failed to get NSScreen class")?;
        let main_screen: *mut Object = msg_send![nsscreen, mainScreen];

        if main_screen.is_null() {
            bail!("No main screen found");
        }

        #[repr(C)]
        struct NSRect {
            origin: NSPoint,
            size: NSSize,
        }
        #[repr(C)]
        struct NSPoint {
            x: f64,
            y: f64,
        }
        #[repr(C)]
        struct NSSize {
            width: f64,
            height: f64,
        }

        let frame: NSRect = msg_send![main_screen, frame];
        Ok(frame.size.height)
    }
}

#[cfg(not(target_os = "macos"))]
fn get_main_screen_height() -> Result<f64> {
    Ok(1080.0)
}

/// Get NSScreen.visibleFrame for a display, converted to AX coordinates
#[cfg(target_os = "macos")]
fn get_nsscreen_visible_frame(display_id: u32, main_screen_height: f64) -> Option<WindowBounds> {
    unsafe {
        use objc::runtime::{Class, Object};
        use objc::{msg_send, sel, sel_impl};

        let nsscreen = Class::get("NSScreen")?;
        let screens: *mut Object = msg_send![nsscreen, screens];

        if screens.is_null() {
            return None;
        }

        let count: usize = msg_send![screens, count];

        #[repr(C)]
        struct NSRect {
            origin: NSPoint,
            size: NSSize,
        }
        #[repr(C)]
        struct NSPoint {
            x: f64,
            y: f64,
        }
        #[repr(C)]
        struct NSSize {
            width: f64,
            height: f64,
        }

        let target_display = core_graphics::display::CGDisplay::new(display_id);
        let target_frame = target_display.bounds();

        for i in 0..count {
            let screen: *mut Object = msg_send![screens, objectAtIndex: i];
            if screen.is_null() {
                continue;
            }

            let frame: NSRect = msg_send![screen, frame];

            // Match by origin and size
            let matches = (frame.origin.x - target_frame.origin.x).abs() < 1.0
                && (frame.size.width - target_frame.size.width).abs() < 1.0
                && (frame.size.height - target_frame.size.height).abs() < 1.0;

            if matches {
                let visible: NSRect = msg_send![screen, visibleFrame];

                return Some(nsrect_to_bounds(
                    visible.origin.x,
                    visible.origin.y,
                    visible.size.width,
                    visible.size.height,
                    main_screen_height,
                ));
            }
        }

        None
    }
}

#[cfg(not(target_os = "macos"))]
fn get_nsscreen_visible_frame(_display_id: u32, _main_screen_height: f64) -> Option<WindowBounds> {
    None
}

#[cfg(test)]
mod tests {
    use super::*;

    fn mock_displays() -> Vec<DisplayInfo> {
        vec![
            DisplayInfo {
                id: 1,
                name: Some("Main".to_string()),
                frame: WindowBounds::new(0.0, 0.0, 1920.0, 1080.0),
                visible_bounds: WindowBounds::new(0.0, 25.0, 1920.0, 1055.0),
                is_main: true,
            },
            DisplayInfo {
                id: 2,
                name: Some("Secondary".to_string()),
                frame: WindowBounds::new(1920.0, 0.0, 1920.0, 1080.0),
                visible_bounds: WindowBounds::new(1920.0, 0.0, 1920.0, 1080.0),
                is_main: false,
            },
        ]
    }

    #[test]
    fn test_relative_position() {
        let display = DisplayInfo {
            id: 1,
            name: None,
            frame: WindowBounds::new(0.0, 0.0, 1920.0, 1080.0),
            visible_bounds: WindowBounds::new(0.0, 25.0, 1920.0, 1055.0),
            is_main: true,
        };

        let window = WindowBounds::new(0.0, 25.0, 800.0, 600.0);
        let (rel_x, rel_y) = display.relative_position(&window);
        assert!((rel_x - 0.0).abs() < 0.001);
        assert!((rel_y - 0.0).abs() < 0.001);
    }

    #[test]
    fn test_apply_relative_position() {
        let display = DisplayInfo {
            id: 1,
            name: None,
            frame: WindowBounds::new(0.0, 0.0, 1920.0, 1080.0),
            visible_bounds: WindowBounds::new(0.0, 25.0, 1920.0, 1055.0),
            is_main: true,
        };

        let bounds = display.apply_relative_position(0.5, 0.5, 800.0, 600.0);
        assert_eq!(bounds.x, 960.0);
        assert_eq!(bounds.y, 552.5);
        assert_eq!(bounds.width, 800.0);
        assert_eq!(bounds.height, 600.0);
    }

    #[test]
    fn test_window_fully_on_main() {
        let displays = mock_displays();
        let window = WindowBounds::new(100.0, 100.0, 800.0, 600.0);

        let display = get_display_for_window(&window, &displays);
        assert!(display.is_some());
        assert_eq!(display.unwrap().id, 1);
    }

    #[test]
    fn test_window_fully_on_secondary() {
        let displays = mock_displays();
        let window = WindowBounds::new(2000.0, 100.0, 800.0, 600.0);

        let display = get_display_for_window(&window, &displays);
        assert!(display.is_some());
        assert_eq!(display.unwrap().id, 2);
    }

    #[test]
    fn test_window_spanning_displays() {
        let displays = mock_displays();
        // Window mostly on secondary (larger overlap)
        let window = WindowBounds::new(1800.0, 100.0, 400.0, 600.0);

        let display = get_display_for_window(&window, &displays);
        assert!(display.is_some());
        // 120px on main, 280px on secondary -> secondary wins
        assert_eq!(display.unwrap().id, 2);
    }

    #[test]
    fn test_window_not_on_any_display() {
        let displays = mock_displays();
        let window = WindowBounds::new(5000.0, 5000.0, 800.0, 600.0);

        let display = get_display_for_window(&window, &displays);
        assert!(display.is_none());
    }
}

</file>

<file path="src/window_state.rs">
//! Window State Persistence
//!
//! This module handles saving and restoring window positions for the main launcher,
//! Notes window, and AI window. Positions are stored in `~/.sk/kit/window-state.json`.
//!
//! # Architecture (Following Expert Review Recommendations)
//!
//! 1. **Canonical coordinate space**: "Global top-left origin (CoreGraphics-style), y increases downward"
//! 2. **Persistence via WindowBounds**: Aligns with GPUI's `WindowBounds` (Windowed/Maximized/Fullscreen)
//! 3. **Restore via WindowOptions.window_bounds**: No "jump after open"
//! 4. **Validation via geometry intersection**: Not display IDs (which can change)
//! 5. **Save on close/hide**: Main window saves on hide (since it's often hidden not closed)

use gpui::{point, px, Bounds, Pixels, WindowBounds};
use serde::{Deserialize, Serialize};
use std::fs;
use std::path::PathBuf;

use crate::logging;
use crate::platform::DisplayBounds;

// ============================================================================
// Types
// ============================================================================

/// Identifies which window we're tracking
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
pub enum WindowRole {
    Main,
    Notes,
    Ai,
}

impl WindowRole {
    /// Get a lowercase string key for persistence/file paths
    pub fn as_str(&self) -> &'static str {
        match self {
            WindowRole::Main => "main",
            WindowRole::Notes => "notes",
            WindowRole::Ai => "ai",
        }
    }

    /// Get a human-readable name for logging
    pub fn name(&self) -> &'static str {
        match self {
            WindowRole::Main => "Main",
            WindowRole::Notes => "Notes",
            WindowRole::Ai => "AI",
        }
    }
}

/// Window mode (matches GPUI WindowBounds variants)
#[derive(Debug, Clone, Copy, Serialize, Deserialize, PartialEq, Eq, Default)]
#[serde(rename_all = "lowercase")]
pub enum PersistedWindowMode {
    #[default]
    Windowed,
    Maximized,
    Fullscreen,
}

/// Persisted bounds for a single window.
/// Uses canonical "top-left origin" coordinates.
#[derive(Debug, Clone, Copy, Serialize, Deserialize)]
pub struct PersistedWindowBounds {
    pub mode: PersistedWindowMode,
    pub x: f64,
    pub y: f64,
    pub width: f64,
    pub height: f64,
}

impl Default for PersistedWindowBounds {
    fn default() -> Self {
        Self {
            mode: PersistedWindowMode::Windowed,
            x: 0.0,
            y: 0.0,
            width: 750.0,
            height: 475.0,
        }
    }
}

impl PersistedWindowBounds {
    /// Convert to GPUI WindowBounds
    #[allow(clippy::wrong_self_convention)]
    pub fn to_gpui(&self) -> WindowBounds {
        let bounds = Bounds {
            origin: point(px(self.x as f32), px(self.y as f32)),
            size: gpui::size(px(self.width as f32), px(self.height as f32)),
        };
        match self.mode {
            PersistedWindowMode::Windowed => WindowBounds::Windowed(bounds),
            PersistedWindowMode::Maximized => WindowBounds::Maximized(bounds),
            PersistedWindowMode::Fullscreen => WindowBounds::Fullscreen(bounds),
        }
    }

    /// Create from GPUI WindowBounds
    pub fn from_gpui(wb: WindowBounds) -> Self {
        let (mode, b): (PersistedWindowMode, Bounds<Pixels>) = match wb {
            WindowBounds::Windowed(b) => (PersistedWindowMode::Windowed, b),
            WindowBounds::Maximized(b) => (PersistedWindowMode::Maximized, b),
            WindowBounds::Fullscreen(b) => (PersistedWindowMode::Fullscreen, b),
        };
        Self {
            mode,
            x: f64::from(b.origin.x),
            y: f64::from(b.origin.y),
            width: f64::from(b.size.width),
            height: f64::from(b.size.height),
        }
    }

    /// Create from raw coordinates (already in top-left canonical space)
    pub fn new(x: f64, y: f64, width: f64, height: f64) -> Self {
        Self {
            mode: PersistedWindowMode::Windowed,
            x,
            y,
            width,
            height,
        }
    }
}

/// The full persisted state file
#[derive(Debug, Clone, Serialize, Deserialize, Default)]
pub struct WindowStateFile {
    #[serde(default = "default_version")]
    pub version: u32,
    pub main: Option<PersistedWindowBounds>,
    pub notes: Option<PersistedWindowBounds>,
    pub ai: Option<PersistedWindowBounds>,
}

fn default_version() -> u32 {
    1
}

// ============================================================================
// File Path
// ============================================================================

/// Get the path to the window state file: ~/.sk/kit/window-state.json
pub fn get_state_file_path() -> PathBuf {
    let home = dirs::home_dir().unwrap_or_else(|| PathBuf::from("."));
    home.join(".sk").join("kit").join("window-state.json")
}

// ============================================================================
// Load / Save
// ============================================================================

/// Load the entire window state file
pub fn load_state_file() -> Option<WindowStateFile> {
    let path = get_state_file_path();
    if !path.exists() {
        return None;
    }
    match fs::read_to_string(&path) {
        Ok(contents) => match serde_json::from_str(&contents) {
            Ok(state) => Some(state),
            Err(e) => {
                logging::log(
                    "WINDOW_STATE",
                    &format!("Failed to parse window-state.json: {}", e),
                );
                None
            }
        },
        Err(e) => {
            logging::log(
                "WINDOW_STATE",
                &format!("Failed to read window-state.json: {}", e),
            );
            None
        }
    }
}

/// Save the entire window state file (atomic write)
pub fn save_state_file(state: &WindowStateFile) -> bool {
    let path = get_state_file_path();
    if let Some(parent) = path.parent() {
        if let Err(e) = fs::create_dir_all(parent) {
            logging::log(
                "WINDOW_STATE",
                &format!("Failed to create directory: {}", e),
            );
            return false;
        }
    }
    let json = match serde_json::to_string_pretty(state) {
        Ok(j) => j,
        Err(e) => {
            logging::log("WINDOW_STATE", &format!("Failed to serialize: {}", e));
            return false;
        }
    };
    // Atomic write: temp file then rename
    let tmp_path = path.with_extension("json.tmp");
    if let Err(e) = fs::write(&tmp_path, &json) {
        logging::log("WINDOW_STATE", &format!("Failed to write temp file: {}", e));
        return false;
    }
    if let Err(e) = fs::rename(&tmp_path, &path) {
        logging::log(
            "WINDOW_STATE",
            &format!("Failed to rename temp file: {}", e),
        );
        let _ = fs::remove_file(&tmp_path);
        return false;
    }
    logging::log("WINDOW_STATE", "Window state saved successfully");
    true
}

/// Load bounds for a specific window role
pub fn load_window_bounds(role: WindowRole) -> Option<PersistedWindowBounds> {
    let state = load_state_file()?;
    match role {
        WindowRole::Main => state.main,
        WindowRole::Notes => state.notes,
        WindowRole::Ai => state.ai,
    }
}

/// Save bounds for a specific window role
pub fn save_window_bounds(role: WindowRole, bounds: PersistedWindowBounds) {
    let mut state = load_state_file().unwrap_or_default();
    state.version = 1;
    match role {
        WindowRole::Main => state.main = Some(bounds),
        WindowRole::Notes => state.notes = Some(bounds),
        WindowRole::Ai => state.ai = Some(bounds),
    }
    save_state_file(&state);
    logging::log(
        "WINDOW_STATE",
        &format!(
            "Saved {} bounds: ({:.0}, {:.0}) {}x{}",
            role.as_str(),
            bounds.x,
            bounds.y,
            bounds.width,
            bounds.height
        ),
    );
}

/// Reset all window positions (delete the state file)
pub fn reset_all_positions() {
    let path = get_state_file_path();
    if path.exists() {
        if let Err(e) = fs::remove_file(&path) {
            logging::log("WINDOW_STATE", &format!("Failed to delete: {}", e));
        } else {
            logging::log("WINDOW_STATE", "All window positions reset to defaults");
        }
    }
}

/// Check if any window positions have been customized
pub fn has_custom_positions() -> bool {
    load_state_file().is_some_and(|s| s.main.is_some() || s.notes.is_some() || s.ai.is_some())
}

// ============================================================================
// Visibility Validation
// ============================================================================

const MIN_VISIBLE_AREA: f64 = 64.0 * 64.0;
const MIN_EDGE_MARGIN: f64 = 50.0;

/// Check if saved bounds are still visible on current displays.
pub fn is_bounds_visible(bounds: &PersistedWindowBounds, displays: &[DisplayBounds]) -> bool {
    if displays.is_empty() {
        return false;
    }
    for display in displays {
        if let Some((_, _, w, h)) = rect_intersection(
            bounds.x,
            bounds.y,
            bounds.width,
            bounds.height,
            display.origin_x,
            display.origin_y,
            display.width,
            display.height,
        ) {
            if w * h >= MIN_VISIBLE_AREA {
                return true;
            }
        }
    }
    false
}

#[allow(clippy::too_many_arguments)]
fn rect_intersection(
    x1: f64,
    y1: f64,
    w1: f64,
    h1: f64,
    x2: f64,
    y2: f64,
    w2: f64,
    h2: f64,
) -> Option<(f64, f64, f64, f64)> {
    let left = x1.max(x2);
    let top = y1.max(y2);
    let right = (x1 + w1).min(x2 + w2);
    let bottom = (y1 + h1).min(y2 + h2);
    if left < right && top < bottom {
        Some((left, top, right - left, bottom - top))
    } else {
        None
    }
}

/// Clamp bounds to ensure window is visible and grabbable on given displays.
pub fn clamp_bounds_to_displays(
    bounds: &PersistedWindowBounds,
    displays: &[DisplayBounds],
) -> Option<PersistedWindowBounds> {
    if displays.is_empty() {
        return None;
    }
    let target = find_best_display_for_bounds(bounds, displays)?;
    let mut clamped = *bounds;
    clamped.width = clamped.width.min(target.width - MIN_EDGE_MARGIN * 2.0);
    clamped.height = clamped.height.min(target.height - MIN_EDGE_MARGIN * 2.0);
    let min_x = target.origin_x + MIN_EDGE_MARGIN;
    let max_x = target.origin_x + target.width - clamped.width - MIN_EDGE_MARGIN;
    clamped.x = clamped.x.max(min_x).min(max_x);
    let min_y = target.origin_y + MIN_EDGE_MARGIN;
    let max_y = target.origin_y + target.height - clamped.height - MIN_EDGE_MARGIN;
    clamped.y = clamped.y.max(min_y).min(max_y);
    Some(clamped)
}

fn find_best_display_for_bounds<'a>(
    bounds: &PersistedWindowBounds,
    displays: &'a [DisplayBounds],
) -> Option<&'a DisplayBounds> {
    let cx = bounds.x + bounds.width / 2.0;
    let cy = bounds.y + bounds.height / 2.0;
    for d in displays {
        if cx >= d.origin_x
            && cx < d.origin_x + d.width
            && cy >= d.origin_y
            && cy < d.origin_y + d.height
        {
            return Some(d);
        }
    }
    let mut best: Option<&DisplayBounds> = None;
    let mut best_area = 0.0;
    for d in displays {
        if let Some((_, _, w, h)) = rect_intersection(
            bounds.x,
            bounds.y,
            bounds.width,
            bounds.height,
            d.origin_x,
            d.origin_y,
            d.width,
            d.height,
        ) {
            if w * h > best_area {
                best_area = w * h;
                best = Some(d);
            }
        }
    }
    best.or_else(|| displays.first())
}

// ============================================================================
// High-Level API
// ============================================================================

/// Get initial bounds for a window, trying saved position first, then fallback.
pub fn get_initial_bounds(
    role: WindowRole,
    default_bounds: Bounds<Pixels>,
    displays: &[DisplayBounds],
) -> Bounds<Pixels> {
    if let Some(saved) = load_window_bounds(role) {
        if is_bounds_visible(&saved, displays) {
            logging::log(
                "WINDOW_STATE",
                &format!(
                    "Restoring {} to ({:.0}, {:.0})",
                    role.as_str(),
                    saved.x,
                    saved.y
                ),
            );
            return saved.to_gpui().get_bounds();
        }
        if let Some(clamped) = clamp_bounds_to_displays(&saved, displays) {
            logging::log(
                "WINDOW_STATE",
                &format!(
                    "Clamped {} to ({:.0}, {:.0})",
                    role.as_str(),
                    clamped.x,
                    clamped.y
                ),
            );
            return clamped.to_gpui().get_bounds();
        }
        logging::log(
            "WINDOW_STATE",
            &format!("{} saved position no longer visible", role.as_str()),
        );
    }
    default_bounds
}

/// Save window bounds from current GPUI window state.
pub fn save_window_from_gpui(role: WindowRole, window_bounds: WindowBounds) {
    save_window_bounds(role, PersistedWindowBounds::from_gpui(window_bounds));
}

// Tests are in src/window_state_persistence_tests.rs

</file>

<file path="src/window_resize.rs">
//! Dynamic Window Resizing Module
//!
//! Handles window height for different view types in Script Kit GPUI.
//!
//! **Key Rules:**
//! - ScriptList (main window with preview): FIXED at 500px, never resizes
//! - ArgPrompt with choices: Dynamic height based on choice count (capped at 500px)
//! - ArgPrompt without choices (input only): Compact input-only height
//! - Editor/Div/Term: Full height 700px

#[cfg(target_os = "macos")]
use cocoa::foundation::{NSPoint, NSRect, NSSize};
#[cfg(target_os = "macos")]
use objc::{msg_send, sel, sel_impl};

use gpui::{px, Pixels};
use tracing::{debug, warn};

use crate::logging;

use crate::list_item::LIST_ITEM_HEIGHT;
use crate::window_manager;

/// Layout constants for height calculations
pub mod layout {
    use crate::panel::{CURSOR_HEIGHT_LG, CURSOR_MARGIN_Y};
    use gpui::{px, Pixels};

    /// Input row vertical padding (matches default design spacing padding_md)
    pub const ARG_INPUT_PADDING_Y: f32 = 12.0;
    /// List container vertical padding (top + bottom, matches default padding_xs)
    pub const ARG_LIST_PADDING_Y: f32 = 8.0;
    /// Divider thickness (matches default design border_thin)
    pub const ARG_DIVIDER_HEIGHT: f32 = 1.0;
    /// Input row text height (cursor height + margins)
    pub const ARG_INPUT_LINE_HEIGHT: f32 = CURSOR_HEIGHT_LG + (CURSOR_MARGIN_Y * 2.0);
    /// Footer height (matches PromptFooter)
    pub const FOOTER_HEIGHT: f32 = 30.0;
    /// Total input-only height (header only, no list, but with footer)
    pub const ARG_HEADER_HEIGHT: f32 =
        (ARG_INPUT_PADDING_Y * 2.0) + ARG_INPUT_LINE_HEIGHT + FOOTER_HEIGHT;

    /// Minimum window height (input only) - for input-only prompts
    pub const MIN_HEIGHT: Pixels = px(ARG_HEADER_HEIGHT);

    /// Standard height for views with preview panel (script list, arg with choices)
    /// This is FIXED - these views do NOT resize dynamically
    pub const STANDARD_HEIGHT: Pixels = px(500.0);

    /// Maximum window height for full-content views (editor, div, term)
    pub const MAX_HEIGHT: Pixels = px(700.0);
}

/// View types for height calculation
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum ViewType {
    /// Script list view (main launcher) - has preview panel, FIXED height
    ScriptList,
    /// Arg prompt with choices - dynamic height based on item count
    ArgPromptWithChoices,
    /// Arg prompt without choices (input only) - compact height
    ArgPromptNoChoices,
    /// Div prompt (HTML display) - full height
    DivPrompt,
    /// Editor prompt (code editor) - full height
    EditorPrompt,
    /// Terminal prompt - full height
    TermPrompt,
}

/// Get the target height for a specific view type
///
/// # Arguments
/// * `view_type` - The type of view being displayed
/// * `item_count` - Number of items in the current view (used for dynamic sizing)
///
/// # Returns
/// The window height for this view type
pub fn height_for_view(view_type: ViewType, item_count: usize) -> Pixels {
    use layout::*;

    let clamp_height = |height: Pixels| -> Pixels {
        let height_f = f32::from(height);
        let min_f = f32::from(MIN_HEIGHT);
        let max_f = f32::from(STANDARD_HEIGHT);
        px(height_f.clamp(min_f, max_f))
    };

    match view_type {
        // Views with preview panel - FIXED height, no dynamic resizing
        // DivPrompt also uses standard height to match main window
        ViewType::ScriptList | ViewType::DivPrompt => STANDARD_HEIGHT,
        ViewType::ArgPromptWithChoices => {
            let visible_items = item_count.max(1) as f32;
            let list_height =
                (visible_items * LIST_ITEM_HEIGHT) + ARG_LIST_PADDING_Y + ARG_DIVIDER_HEIGHT;
            let total_height = ARG_HEADER_HEIGHT + list_height;
            clamp_height(px(total_height))
        }
        // Input-only prompt - compact
        ViewType::ArgPromptNoChoices => MIN_HEIGHT,
        // Full content views (editor, terminal) - max height
        ViewType::EditorPrompt | ViewType::TermPrompt => MAX_HEIGHT,
    }
}

/// Calculate the initial window height for app startup
pub fn initial_window_height() -> Pixels {
    layout::STANDARD_HEIGHT
}

/// Defer a window resize to the end of the current effect cycle.
///
/// This version uses `Window::defer()` for coalesced, deferred execution.
/// Use when you have direct Window access (e.g., in window update closures, hotkey handlers).
///
/// # Arguments
/// * `view_type` - The type of view to resize for
/// * `item_count` - Item count (used for some view types)
/// * `window` - The GPUI Window reference
/// * `cx` - The GPUI App context
///
pub fn defer_resize_to_view(
    view_type: ViewType,
    item_count: usize,
    window: &mut gpui::Window,
    cx: &mut gpui::App,
) {
    let target_height = height_for_view(view_type, item_count);
    crate::window_ops::queue_resize(f32::from(target_height), window, cx);
}

/// Resize window synchronously based on view type.
///
/// Use this version when you only have ViewContext access (e.g., in prompt message handlers
/// running from async tasks via `cx.spawn`). These handlers run outside the render cycle,
/// so direct resize is safe and won't cause RefCell borrow conflicts.
///
/// # Arguments
/// * `view_type` - The type of view to resize for
/// * `item_count` - Item count (used for some view types)
///
/// # Example
/// ```rust,ignore
/// // In handle_prompt_message or similar ViewContext methods:
/// resize_to_view_sync(ViewType::ArgPromptWithChoices, choices.len());
/// ```
pub fn resize_to_view_sync(view_type: ViewType, item_count: usize) {
    let target_height = height_for_view(view_type, item_count);
    resize_first_window_to_height(target_height);
}

/// Force reset the debounce timer (kept for API compatibility)
pub fn reset_resize_debounce() {
    // No-op - we removed debouncing since resizes are now rare
}

/// Resize the main window to a new height, keeping the top edge fixed.
///
/// # Arguments
/// * `target_height` - The desired window height in pixels
///
/// # Platform
/// This function only works on macOS. On other platforms, it's a no-op.
#[cfg(target_os = "macos")]
pub fn resize_first_window_to_height(target_height: Pixels) {
    let height_f64: f64 = f32::from(target_height) as f64;

    // Get the main window from WindowManager
    let window = match window_manager::get_main_window() {
        Some(w) => w,
        None => {
            warn!("Main window not registered in WindowManager, cannot resize");
            logging::log(
                "RESIZE",
                "WARNING: Main window not registered in WindowManager.",
            );
            return;
        }
    };

    unsafe {
        // Get current window frame
        let current_frame: NSRect = msg_send![window, frame];

        // Skip if height is already correct (within 1px tolerance)
        let current_height = current_frame.size.height;
        if (current_height - height_f64).abs() < 1.0 {
            return;
        }

        // Log actual resizes at debug level (these are rare events, not hot-path)
        debug!(
            from_height = current_height,
            to_height = height_f64,
            "Resizing window"
        );
        logging::log(
            "RESIZE",
            &format!("Resize: {:.0} -> {:.0}", current_height, height_f64),
        );

        // Calculate height difference
        let height_delta = height_f64 - current_height;

        // macOS coordinate system: Y=0 at bottom, increases upward
        // To keep the TOP of the window fixed, adjust origin.y
        let new_origin_y = current_frame.origin.y - height_delta;

        let new_frame = NSRect::new(
            NSPoint::new(current_frame.origin.x, new_origin_y),
            NSSize::new(current_frame.size.width, height_f64),
        );

        // Apply the new frame
        let _: () = msg_send![window, setFrame:new_frame display:true animate:false];
    }
}

/// Get the current height of the main window
#[allow(dead_code)]
#[cfg(target_os = "macos")]
pub fn get_first_window_height() -> Option<Pixels> {
    let window = window_manager::get_main_window()?;

    unsafe {
        let frame: NSRect = msg_send![window, frame];
        Some(px(frame.size.height as f32))
    }
}

/// Non-macOS stub for resize function
#[cfg(not(target_os = "macos"))]
pub fn resize_first_window_to_height(_target_height: Pixels) {
    logging::log("RESIZE", "Window resize is only supported on macOS");
}

/// Non-macOS stub for get_first_window_height
#[allow(dead_code)]
#[cfg(not(target_os = "macos"))]
pub fn get_first_window_height() -> Option<Pixels> {
    None
}

#[cfg(test)]
mod tests {
    use super::*;
    use gpui::px;

    #[test]
    fn test_script_list_fixed_height() {
        // Script list should always be STANDARD_HEIGHT regardless of item count
        assert_eq!(
            height_for_view(ViewType::ScriptList, 0),
            layout::STANDARD_HEIGHT
        );
        assert_eq!(
            height_for_view(ViewType::ScriptList, 5),
            layout::STANDARD_HEIGHT
        );
        assert_eq!(
            height_for_view(ViewType::ScriptList, 100),
            layout::STANDARD_HEIGHT
        );
    }

    #[test]
    fn test_arg_with_choices_dynamic_height() {
        // Arg with choices should size to items, clamped to STANDARD_HEIGHT
        let base_height =
            layout::ARG_HEADER_HEIGHT + layout::ARG_DIVIDER_HEIGHT + layout::ARG_LIST_PADDING_Y;
        assert_eq!(
            height_for_view(ViewType::ArgPromptWithChoices, 1),
            px(base_height + LIST_ITEM_HEIGHT)
        );
        assert_eq!(
            height_for_view(ViewType::ArgPromptWithChoices, 2),
            px(base_height + (2.0 * LIST_ITEM_HEIGHT))
        );
        assert_eq!(
            height_for_view(ViewType::ArgPromptWithChoices, 100),
            layout::STANDARD_HEIGHT
        );
    }

    #[test]
    fn test_arg_no_choices_compact() {
        // Arg without choices should be MIN_HEIGHT
        assert_eq!(
            height_for_view(ViewType::ArgPromptNoChoices, 0),
            layout::MIN_HEIGHT
        );
    }

    #[test]
    fn test_full_height_views() {
        // Editor and Terminal use MAX_HEIGHT (700px)
        assert_eq!(
            height_for_view(ViewType::EditorPrompt, 0),
            layout::MAX_HEIGHT
        );
        assert_eq!(height_for_view(ViewType::TermPrompt, 0), layout::MAX_HEIGHT);
    }

    #[test]
    fn test_div_prompt_standard_height() {
        // DivPrompt uses STANDARD_HEIGHT (500px) to match main window
        assert_eq!(
            height_for_view(ViewType::DivPrompt, 0),
            layout::STANDARD_HEIGHT
        );
    }

    #[test]
    fn test_initial_window_height() {
        assert_eq!(initial_window_height(), layout::STANDARD_HEIGHT);
    }

    #[test]
    fn test_height_constants() {
        assert_eq!(layout::MIN_HEIGHT, px(layout::ARG_HEADER_HEIGHT));
        assert_eq!(layout::STANDARD_HEIGHT, px(500.0));
        assert_eq!(layout::MAX_HEIGHT, px(700.0));
    }
}

</file>

<file path="src/window_ops.rs">
//! Coalescing Window Operations Module
//!
//! Provides coalesced window resize and move operations using GPUI's Window::defer API.
//!
//! # Why Coalescing?
//!
//! During rapid UI updates (filtering, typing, state changes), multiple resize/move requests
//! can fire in quick succession. Without coalescing, each request would trigger a macOS
//! window operation, causing:
//! - Visual jitter/flicker
//! - Performance degradation from redundant system calls
//! - Potential RefCell borrow conflicts during GPUI's render cycle
//!
//! # How It Works
//!
//! 1. Callers call `queue_resize()` or `queue_move()` with their desired values
//! 2. The value is stored in a pending slot (overwrites any previous pending value)
//! 3. A `Window::defer()` callback is scheduled (only once per effect cycle)
//! 4. At the end of the effect cycle, `flush_pending_ops()` executes the final values
//!
//! This ensures only ONE window operation happens per effect cycle, using the latest values.
//!
//! # Usage
//!
//! ```rust,ignore
//! // Instead of direct resize:
//! // platform::resize_first_window_to_height(height);
//!
//! // Use coalesced queue:
//! window_ops::queue_resize(height, window, cx);
//! ```

use std::sync::atomic::{AtomicBool, Ordering};
use std::sync::Mutex;

use gpui::{Bounds, Pixels, Window};

use crate::logging;
use crate::platform;
use crate::window_resize;

// ============================================================================
// Coalescing State
// ============================================================================

/// Pending resize height (if Some, a resize is pending)
static PENDING_RESIZE: Mutex<Option<f32>> = Mutex::new(None);

/// Pending move bounds (if Some, a move is pending)
static PENDING_BOUNDS: Mutex<Option<Bounds<Pixels>>> = Mutex::new(None);

/// Whether a flush has been scheduled for this effect cycle
static FLUSH_SCHEDULED: AtomicBool = AtomicBool::new(false);

// ============================================================================
// Public API
// ============================================================================

/// Queue a window resize to happen at the end of the current effect cycle.
///
/// Multiple calls within the same cycle will coalesce - only the final height is used.
///
/// # Arguments
/// * `target_height` - The desired window height in pixels
/// * `window` - The GPUI Window reference (used for defer scheduling)
/// * `cx` - The GPUI App context
///
/// # Example
/// ```rust,ignore
/// use crate::window_ops;
///
/// // In a message handler or event callback:
/// window_ops::queue_resize(500.0, window, cx);
/// ```
pub fn queue_resize(target_height: f32, window: &mut Window, cx: &mut gpui::App) {
    // Store the pending height (overwrites any previous pending value)
    *PENDING_RESIZE.lock().unwrap() = Some(target_height);

    logging::log(
        "WINDOW_OPS",
        &format!("Queued resize to height: {:.0}px", target_height),
    );

    // Schedule flush if not already scheduled
    schedule_flush(window, cx);
}

/// Queue a window move to happen at the end of the current effect cycle.
///
/// Multiple calls within the same cycle will coalesce - only the final bounds are used.
///
/// # Arguments
/// * `bounds` - The desired window bounds (position + size)
/// * `window` - The GPUI Window reference (used for defer scheduling)
/// * `cx` - The GPUI App context
///
/// # Example
/// ```rust,ignore
/// use crate::window_ops;
/// use gpui::{point, px, size, Bounds};
///
/// let bounds = Bounds {
///     origin: point(px(100.0), px(200.0)),
///     size: size(px(750.0), px(500.0)),
/// };
/// window_ops::queue_move(bounds, window, cx);
/// ```
pub fn queue_move(bounds: Bounds<Pixels>, window: &mut Window, cx: &mut gpui::App) {
    // Store the pending bounds (overwrites any previous pending value)
    *PENDING_BOUNDS.lock().unwrap() = Some(bounds);

    logging::log(
        "WINDOW_OPS",
        &format!(
            "Queued move to bounds: origin=({:.0}, {:.0}) size={:.0}x{:.0}",
            f32::from(bounds.origin.x),
            f32::from(bounds.origin.y),
            f32::from(bounds.size.width),
            f32::from(bounds.size.height),
        ),
    );

    // Schedule flush if not already scheduled
    schedule_flush(window, cx);
}

/// Check if there are any pending window operations.
///
/// Useful for debugging or testing.
#[allow(dead_code)]
pub fn has_pending_ops() -> bool {
    PENDING_RESIZE.lock().unwrap().is_some() || PENDING_BOUNDS.lock().unwrap().is_some()
}

/// Clear all pending operations without executing them.
///
/// Use this when the window is being hidden/closed to avoid stale operations.
#[allow(dead_code)]
pub fn clear_pending_ops() {
    *PENDING_RESIZE.lock().unwrap() = None;
    *PENDING_BOUNDS.lock().unwrap() = None;
    FLUSH_SCHEDULED.store(false, Ordering::SeqCst);
    logging::log("WINDOW_OPS", "Cleared all pending operations");
}

// ============================================================================
// Internal Implementation
// ============================================================================

/// Schedule the flush callback if not already scheduled.
///
/// Uses Window::defer to run at the end of the current effect cycle.
fn schedule_flush(window: &mut Window, cx: &mut gpui::App) {
    // Only schedule once per effect cycle
    if !FLUSH_SCHEDULED.swap(true, Ordering::SeqCst) {
        logging::log("WINDOW_OPS", "Scheduling flush via Window::defer");

        window.defer(cx, |_window, _cx| {
            flush_pending_ops();
        });
    }
}

/// Execute all pending window operations.
///
/// Called by the deferred callback at the end of the effect cycle.
fn flush_pending_ops() {
    // Reset the scheduled flag FIRST (allows new operations to schedule a new flush)
    FLUSH_SCHEDULED.store(false, Ordering::SeqCst);

    // Execute pending resize if any
    if let Some(height) = PENDING_RESIZE.lock().unwrap().take() {
        logging::log(
            "WINDOW_OPS",
            &format!("Flushing resize to height: {:.0}px", height),
        );
        window_resize::resize_first_window_to_height(gpui::px(height));
    }

    // Execute pending move if any
    if let Some(bounds) = PENDING_BOUNDS.lock().unwrap().take() {
        logging::log(
            "WINDOW_OPS",
            &format!(
                "Flushing move to bounds: origin=({:.0}, {:.0}) size={:.0}x{:.0}",
                f32::from(bounds.origin.x),
                f32::from(bounds.origin.y),
                f32::from(bounds.size.width),
                f32::from(bounds.size.height),
            ),
        );
        platform::move_first_window_to_bounds(&bounds);
    }
}

// ============================================================================
// Tests
// ============================================================================

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_pending_resize_state() {
        // Clear any leftover state
        clear_pending_ops();

        // Initially no pending ops
        assert!(!has_pending_ops());

        // Manually set pending resize (simulating what queue_resize does internally)
        *PENDING_RESIZE.lock().unwrap() = Some(500.0);
        assert!(has_pending_ops());

        // Clear clears it
        clear_pending_ops();
        assert!(!has_pending_ops());
    }

    #[test]
    fn test_pending_bounds_state() {
        use gpui::{point, px, size};

        clear_pending_ops();
        assert!(!has_pending_ops());

        // Manually set pending bounds
        let bounds = Bounds {
            origin: point(px(100.0), px(200.0)),
            size: size(px(750.0), px(500.0)),
        };
        *PENDING_BOUNDS.lock().unwrap() = Some(bounds);
        assert!(has_pending_ops());

        clear_pending_ops();
        assert!(!has_pending_ops());
    }

    #[test]
    fn test_flush_clears_state() {
        clear_pending_ops();

        // Set some pending state
        *PENDING_RESIZE.lock().unwrap() = Some(700.0);
        FLUSH_SCHEDULED.store(true, Ordering::SeqCst);

        // Note: We can't test the actual flush_pending_ops() without mocking platform functions,
        // but we can verify the state management
        assert!(has_pending_ops());
        assert!(FLUSH_SCHEDULED.load(Ordering::SeqCst));

        // Clear should reset everything
        clear_pending_ops();
        assert!(!has_pending_ops());
        assert!(!FLUSH_SCHEDULED.load(Ordering::SeqCst));
    }

    #[test]
    fn test_coalesce_multiple_resizes() {
        clear_pending_ops();

        // Simulate multiple resize requests (what happens in practice)
        *PENDING_RESIZE.lock().unwrap() = Some(400.0);
        *PENDING_RESIZE.lock().unwrap() = Some(500.0);
        *PENDING_RESIZE.lock().unwrap() = Some(600.0);

        // Only the last value should be stored
        assert_eq!(*PENDING_RESIZE.lock().unwrap(), Some(600.0));

        clear_pending_ops();
    }

    #[test]
    fn test_coalesce_multiple_moves() {
        use gpui::{point, px, size};

        clear_pending_ops();

        // Simulate multiple move requests
        let bounds1 = Bounds {
            origin: point(px(0.0), px(0.0)),
            size: size(px(750.0), px(500.0)),
        };
        let bounds2 = Bounds {
            origin: point(px(100.0), px(100.0)),
            size: size(px(750.0), px(500.0)),
        };
        let bounds3 = Bounds {
            origin: point(px(200.0), px(200.0)),
            size: size(px(750.0), px(500.0)),
        };

        *PENDING_BOUNDS.lock().unwrap() = Some(bounds1);
        *PENDING_BOUNDS.lock().unwrap() = Some(bounds2);
        *PENDING_BOUNDS.lock().unwrap() = Some(bounds3);

        // Only the last value should be stored
        let pending = PENDING_BOUNDS.lock().unwrap();
        assert!(pending.is_some());
        let bounds = pending.unwrap();
        assert_eq!(f32::from(bounds.origin.x), 200.0);
        assert_eq!(f32::from(bounds.origin.y), 200.0);

        drop(pending);
        clear_pending_ops();
    }
}

</file>

<file path="src/window_manager.rs">
//! Window Manager Module for Script Kit GPUI
//!
//! # Problem
//! When GPUI creates windows and macOS creates tray icons, the app's windows array
//! contains multiple windows in unpredictable order. Using `objectAtIndex:0` to find
//! "our" window fails because:
//! - Tray icon popups appear as windows
//! - Menu bar items create windows
//! - System overlays create windows
//!
//! Debug logs showed:
//! - Window[0]: 34x24 - Tray icon popup
//! - Window[1]: 0x37 - Menu bar
//! - Window[2]: 0x24 - System window
//! - Window[3]: 750x501 - Our main window (the one we want!)
//!
//! # Solution
//! This module provides a thread-safe registry to track our windows by role.
//! After GPUI creates a window, we register it with its role (MainWindow, etc.)
//! and later retrieve it reliably, avoiding the index-based lookup problem.
//!
//! # Architecture
//!
//! ```text
//! 
//!                     Window Manager Architecture                       
//! 
//!                                                                       
//!            
//!     main.rs               WindowManager (Global Singleton)      
//!                                                                  
//!    cx.open_window()           
//!                    OnceLock<Mutex<WindowManager>>       
//!                                                               
//!    register_             windows: HashMap<WindowRole,id>       
//!      main_window                                               
//!                          MainWindow -> id                     
//!            (future roles...)                    
//!                                
//!                                                    
//!    window_             Public API:                              
//!    resize.rs       register_window(role, id)              
//!                         get_window(role) -> Option<id>         
//!    get_main_       get_main_window() -> Option<id>        
//!      window()           find_main_window_by_size()             
//!            
//!                                                                       
//! 
//! ```
//!
//!
//! # Thread Safety
//!
//! The module uses `OnceLock<Mutex<WindowManager>>` for thread-safe global access:
//! - `OnceLock` ensures one-time initialization (like lazy_static but in std)
//! - `Mutex` protects concurrent access to the HashMap
//! - All public functions handle locking internally
//!
//! # Platform Support
//!
//! This module is macOS-specific. On other platforms, all functions are no-ops
//! that return None or do nothing.

#[cfg(target_os = "macos")]
use cocoa::appkit::NSApp;
#[cfg(target_os = "macos")]
use cocoa::base::{id, nil};
#[cfg(target_os = "macos")]
use cocoa::foundation::NSRect;
#[cfg(target_os = "macos")]
use objc::{msg_send, sel, sel_impl};

#[cfg(target_os = "macos")]
use std::collections::HashMap;
#[cfg(target_os = "macos")]
use std::sync::{Mutex, OnceLock};

#[cfg(target_os = "macos")]
use crate::logging;

// Re-export the canonical WindowRole from window_state
// This ensures a single source of truth for window roles across the codebase
pub use crate::window_state::WindowRole;

/// A thread-safe wrapper for NSWindow ID pointers.
///
/// # Safety
///
/// This wrapper implements `Send` and `Sync` because:
/// 1. NSWindow IDs are stable identifiers that don't change
/// 2. macOS allows accessing window metadata from any thread
/// 3. Actual window mutations must still occur on the main thread
///    (enforced by the caller, not this module)
///
/// The pointer is stored as a raw address to avoid lifetime issues.
#[cfg(target_os = "macos")]
#[derive(Debug, Clone, Copy)]
struct WindowId(usize);

#[cfg(target_os = "macos")]
impl WindowId {
    /// Create a new WindowId from a native window pointer
    fn from_id(window: id) -> Self {
        Self(window as usize)
    }

    /// Convert back to a native window pointer
    fn to_id(self) -> id {
        self.0 as id
    }
}

// Safety: The window ID is just a numeric identifier. Accessing window
// properties is safe from any thread on macOS. Mutations are done on
// the main thread by the caller.
#[cfg(target_os = "macos")]
unsafe impl Send for WindowId {}
#[cfg(target_os = "macos")]
unsafe impl Sync for WindowId {}

/// Thread-safe window registry.
///
/// Maintains a mapping from window roles to their native macOS window IDs.
/// Access this through the module-level functions, not directly.
#[cfg(target_os = "macos")]
struct WindowManager {
    /// Map of window roles to their native window IDs (wrapped for thread safety)
    windows: HashMap<WindowRole, WindowId>,
}

#[cfg(target_os = "macos")]
impl WindowManager {
    /// Create a new empty WindowManager
    fn new() -> Self {
        Self {
            windows: HashMap::new(),
        }
    }

    /// Register a window with a specific role
    fn register(&mut self, role: WindowRole, window_id: id) {
        logging::log(
            "WINDOW_MGR",
            &format!("Registering window: {:?} -> {:?}", role, window_id),
        );
        self.windows.insert(role, WindowId::from_id(window_id));
    }

    /// Get a window by role
    fn get(&self, role: WindowRole) -> Option<id> {
        self.windows.get(&role).map(|wid| wid.to_id())
    }

    /// Remove a window registration
    #[allow(dead_code)]
    fn unregister(&mut self, role: WindowRole) -> Option<id> {
        logging::log("WINDOW_MGR", &format!("Unregistering window: {:?}", role));
        self.windows.remove(&role).map(|wid| wid.to_id())
    }

    /// Check if a role is registered
    #[allow(dead_code)]
    fn is_registered(&self, role: WindowRole) -> bool {
        self.windows.contains_key(&role)
    }
}

/// Global singleton for the window manager
#[cfg(target_os = "macos")]
static WINDOW_MANAGER: OnceLock<Mutex<WindowManager>> = OnceLock::new();

/// Get or initialize the global WindowManager
#[cfg(target_os = "macos")]
fn get_manager() -> &'static Mutex<WindowManager> {
    WINDOW_MANAGER.get_or_init(|| Mutex::new(WindowManager::new()))
}

// ============================================================================
// Public API - macOS Implementation
// ============================================================================

/// Register a window with a specific role.
///
/// Call this after GPUI creates a window to track it by role.
/// Subsequent calls with the same role will overwrite the previous registration.
///
/// # Arguments
/// * `role` - The purpose/role of this window
/// * `window_id` - The native macOS window ID (NSWindow pointer)
///
#[cfg(target_os = "macos")]
pub fn register_window(role: WindowRole, window_id: id) {
    if let Ok(mut manager) = get_manager().lock() {
        manager.register(role, window_id);
    } else {
        logging::log("WINDOW_MGR", "ERROR: Failed to acquire lock for register");
    }
}

/// Get a window by its role.
///
/// # Arguments
/// * `role` - The role to look up
///
/// # Returns
/// The native window ID if registered, None otherwise
#[cfg(target_os = "macos")]
pub fn get_window(role: WindowRole) -> Option<id> {
    if let Ok(manager) = get_manager().lock() {
        manager.get(role)
    } else {
        logging::log("WINDOW_MGR", "ERROR: Failed to acquire lock for get");
        None
    }
}

/// Convenience function to get the main window.
///
/// # Returns
/// The main window's native ID if registered, None otherwise
#[cfg(target_os = "macos")]
pub fn get_main_window() -> Option<id> {
    get_window(WindowRole::Main)
}

/// Find and register the main window by its expected size.
///
/// This function searches through NSApp's windows array and identifies
/// our main window by its characteristic size (750x~500 pixels).
/// This is necessary because tray icons and other system elements
/// create windows that appear before our main window in the array.
///
/// # Expected Window Size
/// - Width: ~750 pixels
/// - Height: ~400-600 pixels (varies based on content)
///
/// # Returns
/// `true` if the main window was found and registered, `false` otherwise
#[cfg(target_os = "macos")]
pub fn find_and_register_main_window() -> bool {
    // Expected main window dimensions (with tolerance)
    const EXPECTED_WIDTH: f64 = 750.0;
    const WIDTH_TOLERANCE: f64 = 50.0;
    const MIN_HEIGHT: f64 = 100.0;
    const MAX_HEIGHT: f64 = 800.0;

    unsafe {
        let app: id = NSApp();
        let windows: id = msg_send![app, windows];
        let count: usize = msg_send![windows, count];

        logging::log(
            "WINDOW_MGR",
            &format!(
                "Searching for main window among {} windows (expecting ~{:.0}x400-600)",
                count, EXPECTED_WIDTH
            ),
        );

        for i in 0..count {
            let window: id = msg_send![windows, objectAtIndex:i];
            if window == nil {
                continue;
            }

            let frame: NSRect = msg_send![window, frame];
            let width = frame.size.width;
            let height = frame.size.height;

            logging::log(
                "WINDOW_MGR",
                &format!("  Window[{}]: {:.0}x{:.0}", i, width, height),
            );

            // Check if this looks like our main window
            let width_matches = (width - EXPECTED_WIDTH).abs() < WIDTH_TOLERANCE;
            let height_matches = (MIN_HEIGHT..=MAX_HEIGHT).contains(&height);

            if width_matches && height_matches {
                logging::log(
                    "WINDOW_MGR",
                    &format!(
                        "Found main window at index {}: {:.0}x{:.0}",
                        i, width, height
                    ),
                );
                register_window(WindowRole::Main, window);
                return true;
            }
        }

        logging::log(
            "WINDOW_MGR",
            "WARNING: Could not find main window by size. No window matched expected dimensions.",
        );
        false
    }
}

/// Unregister a window by role.
///
/// # Arguments
/// * `role` - The role to unregister
///
/// # Returns
/// The previously registered window ID, if any
#[cfg(target_os = "macos")]
#[allow(dead_code)]
pub fn unregister_window(role: WindowRole) -> Option<id> {
    if let Ok(mut manager) = get_manager().lock() {
        manager.unregister(role)
    } else {
        logging::log("WINDOW_MGR", "ERROR: Failed to acquire lock for unregister");
        None
    }
}

/// Check if a window role is currently registered.
///
/// # Arguments
/// * `role` - The role to check
///
/// # Returns
/// `true` if a window is registered for this role
#[cfg(target_os = "macos")]
#[allow(dead_code)]
pub fn is_window_registered(role: WindowRole) -> bool {
    if let Ok(manager) = get_manager().lock() {
        manager.is_registered(role)
    } else {
        false
    }
}

// ============================================================================
// Public API - Non-macOS Stubs
// ============================================================================

/// Non-macOS stub: register_window is a no-op
#[cfg(not(target_os = "macos"))]
pub fn register_window(_role: WindowRole, _window_id: *mut std::ffi::c_void) {
    // No-op on non-macOS platforms
}

/// Non-macOS stub: get_window always returns None
#[cfg(not(target_os = "macos"))]
pub fn get_window(_role: WindowRole) -> Option<*mut std::ffi::c_void> {
    None
}

/// Non-macOS stub: get_main_window always returns None
#[cfg(not(target_os = "macos"))]
pub fn get_main_window() -> Option<*mut std::ffi::c_void> {
    None
}

/// Non-macOS stub: find_and_register_main_window always returns false
#[cfg(not(target_os = "macos"))]
pub fn find_and_register_main_window() -> bool {
    false
}

/// Non-macOS stub: unregister_window always returns None
#[cfg(not(target_os = "macos"))]
#[allow(dead_code)]
pub fn unregister_window(_role: WindowRole) -> Option<*mut std::ffi::c_void> {
    None
}

/// Non-macOS stub: is_window_registered always returns false
#[cfg(not(target_os = "macos"))]
#[allow(dead_code)]
pub fn is_window_registered(_role: WindowRole) -> bool {
    false
}

// ============================================================================
// Unit Tests
// ============================================================================

#[cfg(test)]
mod tests {
    use super::*;

    /// Test that WindowRole can be used as HashMap key
    #[test]
    fn test_window_role_hash_eq() {
        let role1 = WindowRole::Main;
        let role2 = WindowRole::Main;
        assert_eq!(role1, role2);

        // Verify it's Copy
        let role3 = role1;
        assert_eq!(role1, role3);
    }

    /// Test WindowRole Debug formatting
    #[test]
    fn test_window_role_debug() {
        let role = WindowRole::Main;
        let debug_str = format!("{:?}", role);
        // WindowRole::Main now from window_state, debug shows "Main"
        assert!(debug_str.contains("Main"));
    }

    // macOS-specific tests
    #[cfg(target_os = "macos")]
    mod macos_tests {
        use super::super::*;

        /// Test WindowId wrapper
        #[test]
        fn test_window_id_wrapper() {
            let ptr_value: usize = 0x12345678;
            let mock_id = ptr_value as id;

            let window_id = WindowId::from_id(mock_id);
            let recovered = window_id.to_id();

            assert_eq!(recovered as usize, ptr_value);
        }

        /// Test basic registration and retrieval
        /// Note: Uses a mock pointer since we can't create real NSWindow in tests
        #[test]
        fn test_register_and_get_window() {
            // Create a mock window ID (don't actually use this pointer!)
            let mock_id: id = 0x12345678 as id;

            // Register the window
            register_window(WindowRole::Main, mock_id);

            // Retrieve it
            let retrieved = get_window(WindowRole::Main);
            assert!(retrieved.is_some());
            assert_eq!(retrieved.unwrap(), mock_id);
        }

        /// Test get_main_window convenience function
        #[test]
        fn test_get_main_window_convenience() {
            let mock_id: id = 0x87654321 as id;
            register_window(WindowRole::Main, mock_id);

            let retrieved = get_main_window();
            assert!(retrieved.is_some());
            assert_eq!(retrieved.unwrap(), mock_id);
        }

        /// Test is_window_registered
        #[test]
        fn test_is_window_registered() {
            let mock_id: id = 0xABCDEF00 as id;

            // Register it
            register_window(WindowRole::Main, mock_id);

            // Should be registered now
            assert!(is_window_registered(WindowRole::Main));
        }

        /// Test that registration overwrites previous value
        #[test]
        fn test_registration_overwrites() {
            let first_id: id = 0x11111111 as id;
            let second_id: id = 0x22222222 as id;

            register_window(WindowRole::Main, first_id);
            assert_eq!(get_window(WindowRole::Main), Some(first_id));

            register_window(WindowRole::Main, second_id);
            assert_eq!(get_window(WindowRole::Main), Some(second_id));
        }

        /// Test WindowManager internal struct
        #[test]
        fn test_window_manager_struct() {
            let mut manager = WindowManager::new();

            let mock_id: id = 0x33333333 as id;

            // Initially empty
            assert!(!manager.is_registered(WindowRole::Main));
            assert!(manager.get(WindowRole::Main).is_none());

            // Register
            manager.register(WindowRole::Main, mock_id);
            assert!(manager.is_registered(WindowRole::Main));
            assert_eq!(manager.get(WindowRole::Main), Some(mock_id));

            // Unregister
            let removed = manager.unregister(WindowRole::Main);
            assert_eq!(removed, Some(mock_id));
            assert!(!manager.is_registered(WindowRole::Main));
        }
    }

    // Non-macOS tests
    #[cfg(not(target_os = "macos"))]
    mod non_macos_tests {
        use super::super::*;

        #[test]
        fn test_stubs_return_none() {
            // All stub functions should return None or false
            assert!(get_window(WindowRole::Main).is_none());
            assert!(get_main_window().is_none());
            assert!(!find_and_register_main_window());
            assert!(!is_window_registered(WindowRole::Main));
            assert!(unregister_window(WindowRole::Main).is_none());
        }
    }
}

</file>

<file path="src/system_actions.rs">
//! macOS System Actions Module
//!
//! Provides AppleScript-based system actions for macOS including:
//! - Power management (sleep, restart, shutdown, lock, log out)
//! - UI controls (dark mode, show desktop, mission control, launchpad)
//! - Media controls (volume)
//! - System utilities (empty trash, force quit, screen saver, do not disturb)
//! - System Preferences navigation
//!
//! All functions use `osascript` to execute AppleScript commands and return
//! `Result<(), String>` for consistent error handling.

use std::process::Command;
use tracing::{debug, error, info};

// ============================================================================
// Helper Function
// ============================================================================

/// Execute an AppleScript command and return the result
fn run_applescript(script: &str) -> Result<(), String> {
    debug!(script = %script, "Executing AppleScript");

    let output = Command::new("osascript")
        .arg("-e")
        .arg(script)
        .output()
        .map_err(|e| format!("Failed to execute AppleScript: {}", e))?;

    if output.status.success() {
        debug!("AppleScript executed successfully");
        Ok(())
    } else {
        let stderr = String::from_utf8_lossy(&output.stderr);
        error!(stderr = %stderr, "AppleScript execution failed");
        Err(format!("AppleScript error: {}", stderr))
    }
}

/// Execute an AppleScript command and return the output
#[allow(dead_code)]
fn run_applescript_with_output(script: &str) -> Result<String, String> {
    debug!(script = %script, "Executing AppleScript with output");

    let output = Command::new("osascript")
        .arg("-e")
        .arg(script)
        .output()
        .map_err(|e| format!("Failed to execute AppleScript: {}", e))?;

    if output.status.success() {
        let stdout = String::from_utf8_lossy(&output.stdout).trim().to_string();
        debug!(output = %stdout, "AppleScript executed successfully");
        Ok(stdout)
    } else {
        let stderr = String::from_utf8_lossy(&output.stderr);
        error!(stderr = %stderr, "AppleScript execution failed");
        Err(format!("AppleScript error: {}", stderr))
    }
}

// ============================================================================
// Trash Management
// ============================================================================

/// Empty the macOS Trash
///
/// Uses Finder to empty the trash without user confirmation.
///
/// # Example
/// ```no_run
/// use script_kit_gpui::system_actions::empty_trash;
/// empty_trash().expect("Failed to empty trash");
/// ```
pub fn empty_trash() -> Result<(), String> {
    info!("Emptying trash");
    run_applescript(r#"tell application "Finder" to empty trash"#)
}

// ============================================================================
// Power Management
// ============================================================================

/// Lock the screen
///
/// Activates the screen saver which requires authentication to unlock.
pub fn lock_screen() -> Result<(), String> {
    info!("Locking screen");
    // Use the Keychain Access method which is more reliable
    run_applescript(
        r#"tell application "System Events" to keystroke "q" using {command down, control down}"#,
    )
}

/// Put the system to sleep
///
/// Puts the Mac into sleep mode.
pub fn sleep() -> Result<(), String> {
    info!("Putting system to sleep");
    run_applescript(r#"tell application "System Events" to sleep"#)
}

/// Restart the system
///
/// Initiates a system restart. Applications will be asked to save documents.
pub fn restart() -> Result<(), String> {
    info!("Restarting system");
    run_applescript(r#"tell application "System Events" to restart"#)
}

/// Shut down the system
///
/// Initiates a system shutdown. Applications will be asked to save documents.
pub fn shut_down() -> Result<(), String> {
    info!("Shutting down system");
    run_applescript(r#"tell application "System Events" to shut down"#)
}

/// Log out the current user
///
/// Logs out the current user. Applications will be asked to save documents.
pub fn log_out() -> Result<(), String> {
    info!("Logging out user");
    run_applescript(r#"tell application "System Events" to log out"#)
}

// ============================================================================
// UI Controls
// ============================================================================

/// Toggle Dark Mode
///
/// Switches between light and dark appearance mode.
pub fn toggle_dark_mode() -> Result<(), String> {
    info!("Toggling dark mode");
    run_applescript(
        r#"tell application "System Events"
            tell appearance preferences
                set dark mode to not dark mode
            end tell
        end tell"#,
    )
}

/// Check if Dark Mode is enabled
///
/// Returns true if dark mode is currently active.
#[allow(dead_code)]
pub fn is_dark_mode() -> Result<bool, String> {
    let output = run_applescript_with_output(
        r#"tell application "System Events"
            tell appearance preferences
                return dark mode
            end tell
        end tell"#,
    )?;
    Ok(output == "true")
}

/// Show Desktop (hide all windows)
///
/// Hides all windows to reveal the desktop.
pub fn show_desktop() -> Result<(), String> {
    info!("Showing desktop");
    // F11 key code is 103, but we use the hot corner simulation
    // which is more reliable across different keyboard layouts
    run_applescript(
        r#"tell application "System Events"
            key code 103 using {command down}
        end tell"#,
    )
}

/// Activate Mission Control
///
/// Opens Mission Control to show all windows and desktops.
pub fn mission_control() -> Result<(), String> {
    info!("Activating Mission Control");
    // Control + Up Arrow triggers Mission Control
    run_applescript(
        r#"tell application "System Events"
            key code 126 using {control down}
        end tell"#,
    )
}

/// Open Launchpad
///
/// Opens Launchpad to show all applications.
pub fn launchpad() -> Result<(), String> {
    info!("Opening Launchpad");
    // F4 key code is 118 on many keyboards, but we use the direct approach
    run_applescript(r#"tell application "Launchpad" to activate"#)
}

/// Open Force Quit Applications dialog
///
/// Opens the Force Quit Applications window (Cmd+Option+Escape).
pub fn force_quit_apps() -> Result<(), String> {
    info!("Opening Force Quit Applications dialog");
    run_applescript(
        r#"tell application "System Events"
            keystroke "escape" using {command down, option down}
        end tell"#,
    )
}

// ============================================================================
// Volume Controls
// ============================================================================

/// Increase system volume
///
/// Increases the system volume by approximately 6.25% (1/16th of max).
#[allow(dead_code)]
pub fn volume_up() -> Result<(), String> {
    info!("Increasing volume");
    run_applescript(r#"set volume output volume ((output volume of (get volume settings)) + 6.25)"#)
}

/// Decrease system volume
///
/// Decreases the system volume by approximately 6.25% (1/16th of max).
#[allow(dead_code)]
pub fn volume_down() -> Result<(), String> {
    info!("Decreasing volume");
    run_applescript(r#"set volume output volume ((output volume of (get volume settings)) - 6.25)"#)
}

/// Toggle mute
///
/// Toggles the system audio mute state.
pub fn volume_mute() -> Result<(), String> {
    info!("Toggling mute");
    run_applescript(
        r#"set currentMute to output muted of (get volume settings)
        set volume output muted (not currentMute)"#,
    )
}

/// Set volume to a specific level
///
/// # Arguments
/// * `level` - Volume level from 0 to 100
pub fn set_volume(level: u8) -> Result<(), String> {
    let level = level.min(100);
    info!(level = level, "Setting volume");
    run_applescript(&format!("set volume output volume {}", level))
}

/// Get current volume level
///
/// Returns the current volume level (0-100).
#[allow(dead_code)]
pub fn get_volume() -> Result<u8, String> {
    let output = run_applescript_with_output("output volume of (get volume settings)")?;
    output
        .parse::<f64>()
        .map(|v| v.round() as u8)
        .map_err(|e| format!("Failed to parse volume: {}", e))
}

/// Check if audio is muted
#[allow(dead_code)]
pub fn is_muted() -> Result<bool, String> {
    let output = run_applescript_with_output("output muted of (get volume settings)")?;
    Ok(output == "true")
}

// ============================================================================
// Do Not Disturb
// ============================================================================

/// Toggle Do Not Disturb mode
///
/// Toggles macOS Focus/Do Not Disturb mode.
/// Note: This uses keyboard shortcuts as the DND API changed in recent macOS versions.
pub fn toggle_do_not_disturb() -> Result<(), String> {
    info!("Toggling Do Not Disturb");
    // Option-click on the menu bar clock or use Control Center
    // We'll use the Control Center approach for better compatibility
    run_applescript(
        r#"tell application "System Events"
            tell process "ControlCenter"
                -- Click the Focus button in Control Center
                click menu bar item "Focus" of menu bar 1
            end tell
        end tell"#,
    )
}

// ============================================================================
// Screen Saver
// ============================================================================

/// Start the screen saver
///
/// Immediately activates the screen saver.
pub fn start_screen_saver() -> Result<(), String> {
    info!("Starting screen saver");
    run_applescript(r#"tell application "ScreenSaverEngine" to activate"#)
}

// ============================================================================
// System Preferences Navigation
// ============================================================================

/// Open System Preferences/Settings to a specific pane
///
/// # Arguments
/// * `pane` - The pane identifier (e.g., "com.apple.preference.security")
///
/// # Common Pane IDs
/// - `com.apple.preference.security` - Privacy & Security
/// - `com.apple.preference.displays` - Displays
/// - `com.apple.preference.sound` - Sound
/// - `com.apple.preference.network` - Network
/// - `com.apple.preference.keyboard` - Keyboard
/// - `com.apple.preference.trackpad` - Trackpad
/// - `com.apple.preference.bluetooth` - Bluetooth
/// - `com.apple.preference.notifications` - Notifications
/// - `com.apple.preference.general` - General
/// - `com.apple.preference.dock` - Desktop & Dock
/// - `com.apple.preferences.AppleIDPrefPane` - Apple ID
/// - `com.apple.preference.battery` - Battery
pub fn open_system_preferences(pane: &str) -> Result<(), String> {
    info!(pane = pane, "Opening System Preferences");
    run_applescript(&format!(
        r#"tell application "System Preferences"
            activate
            reveal pane id "{}"
        end tell"#,
        pane
    ))
}

/// Open System Preferences to the Privacy & Security pane
pub fn open_privacy_settings() -> Result<(), String> {
    open_system_preferences("com.apple.preference.security")
}

/// Open System Preferences to the Displays pane
pub fn open_display_settings() -> Result<(), String> {
    open_system_preferences("com.apple.preference.displays")
}

/// Open System Preferences to the Sound pane
pub fn open_sound_settings() -> Result<(), String> {
    open_system_preferences("com.apple.preference.sound")
}

/// Open System Preferences to the Network pane
pub fn open_network_settings() -> Result<(), String> {
    open_system_preferences("com.apple.preference.network")
}

/// Open System Preferences to the Keyboard pane
pub fn open_keyboard_settings() -> Result<(), String> {
    open_system_preferences("com.apple.preference.keyboard")
}

/// Open System Preferences to the Bluetooth pane
pub fn open_bluetooth_settings() -> Result<(), String> {
    open_system_preferences("com.apple.preference.bluetooth")
}

/// Open System Preferences to the Notifications pane
pub fn open_notifications_settings() -> Result<(), String> {
    open_system_preferences("com.apple.preference.notifications")
}

/// Open System Preferences to the General pane
#[allow(dead_code)]
pub fn open_general_settings() -> Result<(), String> {
    open_system_preferences("com.apple.preference.general")
}

/// Open System Preferences to the Desktop & Dock pane
#[allow(dead_code)]
pub fn open_dock_settings() -> Result<(), String> {
    open_system_preferences("com.apple.preference.dock")
}

/// Open System Preferences to the Battery pane
#[allow(dead_code)]
pub fn open_battery_settings() -> Result<(), String> {
    open_system_preferences("com.apple.preference.battery")
}

/// Open System Preferences to the Trackpad pane
#[allow(dead_code)]
pub fn open_trackpad_settings() -> Result<(), String> {
    open_system_preferences("com.apple.preference.trackpad")
}

/// Open System Preferences (main window)
pub fn open_system_preferences_main() -> Result<(), String> {
    info!("Opening System Preferences");
    run_applescript(r#"tell application "System Preferences" to activate"#)
}

// ============================================================================
// Tests
// ============================================================================

#[cfg(test)]
mod tests {
    use super::*;

    // Note: Most of these tests are marked #[ignore] because they require
    // actual system interaction and should only be run manually on macOS.
    // Run with: cargo test --features system-tests -- --ignored

    #[test]
    fn test_run_applescript_syntax_error() {
        // Test that syntax errors are properly caught
        let result = run_applescript("this is not valid applescript syntax (((");
        assert!(result.is_err());
        assert!(result.unwrap_err().contains("AppleScript error"));
    }

    #[test]
    fn test_run_applescript_with_output_simple() {
        // Test a simple AppleScript that returns a value
        let result = run_applescript_with_output("return 42");
        assert!(result.is_ok());
        assert_eq!(result.unwrap(), "42");
    }

    #[test]
    fn test_run_applescript_with_output_string() {
        // Test returning a string
        let result = run_applescript_with_output(r#"return "hello""#);
        assert!(result.is_ok());
        assert_eq!(result.unwrap(), "hello");
    }

    #[test]
    fn test_run_applescript_with_output_boolean() {
        // Test returning a boolean
        let result = run_applescript_with_output("return true");
        assert!(result.is_ok());
        assert_eq!(result.unwrap(), "true");
    }

    #[test]
    fn test_set_volume_clamps_to_100() {
        // Test that set_volume clamps values above 100
        // This doesn't actually set volume, just tests the script generation
        let test_value: u8 = 150;
        let script = format!("set volume output volume {}", test_value.min(100));
        assert!(script.contains("100"));
    }

    #[test]
    #[ignore]
    fn test_empty_trash_integration() {
        // Integration test - only run manually
        let result = empty_trash();
        // May succeed or fail depending on permissions
        println!("empty_trash result: {:?}", result);
    }

    #[test]
    #[ignore]
    fn test_toggle_dark_mode_integration() {
        // Integration test - only run manually
        let result = toggle_dark_mode();
        println!("toggle_dark_mode result: {:?}", result);
    }

    #[test]
    #[ignore]
    fn test_is_dark_mode_integration() {
        // Integration test - only run manually
        let result = is_dark_mode();
        println!("is_dark_mode result: {:?}", result);
    }

    #[test]
    #[ignore]
    fn test_volume_controls_integration() {
        // Integration test - only run manually
        if let Ok(initial_volume) = get_volume() {
            println!("Initial volume: {}", initial_volume);

            // Test volume up
            let _ = volume_up();

            // Test volume down
            let _ = volume_down();

            // Test set volume
            let _ = set_volume(initial_volume);

            // Test mute check
            if let Ok(muted) = is_muted() {
                println!("Is muted: {}", muted);
            }
        }
    }

    #[test]
    #[ignore]
    fn test_start_screen_saver_integration() {
        // Integration test - only run manually
        let result = start_screen_saver();
        println!("start_screen_saver result: {:?}", result);
    }

    #[test]
    #[ignore]
    fn test_mission_control_integration() {
        // Integration test - only run manually
        let result = mission_control();
        println!("mission_control result: {:?}", result);
    }

    #[test]
    #[ignore]
    fn test_launchpad_integration() {
        // Integration test - only run manually
        let result = launchpad();
        println!("launchpad result: {:?}", result);
    }

    #[test]
    #[ignore]
    fn test_open_system_preferences_integration() {
        // Integration test - only run manually
        let result = open_sound_settings();
        println!("open_sound_settings result: {:?}", result);
    }
}

</file>

</files>