# Session: Add mouse hover feedback and input-mode consistency in built-in views

## Files changed
- `src/render_builtins.rs` — Added on_hover handlers + hovered/hover_effect props to 5 built-in list views
- `src/app_impl.rs` — FileSearch display_indices cleared on filter clear, hovered_index cleared on filter clear

## What was improved

### Mouse hover feedback in all built-in list views
Previously, built-in views (ClipboardHistory, AppLauncher, WindowSwitcher,
FileSearch, ThemeChooser) had click handlers but NO on_hover handlers.
Moving the mouse over items gave no visual feedback — unlike the main
menu which had full hover support with InputMode tracking, hovered_index
state, and debouncing.

Now all 5 user-facing list views:
- Track `hovered_index` on mouse enter/leave using the weak entity handle
  pattern (same as click handlers)
- Set `InputMode::Mouse` on hover to re-enable hover effects after keyboard
  navigation cleared them
- For ListItem-based views (ClipboardHistory, AppLauncher, WindowSwitcher):
  pass `.hovered(is_hovered)` and `.with_hover_effect(is_mouse_mode)` to
  properly show/hide hover background based on input mode
- For custom-rendered views (FileSearch, ThemeChooser): use state-based
  hover bg and guard CSS `.hover()` with `is_mouse_mode` check to prevent
  dual-highlight during keyboard navigation

### FileSearch display_indices cleanup
`clear_builtin_view_filter()` now clears `file_search_display_indices`
alongside `cached_file_results`. Previously stale indices could reference
entries in a cleared results vec.

### hovered_index cleared on filter reset
When ESC clears the filter in any built-in view, `hovered_index` is now
set to `None`. This prevents ghost hover highlights lingering after the
list content changes.

## What to avoid repeating
- When adding new built-in views with lists, always add:
  1. `let hovered = self.hovered_index;` + `let current_input_mode = self.input_mode;` before uniform_list
  2. `let hover_entity_handle = cx.entity().downgrade();` (or clone from entity_handle)
  3. Per-item: `let is_hovered = hovered == Some(ix) && current_input_mode == InputMode::Mouse;`
  4. For ListItem: `.hovered(is_hovered).with_hover_effect(current_input_mode == InputMode::Mouse)`
  5. For custom divs: state-based `.bg()` + `.when(is_mouse_mode, |d| d.hover(...))`
  6. On the item div: `.on_hover(hover_handler)` with the weak entity update pattern
- The global `capture_key_down` on the outer div already clears `hovered_index`
  on any key press, so built-in views don't need to clear it in their own
  key handlers — but `clear_builtin_view_filter()` should clear it since
  it changes list content.
- DesignGallery was intentionally skipped (read-only developer tool with
  mixed item types — headers aren't hoverable).
