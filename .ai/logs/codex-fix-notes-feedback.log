==== spawn @ 2026-02-07T23:43:01.128Z ====
cmd: codex "exec" "--cd" "/Users/johnlindquist/dev/script-kit-gpui" "--model" "gpt-5.3-codex" "-c" "model_reasoning_effort=\"xhigh\"" "-c" "model_auto_compact_token_limit=120000" "-c" "developer_instructions=\"You are Codex implementer agent \\\"codex-fix-notes-feedback\\\".\\n\\n## Coordination\\nThis repo runs parallel agents in ONE working tree. Before editing any file, you MUST claim it.\\nCommands (run via shell):\\n  - View roster: ~/.claude/bin/swarm.ts status\\n  - Claim files (blocks until free): ~/.claude/bin/swarm.ts claim --wait --id codex-fix-notes-feedback path/to/file\\n  - Release: ~/.claude/bin/swarm.ts release --id codex-fix-notes-feedback path/to/file\\n  - Update status/notes: ~/.claude/bin/swarm.ts update --id codex-fix-notes-feedback --status in_progress --notes \\\"...\\\"\\nRules:\\n  - Never edit a file you haven't claimed.\\n  - Keep claims tight (claim only what you're actively changing).\\n  - If blocked, set status=blocked and say what you're waiting on.\\n  - When finished, set status=done and release claims.\\n\\n## Development practices (this code is maintained by AI agents)\\n  - Log state transitions with enough context to diagnose failures from logs alone.\\n  - Structured errors: include what was attempted, what failed, and current state.\\n  - Name things for grepability — unique identifiers agents can find on the first search.\\n  - Every behavior change gets a test. Untested code is invisible to the next agent.\\n  - Test names describe the scenario: test_X_does_Y_when_Z.\\n  - Keep functions small and single-purpose. 500-line functions burn agent context.\\n  - Use types to encode constraints (enums > strings for errors).\\n\\n## CRITICAL: Parallel-safe verification\\n  - Other agents are modifying other files RIGHT NOW. Full test suites WILL show their failures.\\n  - ONLY run tests that cover YOUR changed files. Scope every test/check command:\\n    Rust: cargo test -p your-crate -- module::test_name | JS: npx jest your/file.test.ts\\n  - Do NOT run: cargo test (unscoped), cargo check (whole workspace), npm test (unscoped).\\n  - If a scoped test fails, it's YOUR bug — fix it. If tests outside your scope fail, ignore them.\\n\\n## Git commit discipline\\n  - NEVER commit unverified work. Run tests/lints/type-checks FIRST. If it fails, fix it before committing.\\n  - A commit is a declaration: \\\"this works and here's the proof.\\\"\\n  - Commit FREQUENTLY — after each meaningful unit of VERIFIED work, not just at the end.\\n  - A \\\"unit\\\" = one logical change that passes verification (new function, bug fix, refactor, test added).\\n  - NEVER batch an entire task into one giant commit. Small commits are searchable; big ones aren't.\\n  - Commit message format:\\n      Line 1: <type>(<scope>): <what changed> (imperative, max 72 chars)\\n      Line 3+: WHY this change was made, WHAT was verified, and HOW to test it.\\n    Types: feat, fix, refactor, test, docs, chore\\n    Example:\\n      feat(auth): add refresh token rotation\\n      \\n      Tokens now rotate on each refresh call to prevent replay attacks.\\n      The old token is invalidated immediately on rotation.\\n      \\n      Verified: cargo test --lib -- auth::refresh (4 tests pass)\\n      Verified: manual smoke test via curl — token rotates, old token returns 401\\n  - The \\\"Verified:\\\" lines are REQUIRED. Future agents will read git log to understand\\n    what was tested and how to re-verify. This is the most valuable part of the message.\\n  - In your final message, list all commits you made with their hashes.\\n\\n## Time budget\\nYou have approximately 10 minutes. If your task is too broad to complete in time:\\n(1) Commit any verified progress.\\n(2) Run: ~/.claude/bin/swarm.ts update --id YOUR_ID --status needs_split --notes 'suggest: 1) sub-task-desc scope:files 2) sub-task-desc scope:files'.\\n(3) Exit cleanly. The dispatcher will read your suggestions and spawn narrower workers.\"" "--output-last-message" "/Users/johnlindquist/dev/script-kit-gpui/.ai/logs/codex-fix-notes-feedback.final.md" "--yolo" "You are agent codex-fix-notes-feedback.\n\nCurrent parallel-agent roster (read this first):\n```\nSWARM SNAPSHOT @ 2026-02-07T23:43:01.125Z\n- codex-fix-ai-feedback [in_progress] scope=src/app_execute/*.rs,src/app_impl/execution_scripts.rs task=MEDIUM FIX: In src/app_execute/builtin_execution.rs, lines 87,634,677,709,752,796 - several AI command failure paths lo…\n  claims: src/app_execute/builtin_execution.rs, src/app_impl/execution_scripts.rs\n  notes: Claiming builtin execution files and implementing AI error user feedback + NO_MAIN_WINDOW_BUILTINS entries\n- codex-fix-notes-feedback [starting] scope=src/notes/window/notes_actions.rs,src/notes/window/notes.rs,src/notes/window/panels.rs task=MEDIUM FIX: Silent no-op paths when selected note is missing or stale. In src/notes/window/notes_actions.rs:94,101,121,…\n```\n\nYour assignment:\n- Task: MEDIUM FIX: Silent no-op paths when selected note is missing or stale. In src/notes/window/notes_actions.rs:94,101,121,124 and src/notes/window/notes.rs:235 and src/notes/window/panels.rs:294 - duplicate_selected_note, copy_note_deeplink, create_note_quicklink, and export_note return early silently when selected note is missing/stale. Fix: Show a toast/HUD indicating the selected note could not be found. After fix, run cargo check && cargo clippy --all-targets -- -D warnings\n- Scope: src/notes/window/notes_actions.rs,src/notes/window/notes.rs,src/notes/window/panels.rs\n\nOperating constraints:\n- Single working tree (no worktrees, no patches).\n- You MUST claim files before editing (~/.claude/bin/swarm.ts claim --wait ...).\n\nDeliverables:\n- Make the code changes required by the task.\n- Run the most relevant tests/linters.\n- In your FINAL message, include: changed files, how to test, and any risks/known gaps."

OpenAI Codex v0.98.0 (research preview)
--------
workdir: /Users/johnlindquist/dev/script-kit-gpui
model: gpt-5.3-codex
provider: openai
approval: never
sandbox: danger-full-access
reasoning effort: xhigh
reasoning summaries: auto
session id: 019c3a7c-c43d-70e3-8738-94e57f9819f2
--------
user
You are agent codex-fix-notes-feedback.

Current parallel-agent roster (read this first):
```
SWARM SNAPSHOT @ 2026-02-07T23:43:01.125Z
- codex-fix-ai-feedback [in_progress] scope=src/app_execute/*.rs,src/app_impl/execution_scripts.rs task=MEDIUM FIX: In src/app_execute/builtin_execution.rs, lines 87,634,677,709,752,796 - several AI command failure paths lo…
  claims: src/app_execute/builtin_execution.rs, src/app_impl/execution_scripts.rs
  notes: Claiming builtin execution files and implementing AI error user feedback + NO_MAIN_WINDOW_BUILTINS entries
- codex-fix-notes-feedback [starting] scope=src/notes/window/notes_actions.rs,src/notes/window/notes.rs,src/notes/window/panels.rs task=MEDIUM FIX: Silent no-op paths when selected note is missing or stale. In src/notes/window/notes_actions.rs:94,101,121,…
```

Your assignment:
- Task: MEDIUM FIX: Silent no-op paths when selected note is missing or stale. In src/notes/window/notes_actions.rs:94,101,121,124 and src/notes/window/notes.rs:235 and src/notes/window/panels.rs:294 - duplicate_selected_note, copy_note_deeplink, create_note_quicklink, and export_note return early silently when selected note is missing/stale. Fix: Show a toast/HUD indicating the selected note could not be found. After fix, run cargo check && cargo clippy --all-targets -- -D warnings
- Scope: src/notes/window/notes_actions.rs,src/notes/window/notes.rs,src/notes/window/panels.rs

Operating constraints:
- Single working tree (no worktrees, no patches).
- You MUST claim files before editing (~/.claude/bin/swarm.ts claim --wait ...).

Deliverables:
- Make the code changes required by the task.
- Run the most relevant tests/linters.
- In your FINAL message, include: changed files, how to test, and any risks/known gaps.
warning: Under-development features enabled: responses_websockets. Under-development features are incomplete and may behave unpredictably. To suppress this warning, set `suppress_unstable_features_warning = true` in /Users/johnlindquist/.codex/config.toml.
mcp: deepwiki starting
mcp: deepwiki ready
mcp startup: ready: deepwiki

thinking
**Planning skill usage and file claims**
codex
I’m going to inspect the three scoped notes files for the silent early-return paths, then implement a shared user-visible toast/HUD message when the selected note is stale or missing before running the requested Rust checks/lints.

thinking
**Checking swarm status**
exec
/bin/zsh -lc '~/.claude/bin/swarm.ts status && ~/.claude/bin/swarm.ts update --id codex-fix-notes-feedback --status in_progress --notes "Inspecting note actions for stale selected-note early returns; will add user feedback and run check+clippy."' in /Users/johnlindquist/dev/script-kit-gpui succeeded in 51ms:
Repo: /Users/johnlindquist/dev/script-kit-gpui
Updated: 2026-02-07T23:43:13.292Z

Active agents (2):
codex-fix-ai-feedback [in_progress] codex/gpt-5.3-codex/exec
  task: MEDIUM FIX: In src/app_execute/builtin_execution.rs, lines 87,634,677,709,752,796 - several AI command failure paths lo…
  scope: src/app_execute/*.rs,src/app_impl/execution_scripts.rs
  claims(2): src/app_execute/builtin_execution.rs, src/app_impl/execution_scripts.rs
  notes: Claiming builtin execution files and implementing AI error user feedback + NO_MAIN_WINDOW_BUILTINS entries

codex-fix-notes-feedback [in_progress] codex/gpt-5.3-codex/exec
  task: MEDIUM FIX: Silent no-op paths when selected note is missing or stale. In src/notes/window/notes_actions.rs:94,101,121,…
  scope: src/notes/window/notes_actions.rs,src/notes/window/notes.rs,src/notes/window/panels.rs
  claims: (none)
  notes: spawned codex (exec)

Inactive agents (213):
- codex-accessibility [done] done. exit=0. final=.ai/logs/codex-accessibility.final.md. See final message file.
- codex-action-labels [failed] failed. exit=1. final=.ai/logs/codex-action-labels.final.md.
- codex-actions-audit [failed] failed. exit=1. final=.ai/logs/codex-actions-audit.final.md. See final message file.

thinking
**Planning simultaneous resource claiming**
exec
/bin/zsh -lc '~/.claude/bin/swarm.ts claim --wait --id codex-fix-notes-feedback src/notes/window/notes_actions.rs src/notes/window/notes.rs src/notes/window/panels.rs' in /Users/johnlindquist/dev/script-kit-gpui succeeded in 51ms:
Claimed for codex-fix-notes-feedback: src/notes/window/notes_actions.rs, src/notes/window/notes.rs, src/notes/window/panels.rs

thinking
**Preparing file inspection commands**
codex
I’ve claimed the three scoped files and will now pinpoint each early-return site to add consistent stale-selection feedback without widening behavior beyond this task.
exec
/bin/zsh -lc "nl -ba src/notes/window/notes_actions.rs | sed -n '1,260p'" in /Users/johnlindquist/dev/script-kit-gpuiexec
/bin/zsh -lc "nl -ba src/notes/window/notes.rs | sed -n '180,320p'" in /Users/johnlindquist/dev/script-kit-gpuiexec
/bin/zsh -lc "nl -ba src/notes/window/panels.rs | sed -n '240,360p'" in /Users/johnlindquist/dev/script-kit-gpui succeeded in 51ms:
     1	use super::*;
     2	
     3	impl NotesApp {
     4	    /// Cycle sort mode: Updated → Created → Alphabetical → Updated
     5	    pub(super) fn cycle_sort_mode(&mut self, cx: &mut Context<Self>) {
     6	        self.sort_mode = match self.sort_mode {
     7	            NotesSortMode::Updated => NotesSortMode::Created,
     8	            NotesSortMode::Created => NotesSortMode::Alphabetical,
     9	            NotesSortMode::Alphabetical => NotesSortMode::Updated,
    10	        };
    11	        self.apply_sort(cx);
    12	        info!(sort_mode = ?self.sort_mode, "Cycled sort mode");
    13	    }
    14	
    15	    /// Apply current sort mode to the notes list
    16	    pub(super) fn apply_sort(&mut self, cx: &mut Context<Self>) {
    17	        match self.sort_mode {
    18	            NotesSortMode::Updated => {
    19	                self.notes.sort_by(|a, b| match (a.is_pinned, b.is_pinned) {
    20	                    (true, false) => std::cmp::Ordering::Less,
 succeeded in 51ms:
   180	
   181	    /// Restore the selected note from trash
   182	    pub(super) fn restore_note(&mut self, window: &mut Window, cx: &mut Context<Self>) {
   183	        if let Some(id) = self.selected_note_id {
   184	            if let Some(note) = self.deleted_notes.iter_mut().find(|n| n.id == id) {
   185	                note.restore();
   186	
   187	                if let Err(e) = storage::save_note(note) {
   188	                    tracing::error!(error = %e, "Failed to restore note");
   189	                    return;
   190	                }
   191	
   192	                // Move back to active notes
   193	                self.notes.insert(0, note.clone());
   194	            }
   195	
   196	            self.deleted_notes.retain(|n| n.id != id);
   197	            self.view_mode = NotesViewMode::AllNotes;
   198	            self.selected_note_id = Some(id);
   199	            self.select_note(id, window, cx);
 succeeded in 51ms:
   240	        let action = match action_id {
   241	            "new_note" => Some(NotesAction::NewNote),
   242	            "duplicate_note" => Some(NotesAction::DuplicateNote),
   243	            "browse_notes" => Some(NotesAction::BrowseNotes),
   244	            "find_in_note" => Some(NotesAction::FindInNote),
   245	            "format" => Some(NotesAction::Format),
   246	            "copy_note_as" => Some(NotesAction::CopyNoteAs),
   247	            "copy_deeplink" => Some(NotesAction::CopyDeeplink),
   248	            "create_quicklink" => Some(NotesAction::CreateQuicklink),
   249	            "export" => Some(NotesAction::Export),
   250	            "enable_auto_sizing" => Some(NotesAction::EnableAutoSizing),
   251	            _ => {
   252	                tracing::warn!(action_id, "Unknown action ID from CommandBar");
   253	                None
   254	            }
   255	        };
   256	
   257	        if let Some(action) = action {
   258	            self.handle_action(action, window, cx);
   259	        } else {

thinking
**Continuing inspection around panels**
exec
/bin/zsh -lc "nl -ba src/notes/window/panels.rs | sed -n '360,520p'" in /Users/johnlindquist/dev/script-kit-gpui succeeded in 51ms:
   360	    pub(super) fn handle_browse_action(
   361	        &mut self,
   362	        id: NoteId,
   363	        action: NoteAction,
   364	        cx: &mut Context<Self>,
   365	    ) {
   366	        match action {
   367	            NoteAction::TogglePin => {
   368	                if let Some(note) = self.notes.iter_mut().find(|n| n.id == id) {
   369	                    note.is_pinned = !note.is_pinned;
   370	                    if let Err(e) = storage::save_note(note) {
   371	                        tracing::error!(error = %e, "Failed to save note pin state");
   372	                    }
   373	                }
   374	                // Re-sort notes: pinned first, then by updated_at descending
   375	                self.notes.sort_by(|a, b| match (a.is_pinned, b.is_pinned) {
   376	                    (true, false) => std::cmp::Ordering::Less,
   377	                    (false, true) => std::cmp::Ordering::Greater,
   378	                    _ => b.updated_at.cmp(&a.updated_at),
   379	                });

thinking
**Inspecting specific panels range**
exec
/bin/zsh -lc "nl -ba src/notes/window/panels.rs | sed -n '260,340p'" in /Users/johnlindquist/dev/script-kit-gpui succeeded in 51ms:
   260	            // Unknown action - just close the command bar
   261	            self.close_actions_panel(window, cx);
   262	        }
   263	    }
   264	
   265	    /// Execute an action from the note switcher (Cmd+P)
   266	    /// Handles note selection when action_id starts with "note_"
   267	    pub(super) fn execute_note_switcher_action(
   268	        &mut self,
   269	        action_id: &str,
   270	        window: &mut Window,
   271	        cx: &mut Context<Self>,
   272	    ) {
   273	        debug!(action_id, "Executing note switcher action");
   274	
   275	        // Handle note selection (action_id format: "note_{uuid}")
   276	        if let Some(note_id_str) = action_id.strip_prefix("note_") {
   277	            // Find the note by ID string
   278	            if let Some(note) = self.notes.iter().find(|n| n.id.as_str() == note_id_str) {
   279	                let note_id = note.id;

thinking
**Investigating early returns and silent no-ops**
codex
I found the targeted early-return behavior in `notes_actions.rs` and `notes.rs`; next I’m tracing how `panels.rs` routes those actions so we can surface one consistent missing-selection toast from all entry points.
exec
/bin/zsh -lc "nl -ba src/notes/window/panels.rs | sed -n '1,260p'" in /Users/johnlindquist/dev/script-kit-gpuiexec
/bin/zsh -lc 'rg -n "duplicate_selected_note|copy_note_deeplink|create_note_quicklink|export_note|selected_note_id" src/notes/window/notes_actions.rs src/notes/window/notes.rs src/notes/window/panels.rs' in /Users/johnlindquist/dev/script-kit-gpuiexec
/bin/zsh -lc 'rg -n "show_action_feedback|toast|hud|notify" src/notes/window -g"*.rs"' in /Users/johnlindquist/dev/script-kit-gpui succeeded in 51ms:
     1	use super::*;
     2	
     3	impl NotesApp {
     4	    pub(super) fn build_action_items(&self) -> Vec<NotesActionItem> {
     5	        let has_selection = self.selected_note_id.is_some();
     6	        let is_trash = self.view_mode == NotesViewMode::Trash;
     7	        let can_edit = has_selection && !is_trash;
     8	
     9	        let mut items: Vec<NotesActionItem> = NotesAction::all()
    10	            .iter()
    11	            .map(|action| {
    12	                let enabled = match action {
    13	                    NotesAction::NewNote | NotesAction::BrowseNotes => true,
    14	                    NotesAction::DuplicateNote
    15	                    | NotesAction::FindInNote
    16	                    | NotesAction::CopyNoteAs
    17	                    | NotesAction::CopyDeeplink
    18	                    | NotesAction::CreateQuicklink
    19	                    | NotesAction::Export
    20	                    | NotesAction::Format => can_edit,
 succeeded in 50ms:
src/notes/window/panels.rs:5:        let has_selection = self.selected_note_id.is_some();
src/notes/window/panels.rs:46:            has_selection: self.selected_note_id.is_some(),
src/notes/window/panels.rs:188:            NotesAction::DuplicateNote => self.duplicate_selected_note(window, cx),
src/notes/window/panels.rs:210:            NotesAction::CopyDeeplink => self.copy_note_deeplink(),
src/notes/window/panels.rs:211:            NotesAction::CreateQuicklink => self.create_note_quicklink(),
src/notes/window/panels.rs:212:            NotesAction::Export => self.export_note(ExportFormat::Html),
src/notes/window/panels.rs:314:                    is_current: Some(n.id) == self.selected_note_id,
src/notes/window/panels.rs:383:                let current_id = self.selected_note_id;
src/notes/window/panels.rs:384:                self.selected_note_id = Some(id);
src/notes/window/panels.rs:388:                    self.selected_note_id = current_id;
src/notes/window/panels.rs:397:                .map(|note| NoteListItem::from_note(note, Some(note.id) == self.selected_note_id))
src/notes/window/notes.rs:14:                    if let Some(id) = self.selected_note_id {
src/notes/window/notes.rs:16:                            self.selected_note_id = self.notes.first().map(|n| n.id);
src/notes/window/notes.rs:107:            if let Some(prev_id) = self.selected_note_id {
src/notes/window/notes.rs:116:        self.selected_note_id = Some(id);
src/notes/window/notes.rs:144:        if let Some(id) = self.selected_note_id {
src/notes/window/notes.rs:158:            self.selected_note_id = self.notes.first().map(|n| n.id);
src/notes/window/notes.rs:167:        if let Some(id) = self.selected_note_id {
src/notes/window/notes.rs:174:            self.selected_note_id = self.deleted_notes.first().map(|n| n.id);
src/notes/window/notes.rs:183:        if let Some(id) = self.selected_note_id {
 succeeded in 52ms:
src/notes/window/vibrancy.rs:77:            cx.notify();
src/notes/window/vibrancy.rs:83:            cx.notify();
src/notes/window/notes_actions.rs:40:        cx.notify();
src/notes/window/notes_actions.rs:54:        cx.notify();
src/notes/window/notes_actions.rs:136:        self.show_action_feedback("Duplicated", false);
src/notes/window/editor_formatting.rs:62:        cx.notify();
src/notes/window/init.rs:275:            cx.notify();
src/notes/window/init.rs:294:            cx.notify();
src/notes/window/init.rs:350:        cx.notify();
src/notes/window/navigation.rs:165:            self.show_action_feedback(if was_pinned { "● Pinned" } else { "Unpinned" }, was_pinned);
src/notes/window/navigation.rs:166:            cx.notify();
src/notes/window/navigation.rs:225:        cx.notify();
src/notes/window/navigation.rs:357:    pub(super) fn show_action_feedback(&mut self, msg: impl Into<String>, accent: bool) {
src/notes/window/navigation.rs:375:        cx.notify();
src/notes/window/window_ops.rs:232:                cx.notify();
src/notes/window/panels.rs:78:        cx.notify();
src/notes/window/panels.rs:93:        cx.notify();
src/notes/window/panels.rs:198:                cx.notify();
src/notes/window/panels.rs:226:        cx.notify();
src/notes/window/panels.rs:342:        cx.notify();

thinking
**Reviewing navigation feedback methods**
exec
/bin/zsh -lc "nl -ba src/notes/window/navigation.rs | sed -n '320,420p'" in /Users/johnlindquist/dev/script-kit-gpui succeeded in 51ms:
   320	
   321	    /// Welcome note content for first-time users.
   322	    /// Teaches markdown syntax and key shortcuts through the product itself.
   323	    pub(super) fn welcome_note_content() -> String {
   324	        [
   325	            "# Welcome to Notes",
   326	            "",
   327	            "A fast, keyboard-first notes app with markdown support.",
   328	            "",
   329	            "## Formatting",
   330	            "",
   331	            "- **Bold** with ⌘B",
   332	            "- *Italic* with ⌘I",
   333	            "- `Code` with ⌘E",
   334	            "- ~~Strikethrough~~ with ⌘⇧X",
   335	            "",
   336	            "## Lists",
   337	            "",
   338	            "- [ ] Checklist item (⌘⇧L)",
   339	            "- Bullet point (⌘⇧8)",

thinking
**Assessing mutable method needs**
codex
I found an existing notes HUD helper (`show_action_feedback`) we can reuse. I’m now checking all callsites of the affected functions so signature changes don’t break other paths or miss `cx.notify()` behavior.
exec
/bin/zsh -lc "rg -n \"copy_note_deeplink\\(|create_note_quicklink\\(|export_note\\(|duplicate_selected_note\\(\" src/notes/window -g\"*.rs\"" in /Users/johnlindquist/dev/script-kit-gpuiexec
/bin/zsh -lc "nl -ba src/notes/window/keyboard.rs | sed -n '1,260p'" in /Users/johnlindquist/dev/script-kit-gpuiexec
/bin/zsh -lc "rg -n \"show_action_feedback\\(\" src/notes/window -g\"*.rs\"" in /Users/johnlindquist/dev/script-kit-gpui succeeded in 51ms:
src/notes/window/render_ui.rs:183:                        this.export_note(ExportFormat::PlainText);
src/notes/window/render_ui.rs:192:                        this.export_note(ExportFormat::Markdown);
src/notes/window/render_ui.rs:201:                        this.export_note(ExportFormat::Html);
src/notes/window/notes.rs:234:    pub(super) fn export_note(&self, format: ExportFormat) {
src/notes/window/notes_actions.rs:90:        self.export_note(ExportFormat::Markdown);
src/notes/window/notes_actions.rs:93:    pub(super) fn copy_note_deeplink(&self) {
src/notes/window/notes_actions.rs:100:    pub(super) fn create_note_quicklink(&self) {
src/notes/window/notes_actions.rs:120:    pub(super) fn duplicate_selected_note(&mut self, window: &mut Window, cx: &mut Context<Self>) {
src/notes/window/keyboard.rs:311:                        self.duplicate_selected_note(window, cx);
src/notes/window/panels.rs:188:            NotesAction::DuplicateNote => self.duplicate_selected_note(window, cx),
src/notes/window/panels.rs:210:            NotesAction::CopyDeeplink => self.copy_note_deeplink(),
src/notes/window/panels.rs:211:            NotesAction::CreateQuicklink => self.create_note_quicklink(),
src/notes/window/panels.rs:212:            NotesAction::Export => self.export_note(ExportFormat::Html),
 succeeded in 52ms:
     1	use super::*;
     2	
     3	impl NotesApp {
     4	    pub(super) fn handle_key_down(
     5	        &mut self,
     6	        event: &KeyDownEvent,
     7	        window: &mut Window,
     8	        cx: &mut Context<Self>,
     9	    ) {
    10	        self.hide_mouse_cursor(cx);
    11	
    12	        let key = event.keystroke.key.to_lowercase();
    13	        let modifiers = &event.keystroke.modifiers;
    14	
    15	        if self.command_bar.is_open() {
    16	            match key.as_str() {
    17	                "escape" | "esc" => {
    18	                    self.close_actions_panel(window, cx);
    19	                    cx.stop_propagation();
    20	                    return;
 succeeded in 51ms:
src/notes/window/notes_actions.rs:136:        self.show_action_feedback("Duplicated", false);
src/notes/window/navigation.rs:165:            self.show_action_feedback(if was_pinned { "● Pinned" } else { "Unpinned" }, was_pinned);
src/notes/window/navigation.rs:357:    pub(super) fn show_action_feedback(&mut self, msg: impl Into<String>, accent: bool) {
src/notes/window/clipboard_ops.rs:27:        self.show_action_feedback("Copied", false);
src/notes/window/notes.rs:160:            self.show_action_feedback("Deleted · ⌘⇧T trash", false);

thinking
**Inspecting keyboard shortcut callsites**
exec
/bin/zsh -lc "nl -ba src/notes/window/keyboard.rs | sed -n '260,420p'" in /Users/johnlindquist/dev/script-kit-gpui succeeded in 51ms:
   260	                    if modifiers.shift {
   261	                        self.create_note_from_clipboard(window, cx);
   262	                    } else {
   263	                        self.create_note(window, cx);
   264	                    }
   265	                }
   266	                "t" => {
   267	                    if modifiers.shift {
   268	                        if self.view_mode == NotesViewMode::Trash {
   269	                            self.set_view_mode(NotesViewMode::AllNotes, window, cx);
   270	                        } else {
   271	                            self.set_view_mode(NotesViewMode::Trash, window, cx);
   272	                        }
   273	                        cx.stop_propagation();
   274	                    }
   275	                }
   276	                "w" => {
   277	                    self.command_bar.close_app(cx);
   278	                    self.note_switcher.close_app(cx);
   279	                    let wb = window.window_bounds();

thinking
**Inspecting render_ui mutability**
exec
/bin/zsh -lc "nl -ba src/notes/window/render_ui.rs | sed -n '130,240p'" in /Users/johnlindquist/dev/script-kit-gpui succeeded in 50ms:
   130	                    .on_click(cx.listener(|this, _, window, cx| {
   131	                        this.insert_formatting("~~", "~~", window, cx);
   132	                    })),
   133	            )
   134	            .child(
   135	                Button::new("checklist")
   136	                    .ghost()
   137	                    .xsmall()
   138	                    .label("\u{2610}")
   139	                    .on_click(cx.listener(|this, _, window, cx| {
   140	                        this.toggle_checklist(window, cx);
   141	                    })),
   142	            )
   143	            .child(
   144	                Button::new("link")
   145	                    .ghost()
   146	                    .xsmall()
   147	                    .label("\u{1F517}")
   148	                    .on_click(cx.listener(|this, _, window, cx| {
   149	                        this.insert_formatting("[", "](url)", window, cx);

thinking
**Analyzing stale note handling**
exec
/bin/zsh -lc 'rg -n "not found|missing|stale|Selected note|No note" src/notes/window -g"*.rs"' in /Users/johnlindquist/dev/script-kit-gpui succeeded in 51ms:
src/notes/window/render_editor_body.rs:62:                        .child("No notes yet"),
src/notes/window/window_ops.rs:458:            "Warning: Notes window not found by title for floating panel config",
src/notes/window/render_editor.rs:19:                    "No note selected".to_string()

thinking
**Planning missing note feedback helper**
exec
/bin/zsh -lc "rg -n \"copy_note_as_markdown\\(\" src/notes/window -g\"*.rs\"" in /Users/johnlindquist/dev/script-kit-gpui succeeded in 50ms:
src/notes/window/notes_actions.rs:89:    pub(super) fn copy_note_as_markdown(&self) {
src/notes/window/panels.rs:209:            NotesAction::CopyNoteAs => self.copy_note_as_markdown(),

thinking
**Evaluating signature changes and feedback options**
exec
/bin/zsh -lc 'rg -n "toast|HUD|hud|show_action_feedback|action_feedback" src -g"*.rs"' in /Users/johnlindquist/dev/script-kit-gpui succeeded in 51ms:
Total output lines: 1231

src/app_actions/handle_action.rs:12:        // not the entire app (cx.hide() would hide HUD too)
src/app_actions/handle_action.rs:146:                    self.show_hud("No clipboard entry selected".to_string(), Some(2000), cx);
src/app_actions/handle_action.rs:200:                        if let Some(message) = clipboard_pin_action_success_hud(&action_id) {
src/app_actions/handle_action.rs:201:                            self.show_hud(message.to_string(), Some(1500), cx);
src/app_actions/handle_action.rs:207:                        self.show_hud(format!("Failed to update pin: {}", e), Some(3000), cx);
src/app_actions/handle_action.rs:214:                    self.show_hud("No clipboard entry selected".to_string(), Some(2000), cx);
src/app_actions/handle_action.rs:219:                    self.show_hud(
src/app_actions/handle_action.rs:255:                    Ok(()) => self.show_hud("Share sheet opened".to_string(), Some(1500), cx),
src/app_actions/handle_action.rs:256:                    Err(message) => self.show_hud(message, Some(2000), cx),
src/app_actions/handle_action.rs:263:                    self.show_hud("No clipboard entry selected".to_string(), Some(2000), cx);
src/app_actions/handle_action.rs:280:                        self.show_hud("Pasted".to_string(), Some(1000), cx);
src/app_actions/handle_action.rs:285:                        self.show_hud(format!("Failed to paste: {}", e), Some(2500), cx);
src/app_actions/handle_action.rs:292:                    self.show_hud("No clipboard entry selected".to_string(), Some(2000), cx);
src/app_actions/handle_action.rs:297:                    self.show_hud(
src/app_actions/handle_action.rs:317:                            self.show_hud("Failed to open AI window".to_string(), Some(2000), cx);
src/app_actions/handle_action.rs:325:                            self.show_hud(
src/app_actions/handle_action.rs:339:                            self.show_hud("Failed to open AI window".to_string(), Some(2000), cx);
src/app_actions/handle_action.rs:346:                self.show_hud("Attached to AI".to_string(), Some(1500), cx);

thinking
**Assessing HUD notification options**
exec
/bin/zsh -lc "rg -n \"pub fn show_hud\\(\" src/hud_manager.rs src -g\"hud_manager.rs\"" in /Users/johnlindquist/dev/script-kit-gpui exited 2 in 52ms:
rg: src/hud_manager.rs: No such file or directory (os error 2)

thinking
**Scanning HUD manager source path**
codex
I’m evaluating whether we can emit feedback without broad signature churn; if a global HUD helper is usable from these methods, that keeps this change minimal and contained.
exec
/bin/zsh -lc "rg -n \"mod hud_manager|fn show_hud\\(\" src/main.rs src -g\"*.rs\"" in /Users/johnlindquist/dev/script-kit-gpui succeeded in 52ms:
src/main.rs:169:mod hud_manager;
src/app_impl/shortcuts_hud_grid.rs:95:    pub(crate) fn show_hud(&mut self, text: String, duration_ms: Option<u64>, cx: &mut Context<Self>) {
src/hud_manager/part_001.rs:11:pub fn show_hud(text: String, duration_ms: Option<u64>, cx: &mut App) {
src/main.rs:169:mod hud_manager;

thinking
**Assessing feedback approach in notes module**
exec
/bin/zsh -lc 'rg -n "action_feedback" src/notes/window -g"*.rs"' in /Users/johnlindquist/dev/script-kit-gpui succeeded in 50ms:
src/notes/window/notes_actions.rs:136:        self.show_action_feedback("Duplicated", false);
src/notes/window/render_editor_footer.rs:34:        let action_feedback = self
src/notes/window/render_editor_footer.rs:35:            .get_action_feedback()
src/notes/window/render_editor_footer.rs:121:                    .when_some(action_feedback.clone(), |d, (msg, accent)| {
src/notes/window/init.rs:174:            action_feedback: None,
src/notes/window/navigation.rs:165:            self.show_action_feedback(if was_pinned { "● Pinned" } else { "Unpinned" }, was_pinned);
src/notes/window/navigation.rs:357:    pub(super) fn show_action_feedback(&mut self, msg: impl Into<String>, accent: bool) {
src/notes/window/navigation.rs:358:        self.action_feedback = Some((msg.into(), accent, Instant::now()));
src/notes/window/navigation.rs:362:    pub(super) fn get_action_feedback(&self) -> Option<(&str, bool)> {
src/notes/window/navigation.rs:363:        self.action_feedback.as_ref().and_then(|(msg, accent, t)| {
src/notes/window/clipboard_ops.rs:27:        self.show_action_feedback("Copied", false);
src/notes/window/notes.rs:160:            self.show_action_feedback("Deleted · ⌘⇧T trash", false);

thinking
**Evaluating feedback signaling options**
exec
/bin/zsh -lc "rg -n \"hud_manager::show_hud\\(|show_hud\\(\" src -g\"*.rs\"" in /Users/johnlindquist/dev/script-kit-gpui succeeded in 51ms:
Total output lines: 364

src/app_actions/handle_action.rs:146:                    self.show_hud("No clipboard entry selected".to_string(), Some(2000), cx);
src/app_actions/handle_action.rs:201:                            self.show_hud(message.to_string(), Some(1500), cx);
src/app_actions/handle_action.rs:207:                        self.show_hud(format!("Failed to update pin: {}", e), Some(3000), cx);
src/app_actions/handle_action.rs:214:                    self.show_hud("No clipboard entry selected".to_string(), Some(2000), cx);
src/app_actions/handle_action.rs:219:                    self.show_hud(
src/app_actions/handle_action.rs:255:                    Ok(()) => self.show_hud("Share sheet opened".to_string(), Some(1500), cx),
src/app_actions/handle_action.rs:256:                    Err(message) => self.show_hud(message, Some(2000), cx),
src/app_actions/handle_action.rs:263:                    self.show_hud("No clipboard entry selected".to_string(), Some(2000), cx);
src/app_actions/handle_action.rs:280:                        self.show_hud("Pasted".to_string(), Some(1000), cx);
src/app_actions/handle_action.rs:285:                        self.show_hud(format!("Failed to paste: {}", e), Some(2500), cx);
src/app_actions/handle_action.rs:292:                    self.show_hud("No clipboard entry selected".to_string(), Some(2000), cx);
src/app_actions/handle_action.rs:297:                    self.show_hud(
src/app_actions/handle_action.rs:317:                            self.show_hud("Failed to open AI window".to_string(), Some(2000), cx);
src/app_actions/handle_action.rs:325:                            self.show_hud(
src/app_actions/handle_action.rs:339:                            self.show_hud("Failed to open AI window".to_string(), Some(2000), cx);
src/app_actions/handle_action.rs:346:                self.show_hud("Attached to AI".to_string(), Some(1500), cx);
src/app_actions/handle_action.rs:353:                    self.show_hud("No clipboard entry selected".to_string(), Some(2000), cx);
src/app_actions/handle_action.rs:364:                        self.show_hud("Copied to clipboard".to_string(), Some(1500), cx);

thinking
**Evaluating toast/HUD feedback implementation**
exec
/bin/zsh -lc 'rg -n "mod tests|#[ ]*test|test_" src/notes/window -g"*.rs"' in /Users/johnlindquist/dev/script-kit-gpui exited 1 in 51ms:


thinking
**Assessing test coverage for notes**
exec
/bin/zsh -lc 'rg -n "NotesApp|notes window|notes" src -g"*test*.rs"' in /Users/johnlindquist/dev/script-kit-gpui succeeded in 51ms:
Total output lines: 1695

src/actions/dialog_builtin_action_validation_tests_17.rs:12://! 07. Note switcher empty notes fallback placeholder
src/actions/dialog_builtin_action_validation_tests_17.rs:28://! 23. CommandBarConfig notes_style preset values
src/actions/dialog_builtin_action_validation_tests_17.rs:31://! 26. Notes command bar browse_notes action details
src/notes/window/tests.rs:1:use super::NotesApp;
src/notes/window/tests.rs:9:        NotesApp::formatting_replacement(value, selection.clone(), "**", "**");
src/notes/window/tests.rs:28:        NotesApp::formatting_replacement(value, selection.clone(), "**", "**");
src/actions/dialog_builtin_action_validation_tests_8/tests_part_06.rs:2:    fn notes_actions_deterministic() {
src/actions/dialog_builtin_action_validation_tests_8/tests_part_06.rs:8:        let actions1 = get_notes_command_bar_actions(&info);
src/actions/dialog_builtin_action_validation_tests_8/tests_part_06.rs:9:        let actions2 = get_notes_command_bar_actions(&info);
src/actions/dialog_builtin_action_validation_tests_8/tests_part_02.rs:3:        let notes = vec![make_note(
src/actions/dialog_builtin_action_validation_tests_8/tests_part_02.rs:12:        let actions = get_note_switcher_actions(&notes);
src/actions/dialog_builtin_action_validation_tests_8/tests_part_02.rs:20:        let notes = vec![make_note(
src/actions/dialog_builtin_action_validation_tests_8/tests_part_02.rs:29:        let actions = get_note_switcher_actions(&notes);
src/actions/dialog_builtin_action_validation_tests_8/tests_part_02.rs:42:        assert_eq!(actions[0].id, "no_notes");
src/actions/dialog_builtin_action_validation_tests_8/tests_part_02.rs:43:        assert_eq!(actions[0].title, "No notes yet");
src/actions/dialog_builtin_action_validation_tests_8/tests_part_02.rs:48:        let notes = vec![make_note("abc-123-def", "Test", 10, false, false, "", "")];
src/actions/dialog_builtin_action_validation_tests_8/tests_part_02.rs:49:        let actions = get_note_switcher_actions(&notes);
src/actions/dialog_builtin_action_validation_tests_8/tests_part_02.rs:269:    fn notes_full_feature_sections() {

thinking
**Inspecting test file contents**
exec
/bin/zsh -lc "nl -ba src/notes/window/tests.rs | sed -n '1,220p'" in /Users/johnlindquist/dev/script-kit-gpui succeeded in 51ms:
     1	use super::NotesApp;
     2	
     3	#[test]
     4	fn formatting_replacement_wraps_selected_text() {
     5	    let value = "hello world";
     6	    let selection = 6..11;
     7	
     8	    let (replacement, new_selection) =
     9	        NotesApp::formatting_replacement(value, selection.clone(), "**", "**");
    10	
    11	    let new_value = format!(
    12	        "{}{}{}",
    13	        &value[..selection.start],
    14	        replacement,
    15	        &value[selection.end..]
    16	    );
    17	
    18	    assert_eq!(new_value, "hello **world**");
    19	    assert_eq!(new_selection, 8..13);
    20	}

thinking
**Evaluating test strategy for new behavior**
codex
I confirmed there are no existing notes-window tests for this behavior. I’m checking whether `NotesApp` has a lightweight test constructor; if not, I’ll add a small pure helper and unit test to cover the stale-selection feedback branch without pulling in GPUI runtime setup.
exec
/bin/zsh -lc "nl -ba src/notes/window/init.rs | sed -n '1,260p'" in /Users/johnlindquist/dev/script-kit-gpuiexec
/bin/zsh -lc "nl -ba src/notes/window/mod.rs | sed -n '1,260p'" in /Users/johnlindquist/dev/script-kit-gpuiexec
/bin/zsh -lc "rg -n \"impl Default for NotesApp|fn new\\(|fn test_.*NotesApp|cfg\\(test\\).*NotesApp|NotesApp \\{\" src/notes/window -g\"*.rs\"" in /Users/johnlindquist/dev/script-kit-gpui succeeded in 51ms:
nl: src/notes/window/mod.rs: No such file or directory
 succeeded in 51ms:
     1	use super::*;
     2	
     3	impl NotesApp {
     4	    /// Create a new NotesApp
     5	    pub fn new(window: &mut Window, cx: &mut Context<Self>) -> Self {
     6	        // Initialize storage
     7	        if let Err(e) = storage::init_notes_db() {
     8	            tracing::error!(error = %e, "Failed to initialize notes database");
     9	        }
    10	
    11	        // Auto-prune trash entries older than 30 days
    12	        match storage::prune_old_deleted_notes(30) {
    13	            Ok(pruned) if pruned > 0 => {
    14	                info!(
    15	                    pruned_count = pruned,
    16	                    "Auto-pruned old trash notes (>30 days)"
    17	                );
    18	            }
    19	            Err(e) => {
    20	                tracing::error!(error = %e, "Failed to auto-prune trash");
 succeeded in 51ms:
src/notes/window/vibrancy.rs:3:impl NotesApp {
src/notes/window/notes_actions.rs:3:impl NotesApp {
src/notes/window/render_ui.rs:3:impl NotesApp {
src/notes/window/render_editor_footer.rs:3:impl NotesApp {
src/notes/window/traits.rs:3:impl Focusable for NotesApp {
src/notes/window/traits.rs:9:impl Drop for NotesApp {
src/notes/window/editor_formatting.rs:3:impl NotesApp {
src/notes/window/render_editor_body.rs:3:impl NotesApp {
src/notes/window/init.rs:3:impl NotesApp {
src/notes/window/init.rs:5:    pub fn new(window: &mut Window, cx: &mut Context<Self>) -> Self {
src/notes/window/render_overlays.rs:3:impl NotesApp {
src/notes/window/navigation.rs:3:impl NotesApp {
src/notes/window/panels.rs:3:impl NotesApp {
src/notes/window/keyboard.rs:3:impl NotesApp {
src/notes/window/editor_ops_a.rs:3:impl NotesApp {
src/notes/window/clipboard_ops.rs:3:impl NotesApp {
src/notes/window/render_editor.rs:3:impl NotesApp {
src/notes/window/render_shortcuts.rs:3:impl NotesApp {
src/notes/window/editor_ops_b.rs:3:impl NotesApp {
src/notes/window/render.rs:3:impl Render for NotesApp {

thinking
**Checking module declarations in source**
exec
/bin/zsh -lc 'rg -n "mod notes|pub mod window|window/tests" src/notes -g"*.rs"' in /Users/johnlindquist/dev/script-kit-gpui succeeded in 51ms:
src/notes/window.rs:361:mod notes;
src/notes/window.rs:362:mod notes_actions;
exec
/bin/zsh -lc "nl -ba src/notes/window.rs | sed -n '300,430p'" in /Users/johnlindquist/dev/script-kit-gpui succeeded in 51ms:
   300	
   301	    /// Pending note selection from browse panel
   302	    pending_browse_select: Arc<Mutex<Option<NoteId>>>,
   303	
   304	    /// Pending close request from browse panel
   305	    pending_browse_close: Arc<Mutex<bool>>,
   306	
   307	    /// Pending action from browse panel (note id + action)
   308	    pending_browse_action: Arc<Mutex<Option<(NoteId, NoteAction)>>>,
   309	
   310	    /// Debounce: Whether the current note has unsaved changes
   311	    has_unsaved_changes: bool,
   312	
   313	    /// Debounce: Last time we saved (to avoid too-frequent saves)
   314	    last_save_time: Option<Instant>,
   315	
   316	    /// Track last persisted bounds for debounced save on close paths
   317	    /// (traffic light, Cmd+W, toggle) that don't go through close_notes_window
   318	    last_persisted_bounds: Option<gpui::WindowBounds>,
   319	

thinking
**Inspecting note model**
exec
/bin/zsh -lc 'rg -n "pub struct Note|pub type NoteId|struct NoteId" src/notes -g"*.rs"' in /Users/johnlindquist/dev/script-kit-gpui succeeded in 52ms:
src/notes/model.rs:11:pub struct NoteId(pub Uuid);
src/notes/model.rs:44:pub struct Note {
src/notes/window.rs:209:pub struct NotesApp {
src/notes/actions_panel.rs:238:pub struct NotesActionItem {
src/notes/actions_panel.rs:323:pub struct NotesActionsPanel {
src/notes/browse_panel.rs:29:pub struct NoteListItem {

thinking
**Planning selected note helper functions**
exec
/bin/zsh -lc 'rg -n "''^name'"\\s*=\\s*\\\"\" Cargo.toml" in /Users/johnlindquist/dev/script-kit-gpui succeeded in 50ms:
2:name = "script-kit-gpui"
8:name = "script_kit_gpui"
12:name = "script-kit-gpui"
17:name = "smoke-test"
22:name = "storybook"
177:name = "Script Kit"

thinking
**Designing missing note feedback**
exec
/bin/zsh -lc "nl -ba src/notes/window/clipboard_ops.rs | sed -n '1,120p'" in /Users/johnlindquist/dev/script-kit-gpui succeeded in 51ms:
     1	use super::*;
     2	
     3	impl NotesApp {
     4	    /// Insert current date/time at cursor position (Cmd+Shift+D)
     5	    pub(super) fn insert_date_time(&mut self, window: &mut Window, cx: &mut Context<Self>) {
     6	        let now = chrono::Local::now();
     7	        let date_str = now.format("%Y-%m-%d %H:%M").to_string();
     8	        self.editor_state.update(cx, |state, cx| {
     9	            let selection = state.selection();
    10	            let value = state.value().to_string();
    11	            let start = selection.start.min(value.len());
    12	            let end = selection.end.min(value.len());
    13	            let new_value = format!("{}{}{}", &value[..start], date_str, &value[end..]);
    14	            let new_cursor = start + date_str.len();
    15	            state.set_value(&new_value, window, cx);
    16	            state.set_selection(new_cursor, new_cursor, window, cx);
    17	        });
    18	        self.has_unsaved_changes = true;
    19	        info!("Inserted date/time at cursor");
    20	        cx.notify();

thinking
**Refactoring note actions for mutable feedback**
exec
/bin/zsh -lc "nl -ba src/notes/window.rs | sed -n '1,120p'" in /Users/johnlindquist/dev/script-kit-gpui succeeded in 51ms:
     1	//! Notes Window
     2	//!
     3	//! A separate floating window for notes, built with gpui-component.
     4	//! This is completely independent from the main Script Kit launcher window.
     5	
     6	use anyhow::Result;
     7	use gpui::{
     8	    div, prelude::*, px, rgba, size, AnyElement, App, Context, CursorStyle, Entity, FocusHandle,
     9	    Focusable, IntoElement, KeyDownEvent, MouseMoveEvent, ParentElement, Render, Styled,
    10	    Subscription, Window, WindowBounds, WindowOptions,
    11	};
    12	
    13	#[cfg(target_os = "macos")]
    14	use cocoa::appkit::NSApp;
    15	#[cfg(target_os = "macos")]
    16	use cocoa::base::{id, nil};
    17	use gpui_component::{
    18	    button::{Button, ButtonVariants},
    19	    input::{Input, InputEvent, InputState, Search},
    20	    kbd::Kbd,

thinking
**Designing note selection helper and tests**
codex
I’m ready to edit; I’ll add a small shared selected-note resolver + feedback helper, wire the four actions through it, and include focused unit tests for the resolver behavior (`none`, `stale`, `valid`).
exec
/bin/zsh -lc "nl -ba src/notes/model.rs | sed -n '1,180p'" in /Users/johnlindquist/dev/script-kit-gpuiexec
/bin/zsh -lc 'git status --short' in /Users/johnlindquist/dev/script-kit-gpuiexec
/bin/zsh -lc '~/.claude/bin/swarm.ts status' in /Users/johnlindquist/dev/script-kit-gpui succeeded in 52ms:
     1	//! Notes Data Model
     2	//!
     3	//! Core data structures for the Notes feature.
     4	
     5	use chrono::{DateTime, Utc};
     6	use serde::{Deserialize, Serialize};
     7	use uuid::Uuid;
     8	
     9	/// Unique identifier for a note
    10	#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, Serialize, Deserialize)]
    11	pub struct NoteId(pub Uuid);
    12	
    13	impl NoteId {
    14	    /// Create a new random NoteId
    15	    pub fn new() -> Self {
    16	        Self(Uuid::new_v4())
    17	    }
    18	
    19	    /// Create a NoteId from a UUID string
    20	    pub fn parse(s: &str) -> Option<Self> {
 succeeded in 51ms:
Total output lines: 223

 M .ai/logs/codex-audit-act-description-quality-v2.final.md
 M .ai/logs/codex-audit-act-execution-builtin.final.md
 M .ai/logs/codex-audit-act-execution-scripts.final.md
 M .ai/logs/codex-audit-act-keyboard-nav.final.md
 M .ai/logs/codex-audit-act-section-grouping.final.md
 M .ai/logs/codex-audit-act-theme-dialog-render.final.md
 M .ai/roster.json
 M src/actions/builders/file_path.rs
 M src/actions/builders/notes.rs
 M src/actions/builders/shared.rs
 M src/actions/command_bar/part_01.rs
 M src/actions/command_bar/part_02.rs
 M src/actions/command_bar/part_03.rs
 M src/actions/dialog/part_01.rs
 M src/actions/dialog/part_02/part_01.rs
 M src/actions/dialog/part_04/body_part_02.rs
 M src/actions/dialog/part_04/body_part_03.rs
 M src/actions/dialog/part_05.rs
 succeeded in 50ms:
Repo: /Users/johnlindquist/dev/script-kit-gpui
Updated: 2026-02-07T23:46:52.330Z

Active agents (2):
codex-fix-editor-feedback [in_progress] codex/gpt-5.3-codex/exec
  task: MEDIUM FIX: edit_script / edit_scriptlet launch failures are log-only. In src/app_actions/handle_action.rs - if launchi…
  scope: src/app_actions/*.rs
  claims(1): src/app_actions/handle_action.rs
  notes: Claiming handle_action editor launch feedback flow; moving success HUD to async completion

codex-fix-notes-feedback [in_progress] codex/gpt-5.3-codex/exec
  task: MEDIUM FIX: Silent no-op paths when selected note is missing or stale. In src/notes/window/notes_actions.rs:94,101,121,…
  scope: src/notes/window/notes_actions.rs,src/notes/window/notes.rs,src/notes/window/panels.rs
  claims(3): src/notes/window/notes_actions.rs, src/notes/window/notes.rs, src/notes/window/panels.rs
  notes: Inspecting note actions for stale selected-note early returns; will add user feedback and run check+clippy.

Inactive agents (214):
- codex-accessibility [done] done. exit=0. final=.ai/logs/codex-accessibility.final.md. See final message file.
- codex-action-labels [failed] failed. exit=1. final=.ai/logs/codex-action-labels.final.md.
- codex-actions-audit [failed] failed. exit=1. final=.ai/logs/codex-actions-audit.final.md. See final message file.

thinking
**Claiming test file before edits**
codex
I’m moving into code edits now: implementing a shared stale-selection resolver/feedback helper, then wiring it through duplicate/copy/quicklink/export and the note-switcher stale-ID path.
exec
/bin/zsh -lc '~/.claude/bin/swarm.ts claim --wait --id codex-fix-notes-feedback src/notes/window/tests.rs' in /Users/johnlindquist/dev/script-kit-gpui succeeded in 51ms:
Claimed for codex-fix-notes-feedback: src/notes/window/tests.rs

thinking
**Preparing patch for warning support**
file update
M /Users/johnlindquist/dev/script-kit-gpui/src/notes/window/notes_actions.rs
@@ -3,2 +3,36 @@
 impl NotesApp {
+    const SELECTED_NOTE_NOT_FOUND_FEEDBACK: &'static str = "Selected note could not be found";
+
+    pub(super) fn resolve_selected_note(
+        selected_note_id: Option<NoteId>,
+        notes: &[Note],
+    ) -> Option<(NoteId, &Note)> {
+        let selected_note_id = selected_note_id?;
+        notes
+            .iter()
+            .find(|note| note.id == selected_note_id)
+            .map(|note| (selected_note_id, note))
+    }
+
+    pub(super) fn show_selected_note_missing_feedback(&mut self, action: &'static str) {
+        tracing::warn!(
+            action,
+            selected_note_id = ?self.selected_note_id,
+            notes_len = self.notes.len(),
+            "notes_action_selected_note_not_found",
+        );
+        self.show_action_feedback(Self::SELECTED_NOTE_NOT_FOUND_FEEDBACK, true);
+    }
+
+    pub(super) fn selected_note_for_action(
+        &mut self,
+        action: &'static str,
+    ) -> Option<(NoteId, &Note)> {
+        let selected_note = Self::resolve_selected_note(self.selected_note_id, &self.notes);
+        if selected_note.is_none() {
+            self.show_selected_note_missing_feedback(action);
+        }
+        selected_note
+    }
+
     /// Cycle sort mode: Updated → Created → Alphabetical → Updated
@@ -88,3 +122,3 @@
 
-    pub(super) fn copy_note_as_markdown(&self) {
+    pub(super) fn copy_note_as_markdown(&mut self) {
         self.export_note(ExportFormat::Markdown);
@@ -92,27 +126,22 @@
 
-    pub(super) fn copy_note_deeplink(&self) {
-        if let Some(id) = self.selected_note_id {
-            let deeplink = self.note_deeplink(id);
-            self.copy_text_to_clipboard(&deeplink);
-        }
+    pub(super) fn copy_note_deeplink(&mut self) {
+        let Some((id, _)) = self.selected_note_for_action("copy_note_deeplink") else {
+            return;
+        };
+        let deeplink = self.note_deeplink(id);
+        self.copy_text_to_clipboard(&deeplink);
     }
 
-    pub(super) fn create_note_quicklink(&self) {
-        if let Some(id) = self.selected_note_id {
-            let title = self
-                .notes
-                .iter()
-                .find(|note| note.id == id)
-                .map(|note| {
-                    if note.title.is_empty() {
-                        "Untitled Note".to_string()
-                    } else {
-                        note.title.clone()
-                    }
-                })
-                .unwrap_or_else(|| "Untitled Note".to_string());
-            let deeplink = self.note_deeplink(id);
-            let quicklink = format!("[{}]({})", title, deeplink);
-            self.copy_text_to_clipboard(&quicklink);
-        }
+    pub(super) fn create_note_quicklink(&mut self) {
+        let Some((id, note)) = self.selected_note_for_action("create_note_quicklink") else {
+            return;
+        };
+        let title = if note.title.is_empty() {
+            "Untitled Note".to_string()
+        } else {
+            note.title.clone()
+        };
+        let deeplink = self.note_deeplink(id);
+        let quicklink = format!("[{}]({})", title, deeplink);
+        self.copy_text_to_clipboard(&quicklink);
     }
@@ -120,6 +149,3 @@
     pub(super) fn duplicate_selected_note(&mut self, window: &mut Window, cx: &mut Context<Self>) {
-        let Some(id) = self.selected_note_id else {
-            return;
-        };
-        let Some(note) = self.notes.iter().find(|note| note.id == id) else {
+        let Some((_id, note)) = self.selected_note_for_action("duplicate_selected_note") else {
             return;
apply_patch(auto_approved=true) exited 0 in 12ms:
Success. Updated the following files:
M src/notes/window/notes_actions.rs
file update:
diff --git a/src/notes/window/notes_actions.rs b/src/notes/window/notes_actions.rs
index 6405519cffd92b2252b2e410eb3f58ee37800b8d..603be7a00cb2f2023699769b2b8b33c629a21238
--- a/src/notes/window/notes_actions.rs
+++ b/src/notes/window/notes_actions.rs
@@ -1,6 +1,40 @@
 use super::*;
 
 impl NotesApp {
+    const SELECTED_NOTE_NOT_FOUND_FEEDBACK: &'static str = "Selected note could not be found";
+
+    pub(super) fn resolve_selected_note(
+        selected_note_id: Option<NoteId>,
+        notes: &[Note],
+    ) -> Option<(NoteId, &Note)> {
+        let selected_note_id = selected_note_id?;
+        notes
+            .iter()
+            .find(|note| note.id == selected_note_id)
+            .map(|note| (selected_note_id, note))
+    }
+
+    pub(super) fn show_selected_note_missing_feedback(&mut self, action: &'static str) {
+        tracing::warn!(
+            action,
+            selected_note_id = ?self.selected_note_id,
+            notes_len = self.notes.len(),
+            "notes_action_selected_note_not_found",
+        );
+        self.show_action_feedback(Self::SELECTED_NOTE_NOT_FOUND_FEEDBACK, true);
+    }
+
+    pub(super) fn selected_note_for_action(
+        &mut self,
+        action: &'static str,
+    ) -> Option<(NoteId, &Note)> {
+        let selected_note = Self::resolve_selected_note(self.selected_note_id, &self.notes);
+        if selected_note.is_none() {
+            self.show_selected_note_missing_feedback(action);
+        }
+        selected_note
+    }
+
     /// Cycle sort mode: Updated → Created → Alphabetical → Updated
     pub(super) fn cycle_sort_mode(&mut self, cx: &mut Context<Self>) {
         self.sort_mode = match self.sort_mode {
@@ -86,42 +120,34 @@
         format!("scriptkit://notes/{}", id.as_str())
     }
 
-    pub(super) fn copy_note_as_markdown(&self) {
+    pub(super) fn copy_note_as_markdown(&mut self) {
         self.export_note(ExportFormat::Markdown);
     }
 
-    pub(super) fn copy_note_deeplink(&self) {
-        if let Some(id) = self.selected_note_id {
-            let deeplink = self.note_deeplink(id);
-            self.copy_text_to_clipboard(&deeplink);
-        }
+    pub(super) fn copy_note_deeplink(&mut self) {
+        let Some((id, _)) = self.selected_note_for_action("copy_note_deeplink") else {
+            return;
+        };
+        let deeplink = self.note_deeplink(id);
+        self.copy_text_to_clipboard(&deeplink);
     }
 
-    pub(super) fn create_note_quicklink(&self) {
-        if let Some(id) = self.selected_note_id {
-            let title = self
-                .notes
-                .iter()
-                .find(|note| note.id == id)
-                .map(|note| {
-                    if note.title.is_empty() {
-                        "Untitled Note".to_string()
-                    } else {
-                        note.title.clone()
-                    }
-                })
-                .unwrap_or_else(|| "Untitled Note".to_string());
-            let deeplink = self.note_deeplink(id);
-            let quicklink = format!("[{}]({})", title, deeplink);
-            self.copy_text_to_clipboard(&quicklink);
-        }
+    pub(super) fn create_note_quicklink(&mut self) {
+        let Some((id, note)) = self.selected_note_for_action("create_note_quicklink") else {
+            return;
+        };
+        let title = if note.title.is_empty() {
+            "Untitled Note".to_string()
+        } else {
+            note.title.clone()
+        };
+        let deeplink = self.note_deeplink(id);
+        let quicklink = format!("[{}]({})", title, deeplink);
+        self.copy_text_to_clipboard(&quicklink);
     }
 
     pub(super) fn duplicate_selected_note(&mut self, window: &mut Window, cx: &mut Context<Self>) {
-        let Some(id) = self.selected_note_id else {
-            return;
-        };
-        let Some(note) = self.notes.iter().find(|note| note.id == id) else {
+        let Some((_id, note)) = self.selected_note_for_action("duplicate_selected_note") else {
             return;
         };
 

file update:
diff --git a/src/notes/window/notes_actions.rs b/src/notes/window/notes_actions.rs
index 6405519cffd92b2252b2e410eb3f58ee37800b8d..603be7a00cb2f2023699769b2b8b33c629a21238
--- a/src/notes/window/notes_actions.rs
+++ b/src/notes/window/notes_actions.rs
@@ -1,6 +1,40 @@
 use super::*;
 
 impl NotesApp {
+    const SELECTED_NOTE_NOT_FOUND_FEEDBACK: &'static str = "Selected note could not be found";
+
+    pub(super) fn resolve_selected_note(
+        selected_note_id: Option<NoteId>,
+        notes: &[Note],
+    ) -> Option<(NoteId, &Note)> {
+        let selected_note_id = selected_note_id?;
+        notes
+            .iter()
+            .find(|note| note.id == selected_note_id)
+            .map(|note| (selected_note_id, note))
+    }
+
+    pub(super) fn show_selected_note_missing_feedback(&mut self, action: &'static str) {
+        tracing::warn!(
+            action,
+            selected_note_id = ?self.selected_note_id,
+            notes_len = self.notes.len(),
+            "notes_action_selected_note_not_found",
+        );
+        self.show_action_feedback(Self::SELECTED_NOTE_NOT_FOUND_FEEDBACK, true);
+    }
+
+    pub(super) fn selected_note_for_action(
+        &mut self,
+        action: &'static str,
+    ) -> Option<(NoteId, &Note)> {
+        let selected_note = Self::resolve_selected_note(self.selected_note_id, &self.notes);
+        if selected_note.is_none() {
+            self.show_selected_note_missing_feedback(action);
+        }
+        selected_note
+    }
+
     /// Cycle sort mode: Updated → Created → Alphabetical → Updated
     pub(super) fn cycle_sort_mode(&mut self, cx: &mut Context<Self>) {
         self.sort_mode = match self.sort_mode {
@@ -86,42 +120,34 @@
         format!("scriptkit://notes/{}", id.as_str())
     }
 
-    pub(super) fn copy_note_as_markdown(&self) {
+    pub(super) fn copy_note_as_markdown(&mut self) {
         self.export_note(ExportFormat::Markdown);
     }
 
-    pub(super) fn copy_note_deeplink(&self) {
-        if let Some(id) = self.selected_note_id {
-            let deeplink = self.note_deeplink(id);
-            self.copy_text_to_clipboard(&deeplink);
-        }
+    pub(super) fn copy_note_deeplink(&mut self) {
+        let Some((id, _)) = self.selected_note_for_action("copy_note_deeplink") else {
+            return;
+        };
+        let deeplink = self.note_deeplink(id);
+        self.copy_text_to_clipboard(&deeplink);
     }
 
-    pub(super) fn create_note_quicklink(&self) {
-        if let Some(id) = self.selected_note_id {
-            let title = self
-                .notes
-                .iter()
-                .find(|note| note.id == id)
-                .map(|note| {
-                    if note.title.is_empty() {
-                        "Untitled Note".to_string()
-                    } else {
-                        note.title.clone()
-                    }
-                })
-                .unwrap_or_else(|| "Untitled Note".to_string());
-            let deeplink = self.note_deeplink(id);
-            let quicklink = format!("[{}]({})", title, deeplink);
-            self.copy_text_to_clipboard(&quicklink);
-        }
+    pub(super) fn create_note_quicklink(&mut self) {
+        let Some((id, note)) = self.selected_note_for_action("create_note_quicklink") else {
+            return;
+        };
+        let title = if note.title.is_empty() {
+            "Untitled Note".to_string()
+        } else {
+            note.title.clone()
+        };
+        let deeplink = self.note_deeplink(id);
+        let quicklink = format!("[{}]({})", title, deeplink);
+        self.copy_text_to_clipboard(&quicklink);
     }
 
     pub(super) fn duplicate_selected_note(&mut self, window: &mut Window, cx: &mut Context<Self>) {
-        let Some(id) = self.selected_note_id else {
-            return;
-        };
-        let Some(note) = self.notes.iter().find(|note| note.id == id) else {
+        let Some((_id, note)) = self.selected_note_for_action("duplicate_selected_note") else {
             return;
         };
 


thinking
**Checking lifetime elision for returned references**
file update
M /Users/johnlindquist/dev/script-kit-gpui/src/notes/window/notes.rs
@@ -233,38 +233,38 @@
     /// Export the current note
-    pub(super) fn export_note(&self, format: ExportFormat) {
-        if let Some(id) = self.selected_note_id {
-            if let Some(note) = self.notes.iter().find(|n| n.id == id) {
-                let content = match format {
-                    ExportFormat::PlainText => note.content.clone(),
-                    // For Markdown, just export the content as-is.
-                    // The title is derived from the first line of content,
-                    // so prepending it would cause duplication.
-                    ExportFormat::Markdown => note.content.clone(),
-                    ExportFormat::Html => {
-                        // For HTML, we include proper structure with the title
-                        // and render the content as preformatted text
-                        format!(
-                            "<!DOCTYPE html>\n<html>\n<head><title>{}</title></head>\n<body>\n<h1>{}</h1>\n<pre>{}</pre>\n</body>\n</html>",
-                            note.title, note.title, note.content
-                        )
-                    }
-                };
+    pub(super) fn export_note(&mut self, format: ExportFormat) {
+        let Some((_id, note)) = self.selected_note_for_action("export_note") else {
+            return;
+        };
 
-                // Copy to clipboard
-                #[cfg(target_os = "macos")]
-                {
-                    use std::process::Command;
-                    let _ = Command::new("pbcopy")
-                        .stdin(std::process::Stdio::piped())
-                        .spawn()
-                        .and_then(|mut child| {
-                            use std::io::Write;
-                            if let Some(stdin) = child.stdin.as_mut() {
-                                stdin.write_all(content.as_bytes())?;
-                            }
-                            child.wait()
-                        });
-                    info!(format = ?format, "Note exported to clipboard");
-                }
+        let content = match format {
+            ExportFormat::PlainText => note.content.clone(),
+            // For Markdown, just export the content as-is.
+            // The title is derived from the first line of content,
+            // so prepending it would cause duplication.
+            ExportFormat::Markdown => note.content.clone(),
+            ExportFormat::Html => {
+                // For HTML, we include proper structure with the title
+                // and render the content as preformatted text
+                format!(
+                    "<!DOCTYPE html>\n<html>\n<head><title>{}</title></head>\n<body>\n<h1>{}</h1>\n<pre>{}</pre>\n</body>\n</html>",
+                    note.title, note.title, note.content
+                )
             }
+        };
+
+        // Copy to clipboard
+        #[cfg(target_os = "macos")]
+        {
+            use std::process::Command;
+            let _ = Command::new("pbcopy")
+                .stdin(std::process::Stdio::piped())
+                .spawn()
+                .and_then(|mut child| {
+                    use std::io::Write;
+                    if let Some(stdin) = child.stdin.as_mut() {
+                        stdin.write_all(content.as_bytes())?;
+                    }
+                    child.wait()
+                });
+            info!(format = ?format, "Note exported to clipboard");
         }
apply_patch(auto_approved=true) exited 0 in 15ms:
Success. Updated the following files:
M src/notes/window/notes.rs
file update:
diff --git a/src/notes/window/notes.rs b/src/notes/window/notes.rs
index 2b96e1be9f619ad7fa8b88d1287b653adb4780b4..449ab857a161bcb00618adf6e45ab022a3ac86fe
--- a/src/notes/window/notes.rs
+++ b/src/notes/window/notes.rs
@@ -231,42 +231,42 @@
     }
 
     /// Export the current note
-    pub(super) fn export_note(&self, format: ExportFormat) {
-        if let Some(id) = self.selected_note_id {
-            if let Some(note) = self.notes.iter().find(|n| n.id == id) {
-                let content = match format {
-                    ExportFormat::PlainText => note.content.clone(),
-                    // For Markdown, just export the content as-is.
-                    // The title is derived from the first line of content,
-                    // so prepending it would cause duplication.
-                    ExportFormat::Markdown => note.content.clone(),
-                    ExportFormat::Html => {
-                        // For HTML, we include proper structure with the title
-                        // and render the content as preformatted text
-                        format!(
-                            "<!DOCTYPE html>\n<html>\n<head><title>{}</title></head>\n<body>\n<h1>{}</h1>\n<pre>{}</pre>\n</body>\n</html>",
-                            note.title, note.title, note.content
-                        )
-                    }
-                };
+    pub(super) fn export_note(&mut self, format: ExportFormat) {
+        let Some((_id, note)) = self.selected_note_for_action("export_note") else {
+            return;
+        };
 
-                // Copy to clipboard
-                #[cfg(target_os = "macos")]
-                {
-                    use std::process::Command;
-                    let _ = Command::new("pbcopy")
-                        .stdin(std::process::Stdio::piped())
-                        .spawn()
-                        .and_then(|mut child| {
-                            use std::io::Write;
-                            if let Some(stdin) = child.stdin.as_mut() {
-                                stdin.write_all(content.as_bytes())?;
-                            }
-                            child.wait()
-                        });
-                    info!(format = ?format, "Note exported to clipboard");
-                }
+        let content = match format {
+            ExportFormat::PlainText => note.content.clone(),
+            // For Markdown, just export the content as-is.
+            // The title is derived from the first line of content,
+            // so prepending it would cause duplication.
+            ExportFormat::Markdown => note.content.clone(),
+            ExportFormat::Html => {
+                // For HTML, we include proper structure with the title
+                // and render the content as preformatted text
+                format!(
+                    "<!DOCTYPE html>\n<html>\n<head><title>{}</title></head>\n<body>\n<h1>{}</h1>\n<pre>{}</pre>\n</body>\n</html>",
+                    note.title, note.title, note.content
+                )
             }
+        };
+
+        // Copy to clipboard
+        #[cfg(target_os = "macos")]
+        {
+            use std::process::Command;
+            let _ = Command::new("pbcopy")
+                .stdin(std::process::Stdio::piped())
+                .spawn()
+                .and_then(|mut child| {
+                    use std::io::Write;
+                    if let Some(stdin) = child.stdin.as_mut() {
+                        stdin.write_all(content.as_bytes())?;
+                    }
+                    child.wait()
+                });
+            info!(format = ?format, "Note exported to clipboard");
         }
     }
 }
diff --git a/src/notes/window/notes_actions.rs b/src/notes/window/notes_actions.rs
index 6405519cffd92b2252b2e410eb3f58ee37800b8d..603be7a00cb2f2023699769b2b8b33c629a21238
--- a/src/notes/window/notes_actions.rs
+++ b/src/notes/window/notes_actions.rs
@@ -1,6 +1,40 @@
 use super::*;
 
 impl NotesApp {
+    const SELECTED_NOTE_NOT_FOUND_FEEDBACK: &'static str = "Selected note could not be found";
+
+    pub(super) fn resolve_selected_note(
+        selected_note_id: Option<NoteId>,
+        notes: &[Note],
+    ) -> Option<(NoteId, &Note)> {
+        let selected_note_id = selected_note_id?;
+        notes
+            .iter()
+            .find(|note| note.id == selected_note_id)
+            .map(|note| (selected_note_id, note))
+    }
+
+    pub(super) fn show_selected_note_missing_feedback(&mut self, action: &'static str) {
+        tracing::warn!(
+            action,
+            selected_note_id = ?self.selected_note_id,
+            notes_len = self.notes.len(),
+            "notes_action_selected_note_not_found",
+        );
+        self.show_action_feedback(Self::SELECTED_NOTE_NOT_FOUND_FEEDBACK, true);
+    }
+
+    pub(super) fn selected_note_for_action(
+        &mut self,
+        action: &'static str,
+    ) -> Option<(NoteId, &Note)> {
+        let selected_note = Self::resolve_selected_note(self.selected_note_id, &self.notes);
+        if selected_note.is_none() {
+            self.show_selected_note_missing_feedback(action);
+        }
+        selected_note
+    }
+
     /// Cycle sort mode: Updated → Created → Alphabetical → Updated
     pub(super) fn cycle_sort_mode(&mut self, cx: &mut Context<Self>) {
         self.sort_mode = match self.sort_mode {
@@ -86,42 +120,34 @@
         format!("scriptkit://notes/{}", id.as_str())
     }
 
-    pub(super) fn copy_note_as_markdown(&self) {
+    pub(super) fn copy_note_as_markdown(&mut self) {
         self.export_note(ExportFormat::Markdown);
     }
 
-    pub(super) fn copy_note_deeplink(&self) {
-        if let Some(id) = self.selected_note_id {
-            let deeplink = self.note_deeplink(id);
-            self.copy_text_to_clipboard(&deeplink);
-        }
+    pub(super) fn copy_note_deeplink(&mut self) {
+        let Some((id, _)) = self.selected_note_for_action("copy_note_deeplink") else {
+            return;
+        };
+        let deeplink = self.note_deeplink(id);
+        self.copy_text_to_clipboard(&deeplink);
     }
 
-    pub(super) fn create_note_quicklink(&self) {
-        if let Some(id) = self.selected_note_id {
-            let title = self
-                .notes
-                .iter()
-                .find(|note| note.id == id)
-                .map(|note| {
-                    if note.title.is_empty() {
-                        "Untitled Note".to_string()
-                    } else {
-                        note.title.clone()
-                    }
-                })
-                .unwrap_or_else(|| "Untitled Note".to_string());
-            let deeplink = self.note_deeplink(id);
-            let quicklink = format!("[{}]({})", title, deeplink);
-            self.copy_text_to_clipboard(&quicklink);
-        }
+    pub(super) fn create_note_quicklink(&mut self) {
+        let Some((id, note)) = self.selected_note_for_action("create_note_quicklink") else {
+            return;
+        };
+        let title = if note.title.is_empty() {
+            "Untitled Note".to_string()
+        } else {
+            note.title.clone()
+        };
+        let deeplink = self.note_deeplink(id);
+        let quicklink = format!("[{}]({})", title, deeplink);
+        self.copy_text_to_clipboard(&quicklink);
     }
 
     pub(super) fn duplicate_selected_note(&mut self, window: &mut Window, cx: &mut Context<Self>) {
-        let Some(id) = self.selected_note_id else {
-            return;
-        };
-        let Some(note) = self.notes.iter().find(|note| note.id == id) else {
+        let Some((_id, note)) = self.selected_note_for_action("duplicate_selected_note") else {
             return;
         };
 

file update:
diff --git a/src/notes/window/notes.rs b/src/notes/window/notes.rs
index 2b96e1be9f619ad7fa8b88d1287b653adb4780b4..449ab857a161bcb00618adf6e45ab022a3ac86fe
--- a/src/notes/window/notes.rs
+++ b/src/notes/window/notes.rs
@@ -231,42 +231,42 @@
     }
 
     /// Export the current note
-    pub(super) fn export_note(&self, format: ExportFormat) {
-        if let Some(id) = self.selected_note_id {
-            if let Some(note) = self.notes.iter().find(|n| n.id == id) {
-                let content = match format {
-                    ExportFormat::PlainText => note.content.clone(),
-                    // For Markdown, just export the content as-is.
-                    // The title is derived from the first line of content,
-                    // so prepending it would cause duplication.
-                    ExportFormat::Markdown => note.content.clone(),
-                    ExportFormat::Html => {
-                        // For HTML, we include proper structure with the title
-                        // and render the content as preformatted text
-                        format!(
-                            "<!DOCTYPE html>\n<html>\n<head><title>{}</title></head>\n<body>\n<h1>{}</h1>\n<pre>{}</pre>\n</body>\n</html>",
-                            note.title, note.title, note.content
-                        )
-                    }
-                };
+    pub(super) fn export_note(&mut self, format: ExportFormat) {
+        let Some((_id, note)) = self.selected_note_for_action("export_note") else {
+            return;
+        };
 
-                // Copy to clipboard
-                #[cfg(target_os = "macos")]
-                {
-                    use std::process::Command;
-                    let _ = Command::new("pbcopy")
-                        .stdin(std::process::Stdio::piped())
-                        .spawn()
-                        .and_then(|mut child| {
-                            use std::io::Write;
-                            if let Some(stdin) = child.stdin.as_mut() {
-                                stdin.write_all(content.as_bytes())?;
-                            }
-                            child.wait()
-                        });
-                    info!(format = ?format, "Note exported to clipboard");
-                }
+        let content = match format {
+            ExportFormat::PlainText => note.content.clone(),
+            // For Markdown, just export the content as-is.
+            // The title is derived from the first line of content,
+            // so prepending it would cause duplication.
+            ExportFormat::Markdown => note.content.clone(),
+            ExportFormat::Html => {
+                // For HTML, we include proper structure with the title
+                // and render the content as preformatted text
+                format!(
+                    "<!DOCTYPE html>\n<html>\n<head><title>{}</title></head>\n<body>\n<h1>{}</h1>\n<pre>{}</pre>\n</body>\n</html>",
+                    note.title, note.title, note.content
+                )
             }
+        };
+
+        // Copy to clipboard
+        #[cfg(target_os = "macos")]
+        {
+            use std::process::Command;
+            let _ = Command::new("pbcopy")
+                .stdin(std::process::Stdio::piped())
+                .spawn()
+                .and_then(|mut child| {
+                    use std::io::Write;
+                    if let Some(stdin) = child.stdin.as_mut() {
+                        stdin.write_all(content.as_bytes())?;
+                    }
+                    child.wait()
+                });
+            info!(format = ?format, "Note exported to clipboard");
         }
     }
 }
diff --git a/src/notes/window/notes_actions.rs b/src/notes/window/notes_actions.rs
index 6405519cffd92b2252b2e410eb3f58ee37800b8d..603be7a00cb2f2023699769b2b8b33c629a21238
--- a/src/notes/window/notes_actions.rs
+++ b/src/notes/window/notes_actions.rs
@@ -1,6 +1,40 @@
 use super::*;
 
 impl NotesApp {
+    const SELECTED_NOTE_NOT_FOUND_FEEDBACK: &'static str = "Selected note could not be found";
+
+    pub(super) fn resolve_selected_note(
+        selected_note_id: Option<NoteId>,
+        notes: &[Note],
+    ) -> Option<(NoteId, &Note)> {
+        let selected_note_id = selected_note_id?;
+        notes
+            .iter()
+            .find(|note| note.id == selected_note_id)
+            .map(|note| (selected_note_id, note))
+    }
+
+    pub(super) fn show_selected_note_missing_feedback(&mut self, action: &'static str) {
+        tracing::warn!(
+            action,
+            selected_note_id = ?self.selected_note_id,
+            notes_len = self.notes.len(),
+            "notes_action_selected_note_not_found",
+        );
+        self.show_action_feedback(Self::SELECTED_NOTE_NOT_FOUND_FEEDBACK, true);
+    }
+
+    pub(super) fn selected_note_for_action(
+        &mut self,
+        action: &'static str,
+    ) -> Option<(NoteId, &Note)> {
+        let selected_note = Self::resolve_selected_note(self.selected_note_id, &self.notes);
+        if selected_note.is_none() {
+            self.show_selected_note_missing_feedback(action);
+        }
+        selected_note
+    }
+
     /// Cycle sort mode: Updated → Created → Alphabetical → Updated
     pub(super) fn cycle_sort_mode(&mut self, cx: &mut Context<Self>) {
         self.sort_mode = match self.sort_mode {
@@ -86,42 +120,34 @@
         format!("scriptkit://notes/{}", id.as_str())
     }
 
-    pub(super) fn copy_note_as_markdown(&self) {
+    pub(super) fn copy_note_as_markdown(&mut self) {
         self.export_note(ExportFormat::Markdown);
     }
 
-    pub(super) fn copy_note_deeplink(&self) {
-        if let Some(id) = self.selected_note_id {
-            let deeplink = self.note_deeplink(id);
-            self.copy_text_to_clipboard(&deeplink);
-        }
+    pub(super) fn copy_note_deeplink(&mut self) {
+        let Some((id, _)) = self.selected_note_for_action("copy_note_deeplink") else {
+            return;
+        };
+        let deeplink = self.note_deeplink(id);
+        self.copy_text_to_clipboard(&deeplink);
     }
 
-    pub(super) fn create_note_quicklink(&self) {
-        if let Some(id) = self.selected_note_id {
-            let title = self
-                .notes
-                .iter()
-                .find(|note| note.id == id)
-                .map(|note| {
-                    if note.title.is_empty() {
-                        "Untitled Note".to_string()
-                    } else {
-                        note.title.clone()
-                    }
-                })
-                .unwrap_or_else(|| "Untitled Note".to_string());
-            let deeplink = self.note_deeplink(id);
-            let quicklink = format!("[{}]({})", title, deeplink);
-            self.copy_text_to_clipboard(&quicklink);
-        }
+    pub(super) fn create_note_quicklink(&mut self) {
+        let Some((id, note)) = self.selected_note_for_action("create_note_quicklink") else {
+            return;
+        };
+        let title = if note.title.is_empty() {
+            "Untitled Note".to_string()
+        } else {
+            note.title.clone()
+        };
+        let deeplink = self.note_deeplink(id);
+        let quicklink = format!("[{}]({})", title, deeplink);
+        self.copy_text_to_clipboard(&quicklink);
     }
 
     pub(super) fn duplicate_selected_note(&mut self, window: &mut Window, cx: &mut Context<Self>) {
-        let Some(id) = self.selected_note_id else {
-            return;
-        };
-        let Some(note) = self.notes.iter().find(|note| note.id == id) else {
+        let Some((_id, note)) = self.selected_note_for_action("duplicate_selected_note") else {
             return;
         };
 


thinking
**Preparing patch for note switcher helper**
file update
M /Users/johnlindquist/dev/script-kit-gpui/src/notes/window/panels.rs
@@ -283,2 +283,13 @@
             }
+
+            tracing::warn!(
+                action_id,
+                note_id_str,
+                selected_note_id = ?self.selected_note_id,
+                notes_len = self.notes.len(),
+                "notes_note_switcher_selected_note_not_found",
+            );
+            self.show_selected_note_missing_feedback("execute_note_switcher_action");
+            self.close_browse_panel(window, cx);
+            return;
         }
apply_patch(auto_approved=true) exited 0 in 22ms:
Success. Updated the following files:
M src/notes/window/panels.rs
file update:
diff --git a/src/notes/window/notes.rs b/src/notes/window/notes.rs
index 2b96e1be9f619ad7fa8b88d1287b653adb4780b4..449ab857a161bcb00618adf6e45ab022a3ac86fe
--- a/src/notes/window/notes.rs
+++ b/src/notes/window/notes.rs
@@ -231,42 +231,42 @@
     }
 
     /// Export the current note
-    pub(super) fn export_note(&self, format: ExportFormat) {
-        if let Some(id) = self.selected_note_id {
-            if let Some(note) = self.notes.iter().find(|n| n.id == id) {
-                let content = match format {
-                    ExportFormat::PlainText => note.content.clone(),
-                    // For Markdown, just export the content as-is.
-                    // The title is derived from the first line of content,
-                    // so prepending it would cause duplication.
-                    ExportFormat::Markdown => note.content.clone(),
-                    ExportFormat::Html => {
-                        // For HTML, we include proper structure with the title
-                        // and render the content as preformatted text
-                        format!(
-                            "<!DOCTYPE html>\n<html>\n<head><title>{}</title></head>\n<body>\n<h1>{}</h1>\n<pre>{}</pre>\n</body>\n</html>",
-                            note.title, note.title, note.content
-                        )
-                    }
-                };
+    pub(super) fn export_note(&mut self, format: ExportFormat) {
+        let Some((_id, note)) = self.selected_note_for_action("export_note") else {
+            return;
+        };
 
-                // Copy to clipboard
-                #[cfg(target_os = "macos")]
-                {
-                    use std::process::Command;
-                    let _ = Command::new("pbcopy")
-                        .stdin(std::process::Stdio::piped())
-                        .spawn()
-                        .and_then(|mut child| {
-                            use std::io::Write;
-                            if let Some(stdin) = child.stdin.as_mut() {
-                                stdin.write_all(content.as_bytes())?;
-                            }
-                            child.wait()
-                        });
-                    info!(format = ?format, "Note exported to clipboard");
-                }
+        let content = match format {
+            ExportFormat::PlainText => note.content.clone(),
+            // For Markdown, just export the content as-is.
+            // The title is derived from the first line of content,
+            // so prepending it would cause duplication.
+            ExportFormat::Markdown => note.content.clone(),
+            ExportFormat::Html => {
+                // For HTML, we include proper structure with the title
+                // and render the content as preformatted text
+                format!(
+                    "<!DOCTYPE html>\n<html>\n<head><title>{}</title></head>\n<body>\n<h1>{}</h1>\n<pre>{}</pre>\n</body>\n</html>",
+                    note.title, note.title, note.content
+                )
             }
+        };
+
+        // Copy to clipboard
+        #[cfg(target_os = "macos")]
+        {
+            use std::process::Command;
+            let _ = Command::new("pbcopy")
+                .stdin(std::process::Stdio::piped())
+                .spawn()
+                .and_then(|mut child| {
+                    use std::io::Write;
+                    if let Some(stdin) = child.stdin.as_mut() {
+                        stdin.write_all(content.as_bytes())?;
+                    }
+                    child.wait()
+                });
+            info!(format = ?format, "Note exported to clipboard");
         }
     }
 }
diff --git a/src/notes/window/notes_actions.rs b/src/notes/window/notes_actions.rs
index 6405519cffd92b2252b2e410eb3f58ee37800b8d..603be7a00cb2f2023699769b2b8b33c629a21238
--- a/src/notes/window/notes_actions.rs
+++ b/src/notes/window/notes_actions.rs
@@ -1,6 +1,40 @@
 use super::*;
 
 impl NotesApp {
+    const SELECTED_NOTE_NOT_FOUND_FEEDBACK: &'static str = "Selected note could not be found";
+
+    pub(super) fn resolve_selected_note(
+        selected_note_id: Option<NoteId>,
+        notes: &[Note],
+    ) -> Option<(NoteId, &Note)> {
+        let selected_note_id = selected_note_id?;
+        notes
+            .iter()
+            .find(|note| note.id == selected_note_id)
+            .map(|note| (selected_note_id, note))
+    }
+
+    pub(super) fn show_selected_note_missing_feedback(&mut self, action: &'static str) {
+        tracing::warn!(
+            action,
+            selected_note_id = ?self.selected_note_id,
+            notes_len = self.notes.len(),
+            "notes_action_selected_note_not_found",
+        );
+        self.show_action_feedback(Self::SELECTED_NOTE_NOT_FOUND_FEEDBACK, true);
+    }
+
+    pub(super) fn selected_note_for_action(
+        &mut self,
+        action: &'static str,
+    ) -> Option<(NoteId, &Note)> {
+        let selected_note = Self::resolve_selected_note(self.selected_note_id, &self.notes);
+        if selected_note.is_none() {
+            self.show_selected_note_missing_feedback(action);
+        }
+        selected_note
+    }
+
     /// Cycle sort mode: Updated → Created → Alphabetical → Updated
     pub(super) fn cycle_sort_mode(&mut self, cx: &mut Context<Self>) {
         self.sort_mode = match self.sort_mode {
@@ -86,42 +120,34 @@
         format!("scriptkit://notes/{}", id.as_str())
     }
 
-    pub(super) fn copy_note_as_markdown(&self) {
+    pub(super) fn copy_note_as_markdown(&mut self) {
         self.export_note(ExportFormat::Markdown);
     }
 
-    pub(super) fn copy_note_deeplink(&self) {
-        if let Some(id) = self.selected_note_id {
-            let deeplink = self.note_deeplink(id);
-            self.copy_text_to_clipboard(&deeplink);
-        }
+    pub(super) fn copy_note_deeplink(&mut self) {
+        let Some((id, _)) = self.selected_note_for_action("copy_note_deeplink") else {
+            return;
+        };
+        let deeplink = self.note_deeplink(id);
+        self.copy_text_to_clipboard(&deeplink);
     }
 
-    pub(super) fn create_note_quicklink(&self) {
-        if let Some(id) = self.selected_note_id {
-            let title = self
-                .notes
-                .iter()
-                .find(|note| note.id == id)
-                .map(|note| {
-                    if note.title.is_empty() {
-                        "Untitled Note".to_string()
-                    } else {
-                        note.title.clone()
-                    }
-                })
-                .unwrap_or_else(|| "Untitled Note".to_string());
-            let deeplink = self.note_deeplink(id);
-            let quicklink = format!("[{}]({})", title, deeplink);
-            self.copy_text_to_clipboard(&quicklink);
-        }
+    pub(super) fn create_note_quicklink(&mut self) {
+        let Some((id, note)) = self.selected_note_for_action("create_note_quicklink") else {
+            return;
+        };
+        let title = if note.title.is_empty() {
+            "Untitled Note".to_string()
+        } else {
+            note.title.clone()
+        };
+        let deeplink = self.note_deeplink(id);
+        let quicklink = format!("[{}]({})", title, deeplink);
+        self.copy_text_to_clipboard(&quicklink);
     }
 
     pub(super) fn duplicate_selected_note(&mut self, window: &mut Window, cx: &mut Context<Self>) {
-        let Some(id) = self.selected_note_id else {
-            return;
-        };
-        let Some(note) = self.notes.iter().find(|note| note.id == id) else {
+        let Some((_id, note)) = self.selected_note_for_action("duplicate_selected_note") else {
             return;
         };
 
diff --git a/src/notes/window/panels.rs b/src/notes/window/panels.rs
index 16b4b85b9be89780b4c9430f0db050a9af14532e..b843238a1e9103f6055702cf09dc506f1e99fa17
--- a/src/notes/window/panels.rs
+++ b/src/notes/window/panels.rs
@@ -281,6 +281,17 @@
                 self.select_note(note_id, window, cx);
                 return;
             }
+
+            tracing::warn!(
+                action_id,
+                note_id_str,
+                selected_note_id = ?self.selected_note_id,
+                notes_len = self.notes.len(),
+                "notes_note_switcher_selected_note_not_found",
+            );
+            self.show_selected_note_missing_feedback("execute_note_switcher_action");
+            self.close_browse_panel(window, cx);
+            return;
         }
 
         // Handle "no_notes" placeholder action

file update:
diff --git a/src/notes/window/notes.rs b/src/notes/window/notes.rs
index 2b96e1be9f619ad7fa8b88d1287b653adb4780b4..449ab857a161bcb00618adf6e45ab022a3ac86fe
--- a/src/notes/window/notes.rs
+++ b/src/notes/window/notes.rs
@@ -231,42 +231,42 @@
     }
 
     /// Export the current note
-    pub(super) fn export_note(&self, format: ExportFormat) {
-        if let Some(id) = self.selected_note_id {
-            if let Some(note) = self.notes.iter().find(|n| n.id == id) {
-                let content = match format {
-                    ExportFormat::PlainText => note.content.clone(),
-                    // For Markdown, just export the content as-is.
-                    // The title is derived from the first line of content,
-                    // so prepending it would cause duplication.
-                    ExportFormat::Markdown => note.content.clone(),
-                    ExportFormat::Html => {
-                        // For HTML, we include proper structure with the title
-                        // and render the content as preformatted text
-                        format!(
-                            "<!DOCTYPE html>\n<html>\n<head><title>{}</title></head>\n<body>\n<h1>{}</h1>\n<pre>{}</pre>\n</body>\n</html>",
-                            note.title, note.title, note.content
-                        )
-                    }
-                };
+    pub(super) fn export_note(&mut self, format: ExportFormat) {
+        let Some((_id, note)) = self.selected_note_for_action("export_note") else {
+            return;
+        };
 
-                // Copy to clipboard
-                #[cfg(target_os = "macos")]
-                {
-                    use std::process::Command;
-                    let _ = Command::new("pbcopy")
-                        .stdin(std::process::Stdio::piped())
-                        .spawn()
-                        .and_then(|mut child| {
-                            use std::io::Write;
-                            if let Some(stdin) = child.stdin.as_mut() {
-                                stdin.write_all(content.as_bytes())?;
-                            }
-                            child.wait()
-                        });
-                    info!(format = ?format, "Note exported to clipboard");
-                }
+        let content = match format {
+            ExportFormat::PlainText => note.content.clone(),
+            // For Markdown, just export the content as-is.
+            // The title is derived from the first line of content,
+            // so prepending it would cause duplication.
+            ExportFormat::Markdown => note.content.clone(),
+            ExportFormat::Html => {
+                // For HTML, we include proper structure with the title
+                // and render the content as preformatted text
+                format!(
+                    "<!DOCTYPE html>\n<html>\n<head><title>{}</title></head>\n<body>\n<h1>{}</h1>\n<pre>{}</pre>\n</body>\n</html>",
+                    note.title, note.title, note.content
+                )
             }
+        };
+
+        // Copy to clipboard
+        #[cfg(target_os = "macos")]
+        {
+            use std::process::Command;
+            let _ = Command::new("pbcopy")
+                .stdin(std::process::Stdio::piped())
+                .spawn()
+                .and_then(|mut child| {
+                    use std::io::Write;
+                    if let Some(stdin) = child.stdin.as_mut() {
+                        stdin.write_all(content.as_bytes())?;
+                    }
+                    child.wait()
+                });
+            info!(format = ?format, "Note exported to clipboard");
         }
     }
 }
diff --git a/src/notes/window/notes_actions.rs b/src/notes/window/notes_actions.rs
index 6405519cffd92b2252b2e410eb3f58ee37800b8d..603be7a00cb2f2023699769b2b8b33c629a21238
--- a/src/notes/window/notes_actions.rs
+++ b/src/notes/window/notes_actions.rs
@@ -1,6 +1,40 @@
 use super::*;
 
 impl NotesApp {
+    const SELECTED_NOTE_NOT_FOUND_FEEDBACK: &'static str = "Selected note could not be found";
+
+    pub(super) fn resolve_selected_note(
+        selected_note_id: Option<NoteId>,
+        notes: &[Note],
+    ) -> Option<(NoteId, &Note)> {
+        let selected_note_id = selected_note_id?;
+        notes
+            .iter()
+            .find(|note| note.id == selected_note_id)
+            .map(|note| (selected_note_id, note))
+    }
+
+    pub(super) fn show_selected_note_missing_feedback(&mut self, action: &'static str) {
+        tracing::warn!(
+            action,
+            selected_note_id = ?self.selected_note_id,
+            notes_len = self.notes.len(),
+            "notes_action_selected_note_not_found",
+        );
+        self.show_action_feedback(Self::SELECTED_NOTE_NOT_FOUND_FEEDBACK, true);
+    }
+
+    pub(super) fn selected_note_for_action(
+        &mut self,
+        action: &'static str,
+    ) -> Option<(NoteId, &Note)> {
+        let selected_note = Self::resolve_selected_note(self.selected_note_id, &self.notes);
+        if selected_note.is_none() {
+            self.show_selected_note_missing_feedback(action);
+        }
+        selected_note
+    }
+
     /// Cycle sort mode: Updated → Created → Alphabetical → Updated
     pub(super) fn cycle_sort_mode(&mut self, cx: &mut Context<Self>) {
         self.sort_mode = match self.sort_mode {
@@ -86,42 +120,34 @@
         format!("scriptkit://notes/{}", id.as_str())
     }
 
-    pub(super) fn copy_note_as_markdown(&self) {
+    pub(super) fn copy_note_as_markdown(&mut self) {
         self.export_note(ExportFormat::Markdown);
     }
 
-    pub(super) fn copy_note_deeplink(&self) {
-        if let Some(id) = self.selected_note_id {
-            let deeplink = self.note_deeplink(id);
-            self.copy_text_to_clipboard(&deeplink);
-        }
+    pub(super) fn copy_note_deeplink(&mut self) {
+        let Some((id, _)) = self.selected_note_for_action("copy_note_deeplink") else {
+            return;
+        };
+        let deeplink = self.note_deeplink(id);
+        self.copy_text_to_clipboard(&deeplink);
     }
 
-    pub(super) fn create_note_quicklink(&self) {
-        if let Some(id) = self.selected_note_id {
-            let title = self
-                .notes
-                .iter()
-                .find(|note| note.id == id)
-                .map(|note| {
-                    if note.title.is_empty() {
-                        "Untitled Note".to_string()
-                    } else {
-                        note.title.clone()
-                    }
-                })
-                .unwrap_or_else(|| "Untitled Note".to_string());
-            let deeplink = self.note_deeplink(id);
-            let quicklink = format!("[{}]({})", title, deeplink);
-            self.copy_text_to_clipboard(&quicklink);
-        }
+    pub(super) fn create_note_quicklink(&mut self) {
+        let Some((id, note)) = self.selected_note_for_action("create_note_quicklink") else {
+            return;
+        };
+        let title = if note.title.is_empty() {
+            "Untitled Note".to_string()
+        } else {
+            note.title.clone()
+        };
+        let deeplink = self.note_deeplink(id);
+        let quicklink = format!("[{}]({})", title, deeplink);
+        self.copy_text_to_clipboard(&quicklink);
     }
 
     pub(super) fn duplicate_selected_note(&mut self, window: &mut Window, cx: &mut Context<Self>) {
-        let Some(id) = self.selected_note_id else {
-            return;
-        };
-        let Some(note) = self.notes.iter().find(|note| note.id == id) else {
+        let Some((_id, note)) = self.selected_note_for_action("duplicate_selected_note") else {
             return;
         };
 
diff --git a/src/notes/window/panels.rs b/src/notes/window/panels.rs
index 16b4b85b9be89780b4c9430f0db050a9af14532e..b843238a1e9103f6055702cf09dc506f1e99fa17
--- a/src/notes/window/panels.rs
+++ b/src/notes/window/panels.rs
@@ -281,6 +281,17 @@
                 self.select_note(note_id, window, cx);
                 return;
             }
+
+            tracing::warn!(
+                action_id,
+                note_id_str,
+                selected_note_id = ?self.selected_note_id,
+                notes_len = self.notes.len(),
+                "notes_note_switcher_selected_note_not_found",
+            );
+            self.show_selected_note_missing_feedback("execute_note_switcher_action");
+            self.close_browse_panel(window, cx);
+            return;
         }
 
         // Handle "no_notes" placeholder action


thinking
**Adding helper tests imports**
codex
I’ve finished the behavior wiring; next I’m adding targeted unit tests for the selected-note resolver to cover missing, stale, and valid selection cases.
file update
M /Users/johnlindquist/dev/script-kit-gpui/src/notes/window/tests.rs
@@ -1,2 +1,2 @@
-use super::NotesApp;
+use super::{Note, NoteId, NotesApp};
 
@@ -39 +39,29 @@
 }
+
+#[test]
+fn test_resolve_selected_note_returns_none_when_selection_is_missing() {
+    let notes = vec![Note::with_content("one"), Note::with_content("two")];
+
+    let selected = NotesApp::resolve_selected_note(None, &notes);
+
+    assert!(selected.is_none());
+}
+
+#[test]
+fn test_resolve_selected_note_returns_none_when_selection_is_stale() {
+    let notes = vec![Note::with_content("one"), Note::with_content("two")];
+
+    let selected = NotesApp::resolve_selected_note(Some(NoteId::new()), &notes);
+
+    assert!(selected.is_none());
+}
+
+#[test]
+fn test_resolve_selected_note_returns_note_when_selection_exists() {
+    let notes = vec![Note::with_content("one"), Note::with_content("two")];
+    let selected_id = notes[1].id;
+
+    let selected = NotesApp::resolve_selected_note(Some(selected_id), &notes);
+
+    assert_eq!(selected.map(|(id, note)| (id, note.id)), Some((selected_id, selected_id)));
+}
apply_patch(auto_approved=true) exited 0 in 26ms:
Success. Updated the following files:
M src/notes/window/tests.rs
file update:
diff --git a/src/notes/window/notes.rs b/src/notes/window/notes.rs
index 2b96e1be9f619ad7fa8b88d1287b653adb4780b4..449ab857a161bcb00618adf6e45ab022a3ac86fe
--- a/src/notes/window/notes.rs
+++ b/src/notes/window/notes.rs
@@ -231,42 +231,42 @@
     }
 
     /// Export the current note
-    pub(super) fn export_note(&self, format: ExportFormat) {
-        if let Some(id) = self.selected_note_id {
-            if let Some(note) = self.notes.iter().find(|n| n.id == id) {
-                let content = match format {
-                    ExportFormat::PlainText => note.content.clone(),
-                    // For Markdown, just export the content as-is.
-                    // The title is derived from the first line of content,
-                    // so prepending it would cause duplication.
-                    ExportFormat::Markdown => note.content.clone(),
-                    ExportFormat::Html => {
-                        // For HTML, we include proper structure with the title
-                        // and render the content as preformatted text
-                        format!(
-                            "<!DOCTYPE html>\n<html>\n<head><title>{}</title></head>\n<body>\n<h1>{}</h1>\n<pre>{}</pre>\n</body>\n</html>",
-                            note.title, note.title, note.content
-                        )
-                    }
-                };
+    pub(super) fn export_note(&mut self, format: ExportFormat) {
+        let Some((_id, note)) = self.selected_note_for_action("export_note") else {
+            return;
+        };
 
-                // Copy to clipboard
-                #[cfg(target_os = "macos")]
-                {
-                    use std::process::Command;
-                    let _ = Command::new("pbcopy")
-                        .stdin(std::process::Stdio::piped())
-                        .spawn()
-                        .and_then(|mut child| {
-                            use std::io::Write;
-                            if let Some(stdin) = child.stdin.as_mut() {
-                                stdin.write_all(content.as_bytes())?;
-                            }
-                            child.wait()
-                        });
-                    info!(format = ?format, "Note exported to clipboard");
-                }
+        let content = match format {
+            ExportFormat::PlainText => note.content.clone(),
+            // For Markdown, just export the content as-is.
+            // The title is derived from the first line of content,
+            // so prepending it would cause duplication.
+            ExportFormat::Markdown => note.content.clone(),
+            ExportFormat::Html => {
+                // For HTML, we include proper structure with the title
+                // and render the content as preformatted text
+                format!(
+                    "<!DOCTYPE html>\n<html>\n<head><title>{}</title></head>\n<body>\n<h1>{}</h1>\n<pre>{}</pre>\n</body>\n</html>",
+                    note.title, note.title, note.content
+                )
             }
+        };
+
+        // Copy to clipboard
+        #[cfg(target_os = "macos")]
+        {
+            use std::process::Command;
+            let _ = Command::new("pbcopy")
+                .stdin(std::process::Stdio::piped())
+                .spawn()
+                .and_then(|mut child| {
+                    use std::io::Write;
+                    if let Some(stdin) = child.stdin.as_mut() {
+                        stdin.write_all(content.as_bytes())?;
+                    }
+                    child.wait()
+                });
+            info!(format = ?format, "Note exported to clipboard");
         }
     }
 }
diff --git a/src/notes/window/notes_actions.rs b/src/notes/window/notes_actions.rs
index 6405519cffd92b2252b2e410eb3f58ee37800b8d..603be7a00cb2f2023699769b2b8b33c629a21238
--- a/src/notes/window/notes_actions.rs
+++ b/src/notes/window/notes_actions.rs
@@ -1,6 +1,40 @@
 use super::*;
 
 impl NotesApp {
+    const SELECTED_NOTE_NOT_FOUND_FEEDBACK: &'static str = "Selected note could not be found";
+
+    pub(super) fn resolve_selected_note(
+        selected_note_id: Option<NoteId>,
+        notes: &[Note],
+    ) -> Option<(NoteId, &Note)> {
+        let selected_note_id = selected_note_id?;
+        notes
+            .iter()
+            .find(|note| note.id == selected_note_id)
+            .map(|note| (selected_note_id, note))
+    }
+
+    pub(super) fn show_selected_note_missing_feedback(&mut self, action: &'static str) {
+        tracing::warn!(
+            action,
+            selected_note_id = ?self.selected_note_id,
+            notes_len = self.notes.len(),
+            "notes_action_selected_note_not_found",
+        );
+        self.show_action_feedback(Self::SELECTED_NOTE_NOT_FOUND_FEEDBACK, true);
+    }
+
+    pub(super) fn selected_note_for_action(
+        &mut self,
+        action: &'static str,
+    ) -> Option<(NoteId, &Note)> {
+        let selected_note = Self::resolve_selected_note(self.selected_note_id, &self.notes);
+        if selected_note.is_none() {
+            self.show_selected_note_missing_feedback(action);
+        }
+        selected_note
+    }
+
     /// Cycle sort mode: Updated → Created → Alphabetical → Updated
     pub(super) fn cycle_sort_mode(&mut self, cx: &mut Context<Self>) {
         self.sort_mode = match self.sort_mode {
@@ -86,42 +120,34 @@
         format!("scriptkit://notes/{}", id.as_str())
     }
 
-    pub(super) fn copy_note_as_markdown(&self) {
+    pub(super) fn copy_note_as_markdown(&mut self) {
         self.export_note(ExportFormat::Markdown);
     }
 
-    pub(super) fn copy_note_deeplink(&self) {
-        if let Some(id) = self.selected_note_id {
-            let deeplink = self.note_deeplink(id);
-            self.copy_text_to_clipboard(&deeplink);
-        }
+    pub(super) fn copy_note_deeplink(&mut self) {
+        let Some((id, _)) = self.selected_note_for_action("copy_note_deeplink") else {
+            return;
+        };
+        let deeplink = self.note_deeplink(id);
+        self.copy_text_to_clipboard(&deeplink);
     }
 
-    pub(super) fn create_note_quicklink(&self) {
-        if let Some(id) = self.selected_note_id {
-            let title = self
-                .notes
-                .iter()
-                .find(|note| note.id == id)
-                .map(|note| {
-                    if note.title.is_empty() {
-                        "Untitled Note".to_string()
-                    } else {
-                        note.title.clone()
-                    }
-                })
-                .unwrap_or_else(|| "Untitled Note".to_string());
-            let deeplink = self.note_deeplink(id);
-            let quicklink = format!("[{}]({})", title, deeplink);
-            self.copy_text_to_clipboard(&quicklink);
-        }
+    pub(super) fn create_note_quicklink(&mut self) {
+        let Some((id, note)) = self.selected_note_for_action("create_note_quicklink") else {
+            return;
+        };
+        let title = if note.title.is_empty() {
+            "Untitled Note".to_string()
+        } else {
+            note.title.clone()
+        };
+        let deeplink = self.note_deeplink(id);
+        let quicklink = format!("[{}]({})", title, deeplink);
+        self.copy_text_to_clipboard(&quicklink);
     }
 
     pub(super) fn duplicate_selected_note(&mut self, window: &mut Window, cx: &mut Context<Self>) {
-        let Some(id) = self.selected_note_id else {
-            return;
-        };
-        let Some(note) = self.notes.iter().find(|note| note.id == id) else {
+        let Some((_id, note)) = self.selected_note_for_action("duplicate_selected_note") else {
             return;
         };
 
diff --git a/src/notes/window/panels.rs b/src/notes/window/panels.rs
index 16b4b85b9be89780b4c9430f0db050a9af14532e..b843238a1e9103f6055702cf09dc506f1e99fa17
--- a/src/notes/window/panels.rs
+++ b/src/notes/window/panels.rs
@@ -281,6 +281,17 @@
                 self.select_note(note_id, window, cx);
                 return;
             }
+
+            tracing::warn!(
+                action_id,
+                note_id_str,
+                selected_note_id = ?self.selected_note_id,
+                notes_len = self.notes.len(),
+                "notes_note_switcher_selected_note_not_found",
+            );
+            self.show_selected_note_missing_feedback("execute_note_switcher_action");
+            self.close_browse_panel(window, cx);
+            return;
         }
 
         // Handle "no_notes" placeholder action
diff --git a/src/notes/window/tests.rs b/src/notes/window/tests.rs
index 8cb070d17ec066ba2b9e5a81de39cf1dfd19742b..441dc8b615019a2f05ba8f031d6bad5a449dd4a1
--- a/src/notes/window/tests.rs
+++ b/src/notes/window/tests.rs
@@ -1,4 +1,4 @@
-use super::NotesApp;
+use super::{Note, NoteId, NotesApp};
 
 #[test]
 fn formatting_replacement_wraps_selected_text() {
@@ -37,3 +37,31 @@
     assert_eq!(new_value, "he****llo");
     assert_eq!(new_selection, 4..4);
 }
+
+#[test]
+fn test_resolve_selected_note_returns_none_when_selection_is_missing() {
+    let notes = vec![Note::with_content("one"), Note::with_content("two")];
+
+    let selected = NotesApp::resolve_selected_note(None, &notes);
+
+    assert!(selected.is_none());
+}
+
+#[test]
+fn test_resolve_selected_note_returns_none_when_selection_is_stale() {
+    let notes = vec![Note::with_content("one"), Note::with_content("two")];
+
+    let selected = NotesApp::resolve_selected_note(Some(NoteId::new()), &notes);
+
+    assert!(selected.is_none());
+}
+
+#[test]
+fn test_resolve_selected_note_returns_note_when_selection_exists() {
+    let notes = vec![Note::with_content("one"), Note::with_content("two")];
+    let selected_id = notes[1].id;
+
+    let selected = NotesApp::resolve_selected_note(Some(selected_id), &notes);
+
+    assert_eq!(selected.map(|(id, note)| (id, note.id)), Some((selected_id, selected_id)));
+}

file update:
diff --git a/src/notes/window/notes.rs b/src/notes/window/notes.rs
index 2b96e1be9f619ad7fa8b88d1287b653adb4780b4..449ab857a161bcb00618adf6e45ab022a3ac86fe
--- a/src/notes/window/notes.rs
+++ b/src/notes/window/notes.rs
@@ -231,42 +231,42 @@
     }
 
     /// Export the current note
-    pub(super) fn export_note(&self, format: ExportFormat) {
-        if let Some(id) = self.selected_note_id {
-            if let Some(note) = self.notes.iter().find(|n| n.id == id) {
-                let content = match format {
-                    ExportFormat::PlainText => note.content.clone(),
-                    // For Markdown, just export the content as-is.
-                    // The title is derived from the first line of content,
-                    // so prepending it would cause duplication.
-                    ExportFormat::Markdown => note.content.clone(),
-                    ExportFormat::Html => {
-                        // For HTML, we include proper structure with the title
-                        // and render the content as preformatted text
-                        format!(
-                            "<!DOCTYPE html>\n<html>\n<head><title>{}</title></head>\n<body>\n<h1>{}</h1>\n<pre>{}</pre>\n</body>\n</html>",
-                            note.title, note.title, note.content
-                        )
-                    }
-                };
+    pub(super) fn export_note(&mut self, format: ExportFormat) {
+        let Some((_id, note)) = self.selected_note_for_action("export_note") else {
+            return;
+        };
 
-                // Copy to clipboard
-                #[cfg(target_os = "macos")]
-                {
-                    use std::process::Command;
-                    let _ = Command::new("pbcopy")
-                        .stdin(std::process::Stdio::piped())
-                        .spawn()
-                        .and_then(|mut child| {
-                            use std::io::Write;
-                            if let Some(stdin) = child.stdin.as_mut() {
-                                stdin.write_all(content.as_bytes())?;
-                            }
-                            child.wait()
-                        });
-                    info!(format = ?format, "Note exported to clipboard");
-                }
+        let content = match format {
+            ExportFormat::PlainText => note.content.clone(),
+            // For Markdown, just export the content as-is.
+            // The title is derived from the first line of content,
+            // so prepending it would cause duplication.
+            ExportFormat::Markdown => note.content.clone(),
+            ExportFormat::Html => {
+                // For HTML, we include proper structure with the title
+                // and render the content as preformatted text
+                format!(
+                    "<!DOCTYPE html>\n<html>\n<head><title>{}</title></head>\n<body>\n<h1>{}</h1>\n<pre>{}</pre>\n</body>\n</html>",
+                    note.title, note.title, note.content
+                )
             }
+        };
+
+        // Copy to clipboard
+        #[cfg(target_os = "macos")]
+        {
+            use std::process::Command;
+            let _ = Command::new("pbcopy")
+                .stdin(std::process::Stdio::piped())
+                .spawn()
+                .and_then(|mut child| {
+                    use std::io::Write;
+                    if let Some(stdin) = child.stdin.as_mut() {
+                        stdin.write_all(content.as_bytes())?;
+                    }
+                    child.wait()
+                });
+            info!(format = ?format, "Note exported to clipboard");
         }
     }
 }
diff --git a/src/notes/window/notes_actions.rs b/src/notes/window/notes_actions.rs
index 6405519cffd92b2252b2e410eb3f58ee37800b8d..603be7a00cb2f2023699769b2b8b33c629a21238
--- a/src/notes/window/notes_actions.rs
+++ b/src/notes/window/notes_actions.rs
@@ -1,6 +1,40 @@
 use super::*;
 
 impl NotesApp {
+    const SELECTED_NOTE_NOT_FOUND_FEEDBACK: &'static str = "Selected note could not be found";
+
+    pub(super) fn resolve_selected_note(
+        selected_note_id: Option<NoteId>,
+        notes: &[Note],
+    ) -> Option<(NoteId, &Note)> {
+        let selected_note_id = selected_note_id?;
+        notes
+            .iter()
+            .find(|note| note.id == selected_note_id)
+            .map(|note| (selected_note_id, note))
+    }
+
+    pub(super) fn show_selected_note_missing_feedback(&mut self, action: &'static str) {
+        tracing::warn!(
+            action,
+            selected_note_id = ?self.selected_note_id,
+            notes_len = self.notes.len(),
+            "notes_action_selected_note_not_found",
+        );
+        self.show_action_feedback(Self::SELECTED_NOTE_NOT_FOUND_FEEDBACK, true);
+    }
+
+    pub(super) fn selected_note_for_action(
+        &mut self,
+        action: &'static str,
+    ) -> Option<(NoteId, &Note)> {
+        let selected_note = Self::resolve_selected_note(self.selected_note_id, &self.notes);
+        if selected_note.is_none() {
+            self.show_selected_note_missing_feedback(action);
+        }
+        selected_note
+    }
+
     /// Cycle sort mode: Updated → Created → Alphabetical → Updated
     pub(super) fn cycle_sort_mode(&mut self, cx: &mut Context<Self>) {
         self.sort_mode = match self.sort_mode {
@@ -86,42 +120,34 @@
         format!("scriptkit://notes/{}", id.as_str())
     }
 
-    pub(super) fn copy_note_as_markdown(&self) {
+    pub(super) fn copy_note_as_markdown(&mut self) {
         self.export_note(ExportFormat::Markdown);
     }
 
-    pub(super) fn copy_note_deeplink(&self) {
-        if let Some(id) = self.selected_note_id {
-            let deeplink = self.note_deeplink(id);
-            self.copy_text_to_clipboard(&deeplink);
-        }
+    pub(super) fn copy_note_deeplink(&mut self) {
+        let Some((id, _)) = self.selected_note_for_action("copy_note_deeplink") else {
+            return;
+        };
+        let deeplink = self.note_deeplink(id);
+        self.copy_text_to_clipboard(&deeplink);
     }
 
-    pub(super) fn create_note_quicklink(&self) {
-        if let Some(id) = self.selected_note_id {
-            let title = self
-                .notes
-                .iter()
-                .find(|note| note.id == id)
-                .map(|note| {
-                    if note.title.is_empty() {
-                        "Untitled Note".to_string()
-                    } else {
-                        note.title.clone()
-                    }
-                })
-                .unwrap_or_else(|| "Untitled Note".to_string());
-            let deeplink = self.note_deeplink(id);
-            let quicklink = format!("[{}]({})", title, deeplink);
-            self.copy_text_to_clipboard(&quicklink);
-        }
+    pub(super) fn create_note_quicklink(&mut self) {
+        let Some((id, note)) = self.selected_note_for_action("create_note_quicklink") else {
+            return;
+        };
+        let title = if note.title.is_empty() {
+            "Untitled Note".to_string()
+        } else {
+            note.title.clone()
+        };
+        let deeplink = self.note_deeplink(id);
+        let quicklink = format!("[{}]({})", title, deeplink);
+        self.copy_text_to_clipboard(&quicklink);
     }
 
     pub(super) fn duplicate_selected_note(&mut self, window: &mut Window, cx: &mut Context<Self>) {
-        let Some(id) = self.selected_note_id else {
-            return;
-        };
-        let Some(note) = self.notes.iter().find(|note| note.id == id) else {
+        let Some((_id, note)) = self.selected_note_for_action("duplicate_selected_note") else {
             return;
         };
 
diff --git a/src/notes/window/panels.rs b/src/notes/window/panels.rs
index 16b4b85b9be89780b4c9430f0db050a9af14532e..b843238a1e9103f6055702cf09dc506f1e99fa17
--- a/src/notes/window/panels.rs
+++ b/src/notes/window/panels.rs
@@ -281,6 +281,17 @@
                 self.select_note(note_id, window, cx);
                 return;
             }
+
+            tracing::warn!(
+                action_id,
+                note_id_str,
+                selected_note_id = ?self.selected_note_id,
+                notes_len = self.notes.len(),
+                "notes_note_switcher_selected_note_not_found",
+            );
+            self.show_selected_note_missing_feedback("execute_note_switcher_action");
+            self.close_browse_panel(window, cx);
+            return;
         }
 
         // Handle "no_notes" placeholder action
diff --git a/src/notes/window/tests.rs b/src/notes/window/tests.rs
index 8cb070d17ec066ba2b9e5a81de39cf1dfd19742b..441dc8b615019a2f05ba8f031d6bad5a449dd4a1
--- a/src/notes/window/tests.rs
+++ b/src/notes/window/tests.rs
@@ -1,4 +1,4 @@
-use super::NotesApp;
+use super::{Note, NoteId, NotesApp};
 
 #[test]
 fn formatting_replacement_wraps_selected_text() {
@@ -37,3 +37,31 @@
     assert_eq!(new_value, "he****llo");
     assert_eq!(new_selection, 4..4);
 }
+
+#[test]
+fn test_resolve_selected_note_returns_none_when_selection_is_missing() {
+    let notes = vec![Note::with_content("one"), Note::with_content("two")];
+
+    let selected = NotesApp::resolve_selected_note(None, &notes);
+
+    assert!(selected.is_none());
+}
+
+#[test]
+fn test_resolve_selected_note_returns_none_when_selection_is_stale() {
+    let notes = vec![Note::with_content("one"), Note::with_content("two")];
+
+    let selected = NotesApp::resolve_selected_note(Some(NoteId::new()), &notes);
+
+    assert!(selected.is_none());
+}
+
+#[test]
+fn test_resolve_selected_note_returns_note_when_selection_exists() {
+    let notes = vec![Note::with_content("one"), Note::with_content("two")];
+    let selected_id = notes[1].id;
+
+    let selected = NotesApp::resolve_selected_note(Some(selected_id), &notes);
+
+    assert_eq!(selected.map(|(id, note)| (id, note.id)), Some((selected_id, selected_id)));
+}


thinking
**Checking changed files for issues**
exec
/bin/zsh -lc "nl -ba src/notes/window/tests.rs | sed -n '1,220p'" in /Users/johnlindquist/dev/script-kit-gpuiexec
/bin/zsh -lc "nl -ba src/notes/window/notes_actions.rs | sed -n '1,260p'" in /Users/johnlindquist/dev/script-kit-gpuiexec
/bin/zsh -lc "nl -ba src/notes/window/panels.rs | sed -n '260,330p'" in /Users/johnlindquist/dev/script-kit-gpuiexec
/bin/zsh -lc "nl -ba src/notes/window/notes.rs | sed -n '220,320p'" in /Users/johnlindquist/dev/script-kit-gpui succeeded in 51ms:
   220	
   221	        if let Some(note) = notes.first() {
   222	            self.select_note(note.id, window, cx);
   223	        } else {
   224	            self.selected_note_id = None;
   225	            self.editor_state.update(cx, |state, cx| {
   226	                state.set_value("", window, cx);
   227	            });
   228	        }
   229	
   230	        cx.notify();
   231	    }
   232	
   233	    /// Export the current note
   234	    pub(super) fn export_note(&mut self, format: ExportFormat) {
   235	        let Some((_id, note)) = self.selected_note_for_action("export_note") else {
   236	            return;
   237	        };
   238	
   239	        let content = match format {
 succeeded in 51ms:
     1	use super::{Note, NoteId, NotesApp};
     2	
     3	#[test]
     4	fn formatting_replacement_wraps_selected_text() {
     5	    let value = "hello world";
     6	    let selection = 6..11;
     7	
     8	    let (replacement, new_selection) =
     9	        NotesApp::formatting_replacement(value, selection.clone(), "**", "**");
    10	
    11	    let new_value = format!(
    12	        "{}{}{}",
    13	        &value[..selection.start],
    14	        replacement,
    15	        &value[selection.end..]
    16	    );
    17	
    18	    assert_eq!(new_value, "hello **world**");
    19	    assert_eq!(new_selection, 8..13);
    20	}
 succeeded in 51ms:
   260	            // Unknown action - just close the command bar
   261	            self.close_actions_panel(window, cx);
   262	        }
   263	    }
   264	
   265	    /// Execute an action from the note switcher (Cmd+P)
   266	    /// Handles note selection when action_id starts with "note_"
   267	    pub(super) fn execute_note_switcher_action(
   268	        &mut self,
   269	        action_id: &str,
   270	        window: &mut Window,
   271	        cx: &mut Context<Self>,
   272	    ) {
   273	        debug!(action_id, "Executing note switcher action");
   274	
   275	        // Handle note selection (action_id format: "note_{uuid}")
   276	        if let Some(note_id_str) = action_id.strip_prefix("note_") {
   277	            // Find the note by ID string
   278	            if let Some(note) = self.notes.iter().find(|n| n.id.as_str() == note_id_str) {
   279	                let note_id = note.id;
 succeeded in 51ms:
     1	use super::*;
     2	
     3	impl NotesApp {
     4	    const SELECTED_NOTE_NOT_FOUND_FEEDBACK: &'static str = "Selected note could not be found";
     5	
     6	    pub(super) fn resolve_selected_note(
     7	        selected_note_id: Option<NoteId>,
     8	        notes: &[Note],
     9	    ) -> Option<(NoteId, &Note)> {
    10	        let selected_note_id = selected_note_id?;
    11	        notes
    12	            .iter()
    13	            .find(|note| note.id == selected_note_id)
    14	            .map(|note| (selected_note_id, note))
    15	    }
    16	
    17	    pub(super) fn show_selected_note_missing_feedback(&mut self, action: &'static str) {
    18	        tracing::warn!(
    19	            action,
    20	            selected_note_id = ?self.selected_note_id,
file update:
diff --git a/src/notes/window/notes.rs b/src/notes/window/notes.rs
index 2b96e1be9f619ad7fa8b88d1287b653adb4780b4..449ab857a161bcb00618adf6e45ab022a3ac86fe
--- a/src/notes/window/notes.rs
+++ b/src/notes/window/notes.rs
@@ -231,42 +231,42 @@
     }
 
     /// Export the current note
-    pub(super) fn export_note(&self, format: ExportFormat) {
-        if let Some(id) = self.selected_note_id {
-            if let Some(note) = self.notes.iter().find(|n| n.id == id) {
-                let content = match format {
-                    ExportFormat::PlainText => note.content.clone(),
-                    // For Markdown, just export the content as-is.
-                    // The title is derived from the first line of content,
-                    // so prepending it would cause duplication.
-                    ExportFormat::Markdown => note.content.clone(),
-                    ExportFormat::Html => {
-                        // For HTML, we include proper structure with the title
-                        // and render the content as preformatted text
-                        format!(
-                            "<!DOCTYPE html>\n<html>\n<head><title>{}</title></head>\n<body>\n<h1>{}</h1>\n<pre>{}</pre>\n</body>\n</html>",
-                            note.title, note.title, note.content
-                        )
-                    }
-                };
+    pub(super) fn export_note(&mut self, format: ExportFormat) {
+        let Some((_id, note)) = self.selected_note_for_action("export_note") else {
+            return;
+        };
 
-                // Copy to clipboard
-                #[cfg(target_os = "macos")]
-                {
-                    use std::process::Command;
-                    let _ = Command::new("pbcopy")
-                        .stdin(std::process::Stdio::piped())
-                        .spawn()
-                        .and_then(|mut child| {
-                            use std::io::Write;
-                            if let Some(stdin) = child.stdin.as_mut() {
-                                stdin.write_all(content.as_bytes())?;
-                            }
-                            child.wait()
-                        });
-                    info!(format = ?format, "Note exported to clipboard");
-                }
+        let content = match format {
+            ExportFormat::PlainText => note.content.clone(),
+            // For Markdown, just export the content as-is.
+            // The title is derived from the first line of content,
+            // so prepending it would cause duplication.
+            ExportFormat::Markdown => note.content.clone(),
+            ExportFormat::Html => {
+                // For HTML, we include proper structure with the title
+                // and render the content as preformatted text
+                format!(
+                    "<!DOCTYPE html>\n<html>\n<head><title>{}</title></head>\n<body>\n<h1>{}</h1>\n<pre>{}</pre>\n</body>\n</html>",
+                    note.title, note.title, note.content
+                )
             }
+        };
+
+        // Copy to clipboard
+        #[cfg(target_os = "macos")]
+        {
+            use std::process::Command;
+            let _ = Command::new("pbcopy")
+                .stdin(std::process::Stdio::piped())
+                .spawn()
+                .and_then(|mut child| {
+                    use std::io::Write;
+                    if let Some(stdin) = child.stdin.as_mut() {
+                        stdin.write_all(content.as_bytes())?;
+                    }
+                    child.wait()
+                });
+            info!(format = ?format, "Note exported to clipboard");
         }
     }
 }
diff --git a/src/notes/window/notes_actions.rs b/src/notes/window/notes_actions.rs
index 6405519cffd92b2252b2e410eb3f58ee37800b8d..603be7a00cb2f2023699769b2b8b33c629a21238
--- a/src/notes/window/notes_actions.rs
+++ b/src/notes/window/notes_actions.rs
@@ -1,6 +1,40 @@
 use super::*;
 
 impl NotesApp {
+    const SELECTED_NOTE_NOT_FOUND_FEEDBACK: &'static str = "Selected note could not be found";
+
+    pub(super) fn resolve_selected_note(
+        selected_note_id: Option<NoteId>,
+        notes: &[Note],
+    ) -> Option<(NoteId, &Note)> {
+        let selected_note_id = selected_note_id?;
+        notes
+            .iter()
+            .find(|note| note.id == selected_note_id)
+            .map(|note| (selected_note_id, note))
+    }
+
+    pub(super) fn show_selected_note_missing_feedback(&mut self, action: &'static str) {
+        tracing::warn!(
+            action,
+            selected_note_id = ?self.selected_note_id,
+            notes_len = self.notes.len(),
+            "notes_action_selected_note_not_found",
+        );
+        self.show_action_feedback(Self::SELECTED_NOTE_NOT_FOUND_FEEDBACK, true);
+    }
+
+    pub(super) fn selected_note_for_action(
+        &mut self,
+        action: &'static str,
+    ) -> Option<(NoteId, &Note)> {
+        let selected_note = Self::resolve_selected_note(self.selected_note_id, &self.notes);
+        if selected_note.is_none() {
+            self.show_selected_note_missing_feedback(action);
+        }
+        selected_note
+    }
+
     /// Cycle sort mode: Updated → Created → Alphabetical → Updated
     pub(super) fn cycle_sort_mode(&mut self, cx: &mut Context<Self>) {
         self.sort_mode = match self.sort_mode {
@@ -86,42 +120,34 @@
         format!("scriptkit://notes/{}", id.as_str())
     }
 
-    pub(super) fn copy_note_as_markdown(&self) {
+    pub(super) fn copy_note_as_markdown(&mut self) {
         self.export_note(ExportFormat::Markdown);
     }
 
-    pub(super) fn copy_note_deeplink(&self) {
-        if let Some(id) = self.selected_note_id {
-            let deeplink = self.note_deeplink(id);
-            self.copy_text_to_clipboard(&deeplink);
-        }
+    pub(super) fn copy_note_deeplink(&mut self) {
+        let Some((id, _)) = self.selected_note_for_action("copy_note_deeplink") else {
+            return;
+        };
+        let deeplink = self.note_deeplink(id);
+        self.copy_text_to_clipboard(&deeplink);
     }
 
-    pub(super) fn create_note_quicklink(&self) {
-        if let Some(id) = self.selected_note_id {
-            let title = self
-                .notes
-                .iter()
-                .find(|note| note.id == id)
-                .map(|note| {
-                    if note.title.is_empty() {
-                        "Untitled Note".to_string()
-                    } else {
-                        note.title.clone()
-                    }
-                })
-                .unwrap_or_else(|| "Untitled Note".to_string());
-            let deeplink = self.note_deeplink(id);
-            let quicklink = format!("[{}]({})", title, deeplink);
-            self.copy_text_to_clipboard(&quicklink);
-        }
+    pub(super) fn create_note_quicklink(&mut self) {
+        let Some((id, note)) = self.selected_note_for_action("create_note_quicklink") else {
+            return;
+        };
+        let title = if note.title.is_empty() {
+            "Untitled Note".to_string()
+        } else {
+            note.title.clone()
+        };
+        let deeplink = self.note_deeplink(id);
+        let quicklink = format!("[{}]({})", title, deeplink);
+        self.copy_text_to_clipboard(&quicklink);
     }
 
     pub(super) fn duplicate_selected_note(&mut self, window: &mut Window, cx: &mut Context<Self>) {
-        let Some(id) = self.selected_note_id else {
-            return;
-        };
-        let Some(note) = self.notes.iter().find(|note| note.id == id) else {
+        let Some((_id, note)) = self.selected_note_for_action("duplicate_selected_note") else {
             return;
         };
 
diff --git a/src/notes/window/panels.rs b/src/notes/window/panels.rs
index 16b4b85b9be89780b4c9430f0db050a9af14532e..b843238a1e9103f6055702cf09dc506f1e99fa17
--- a/src/notes/window/panels.rs
+++ b/src/notes/window/panels.rs
@@ -281,6 +281,17 @@
                 self.select_note(note_id, window, cx);
                 return;
             }
+
+            tracing::warn!(
+                action_id,
+                note_id_str,
+                selected_note_id = ?self.selected_note_id,
+                notes_len = self.notes.len(),
+                "notes_note_switcher_selected_note_not_found",
+            );
+            self.show_selected_note_missing_feedback("execute_note_switcher_action");
+            self.close_browse_panel(window, cx);
+            return;
         }
 
         // Handle "no_notes" placeholder action
diff --git a/src/notes/window/tests.rs b/src/notes/window/tests.rs
index 8cb070d17ec066ba2b9e5a81de39cf1dfd19742b..441dc8b615019a2f05ba8f031d6bad5a449dd4a1
--- a/src/notes/window/tests.rs
+++ b/src/notes/window/tests.rs
@@ -1,4 +1,4 @@
-use super::NotesApp;
+use super::{Note, NoteId, NotesApp};
 
 #[test]
 fn formatting_replacement_wraps_selected_text() {
@@ -37,3 +37,31 @@
     assert_eq!(new_value, "he****llo");
     assert_eq!(new_selection, 4..4);
 }
+
+#[test]
+fn test_resolve_selected_note_returns_none_when_selection_is_missing() {
+    let notes = vec![Note::with_content("one"), Note::with_content("two")];
+
+    let selected = NotesApp::resolve_selected_note(None, &notes);
+
+    assert!(selected.is_none());
+}
+
+#[test]
+fn test_resolve_selected_note_returns_none_when_selection_is_stale() {
+    let notes = vec![Note::with_content("one"), Note::with_content("two")];
+
+    let selected = NotesApp::resolve_selected_note(Some(NoteId::new()), &notes);
+
+    assert!(selected.is_none());
+}
+
+#[test]
+fn test_resolve_selected_note_returns_note_when_selection_exists() {
+    let notes = vec![Note::with_content("one"), Note::with_content("two")];
+    let selected_id = notes[1].id;
+
+    let selected = NotesApp::resolve_selected_note(Some(selected_id), &notes);
+
+    assert_eq!(selected.map(|(id, note)| (id, note.id)), Some((selected_id, selected_id)));
+}


thinking
**Preparing to run cargo checks**
codex
The code changes are in place and compile-facing call paths are updated. I’m running targeted verification now: first the notes-window unit tests I added, then `cargo check` and `cargo clippy` scoped to this package.

thinking
**Planning sequential test commands**
exec
/bin/zsh -lc 'cargo test -p script-kit-gpui notes::window::tests -- --nocapture' in /Users/johnlindquist/dev/script-kit-gpuifile update:
diff --git a/src/notes/window/notes.rs b/src/notes/window/notes.rs
index 2b96e1be9f619ad7fa8b88d1287b653adb4780b4..449ab857a161bcb00618adf6e45ab022a3ac86fe
--- a/src/notes/window/notes.rs
+++ b/src/notes/window/notes.rs
@@ -231,42 +231,42 @@
     }
 
     /// Export the current note
-    pub(super) fn export_note(&self, format: ExportFormat) {
-        if let Some(id) = self.selected_note_id {
-            if let Some(note) = self.notes.iter().find(|n| n.id == id) {
-                let content = match format {
-                    ExportFormat::PlainText => note.content.clone(),
-                    // For Markdown, just export the content as-is.
-                    // The title is derived from the first line of content,
-                    // so prepending it would cause duplication.
-                    ExportFormat::Markdown => note.content.clone(),
-                    ExportFormat::Html => {
-                        // For HTML, we include proper structure with the title
-                        // and render the content as preformatted text
-                        format!(
-                            "<!DOCTYPE html>\n<html>\n<head><title>{}</title></head>\n<body>\n<h1>{}</h1>\n<pre>{}</pre>\n</body>\n</html>",
-                            note.title, note.title, note.content
-                        )
-                    }
-                };
+    pub(super) fn export_note(&mut self, format: ExportFormat) {
+        let Some((_id, note)) = self.selected_note_for_action("export_note") else {
+            return;
+        };
 
-                // Copy to clipboard
-                #[cfg(target_os = "macos")]
-                {
-                    use std::process::Command;
-                    let _ = Command::new("pbcopy")
-                        .stdin(std::process::Stdio::piped())
-                        .spawn()
-                        .and_then(|mut child| {
-                            use std::io::Write;
-                            if let Some(stdin) = child.stdin.as_mut() {
-                                stdin.write_all(content.as_bytes())?;
-                            }
-                            child.wait()
-                        });
-                    info!(format = ?format, "Note exported to clipboard");
-                }
+        let content = match format {
+            ExportFormat::PlainText => note.content.clone(),
+            // For Markdown, just export the content as-is.
+            // The title is derived from the first line of content,
+            // so prepending it would cause duplication.
+            ExportFormat::Markdown => note.content.clone(),
+            ExportFormat::Html => {
+                // For HTML, we include proper structure with the title
+                // and render the content as preformatted text
+                format!(
+                    "<!DOCTYPE html>\n<html>\n<head><title>{}</title></head>\n<body>\n<h1>{}</h1>\n<pre>{}</pre>\n</body>\n</html>",
+                    note.title, note.title, note.content
+                )
             }
+        };
+
+        // Copy to clipboard
+        #[cfg(target_os = "macos")]
+        {
+            use std::process::Command;
+            let _ = Command::new("pbcopy")
+                .stdin(std::process::Stdio::piped())
+                .spawn()
+                .and_then(|mut child| {
+                    use std::io::Write;
+                    if let Some(stdin) = child.stdin.as_mut() {
+                        stdin.write_all(content.as_bytes())?;
+                    }
+                    child.wait()
+                });
+            info!(format = ?format, "Note exported to clipboard");
         }
     }
 }
diff --git a/src/notes/window/notes_actions.rs b/src/notes/window/notes_actions.rs
index 6405519cffd92b2252b2e410eb3f58ee37800b8d..603be7a00cb2f2023699769b2b8b33c629a21238
--- a/src/notes/window/notes_actions.rs
+++ b/src/notes/window/notes_actions.rs
@@ -1,6 +1,40 @@
 use super::*;
 
 impl NotesApp {
+    const SELECTED_NOTE_NOT_FOUND_FEEDBACK: &'static str = "Selected note could not be found";
+
+    pub(super) fn resolve_selected_note(
+        selected_note_id: Option<NoteId>,
+        notes: &[Note],
+    ) -> Option<(NoteId, &Note)> {
+        let selected_note_id = selected_note_id?;
+        notes
+            .iter()
+            .find(|note| note.id == selected_note_id)
+            .map(|note| (selected_note_id, note))
+    }
+
+    pub(super) fn show_selected_note_missing_feedback(&mut self, action: &'static str) {
+        tracing::warn!(
+            action,
+            selected_note_id = ?self.selected_note_id,
+            notes_len = self.notes.len(),
+            "notes_action_selected_note_not_found",
+        );
+        self.show_action_feedback(Self::SELECTED_NOTE_NOT_FOUND_FEEDBACK, true);
+    }
+
+    pub(super) fn selected_note_for_action(
+        &mut self,
+        action: &'static str,
+    ) -> Option<(NoteId, &Note)> {
+        let selected_note = Self::resolve_selected_note(self.selected_note_id, &self.notes);
+        if selected_note.is_none() {
+            self.show_selected_note_missing_feedback(action);
+        }
+        selected_note
+    }
+
     /// Cycle sort mode: Updated → Created → Alphabetical → Updated
     pub(super) fn cycle_sort_mode(&mut self, cx: &mut Context<Self>) {
         self.sort_mode = match self.sort_mode {
@@ -86,42 +120,34 @@
         format!("scriptkit://notes/{}", id.as_str())
     }
 
-    pub(super) fn copy_note_as_markdown(&self) {
+    pub(super) fn copy_note_as_markdown(&mut self) {
         self.export_note(ExportFormat::Markdown);
     }
 
-    pub(super) fn copy_note_deeplink(&self) {
-        if let Some(id) = self.selected_note_id {
-            let deeplink = self.note_deeplink(id);
-            self.copy_text_to_clipboard(&deeplink);
-        }
+    pub(super) fn copy_note_deeplink(&mut self) {
+        let Some((id, _)) = self.selected_note_for_action("copy_note_deeplink") else {
+            return;
+        };
+        let deeplink = self.note_deeplink(id);
+        self.copy_text_to_clipboard(&deeplink);
     }
 
-    pub(super) fn create_note_quicklink(&self) {
-        if let Some(id) = self.selected_note_id {
-            let title = self
-                .notes
-                .iter()
-                .find(|note| note.id == id)
-                .map(|note| {
-                    if note.title.is_empty() {
-                        "Untitled Note".to_string()
-                    } else {
-                        note.title.clone()
-                    }
-                })
-                .unwrap_or_else(|| "Untitled Note".to_string());
-            let deeplink = self.note_deeplink(id);
-            let quicklink = format!("[{}]({})", title, deeplink);
-            self.copy_text_to_clipboard(&quicklink);
-        }
+    pub(super) fn create_note_quicklink(&mut self) {
+        let Some((id, note)) = self.selected_note_for_action("create_note_quicklink") else {
+            return;
+        };
+        let title = if note.title.is_empty() {
+            "Untitled Note".to_string()
+        } else {
+            note.title.clone()
+        };
+        let deeplink = self.note_deeplink(id);
+        let quicklink = format!("[{}]({})", title, deeplink);
+        self.copy_text_to_clipboard(&quicklink);
     }
 
     pub(super) fn duplicate_selected_note(&mut self, window: &mut Window, cx: &mut Context<Self>) {
-        let Some(id) = self.selected_note_id else {
-            return;
-        };
-        let Some(note) = self.notes.iter().find(|note| note.id == id) else {
+        let Some((_id, note)) = self.selected_note_for_action("duplicate_selected_note") else {
             return;
         };
 
diff --git a/src/notes/window/panels.rs b/src/notes/window/panels.rs
index 16b4b85b9be89780b4c9430f0db050a9af14532e..b843238a1e9103f6055702cf09dc506f1e99fa17
--- a/src/notes/window/panels.rs
+++ b/src/notes/window/panels.rs
@@ -281,6 +281,17 @@
                 self.select_note(note_id, window, cx);
                 return;
             }
+
+            tracing::warn!(
+                action_id,
+                note_id_str,
+                selected_note_id = ?self.selected_note_id,
+                notes_len = self.notes.len(),
+                "notes_note_switcher_selected_note_not_found",
+            );
+            self.show_selected_note_missing_feedback("execute_note_switcher_action");
+            self.close_browse_panel(window, cx);
+            return;
         }
 
         // Handle "no_notes" placeholder action
diff --git a/src/notes/window/tests.rs b/src/notes/window/tests.rs
index 8cb070d17ec066ba2b9e5a81de39cf1dfd19742b..441dc8b615019a2f05ba8f031d6bad5a449dd4a1
--- a/src/notes/window/tests.rs
+++ b/src/notes/window/tests.rs
@@ -1,4 +1,4 @@
-use super::NotesApp;
+use super::{Note, NoteId, NotesApp};
 
 #[test]
 fn formatting_replacement_wraps_selected_text() {
@@ -37,3 +37,31 @@
     assert_eq!(new_value, "he****llo");
     assert_eq!(new_selection, 4..4);
 }
+
+#[test]
+fn test_resolve_selected_note_returns_none_when_selection_is_missing() {
+    let notes = vec![Note::with_content("one"), Note::with_content("two")];
+
+    let selected = NotesApp::resolve_selected_note(None, &notes);
+
+    assert!(selected.is_none());
+}
+
+#[test]
+fn test_resolve_selected_note_returns_none_when_selection_is_stale() {
+    let notes = vec![Note::with_content("one"), Note::with_content("two")];
+
+    let selected = NotesApp::resolve_selected_note(Some(NoteId::new()), &notes);
+
+    assert!(selected.is_none());
+}
+
+#[test]
+fn test_resolve_selected_note_returns_note_when_selection_exists() {
+    let notes = vec![Note::with_content("one"), Note::with_content("two")];
+    let selected_id = notes[1].id;
+
+    let selected = NotesApp::resolve_selected_note(Some(selected_id), &notes);
+
+    assert_eq!(selected.map(|(id, note)| (id, note.id)), Some((selected_id, selected_id)));
+}


thinking
**Monitoring command completion**
file update:
diff --git a/src/notes/window/notes.rs b/src/notes/window/notes.rs
index 2b96e1be9f619ad7fa8b88d1287b653adb4780b4..449ab857a161bcb00618adf6e45ab022a3ac86fe
--- a/src/notes/window/notes.rs
+++ b/src/notes/window/notes.rs
@@ -231,42 +231,42 @@
     }
 
     /// Export the current note
-    pub(super) fn export_note(&self, format: ExportFormat) {
-        if let Some(id) = self.selected_note_id {
-            if let Some(note) = self.notes.iter().find(|n| n.id == id) {
-                let content = match format {
-                    ExportFormat::PlainText => note.content.clone(),
-                    // For Markdown, just export the content as-is.
-                    // The title is derived from the first line of content,
-                    // so prepending it would cause duplication.
-                    ExportFormat::Markdown => note.content.clone(),
-                    ExportFormat::Html => {
-                        // For HTML, we include proper structure with the title
-                        // and render the content as preformatted text
-                        format!(
-                            "<!DOCTYPE html>\n<html>\n<head><title>{}</title></head>\n<body>\n<h1>{}</h1>\n<pre>{}</pre>\n</body>\n</html>",
-                            note.title, note.title, note.content
-                        )
-                    }
-                };
+    pub(super) fn export_note(&mut self, format: ExportFormat) {
+        let Some((_id, note)) = self.selected_note_for_action("export_note") else {
+            return;
+        };
 
-                // Copy to clipboard
-                #[cfg(target_os = "macos")]
-                {
-                    use std::process::Command;
-                    let _ = Command::new("pbcopy")
-                        .stdin(std::process::Stdio::piped())
-                        .spawn()
-                        .and_then(|mut child| {
-                            use std::io::Write;
-                            if let Some(stdin) = child.stdin.as_mut() {
-                                stdin.write_all(content.as_bytes())?;
-                            }
-                            child.wait()
-                        });
-                    info!(format = ?format, "Note exported to clipboard");
-                }
+        let content = match format {
+            ExportFormat::PlainText => note.content.clone(),
+            // For Markdown, just export the content as-is.
+            // The title is derived from the first line of content,
+            // so prepending it would cause duplication.
+            ExportFormat::Markdown => note.content.clone(),
+            ExportFormat::Html => {
+                // For HTML, we include proper structure with the title
+                // and render the content as preformatted text
+                format!(
+                    "<!DOCTYPE html>\n<html>\n<head><title>{}</title></head>\n<body>\n<h1>{}</h1>\n<pre>{}</pre>\n</body>\n</html>",
+                    note.title, note.title, note.content
+                )
             }
+        };
+
+        // Copy to clipboard
+        #[cfg(target_os = "macos")]
+        {
+            use std::process::Command;
+            let _ = Command::new("pbcopy")
+                .stdin(std::process::Stdio::piped())
+                .spawn()
+                .and_then(|mut child| {
+                    use std::io::Write;
+                    if let Some(stdin) = child.stdin.as_mut() {
+                        stdin.write_all(content.as_bytes())?;
+                    }
+                    child.wait()
+                });
+            info!(format = ?format, "Note exported to clipboard");
         }
     }
 }
diff --git a/src/notes/window/notes_actions.rs b/src/notes/window/notes_actions.rs
index 6405519cffd92b2252b2e410eb3f58ee37800b8d..603be7a00cb2f2023699769b2b8b33c629a21238
--- a/src/notes/window/notes_actions.rs
+++ b/src/notes/window/notes_actions.rs
@@ -1,6 +1,40 @@
 use super::*;
 
 impl NotesApp {
+    const SELECTED_NOTE_NOT_FOUND_FEEDBACK: &'static str = "Selected note could not be found";
+
+    pub(super) fn resolve_selected_note(
+        selected_note_id: Option<NoteId>,
+        notes: &[Note],
+    ) -> Option<(NoteId, &Note)> {
+        let selected_note_id = selected_note_id?;
+        notes
+            .iter()
+            .find(|note| note.id == selected_note_id)
+            .map(|note| (selected_note_id, note))
+    }
+
+    pub(super) fn show_selected_note_missing_feedback(&mut self, action: &'static str) {
+        tracing::warn!(
+            action,
+            selected_note_id = ?self.selected_note_id,
+            notes_len = self.notes.len(),
+            "notes_action_selected_note_not_found",
+        );
+        self.show_action_feedback(Self::SELECTED_NOTE_NOT_FOUND_FEEDBACK, true);
+    }
+
+    pub(super) fn selected_note_for_action(
+        &mut self,
+        action: &'static str,
+    ) -> Option<(NoteId, &Note)> {
+        let selected_note = Self::resolve_selected_note(self.selected_note_id, &self.notes);
+        if selected_note.is_none() {
+            self.show_selected_note_missing_feedback(action);
+        }
+        selected_note
+    }
+
     /// Cycle sort mode: Updated → Created → Alphabetical → Updated
     pub(super) fn cycle_sort_mode(&mut self, cx: &mut Context<Self>) {
         self.sort_mode = match self.sort_mode {
@@ -86,42 +120,34 @@
         format!("scriptkit://notes/{}", id.as_str())
     }
 
-    pub(super) fn copy_note_as_markdown(&self) {
+    pub(super) fn copy_note_as_markdown(&mut self) {
         self.export_note(ExportFormat::Markdown);
     }
 
-    pub(super) fn copy_note_deeplink(&self) {
-        if let Some(id) = self.selected_note_id {
-            let deeplink = self.note_deeplink(id);
-            self.copy_text_to_clipboard(&deeplink);
-        }
+    pub(super) fn copy_note_deeplink(&mut self) {
+        let Some((id, _)) = self.selected_note_for_action("copy_note_deeplink") else {
+            return;
+        };
+        let deeplink = self.note_deeplink(id);
+        self.copy_text_to_clipboard(&deeplink);
     }
 
-    pub(super) fn create_note_quicklink(&self) {
-        if let Some(id) = self.selected_note_id {
-            let title = self
-                .notes
-                .iter()
-                .find(|note| note.id == id)
-                .map(|note| {
-                    if note.title.is_empty() {
-                        "Untitled Note".to_string()
-                    } else {
-                        note.title.clone()
-                    }
-                })
-                .unwrap_or_else(|| "Untitled Note".to_string());
-            let deeplink = self.note_deeplink(id);
-            let quicklink = format!("[{}]({})", title, deeplink);
-            self.copy_text_to_clipboard(&quicklink);
-        }
+    pub(super) fn create_note_quicklink(&mut self) {
+        let Some((id, note)) = self.selected_note_for_action("create_note_quicklink") else {
+            return;
+        };
+        let title = if note.title.is_empty() {
+            "Untitled Note".to_string()
+        } else {
+            note.title.clone()
+        };
+        let deeplink = self.note_deeplink(id);
+        let quicklink = format!("[{}]({})", title, deeplink);
+        self.copy_text_to_clipboard(&quicklink);
     }
 
     pub(super) fn duplicate_selected_note(&mut self, window: &mut Window, cx: &mut Context<Self>) {
-        let Some(id) = self.selected_note_id else {
-            return;
-        };
-        let Some(note) = self.notes.iter().find(|note| note.id == id) else {
+        let Some((_id, note)) = self.selected_note_for_action("duplicate_selected_note") else {
             return;
         };
 
diff --git a/src/notes/window/panels.rs b/src/notes/window/panels.rs
index 16b4b85b9be89780b4c9430f0db050a9af14532e..b843238a1e9103f6055702cf09dc506f1e99fa17
--- a/src/notes/window/panels.rs
+++ b/src/notes/window/panels.rs
@@ -281,6 +281,17 @@
                 self.select_note(note_id, window, cx);
                 return;
             }
+
+            tracing::warn!(
+                action_id,
+                note_id_str,
+                selected_note_id = ?self.selected_note_id,
+                notes_len = self.notes.len(),
+                "notes_note_switcher_selected_note_not_found",
+            );
+            self.show_selected_note_missing_feedback("execute_note_switcher_action");
+            self.close_browse_panel(window, cx);
+            return;
         }
 
         // Handle "no_notes" placeholder action
diff --git a/src/notes/window/tests.rs b/src/notes/window/tests.rs
index 8cb070d17ec066ba2b9e5a81de39cf1dfd19742b..441dc8b615019a2f05ba8f031d6bad5a449dd4a1
--- a/src/notes/window/tests.rs
+++ b/src/notes/window/tests.rs
@@ -1,4 +1,4 @@
-use super::NotesApp;
+use super::{Note, NoteId, NotesApp};
 
 #[test]
 fn formatting_replacement_wraps_selected_text() {
@@ -37,3 +37,31 @@
     assert_eq!(new_value, "he****llo");
     assert_eq!(new_selection, 4..4);
 }
+
+#[test]
+fn test_resolve_selected_note_returns_none_when_selection_is_missing() {
+    let notes = vec![Note::with_content("one"), Note::with_content("two")];
+
+    let selected = NotesApp::resolve_selected_note(None, &notes);
+
+    assert!(selected.is_none());
+}
+
+#[test]
+fn test_resolve_selected_note_returns_none_when_selection_is_stale() {
+    let notes = vec![Note::with_content("one"), Note::with_content("two")];
+
+    let selected = NotesApp::resolve_selected_note(Some(NoteId::new()), &notes);
+
+    assert!(selected.is_none());
+}
+
+#[test]
+fn test_resolve_selected_note_returns_note_when_selection_exists() {
+    let notes = vec![Note::with_content("one"), Note::with_content("two")];
+    let selected_id = notes[1].id;
+
+    let selected = NotesApp::resolve_selected_note(Some(selected_id), &notes);
+
+    assert_eq!(selected.map(|(id, note)| (id, note.id)), Some((selected_id, selected_id)));
+}


thinking
**Noticing lingering process**
file update:
diff --git a/src/notes/window/notes.rs b/src/notes/window/notes.rs
index 2b96e1be9f619ad7fa8b88d1287b653adb4780b4..449ab857a161bcb00618adf6e45ab022a3ac86fe
--- a/src/notes/window/notes.rs
+++ b/src/notes/window/notes.rs
@@ -231,42 +231,42 @@
     }
 
     /// Export the current note
-    pub(super) fn export_note(&self, format: ExportFormat) {
-        if let Some(id) = self.selected_note_id {
-            if let Some(note) = self.notes.iter().find(|n| n.id == id) {
-                let content = match format {
-                    ExportFormat::PlainText => note.content.clone(),
-                    // For Markdown, just export the content as-is.
-                    // The title is derived from the first line of content,
-                    // so prepending it would cause duplication.
-                    ExportFormat::Markdown => note.content.clone(),
-                    ExportFormat::Html => {
-                        // For HTML, we include proper structure with the title
-                        // and render the content as preformatted text
-                        format!(
-                            "<!DOCTYPE html>\n<html>\n<head><title>{}</title></head>\n<body>\n<h1>{}</h1>\n<pre>{}</pre>\n</body>\n</html>",
-                            note.title, note.title, note.content
-                        )
-                    }
-                };
+    pub(super) fn export_note(&mut self, format: ExportFormat) {
+        let Some((_id, note)) = self.selected_note_for_action("export_note") else {
+            return;
+        };
 
-                // Copy to clipboard
-                #[cfg(target_os = "macos")]
-                {
-                    use std::process::Command;
-                    let _ = Command::new("pbcopy")
-                        .stdin(std::process::Stdio::piped())
-                        .spawn()
-                        .and_then(|mut child| {
-                            use std::io::Write;
-                            if let Some(stdin) = child.stdin.as_mut() {
-                                stdin.write_all(content.as_bytes())?;
-                            }
-                            child.wait()
-                        });
-                    info!(format = ?format, "Note exported to clipboard");
-                }
+        let content = match format {
+            ExportFormat::PlainText => note.content.clone(),
+            // For Markdown, just export the content as-is.
+            // The title is derived from the first line of content,
+            // so prepending it would cause duplication.
+            ExportFormat::Markdown => note.content.clone(),
+            ExportFormat::Html => {
+                // For HTML, we include proper structure with the title
+                // and render the content as preformatted text
+                format!(
+                    "<!DOCTYPE html>\n<html>\n<head><title>{}</title></head>\n<body>\n<h1>{}</h1>\n<pre>{}</pre>\n</body>\n</html>",
+                    note.title, note.title, note.content
+                )
             }
+        };
+
+        // Copy to clipboard
+        #[cfg(target_os = "macos")]
+        {
+            use std::process::Command;
+            let _ = Command::new("pbcopy")
+                .stdin(std::process::Stdio::piped())
+                .spawn()
+                .and_then(|mut child| {
+                    use std::io::Write;
+                    if let Some(stdin) = child.stdin.as_mut() {
+                        stdin.write_all(content.as_bytes())?;
+                    }
+                    child.wait()
+                });
+            info!(format = ?format, "Note exported to clipboard");
         }
     }
 }
diff --git a/src/notes/window/notes_actions.rs b/src/notes/window/notes_actions.rs
index 6405519cffd92b2252b2e410eb3f58ee37800b8d..603be7a00cb2f2023699769b2b8b33c629a21238
--- a/src/notes/window/notes_actions.rs
+++ b/src/notes/window/notes_actions.rs
@@ -1,6 +1,40 @@
 use super::*;
 
 impl NotesApp {
+    const SELECTED_NOTE_NOT_FOUND_FEEDBACK: &'static str = "Selected note could not be found";
+
+    pub(super) fn resolve_selected_note(
+        selected_note_id: Option<NoteId>,
+        notes: &[Note],
+    ) -> Option<(NoteId, &Note)> {
+        let selected_note_id = selected_note_id?;
+        notes
+            .iter()
+            .find(|note| note.id == selected_note_id)
+            .map(|note| (selected_note_id, note))
+    }
+
+    pub(super) fn show_selected_note_missing_feedback(&mut self, action: &'static str) {
+        tracing::warn!(
+            action,
+            selected_note_id = ?self.selected_note_id,
+            notes_len = self.notes.len(),
+            "notes_action_selected_note_not_found",
+        );
+        self.show_action_feedback(Self::SELECTED_NOTE_NOT_FOUND_FEEDBACK, true);
+    }
+
+    pub(super) fn selected_note_for_action(
+        &mut self,
+        action: &'static str,
+    ) -> Option<(NoteId, &Note)> {
+        let selected_note = Self::resolve_selected_note(self.selected_note_id, &self.notes);
+        if selected_note.is_none() {
+            self.show_selected_note_missing_feedback(action);
+        }
+        selected_note
+    }
+
     /// Cycle sort mode: Updated → Created → Alphabetical → Updated
     pub(super) fn cycle_sort_mode(&mut self, cx: &mut Context<Self>) {
         self.sort_mode = match self.sort_mode {
@@ -86,42 +120,34 @@
         format!("scriptkit://notes/{}", id.as_str())
     }
 
-    pub(super) fn copy_note_as_markdown(&self) {
+    pub(super) fn copy_note_as_markdown(&mut self) {
         self.export_note(ExportFormat::Markdown);
     }
 
-    pub(super) fn copy_note_deeplink(&self) {
-        if let Some(id) = self.selected_note_id {
-            let deeplink = self.note_deeplink(id);
-            self.copy_text_to_clipboard(&deeplink);
-        }
+    pub(super) fn copy_note_deeplink(&mut self) {
+        let Some((id, _)) = self.selected_note_for_action("copy_note_deeplink") else {
+            return;
+        };
+        let deeplink = self.note_deeplink(id);
+        self.copy_text_to_clipboard(&deeplink);
     }
 
-    pub(super) fn create_note_quicklink(&self) {
-        if let Some(id) = self.selected_note_id {
-            let title = self
-                .notes
-                .iter()
-                .find(|note| note.id == id)
-                .map(|note| {
-                    if note.title.is_empty() {
-                        "Untitled Note".to_string()
-                    } else {
-                        note.title.clone()
-                    }
-                })
-                .unwrap_or_else(|| "Untitled Note".to_string());
-            let deeplink = self.note_deeplink(id);
-            let quicklink = format!("[{}]({})", title, deeplink);
-            self.copy_text_to_clipboard(&quicklink);
-        }
+    pub(super) fn create_note_quicklink(&mut self) {
+        let Some((id, note)) = self.selected_note_for_action("create_note_quicklink") else {
+            return;
+        };
+        let title = if note.title.is_empty() {
+            "Untitled Note".to_string()
+        } else {
+            note.title.clone()
+        };
+        let deeplink = self.note_deeplink(id);
+        let quicklink = format!("[{}]({})", title, deeplink);
+        self.copy_text_to_clipboard(&quicklink);
     }
 
     pub(super) fn duplicate_selected_note(&mut self, window: &mut Window, cx: &mut Context<Self>) {
-        let Some(id) = self.selected_note_id else {
-            return;
-        };
-        let Some(note) = self.notes.iter().find(|note| note.id == id) else {
+        let Some((_id, note)) = self.selected_note_for_action("duplicate_selected_note") else {
             return;
         };
 
diff --git a/src/notes/window/panels.rs b/src/notes/window/panels.rs
index 16b4b85b9be89780b4c9430f0db050a9af14532e..b843238a1e9103f6055702cf09dc506f1e99fa17
--- a/src/notes/window/panels.rs
+++ b/src/notes/window/panels.rs
@@ -281,6 +281,17 @@
                 self.select_note(note_id, window, cx);
                 return;
             }
+
+            tracing::warn!(
+                action_id,
+                note_id_str,
+                selected_note_id = ?self.selected_note_id,
+                notes_len = self.notes.len(),
+                "notes_note_switcher_selected_note_not_found",
+            );
+            self.show_selected_note_missing_feedback("execute_note_switcher_action");
+            self.close_browse_panel(window, cx);
+            return;
         }
 
         // Handle "no_notes" placeholder action
diff --git a/src/notes/window/tests.rs b/src/notes/window/tests.rs
index 8cb070d17ec066ba2b9e5a81de39cf1dfd19742b..441dc8b615019a2f05ba8f031d6bad5a449dd4a1
--- a/src/notes/window/tests.rs
+++ b/src/notes/window/tests.rs
@@ -1,4 +1,4 @@
-use super::NotesApp;
+use super::{Note, NoteId, NotesApp};
 
 #[test]
 fn formatting_replacement_wraps_selected_text() {
@@ -37,3 +37,31 @@
     assert_eq!(new_value, "he****llo");
     assert_eq!(new_selection, 4..4);
 }
+
+#[test]
+fn test_resolve_selected_note_returns_none_when_selection_is_missing() {
+    let notes = vec![Note::with_content("one"), Note::with_content("two")];
+
+    let selected = NotesApp::resolve_selected_note(None, &notes);
+
+    assert!(selected.is_none());
+}
+
+#[test]
+fn test_resolve_selected_note_returns_none_when_selection_is_stale() {
+    let notes = vec![Note::with_content("one"), Note::with_content("two")];
+
+    let selected = NotesApp::resolve_selected_note(Some(NoteId::new()), &notes);
+
+    assert!(selected.is_none());
+}
+
+#[test]
+fn test_resolve_selected_note_returns_note_when_selection_exists() {
+    let notes = vec![Note::with_content("one"), Note::with_content("two")];
+    let selected_id = notes[1].id;
+
+    let selected = NotesApp::resolve_selected_note(Some(selected_id), &notes);
+
+    assert_eq!(selected.map(|(id, note)| (id, note.id)), Some((selected_id, selected_id)));
+}

file update:
diff --git a/src/notes/window/notes.rs b/src/notes/window/notes.rs
index 2b96e1be9f619ad7fa8b88d1287b653adb4780b4..449ab857a161bcb00618adf6e45ab022a3ac86fe
--- a/src/notes/window/notes.rs
+++ b/src/notes/window/notes.rs
@@ -231,42 +231,42 @@
     }
 
     /// Export the current note
-    pub(super) fn export_note(&self, format: ExportFormat) {
-        if let Some(id) = self.selected_note_id {
-            if let Some(note) = self.notes.iter().find(|n| n.id == id) {
-                let content = match format {
-                    ExportFormat::PlainText => note.content.clone(),
-                    // For Markdown, just export the content as-is.
-                    // The title is derived from the first line of content,
-                    // so prepending it would cause duplication.
-                    ExportFormat::Markdown => note.content.clone(),
-                    ExportFormat::Html => {
-                        // For HTML, we include proper structure with the title
-                        // and render the content as preformatted text
-                        format!(
-                            "<!DOCTYPE html>\n<html>\n<head><title>{}</title></head>\n<body>\n<h1>{}</h1>\n<pre>{}</pre>\n</body>\n</html>",
-                            note.title, note.title, note.content
-                        )
-                    }
-                };
+    pub(super) fn export_note(&mut self, format: ExportFormat) {
+        let Some((_id, note)) = self.selected_note_for_action("export_note") else {
+            return;
+        };
 
-                // Copy to clipboard
-                #[cfg(target_os = "macos")]
-                {
-                    use std::process::Command;
-                    let _ = Command::new("pbcopy")
-                        .stdin(std::process::Stdio::piped())
-                        .spawn()
-                        .and_then(|mut child| {
-                            use std::io::Write;
-                            if let Some(stdin) = child.stdin.as_mut() {
-                                stdin.write_all(content.as_bytes())?;
-                            }
-                            child.wait()
-                        });
-                    info!(format = ?format, "Note exported to clipboard");
-                }
+        let content = match format {
+            ExportFormat::PlainText => note.content.clone(),
+            // For Markdown, just export the content as-is.
+            // The title is derived from the first line of content,
+            // so prepending it would cause duplication.
+            ExportFormat::Markdown => note.content.clone(),
+            ExportFormat::Html => {
+                // For HTML, we include proper structure with the title
+                // and render the content as preformatted text
+                format!(
+                    "<!DOCTYPE html>\n<html>\n<head><title>{}</title></head>\n<body>\n<h1>{}</h1>\n<pre>{}</pre>\n</body>\n</html>",
+                    note.title, note.title, note.content
+                )
             }
+        };
+
+        // Copy to clipboard
+        #[cfg(target_os = "macos")]
+        {
+            use std::process::Command;
+            let _ = Command::new("pbcopy")
+                .stdin(std::process::Stdio::piped())
+                .spawn()
+                .and_then(|mut child| {
+                    use std::io::Write;
+                    if let Some(stdin) = child.stdin.as_mut() {
+                        stdin.write_all(content.as_bytes())?;
+                    }
+                    child.wait()
+                });
+            info!(format = ?format, "Note exported to clipboard");
         }
     }
 }
diff --git a/src/notes/window/notes_actions.rs b/src/notes/window/notes_actions.rs
index 6405519cffd92b2252b2e410eb3f58ee37800b8d..603be7a00cb2f2023699769b2b8b33c629a21238
--- a/src/notes/window/notes_actions.rs
+++ b/src/notes/window/notes_actions.rs
@@ -1,6 +1,40 @@
 use super::*;
 
 impl NotesApp {
+    const SELECTED_NOTE_NOT_FOUND_FEEDBACK: &'static str = "Selected note could not be found";
+
+    pub(super) fn resolve_selected_note(
+        selected_note_id: Option<NoteId>,
+        notes: &[Note],
+    ) -> Option<(NoteId, &Note)> {
+        let selected_note_id = selected_note_id?;
+        notes
+            .iter()
+            .find(|note| note.id == selected_note_id)
+            .map(|note| (selected_note_id, note))
+    }
+
+    pub(super) fn show_selected_note_missing_feedback(&mut self, action: &'static str) {
+        tracing::warn!(
+            action,
+            selected_note_id = ?self.selected_note_id,
+            notes_len = self.notes.len(),
+            "notes_action_selected_note_not_found",
+        );
+        self.show_action_feedback(Self::SELECTED_NOTE_NOT_FOUND_FEEDBACK, true);
+    }
+
+    pub(super) fn selected_note_for_action(
+        &mut self,
+        action: &'static str,
+    ) -> Option<(NoteId, &Note)> {
+        let selected_note = Self::resolve_selected_note(self.selected_note_id, &self.notes);
+        if selected_note.is_none() {
+            self.show_selected_note_missing_feedback(action);
+        }
+        selected_note
+    }
+
     /// Cycle sort mode: Updated → Created → Alphabetical → Updated
     pub(super) fn cycle_sort_mode(&mut self, cx: &mut Context<Self>) {
         self.sort_mode = match self.sort_mode {
@@ -86,42 +120,34 @@
         format!("scriptkit://notes/{}", id.as_str())
     }
 
-    pub(super) fn copy_note_as_markdown(&self) {
+    pub(super) fn copy_note_as_markdown(&mut self) {
         self.export_note(ExportFormat::Markdown);
     }
 
-    pub(super) fn copy_note_deeplink(&self) {
-        if let Some(id) = self.selected_note_id {
-            let deeplink = self.note_deeplink(id);
-            self.copy_text_to_clipboard(&deeplink);
-        }
+    pub(super) fn copy_note_deeplink(&mut self) {
+        let Some((id, _)) = self.selected_note_for_action("copy_note_deeplink") else {
+            return;
+        };
+        let deeplink = self.note_deeplink(id);
+        self.copy_text_to_clipboard(&deeplink);
     }
 
-    pub(super) fn create_note_quicklink(&self) {
-        if let Some(id) = self.selected_note_id {
-            let title = self
-                .notes
-                .iter()
-                .find(|note| note.id == id)
-                .map(|note| {
-                    if note.title.is_empty() {
-                        "Untitled Note".to_string()
-                    } else {
-                        note.title.clone()
-                    }
-                })
-                .unwrap_or_else(|| "Untitled Note".to_string());
-            let deeplink = self.note_deeplink(id);
-            let quicklink = format!("[{}]({})", title, deeplink);
-            self.copy_text_to_clipboard(&quicklink);
-        }
+    pub(super) fn create_note_quicklink(&mut self) {
+        let Some((id, note)) = self.selected_note_for_action("create_note_quicklink") else {
+            return;
+        };
+        let title = if note.title.is_empty() {
+            "Untitled Note".to_string()
+        } else {
+            note.title.clone()
+        };
+        let deeplink = self.note_deeplink(id);
+        let quicklink = format!("[{}]({})", title, deeplink);
+        self.copy_text_to_clipboard(&quicklink);
     }
 
     pub(super) fn duplicate_selected_note(&mut self, window: &mut Window, cx: &mut Context<Self>) {
-        let Some(id) = self.selected_note_id else {
-            return;
-        };
-        let Some(note) = self.notes.iter().find(|note| note.id == id) else {
+        let Some((_id, note)) = self.selected_note_for_action("duplicate_selected_note") else {
             return;
         };
 
diff --git a/src/notes/window/panels.rs b/src/notes/window/panels.rs
index 16b4b85b9be89780b4c9430f0db050a9af14532e..b843238a1e9103f6055702cf09dc506f1e99fa17
--- a/src/notes/window/panels.rs
+++ b/src/notes/window/panels.rs
@@ -281,6 +281,17 @@
                 self.select_note(note_id, window, cx);
                 return;
             }
+
+            tracing::warn!(
+                action_id,
+                note_id_str,
+                selected_note_id = ?self.selected_note_id,
+                notes_len = self.notes.len(),
+                "notes_note_switcher_selected_note_not_found",
+            );
+            self.show_selected_note_missing_feedback("execute_note_switcher_action");
+            self.close_browse_panel(window, cx);
+            return;
         }
 
         // Handle "no_notes" placeholder action
diff --git a/src/notes/window/tests.rs b/src/notes/window/tests.rs
index 8cb070d17ec066ba2b9e5a81de39cf1dfd19742b..441dc8b615019a2f05ba8f031d6bad5a449dd4a1
--- a/src/notes/window/tests.rs
+++ b/src/notes/window/tests.rs
@@ -1,4 +1,4 @@
-use super::NotesApp;
+use super::{Note, NoteId, NotesApp};
 
 #[test]
 fn formatting_replacement_wraps_selected_text() {
@@ -37,3 +37,31 @@
     assert_eq!(new_value, "he****llo");
     assert_eq!(new_selection, 4..4);
 }
+
+#[test]
+fn test_resolve_selected_note_returns_none_when_selection_is_missing() {
+    let notes = vec![Note::with_content("one"), Note::with_content("two")];
+
+    let selected = NotesApp::resolve_selected_note(None, &notes);
+
+    assert!(selected.is_none());
+}
+
+#[test]
+fn test_resolve_selected_note_returns_none_when_selection_is_stale() {
+    let notes = vec![Note::with_content("one"), Note::with_content("two")];
+
+    let selected = NotesApp::resolve_selected_note(Some(NoteId::new()), &notes);
+
+    assert!(selected.is_none());
+}
+
+#[test]
+fn test_resolve_selected_note_returns_note_when_selection_exists() {
+    let notes = vec![Note::with_content("one"), Note::with_content("two")];
+    let selected_id = notes[1].id;
+
+    let selected = NotesApp::resolve_selected_note(Some(selected_id), &notes);
+
+    assert_eq!(selected.map(|(id, note)| (id, note.id)), Some((selected_id, selected_id)));
+}

 exited 101 in 18.94s:
   Compiling script-kit-gpui v0.1.0 (/Users/johnlindquist/dev/script-kit-gpui)
error[E0761]: file for module `tests` found at both "src/protocol/message/tests.rs" and "src/protocol/message/tests/mod.rs"
  --> src/protocol/message/mod.rs:87:1
   |
87 | mod tests;
   | ^^^^^^^^^^
   |
   = help: delete or rename one of them to remove the ambiguity

error[E0761]: file for module `tests` found at both "src/designs/core/tests.rs" and "src/designs/core/tests/mod.rs"
 --> src/designs/core/part_04.rs:2:1
  |
2 | mod tests;
  | ^^^^^^^^^^
  |
  = help: delete or rename one of them to remove the ambiguity

warning: glob import doesn't reexport anything with visibility `pub(in crate::prompts)` because no imported item is public enough
  --> src/prompts/div/mod.rs:32:16
   |

thinking
**Assessing test run feasibility amid errors**
exec
/bin/zsh -lc 'cargo check -p script-kit-gpui' in /Users/johnlindquist/dev/script-kit-gpuifile update:
diff --git a/src/notes/window/notes.rs b/src/notes/window/notes.rs
index 2b96e1be9f619ad7fa8b88d1287b653adb4780b4..449ab857a161bcb00618adf6e45ab022a3ac86fe
--- a/src/notes/window/notes.rs
+++ b/src/notes/window/notes.rs
@@ -231,42 +231,42 @@
     }
 
     /// Export the current note
-    pub(super) fn export_note(&self, format: ExportFormat) {
-        if let Some(id) = self.selected_note_id {
-            if let Some(note) = self.notes.iter().find(|n| n.id == id) {
-                let content = match format {
-                    ExportFormat::PlainText => note.content.clone(),
-                    // For Markdown, just export the content as-is.
-                    // The title is derived from the first line of content,
-                    // so prepending it would cause duplication.
-                    ExportFormat::Markdown => note.content.clone(),
-                    ExportFormat::Html => {
-                        // For HTML, we include proper structure with the title
-                        // and render the content as preformatted text
-                        format!(
-                            "<!DOCTYPE html>\n<html>\n<head><title>{}</title></head>\n<body>\n<h1>{}</h1>\n<pre>{}</pre>\n</body>\n</html>",
-                            note.title, note.title, note.content
-                        )
-                    }
-                };
+    pub(super) fn export_note(&mut self, format: ExportFormat) {
+        let Some((_id, note)) = self.selected_note_for_action("export_note") else {
+            return;
+        };
 
-                // Copy to clipboard
-                #[cfg(target_os = "macos")]
-                {
-                    use std::process::Command;
-                    let _ = Command::new("pbcopy")
-                        .stdin(std::process::Stdio::piped())
-                        .spawn()
-                        .and_then(|mut child| {
-                            use std::io::Write;
-                            if let Some(stdin) = child.stdin.as_mut() {
-                                stdin.write_all(content.as_bytes())?;
-                            }
-                            child.wait()
-                        });
-                    info!(format = ?format, "Note exported to clipboard");
-                }
+        let content = match format {
+            ExportFormat::PlainText => note.content.clone(),
+            // For Markdown, just export the content as-is.
+            // The title is derived from the first line of content,
+            // so prepending it would cause duplication.
+            ExportFormat::Markdown => note.content.clone(),
+            ExportFormat::Html => {
+                // For HTML, we include proper structure with the title
+                // and render the content as preformatted text
+                format!(
+                    "<!DOCTYPE html>\n<html>\n<head><title>{}</title></head>\n<body>\n<h1>{}</h1>\n<pre>{}</pre>\n</body>\n</html>",
+                    note.title, note.title, note.content
+                )
             }
+        };
+
+        // Copy to clipboard
+        #[cfg(target_os = "macos")]
+        {
+            use std::process::Command;
+            let _ = Command::new("pbcopy")
+                .stdin(std::process::Stdio::piped())
+                .spawn()
+                .and_then(|mut child| {
+                    use std::io::Write;
+                    if let Some(stdin) = child.stdin.as_mut() {
+                        stdin.write_all(content.as_bytes())?;
+                    }
+                    child.wait()
+                });
+            info!(format = ?format, "Note exported to clipboard");
         }
     }
 }
diff --git a/src/notes/window/notes_actions.rs b/src/notes/window/notes_actions.rs
index 6405519cffd92b2252b2e410eb3f58ee37800b8d..603be7a00cb2f2023699769b2b8b33c629a21238
--- a/src/notes/window/notes_actions.rs
+++ b/src/notes/window/notes_actions.rs
@@ -1,6 +1,40 @@
 use super::*;
 
 impl NotesApp {
+    const SELECTED_NOTE_NOT_FOUND_FEEDBACK: &'static str = "Selected note could not be found";
+
+    pub(super) fn resolve_selected_note(
+        selected_note_id: Option<NoteId>,
+        notes: &[Note],
+    ) -> Option<(NoteId, &Note)> {
+        let selected_note_id = selected_note_id?;
+        notes
+            .iter()
+            .find(|note| note.id == selected_note_id)
+            .map(|note| (selected_note_id, note))
+    }
+
+    pub(super) fn show_selected_note_missing_feedback(&mut self, action: &'static str) {
+        tracing::warn!(
+            action,
+            selected_note_id = ?self.selected_note_id,
+            notes_len = self.notes.len(),
+            "notes_action_selected_note_not_found",
+        );
+        self.show_action_feedback(Self::SELECTED_NOTE_NOT_FOUND_FEEDBACK, true);
+    }
+
+    pub(super) fn selected_note_for_action(
+        &mut self,
+        action: &'static str,
+    ) -> Option<(NoteId, &Note)> {
+        let selected_note = Self::resolve_selected_note(self.selected_note_id, &self.notes);
+        if selected_note.is_none() {
+            self.show_selected_note_missing_feedback(action);
+        }
+        selected_note
+    }
+
     /// Cycle sort mode: Updated → Created → Alphabetical → Updated
     pub(super) fn cycle_sort_mode(&mut self, cx: &mut Context<Self>) {
         self.sort_mode = match self.sort_mode {
@@ -86,42 +120,34 @@
         format!("scriptkit://notes/{}", id.as_str())
     }
 
-    pub(super) fn copy_note_as_markdown(&self) {
+    pub(super) fn copy_note_as_markdown(&mut self) {
         self.export_note(ExportFormat::Markdown);
     }
 
-    pub(super) fn copy_note_deeplink(&self) {
-        if let Some(id) = self.selected_note_id {
-            let deeplink = self.note_deeplink(id);
-            self.copy_text_to_clipboard(&deeplink);
-        }
+    pub(super) fn copy_note_deeplink(&mut self) {
+        let Some((id, _)) = self.selected_note_for_action("copy_note_deeplink") else {
+            return;
+        };
+        let deeplink = self.note_deeplink(id);
+        self.copy_text_to_clipboard(&deeplink);
     }
 
-    pub(super) fn create_note_quicklink(&self) {
-        if let Some(id) = self.selected_note_id {
-            let title = self
-                .notes
-                .iter()
-                .find(|note| note.id == id)
-                .map(|note| {
-                    if note.title.is_empty() {
-                        "Untitled Note".to_string()
-                    } else {
-                        note.title.clone()
-                    }
-                })
-                .unwrap_or_else(|| "Untitled Note".to_string());
-            let deeplink = self.note_deeplink(id);
-            let quicklink = format!("[{}]({})", title, deeplink);
-            self.copy_text_to_clipboard(&quicklink);
-        }
+    pub(super) fn create_note_quicklink(&mut self) {
+        let Some((id, note)) = self.selected_note_for_action("create_note_quicklink") else {
+            return;
+        };
+        let title = if note.title.is_empty() {
+            "Untitled Note".to_string()
+        } else {
+            note.title.clone()
+        };
+        let deeplink = self.note_deeplink(id);
+        let quicklink = format!("[{}]({})", title, deeplink);
+        self.copy_text_to_clipboard(&quicklink);
     }
 
     pub(super) fn duplicate_selected_note(&mut self, window: &mut Window, cx: &mut Context<Self>) {
-        let Some(id) = self.selected_note_id else {
-            return;
-        };
-        let Some(note) = self.notes.iter().find(|note| note.id == id) else {
+        let Some((_id, note)) = self.selected_note_for_action("duplicate_selected_note") else {
             return;
         };
 
diff --git a/src/notes/window/panels.rs b/src/notes/window/panels.rs
index 16b4b85b9be89780b4c9430f0db050a9af14532e..b843238a1e9103f6055702cf09dc506f1e99fa17
--- a/src/notes/window/panels.rs
+++ b/src/notes/window/panels.rs
@@ -281,6 +281,17 @@
                 self.select_note(note_id, window, cx);
                 return;
             }
+
+            tracing::warn!(
+                action_id,
+                note_id_str,
+                selected_note_id = ?self.selected_note_id,
+                notes_len = self.notes.len(),
+                "notes_note_switcher_selected_note_not_found",
+            );
+            self.show_selected_note_missing_feedback("execute_note_switcher_action");
+            self.close_browse_panel(window, cx);
+            return;
         }
 
         // Handle "no_notes" placeholder action
diff --git a/src/notes/window/tests.rs b/src/notes/window/tests.rs
index 8cb070d17ec066ba2b9e5a81de39cf1dfd19742b..441dc8b615019a2f05ba8f031d6bad5a449dd4a1
--- a/src/notes/window/tests.rs
+++ b/src/notes/window/tests.rs
@@ -1,4 +1,4 @@
-use super::NotesApp;
+use super::{Note, NoteId, NotesApp};
 
 #[test]
 fn formatting_replacement_wraps_selected_text() {
@@ -37,3 +37,31 @@
     assert_eq!(new_value, "he****llo");
     assert_eq!(new_selection, 4..4);
 }
+
+#[test]
+fn test_resolve_selected_note_returns_none_when_selection_is_missing() {
+    let notes = vec![Note::with_content("one"), Note::with_content("two")];
+
+    let selected = NotesApp::resolve_selected_note(None, &notes);
+
+    assert!(selected.is_none());
+}
+
+#[test]
+fn test_resolve_selected_note_returns_none_when_selection_is_stale() {
+    let notes = vec![Note::with_content("one"), Note::with_content("two")];
+
+    let selected = NotesApp::resolve_selected_note(Some(NoteId::new()), &notes);
+
+    assert!(selected.is_none());
+}
+
+#[test]
+fn test_resolve_selected_note_returns_note_when_selection_exists() {
+    let notes = vec![Note::with_content("one"), Note::with_content("two")];
+    let selected_id = notes[1].id;
+
+    let selected = NotesApp::resolve_selected_note(Some(selected_id), &notes);
+
+    assert_eq!(selected.map(|(id, note)| (id, note.id)), Some((selected_id, selected_id)));
+}


thinking
**Identifying need for polling session**
file update:
diff --git a/src/notes/window/notes.rs b/src/notes/window/notes.rs
index 2b96e1be9f619ad7fa8b88d1287b653adb4780b4..449ab857a161bcb00618adf6e45ab022a3ac86fe
--- a/src/notes/window/notes.rs
+++ b/src/notes/window/notes.rs
@@ -231,42 +231,42 @@
     }
 
     /// Export the current note
-    pub(super) fn export_note(&self, format: ExportFormat) {
-        if let Some(id) = self.selected_note_id {
-            if let Some(note) = self.notes.iter().find(|n| n.id == id) {
-                let content = match format {
-                    ExportFormat::PlainText => note.content.clone(),
-                    // For Markdown, just export the content as-is.
-                    // The title is derived from the first line of content,
-                    // so prepending it would cause duplication.
-                    ExportFormat::Markdown => note.content.clone(),
-                    ExportFormat::Html => {
-                        // For HTML, we include proper structure with the title
-                        // and render the content as preformatted text
-                        format!(
-                            "<!DOCTYPE html>\n<html>\n<head><title>{}</title></head>\n<body>\n<h1>{}</h1>\n<pre>{}</pre>\n</body>\n</html>",
-                            note.title, note.title, note.content
-                        )
-                    }
-                };
+    pub(super) fn export_note(&mut self, format: ExportFormat) {
+        let Some((_id, note)) = self.selected_note_for_action("export_note") else {
+            return;
+        };
 
-                // Copy to clipboard
-                #[cfg(target_os = "macos")]
-                {
-                    use std::process::Command;
-                    let _ = Command::new("pbcopy")
-                        .stdin(std::process::Stdio::piped())
-                        .spawn()
-                        .and_then(|mut child| {
-                            use std::io::Write;
-                            if let Some(stdin) = child.stdin.as_mut() {
-                                stdin.write_all(content.as_bytes())?;
-                            }
-                            child.wait()
-                        });
-                    info!(format = ?format, "Note exported to clipboard");
-                }
+        let content = match format {
+            ExportFormat::PlainText => note.content.clone(),
+            // For Markdown, just export the content as-is.
+            // The title is derived from the first line of content,
+            // so prepending it would cause duplication.
+            ExportFormat::Markdown => note.content.clone(),
+            ExportFormat::Html => {
+                // For HTML, we include proper structure with the title
+                // and render the content as preformatted text
+                format!(
+                    "<!DOCTYPE html>\n<html>\n<head><title>{}</title></head>\n<body>\n<h1>{}</h1>\n<pre>{}</pre>\n</body>\n</html>",
+                    note.title, note.title, note.content
+                )
             }
+        };
+
+        // Copy to clipboard
+        #[cfg(target_os = "macos")]
+        {
+            use std::process::Command;
+            let _ = Command::new("pbcopy")
+                .stdin(std::process::Stdio::piped())
+                .spawn()
+                .and_then(|mut child| {
+                    use std::io::Write;
+                    if let Some(stdin) = child.stdin.as_mut() {
+                        stdin.write_all(content.as_bytes())?;
+                    }
+                    child.wait()
+                });
+            info!(format = ?format, "Note exported to clipboard");
         }
     }
 }
diff --git a/src/notes/window/notes_actions.rs b/src/notes/window/notes_actions.rs
index 6405519cffd92b2252b2e410eb3f58ee37800b8d..603be7a00cb2f2023699769b2b8b33c629a21238
--- a/src/notes/window/notes_actions.rs
+++ b/src/notes/window/notes_actions.rs
@@ -1,6 +1,40 @@
 use super::*;
 
 impl NotesApp {
+    const SELECTED_NOTE_NOT_FOUND_FEEDBACK: &'static str = "Selected note could not be found";
+
+    pub(super) fn resolve_selected_note(
+        selected_note_id: Option<NoteId>,
+        notes: &[Note],
+    ) -> Option<(NoteId, &Note)> {
+        let selected_note_id = selected_note_id?;
+        notes
+            .iter()
+            .find(|note| note.id == selected_note_id)
+            .map(|note| (selected_note_id, note))
+    }
+
+    pub(super) fn show_selected_note_missing_feedback(&mut self, action: &'static str) {
+        tracing::warn!(
+            action,
+            selected_note_id = ?self.selected_note_id,
+            notes_len = self.notes.len(),
+            "notes_action_selected_note_not_found",
+        );
+        self.show_action_feedback(Self::SELECTED_NOTE_NOT_FOUND_FEEDBACK, true);
+    }
+
+    pub(super) fn selected_note_for_action(
+        &mut self,
+        action: &'static str,
+    ) -> Option<(NoteId, &Note)> {
+        let selected_note = Self::resolve_selected_note(self.selected_note_id, &self.notes);
+        if selected_note.is_none() {
+            self.show_selected_note_missing_feedback(action);
+        }
+        selected_note
+    }
+
     /// Cycle sort mode: Updated → Created → Alphabetical → Updated
     pub(super) fn cycle_sort_mode(&mut self, cx: &mut Context<Self>) {
         self.sort_mode = match self.sort_mode {
@@ -86,42 +120,34 @@
         format!("scriptkit://notes/{}", id.as_str())
     }
 
-    pub(super) fn copy_note_as_markdown(&self) {
+    pub(super) fn copy_note_as_markdown(&mut self) {
         self.export_note(ExportFormat::Markdown);
     }
 
-    pub(super) fn copy_note_deeplink(&self) {
-        if let Some(id) = self.selected_note_id {
-            let deeplink = self.note_deeplink(id);
-            self.copy_text_to_clipboard(&deeplink);
-        }
+    pub(super) fn copy_note_deeplink(&mut self) {
+        let Some((id, _)) = self.selected_note_for_action("copy_note_deeplink") else {
+            return;
+        };
+        let deeplink = self.note_deeplink(id);
+        self.copy_text_to_clipboard(&deeplink);
     }
 
-    pub(super) fn create_note_quicklink(&self) {
-        if let Some(id) = self.selected_note_id {
-            let title = self
-                .notes
-                .iter()
-                .find(|note| note.id == id)
-                .map(|note| {
-                    if note.title.is_empty() {
-                        "Untitled Note".to_string()
-                    } else {
-                        note.title.clone()
-                    }
-                })
-                .unwrap_or_else(|| "Untitled Note".to_string());
-            let deeplink = self.note_deeplink(id);
-            let quicklink = format!("[{}]({})", title, deeplink);
-            self.copy_text_to_clipboard(&quicklink);
-        }
+    pub(super) fn create_note_quicklink(&mut self) {
+        let Some((id, note)) = self.selected_note_for_action("create_note_quicklink") else {
+            return;
+        };
+        let title = if note.title.is_empty() {
+            "Untitled Note".to_string()
+        } else {
+            note.title.clone()
+        };
+        let deeplink = self.note_deeplink(id);
+        let quicklink = format!("[{}]({})", title, deeplink);
+        self.copy_text_to_clipboard(&quicklink);
     }
 
     pub(super) fn duplicate_selected_note(&mut self, window: &mut Window, cx: &mut Context<Self>) {
-        let Some(id) = self.selected_note_id else {
-            return;
-        };
-        let Some(note) = self.notes.iter().find(|note| note.id == id) else {
+        let Some((_id, note)) = self.selected_note_for_action("duplicate_selected_note") else {
             return;
         };
 
diff --git a/src/notes/window/panels.rs b/src/notes/window/panels.rs
index 16b4b85b9be89780b4c9430f0db050a9af14532e..b843238a1e9103f6055702cf09dc506f1e99fa17
--- a/src/notes/window/panels.rs
+++ b/src/notes/window/panels.rs
@@ -281,6 +281,17 @@
                 self.select_note(note_id, window, cx);
                 return;
             }
+
+            tracing::warn!(
+                action_id,
+                note_id_str,
+                selected_note_id = ?self.selected_note_id,
+                notes_len = self.notes.len(),
+                "notes_note_switcher_selected_note_not_found",
+            );
+            self.show_selected_note_missing_feedback("execute_note_switcher_action");
+            self.close_browse_panel(window, cx);
+            return;
         }
 
         // Handle "no_notes" placeholder action
diff --git a/src/notes/window/tests.rs b/src/notes/window/tests.rs
index 8cb070d17ec066ba2b9e5a81de39cf1dfd19742b..441dc8b615019a2f05ba8f031d6bad5a449dd4a1
--- a/src/notes/window/tests.rs
+++ b/src/notes/window/tests.rs
@@ -1,4 +1,4 @@
-use super::NotesApp;
+use super::{Note, NoteId, NotesApp};
 
 #[test]
 fn formatting_replacement_wraps_selected_text() {
@@ -37,3 +37,31 @@
     assert_eq!(new_value, "he****llo");
     assert_eq!(new_selection, 4..4);
 }
+
+#[test]
+fn test_resolve_selected_note_returns_none_when_selection_is_missing() {
+    let notes = vec![Note::with_content("one"), Note::with_content("two")];
+
+    let selected = NotesApp::resolve_selected_note(None, &notes);
+
+    assert!(selected.is_none());
+}
+
+#[test]
+fn test_resolve_selected_note_returns_none_when_selection_is_stale() {
+    let notes = vec![Note::with_content("one"), Note::with_content("two")];
+
+    let selected = NotesApp::resolve_selected_note(Some(NoteId::new()), &notes);
+
+    assert!(selected.is_none());
+}
+
+#[test]
+fn test_resolve_selected_note_returns_note_when_selection_exists() {
+    let notes = vec![Note::with_content("one"), Note::with_content("two")];
+    let selected_id = notes[1].id;
+
+    let selected = NotesApp::resolve_selected_note(Some(selected_id), &notes);
+
+    assert_eq!(selected.map(|(id, note)| (id, note.id)), Some((selected_id, selected_id)));
+}

 exited 101 in 9.54s:
    Checking script-kit-gpui v0.1.0 (/Users/johnlindquist/dev/script-kit-gpui)
warning: glob import doesn't reexport anything with visibility `pub(in crate::prompts)` because no imported item is public enough
  --> src/prompts/div/mod.rs:32:16
   |
32 | pub(super) use inline::*;
   |                ^^^^^^^^^
   |
note: the most public imported item is `pub(self)`
  --> src/prompts/div/mod.rs:32:16
   |
32 | pub(super) use inline::*;
   |                ^^^^^^^^^
   = help: reduce the glob import's visibility or increase visibility of imported items
   = note: `#[warn(unused_imports)]` (part of `#[warn(unused)]`) on by default

warning: glob import doesn't reexport anything with visibility `pub(in crate::prompts)` because no imported item is public enough
  --> src/prompts/div/mod.rs:34:16
   |
34 | pub(super) use render_html::*;
   |                ^^^^^^^^^^^^^^
file update:
diff --git a/src/notes/window/notes.rs b/src/notes/window/notes.rs
index 2b96e1be9f619ad7fa8b88d1287b653adb4780b4..449ab857a161bcb00618adf6e45ab022a3ac86fe
--- a/src/notes/window/notes.rs
+++ b/src/notes/window/notes.rs
@@ -231,42 +231,42 @@
     }
 
     /// Export the current note
-    pub(super) fn export_note(&self, format: ExportFormat) {
-        if let Some(id) = self.selected_note_id {
-            if let Some(note) = self.notes.iter().find(|n| n.id == id) {
-                let content = match format {
-                    ExportFormat::PlainText => note.content.clone(),
-                    // For Markdown, just export the content as-is.
-                    // The title is derived from the first line of content,
-                    // so prepending it would cause duplication.
-                    ExportFormat::Markdown => note.content.clone(),
-                    ExportFormat::Html => {
-                        // For HTML, we include proper structure with the title
-                        // and render the content as preformatted text
-                        format!(
-                            "<!DOCTYPE html>\n<html>\n<head><title>{}</title></head>\n<body>\n<h1>{}</h1>\n<pre>{}</pre>\n</body>\n</html>",
-                            note.title, note.title, note.content
-                        )
-                    }
-                };
+    pub(super) fn export_note(&mut self, format: ExportFormat) {
+        let Some((_id, note)) = self.selected_note_for_action("export_note") else {
+            return;
+        };
 
-                // Copy to clipboard
-                #[cfg(target_os = "macos")]
-                {
-                    use std::process::Command;
-                    let _ = Command::new("pbcopy")
-                        .stdin(std::process::Stdio::piped())
-                        .spawn()
-                        .and_then(|mut child| {
-                            use std::io::Write;
-                            if let Some(stdin) = child.stdin.as_mut() {
-                                stdin.write_all(content.as_bytes())?;
-                            }
-                            child.wait()
-                        });
-                    info!(format = ?format, "Note exported to clipboard");
-                }
+        let content = match format {
+            ExportFormat::PlainText => note.content.clone(),
+            // For Markdown, just export the content as-is.
+            // The title is derived from the first line of content,
+            // so prepending it would cause duplication.
+            ExportFormat::Markdown => note.content.clone(),
+            ExportFormat::Html => {
+                // For HTML, we include proper structure with the title
+                // and render the content as preformatted text
+                format!(
+                    "<!DOCTYPE html>\n<html>\n<head><title>{}</title></head>\n<body>\n<h1>{}</h1>\n<pre>{}</pre>\n</body>\n</html>",
+                    note.title, note.title, note.content
+                )
             }
+        };
+
+        // Copy to clipboard
+        #[cfg(target_os = "macos")]
+        {
+            use std::process::Command;
+            let _ = Command::new("pbcopy")
+                .stdin(std::process::Stdio::piped())
+                .spawn()
+                .and_then(|mut child| {
+                    use std::io::Write;
+                    if let Some(stdin) = child.stdin.as_mut() {
+                        stdin.write_all(content.as_bytes())?;
+                    }
+                    child.wait()
+                });
+            info!(format = ?format, "Note exported to clipboard");
         }
     }
 }
diff --git a/src/notes/window/notes_actions.rs b/src/notes/window/notes_actions.rs
index 6405519cffd92b2252b2e410eb3f58ee37800b8d..603be7a00cb2f2023699769b2b8b33c629a21238
--- a/src/notes/window/notes_actions.rs
+++ b/src/notes/window/notes_actions.rs
@@ -1,6 +1,40 @@
 use super::*;
 
 impl NotesApp {
+    const SELECTED_NOTE_NOT_FOUND_FEEDBACK: &'static str = "Selected note could not be found";
+
+    pub(super) fn resolve_selected_note(
+        selected_note_id: Option<NoteId>,
+        notes: &[Note],
+    ) -> Option<(NoteId, &Note)> {
+        let selected_note_id = selected_note_id?;
+        notes
+            .iter()
+            .find(|note| note.id == selected_note_id)
+            .map(|note| (selected_note_id, note))
+    }
+
+    pub(super) fn show_selected_note_missing_feedback(&mut self, action: &'static str) {
+        tracing::warn!(
+            action,
+            selected_note_id = ?self.selected_note_id,
+            notes_len = self.notes.len(),
+            "notes_action_selected_note_not_found",
+        );
+        self.show_action_feedback(Self::SELECTED_NOTE_NOT_FOUND_FEEDBACK, true);
+    }
+
+    pub(super) fn selected_note_for_action(
+        &mut self,
+        action: &'static str,
+    ) -> Option<(NoteId, &Note)> {
+        let selected_note = Self::resolve_selected_note(self.selected_note_id, &self.notes);
+        if selected_note.is_none() {
+            self.show_selected_note_missing_feedback(action);
+        }
+        selected_note
+    }
+
     /// Cycle sort mode: Updated → Created → Alphabetical → Updated
     pub(super) fn cycle_sort_mode(&mut self, cx: &mut Context<Self>) {
         self.sort_mode = match self.sort_mode {
@@ -86,42 +120,34 @@
         format!("scriptkit://notes/{}", id.as_str())
     }
 
-    pub(super) fn copy_note_as_markdown(&self) {
+    pub(super) fn copy_note_as_markdown(&mut self) {
         self.export_note(ExportFormat::Markdown);
     }
 
-    pub(super) fn copy_note_deeplink(&self) {
-        if let Some(id) = self.selected_note_id {
-            let deeplink = self.note_deeplink(id);
-            self.copy_text_to_clipboard(&deeplink);
-        }
+    pub(super) fn copy_note_deeplink(&mut self) {
+        let Some((id, _)) = self.selected_note_for_action("copy_note_deeplink") else {
+            return;
+        };
+        let deeplink = self.note_deeplink(id);
+        self.copy_text_to_clipboard(&deeplink);
     }
 
-    pub(super) fn create_note_quicklink(&self) {
-        if let Some(id) = self.selected_note_id {
-            let title = self
-                .notes
-                .iter()
-                .find(|note| note.id == id)
-                .map(|note| {
-                    if note.title.is_empty() {
-                        "Untitled Note".to_string()
-                    } else {
-                        note.title.clone()
-                    }
-                })
-                .unwrap_or_else(|| "Untitled Note".to_string());
-            let deeplink = self.note_deeplink(id);
-            let quicklink = format!("[{}]({})", title, deeplink);
-            self.copy_text_to_clipboard(&quicklink);
-        }
+    pub(super) fn create_note_quicklink(&mut self) {
+        let Some((id, note)) = self.selected_note_for_action("create_note_quicklink") else {
+            return;
+        };
+        let title = if note.title.is_empty() {
+            "Untitled Note".to_string()
+        } else {
+            note.title.clone()
+        };
+        let deeplink = self.note_deeplink(id);
+        let quicklink = format!("[{}]({})", title, deeplink);
+        self.copy_text_to_clipboard(&quicklink);
     }
 
     pub(super) fn duplicate_selected_note(&mut self, window: &mut Window, cx: &mut Context<Self>) {
-        let Some(id) = self.selected_note_id else {
-            return;
-        };
-        let Some(note) = self.notes.iter().find(|note| note.id == id) else {
+        let Some((_id, note)) = self.selected_note_for_action("duplicate_selected_note") else {
             return;
         };
 
diff --git a/src/notes/window/panels.rs b/src/notes/window/panels.rs
index 16b4b85b9be89780b4c9430f0db050a9af14532e..b843238a1e9103f6055702cf09dc506f1e99fa17
--- a/src/notes/window/panels.rs
+++ b/src/notes/window/panels.rs
@@ -281,6 +281,17 @@
                 self.select_note(note_id, window, cx);
                 return;
             }
+
+            tracing::warn!(
+                action_id,
+                note_id_str,
+                selected_note_id = ?self.selected_note_id,
+                notes_len = self.notes.len(),
+                "notes_note_switcher_selected_note_not_found",
+            );
+            self.show_selected_note_missing_feedback("execute_note_switcher_action");
+            self.close_browse_panel(window, cx);
+            return;
         }
 
         // Handle "no_notes" placeholder action
diff --git a/src/notes/window/tests.rs b/src/notes/window/tests.rs
index 8cb070d17ec066ba2b9e5a81de39cf1dfd19742b..441dc8b615019a2f05ba8f031d6bad5a449dd4a1
--- a/src/notes/window/tests.rs
+++ b/src/notes/window/tests.rs
@@ -1,4 +1,4 @@
-use super::NotesApp;
+use super::{Note, NoteId, NotesApp};
 
 #[test]
 fn formatting_replacement_wraps_selected_text() {
@@ -37,3 +37,31 @@
     assert_eq!(new_value, "he****llo");
     assert_eq!(new_selection, 4..4);
 }
+
+#[test]
+fn test_resolve_selected_note_returns_none_when_selection_is_missing() {
+    let notes = vec![Note::with_content("one"), Note::with_content("two")];
+
+    let selected = NotesApp::resolve_selected_note(None, &notes);
+
+    assert!(selected.is_none());
+}
+
+#[test]
+fn test_resolve_selected_note_returns_none_when_selection_is_stale() {
+    let notes = vec![Note::with_content("one"), Note::with_content("two")];
+
+    let selected = NotesApp::resolve_selected_note(Some(NoteId::new()), &notes);
+
+    assert!(selected.is_none());
+}
+
+#[test]
+fn test_resolve_selected_note_returns_note_when_selection_exists() {
+    let notes = vec![Note::with_content("one"), Note::with_content("two")];
+    let selected_id = notes[1].id;
+
+    let selected = NotesApp::resolve_selected_note(Some(selected_id), &notes);
+
+    assert_eq!(selected.map(|(id, note)| (id, note.id)), Some((selected_id, selected_id)));
+}


thinking
**Fixing compile error by avoiding borrow**
file update
M /Users/johnlindquist/dev/script-kit-gpui/src/notes/window/notes_actions.rs
@@ -30,7 +30,13 @@
     ) -> Option<(NoteId, &Note)> {
-        let selected_note = Self::resolve_selected_note(self.selected_note_id, &self.notes);
-        if selected_note.is_none() {
+        let Some(selected_note_id) = self.selected_note_id else {
+            self.show_selected_note_missing_feedback(action);
+            return None;
+        };
+
+        if !self.notes.iter().any(|note| note.id == selected_note_id) {
             self.show_selected_note_missing_feedback(action);
+            return None;
         }
-        selected_note
+
+        Self::resolve_selected_note(Some(selected_note_id), &self.notes)
     }
apply_patch(auto_approved=true) exited 0 in 26ms:
Success. Updated the following files:
M src/notes/window/notes_actions.rs
file update:
diff --git a/src/notes/window/notes.rs b/src/notes/window/notes.rs
index 2b96e1be9f619ad7fa8b88d1287b653adb4780b4..449ab857a161bcb00618adf6e45ab022a3ac86fe
--- a/src/notes/window/notes.rs
+++ b/src/notes/window/notes.rs
@@ -231,42 +231,42 @@
     }
 
     /// Export the current note
-    pub(super) fn export_note(&self, format: ExportFormat) {
-        if let Some(id) = self.selected_note_id {
-            if let Some(note) = self.notes.iter().find(|n| n.id == id) {
-                let content = match format {
-                    ExportFormat::PlainText => note.content.clone(),
-                    // For Markdown, just export the content as-is.
-                    // The title is derived from the first line of content,
-                    // so prepending it would cause duplication.
-                    ExportFormat::Markdown => note.content.clone(),
-                    ExportFormat::Html => {
-                        // For HTML, we include proper structure with the title
-                        // and render the content as preformatted text
-                        format!(
-                            "<!DOCTYPE html>\n<html>\n<head><title>{}</title></head>\n<body>\n<h1>{}</h1>\n<pre>{}</pre>\n</body>\n</html>",
-                            note.title, note.title, note.content
-                        )
-                    }
-                };
+    pub(super) fn export_note(&mut self, format: ExportFormat) {
+        let Some((_id, note)) = self.selected_note_for_action("export_note") else {
+            return;
+        };
 
-                // Copy to clipboard
-                #[cfg(target_os = "macos")]
-                {
-                    use std::process::Command;
-                    let _ = Command::new("pbcopy")
-                        .stdin(std::process::Stdio::piped())
-                        .spawn()
-                        .and_then(|mut child| {
-                            use std::io::Write;
-                            if let Some(stdin) = child.stdin.as_mut() {
-                                stdin.write_all(content.as_bytes())?;
-                            }
-                            child.wait()
-                        });
-                    info!(format = ?format, "Note exported to clipboard");
-                }
+        let content = match format {
+            ExportFormat::PlainText => note.content.clone(),
+            // For Markdown, just export the content as-is.
+            // The title is derived from the first line of content,
+            // so prepending it would cause duplication.
+            ExportFormat::Markdown => note.content.clone(),
+            ExportFormat::Html => {
+                // For HTML, we include proper structure with the title
+                // and render the content as preformatted text
+                format!(
+                    "<!DOCTYPE html>\n<html>\n<head><title>{}</title></head>\n<body>\n<h1>{}</h1>\n<pre>{}</pre>\n</body>\n</html>",
+                    note.title, note.title, note.content
+                )
             }
+        };
+
+        // Copy to clipboard
+        #[cfg(target_os = "macos")]
+        {
+            use std::process::Command;
+            let _ = Command::new("pbcopy")
+                .stdin(std::process::Stdio::piped())
+                .spawn()
+                .and_then(|mut child| {
+                    use std::io::Write;
+                    if let Some(stdin) = child.stdin.as_mut() {
+                        stdin.write_all(content.as_bytes())?;
+                    }
+                    child.wait()
+                });
+            info!(format = ?format, "Note exported to clipboard");
         }
     }
 }
diff --git a/src/notes/window/notes_actions.rs b/src/notes/window/notes_actions.rs
index 6405519cffd92b2252b2e410eb3f58ee37800b8d..6d16c492f61a4be231c5a86328a3b9c14112bb7c
--- a/src/notes/window/notes_actions.rs
+++ b/src/notes/window/notes_actions.rs
@@ -1,6 +1,46 @@
 use super::*;
 
 impl NotesApp {
+    const SELECTED_NOTE_NOT_FOUND_FEEDBACK: &'static str = "Selected note could not be found";
+
+    pub(super) fn resolve_selected_note(
+        selected_note_id: Option<NoteId>,
+        notes: &[Note],
+    ) -> Option<(NoteId, &Note)> {
+        let selected_note_id = selected_note_id?;
+        notes
+            .iter()
+            .find(|note| note.id == selected_note_id)
+            .map(|note| (selected_note_id, note))
+    }
+
+    pub(super) fn show_selected_note_missing_feedback(&mut self, action: &'static str) {
+        tracing::warn!(
+            action,
+            selected_note_id = ?self.selected_note_id,
+            notes_len = self.notes.len(),
+            "notes_action_selected_note_not_found",
+        );
+        self.show_action_feedback(Self::SELECTED_NOTE_NOT_FOUND_FEEDBACK, true);
+    }
+
+    pub(super) fn selected_note_for_action(
+        &mut self,
+        action: &'static str,
+    ) -> Option<(NoteId, &Note)> {
+        let Some(selected_note_id) = self.selected_note_id else {
+            self.show_selected_note_missing_feedback(action);
+            return None;
+        };
+
+        if !self.notes.iter().any(|note| note.id == selected_note_id) {
+            self.show_selected_note_missing_feedback(action);
+            return None;
+        }
+
+        Self::resolve_selected_note(Some(selected_note_id), &self.notes)
+    }
+
     /// Cycle sort mode: Updated → Created → Alphabetical → Updated
     pub(super) fn cycle_sort_mode(&mut self, cx: &mut Context<Self>) {
         self.sort_mode = match self.sort_mode {
@@ -86,42 +126,34 @@
         format!("scriptkit://notes/{}", id.as_str())
     }
 
-    pub(super) fn copy_note_as_markdown(&self) {
+    pub(super) fn copy_note_as_markdown(&mut self) {
         self.export_note(ExportFormat::Markdown);
     }
 
-    pub(super) fn copy_note_deeplink(&self) {
-        if let Some(id) = self.selected_note_id {
-            let deeplink = self.note_deeplink(id);
-            self.copy_text_to_clipboard(&deeplink);
-        }
+    pub(super) fn copy_note_deeplink(&mut self) {
+        let Some((id, _)) = self.selected_note_for_action("copy_note_deeplink") else {
+            return;
+        };
+        let deeplink = self.note_deeplink(id);
+        self.copy_text_to_clipboard(&deeplink);
     }
 
-    pub(super) fn create_note_quicklink(&self) {
-        if let Some(id) = self.selected_note_id {
-            let title = self
-                .notes
-                .iter()
-                .find(|note| note.id == id)
-                .map(|note| {
-                    if note.title.is_empty() {
-                        "Untitled Note".to_string()
-                    } else {
-                        note.title.clone()
-                    }
-                })
-                .unwrap_or_else(|| "Untitled Note".to_string());
-            let deeplink = self.note_deeplink(id);
-            let quicklink = format!("[{}]({})", title, deeplink);
-            self.copy_text_to_clipboard(&quicklink);
-        }
+    pub(super) fn create_note_quicklink(&mut self) {
+        let Some((id, note)) = self.selected_note_for_action("create_note_quicklink") else {
+            return;
+        };
+        let title = if note.title.is_empty() {
+            "Untitled Note".to_string()
+        } else {
+            note.title.clone()
+        };
+        let deeplink = self.note_deeplink(id);
+        let quicklink = format!("[{}]({})", title, deeplink);
+        self.copy_text_to_clipboard(&quicklink);
     }
 
     pub(super) fn duplicate_selected_note(&mut self, window: &mut Window, cx: &mut Context<Self>) {
-        let Some(id) = self.selected_note_id else {
-            return;
-        };
-        let Some(note) = self.notes.iter().find(|note| note.id == id) else {
+        let Some((_id, note)) = self.selected_note_for_action("duplicate_selected_note") else {
             return;
         };
 
diff --git a/src/notes/window/panels.rs b/src/notes/window/panels.rs
index 16b4b85b9be89780b4c9430f0db050a9af14532e..b843238a1e9103f6055702cf09dc506f1e99fa17
--- a/src/notes/window/panels.rs
+++ b/src/notes/window/panels.rs
@@ -281,6 +281,17 @@
                 self.select_note(note_id, window, cx);
                 return;
             }
+
+            tracing::warn!(
+                action_id,
+                note_id_str,
+                selected_note_id = ?self.selected_note_id,
+                notes_len = self.notes.len(),
+                "notes_note_switcher_selected_note_not_found",
+            );
+            self.show_selected_note_missing_feedback("execute_note_switcher_action");
+            self.close_browse_panel(window, cx);
+            return;
         }
 
         // Handle "no_notes" placeholder action
diff --git a/src/notes/window/tests.rs b/src/notes/window/tests.rs
index 8cb070d17ec066ba2b9e5a81de39cf1dfd19742b..441dc8b615019a2f05ba8f031d6bad5a449dd4a1
--- a/src/notes/window/tests.rs
+++ b/src/notes/window/tests.rs
@@ -1,4 +1,4 @@
-use super::NotesApp;
+use super::{Note, NoteId, NotesApp};
 
 #[test]
 fn formatting_replacement_wraps_selected_text() {
@@ -37,3 +37,31 @@
     assert_eq!(new_value, "he****llo");
     assert_eq!(new_selection, 4..4);
 }
+
+#[test]
+fn test_resolve_selected_note_returns_none_when_selection_is_missing() {
+    let notes = vec![Note::with_content("one"), Note::with_content("two")];
+
+    let selected = NotesApp::resolve_selected_note(None, &notes);
+
+    assert!(selected.is_none());
+}
+
+#[test]
+fn test_resolve_selected_note_returns_none_when_selection_is_stale() {
+    let notes = vec![Note::with_content("one"), Note::with_content("two")];
+
+    let selected = NotesApp::resolve_selected_note(Some(NoteId::new()), &notes);
+
+    assert!(selected.is_none());
+}
+
+#[test]
+fn test_resolve_selected_note_returns_note_when_selection_exists() {
+    let notes = vec![Note::with_content("one"), Note::with_content("two")];
+    let selected_id = notes[1].id;
+
+    let selected = NotesApp::resolve_selected_note(Some(selected_id), &notes);
+
+    assert_eq!(selected.map(|(id, note)| (id, note.id)), Some((selected_id, selected_id)));
+}

file update:
diff --git a/src/notes/window/notes.rs b/src/notes/window/notes.rs
index 2b96e1be9f619ad7fa8b88d1287b653adb4780b4..449ab857a161bcb00618adf6e45ab022a3ac86fe
--- a/src/notes/window/notes.rs
+++ b/src/notes/window/notes.rs
@@ -231,42 +231,42 @@
     }
 
     /// Export the current note
-    pub(super) fn export_note(&self, format: ExportFormat) {
-        if let Some(id) = self.selected_note_id {
-            if let Some(note) = self.notes.iter().find(|n| n.id == id) {
-                let content = match format {
-                    ExportFormat::PlainText => note.content.clone(),
-                    // For Markdown, just export the content as-is.
-                    // The title is derived from the first line of content,
-                    // so prepending it would cause duplication.
-                    ExportFormat::Markdown => note.content.clone(),
-                    ExportFormat::Html => {
-                        // For HTML, we include proper structure with the title
-                        // and render the content as preformatted text
-                        format!(
-                            "<!DOCTYPE html>\n<html>\n<head><title>{}</title></head>\n<body>\n<h1>{}</h1>\n<pre>{}</pre>\n</body>\n</html>",
-                            note.title, note.title, note.content
-                        )
-                    }
-                };
+    pub(super) fn export_note(&mut self, format: ExportFormat) {
+        let Some((_id, note)) = self.selected_note_for_action("export_note") else {
+            return;
+        };
 
-                // Copy to clipboard
-                #[cfg(target_os = "macos")]
-                {
-                    use std::process::Command;
-                    let _ = Command::new("pbcopy")
-                        .stdin(std::process::Stdio::piped())
-                        .spawn()
-                        .and_then(|mut child| {
-                            use std::io::Write;
-                            if let Some(stdin) = child.stdin.as_mut() {
-                                stdin.write_all(content.as_bytes())?;
-                            }
-                            child.wait()
-                        });
-                    info!(format = ?format, "Note exported to clipboard");
-                }
+        let content = match format {
+            ExportFormat::PlainText => note.content.clone(),
+            // For Markdown, just export the content as-is.
+            // The title is derived from the first line of content,
+            // so prepending it would cause duplication.
+            ExportFormat::Markdown => note.content.clone(),
+            ExportFormat::Html => {
+                // For HTML, we include proper structure with the title
+                // and render the content as preformatted text
+                format!(
+                    "<!DOCTYPE html>\n<html>\n<head><title>{}</title></head>\n<body>\n<h1>{}</h1>\n<pre>{}</pre>\n</body>\n</html>",
+                    note.title, note.title, note.content
+                )
             }
+        };
+
+        // Copy to clipboard
+        #[cfg(target_os = "macos")]
+        {
+            use std::process::Command;
+            let _ = Command::new("pbcopy")
+                .stdin(std::process::Stdio::piped())
+                .spawn()
+                .and_then(|mut child| {
+                    use std::io::Write;
+                    if let Some(stdin) = child.stdin.as_mut() {
+                        stdin.write_all(content.as_bytes())?;
+                    }
+                    child.wait()
+                });
+            info!(format = ?format, "Note exported to clipboard");
         }
     }
 }
diff --git a/src/notes/window/notes_actions.rs b/src/notes/window/notes_actions.rs
index 6405519cffd92b2252b2e410eb3f58ee37800b8d..6d16c492f61a4be231c5a86328a3b9c14112bb7c
--- a/src/notes/window/notes_actions.rs
+++ b/src/notes/window/notes_actions.rs
@@ -1,6 +1,46 @@
 use super::*;
 
 impl NotesApp {
+    const SELECTED_NOTE_NOT_FOUND_FEEDBACK: &'static str = "Selected note could not be found";
+
+    pub(super) fn resolve_selected_note(
+        selected_note_id: Option<NoteId>,
+        notes: &[Note],
+    ) -> Option<(NoteId, &Note)> {
+        let selected_note_id = selected_note_id?;
+        notes
+            .iter()
+            .find(|note| note.id == selected_note_id)
+            .map(|note| (selected_note_id, note))
+    }
+
+    pub(super) fn show_selected_note_missing_feedback(&mut self, action: &'static str) {
+        tracing::warn!(
+            action,
+            selected_note_id = ?self.selected_note_id,
+            notes_len = self.notes.len(),
+            "notes_action_selected_note_not_found",
+        );
+        self.show_action_feedback(Self::SELECTED_NOTE_NOT_FOUND_FEEDBACK, true);
+    }
+
+    pub(super) fn selected_note_for_action(
+        &mut self,
+        action: &'static str,
+    ) -> Option<(NoteId, &Note)> {
+        let Some(selected_note_id) = self.selected_note_id else {
+            self.show_selected_note_missing_feedback(action);
+            return None;
+        };
+
+        if !self.notes.iter().any(|note| note.id == selected_note_id) {
+            self.show_selected_note_missing_feedback(action);
+            return None;
+        }
+
+        Self::resolve_selected_note(Some(selected_note_id), &self.notes)
+    }
+
     /// Cycle sort mode: Updated → Created → Alphabetical → Updated
     pub(super) fn cycle_sort_mode(&mut self, cx: &mut Context<Self>) {
         self.sort_mode = match self.sort_mode {
@@ -86,42 +126,34 @@
         format!("scriptkit://notes/{}", id.as_str())
     }
 
-    pub(super) fn copy_note_as_markdown(&self) {
+    pub(super) fn copy_note_as_markdown(&mut self) {
         self.export_note(ExportFormat::Markdown);
     }
 
-    pub(super) fn copy_note_deeplink(&self) {
-        if let Some(id) = self.selected_note_id {
-            let deeplink = self.note_deeplink(id);
-            self.copy_text_to_clipboard(&deeplink);
-        }
+    pub(super) fn copy_note_deeplink(&mut self) {
+        let Some((id, _)) = self.selected_note_for_action("copy_note_deeplink") else {
+            return;
+        };
+        let deeplink = self.note_deeplink(id);
+        self.copy_text_to_clipboard(&deeplink);
     }
 
-    pub(super) fn create_note_quicklink(&self) {
-        if let Some(id) = self.selected_note_id {
-            let title = self
-                .notes
-                .iter()
-                .find(|note| note.id == id)
-                .map(|note| {
-                    if note.title.is_empty() {
-                        "Untitled Note".to_string()
-                    } else {
-                        note.title.clone()
-                    }
-                })
-                .unwrap_or_else(|| "Untitled Note".to_string());
-            let deeplink = self.note_deeplink(id);
-            let quicklink = format!("[{}]({})", title, deeplink);
-            self.copy_text_to_clipboard(&quicklink);
-        }
+    pub(super) fn create_note_quicklink(&mut self) {
+        let Some((id, note)) = self.selected_note_for_action("create_note_quicklink") else {
+            return;
+        };
+        let title = if note.title.is_empty() {
+            "Untitled Note".to_string()
+        } else {
+            note.title.clone()
+        };
+        let deeplink = self.note_deeplink(id);
+        let quicklink = format!("[{}]({})", title, deeplink);
+        self.copy_text_to_clipboard(&quicklink);
     }
 
     pub(super) fn duplicate_selected_note(&mut self, window: &mut Window, cx: &mut Context<Self>) {
-        let Some(id) = self.selected_note_id else {
-            return;
-        };
-        let Some(note) = self.notes.iter().find(|note| note.id == id) else {
+        let Some((_id, note)) = self.selected_note_for_action("duplicate_selected_note") else {
             return;
         };
 
diff --git a/src/notes/window/panels.rs b/src/notes/window/panels.rs
index 16b4b85b9be89780b4c9430f0db050a9af14532e..b843238a1e9103f6055702cf09dc506f1e99fa17
--- a/src/notes/window/panels.rs
+++ b/src/notes/window/panels.rs
@@ -281,6 +281,17 @@
                 self.select_note(note_id, window, cx);
                 return;
             }
+
+            tracing::warn!(
+                action_id,
+                note_id_str,
+                selected_note_id = ?self.selected_note_id,
+                notes_len = self.notes.len(),
+                "notes_note_switcher_selected_note_not_found",
+            );
+            self.show_selected_note_missing_feedback("execute_note_switcher_action");
+            self.close_browse_panel(window, cx);
+            return;
         }
 
         // Handle "no_notes" placeholder action
diff --git a/src/notes/window/tests.rs b/src/notes/window/tests.rs
index 8cb070d17ec066ba2b9e5a81de39cf1dfd19742b..441dc8b615019a2f05ba8f031d6bad5a449dd4a1
--- a/src/notes/window/tests.rs
+++ b/src/notes/window/tests.rs
@@ -1,4 +1,4 @@
-use super::NotesApp;
+use super::{Note, NoteId, NotesApp};
 
 #[test]
 fn formatting_replacement_wraps_selected_text() {
@@ -37,3 +37,31 @@
     assert_eq!(new_value, "he****llo");
     assert_eq!(new_selection, 4..4);
 }
+
+#[test]
+fn test_resolve_selected_note_returns_none_when_selection_is_missing() {
+    let notes = vec![Note::with_content("one"), Note::with_content("two")];
+
+    let selected = NotesApp::resolve_selected_note(None, &notes);
+
+    assert!(selected.is_none());
+}
+
+#[test]
+fn test_resolve_selected_note_returns_none_when_selection_is_stale() {
+    let notes = vec![Note::with_content("one"), Note::with_content("two")];
+
+    let selected = NotesApp::resolve_selected_note(Some(NoteId::new()), &notes);
+
+    assert!(selected.is_none());
+}
+
+#[test]
+fn test_resolve_selected_note_returns_note_when_selection_exists() {
+    let notes = vec![Note::with_content("one"), Note::with_content("two")];
+    let selected_id = notes[1].id;
+
+    let selected = NotesApp::resolve_selected_note(Some(selected_id), &notes);
+
+    assert_eq!(selected.map(|(id, note)| (id, note.id)), Some((selected_id, selected_id)));
+}


thinking
**Refining targeted Rust checks**
codex
I hit one compile-time borrow issue in the new helper and patched it. I’m re-running `cargo check` to confirm our notes changes no longer introduce errors; remaining failures should be unrelated concurrent work.
exec
/bin/zsh -lc "cargo check -p script-kit-gpui 2>&1 | rg -n \"notes/window/notes_actions.rs|notes/window/notes.rs|notes/window/panels.rs|notes/window/tests.rs|error\\[E\"" in /Users/johnlindquist/dev/script-kit-gpuifile update:
diff --git a/src/notes/window/notes.rs b/src/notes/window/notes.rs
index 2b96e1be9f619ad7fa8b88d1287b653adb4780b4..449ab857a161bcb00618adf6e45ab022a3ac86fe
--- a/src/notes/window/notes.rs
+++ b/src/notes/window/notes.rs
@@ -231,42 +231,42 @@
     }
 
     /// Export the current note
-    pub(super) fn export_note(&self, format: ExportFormat) {
-        if let Some(id) = self.selected_note_id {
-            if let Some(note) = self.notes.iter().find(|n| n.id == id) {
-                let content = match format {
-                    ExportFormat::PlainText => note.content.clone(),
-                    // For Markdown, just export the content as-is.
-                    // The title is derived from the first line of content,
-                    // so prepending it would cause duplication.
-                    ExportFormat::Markdown => note.content.clone(),
-                    ExportFormat::Html => {
-                        // For HTML, we include proper structure with the title
-                        // and render the content as preformatted text
-                        format!(
-                            "<!DOCTYPE html>\n<html>\n<head><title>{}</title></head>\n<body>\n<h1>{}</h1>\n<pre>{}</pre>\n</body>\n</html>",
-                            note.title, note.title, note.content
-                        )
-                    }
-                };
+    pub(super) fn export_note(&mut self, format: ExportFormat) {
+        let Some((_id, note)) = self.selected_note_for_action("export_note") else {
+            return;
+        };
 
-                // Copy to clipboard
-                #[cfg(target_os = "macos")]
-                {
-                    use std::process::Command;
-                    let _ = Command::new("pbcopy")
-                        .stdin(std::process::Stdio::piped())
-                        .spawn()
-                        .and_then(|mut child| {
-                            use std::io::Write;
-                            if let Some(stdin) = child.stdin.as_mut() {
-                                stdin.write_all(content.as_bytes())?;
-                            }
-                            child.wait()
-                        });
-                    info!(format = ?format, "Note exported to clipboard");
-                }
+        let content = match format {
+            ExportFormat::PlainText => note.content.clone(),
+            // For Markdown, just export the content as-is.
+            // The title is derived from the first line of content,
+            // so prepending it would cause duplication.
+            ExportFormat::Markdown => note.content.clone(),
+            ExportFormat::Html => {
+                // For HTML, we include proper structure with the title
+                // and render the content as preformatted text
+                format!(
+                    "<!DOCTYPE html>\n<html>\n<head><title>{}</title></head>\n<body>\n<h1>{}</h1>\n<pre>{}</pre>\n</body>\n</html>",
+                    note.title, note.title, note.content
+                )
             }
+        };
+
+        // Copy to clipboard
+        #[cfg(target_os = "macos")]
+        {
+            use std::process::Command;
+            let _ = Command::new("pbcopy")
+                .stdin(std::process::Stdio::piped())
+                .spawn()
+                .and_then(|mut child| {
+                    use std::io::Write;
+                    if let Some(stdin) = child.stdin.as_mut() {
+                        stdin.write_all(content.as_bytes())?;
+                    }
+                    child.wait()
+                });
+            info!(format = ?format, "Note exported to clipboard");
         }
     }
 }
diff --git a/src/notes/window/notes_actions.rs b/src/notes/window/notes_actions.rs
index 6405519cffd92b2252b2e410eb3f58ee37800b8d..6d16c492f61a4be231c5a86328a3b9c14112bb7c
--- a/src/notes/window/notes_actions.rs
+++ b/src/notes/window/notes_actions.rs
@@ -1,6 +1,46 @@
 use super::*;
 
 impl NotesApp {
+    const SELECTED_NOTE_NOT_FOUND_FEEDBACK: &'static str = "Selected note could not be found";
+
+    pub(super) fn resolve_selected_note(
+        selected_note_id: Option<NoteId>,
+        notes: &[Note],
+    ) -> Option<(NoteId, &Note)> {
+        let selected_note_id = selected_note_id?;
+        notes
+            .iter()
+            .find(|note| note.id == selected_note_id)
+            .map(|note| (selected_note_id, note))
+    }
+
+    pub(super) fn show_selected_note_missing_feedback(&mut self, action: &'static str) {
+        tracing::warn!(
+            action,
+            selected_note_id = ?self.selected_note_id,
+            notes_len = self.notes.len(),
+            "notes_action_selected_note_not_found",
+        );
+        self.show_action_feedback(Self::SELECTED_NOTE_NOT_FOUND_FEEDBACK, true);
+    }
+
+    pub(super) fn selected_note_for_action(
+        &mut self,
+        action: &'static str,
+    ) -> Option<(NoteId, &Note)> {
+        let Some(selected_note_id) = self.selected_note_id else {
+            self.show_selected_note_missing_feedback(action);
+            return None;
+        };
+
+        if !self.notes.iter().any(|note| note.id == selected_note_id) {
+            self.show_selected_note_missing_feedback(action);
+            return None;
+        }
+
+        Self::resolve_selected_note(Some(selected_note_id), &self.notes)
+    }
+
     /// Cycle sort mode: Updated → Created → Alphabetical → Updated
     pub(super) fn cycle_sort_mode(&mut self, cx: &mut Context<Self>) {
         self.sort_mode = match self.sort_mode {
@@ -86,42 +126,34 @@
         format!("scriptkit://notes/{}", id.as_str())
     }
 
-    pub(super) fn copy_note_as_markdown(&self) {
+    pub(super) fn copy_note_as_markdown(&mut self) {
         self.export_note(ExportFormat::Markdown);
     }
 
-    pub(super) fn copy_note_deeplink(&self) {
-        if let Some(id) = self.selected_note_id {
-            let deeplink = self.note_deeplink(id);
-            self.copy_text_to_clipboard(&deeplink);
-        }
+    pub(super) fn copy_note_deeplink(&mut self) {
+        let Some((id, _)) = self.selected_note_for_action("copy_note_deeplink") else {
+            return;
+        };
+        let deeplink = self.note_deeplink(id);
+        self.copy_text_to_clipboard(&deeplink);
     }
 
-    pub(super) fn create_note_quicklink(&self) {
-        if let Some(id) = self.selected_note_id {
-            let title = self
-                .notes
-                .iter()
-                .find(|note| note.id == id)
-                .map(|note| {
-                    if note.title.is_empty() {
-                        "Untitled Note".to_string()
-                    } else {
-                        note.title.clone()
-                    }
-                })
-                .unwrap_or_else(|| "Untitled Note".to_string());
-            let deeplink = self.note_deeplink(id);
-            let quicklink = format!("[{}]({})", title, deeplink);
-            self.copy_text_to_clipboard(&quicklink);
-        }
+    pub(super) fn create_note_quicklink(&mut self) {
+        let Some((id, note)) = self.selected_note_for_action("create_note_quicklink") else {
+            return;
+        };
+        let title = if note.title.is_empty() {
+            "Untitled Note".to_string()
+        } else {
+            note.title.clone()
+        };
+        let deeplink = self.note_deeplink(id);
+        let quicklink = format!("[{}]({})", title, deeplink);
+        self.copy_text_to_clipboard(&quicklink);
     }
 
     pub(super) fn duplicate_selected_note(&mut self, window: &mut Window, cx: &mut Context<Self>) {
-        let Some(id) = self.selected_note_id else {
-            return;
-        };
-        let Some(note) = self.notes.iter().find(|note| note.id == id) else {
+        let Some((_id, note)) = self.selected_note_for_action("duplicate_selected_note") else {
             return;
         };
 
diff --git a/src/notes/window/panels.rs b/src/notes/window/panels.rs
index 16b4b85b9be89780b4c9430f0db050a9af14532e..b843238a1e9103f6055702cf09dc506f1e99fa17
--- a/src/notes/window/panels.rs
+++ b/src/notes/window/panels.rs
@@ -281,6 +281,17 @@
                 self.select_note(note_id, window, cx);
                 return;
             }
+
+            tracing::warn!(
+                action_id,
+                note_id_str,
+                selected_note_id = ?self.selected_note_id,
+                notes_len = self.notes.len(),
+                "notes_note_switcher_selected_note_not_found",
+            );
+            self.show_selected_note_missing_feedback("execute_note_switcher_action");
+            self.close_browse_panel(window, cx);
+            return;
         }
 
         // Handle "no_notes" placeholder action
diff --git a/src/notes/window/tests.rs b/src/notes/window/tests.rs
index 8cb070d17ec066ba2b9e5a81de39cf1dfd19742b..441dc8b615019a2f05ba8f031d6bad5a449dd4a1
--- a/src/notes/window/tests.rs
+++ b/src/notes/window/tests.rs
@@ -1,4 +1,4 @@
-use super::NotesApp;
+use super::{Note, NoteId, NotesApp};
 
 #[test]
 fn formatting_replacement_wraps_selected_text() {
@@ -37,3 +37,31 @@
     assert_eq!(new_value, "he****llo");
     assert_eq!(new_selection, 4..4);
 }
+
+#[test]
+fn test_resolve_selected_note_returns_none_when_selection_is_missing() {
+    let notes = vec![Note::with_content("one"), Note::with_content("two")];
+
+    let selected = NotesApp::resolve_selected_note(None, &notes);
+
+    assert!(selected.is_none());
+}
+
+#[test]
+fn test_resolve_selected_note_returns_none_when_selection_is_stale() {
+    let notes = vec![Note::with_content("one"), Note::with_content("two")];
+
+    let selected = NotesApp::resolve_selected_note(Some(NoteId::new()), &notes);
+
+    assert!(selected.is_none());
+}
+
+#[test]
+fn test_resolve_selected_note_returns_note_when_selection_exists() {
+    let notes = vec![Note::with_content("one"), Note::with_content("two")];
+    let selected_id = notes[1].id;
+
+    let selected = NotesApp::resolve_selected_note(Some(selected_id), &notes);
+
+    assert_eq!(selected.map(|(id, note)| (id, note.id)), Some((selected_id, selected_id)));
+}

file update:
diff --git a/src/notes/window/notes.rs b/src/notes/window/notes.rs
index 2b96e1be9f619ad7fa8b88d1287b653adb4780b4..449ab857a161bcb00618adf6e45ab022a3ac86fe
--- a/src/notes/window/notes.rs
+++ b/src/notes/window/notes.rs
@@ -231,42 +231,42 @@
     }
 
     /// Export the current note
-    pub(super) fn export_note(&self, format: ExportFormat) {
-        if let Some(id) = self.selected_note_id {
-            if let Some(note) = self.notes.iter().find(|n| n.id == id) {
-                let content = match format {
-                    ExportFormat::PlainText => note.content.clone(),
-                    // For Markdown, just export the content as-is.
-                    // The title is derived from the first line of content,
-                    // so prepending it would cause duplication.
-                    ExportFormat::Markdown => note.content.clone(),
-                    ExportFormat::Html => {
-                        // For HTML, we include proper structure with the title
-                        // and render the content as preformatted text
-                        format!(
-                            "<!DOCTYPE html>\n<html>\n<head><title>{}</title></head>\n<body>\n<h1>{}</h1>\n<pre>{}</pre>\n</body>\n</html>",
-                            note.title, note.title, note.content
-                        )
-                    }
-                };
+    pub(super) fn export_note(&mut self, format: ExportFormat) {
+        let Some((_id, note)) = self.selected_note_for_action("export_note") else {
+            return;
+        };
 
-                // Copy to clipboard
-                #[cfg(target_os = "macos")]
-                {
-                    use std::process::Command;
-                    let _ = Command::new("pbcopy")
-                        .stdin(std::process::Stdio::piped())
-                        .spawn()
-                        .and_then(|mut child| {
-                            use std::io::Write;
-                            if let Some(stdin) = child.stdin.as_mut() {
-                                stdin.write_all(content.as_bytes())?;
-                            }
-                            child.wait()
-                        });
-                    info!(format = ?format, "Note exported to clipboard");
-                }
+        let content = match format {
+            ExportFormat::PlainText => note.content.clone(),
+            // For Markdown, just export the content as-is.
+            // The title is derived from the first line of content,
+            // so prepending it would cause duplication.
+            ExportFormat::Markdown => note.content.clone(),
+            ExportFormat::Html => {
+                // For HTML, we include proper structure with the title
+                // and render the content as preformatted text
+                format!(
+                    "<!DOCTYPE html>\n<html>\n<head><title>{}</title></head>\n<body>\n<h1>{}</h1>\n<pre>{}</pre>\n</body>\n</html>",
+                    note.title, note.title, note.content
+                )
             }
+        };
+
+        // Copy to clipboard
+        #[cfg(target_os = "macos")]
+        {
+            use std::process::Command;
+            let _ = Command::new("pbcopy")
+                .stdin(std::process::Stdio::piped())
+                .spawn()
+                .and_then(|mut child| {
+                    use std::io::Write;
+                    if let Some(stdin) = child.stdin.as_mut() {
+                        stdin.write_all(content.as_bytes())?;
+                    }
+                    child.wait()
+                });
+            info!(format = ?format, "Note exported to clipboard");
         }
     }
 }
diff --git a/src/notes/window/notes_actions.rs b/src/notes/window/notes_actions.rs
index 6405519cffd92b2252b2e410eb3f58ee37800b8d..6d16c492f61a4be231c5a86328a3b9c14112bb7c
--- a/src/notes/window/notes_actions.rs
+++ b/src/notes/window/notes_actions.rs
@@ -1,6 +1,46 @@
 use super::*;
 
 impl NotesApp {
+    const SELECTED_NOTE_NOT_FOUND_FEEDBACK: &'static str = "Selected note could not be found";
+
+    pub(super) fn resolve_selected_note(
+        selected_note_id: Option<NoteId>,
+        notes: &[Note],
+    ) -> Option<(NoteId, &Note)> {
+        let selected_note_id = selected_note_id?;
+        notes
+            .iter()
+            .find(|note| note.id == selected_note_id)
+            .map(|note| (selected_note_id, note))
+    }
+
+    pub(super) fn show_selected_note_missing_feedback(&mut self, action: &'static str) {
+        tracing::warn!(
+            action,
+            selected_note_id = ?self.selected_note_id,
+            notes_len = self.notes.len(),
+            "notes_action_selected_note_not_found",
+        );
+        self.show_action_feedback(Self::SELECTED_NOTE_NOT_FOUND_FEEDBACK, true);
+    }
+
+    pub(super) fn selected_note_for_action(
+        &mut self,
+        action: &'static str,
+    ) -> Option<(NoteId, &Note)> {
+        let Some(selected_note_id) = self.selected_note_id else {
+            self.show_selected_note_missing_feedback(action);
+            return None;
+        };
+
+        if !self.notes.iter().any(|note| note.id == selected_note_id) {
+            self.show_selected_note_missing_feedback(action);
+            return None;
+        }
+
+        Self::resolve_selected_note(Some(selected_note_id), &self.notes)
+    }
+
     /// Cycle sort mode: Updated → Created → Alphabetical → Updated
     pub(super) fn cycle_sort_mode(&mut self, cx: &mut Context<Self>) {
         self.sort_mode = match self.sort_mode {
@@ -86,42 +126,34 @@
         format!("scriptkit://notes/{}", id.as_str())
     }
 
-    pub(super) fn copy_note_as_markdown(&self) {
+    pub(super) fn copy_note_as_markdown(&mut self) {
         self.export_note(ExportFormat::Markdown);
     }
 
-    pub(super) fn copy_note_deeplink(&self) {
-        if let Some(id) = self.selected_note_id {
-            let deeplink = self.note_deeplink(id);
-            self.copy_text_to_clipboard(&deeplink);
-        }
+    pub(super) fn copy_note_deeplink(&mut self) {
+        let Some((id, _)) = self.selected_note_for_action("copy_note_deeplink") else {
+            return;
+        };
+        let deeplink = self.note_deeplink(id);
+        self.copy_text_to_clipboard(&deeplink);
     }
 
-    pub(super) fn create_note_quicklink(&self) {
-        if let Some(id) = self.selected_note_id {
-            let title = self
-                .notes
-                .iter()
-                .find(|note| note.id == id)
-                .map(|note| {
-                    if note.title.is_empty() {
-                        "Untitled Note".to_string()
-                    } else {
-                        note.title.clone()
-                    }
-                })
-                .unwrap_or_else(|| "Untitled Note".to_string());
-            let deeplink = self.note_deeplink(id);
-            let quicklink = format!("[{}]({})", title, deeplink);
-            self.copy_text_to_clipboard(&quicklink);
-        }
+    pub(super) fn create_note_quicklink(&mut self) {
+        let Some((id, note)) = self.selected_note_for_action("create_note_quicklink") else {
+            return;
+        };
+        let title = if note.title.is_empty() {
+            "Untitled Note".to_string()
+        } else {
+            note.title.clone()
+        };
+        let deeplink = self.note_deeplink(id);
+        let quicklink = format!("[{}]({})", title, deeplink);
+        self.copy_text_to_clipboard(&quicklink);
     }
 
     pub(super) fn duplicate_selected_note(&mut self, window: &mut Window, cx: &mut Context<Self>) {
-        let Some(id) = self.selected_note_id else {
-            return;
-        };
-        let Some(note) = self.notes.iter().find(|note| note.id == id) else {
+        let Some((_id, note)) = self.selected_note_for_action("duplicate_selected_note") else {
             return;
         };
 
diff --git a/src/notes/window/panels.rs b/src/notes/window/panels.rs
index 16b4b85b9be89780b4c9430f0db050a9af14532e..b843238a1e9103f6055702cf09dc506f1e99fa17
--- a/src/notes/window/panels.rs
+++ b/src/notes/window/panels.rs
@@ -281,6 +281,17 @@
                 self.select_note(note_id, window, cx);
                 return;
             }
+
+            tracing::warn!(
+                action_id,
+                note_id_str,
+                selected_note_id = ?self.selected_note_id,
+                notes_len = self.notes.len(),
+                "notes_note_switcher_selected_note_not_found",
+            );
+            self.show_selected_note_missing_feedback("execute_note_switcher_action");
+            self.close_browse_panel(window, cx);
+            return;
         }
 
         // Handle "no_notes" placeholder action
diff --git a/src/notes/window/tests.rs b/src/notes/window/tests.rs
index 8cb070d17ec066ba2b9e5a81de39cf1dfd19742b..441dc8b615019a2f05ba8f031d6bad5a449dd4a1
--- a/src/notes/window/tests.rs
+++ b/src/notes/window/tests.rs
@@ -1,4 +1,4 @@
-use super::NotesApp;
+use super::{Note, NoteId, NotesApp};
 
 #[test]
 fn formatting_replacement_wraps_selected_text() {
@@ -37,3 +37,31 @@
     assert_eq!(new_value, "he****llo");
     assert_eq!(new_selection, 4..4);
 }
+
+#[test]
+fn test_resolve_selected_note_returns_none_when_selection_is_missing() {
+    let notes = vec![Note::with_content("one"), Note::with_content("two")];
+
+    let selected = NotesApp::resolve_selected_note(None, &notes);
+
+    assert!(selected.is_none());
+}
+
+#[test]
+fn test_resolve_selected_note_returns_none_when_selection_is_stale() {
+    let notes = vec![Note::with_content("one"), Note::with_content("two")];
+
+    let selected = NotesApp::resolve_selected_note(Some(NoteId::new()), &notes);
+
+    assert!(selected.is_none());
+}
+
+#[test]
+fn test_resolve_selected_note_returns_note_when_selection_exists() {
+    let notes = vec![Note::with_content("one"), Note::with_content("two")];
+    let selected_id = notes[1].id;
+
+    let selected = NotesApp::resolve_selected_note(Some(selected_id), &notes);
+
+    assert_eq!(selected.map(|(id, note)| (id, note.id)), Some((selected_id, selected_id)));
+}

file update:
diff --git a/src/notes/window/notes.rs b/src/notes/window/notes.rs
index 2b96e1be9f619ad7fa8b88d1287b653adb4780b4..449ab857a161bcb00618adf6e45ab022a3ac86fe
--- a/src/notes/window/notes.rs
+++ b/src/notes/window/notes.rs
@@ -231,42 +231,42 @@
     }
 
     /// Export the current note
-    pub(super) fn export_note(&self, format: ExportFormat) {
-        if let Some(id) = self.selected_note_id {
-            if let Some(note) = self.notes.iter().find(|n| n.id == id) {
-                let content = match format {
-                    ExportFormat::PlainText => note.content.clone(),
-                    // For Markdown, just export the content as-is.
-                    // The title is derived from the first line of content,
-                    // so prepending it would cause duplication.
-                    ExportFormat::Markdown => note.content.clone(),
-                    ExportFormat::Html => {
-                        // For HTML, we include proper structure with the title
-                        // and render the content as preformatted text
-                        format!(
-                            "<!DOCTYPE html>\n<html>\n<head><title>{}</title></head>\n<body>\n<h1>{}</h1>\n<pre>{}</pre>\n</body>\n</html>",
-                            note.title, note.title, note.content
-                        )
-                    }
-                };
+    pub(super) fn export_note(&mut self, format: ExportFormat) {
+        let Some((_id, note)) = self.selected_note_for_action("export_note") else {
+            return;
+        };
 
-                // Copy to clipboard
-                #[cfg(target_os = "macos")]
-                {
-                    use std::process::Command;
-                    let _ = Command::new("pbcopy")
-                        .stdin(std::process::Stdio::piped())
-                        .spawn()
-                        .and_then(|mut child| {
-                            use std::io::Write;
-                            if let Some(stdin) = child.stdin.as_mut() {
-                                stdin.write_all(content.as_bytes())?;
-                            }
-                            child.wait()
-                        });
-                    info!(format = ?format, "Note exported to clipboard");
-                }
+        let content = match format {
+            ExportFormat::PlainText => note.content.clone(),
+            // For Markdown, just export the content as-is.
+            // The title is derived from the first line of content,
+            // so prepending it would cause duplication.
+            ExportFormat::Markdown => note.content.clone(),
+            ExportFormat::Html => {
+                // For HTML, we include proper structure with the title
+                // and render the content as preformatted text
+                format!(
+                    "<!DOCTYPE html>\n<html>\n<head><title>{}</title></head>\n<body>\n<h1>{}</h1>\n<pre>{}</pre>\n</body>\n</html>",
+                    note.title, note.title, note.content
+                )
             }
+        };
+
+        // Copy to clipboard
+        #[cfg(target_os = "macos")]
+        {
+            use std::process::Command;
+            let _ = Command::new("pbcopy")
+                .stdin(std::process::Stdio::piped())
+                .spawn()
+                .and_then(|mut child| {
+                    use std::io::Write;
+                    if let Some(stdin) = child.stdin.as_mut() {
+                        stdin.write_all(content.as_bytes())?;
+                    }
+                    child.wait()
+                });
+            info!(format = ?format, "Note exported to clipboard");
         }
     }
 }
diff --git a/src/notes/window/notes_actions.rs b/src/notes/window/notes_actions.rs
index 6405519cffd92b2252b2e410eb3f58ee37800b8d..6d16c492f61a4be231c5a86328a3b9c14112bb7c
--- a/src/notes/window/notes_actions.rs
+++ b/src/notes/window/notes_actions.rs
@@ -1,6 +1,46 @@
 use super::*;
 
 impl NotesApp {
+    const SELECTED_NOTE_NOT_FOUND_FEEDBACK: &'static str = "Selected note could not be found";
+
+    pub(super) fn resolve_selected_note(
+        selected_note_id: Option<NoteId>,
+        notes: &[Note],
+    ) -> Option<(NoteId, &Note)> {
+        let selected_note_id = selected_note_id?;
+        notes
+            .iter()
+            .find(|note| note.id == selected_note_id)
+            .map(|note| (selected_note_id, note))
+    }
+
+    pub(super) fn show_selected_note_missing_feedback(&mut self, action: &'static str) {
+        tracing::warn!(
+            action,
+            selected_note_id = ?self.selected_note_id,
+            notes_len = self.notes.len(),
+            "notes_action_selected_note_not_found",
+        );
+        self.show_action_feedback(Self::SELECTED_NOTE_NOT_FOUND_FEEDBACK, true);
+    }
+
+    pub(super) fn selected_note_for_action(
+        &mut self,
+        action: &'static str,
+    ) -> Option<(NoteId, &Note)> {
+        let Some(selected_note_id) = self.selected_note_id else {
+            self.show_selected_note_missing_feedback(action);
+            return None;
+        };
+
+        if !self.notes.iter().any(|note| note.id == selected_note_id) {
+            self.show_selected_note_missing_feedback(action);
+            return None;
+        }
+
+        Self::resolve_selected_note(Some(selected_note_id), &self.notes)
+    }
+
     /// Cycle sort mode: Updated → Created → Alphabetical → Updated
     pub(super) fn cycle_sort_mode(&mut self, cx: &mut Context<Self>) {
         self.sort_mode = match self.sort_mode {
@@ -86,42 +126,34 @@
         format!("scriptkit://notes/{}", id.as_str())
     }
 
-    pub(super) fn copy_note_as_markdown(&self) {
+    pub(super) fn copy_note_as_markdown(&mut self) {
         self.export_note(ExportFormat::Markdown);
     }
 
-    pub(super) fn copy_note_deeplink(&self) {
-        if let Some(id) = self.selected_note_id {
-            let deeplink = self.note_deeplink(id);
-            self.copy_text_to_clipboard(&deeplink);
-        }
+    pub(super) fn copy_note_deeplink(&mut self) {
+        let Some((id, _)) = self.selected_note_for_action("copy_note_deeplink") else {
+            return;
+        };
+        let deeplink = self.note_deeplink(id);
+        self.copy_text_to_clipboard(&deeplink);
     }
 
-    pub(super) fn create_note_quicklink(&self) {
-        if let Some(id) = self.selected_note_id {
-            let title = self
-                .notes
-                .iter()
-                .find(|note| note.id == id)
-                .map(|note| {
-                    if note.title.is_empty() {
-                        "Untitled Note".to_string()
-                    } else {
-                        note.title.clone()
-                    }
-                })
-                .unwrap_or_else(|| "Untitled Note".to_string());
-            let deeplink = self.note_deeplink(id);
-            let quicklink = format!("[{}]({})", title, deeplink);
-            self.copy_text_to_clipboard(&quicklink);
-        }
+    pub(super) fn create_note_quicklink(&mut self) {
+        let Some((id, note)) = self.selected_note_for_action("create_note_quicklink") else {
+            return;
+        };
+        let title = if note.title.is_empty() {
+            "Untitled Note".to_string()
+        } else {
+            note.title.clone()
+        };
+        let deeplink = self.note_deeplink(id);
+        let quicklink = format!("[{}]({})", title, deeplink);
+        self.copy_text_to_clipboard(&quicklink);
     }
 
     pub(super) fn duplicate_selected_note(&mut self, window: &mut Window, cx: &mut Context<Self>) {
-        let Some(id) = self.selected_note_id else {
-            return;
-        };
-        let Some(note) = self.notes.iter().find(|note| note.id == id) else {
+        let Some((_id, note)) = self.selected_note_for_action("duplicate_selected_note") else {
             return;
         };
 
diff --git a/src/notes/window/panels.rs b/src/notes/window/panels.rs
index 16b4b85b9be89780b4c9430f0db050a9af14532e..b843238a1e9103f6055702cf09dc506f1e99fa17
--- a/src/notes/window/panels.rs
+++ b/src/notes/window/panels.rs
@@ -281,6 +281,17 @@
                 self.select_note(note_id, window, cx);
                 return;
             }
+
+            tracing::warn!(
+                action_id,
+                note_id_str,
+                selected_note_id = ?self.selected_note_id,
+                notes_len = self.notes.len(),
+                "notes_note_switcher_selected_note_not_found",
+            );
+            self.show_selected_note_missing_feedback("execute_note_switcher_action");
+            self.close_browse_panel(window, cx);
+            return;
         }
 
         // Handle "no_notes" placeholder action
diff --git a/src/notes/window/tests.rs b/src/notes/window/tests.rs
index 8cb070d17ec066ba2b9e5a81de39cf1dfd19742b..441dc8b615019a2f05ba8f031d6bad5a449dd4a1
--- a/src/notes/window/tests.rs
+++ b/src/notes/window/tests.rs
@@ -1,4 +1,4 @@
-use super::NotesApp;
+use super::{Note, NoteId, NotesApp};
 
 #[test]
 fn formatting_replacement_wraps_selected_text() {
@@ -37,3 +37,31 @@
     assert_eq!(new_value, "he****llo");
     assert_eq!(new_selection, 4..4);
 }
+
+#[test]
+fn test_resolve_selected_note_returns_none_when_selection_is_missing() {
+    let notes = vec![Note::with_content("one"), Note::with_content("two")];
+
+    let selected = NotesApp::resolve_selected_note(None, &notes);
+
+    assert!(selected.is_none());
+}
+
+#[test]
+fn test_resolve_selected_note_returns_none_when_selection_is_stale() {
+    let notes = vec![Note::with_content("one"), Note::with_content("two")];
+
+    let selected = NotesApp::resolve_selected_note(Some(NoteId::new()), &notes);
+
+    assert!(selected.is_none());
+}
+
+#[test]
+fn test_resolve_selected_note_returns_note_when_selection_exists() {
+    let notes = vec![Note::with_content("one"), Note::with_content("two")];
+    let selected_id = notes[1].id;
+
+    let selected = NotesApp::resolve_selected_note(Some(selected_id), &notes);
+
+    assert_eq!(selected.map(|(id, note)| (id, note.id)), Some((selected_id, selected_id)));
+}

 succeeded in 14.75s:
196:error[E0063]: missing fields `source_app_bundle_id` and `source_app_name` in initializer of `clipboard_history::types::ClipboardEntry`
202:error[E0063]: missing fields `source_app_bundle_id` and `source_app_name` in initializer of `clipboard_history::types::ClipboardEntry`
208:error[E0063]: missing fields `source_app_bundle_id` and `source_app_name` in initializer of `clipboard_history::types::ClipboardEntry`
214:error[E0063]: missing fields `source_app_bundle_id` and `source_app_name` in initializer of `clipboard_history::types::ClipboardEntry`
226:error[E0004]: non-exhaustive patterns: `ContentType::Link`, `ContentType::File` and `ContentType::Color` not covered
251:error[E0004]: non-exhaustive patterns: `ContentType::Link`, `ContentType::File` and `ContentType::Color` not covered
276:error[E0004]: non-exhaustive patterns: `ContentType::Link`, `ContentType::File` and `ContentType::Color` not covered
301:error[E0004]: non-exhaustive patterns: `ContentType::Link`, `ContentType::File` and `ContentType::Color` not covered
326:error[E0004]: non-exhaustive patterns: `ContentType::Link`, `ContentType::File` and `ContentType::Color` not covered

thinking
**Planning clippy run despite failures**
exec
/bin/zsh -lc 'cargo clippy -p script-kit-gpui --all-targets -- -D warnings' in /Users/johnlindquist/dev/script-kit-gpuifile update:
diff --git a/src/notes/window/notes.rs b/src/notes/window/notes.rs
index 2b96e1be9f619ad7fa8b88d1287b653adb4780b4..449ab857a161bcb00618adf6e45ab022a3ac86fe
--- a/src/notes/window/notes.rs
+++ b/src/notes/window/notes.rs
@@ -231,42 +231,42 @@
     }
 
     /// Export the current note
-    pub(super) fn export_note(&self, format: ExportFormat) {
-        if let Some(id) = self.selected_note_id {
-            if let Some(note) = self.notes.iter().find(|n| n.id == id) {
-                let content = match format {
-                    ExportFormat::PlainText => note.content.clone(),
-                    // For Markdown, just export the content as-is.
-                    // The title is derived from the first line of content,
-                    // so prepending it would cause duplication.
-                    ExportFormat::Markdown => note.content.clone(),
-                    ExportFormat::Html => {
-                        // For HTML, we include proper structure with the title
-                        // and render the content as preformatted text
-                        format!(
-                            "<!DOCTYPE html>\n<html>\n<head><title>{}</title></head>\n<body>\n<h1>{}</h1>\n<pre>{}</pre>\n</body>\n</html>",
-                            note.title, note.title, note.content
-                        )
-                    }
-                };
+    pub(super) fn export_note(&mut self, format: ExportFormat) {
+        let Some((_id, note)) = self.selected_note_for_action("export_note") else {
+            return;
+        };
 
-                // Copy to clipboard
-                #[cfg(target_os = "macos")]
-                {
-                    use std::process::Command;
-                    let _ = Command::new("pbcopy")
-                        .stdin(std::process::Stdio::piped())
-                        .spawn()
-                        .and_then(|mut child| {
-                            use std::io::Write;
-                            if let Some(stdin) = child.stdin.as_mut() {
-                                stdin.write_all(content.as_bytes())?;
-                            }
-                            child.wait()
-                        });
-                    info!(format = ?format, "Note exported to clipboard");
-                }
+        let content = match format {
+            ExportFormat::PlainText => note.content.clone(),
+            // For Markdown, just export the content as-is.
+            // The title is derived from the first line of content,
+            // so prepending it would cause duplication.
+            ExportFormat::Markdown => note.content.clone(),
+            ExportFormat::Html => {
+                // For HTML, we include proper structure with the title
+                // and render the content as preformatted text
+                format!(
+                    "<!DOCTYPE html>\n<html>\n<head><title>{}</title></head>\n<body>\n<h1>{}</h1>\n<pre>{}</pre>\n</body>\n</html>",
+                    note.title, note.title, note.content
+                )
             }
+        };
+
+        // Copy to clipboard
+        #[cfg(target_os = "macos")]
+        {
+            use std::process::Command;
+            let _ = Command::new("pbcopy")
+                .stdin(std::process::Stdio::piped())
+                .spawn()
+                .and_then(|mut child| {
+                    use std::io::Write;
+                    if let Some(stdin) = child.stdin.as_mut() {
+                        stdin.write_all(content.as_bytes())?;
+                    }
+                    child.wait()
+                });
+            info!(format = ?format, "Note exported to clipboard");
         }
     }
 }
diff --git a/src/notes/window/notes_actions.rs b/src/notes/window/notes_actions.rs
index 6405519cffd92b2252b2e410eb3f58ee37800b8d..6d16c492f61a4be231c5a86328a3b9c14112bb7c
--- a/src/notes/window/notes_actions.rs
+++ b/src/notes/window/notes_actions.rs
@@ -1,6 +1,46 @@
 use super::*;
 
 impl NotesApp {
+    const SELECTED_NOTE_NOT_FOUND_FEEDBACK: &'static str = "Selected note could not be found";
+
+    pub(super) fn resolve_selected_note(
+        selected_note_id: Option<NoteId>,
+        notes: &[Note],
+    ) -> Option<(NoteId, &Note)> {
+        let selected_note_id = selected_note_id?;
+        notes
+            .iter()
+            .find(|note| note.id == selected_note_id)
+            .map(|note| (selected_note_id, note))
+    }
+
+    pub(super) fn show_selected_note_missing_feedback(&mut self, action: &'static str) {
+        tracing::warn!(
+            action,
+            selected_note_id = ?self.selected_note_id,
+            notes_len = self.notes.len(),
+            "notes_action_selected_note_not_found",
+        );
+        self.show_action_feedback(Self::SELECTED_NOTE_NOT_FOUND_FEEDBACK, true);
+    }
+
+    pub(super) fn selected_note_for_action(
+        &mut self,
+        action: &'static str,
+    ) -> Option<(NoteId, &Note)> {
+        let Some(selected_note_id) = self.selected_note_id else {
+            self.show_selected_note_missing_feedback(action);
+            return None;
+        };
+
+        if !self.notes.iter().any(|note| note.id == selected_note_id) {
+            self.show_selected_note_missing_feedback(action);
+            return None;
+        }
+
+        Self::resolve_selected_note(Some(selected_note_id), &self.notes)
+    }
+
     /// Cycle sort mode: Updated → Created → Alphabetical → Updated
     pub(super) fn cycle_sort_mode(&mut self, cx: &mut Context<Self>) {
         self.sort_mode = match self.sort_mode {
@@ -86,42 +126,34 @@
         format!("scriptkit://notes/{}", id.as_str())
     }
 
-    pub(super) fn copy_note_as_markdown(&self) {
+    pub(super) fn copy_note_as_markdown(&mut self) {
         self.export_note(ExportFormat::Markdown);
     }
 
-    pub(super) fn copy_note_deeplink(&self) {
-        if let Some(id) = self.selected_note_id {
-            let deeplink = self.note_deeplink(id);
-            self.copy_text_to_clipboard(&deeplink);
-        }
+    pub(super) fn copy_note_deeplink(&mut self) {
+        let Some((id, _)) = self.selected_note_for_action("copy_note_deeplink") else {
+            return;
+        };
+        let deeplink = self.note_deeplink(id);
+        self.copy_text_to_clipboard(&deeplink);
     }
 
-    pub(super) fn create_note_quicklink(&self) {
-        if let Some(id) = self.selected_note_id {
-            let title = self
-                .notes
-                .iter()
-                .find(|note| note.id == id)
-                .map(|note| {
-                    if note.title.is_empty() {
-                        "Untitled Note".to_string()
-                    } else {
-                        note.title.clone()
-                    }
-                })
-                .unwrap_or_else(|| "Untitled Note".to_string());
-            let deeplink = self.note_deeplink(id);
-            let quicklink = format!("[{}]({})", title, deeplink);
-            self.copy_text_to_clipboard(&quicklink);
-        }
+    pub(super) fn create_note_quicklink(&mut self) {
+        let Some((id, note)) = self.selected_note_for_action("create_note_quicklink") else {
+            return;
+        };
+        let title = if note.title.is_empty() {
+            "Untitled Note".to_string()
+        } else {
+            note.title.clone()
+        };
+        let deeplink = self.note_deeplink(id);
+        let quicklink = format!("[{}]({})", title, deeplink);
+        self.copy_text_to_clipboard(&quicklink);
     }
 
     pub(super) fn duplicate_selected_note(&mut self, window: &mut Window, cx: &mut Context<Self>) {
-        let Some(id) = self.selected_note_id else {
-            return;
-        };
-        let Some(note) = self.notes.iter().find(|note| note.id == id) else {
+        let Some((_id, note)) = self.selected_note_for_action("duplicate_selected_note") else {
             return;
         };
 
diff --git a/src/notes/window/panels.rs b/src/notes/window/panels.rs
index 16b4b85b9be89780b4c9430f0db050a9af14532e..b843238a1e9103f6055702cf09dc506f1e99fa17
--- a/src/notes/window/panels.rs
+++ b/src/notes/window/panels.rs
@@ -281,6 +281,17 @@
                 self.select_note(note_id, window, cx);
                 return;
             }
+
+            tracing::warn!(
+                action_id,
+                note_id_str,
+                selected_note_id = ?self.selected_note_id,
+                notes_len = self.notes.len(),
+                "notes_note_switcher_selected_note_not_found",
+            );
+            self.show_selected_note_missing_feedback("execute_note_switcher_action");
+            self.close_browse_panel(window, cx);
+            return;
         }
 
         // Handle "no_notes" placeholder action
diff --git a/src/notes/window/tests.rs b/src/notes/window/tests.rs
index 8cb070d17ec066ba2b9e5a81de39cf1dfd19742b..441dc8b615019a2f05ba8f031d6bad5a449dd4a1
--- a/src/notes/window/tests.rs
+++ b/src/notes/window/tests.rs
@@ -1,4 +1,4 @@
-use super::NotesApp;
+use super::{Note, NoteId, NotesApp};
 
 #[test]
 fn formatting_replacement_wraps_selected_text() {
@@ -37,3 +37,31 @@
     assert_eq!(new_value, "he****llo");
     assert_eq!(new_selection, 4..4);
 }
+
+#[test]
+fn test_resolve_selected_note_returns_none_when_selection_is_missing() {
+    let notes = vec![Note::with_content("one"), Note::with_content("two")];
+
+    let selected = NotesApp::resolve_selected_note(None, &notes);
+
+    assert!(selected.is_none());
+}
+
+#[test]
+fn test_resolve_selected_note_returns_none_when_selection_is_stale() {
+    let notes = vec![Note::with_content("one"), Note::with_content("two")];
+
+    let selected = NotesApp::resolve_selected_note(Some(NoteId::new()), &notes);
+
+    assert!(selected.is_none());
+}
+
+#[test]
+fn test_resolve_selected_note_returns_note_when_selection_exists() {
+    let notes = vec![Note::with_content("one"), Note::with_content("two")];
+    let selected_id = notes[1].id;
+
+    let selected = NotesApp::resolve_selected_note(Some(selected_id), &notes);
+
+    assert_eq!(selected.map(|(id, note)| (id, note.id)), Some((selected_id, selected_id)));
+}

file update:
diff --git a/src/notes/window/notes.rs b/src/notes/window/notes.rs
index 2b96e1be9f619ad7fa8b88d1287b653adb4780b4..449ab857a161bcb00618adf6e45ab022a3ac86fe
--- a/src/notes/window/notes.rs
+++ b/src/notes/window/notes.rs
@@ -231,42 +231,42 @@
     }
 
     /// Export the current note
-    pub(super) fn export_note(&self, format: ExportFormat) {
-        if let Some(id) = self.selected_note_id {
-            if let Some(note) = self.notes.iter().find(|n| n.id == id) {
-                let content = match format {
-                    ExportFormat::PlainText => note.content.clone(),
-                    // For Markdown, just export the content as-is.
-                    // The title is derived from the first line of content,
-                    // so prepending it would cause duplication.
-                    ExportFormat::Markdown => note.content.clone(),
-                    ExportFormat::Html => {
-                        // For HTML, we include proper structure with the title
-                        // and render the content as preformatted text
-                        format!(
-                            "<!DOCTYPE html>\n<html>\n<head><title>{}</title></head>\n<body>\n<h1>{}</h1>\n<pre>{}</pre>\n</body>\n</html>",
-                            note.title, note.title, note.content
-                        )
-                    }
-                };
+    pub(super) fn export_note(&mut self, format: ExportFormat) {
+        let Some((_id, note)) = self.selected_note_for_action("export_note") else {
+            return;
+        };
 
-                // Copy to clipboard
-                #[cfg(target_os = "macos")]
-                {
-                    use std::process::Command;
-                    let _ = Command::new("pbcopy")
-                        .stdin(std::process::Stdio::piped())
-                        .spawn()
-                        .and_then(|mut child| {
-                            use std::io::Write;
-                            if let Some(stdin) = child.stdin.as_mut() {
-                                stdin.write_all(content.as_bytes())?;
-                            }
-                            child.wait()
-                        });
-                    info!(format = ?format, "Note exported to clipboard");
-                }
+        let content = match format {
+            ExportFormat::PlainText => note.content.clone(),
+            // For Markdown, just export the content as-is.
+            // The title is derived from the first line of content,
+            // so prepending it would cause duplication.
+            ExportFormat::Markdown => note.content.clone(),
+            ExportFormat::Html => {
+                // For HTML, we include proper structure with the title
+                // and render the content as preformatted text
+                format!(
+                    "<!DOCTYPE html>\n<html>\n<head><title>{}</title></head>\n<body>\n<h1>{}</h1>\n<pre>{}</pre>\n</body>\n</html>",
+                    note.title, note.title, note.content
+                )
             }
+        };
+
+        // Copy to clipboard
+        #[cfg(target_os = "macos")]
+        {
+            use std::process::Command;
+            let _ = Command::new("pbcopy")
+                .stdin(std::process::Stdio::piped())
+                .spawn()
+                .and_then(|mut child| {
+                    use std::io::Write;
+                    if let Some(stdin) = child.stdin.as_mut() {
+                        stdin.write_all(content.as_bytes())?;
+                    }
+                    child.wait()
+                });
+            info!(format = ?format, "Note exported to clipboard");
         }
     }
 }
diff --git a/src/notes/window/notes_actions.rs b/src/notes/window/notes_actions.rs
index 6405519cffd92b2252b2e410eb3f58ee37800b8d..6d16c492f61a4be231c5a86328a3b9c14112bb7c
--- a/src/notes/window/notes_actions.rs
+++ b/src/notes/window/notes_actions.rs
@@ -1,6 +1,46 @@
 use super::*;
 
 impl NotesApp {
+    const SELECTED_NOTE_NOT_FOUND_FEEDBACK: &'static str = "Selected note could not be found";
+
+    pub(super) fn resolve_selected_note(
+        selected_note_id: Option<NoteId>,
+        notes: &[Note],
+    ) -> Option<(NoteId, &Note)> {
+        let selected_note_id = selected_note_id?;
+        notes
+            .iter()
+            .find(|note| note.id == selected_note_id)
+            .map(|note| (selected_note_id, note))
+    }
+
+    pub(super) fn show_selected_note_missing_feedback(&mut self, action: &'static str) {
+        tracing::warn!(
+            action,
+            selected_note_id = ?self.selected_note_id,
+            notes_len = self.notes.len(),
+            "notes_action_selected_note_not_found",
+        );
+        self.show_action_feedback(Self::SELECTED_NOTE_NOT_FOUND_FEEDBACK, true);
+    }
+
+    pub(super) fn selected_note_for_action(
+        &mut self,
+        action: &'static str,
+    ) -> Option<(NoteId, &Note)> {
+        let Some(selected_note_id) = self.selected_note_id else {
+            self.show_selected_note_missing_feedback(action);
+            return None;
+        };
+
+        if !self.notes.iter().any(|note| note.id == selected_note_id) {
+            self.show_selected_note_missing_feedback(action);
+            return None;
+        }
+
+        Self::resolve_selected_note(Some(selected_note_id), &self.notes)
+    }
+
     /// Cycle sort mode: Updated → Created → Alphabetical → Updated
     pub(super) fn cycle_sort_mode(&mut self, cx: &mut Context<Self>) {
         self.sort_mode = match self.sort_mode {
@@ -86,42 +126,34 @@
         format!("scriptkit://notes/{}", id.as_str())
     }
 
-    pub(super) fn copy_note_as_markdown(&self) {
+    pub(super) fn copy_note_as_markdown(&mut self) {
         self.export_note(ExportFormat::Markdown);
     }
 
-    pub(super) fn copy_note_deeplink(&self) {
-        if let Some(id) = self.selected_note_id {
-            let deeplink = self.note_deeplink(id);
-            self.copy_text_to_clipboard(&deeplink);
-        }
+    pub(super) fn copy_note_deeplink(&mut self) {
+        let Some((id, _)) = self.selected_note_for_action("copy_note_deeplink") else {
+            return;
+        };
+        let deeplink = self.note_deeplink(id);
+        self.copy_text_to_clipboard(&deeplink);
     }
 
-    pub(super) fn create_note_quicklink(&self) {
-        if let Some(id) = self.selected_note_id {
-            let title = self
-                .notes
-                .iter()
-                .find(|note| note.id == id)
-                .map(|note| {
-                    if note.title.is_empty() {
-                        "Untitled Note".to_string()
-                    } else {
-                        note.title.clone()
-                    }
-                })
-                .unwrap_or_else(|| "Untitled Note".to_string());
-            let deeplink = self.note_deeplink(id);
-            let quicklink = format!("[{}]({})", title, deeplink);
-            self.copy_text_to_clipboard(&quicklink);
-        }
+    pub(super) fn create_note_quicklink(&mut self) {
+        let Some((id, note)) = self.selected_note_for_action("create_note_quicklink") else {
+            return;
+        };
+        let title = if note.title.is_empty() {
+            "Untitled Note".to_string()
+        } else {
+            note.title.clone()
+        };
+        let deeplink = self.note_deeplink(id);
+        let quicklink = format!("[{}]({})", title, deeplink);
+        self.copy_text_to_clipboard(&quicklink);
     }
 
     pub(super) fn duplicate_selected_note(&mut self, window: &mut Window, cx: &mut Context<Self>) {
-        let Some(id) = self.selected_note_id else {
-            return;
-        };
-        let Some(note) = self.notes.iter().find(|note| note.id == id) else {
+        let Some((_id, note)) = self.selected_note_for_action("duplicate_selected_note") else {
             return;
         };
 
diff --git a/src/notes/window/panels.rs b/src/notes/window/panels.rs
index 16b4b85b9be89780b4c9430f0db050a9af14532e..b843238a1e9103f6055702cf09dc506f1e99fa17
--- a/src/notes/window/panels.rs
+++ b/src/notes/window/panels.rs
@@ -281,6 +281,17 @@
                 self.select_note(note_id, window, cx);
                 return;
             }
+
+            tracing::warn!(
+                action_id,
+                note_id_str,
+                selected_note_id = ?self.selected_note_id,
+                notes_len = self.notes.len(),
+                "notes_note_switcher_selected_note_not_found",
+            );
+            self.show_selected_note_missing_feedback("execute_note_switcher_action");
+            self.close_browse_panel(window, cx);
+            return;
         }
 
         // Handle "no_notes" placeholder action
diff --git a/src/notes/window/tests.rs b/src/notes/window/tests.rs
index 8cb070d17ec066ba2b9e5a81de39cf1dfd19742b..441dc8b615019a2f05ba8f031d6bad5a449dd4a1
--- a/src/notes/window/tests.rs
+++ b/src/notes/window/tests.rs
@@ -1,4 +1,4 @@
-use super::NotesApp;
+use super::{Note, NoteId, NotesApp};
 
 #[test]
 fn formatting_replacement_wraps_selected_text() {
@@ -37,3 +37,31 @@
     assert_eq!(new_value, "he****llo");
     assert_eq!(new_selection, 4..4);
 }
+
+#[test]
+fn test_resolve_selected_note_returns_none_when_selection_is_missing() {
+    let notes = vec![Note::with_content("one"), Note::with_content("two")];
+
+    let selected = NotesApp::resolve_selected_note(None, &notes);
+
+    assert!(selected.is_none());
+}
+
+#[test]
+fn test_resolve_selected_note_returns_none_when_selection_is_stale() {
+    let notes = vec![Note::with_content("one"), Note::with_content("two")];
+
+    let selected = NotesApp::resolve_selected_note(Some(NoteId::new()), &notes);
+
+    assert!(selected.is_none());
+}
+
+#[test]
+fn test_resolve_selected_note_returns_note_when_selection_exists() {
+    let notes = vec![Note::with_content("one"), Note::with_content("two")];
+    let selected_id = notes[1].id;
+
+    let selected = NotesApp::resolve_selected_note(Some(selected_id), &notes);
+
+    assert_eq!(selected.map(|(id, note)| (id, note.id)), Some((selected_id, selected_id)));
+}

file update:
diff --git a/src/notes/window/notes.rs b/src/notes/window/notes.rs
index 2b96e1be9f619ad7fa8b88d1287b653adb4780b4..449ab857a161bcb00618adf6e45ab022a3ac86fe
--- a/src/notes/window/notes.rs
+++ b/src/notes/window/notes.rs
@@ -231,42 +231,42 @@
     }
 
     /// Export the current note
-    pub(super) fn export_note(&self, format: ExportFormat) {
-        if let Some(id) = self.selected_note_id {
-            if let Some(note) = self.notes.iter().find(|n| n.id == id) {
-                let content = match format {
-                    ExportFormat::PlainText => note.content.clone(),
-                    // For Markdown, just export the content as-is.
-                    // The title is derived from the first line of content,
-                    // so prepending it would cause duplication.
-                    ExportFormat::Markdown => note.content.clone(),
-                    ExportFormat::Html => {
-                        // For HTML, we include proper structure with the title
-                        // and render the content as preformatted text
-                        format!(
-                            "<!DOCTYPE html>\n<html>\n<head><title>{}</title></head>\n<body>\n<h1>{}</h1>\n<pre>{}</pre>\n</body>\n</html>",
-                            note.title, note.title, note.content
-                        )
-                    }
-                };
+    pub(super) fn export_note(&mut self, format: ExportFormat) {
+        let Some((_id, note)) = self.selected_note_for_action("export_note") else {
+            return;
+        };
 
-                // Copy to clipboard
-                #[cfg(target_os = "macos")]
-                {
-                    use std::process::Command;
-                    let _ = Command::new("pbcopy")
-                        .stdin(std::process::Stdio::piped())
-                        .spawn()
-                        .and_then(|mut child| {
-                            use std::io::Write;
-                            if let Some(stdin) = child.stdin.as_mut() {
-                                stdin.write_all(content.as_bytes())?;
-                            }
-                            child.wait()
-                        });
-                    info!(format = ?format, "Note exported to clipboard");
-                }
+        let content = match format {
+            ExportFormat::PlainText => note.content.clone(),
+            // For Markdown, just export the content as-is.
+            // The title is derived from the first line of content,
+            // so prepending it would cause duplication.
+            ExportFormat::Markdown => note.content.clone(),
+            ExportFormat::Html => {
+                // For HTML, we include proper structure with the title
+                // and render the content as preformatted text
+                format!(
+                    "<!DOCTYPE html>\n<html>\n<head><title>{}</title></head>\n<body>\n<h1>{}</h1>\n<pre>{}</pre>\n</body>\n</html>",
+                    note.title, note.title, note.content
+                )
             }
+        };
+
+        // Copy to clipboard
+        #[cfg(target_os = "macos")]
+        {
+            use std::process::Command;
+            let _ = Command::new("pbcopy")
+                .stdin(std::process::Stdio::piped())
+                .spawn()
+                .and_then(|mut child| {
+                    use std::io::Write;
+                    if let Some(stdin) = child.stdin.as_mut() {
+                        stdin.write_all(content.as_bytes())?;
+                    }
+                    child.wait()
+                });
+            info!(format = ?format, "Note exported to clipboard");
         }
     }
 }
diff --git a/src/notes/window/notes_actions.rs b/src/notes/window/notes_actions.rs
index 6405519cffd92b2252b2e410eb3f58ee37800b8d..6d16c492f61a4be231c5a86328a3b9c14112bb7c
--- a/src/notes/window/notes_actions.rs
+++ b/src/notes/window/notes_actions.rs
@@ -1,6 +1,46 @@
 use super::*;
 
 impl NotesApp {
+    const SELECTED_NOTE_NOT_FOUND_FEEDBACK: &'static str = "Selected note could not be found";
+
+    pub(super) fn resolve_selected_note(
+        selected_note_id: Option<NoteId>,
+        notes: &[Note],
+    ) -> Option<(NoteId, &Note)> {
+        let selected_note_id = selected_note_id?;
+        notes
+            .iter()
+            .find(|note| note.id == selected_note_id)
+            .map(|note| (selected_note_id, note))
+    }
+
+    pub(super) fn show_selected_note_missing_feedback(&mut self, action: &'static str) {
+        tracing::warn!(
+            action,
+            selected_note_id = ?self.selected_note_id,
+            notes_len = self.notes.len(),
+            "notes_action_selected_note_not_found",
+        );
+        self.show_action_feedback(Self::SELECTED_NOTE_NOT_FOUND_FEEDBACK, true);
+    }
+
+    pub(super) fn selected_note_for_action(
+        &mut self,
+        action: &'static str,
+    ) -> Option<(NoteId, &Note)> {
+        let Some(selected_note_id) = self.selected_note_id else {
+            self.show_selected_note_missing_feedback(action);
+            return None;
+        };
+
+        if !self.notes.iter().any(|note| note.id == selected_note_id) {
+            self.show_selected_note_missing_feedback(action);
+            return None;
+        }
+
+        Self::resolve_selected_note(Some(selected_note_id), &self.notes)
+    }
+
     /// Cycle sort mode: Updated → Created → Alphabetical → Updated
     pub(super) fn cycle_sort_mode(&mut self, cx: &mut Context<Self>) {
         self.sort_mode = match self.sort_mode {
@@ -86,42 +126,34 @@
         format!("scriptkit://notes/{}", id.as_str())
     }
 
-    pub(super) fn copy_note_as_markdown(&self) {
+    pub(super) fn copy_note_as_markdown(&mut self) {
         self.export_note(ExportFormat::Markdown);
     }
 
-    pub(super) fn copy_note_deeplink(&self) {
-        if let Some(id) = self.selected_note_id {
-            let deeplink = self.note_deeplink(id);
-            self.copy_text_to_clipboard(&deeplink);
-        }
+    pub(super) fn copy_note_deeplink(&mut self) {
+        let Some((id, _)) = self.selected_note_for_action("copy_note_deeplink") else {
+            return;
+        };
+        let deeplink = self.note_deeplink(id);
+        self.copy_text_to_clipboard(&deeplink);
     }
 
-    pub(super) fn create_note_quicklink(&self) {
-        if let Some(id) = self.selected_note_id {
-            let title = self
-                .notes
-                .iter()
-                .find(|note| note.id == id)
-                .map(|note| {
-                    if note.title.is_empty() {
-                        "Untitled Note".to_string()
-                    } else {
-                        note.title.clone()
-                    }
-                })
-                .unwrap_or_else(|| "Untitled Note".to_string());
-            let deeplink = self.note_deeplink(id);
-            let quicklink = format!("[{}]({})", title, deeplink);
-            self.copy_text_to_clipboard(&quicklink);
-        }
+    pub(super) fn create_note_quicklink(&mut self) {
+        let Some((id, note)) = self.selected_note_for_action("create_note_quicklink") else {
+            return;
+        };
+        let title = if note.title.is_empty() {
+            "Untitled Note".to_string()
+        } else {
+            note.title.clone()
+        };
+        let deeplink = self.note_deeplink(id);
+        let quicklink = format!("[{}]({})", title, deeplink);
+        self.copy_text_to_clipboard(&quicklink);
     }
 
     pub(super) fn duplicate_selected_note(&mut self, window: &mut Window, cx: &mut Context<Self>) {
-        let Some(id) = self.selected_note_id else {
-            return;
-        };
-        let Some(note) = self.notes.iter().find(|note| note.id == id) else {
+        let Some((_id, note)) = self.selected_note_for_action("duplicate_selected_note") else {
             return;
         };
 
diff --git a/src/notes/window/panels.rs b/src/notes/window/panels.rs
index 16b4b85b9be89780b4c9430f0db050a9af14532e..b843238a1e9103f6055702cf09dc506f1e99fa17
--- a/src/notes/window/panels.rs
+++ b/src/notes/window/panels.rs
@@ -281,6 +281,17 @@
                 self.select_note(note_id, window, cx);
                 return;
             }
+
+            tracing::warn!(
+                action_id,
+                note_id_str,
+                selected_note_id = ?self.selected_note_id,
+                notes_len = self.notes.len(),
+                "notes_note_switcher_selected_note_not_found",
+            );
+            self.show_selected_note_missing_feedback("execute_note_switcher_action");
+            self.close_browse_panel(window, cx);
+            return;
         }
 
         // Handle "no_notes" placeholder action
diff --git a/src/notes/window/tests.rs b/src/notes/window/tests.rs
index 8cb070d17ec066ba2b9e5a81de39cf1dfd19742b..441dc8b615019a2f05ba8f031d6bad5a449dd4a1
--- a/src/notes/window/tests.rs
+++ b/src/notes/window/tests.rs
@@ -1,4 +1,4 @@
-use super::NotesApp;
+use super::{Note, NoteId, NotesApp};
 
 #[test]
 fn formatting_replacement_wraps_selected_text() {
@@ -37,3 +37,31 @@
     assert_eq!(new_value, "he****llo");
     assert_eq!(new_selection, 4..4);
 }
+
+#[test]
+fn test_resolve_selected_note_returns_none_when_selection_is_missing() {
+    let notes = vec![Note::with_content("one"), Note::with_content("two")];
+
+    let selected = NotesApp::resolve_selected_note(None, &notes);
+
+    assert!(selected.is_none());
+}
+
+#[test]
+fn test_resolve_selected_note_returns_none_when_selection_is_stale() {
+    let notes = vec![Note::with_content("one"), Note::with_content("two")];
+
+    let selected = NotesApp::resolve_selected_note(Some(NoteId::new()), &notes);
+
+    assert!(selected.is_none());
+}
+
+#[test]
+fn test_resolve_selected_note_returns_note_when_selection_exists() {
+    let notes = vec![Note::with_content("one"), Note::with_content("two")];
+    let selected_id = notes[1].id;
+
+    let selected = NotesApp::resolve_selected_note(Some(selected_id), &notes);
+
+    assert_eq!(selected.map(|(id, note)| (id, note.id)), Some((selected_id, selected_id)));
+}

file update:
diff --git a/src/notes/window/notes.rs b/src/notes/window/notes.rs
index 2b96e1be9f619ad7fa8b88d1287b653adb4780b4..449ab857a161bcb00618adf6e45ab022a3ac86fe
--- a/src/notes/window/notes.rs
+++ b/src/notes/window/notes.rs
@@ -231,42 +231,42 @@
     }
 
     /// Export the current note
-    pub(super) fn export_note(&self, format: ExportFormat) {
-        if let Some(id) = self.selected_note_id {
-            if let Some(note) = self.notes.iter().find(|n| n.id == id) {
-                let content = match format {
-                    ExportFormat::PlainText => note.content.clone(),
-                    // For Markdown, just export the content as-is.
-                    // The title is derived from the first line of content,
-                    // so prepending it would cause duplication.
-                    ExportFormat::Markdown => note.content.clone(),
-                    ExportFormat::Html => {
-                        // For HTML, we include proper structure with the title
-                        // and render the content as preformatted text
-                        format!(
-                            "<!DOCTYPE html>\n<html>\n<head><title>{}</title></head>\n<body>\n<h1>{}</h1>\n<pre>{}</pre>\n</body>\n</html>",
-                            note.title, note.title, note.content
-                        )
-                    }
-                };
+    pub(super) fn export_note(&mut self, format: ExportFormat) {
+        let Some((_id, note)) = self.selected_note_for_action("export_note") else {
+            return;
+        };
 
-                // Copy to clipboard
-                #[cfg(target_os = "macos")]
-                {
-                    use std::process::Command;
-                    let _ = Command::new("pbcopy")
-                        .stdin(std::process::Stdio::piped())
-                        .spawn()
-                        .and_then(|mut child| {
-                            use std::io::Write;
-                            if let Some(stdin) = child.stdin.as_mut() {
-                                stdin.write_all(content.as_bytes())?;
-                            }
-                            child.wait()
-                        });
-                    info!(format = ?format, "Note exported to clipboard");
-                }
+        let content = match format {
+            ExportFormat::PlainText => note.content.clone(),
+            // For Markdown, just export the content as-is.
+            // The title is derived from the first line of content,
+            // so prepending it would cause duplication.
+            ExportFormat::Markdown => note.content.clone(),
+            ExportFormat::Html => {
+                // For HTML, we include proper structure with the title
+                // and render the content as preformatted text
+                format!(
+                    "<!DOCTYPE html>\n<html>\n<head><title>{}</title></head>\n<body>\n<h1>{}</h1>\n<pre>{}</pre>\n</body>\n</html>",
+                    note.title, note.title, note.content
+                )
             }
+        };
+
+        // Copy to clipboard
+        #[cfg(target_os = "macos")]
+        {
+            use std::process::Command;
+            let _ = Command::new("pbcopy")
+                .stdin(std::process::Stdio::piped())
+                .spawn()
+                .and_then(|mut child| {
+                    use std::io::Write;
+                    if let Some(stdin) = child.stdin.as_mut() {
+                        stdin.write_all(content.as_bytes())?;
+                    }
+                    child.wait()
+                });
+            info!(format = ?format, "Note exported to clipboard");
         }
     }
 }
diff --git a/src/notes/window/notes_actions.rs b/src/notes/window/notes_actions.rs
index 6405519cffd92b2252b2e410eb3f58ee37800b8d..6d16c492f61a4be231c5a86328a3b9c14112bb7c
--- a/src/notes/window/notes_actions.rs
+++ b/src/notes/window/notes_actions.rs
@@ -1,6 +1,46 @@
 use super::*;
 
 impl NotesApp {
+    const SELECTED_NOTE_NOT_FOUND_FEEDBACK: &'static str = "Selected note could not be found";
+
+    pub(super) fn resolve_selected_note(
+        selected_note_id: Option<NoteId>,
+        notes: &[Note],
+    ) -> Option<(NoteId, &Note)> {
+        let selected_note_id = selected_note_id?;
+        notes
+            .iter()
+            .find(|note| note.id == selected_note_id)
+            .map(|note| (selected_note_id, note))
+    }
+
+    pub(super) fn show_selected_note_missing_feedback(&mut self, action: &'static str) {
+        tracing::warn!(
+            action,
+            selected_note_id = ?self.selected_note_id,
+            notes_len = self.notes.len(),
+            "notes_action_selected_note_not_found",
+        );
+        self.show_action_feedback(Self::SELECTED_NOTE_NOT_FOUND_FEEDBACK, true);
+    }
+
+    pub(super) fn selected_note_for_action(
+        &mut self,
+        action: &'static str,
+    ) -> Option<(NoteId, &Note)> {
+        let Some(selected_note_id) = self.selected_note_id else {
+            self.show_selected_note_missing_feedback(action);
+            return None;
+        };
+
+        if !self.notes.iter().any(|note| note.id == selected_note_id) {
+            self.show_selected_note_missing_feedback(action);
+            return None;
+        }
+
+        Self::resolve_selected_note(Some(selected_note_id), &self.notes)
+    }
+
     /// Cycle sort mode: Updated → Created → Alphabetical → Updated
     pub(super) fn cycle_sort_mode(&mut self, cx: &mut Context<Self>) {
         self.sort_mode = match self.sort_mode {
@@ -86,42 +126,34 @@
         format!("scriptkit://notes/{}", id.as_str())
     }
 
-    pub(super) fn copy_note_as_markdown(&self) {
+    pub(super) fn copy_note_as_markdown(&mut self) {
         self.export_note(ExportFormat::Markdown);
     }
 
-    pub(super) fn copy_note_deeplink(&self) {
-        if let Some(id) = self.selected_note_id {
-            let deeplink = self.note_deeplink(id);
-            self.copy_text_to_clipboard(&deeplink);
-        }
+    pub(super) fn copy_note_deeplink(&mut self) {
+        let Some((id, _)) = self.selected_note_for_action("copy_note_deeplink") else {
+            return;
+        };
+        let deeplink = self.note_deeplink(id);
+        self.copy_text_to_clipboard(&deeplink);
     }
 
-    pub(super) fn create_note_quicklink(&self) {
-        if let Some(id) = self.selected_note_id {
-            let title = self
-                .notes
-                .iter()
-                .find(|note| note.id == id)
-                .map(|note| {
-                    if note.title.is_empty() {
-                        "Untitled Note".to_string()
-                    } else {
-                        note.title.clone()
-                    }
-                })
-                .unwrap_or_else(|| "Untitled Note".to_string());
-            let deeplink = self.note_deeplink(id);
-            let quicklink = format!("[{}]({})", title, deeplink);
-            self.copy_text_to_clipboard(&quicklink);
-        }
+    pub(super) fn create_note_quicklink(&mut self) {
+        let Some((id, note)) = self.selected_note_for_action("create_note_quicklink") else {
+            return;
+        };
+        let title = if note.title.is_empty() {
+            "Untitled Note".to_string()
+        } else {
+            note.title.clone()
+        };
+        let deeplink = self.note_deeplink(id);
+        let quicklink = format!("[{}]({})", title, deeplink);
+        self.copy_text_to_clipboard(&quicklink);
     }
 
     pub(super) fn duplicate_selected_note(&mut self, window: &mut Window, cx: &mut Context<Self>) {
-        let Some(id) = self.selected_note_id else {
-            return;
-        };
-        let Some(note) = self.notes.iter().find(|note| note.id == id) else {
+        let Some((_id, note)) = self.selected_note_for_action("duplicate_selected_note") else {
             return;
         };
 
diff --git a/src/notes/window/panels.rs b/src/notes/window/panels.rs
index 16b4b85b9be89780b4c9430f0db050a9af14532e..b843238a1e9103f6055702cf09dc506f1e99fa17
--- a/src/notes/window/panels.rs
+++ b/src/notes/window/panels.rs
@@ -281,6 +281,17 @@
                 self.select_note(note_id, window, cx);
                 return;
             }
+
+            tracing::warn!(
+                action_id,
+                note_id_str,
+                selected_note_id = ?self.selected_note_id,
+                notes_len = self.notes.len(),
+                "notes_note_switcher_selected_note_not_found",
+            );
+            self.show_selected_note_missing_feedback("execute_note_switcher_action");
+            self.close_browse_panel(window, cx);
+            return;
         }
 
         // Handle "no_notes" placeholder action
diff --git a/src/notes/window/tests.rs b/src/notes/window/tests.rs
index 8cb070d17ec066ba2b9e5a81de39cf1dfd19742b..441dc8b615019a2f05ba8f031d6bad5a449dd4a1
--- a/src/notes/window/tests.rs
+++ b/src/notes/window/tests.rs
@@ -1,4 +1,4 @@
-use super::NotesApp;
+use super::{Note, NoteId, NotesApp};
 
 #[test]
 fn formatting_replacement_wraps_selected_text() {
@@ -37,3 +37,31 @@
     assert_eq!(new_value, "he****llo");
     assert_eq!(new_selection, 4..4);
 }
+
+#[test]
+fn test_resolve_selected_note_returns_none_when_selection_is_missing() {
+    let notes = vec![Note::with_content("one"), Note::with_content("two")];
+
+    let selected = NotesApp::resolve_selected_note(None, &notes);
+
+    assert!(selected.is_none());
+}
+
+#[test]
+fn test_resolve_selected_note_returns_none_when_selection_is_stale() {
+    let notes = vec![Note::with_content("one"), Note::with_content("two")];
+
+    let selected = NotesApp::resolve_selected_note(Some(NoteId::new()), &notes);
+
+    assert!(selected.is_none());
+}
+
+#[test]
+fn test_resolve_selected_note_returns_note_when_selection_exists() {
+    let notes = vec![Note::with_content("one"), Note::with_content("two")];
+    let selected_id = notes[1].id;
+
+    let selected = NotesApp::resolve_selected_note(Some(selected_id), &notes);
+
+    assert_eq!(selected.map(|(id, note)| (id, note.id)), Some((selected_id, selected_id)));
+}

file update:
diff --git a/src/notes/window/notes.rs b/src/notes/window/notes.rs
index 2b96e1be9f619ad7fa8b88d1287b653adb4780b4..449ab857a161bcb00618adf6e45ab022a3ac86fe
--- a/src/notes/window/notes.rs
+++ b/src/notes/window/notes.rs
@@ -231,42 +231,42 @@
     }
 
     /// Export the current note
-    pub(super) fn export_note(&self, format: ExportFormat) {
-        if let Some(id) = self.selected_note_id {
-            if let Some(note) = self.notes.iter().find(|n| n.id == id) {
-                let content = match format {
-                    ExportFormat::PlainText => note.content.clone(),
-                    // For Markdown, just export the content as-is.
-                    // The title is derived from the first line of content,
-                    // so prepending it would cause duplication.
-                    ExportFormat::Markdown => note.content.clone(),
-                    ExportFormat::Html => {
-                        // For HTML, we include proper structure with the title
-                        // and render the content as preformatted text
-                        format!(
-                            "<!DOCTYPE html>\n<html>\n<head><title>{}</title></head>\n<body>\n<h1>{}</h1>\n<pre>{}</pre>\n</body>\n</html>",
-                            note.title, note.title, note.content
-                        )
-                    }
-                };
+    pub(super) fn export_note(&mut self, format: ExportFormat) {
+        let Some((_id, note)) = self.selected_note_for_action("export_note") else {
+            return;
+        };
 
-                // Copy to clipboard
-                #[cfg(target_os = "macos")]
-                {
-                    use std::process::Command;
-                    let _ = Command::new("pbcopy")
-                        .stdin(std::process::Stdio::piped())
-                        .spawn()
-                        .and_then(|mut child| {
-                            use std::io::Write;
-                            if let Some(stdin) = child.stdin.as_mut() {
-                                stdin.write_all(content.as_bytes())?;
-                            }
-                            child.wait()
-                        });
-                    info!(format = ?format, "Note exported to clipboard");
-                }
+        let content = match format {
+            ExportFormat::PlainText => note.content.clone(),
+            // For Markdown, just export the content as-is.
+            // The title is derived from the first line of content,
+            // so prepending it would cause duplication.
+            ExportFormat::Markdown => note.content.clone(),
+            ExportFormat::Html => {
+                // For HTML, we include proper structure with the title
+                // and render the content as preformatted text
+                format!(
+                    "<!DOCTYPE html>\n<html>\n<head><title>{}</title></head>\n<body>\n<h1>{}</h1>\n<pre>{}</pre>\n</body>\n</html>",
+                    note.title, note.title, note.content
+                )
             }
+        };
+
+        // Copy to clipboard
+        #[cfg(target_os = "macos")]
+        {
+            use std::process::Command;
+            let _ = Command::new("pbcopy")
+                .stdin(std::process::Stdio::piped())
+                .spawn()
+                .and_then(|mut child| {
+                    use std::io::Write;
+                    if let Some(stdin) = child.stdin.as_mut() {
+                        stdin.write_all(content.as_bytes())?;
+                    }
+                    child.wait()
+                });
+            info!(format = ?format, "Note exported to clipboard");
         }
     }
 }
diff --git a/src/notes/window/notes_actions.rs b/src/notes/window/notes_actions.rs
index 6405519cffd92b2252b2e410eb3f58ee37800b8d..6d16c492f61a4be231c5a86328a3b9c14112bb7c
--- a/src/notes/window/notes_actions.rs
+++ b/src/notes/window/notes_actions.rs
@@ -1,6 +1,46 @@
 use super::*;
 
 impl NotesApp {
+    const SELECTED_NOTE_NOT_FOUND_FEEDBACK: &'static str = "Selected note could not be found";
+
+    pub(super) fn resolve_selected_note(
+        selected_note_id: Option<NoteId>,
+        notes: &[Note],
+    ) -> Option<(NoteId, &Note)> {
+        let selected_note_id = selected_note_id?;
+        notes
+            .iter()
+            .find(|note| note.id == selected_note_id)
+            .map(|note| (selected_note_id, note))
+    }
+
+    pub(super) fn show_selected_note_missing_feedback(&mut self, action: &'static str) {
+        tracing::warn!(
+            action,
+            selected_note_id = ?self.selected_note_id,
+            notes_len = self.notes.len(),
+            "notes_action_selected_note_not_found",
+        );
+        self.show_action_feedback(Self::SELECTED_NOTE_NOT_FOUND_FEEDBACK, true);
+    }
+
+    pub(super) fn selected_note_for_action(
+        &mut self,
+        action: &'static str,
+    ) -> Option<(NoteId, &Note)> {
+        let Some(selected_note_id) = self.selected_note_id else {
+            self.show_selected_note_missing_feedback(action);
+            return None;
+        };
+
+        if !self.notes.iter().any(|note| note.id == selected_note_id) {
+            self.show_selected_note_missing_feedback(action);
+            return None;
+        }
+
+        Self::resolve_selected_note(Some(selected_note_id), &self.notes)
+    }
+
     /// Cycle sort mode: Updated → Created → Alphabetical → Updated
     pub(super) fn cycle_sort_mode(&mut self, cx: &mut Context<Self>) {
         self.sort_mode = match self.sort_mode {
@@ -86,42 +126,34 @@
         format!("scriptkit://notes/{}", id.as_str())
     }
 
-    pub(super) fn copy_note_as_markdown(&self) {
+    pub(super) fn copy_note_as_markdown(&mut self) {
         self.export_note(ExportFormat::Markdown);
     }
 
-    pub(super) fn copy_note_deeplink(&self) {
-        if let Some(id) = self.selected_note_id {
-            let deeplink = self.note_deeplink(id);
-            self.copy_text_to_clipboard(&deeplink);
-        }
+    pub(super) fn copy_note_deeplink(&mut self) {
+        let Some((id, _)) = self.selected_note_for_action("copy_note_deeplink") else {
+            return;
+        };
+        let deeplink = self.note_deeplink(id);
+        self.copy_text_to_clipboard(&deeplink);
     }
 
-    pub(super) fn create_note_quicklink(&self) {
-        if let Some(id) = self.selected_note_id {
-            let title = self
-                .notes
-                .iter()
-                .find(|note| note.id == id)
-                .map(|note| {
-                    if note.title.is_empty() {
-                        "Untitled Note".to_string()
-                    } else {
-                        note.title.clone()
-                    }
-                })
-                .unwrap_or_else(|| "Untitled Note".to_string());
-            let deeplink = self.note_deeplink(id);
-            let quicklink = format!("[{}]({})", title, deeplink);
-            self.copy_text_to_clipboard(&quicklink);
-        }
+    pub(super) fn create_note_quicklink(&mut self) {
+        let Some((id, note)) = self.selected_note_for_action("create_note_quicklink") else {
+            return;
+        };
+        let title = if note.title.is_empty() {
+            "Untitled Note".to_string()
+        } else {
+            note.title.clone()
+        };
+        let deeplink = self.note_deeplink(id);
+        let quicklink = format!("[{}]({})", title, deeplink);
+        self.copy_text_to_clipboard(&quicklink);
     }
 
     pub(super) fn duplicate_selected_note(&mut self, window: &mut Window, cx: &mut Context<Self>) {
-        let Some(id) = self.selected_note_id else {
-            return;
-        };
-        let Some(note) = self.notes.iter().find(|note| note.id == id) else {
+        let Some((_id, note)) = self.selected_note_for_action("duplicate_selected_note") else {
             return;
         };
 
diff --git a/src/notes/window/panels.rs b/src/notes/window/panels.rs
index 16b4b85b9be89780b4c9430f0db050a9af14532e..b843238a1e9103f6055702cf09dc506f1e99fa17
--- a/src/notes/window/panels.rs
+++ b/src/notes/window/panels.rs
@@ -281,6 +281,17 @@
                 self.select_note(note_id, window, cx);
                 return;
             }
+
+            tracing::warn!(
+                action_id,
+                note_id_str,
+                selected_note_id = ?self.selected_note_id,
+                notes_len = self.notes.len(),
+                "notes_note_switcher_selected_note_not_found",
+            );
+            self.show_selected_note_missing_feedback("execute_note_switcher_action");
+            self.close_browse_panel(window, cx);
+            return;
         }
 
         // Handle "no_notes" placeholder action
diff --git a/src/notes/window/tests.rs b/src/notes/window/tests.rs
index 8cb070d17ec066ba2b9e5a81de39cf1dfd19742b..441dc8b615019a2f05ba8f031d6bad5a449dd4a1
--- a/src/notes/window/tests.rs
+++ b/src/notes/window/tests.rs
@@ -1,4 +1,4 @@
-use super::NotesApp;
+use super::{Note, NoteId, NotesApp};
 
 #[test]
 fn formatting_replacement_wraps_selected_text() {
@@ -37,3 +37,31 @@
     assert_eq!(new_value, "he****llo");
     assert_eq!(new_selection, 4..4);
 }
+
+#[test]
+fn test_resolve_selected_note_returns_none_when_selection_is_missing() {
+    let notes = vec![Note::with_content("one"), Note::with_content("two")];
+
+    let selected = NotesApp::resolve_selected_note(None, &notes);
+
+    assert!(selected.is_none());
+}
+
+#[test]
+fn test_resolve_selected_note_returns_none_when_selection_is_stale() {
+    let notes = vec![Note::with_content("one"), Note::with_content("two")];
+
+    let selected = NotesApp::resolve_selected_note(Some(NoteId::new()), &notes);
+
+    assert!(selected.is_none());
+}
+
+#[test]
+fn test_resolve_selected_note_returns_note_when_selection_exists() {
+    let notes = vec![Note::with_content("one"), Note::with_content("two")];
+    let selected_id = notes[1].id;
+
+    let selected = NotesApp::resolve_selected_note(Some(selected_id), &notes);
+
+    assert_eq!(selected.map(|(id, note)| (id, note.id)), Some((selected_id, selected_id)));
+}


thinking
**Planning repeated polling on exit**
file update:
diff --git a/src/notes/window/notes.rs b/src/notes/window/notes.rs
index 2b96e1be9f619ad7fa8b88d1287b653adb4780b4..449ab857a161bcb00618adf6e45ab022a3ac86fe
--- a/src/notes/window/notes.rs
+++ b/src/notes/window/notes.rs
@@ -231,42 +231,42 @@
     }
 
     /// Export the current note
-    pub(super) fn export_note(&self, format: ExportFormat) {
-        if let Some(id) = self.selected_note_id {
-            if let Some(note) = self.notes.iter().find(|n| n.id == id) {
-                let content = match format {
-                    ExportFormat::PlainText => note.content.clone(),
-                    // For Markdown, just export the content as-is.
-                    // The title is derived from the first line of content,
-                    // so prepending it would cause duplication.
-                    ExportFormat::Markdown => note.content.clone(),
-                    ExportFormat::Html => {
-                        // For HTML, we include proper structure with the title
-                        // and render the content as preformatted text
-                        format!(
-                            "<!DOCTYPE html>\n<html>\n<head><title>{}</title></head>\n<body>\n<h1>{}</h1>\n<pre>{}</pre>\n</body>\n</html>",
-                            note.title, note.title, note.content
-                        )
-                    }
-                };
+    pub(super) fn export_note(&mut self, format: ExportFormat) {
+        let Some((_id, note)) = self.selected_note_for_action("export_note") else {
+            return;
+        };
 
-                // Copy to clipboard
-                #[cfg(target_os = "macos")]
-                {
-                    use std::process::Command;
-                    let _ = Command::new("pbcopy")
-                        .stdin(std::process::Stdio::piped())
-                        .spawn()
-                        .and_then(|mut child| {
-                            use std::io::Write;
-                            if let Some(stdin) = child.stdin.as_mut() {
-                                stdin.write_all(content.as_bytes())?;
-                            }
-                            child.wait()
-                        });
-                    info!(format = ?format, "Note exported to clipboard");
-                }
+        let content = match format {
+            ExportFormat::PlainText => note.content.clone(),
+            // For Markdown, just export the content as-is.
+            // The title is derived from the first line of content,
+            // so prepending it would cause duplication.
+            ExportFormat::Markdown => note.content.clone(),
+            ExportFormat::Html => {
+                // For HTML, we include proper structure with the title
+                // and render the content as preformatted text
+                format!(
+                    "<!DOCTYPE html>\n<html>\n<head><title>{}</title></head>\n<body>\n<h1>{}</h1>\n<pre>{}</pre>\n</body>\n</html>",
+                    note.title, note.title, note.content
+                )
             }
+        };
+
+        // Copy to clipboard
+        #[cfg(target_os = "macos")]
+        {
+            use std::process::Command;
+            let _ = Command::new("pbcopy")
+                .stdin(std::process::Stdio::piped())
+                .spawn()
+                .and_then(|mut child| {
+                    use std::io::Write;
+                    if let Some(stdin) = child.stdin.as_mut() {
+                        stdin.write_all(content.as_bytes())?;
+                    }
+                    child.wait()
+                });
+            info!(format = ?format, "Note exported to clipboard");
         }
     }
 }
diff --git a/src/notes/window/notes_actions.rs b/src/notes/window/notes_actions.rs
index 6405519cffd92b2252b2e410eb3f58ee37800b8d..6d16c492f61a4be231c5a86328a3b9c14112bb7c
--- a/src/notes/window/notes_actions.rs
+++ b/src/notes/window/notes_actions.rs
@@ -1,6 +1,46 @@
 use super::*;
 
 impl NotesApp {
+    const SELECTED_NOTE_NOT_FOUND_FEEDBACK: &'static str = "Selected note could not be found";
+
+    pub(super) fn resolve_selected_note(
+        selected_note_id: Option<NoteId>,
+        notes: &[Note],
+    ) -> Option<(NoteId, &Note)> {
+        let selected_note_id = selected_note_id?;
+        notes
+            .iter()
+            .find(|note| note.id == selected_note_id)
+            .map(|note| (selected_note_id, note))
+    }
+
+    pub(super) fn show_selected_note_missing_feedback(&mut self, action: &'static str) {
+        tracing::warn!(
+            action,
+            selected_note_id = ?self.selected_note_id,
+            notes_len = self.notes.len(),
+            "notes_action_selected_note_not_found",
+        );
+        self.show_action_feedback(Self::SELECTED_NOTE_NOT_FOUND_FEEDBACK, true);
+    }
+
+    pub(super) fn selected_note_for_action(
+        &mut self,
+        action: &'static str,
+    ) -> Option<(NoteId, &Note)> {
+        let Some(selected_note_id) = self.selected_note_id else {
+            self.show_selected_note_missing_feedback(action);
+            return None;
+        };
+
+        if !self.notes.iter().any(|note| note.id == selected_note_id) {
+            self.show_selected_note_missing_feedback(action);
+            return None;
+        }
+
+        Self::resolve_selected_note(Some(selected_note_id), &self.notes)
+    }
+
     /// Cycle sort mode: Updated → Created → Alphabetical → Updated
     pub(super) fn cycle_sort_mode(&mut self, cx: &mut Context<Self>) {
         self.sort_mode = match self.sort_mode {
@@ -86,42 +126,34 @@
         format!("scriptkit://notes/{}", id.as_str())
     }
 
-    pub(super) fn copy_note_as_markdown(&self) {
+    pub(super) fn copy_note_as_markdown(&mut self) {
         self.export_note(ExportFormat::Markdown);
     }
 
-    pub(super) fn copy_note_deeplink(&self) {
-        if let Some(id) = self.selected_note_id {
-            let deeplink = self.note_deeplink(id);
-            self.copy_text_to_clipboard(&deeplink);
-        }
+    pub(super) fn copy_note_deeplink(&mut self) {
+        let Some((id, _)) = self.selected_note_for_action("copy_note_deeplink") else {
+            return;
+        };
+        let deeplink = self.note_deeplink(id);
+        self.copy_text_to_clipboard(&deeplink);
     }
 
-    pub(super) fn create_note_quicklink(&self) {
-        if let Some(id) = self.selected_note_id {
-            let title = self
-                .notes
-                .iter()
-                .find(|note| note.id == id)
-                .map(|note| {
-                    if note.title.is_empty() {
-                        "Untitled Note".to_string()
-                    } else {
-                        note.title.clone()
-                    }
-                })
-                .unwrap_or_else(|| "Untitled Note".to_string());
-            let deeplink = self.note_deeplink(id);
-            let quicklink = format!("[{}]({})", title, deeplink);
-            self.copy_text_to_clipboard(&quicklink);
-        }
+    pub(super) fn create_note_quicklink(&mut self) {
+        let Some((id, note)) = self.selected_note_for_action("create_note_quicklink") else {
+            return;
+        };
+        let title = if note.title.is_empty() {
+            "Untitled Note".to_string()
+        } else {
+            note.title.clone()
+        };
+        let deeplink = self.note_deeplink(id);
+        let quicklink = format!("[{}]({})", title, deeplink);
+        self.copy_text_to_clipboard(&quicklink);
     }
 
     pub(super) fn duplicate_selected_note(&mut self, window: &mut Window, cx: &mut Context<Self>) {
-        let Some(id) = self.selected_note_id else {
-            return;
-        };
-        let Some(note) = self.notes.iter().find(|note| note.id == id) else {
+        let Some((_id, note)) = self.selected_note_for_action("duplicate_selected_note") else {
             return;
         };
 
diff --git a/src/notes/window/panels.rs b/src/notes/window/panels.rs
index 16b4b85b9be89780b4c9430f0db050a9af14532e..b843238a1e9103f6055702cf09dc506f1e99fa17
--- a/src/notes/window/panels.rs
+++ b/src/notes/window/panels.rs
@@ -281,6 +281,17 @@
                 self.select_note(note_id, window, cx);
                 return;
             }
+
+            tracing::warn!(
+                action_id,
+                note_id_str,
+                selected_note_id = ?self.selected_note_id,
+                notes_len = self.notes.len(),
+                "notes_note_switcher_selected_note_not_found",
+            );
+            self.show_selected_note_missing_feedback("execute_note_switcher_action");
+            self.close_browse_panel(window, cx);
+            return;
         }
 
         // Handle "no_notes" placeholder action
diff --git a/src/notes/window/tests.rs b/src/notes/window/tests.rs
index 8cb070d17ec066ba2b9e5a81de39cf1dfd19742b..441dc8b615019a2f05ba8f031d6bad5a449dd4a1
--- a/src/notes/window/tests.rs
+++ b/src/notes/window/tests.rs
@@ -1,4 +1,4 @@
-use super::NotesApp;
+use super::{Note, NoteId, NotesApp};
 
 #[test]
 fn formatting_replacement_wraps_selected_text() {
@@ -37,3 +37,31 @@
     assert_eq!(new_value, "he****llo");
     assert_eq!(new_selection, 4..4);
 }
+
+#[test]
+fn test_resolve_selected_note_returns_none_when_selection_is_missing() {
+    let notes = vec![Note::with_content("one"), Note::with_content("two")];
+
+    let selected = NotesApp::resolve_selected_note(None, &notes);
+
+    assert!(selected.is_none());
+}
+
+#[test]
+fn test_resolve_selected_note_returns_none_when_selection_is_stale() {
+    let notes = vec![Note::with_content("one"), Note::with_content("two")];
+
+    let selected = NotesApp::resolve_selected_note(Some(NoteId::new()), &notes);
+
+    assert!(selected.is_none());
+}
+
+#[test]
+fn test_resolve_selected_note_returns_note_when_selection_exists() {
+    let notes = vec![Note::with_content("one"), Note::with_content("two")];
+    let selected_id = notes[1].id;
+
+    let selected = NotesApp::resolve_selected_note(Some(selected_id), &notes);
+
+    assert_eq!(selected.map(|(id, note)| (id, note.id)), Some((selected_id, selected_id)));
+}

 exited 101 in 34.32s:
    Blocking waiting for file lock on build directory
    Checking script-kit-gpui v0.1.0 (/Users/johnlindquist/dev/script-kit-gpui)
error[E0761]: file for module `tests` found at both "src/protocol/message/tests.rs" and "src/protocol/message/tests/mod.rs"
  --> src/protocol/message/mod.rs:87:1
   |
87 | mod tests;
   | ^^^^^^^^^^
   |
   = help: delete or rename one of them to remove the ambiguity

error[E0761]: file for module `tests` found at both "src/designs/core/tests.rs" and "src/designs/core/tests/mod.rs"
 --> src/designs/core/part_04.rs:2:1
  |
2 | mod tests;
  | ^^^^^^^^^^
  |
  = help: delete or rename one of them to remove the ambiguity

error: glob import doesn't reexport anything with visibility `pub(in crate::prompts)` because no imported item is public enough
  --> src/prompts/div/mod.rs:32:16

thinking
**Assessing targeted test constraints due to unrelated compile errors**
exec
/bin/zsh -lc 'git diff -- src/notes/window/notes_actions.rs src/notes/window/notes.rs src/notes/window/panels.rs src/notes/window/tests.rs' in /Users/johnlindquist/dev/script-kit-gpui succeeded in 51ms:
diff --git a/src/notes/window/notes.rs b/src/notes/window/notes.rs
index 2b96e1b..449ab85 100644
--- a/src/notes/window/notes.rs
+++ b/src/notes/window/notes.rs
@@ -231,42 +231,42 @@ impl NotesApp {
     }
 
     /// Export the current note
-    pub(super) fn export_note(&self, format: ExportFormat) {
-        if let Some(id) = self.selected_note_id {
-            if let Some(note) = self.notes.iter().find(|n| n.id == id) {
-                let content = match format {
-                    ExportFormat::PlainText => note.content.clone(),
-                    // For Markdown, just export the content as-is.
-                    // The title is derived from the first line of content,
-                    // so prepending it would cause duplication.
-                    ExportFormat::Markdown => note.content.clone(),
-                    ExportFormat::Html => {
-                        // For HTML, we include proper structure with the title
-                        // and render the content as preformatted text
file update:
diff --git a/src/notes/window/notes.rs b/src/notes/window/notes.rs
index 2b96e1be9f619ad7fa8b88d1287b653adb4780b4..449ab857a161bcb00618adf6e45ab022a3ac86fe
--- a/src/notes/window/notes.rs
+++ b/src/notes/window/notes.rs
@@ -231,42 +231,42 @@
     }
 
     /// Export the current note
-    pub(super) fn export_note(&self, format: ExportFormat) {
-        if let Some(id) = self.selected_note_id {
-            if let Some(note) = self.notes.iter().find(|n| n.id == id) {
-                let content = match format {
-                    ExportFormat::PlainText => note.content.clone(),
-                    // For Markdown, just export the content as-is.
-                    // The title is derived from the first line of content,
-                    // so prepending it would cause duplication.
-                    ExportFormat::Markdown => note.content.clone(),
-                    ExportFormat::Html => {
-                        // For HTML, we include proper structure with the title
-                        // and render the content as preformatted text
-                        format!(
-                            "<!DOCTYPE html>\n<html>\n<head><title>{}</title></head>\n<body>\n<h1>{}</h1>\n<pre>{}</pre>\n</body>\n</html>",
-                            note.title, note.title, note.content
-                        )
-                    }
-                };
+    pub(super) fn export_note(&mut self, format: ExportFormat) {
+        let Some((_id, note)) = self.selected_note_for_action("export_note") else {
+            return;
+        };
 
-                // Copy to clipboard
-                #[cfg(target_os = "macos")]
-                {
-                    use std::process::Command;
-                    let _ = Command::new("pbcopy")
-                        .stdin(std::process::Stdio::piped())
-                        .spawn()
-                        .and_then(|mut child| {
-                            use std::io::Write;
-                            if let Some(stdin) = child.stdin.as_mut() {
-                                stdin.write_all(content.as_bytes())?;
-                            }
-                            child.wait()
-                        });
-                    info!(format = ?format, "Note exported to clipboard");
-                }
+        let content = match format {
+            ExportFormat::PlainText => note.content.clone(),
+            // For Markdown, just export the content as-is.
+            // The title is derived from the first line of content,
+            // so prepending it would cause duplication.
+            ExportFormat::Markdown => note.content.clone(),
+            ExportFormat::Html => {
+                // For HTML, we include proper structure with the title
+                // and render the content as preformatted text
+                format!(
+                    "<!DOCTYPE html>\n<html>\n<head><title>{}</title></head>\n<body>\n<h1>{}</h1>\n<pre>{}</pre>\n</body>\n</html>",
+                    note.title, note.title, note.content
+                )
             }
+        };
+
+        // Copy to clipboard
+        #[cfg(target_os = "macos")]
+        {
+            use std::process::Command;
+            let _ = Command::new("pbcopy")
+                .stdin(std::process::Stdio::piped())
+                .spawn()
+                .and_then(|mut child| {
+                    use std::io::Write;
+                    if let Some(stdin) = child.stdin.as_mut() {
+                        stdin.write_all(content.as_bytes())?;
+                    }
+                    child.wait()
+                });
+            info!(format = ?format, "Note exported to clipboard");
         }
     }
 }
diff --git a/src/notes/window/notes_actions.rs b/src/notes/window/notes_actions.rs
index 6405519cffd92b2252b2e410eb3f58ee37800b8d..6d16c492f61a4be231c5a86328a3b9c14112bb7c
--- a/src/notes/window/notes_actions.rs
+++ b/src/notes/window/notes_actions.rs
@@ -1,6 +1,46 @@
 use super::*;
 
 impl NotesApp {
+    const SELECTED_NOTE_NOT_FOUND_FEEDBACK: &'static str = "Selected note could not be found";
+
+    pub(super) fn resolve_selected_note(
+        selected_note_id: Option<NoteId>,
+        notes: &[Note],
+    ) -> Option<(NoteId, &Note)> {
+        let selected_note_id = selected_note_id?;
+        notes
+            .iter()
+            .find(|note| note.id == selected_note_id)
+            .map(|note| (selected_note_id, note))
+    }
+
+    pub(super) fn show_selected_note_missing_feedback(&mut self, action: &'static str) {
+        tracing::warn!(
+            action,
+            selected_note_id = ?self.selected_note_id,
+            notes_len = self.notes.len(),
+            "notes_action_selected_note_not_found",
+        );
+        self.show_action_feedback(Self::SELECTED_NOTE_NOT_FOUND_FEEDBACK, true);
+    }
+
+    pub(super) fn selected_note_for_action(
+        &mut self,
+        action: &'static str,
+    ) -> Option<(NoteId, &Note)> {
+        let Some(selected_note_id) = self.selected_note_id else {
+            self.show_selected_note_missing_feedback(action);
+            return None;
+        };
+
+        if !self.notes.iter().any(|note| note.id == selected_note_id) {
+            self.show_selected_note_missing_feedback(action);
+            return None;
+        }
+
+        Self::resolve_selected_note(Some(selected_note_id), &self.notes)
+    }
+
     /// Cycle sort mode: Updated → Created → Alphabetical → Updated
     pub(super) fn cycle_sort_mode(&mut self, cx: &mut Context<Self>) {
         self.sort_mode = match self.sort_mode {
@@ -86,42 +126,34 @@
         format!("scriptkit://notes/{}", id.as_str())
     }
 
-    pub(super) fn copy_note_as_markdown(&self) {
+    pub(super) fn copy_note_as_markdown(&mut self) {
         self.export_note(ExportFormat::Markdown);
     }
 
-    pub(super) fn copy_note_deeplink(&self) {
-        if let Some(id) = self.selected_note_id {
-            let deeplink = self.note_deeplink(id);
-            self.copy_text_to_clipboard(&deeplink);
-        }
+    pub(super) fn copy_note_deeplink(&mut self) {
+        let Some((id, _)) = self.selected_note_for_action("copy_note_deeplink") else {
+            return;
+        };
+        let deeplink = self.note_deeplink(id);
+        self.copy_text_to_clipboard(&deeplink);
     }
 
-    pub(super) fn create_note_quicklink(&self) {
-        if let Some(id) = self.selected_note_id {
-            let title = self
-                .notes
-                .iter()
-                .find(|note| note.id == id)
-                .map(|note| {
-                    if note.title.is_empty() {
-                        "Untitled Note".to_string()
-                    } else {
-                        note.title.clone()
-                    }
-                })
-                .unwrap_or_else(|| "Untitled Note".to_string());
-            let deeplink = self.note_deeplink(id);
-            let quicklink = format!("[{}]({})", title, deeplink);
-            self.copy_text_to_clipboard(&quicklink);
-        }
+    pub(super) fn create_note_quicklink(&mut self) {
+        let Some((id, note)) = self.selected_note_for_action("create_note_quicklink") else {
+            return;
+        };
+        let title = if note.title.is_empty() {
+            "Untitled Note".to_string()
+        } else {
+            note.title.clone()
+        };
+        let deeplink = self.note_deeplink(id);
+        let quicklink = format!("[{}]({})", title, deeplink);
+        self.copy_text_to_clipboard(&quicklink);
     }
 
     pub(super) fn duplicate_selected_note(&mut self, window: &mut Window, cx: &mut Context<Self>) {
-        let Some(id) = self.selected_note_id else {
-            return;
-        };
-        let Some(note) = self.notes.iter().find(|note| note.id == id) else {
+        let Some((_id, note)) = self.selected_note_for_action("duplicate_selected_note") else {
             return;
         };
 
diff --git a/src/notes/window/panels.rs b/src/notes/window/panels.rs
index 16b4b85b9be89780b4c9430f0db050a9af14532e..b843238a1e9103f6055702cf09dc506f1e99fa17
--- a/src/notes/window/panels.rs
+++ b/src/notes/window/panels.rs
@@ -281,6 +281,17 @@
                 self.select_note(note_id, window, cx);
                 return;
             }
+
+            tracing::warn!(
+                action_id,
+                note_id_str,
+                selected_note_id = ?self.selected_note_id,
+                notes_len = self.notes.len(),
+                "notes_note_switcher_selected_note_not_found",
+            );
+            self.show_selected_note_missing_feedback("execute_note_switcher_action");
+            self.close_browse_panel(window, cx);
+            return;
         }
 
         // Handle "no_notes" placeholder action
diff --git a/src/notes/window/tests.rs b/src/notes/window/tests.rs
index 8cb070d17ec066ba2b9e5a81de39cf1dfd19742b..441dc8b615019a2f05ba8f031d6bad5a449dd4a1
--- a/src/notes/window/tests.rs
+++ b/src/notes/window/tests.rs
@@ -1,4 +1,4 @@
-use super::NotesApp;
+use super::{Note, NoteId, NotesApp};
 
 #[test]
 fn formatting_replacement_wraps_selected_text() {
@@ -37,3 +37,31 @@
     assert_eq!(new_value, "he****llo");
     assert_eq!(new_selection, 4..4);
 }
+
+#[test]
+fn test_resolve_selected_note_returns_none_when_selection_is_missing() {
+    let notes = vec![Note::with_content("one"), Note::with_content("two")];
+
+    let selected = NotesApp::resolve_selected_note(None, &notes);
+
+    assert!(selected.is_none());
+}
+
+#[test]
+fn test_resolve_selected_note_returns_none_when_selection_is_stale() {
+    let notes = vec![Note::with_content("one"), Note::with_content("two")];
+
+    let selected = NotesApp::resolve_selected_note(Some(NoteId::new()), &notes);
+
+    assert!(selected.is_none());
+}
+
+#[test]
+fn test_resolve_selected_note_returns_note_when_selection_exists() {
+    let notes = vec![Note::with_content("one"), Note::with_content("two")];
+    let selected_id = notes[1].id;
+
+    let selected = NotesApp::resolve_selected_note(Some(selected_id), &notes);
+
+    assert_eq!(selected.map(|(id, note)| (id, note.id)), Some((selected_id, selected_id)));
+}


thinking
**Finalizing with partial verification and status update**
codex
Implementation and tests are complete for the scoped notes files. I’m now finalizing agent state by recording the verification blockers (repo-wide concurrent compile failures) and releasing file claims.
exec
/bin/zsh -lc '~/.claude/bin/swarm.ts update --id codex-fix-notes-feedback --status done --notes "Added stale selected-note feedback for duplicate/copy deeplink/create quicklink/export + stale note-switcher action path; added resolve_selected_note tests; cargo check/clippy currently blocked by unrelated workspace errors in clipboard_history/actions test modules." && ~/.claude/bin/swarm.ts release --id codex-fix-notes-feedback src/notes/window/notes_actions.rs src/notes/window/notes.rs src/notes/window/panels.rs src/notes/window/tests.rs' in /Users/johnlindquist/dev/script-kit-gpui succeeded in 50ms:
Updated: codex-fix-notes-feedback
Released for codex-fix-notes-feedback: src/notes/window/notes_actions.rs, src/notes/window/notes.rs, src/notes/window/panels.rs, src/notes/window/tests.rs
file update:
diff --git a/src/notes/window/notes.rs b/src/notes/window/notes.rs
index 2b96e1be9f619ad7fa8b88d1287b653adb4780b4..449ab857a161bcb00618adf6e45ab022a3ac86fe
--- a/src/notes/window/notes.rs
+++ b/src/notes/window/notes.rs
@@ -231,42 +231,42 @@
     }
 
     /// Export the current note
-    pub(super) fn export_note(&self, format: ExportFormat) {
-        if let Some(id) = self.selected_note_id {
-            if let Some(note) = self.notes.iter().find(|n| n.id == id) {
-                let content = match format {
-                    ExportFormat::PlainText => note.content.clone(),
-                    // For Markdown, just export the content as-is.
-                    // The title is derived from the first line of content,
-                    // so prepending it would cause duplication.
-                    ExportFormat::Markdown => note.content.clone(),
-                    ExportFormat::Html => {
-                        // For HTML, we include proper structure with the title
-                        // and render the content as preformatted text
-                        format!(
-                            "<!DOCTYPE html>\n<html>\n<head><title>{}</title></head>\n<body>\n<h1>{}</h1>\n<pre>{}</pre>\n</body>\n</html>",
-                            note.title, note.title, note.content
-                        )
-                    }
-                };
+    pub(super) fn export_note(&mut self, format: ExportFormat) {
+        let Some((_id, note)) = self.selected_note_for_action("export_note") else {
+            return;
+        };
 
-                // Copy to clipboard
-                #[cfg(target_os = "macos")]
-                {
-                    use std::process::Command;
-                    let _ = Command::new("pbcopy")
-                        .stdin(std::process::Stdio::piped())
-                        .spawn()
-                        .and_then(|mut child| {
-                            use std::io::Write;
-                            if let Some(stdin) = child.stdin.as_mut() {
-                                stdin.write_all(content.as_bytes())?;
-                            }
-                            child.wait()
-                        });
-                    info!(format = ?format, "Note exported to clipboard");
-                }
+        let content = match format {
+            ExportFormat::PlainText => note.content.clone(),
+            // For Markdown, just export the content as-is.
+            // The title is derived from the first line of content,
+            // so prepending it would cause duplication.
+            ExportFormat::Markdown => note.content.clone(),
+            ExportFormat::Html => {
+                // For HTML, we include proper structure with the title
+                // and render the content as preformatted text
+                format!(
+                    "<!DOCTYPE html>\n<html>\n<head><title>{}</title></head>\n<body>\n<h1>{}</h1>\n<pre>{}</pre>\n</body>\n</html>",
+                    note.title, note.title, note.content
+                )
             }
+        };
+
+        // Copy to clipboard
+        #[cfg(target_os = "macos")]
+        {
+            use std::process::Command;
+            let _ = Command::new("pbcopy")
+                .stdin(std::process::Stdio::piped())
+                .spawn()
+                .and_then(|mut child| {
+                    use std::io::Write;
+                    if let Some(stdin) = child.stdin.as_mut() {
+                        stdin.write_all(content.as_bytes())?;
+                    }
+                    child.wait()
+                });
+            info!(format = ?format, "Note exported to clipboard");
         }
     }
 }
diff --git a/src/notes/window/notes_actions.rs b/src/notes/window/notes_actions.rs
index 6405519cffd92b2252b2e410eb3f58ee37800b8d..6d16c492f61a4be231c5a86328a3b9c14112bb7c
--- a/src/notes/window/notes_actions.rs
+++ b/src/notes/window/notes_actions.rs
@@ -1,6 +1,46 @@
 use super::*;
 
 impl NotesApp {
+    const SELECTED_NOTE_NOT_FOUND_FEEDBACK: &'static str = "Selected note could not be found";
+
+    pub(super) fn resolve_selected_note(
+        selected_note_id: Option<NoteId>,
+        notes: &[Note],
+    ) -> Option<(NoteId, &Note)> {
+        let selected_note_id = selected_note_id?;
+        notes
+            .iter()
+            .find(|note| note.id == selected_note_id)
+            .map(|note| (selected_note_id, note))
+    }
+
+    pub(super) fn show_selected_note_missing_feedback(&mut self, action: &'static str) {
+        tracing::warn!(
+            action,
+            selected_note_id = ?self.selected_note_id,
+            notes_len = self.notes.len(),
+            "notes_action_selected_note_not_found",
+        );
+        self.show_action_feedback(Self::SELECTED_NOTE_NOT_FOUND_FEEDBACK, true);
+    }
+
+    pub(super) fn selected_note_for_action(
+        &mut self,
+        action: &'static str,
+    ) -> Option<(NoteId, &Note)> {
+        let Some(selected_note_id) = self.selected_note_id else {
+            self.show_selected_note_missing_feedback(action);
+            return None;
+        };
+
+        if !self.notes.iter().any(|note| note.id == selected_note_id) {
+            self.show_selected_note_missing_feedback(action);
+            return None;
+        }
+
+        Self::resolve_selected_note(Some(selected_note_id), &self.notes)
+    }
+
     /// Cycle sort mode: Updated → Created → Alphabetical → Updated
     pub(super) fn cycle_sort_mode(&mut self, cx: &mut Context<Self>) {
         self.sort_mode = match self.sort_mode {
@@ -86,42 +126,34 @@
         format!("scriptkit://notes/{}", id.as_str())
     }
 
-    pub(super) fn copy_note_as_markdown(&self) {
+    pub(super) fn copy_note_as_markdown(&mut self) {
         self.export_note(ExportFormat::Markdown);
     }
 
-    pub(super) fn copy_note_deeplink(&self) {
-        if let Some(id) = self.selected_note_id {
-            let deeplink = self.note_deeplink(id);
-            self.copy_text_to_clipboard(&deeplink);
-        }
+    pub(super) fn copy_note_deeplink(&mut self) {
+        let Some((id, _)) = self.selected_note_for_action("copy_note_deeplink") else {
+            return;
+        };
+        let deeplink = self.note_deeplink(id);
+        self.copy_text_to_clipboard(&deeplink);
     }
 
-    pub(super) fn create_note_quicklink(&self) {
-        if let Some(id) = self.selected_note_id {
-            let title = self
-                .notes
-                .iter()
-                .find(|note| note.id == id)
-                .map(|note| {
-                    if note.title.is_empty() {
-                        "Untitled Note".to_string()
-                    } else {
-                        note.title.clone()
-                    }
-                })
-                .unwrap_or_else(|| "Untitled Note".to_string());
-            let deeplink = self.note_deeplink(id);
-            let quicklink = format!("[{}]({})", title, deeplink);
-            self.copy_text_to_clipboard(&quicklink);
-        }
+    pub(super) fn create_note_quicklink(&mut self) {
+        let Some((id, note)) = self.selected_note_for_action("create_note_quicklink") else {
+            return;
+        };
+        let title = if note.title.is_empty() {
+            "Untitled Note".to_string()
+        } else {
+            note.title.clone()
+        };
+        let deeplink = self.note_deeplink(id);
+        let quicklink = format!("[{}]({})", title, deeplink);
+        self.copy_text_to_clipboard(&quicklink);
     }
 
     pub(super) fn duplicate_selected_note(&mut self, window: &mut Window, cx: &mut Context<Self>) {
-        let Some(id) = self.selected_note_id else {
-            return;
-        };
-        let Some(note) = self.notes.iter().find(|note| note.id == id) else {
+        let Some((_id, note)) = self.selected_note_for_action("duplicate_selected_note") else {
             return;
         };
 
diff --git a/src/notes/window/panels.rs b/src/notes/window/panels.rs
index 16b4b85b9be89780b4c9430f0db050a9af14532e..b843238a1e9103f6055702cf09dc506f1e99fa17
--- a/src/notes/window/panels.rs
+++ b/src/notes/window/panels.rs
@@ -281,6 +281,17 @@
                 self.select_note(note_id, window, cx);
                 return;
             }
+
+            tracing::warn!(
+                action_id,
+                note_id_str,
+                selected_note_id = ?self.selected_note_id,
+                notes_len = self.notes.len(),
+                "notes_note_switcher_selected_note_not_found",
+            );
+            self.show_selected_note_missing_feedback("execute_note_switcher_action");
+            self.close_browse_panel(window, cx);
+            return;
         }
 
         // Handle "no_notes" placeholder action
diff --git a/src/notes/window/tests.rs b/src/notes/window/tests.rs
index 8cb070d17ec066ba2b9e5a81de39cf1dfd19742b..441dc8b615019a2f05ba8f031d6bad5a449dd4a1
--- a/src/notes/window/tests.rs
+++ b/src/notes/window/tests.rs
@@ -1,4 +1,4 @@
-use super::NotesApp;
+use super::{Note, NoteId, NotesApp};
 
 #[test]
 fn formatting_replacement_wraps_selected_text() {
@@ -37,3 +37,31 @@
     assert_eq!(new_value, "he****llo");
     assert_eq!(new_selection, 4..4);
 }
+
+#[test]
+fn test_resolve_selected_note_returns_none_when_selection_is_missing() {
+    let notes = vec![Note::with_content("one"), Note::with_content("two")];
+
+    let selected = NotesApp::resolve_selected_note(None, &notes);
+
+    assert!(selected.is_none());
+}
+
+#[test]
+fn test_resolve_selected_note_returns_none_when_selection_is_stale() {
+    let notes = vec![Note::with_content("one"), Note::with_content("two")];
+
+    let selected = NotesApp::resolve_selected_note(Some(NoteId::new()), &notes);
+
+    assert!(selected.is_none());
+}
+
+#[test]
+fn test_resolve_selected_note_returns_note_when_selection_exists() {
+    let notes = vec![Note::with_content("one"), Note::with_content("two")];
+    let selected_id = notes[1].id;
+
+    let selected = NotesApp::resolve_selected_note(Some(selected_id), &notes);
+
+    assert_eq!(selected.map(|(id, note)| (id, note.id)), Some((selected_id, selected_id)));
+}


thinking
**Preparing final summary message**
codex
Implemented the stale/missing selected-note feedback fix in the scoped notes window paths.

**Changed Files**
- `src/notes/window/notes_actions.rs`
  - Added shared selection resolver + feedback helpers:
    - `resolve_selected_note(...)`
    - `show_selected_note_missing_feedback(...)`
    - `selected_note_for_action(...)`
  - Updated:
    - `copy_note_as_markdown` to mutable receiver
    - `copy_note_deeplink` to validate selected note and show feedback when stale/missing
    - `create_note_quicklink` to validate selected note and show feedback when stale/missing
    - `duplicate_selected_note` to use shared stale/missing feedback path
- `src/notes/window/notes.rs`
  - Updated `export_note` to mutable receiver and to use shared selected-note validation/feedback instead of silent return.
- `src/notes/window/panels.rs`
  - In `execute_note_switcher_action`, stale `note_{uuid}` actions now show missing-note feedback and close browse panel instead of silent close/warn-only.
- `src/notes/window/tests.rs`
  - Added unit tests for selected-note resolution:
    - `test_resolve_selected_note_returns_none_when_selection_is_missing`
    - `test_resolve_selected_note_returns_none_when_selection_is_stale`
    - `test_resolve_selected_note_returns_note_when_selection_exists`

**Verification Run**
- Ran: `cargo check -p script-kit-gpui`
  - Fails due unrelated concurrent workspace issues (not in notes scope), e.g.:
    - `src/clipboard_history/database.rs` missing fields in `ClipboardEntry`
    - non-exhaustive `ContentType` matches in clipboard modules
- Ran: `cargo clippy -p script-kit-gpui --all-targets -- -D warnings`
  - Fails due broad unrelated errors/warnings in other modules/tests (duplicate test modules, missing imports/types in actions test files, clipboard type changes, etc.).
- Ran scoped test attempt: `cargo test -p script-kit-gpui notes::window::tests -- --nocapture`
  - Blocked by the same unrelated repo-wide compile failures.

**How To Test (once repo-wide compile blockers are cleared)**
1. Open Notes window, trigger `Duplicate`, `Copy Deeplink`, `Create Quicklink`, and `Export` with no valid selected note (or stale selection state).
2. Confirm feedback appears: `Selected note could not be found`.
3. For note switcher (`Cmd+P`), trigger a stale `note_{uuid}` action and confirm the same feedback appears and switcher closes.
4. Re-run:
   - `cargo check -p script-kit-gpui`
   - `cargo clippy -p script-kit-gpui --all-targets -- -D warnings`
   - `cargo test -p script-kit-gpui notes::window::tests`

**Risks / Known Gaps**
- Verification is currently blocked by unrelated parallel changes outside this task’s scope, so full green check/clippy could not be completed in this workspace state.
file update:
diff --git a/src/notes/window/notes.rs b/src/notes/window/notes.rs
index 2b96e1be9f619ad7fa8b88d1287b653adb4780b4..449ab857a161bcb00618adf6e45ab022a3ac86fe
--- a/src/notes/window/notes.rs
+++ b/src/notes/window/notes.rs
@@ -231,42 +231,42 @@
     }
 
     /// Export the current note
-    pub(super) fn export_note(&self, format: ExportFormat) {
-        if let Some(id) = self.selected_note_id {
-            if let Some(note) = self.notes.iter().find(|n| n.id == id) {
-                let content = match format {
-                    ExportFormat::PlainText => note.content.clone(),
-                    // For Markdown, just export the content as-is.
-                    // The title is derived from the first line of content,
-                    // so prepending it would cause duplication.
-                    ExportFormat::Markdown => note.content.clone(),
-                    ExportFormat::Html => {
-                        // For HTML, we include proper structure with the title
-                        // and render the content as preformatted text
-                        format!(
-                            "<!DOCTYPE html>\n<html>\n<head><title>{}</title></head>\n<body>\n<h1>{}</h1>\n<pre>{}</pre>\n</body>\n</html>",
-                            note.title, note.title, note.content
-                        )
-                    }
-                };
+    pub(super) fn export_note(&mut self, format: ExportFormat) {
+        let Some((_id, note)) = self.selected_note_for_action("export_note") else {
+            return;
+        };
 
-                // Copy to clipboard
-                #[cfg(target_os = "macos")]
-                {
-                    use std::process::Command;
-                    let _ = Command::new("pbcopy")
-                        .stdin(std::process::Stdio::piped())
-                        .spawn()
-                        .and_then(|mut child| {
-                            use std::io::Write;
-                            if let Some(stdin) = child.stdin.as_mut() {
-                                stdin.write_all(content.as_bytes())?;
-                            }
-                            child.wait()
-                        });
-                    info!(format = ?format, "Note exported to clipboard");
-                }
+        let content = match format {
+            ExportFormat::PlainText => note.content.clone(),
+            // For Markdown, just export the content as-is.
+            // The title is derived from the first line of content,
+            // so prepending it would cause duplication.
+            ExportFormat::Markdown => note.content.clone(),
+            ExportFormat::Html => {
+                // For HTML, we include proper structure with the title
+                // and render the content as preformatted text
+                format!(
+                    "<!DOCTYPE html>\n<html>\n<head><title>{}</title></head>\n<body>\n<h1>{}</h1>\n<pre>{}</pre>\n</body>\n</html>",
+                    note.title, note.title, note.content
+                )
             }
+        };
+
+        // Copy to clipboard
+        #[cfg(target_os = "macos")]
+        {
+            use std::process::Command;
+            let _ = Command::new("pbcopy")
+                .stdin(std::process::Stdio::piped())
+                .spawn()
+                .and_then(|mut child| {
+                    use std::io::Write;
+                    if let Some(stdin) = child.stdin.as_mut() {
+                        stdin.write_all(content.as_bytes())?;
+                    }
+                    child.wait()
+                });
+            info!(format = ?format, "Note exported to clipboard");
         }
     }
 }
diff --git a/src/notes/window/notes_actions.rs b/src/notes/window/notes_actions.rs
index 6405519cffd92b2252b2e410eb3f58ee37800b8d..6d16c492f61a4be231c5a86328a3b9c14112bb7c
--- a/src/notes/window/notes_actions.rs
+++ b/src/notes/window/notes_actions.rs
@@ -1,6 +1,46 @@
 use super::*;
 
 impl NotesApp {
+    const SELECTED_NOTE_NOT_FOUND_FEEDBACK: &'static str = "Selected note could not be found";
+
+    pub(super) fn resolve_selected_note(
+        selected_note_id: Option<NoteId>,
+        notes: &[Note],
+    ) -> Option<(NoteId, &Note)> {
+        let selected_note_id = selected_note_id?;
+        notes
+            .iter()
+            .find(|note| note.id == selected_note_id)
+            .map(|note| (selected_note_id, note))
+    }
+
+    pub(super) fn show_selected_note_missing_feedback(&mut self, action: &'static str) {
+        tracing::warn!(
+            action,
+            selected_note_id = ?self.selected_note_id,
+            notes_len = self.notes.len(),
+            "notes_action_selected_note_not_found",
+        );
+        self.show_action_feedback(Self::SELECTED_NOTE_NOT_FOUND_FEEDBACK, true);
+    }
+
+    pub(super) fn selected_note_for_action(
+        &mut self,
+        action: &'static str,
+    ) -> Option<(NoteId, &Note)> {
+        let Some(selected_note_id) = self.selected_note_id else {
+            self.show_selected_note_missing_feedback(action);
+            return None;
+        };
+
+        if !self.notes.iter().any(|note| note.id == selected_note_id) {
+            self.show_selected_note_missing_feedback(action);
+            return None;
+        }
+
+        Self::resolve_selected_note(Some(selected_note_id), &self.notes)
+    }
+
     /// Cycle sort mode: Updated → Created → Alphabetical → Updated
     pub(super) fn cycle_sort_mode(&mut self, cx: &mut Context<Self>) {
         self.sort_mode = match self.sort_mode {
@@ -86,42 +126,34 @@
         format!("scriptkit://notes/{}", id.as_str())
     }
 
-    pub(super) fn copy_note_as_markdown(&self) {
+    pub(super) fn copy_note_as_markdown(&mut self) {
         self.export_note(ExportFormat::Markdown);
     }
 
-    pub(super) fn copy_note_deeplink(&self) {
-        if let Some(id) = self.selected_note_id {
-            let deeplink = self.note_deeplink(id);
-            self.copy_text_to_clipboard(&deeplink);
-        }
+    pub(super) fn copy_note_deeplink(&mut self) {
+        let Some((id, _)) = self.selected_note_for_action("copy_note_deeplink") else {
+            return;
+        };
+        let deeplink = self.note_deeplink(id);
+        self.copy_text_to_clipboard(&deeplink);
     }
 
-    pub(super) fn create_note_quicklink(&self) {
-        if let Some(id) = self.selected_note_id {
-            let title = self
-                .notes
-                .iter()
-                .find(|note| note.id == id)
-                .map(|note| {
-                    if note.title.is_empty() {
-                        "Untitled Note".to_string()
-                    } else {
-                        note.title.clone()
-                    }
-                })
-                .unwrap_or_else(|| "Untitled Note".to_string());
-            let deeplink = self.note_deeplink(id);
-            let quicklink = format!("[{}]({})", title, deeplink);
-            self.copy_text_to_clipboard(&quicklink);
-        }
+    pub(super) fn create_note_quicklink(&mut self) {
+        let Some((id, note)) = self.selected_note_for_action("create_note_quicklink") else {
+            return;
+        };
+        let title = if note.title.is_empty() {
+            "Untitled Note".to_string()
+        } else {
+            note.title.clone()
+        };
+        let deeplink = self.note_deeplink(id);
+        let quicklink = format!("[{}]({})", title, deeplink);
+        self.copy_text_to_clipboard(&quicklink);
     }
 
     pub(super) fn duplicate_selected_note(&mut self, window: &mut Window, cx: &mut Context<Self>) {
-        let Some(id) = self.selected_note_id else {
-            return;
-        };
-        let Some(note) = self.notes.iter().find(|note| note.id == id) else {
+        let Some((_id, note)) = self.selected_note_for_action("duplicate_selected_note") else {
             return;
         };
 
diff --git a/src/notes/window/panels.rs b/src/notes/window/panels.rs
index 16b4b85b9be89780b4c9430f0db050a9af14532e..b843238a1e9103f6055702cf09dc506f1e99fa17
--- a/src/notes/window/panels.rs
+++ b/src/notes/window/panels.rs
@@ -281,6 +281,17 @@
                 self.select_note(note_id, window, cx);
                 return;
             }
+
+            tracing::warn!(
+                action_id,
+                note_id_str,
+                selected_note_id = ?self.selected_note_id,
+                notes_len = self.notes.len(),
+                "notes_note_switcher_selected_note_not_found",
+            );
+            self.show_selected_note_missing_feedback("execute_note_switcher_action");
+            self.close_browse_panel(window, cx);
+            return;
         }
 
         // Handle "no_notes" placeholder action
diff --git a/src/notes/window/tests.rs b/src/notes/window/tests.rs
index 8cb070d17ec066ba2b9e5a81de39cf1dfd19742b..441dc8b615019a2f05ba8f031d6bad5a449dd4a1
--- a/src/notes/window/tests.rs
+++ b/src/notes/window/tests.rs
@@ -1,4 +1,4 @@
-use super::NotesApp;
+use super::{Note, NoteId, NotesApp};
 
 #[test]
 fn formatting_replacement_wraps_selected_text() {
@@ -37,3 +37,31 @@
     assert_eq!(new_value, "he****llo");
     assert_eq!(new_selection, 4..4);
 }
+
+#[test]
+fn test_resolve_selected_note_returns_none_when_selection_is_missing() {
+    let notes = vec![Note::with_content("one"), Note::with_content("two")];
+
+    let selected = NotesApp::resolve_selected_note(None, &notes);
+
+    assert!(selected.is_none());
+}
+
+#[test]
+fn test_resolve_selected_note_returns_none_when_selection_is_stale() {
+    let notes = vec![Note::with_content("one"), Note::with_content("two")];
+
+    let selected = NotesApp::resolve_selected_note(Some(NoteId::new()), &notes);
+
+    assert!(selected.is_none());
+}
+
+#[test]
+fn test_resolve_selected_note_returns_note_when_selection_exists() {
+    let notes = vec![Note::with_content("one"), Note::with_content("two")];
+    let selected_id = notes[1].id;
+
+    let selected = NotesApp::resolve_selected_note(Some(selected_id), &notes);
+
+    assert_eq!(selected.map(|(id, note)| (id, note.id)), Some((selected_id, selected_id)));
+}

tokens used
302,001
Implemented the stale/missing selected-note feedback fix in the scoped notes window paths.

**Changed Files**
- `src/notes/window/notes_actions.rs`
  - Added shared selection resolver + feedback helpers:
    - `resolve_selected_note(...)`
    - `show_selected_note_missing_feedback(...)`
    - `selected_note_for_action(...)`
  - Updated:
    - `copy_note_as_markdown` to mutable receiver
    - `copy_note_deeplink` to validate selected note and show feedback when stale/missing
    - `create_note_quicklink` to validate selected note and show feedback when stale/missing
    - `duplicate_selected_note` to use shared stale/missing feedback path
- `src/notes/window/notes.rs`
  - Updated `export_note` to mutable receiver and to use shared selected-note validation/feedback instead of silent return.
- `src/notes/window/panels.rs`
  - In `execute_note_switcher_action`, stale `note_{uuid}` actions now show missing-note feedback and close browse panel instead of silent close/warn-only.
- `src/notes/window/tests.rs`
  - Added unit tests for selected-note resolution:
    - `test_resolve_selected_note_returns_none_when_selection_is_missing`
    - `test_resolve_selected_note_returns_none_when_selection_is_stale`
    - `test_resolve_selected_note_returns_note_when_selection_exists`

**Verification Run**
- Ran: `cargo check -p script-kit-gpui`
  - Fails due unrelated concurrent workspace issues (not in notes scope), e.g.:
    - `src/clipboard_history/database.rs` missing fields in `ClipboardEntry`
    - non-exhaustive `ContentType` matches in clipboard modules
- Ran: `cargo clippy -p script-kit-gpui --all-targets -- -D warnings`
  - Fails due broad unrelated errors/warnings in other modules/tests (duplicate test modules, missing imports/types in actions test files, clipboard type changes, etc.).
- Ran scoped test attempt: `cargo test -p script-kit-gpui notes::window::tests -- --nocapture`
  - Blocked by the same unrelated repo-wide compile failures.

**How To Test (once repo-wide compile blockers are cleared)**
1. Open Notes window, trigger `Duplicate`, `Copy Deeplink`, `Create Quicklink`, and `Export` with no valid selected note (or stale selection state).
2. Confirm feedback appears: `Selected note could not be found`.
3. For note switcher (`Cmd+P`), trigger a stale `note_{uuid}` action and confirm the same feedback appears and switcher closes.
4. Re-run:
   - `cargo check -p script-kit-gpui`
   - `cargo clippy -p script-kit-gpui --all-targets -- -D warnings`
   - `cargo test -p script-kit-gpui notes::window::tests`

**Risks / Known Gaps**
- Verification is currently blocked by unrelated parallel changes outside this task’s scope, so full green check/clippy could not be completed in this workspace state.


==== exit @ 2026-02-07T23:49:52.228Z code=0 status=done ====
