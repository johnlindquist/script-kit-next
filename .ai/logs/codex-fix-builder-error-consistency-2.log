==== spawn @ 2026-02-08T00:15:57.052Z ====
cmd: codex "exec" "--cd" "/Users/johnlindquist/dev/script-kit-gpui" "--model" "gpt-5.3-codex" "-c" "model_reasoning_effort=\"xhigh\"" "-c" "model_auto_compact_token_limit=120000" "-c" "developer_instructions=\"You are Codex implementer agent \\\"codex-fix-builder-error-consistency-2\\\".\\n\\n## Coordination\\nThis repo runs parallel agents in ONE working tree. Before editing any file, you MUST claim it.\\nCommands (run via shell):\\n  - View roster: ~/.claude/bin/swarm.ts status\\n  - Claim files (blocks until free): ~/.claude/bin/swarm.ts claim --wait --id codex-fix-builder-error-consistency-2 path/to/file\\n  - Release: ~/.claude/bin/swarm.ts release --id codex-fix-builder-error-consistency-2 path/to/file\\n  - Update status/notes: ~/.claude/bin/swarm.ts update --id codex-fix-builder-error-consistency-2 --status in_progress --notes \\\"...\\\"\\nRules:\\n  - Never edit a file you haven't claimed.\\n  - Keep claims tight (claim only what you're actively changing).\\n  - If blocked, set status=blocked and say what you're waiting on.\\n  - When finished, set status=done and release claims.\\n\\n## Development practices (this code is maintained by AI agents)\\n  - Log state transitions with enough context to diagnose failures from logs alone.\\n  - Structured errors: include what was attempted, what failed, and current state.\\n  - Name things for grepability — unique identifiers agents can find on the first search.\\n  - Every behavior change gets a test. Untested code is invisible to the next agent.\\n  - Test names describe the scenario: test_X_does_Y_when_Z.\\n  - Keep functions small and single-purpose. 500-line functions burn agent context.\\n  - Use types to encode constraints (enums > strings for errors).\\n\\n## CRITICAL: Parallel-safe verification\\n  - Other agents are modifying other files RIGHT NOW. Full test suites WILL show their failures.\\n  - ONLY run tests that cover YOUR changed files. Scope every test/check command:\\n    Rust: cargo test -p your-crate -- module::test_name | JS: npx jest your/file.test.ts\\n  - Do NOT run: cargo test (unscoped), cargo check (whole workspace), npm test (unscoped).\\n  - If a scoped test fails, it's YOUR bug — fix it. If tests outside your scope fail, ignore them.\\n\\n## Git commit discipline\\n  - NEVER commit unverified work. Run tests/lints/type-checks FIRST. If it fails, fix it before committing.\\n  - A commit is a declaration: \\\"this works and here's the proof.\\\"\\n  - Commit FREQUENTLY — after each meaningful unit of VERIFIED work, not just at the end.\\n  - A \\\"unit\\\" = one logical change that passes verification (new function, bug fix, refactor, test added).\\n  - NEVER batch an entire task into one giant commit. Small commits are searchable; big ones aren't.\\n  - Commit message format:\\n      Line 1: <type>(<scope>): <what changed> (imperative, max 72 chars)\\n      Line 3+: WHY this change was made, WHAT was verified, and HOW to test it.\\n    Types: feat, fix, refactor, test, docs, chore\\n    Example:\\n      feat(auth): add refresh token rotation\\n      \\n      Tokens now rotate on each refresh call to prevent replay attacks.\\n      The old token is invalidated immediately on rotation.\\n      \\n      Verified: cargo test --lib -- auth::refresh (4 tests pass)\\n      Verified: manual smoke test via curl — token rotates, old token returns 401\\n  - The \\\"Verified:\\\" lines are REQUIRED. Future agents will read git log to understand\\n    what was tested and how to re-verify. This is the most valuable part of the message.\\n  - In your final message, list all commits you made with their hashes.\\n\\n## Time budget\\nYou have approximately 10 minutes. If your task is too broad to complete in time:\\n(1) Commit any verified progress.\\n(2) Run: ~/.claude/bin/swarm.ts update --id YOUR_ID --status needs_split --notes 'suggest: 1) sub-task-desc scope:files 2) sub-task-desc scope:files'.\\n(3) Exit cleanly. The dispatcher will read your suggestions and spawn narrower workers.\"" "--output-last-message" "/Users/johnlindquist/dev/script-kit-gpui/.ai/logs/codex-fix-builder-error-consistency-2.final.md" "--yolo" "You are agent codex-fix-builder-error-consistency-2.\n\nCurrent parallel-agent roster (read this first):\n```\nSWARM SNAPSHOT @ 2026-02-08T00:15:57.049Z\n- codex-fix-action-id-namespace [in_progress] scope=src/actions/builders/file_path.rs,src/actions/builders/clipboard.rs,src/actions/builders/chat.rs task=CONSISTENCY FIX: Action IDs can overlap across different builder functions. Add namespace prefixes to action IDs by bui…\n  claims: src/actions/builders/file_path.rs, src/actions/builders/clipboard.rs, src/actions/builders/chat.rs, src/app_actions/handle_action.rs, src/app_impl/execution_paths.rs, src/app_impl/chat_actions.rs, sr…\n  notes: auditing action ids and handlers in scoped builders for namespacing | [claim-wait] codex-fix-builder-error-consistency waiting for src/actions/builders/chat.rs\n- codex-fix-builder-error-consistency [blocked] scope=src/actions/builders/chat.rs,src/actions/builders/clipboard.rs,src/actions/builders/file_path.rs task=CONSISTENCY FIX: Make error handling consistent across all action builders. Currently some builders silently return emp…\n  notes: waiting for claims on chat/clipboard/file_path builders currently held by codex-fix-action-id-namespace\n- codex-fix-builder-error-consistency-2 [starting] scope=src/actions/builders/notes.rs,src/actions/builders/scri…\n```\n\nYour assignment:\n- Task: CONSISTENCY FIX: Make error handling consistent across action builders part 2. Ensure builders in src/actions/builders/notes.rs, src/actions/builders/script_context.rs, src/actions/builders/scriptlet.rs follow same pattern as other builders: (1) Return empty Vec with tracing::warn when input is invalid (2) Never panic/unwrap (3) Consistent log levels. After fix, run cargo check && cargo clippy --all-targets -- -D warnings\n- Scope: src/actions/builders/notes.rs,src/actions/builders/script_context.rs,src/actions/builders/scriptlet.rs\n\nOperating constraints:\n- Single working tree (no worktrees, no patches).\n- You MUST claim files before editing (~/.claude/bin/swarm.ts claim --wait ...).\n\nDeliverables:\n- Make the code changes required by the task.\n- Run the most relevant tests/linters.\n- In your FINAL message, include: changed files, how to test, and any risks/known gaps."

OpenAI Codex v0.98.0 (research preview)
--------
workdir: /Users/johnlindquist/dev/script-kit-gpui
model: gpt-5.3-codex
provider: openai
approval: never
sandbox: danger-full-access
reasoning effort: xhigh
reasoning summaries: auto
session id: 019c3a9a-eaaf-7900-94ed-80d457ba0629
--------
user
You are agent codex-fix-builder-error-consistency-2.

Current parallel-agent roster (read this first):
```
SWARM SNAPSHOT @ 2026-02-08T00:15:57.049Z
- codex-fix-action-id-namespace [in_progress] scope=src/actions/builders/file_path.rs,src/actions/builders/clipboard.rs,src/actions/builders/chat.rs task=CONSISTENCY FIX: Action IDs can overlap across different builder functions. Add namespace prefixes to action IDs by bui…
  claims: src/actions/builders/file_path.rs, src/actions/builders/clipboard.rs, src/actions/builders/chat.rs, src/app_actions/handle_action.rs, src/app_impl/execution_paths.rs, src/app_impl/chat_actions.rs, sr…
  notes: auditing action ids and handlers in scoped builders for namespacing | [claim-wait] codex-fix-builder-error-consistency waiting for src/actions/builders/chat.rs
- codex-fix-builder-error-consistency [blocked] scope=src/actions/builders/chat.rs,src/actions/builders/clipboard.rs,src/actions/builders/file_path.rs task=CONSISTENCY FIX: Make error handling consistent across all action builders. Currently some builders silently return emp…
  notes: waiting for claims on chat/clipboard/file_path builders currently held by codex-fix-action-id-namespace
- codex-fix-builder-error-consistency-2 [starting] scope=src/actions/builders/notes.rs,src/actions/builders/scri…
```

Your assignment:
- Task: CONSISTENCY FIX: Make error handling consistent across action builders part 2. Ensure builders in src/actions/builders/notes.rs, src/actions/builders/script_context.rs, src/actions/builders/scriptlet.rs follow same pattern as other builders: (1) Return empty Vec with tracing::warn when input is invalid (2) Never panic/unwrap (3) Consistent log levels. After fix, run cargo check && cargo clippy --all-targets -- -D warnings
- Scope: src/actions/builders/notes.rs,src/actions/builders/script_context.rs,src/actions/builders/scriptlet.rs

Operating constraints:
- Single working tree (no worktrees, no patches).
- You MUST claim files before editing (~/.claude/bin/swarm.ts claim --wait ...).

Deliverables:
- Make the code changes required by the task.
- Run the most relevant tests/linters.
- In your FINAL message, include: changed files, how to test, and any risks/known gaps.
warning: Under-development features enabled: responses_websockets. Under-development features are incomplete and may behave unpredictably. To suppress this warning, set `suppress_unstable_features_warning = true` in /Users/johnlindquist/.codex/config.toml.
mcp: deepwiki starting
mcp: deepwiki ready
mcp startup: ready: deepwiki

thinking
**Resolving conflicting verification instructions**
codex
I’ll take the three builder files in your assigned scope, claim them in swarm first, then audit each for invalid-input behavior and logging consistency before making targeted edits. After changes, I’ll run scoped Rust checks/lints and report exact results.
exec
/bin/zsh -lc '~/.claude/bin/swarm.ts status && ~/.claude/bin/swarm.ts update --id codex-fix-builder-error-consistency-2 --status in_progress --notes "claiming notes/script_context/scriptlet for error-handling consistency audit"' in /Users/johnlindquist/dev/script-kit-gpui succeeded in 51ms:
Repo: /Users/johnlindquist/dev/script-kit-gpui
Updated: 2026-02-08T00:16:11.774Z

Active agents (4):
codex-fix-action-id-namespace [in_progress] codex/gpt-5.3-codex/exec
  task: CONSISTENCY FIX: Action IDs can overlap across different builder functions. Add namespace prefixes to action IDs by bui…
  scope: src/actions/builders/file_path.rs,src/actions/builders/clipboard.rs,src/actions/builders/chat.rs
  claims(7): src/actions/builders/file_path.rs, src/actions/builders/clipboard.rs, src/actions/builders/chat.rs, src/app_actions/handle_action.rs, src/app_impl/execution_pa…
  notes: auditing action ids and handlers in scoped builders for namespacing | [claim-wait] codex-fix-builder-error-consistency waiting for src/actions/builders/chat.rs

codex-fix-builder-error-consistency [blocked] codex/gpt-5.3-codex/exec
  task: CONSISTENCY FIX: Make error handling consistent across all action builders. Currently some builders silently return emp…
  scope: src/actions/builders/chat.rs,src/actions/builders/clipboard.rs,src/actions/builders/file_path.rs
  claims: (none)
  notes: waiting for claims on chat/clipboard/file_path builders currently held by codex-fix-action-id-namespace

codex-fix-builder-error-consistency-2 [in_progress] codex/gpt-5.3-codex/exec
  task: CONSISTENCY FIX: Make error handling consistent across action builders part 2. Ensure builders in src/actions/builders/…
  scope: src/actions/builders/notes.rs,src/actions/builders/script_context.rs,src/actions/builders/scriptlet.rs
  claims: (none)

thinking
**Prioritizing claims on notes and context files**
codex
I found one active agent currently holding `src/actions/builders/scriptlet.rs`, so I’m claiming `notes.rs` and `script_context.rs` first and will update once I can safely claim `scriptlet.rs`.
exec
/bin/zsh -lc '~/.claude/bin/swarm.ts claim --wait --id codex-fix-builder-error-consistency-2 src/actions/builders/notes.rs && ~/.claude/bin/swarm.ts claim --wait --id codex-fix-builder-error-consistency-2 src/actions/builders/script_context.rs' in /Users/johnlindquist/dev/script-kit-gpui succeeded in 51ms:
Claimed for codex-fix-builder-error-consistency-2: src/actions/builders/notes.rs
Claimed for codex-fix-builder-error-consistency-2: src/actions/builders/script_context.rs

thinking
**Planning pattern inspection**
codex
I’ve secured `notes.rs` and `script_context.rs`; next I’m auditing their current invalid-input branches and comparing against existing builder patterns so the fixes stay consistent with project conventions.
exec
/bin/zsh -lc "sed -n '1,240p' src/actions/builders/notes.rs" in /Users/johnlindquist/dev/script-kit-gpuiexec
/bin/zsh -lc "sed -n '1,260p' src/actions/builders/script_context.rs" in /Users/johnlindquist/dev/script-kit-gpuiexec
/bin/zsh -lc 'rg -n "tracing::warn|return vec!'"\\[\\]|invalid|empty\" src/actions/builders -g '*.rs'" in /Users/johnlindquist/dev/script-kit-gpui succeeded in 51ms:
use super::types::{Action, ActionCategory};
use crate::designs::icon_variations::IconName;

/// Information about a model for the new chat dropdown
#[derive(Debug, Clone)]
#[allow(dead_code)]
pub struct NewChatModelInfo {
    pub model_id: String,
    pub display_name: String,
    pub provider: String,
    pub provider_display_name: String,
}

/// Information about a preset for the new chat dropdown
#[derive(Debug, Clone)]
pub struct NewChatPresetInfo {
    pub id: String,
    pub name: String,
    pub icon: IconName,
}
 succeeded in 51ms:
use super::shared::to_deeplink_name;
use super::types::{Action, ActionCategory, ScriptInfo};
use std::collections::HashSet;

/// Get actions specific to the focused script.
pub fn get_script_context_actions(script: &ScriptInfo) -> Vec<Action> {
    let mut actions = Vec::new();
    let mut destructive_actions = Vec::new();

    tracing::debug!(
        target: "script_kit::actions",
        name = %script.name,
        is_script = script.is_script,
        is_scriptlet = script.is_scriptlet,
        is_agent = script.is_agent,
        has_shortcut = script.shortcut.is_some(),
        has_alias = script.alias.is_some(),
        is_suggested = script.is_suggested,
        "Building script context actions"
    );
 succeeded in 51ms:
src/actions/builders/shared.rs:15:        .filter(|s| !s.is_empty())
src/actions/builders/shared.rs:19:    if normalized.is_empty() {
src/actions/builders/shared.rs:94:    fn test_to_deeplink_name_returns_unnamed_when_input_is_empty_or_symbols() {
src/actions/builders/scriptlet.rs:11:        .filter(|command| !command.trim().is_empty())
src/actions/builders/scriptlet.rs:20:        tracing::warn!(
src/actions/builders/scriptlet.rs:88:    if !actions.is_empty() {
src/actions/builders/scriptlet.rs:329:    fn test_get_scriptlet_defined_actions_drops_action_when_command_is_empty() {
src/actions/builders/scriptlet.rs:338:        assert!(actions.is_empty());
src/actions/builders/notes.rs:462:        let description = if !note.preview.is_empty() {
src/actions/builders/notes.rs:469:            if note.relative_time.is_empty() {
src/actions/builders/notes.rs:474:        } else if !note.relative_time.is_empty() {
src/actions/builders/notes.rs:498:    if actions.is_empty() {
src/actions/builders/script_context.rs:293:    if !duplicate_ids.is_empty() {
src/actions/builders/script_context.rs:294:        tracing::warn!(

thinking
**Planning full file inspections**
codex
I found `notes.rs` and `script_context.rs` are larger than the initial snippet; I’m now reading their full builders and tests to pinpoint exactly where invalid input currently returns silently or logs inconsistently.
exec
/bin/zsh -lc "nl -ba src/actions/builders/notes.rs | sed -n '1,260p'" in /Users/johnlindquist/dev/script-kit-gpuiexec
/bin/zsh -lc "nl -ba src/actions/builders/script_context.rs | sed -n '1,380p'" in /Users/johnlindquist/dev/script-kit-gpuiexec
/bin/zsh -lc "nl -ba src/actions/builders/notes.rs | sed -n '261,620p'" in /Users/johnlindquist/dev/script-kit-gpui succeeded in 51ms:
     1	use super::types::{Action, ActionCategory};
     2	use crate::designs::icon_variations::IconName;
     3	
     4	/// Information about a model for the new chat dropdown
     5	#[derive(Debug, Clone)]
     6	#[allow(dead_code)]
     7	pub struct NewChatModelInfo {
     8	    pub model_id: String,
     9	    pub display_name: String,
    10	    pub provider: String,
    11	    pub provider_display_name: String,
    12	}
    13	
    14	/// Information about a preset for the new chat dropdown
    15	#[derive(Debug, Clone)]
    16	pub struct NewChatPresetInfo {
    17	    pub id: String,
    18	    pub name: String,
    19	    pub icon: IconName,
    20	}
 succeeded in 50ms:
     1	use super::shared::to_deeplink_name;
     2	use super::types::{Action, ActionCategory, ScriptInfo};
     3	use std::collections::HashSet;
     4	
     5	/// Get actions specific to the focused script.
     6	pub fn get_script_context_actions(script: &ScriptInfo) -> Vec<Action> {
     7	    let mut actions = Vec::new();
     8	    let mut destructive_actions = Vec::new();
     9	
    10	    tracing::debug!(
    11	        target: "script_kit::actions",
    12	        name = %script.name,
    13	        is_script = script.is_script,
    14	        is_scriptlet = script.is_scriptlet,
    15	        is_agent = script.is_agent,
    16	        has_shortcut = script.shortcut.is_some(),
    17	        has_alias = script.alias.is_some(),
    18	        is_suggested = script.is_suggested,
    19	        "Building script context actions"
    20	    );
 succeeded in 50ms:
   261	        assert_eq!(restore_note.shortcut.as_deref(), Some("⌘Z"));
   262	        assert_eq!(
   263	            restore_note.description.as_deref(),
   264	            Some("Restore the current note from trash")
   265	        );
   266	        assert_eq!(restore_note.section.as_deref(), Some("Trash"));
   267	
   268	        assert_eq!(permanently_delete_note.title, "Delete Permanently");
   269	        assert_eq!(permanently_delete_note.shortcut.as_deref(), None);
   270	        assert_eq!(
   271	            permanently_delete_note.description.as_deref(),
   272	            Some("Permanently delete the current note")
   273	        );
   274	        assert_eq!(permanently_delete_note.section.as_deref(), Some("Trash"));
   275	    }
   276	
   277	    #[test]
   278	    fn test_get_notes_command_bar_actions_excludes_trash_actions_when_no_selection_in_trash() {
   279	        let info = NotesInfo {
   280	            has_selection: false,

thinking
**Inspecting existing scriptlet file**
exec
/bin/zsh -lc "nl -ba src/actions/builders/scriptlet.rs | sed -n '1,420p'" in /Users/johnlindquist/dev/script-kit-gpui succeeded in 52ms:
     1	use super::shared::{format_shortcut_hint, to_deeplink_name};
     2	use super::types::{Action, ActionCategory, ScriptInfo};
     3	use crate::scriptlets::Scriptlet;
     4	use std::collections::HashSet;
     5	
     6	const SCRIPTLET_ACTION_ID_PREFIX: &str = "scriptlet_action:";
     7	
     8	fn parse_scriptlet_action_command(action_id: &str) -> Option<&str> {
     9	    action_id
    10	        .strip_prefix(SCRIPTLET_ACTION_ID_PREFIX)
    11	        .filter(|command| !command.trim().is_empty())
    12	}
    13	
    14	fn unique_scriptlet_action_id(
    15	    raw_action_id: &str,
    16	    action_name: &str,
    17	    used_action_ids: &mut HashSet<String>,
    18	) -> Option<String> {
    19	    let Some(action_command) = parse_scriptlet_action_command(raw_action_id) else {
    20	        tracing::warn!(

thinking
**Inspecting builder validation patterns**
exec
/bin/zsh -lc 'rg -n "return vec!'"\\[\\];|tracing::warn"'!'"\\(|invalid .*input|failed to parse|dropping\" src/actions/builders/*.rs" in /Users/johnlindquist/dev/script-kit-gpui succeeded in 50ms:
src/actions/builders/script_context.rs:294:        tracing::warn!(
src/actions/builders/scriptlet.rs:20:        tracing::warn!(
src/actions/builders/scriptlet.rs:24:            "Failed to parse scriptlet H3 action id; dropping malformed action"

thinking
**Inspecting builder input validation**
exec
/bin/zsh -lc 'ls src/actions/builders' in /Users/johnlindquist/dev/script-kit-gpui succeeded in 50ms:
chat.rs
clipboard.rs
file_path.rs
notes.rs
script_context.rs
scriptlet.rs
shared.rs
tests.rs

thinking
**Checking concurrent state changes**
codex
I’ve confirmed these three files are currently the only ones using warn-level builder logs; I’m now checking sibling builders (`chat/clipboard/file_path`) to mirror the exact invalid-input pattern those use.
exec
/bin/zsh -lc "nl -ba src/actions/builders/chat.rs | sed -n '1,260p'" in /Users/johnlindquist/dev/script-kit-gpuiexec
/bin/zsh -lc "nl -ba src/actions/builders/clipboard.rs | sed -n '1,260p'" in /Users/johnlindquist/dev/script-kit-gpuiexec
/bin/zsh -lc "nl -ba src/actions/builders/file_path.rs | sed -n '1,320p'" in /Users/johnlindquist/dev/script-kit-gpui succeeded in 51ms:
     1	use super::types::{Action, ActionCategory};
     2	use crate::designs::icon_variations::IconName;
     3	
     4	/// Information about a chat prompt for action building
     5	#[derive(Debug, Clone)]
     6	pub struct ChatPromptInfo {
     7	    pub current_model: Option<String>,
     8	    pub available_models: Vec<ChatModelInfo>,
     9	    pub has_messages: bool,
    10	    pub has_response: bool,
    11	}
    12	
    13	/// Information about an available chat model
    14	#[derive(Debug, Clone)]
    15	pub struct ChatModelInfo {
    16	    pub id: String,
    17	    pub display_name: String,
    18	    pub provider: String,
    19	}
    20	
 succeeded in 50ms:
     1	use super::types::{Action, ActionCategory};
     2	use crate::file_search::FileInfo;
     3	use crate::prompts::PathInfo;
     4	
     5	/// Get actions specific to a file search result
     6	///
     7	/// Actions vary based on whether the item is a file or directory:
     8	/// - Directory: `file:open_directory` as primary
     9	/// - File: `file:open_file` as primary, plus Quick Look (macOS)
    10	///
    11	/// Common actions for both: file:reveal_in_finder, file:copy_path, file:copy_filename
    12	pub fn get_file_context_actions(file_info: &FileInfo) -> Vec<Action> {
    13	    let mut actions = Vec::new();
    14	
    15	    tracing::debug!(
    16	        target: "script_kit::actions",
    17	        name = %file_info.name,
    18	        is_dir = file_info.is_dir,
    19	        "Building file context actions"
    20	    );
 succeeded in 50ms:
     1	use super::types::{Action, ActionCategory};
     2	use crate::clipboard_history::ContentType;
     3	
     4	/// Information about a clipboard history entry for action building
     5	#[derive(Debug, Clone)]
     6	pub struct ClipboardEntryInfo {
     7	    /// Entry ID in the database
     8	    pub id: String,
     9	    /// Content type (text or image)
    10	    pub content_type: ContentType,
    11	    /// Whether the entry is pinned
    12	    pub pinned: bool,
    13	    /// Preview text (for text entries)
    14	    pub preview: String,
    15	    /// Image dimensions (for image entries)
    16	    #[allow(dead_code)]
    17	    pub image_dimensions: Option<(u32, u32)>,
    18	    /// Name of the frontmost app (for "Paste to [AppName]" action title)
    19	    pub frontmost_app_name: Option<String>,
    20	}

thinking
**Assessing error handling pattern**
exec
/bin/zsh -lc "rg --files src/actions | rg 'builders/.+types|builders/mod|actions/builders.rs' && nl -ba src/actions/builders.rs | sed -n '1,260p'" in /Users/johnlindquist/dev/script-kit-gpui succeeded in 51ms:
src/actions/builders.rs
     1	//! Action builders
     2	//!
     3	//! Factory functions for creating context-specific action lists.
     4	
     5	mod chat;
     6	mod clipboard;
     7	mod file_path;
     8	mod notes;
     9	mod script_context;
    10	mod scriptlet;
    11	mod shared;
    12	
    13	pub use chat::{ChatModelInfo, ChatPromptInfo};
    14	pub use clipboard::ClipboardEntryInfo;
    15	pub use notes::{NewChatModelInfo, NewChatPresetInfo, NoteSwitcherNoteInfo, NotesInfo};
    16	pub use shared::to_deeplink_name;
    17	
    18	#[allow(unused_imports)]
    19	pub(crate) use scriptlet::get_scriptlet_defined_actions;

thinking
**Searching for types module**
exec
/bin/zsh -lc "rg -n \"pub struct ScriptInfo|pub struct Action|enum ActionCategory\" src/actions -g '*.rs'" in /Users/johnlindquist/dev/script-kit-gpui succeeded in 51ms:
src/actions/dialog/part_01.rs:268:pub struct ActionsDialog {
src/actions/window/part_01.rs:219:pub struct ActionsWindow {
src/actions/types/script_info.rs:53:pub struct ScriptInfo {
src/actions/types/action_model.rs:44:pub struct Action {
src/actions/types/action_model.rs:133:pub struct ActionsDialogConfig {
src/actions/types/action_model.rs:156:pub enum ActionCategory {

thinking
**Inspecting action model structure**
exec
/bin/zsh -lc "nl -ba src/actions/types/script_info.rs | sed -n '1,260p'" in /Users/johnlindquist/dev/script-kit-gpui succeeded in 51ms:
     1	// Action types and data structures
     2	//
     3	// Core types for the actions system including Action, ActionCategory, and ScriptInfo.
     4	//
     5	// # Architecture Overview
     6	//
     7	// The actions system is **intentionally decoupled** from the standard selection callbacks:
     8	//
     9	// - **on_select callback is bypassed by design** for keyboard navigation
    10	// - Actions route through `handle_action()` in the main app via keyboard events
    11	// - This enables consistent keyboard-driven action execution across all contexts
    12	//
    13	// ## Key Types
    14	//
    15	// - [`Action`]: Represents a single action item with id, title, category, and optional shortcut
    16	// - [`ActionCategory`]: Categorizes actions (ScriptContext, ScriptOps, GlobalOps)
    17	// - [`ScriptInfo`]: Context about the focused script/item for building context-specific actions
    18	//
    19	// ## Action ID Conventions
    20	//
exec
/bin/zsh -lc "nl -ba src/actions/types/action_model.rs | sed -n '1,240p'" in /Users/johnlindquist/dev/script-kit-gpui succeeded in 52ms:
     1	/// Represents a single action item in the actions menu.
     2	///
     3	/// Actions are created by builder functions in `builders.rs` or converted from
     4	/// SDK-provided `ProtocolAction` messages. Each action has a unique identifier,
     5	/// display title, and category for grouping.
     6	///
     7	/// # Action ID Convention
     8	///
     9	/// - Built-in actions: snake_case IDs (`edit_script`, `copy_path`, etc.)
    10	/// - SDK actions: Use the `name` field from ProtocolAction as-is
    11	/// - Scriptlet actions: Prefixed with `scriptlet_action:` followed by command
    12	///
    13	/// # Routing via has_action
    14	///
    15	/// The `has_action` field determines how actions are executed:
    16	/// - `false` (default for built-ins): Handle locally in Rust via `handle_action()`
    17	/// - `true` (SDK actions): Send `ActionTriggered` message to script for handling
    18	///
    19	/// Note: The routing logic in `handle_action()` may also read from the original
    20	/// `ProtocolAction` for SDK-provided actions to ensure consistency.

thinking
**Planning test inspection for builders**
exec
/bin/zsh -lc "nl -ba src/actions/builders/tests.rs | sed -n '1,360p'" in /Users/johnlindquist/dev/script-kit-gpuiexec
/bin/zsh -lc "nl -ba src/actions/builders_tests.rs | sed -n '1,420p'" in /Users/johnlindquist/dev/script-kit-gpui succeeded in 51ms:
     1	// Builders-specific tests live in `src/actions/builders_tests.rs`.
 succeeded in 50ms:
     1	include!("builders_tests/part_01.rs");
     2	include!("builders_tests/part_02.rs");
     3	include!("builders_tests/part_03.rs");
     4	include!("builders_tests/part_04.rs");

thinking
**Inspecting test inputs for invalid cases**
exec
/bin/zsh -lc "rg -n \"get_note_switcher_actions|get_notes_command_bar_actions|get_new_chat_actions|get_script_context_actions|get_scriptlet_context_actions_with_custom|get_scriptlet_defined_actions|invalid|warn|empty\" src/actions/builders_tests -g '*.rs'" in /Users/johnlindquist/dev/script-kit-gpui succeeded in 52ms:
src/actions/builders_tests/part_04.rs:6:fn new_chat_actions_empty_inputs() {
src/actions/builders_tests/part_04.rs:7:    let actions = get_new_chat_actions(&[], &[], &[]);
src/actions/builders_tests/part_04.rs:8:    assert!(actions.is_empty(), "No inputs should produce no actions");
src/actions/builders_tests/part_04.rs:27:    let actions = get_new_chat_actions(&last_used, &[], &[]);
src/actions/builders_tests/part_04.rs:54:    let actions = get_new_chat_actions(&[], &presets, &[]);
src/actions/builders_tests/part_04.rs:77:    let actions = get_new_chat_actions(&[], &[], &models);
src/actions/builders_tests/part_04.rs:106:    let actions = get_new_chat_actions(&last_used, &presets, &models);
src/actions/builders_tests/part_04.rs:135:    let actions = get_new_chat_actions(&last_used, &presets, &models);
src/actions/builders_tests/part_04.rs:155:    let actions = get_script_context_actions(&agent);
src/actions/builders_tests/part_04.rs:182:    let actions = get_script_context_actions(&agent);
src/actions/builders_tests/part_04.rs:198:    let actions = get_script_context_actions(&agent);
src/actions/builders_tests/part_04.rs:221:    let actions = get_script_context_actions(&agent);
src/actions/builders_tests/part_04.rs:232:    let actions = get_script_context_actions(&script);
src/actions/builders_tests/part_02.rs:83:    let empty = ChatPromptInfo {
src/actions/builders_tests/part_02.rs:89:    let actions = get_chat_context_actions(&empty);
src/actions/builders_tests/part_02.rs:144:    let actions = get_script_context_actions(&script);
src/actions/builders_tests/part_02.rs:175:    let actions = get_script_context_actions(&script);
src/actions/builders_tests/part_02.rs:296:    let actions = get_notes_command_bar_actions(&info);
src/actions/builders_tests/part_02.rs:325:    let actions = get_notes_command_bar_actions(&info);
src/actions/builders_tests/part_02.rs:355:    let actions = get_notes_command_bar_actions(&info);

thinking
**Planning test inspection**
exec
/bin/zsh -lc "nl -ba src/actions/builders_tests/part_02.rs | sed -n '120,260p'" in /Users/johnlindquist/dev/script-kit-gpuiexec
/bin/zsh -lc "nl -ba src/actions/builders_tests/part_03.rs | sed -n '1,320p'" in /Users/johnlindquist/dev/script-kit-gpuiexec
/bin/zsh -lc "nl -ba src/actions/builders_tests/part_02.rs | sed -n '260,430p'" in /Users/johnlindquist/dev/script-kit-gpui succeeded in 51ms:
   120	    assert_eq!(to_deeplink_name("Clipboard History"), "clipboard-history");
   121	    assert_eq!(to_deeplink_name("hello_world"), "hello-world");
   122	}
   123	
   124	#[test]
   125	fn deeplink_name_strips_special_chars() {
   126	    assert_eq!(to_deeplink_name("hello@world!"), "hello-world");
   127	    assert_eq!(to_deeplink_name("  spaced  out  "), "spaced-out");
   128	    assert_eq!(to_deeplink_name("---dashes---"), "dashes");
   129	}
   130	
   131	#[test]
   132	fn deeplink_name_preserves_alphanumeric() {
   133	    assert_eq!(to_deeplink_name("script123"), "script123");
   134	    assert_eq!(to_deeplink_name("ABC"), "abc");
   135	}
   136	
   137	// ============================================================
   138	// 6. Script context actions: sections + destructive ordering
   139	// ============================================================
 succeeded in 51ms:
     1	// 8. Scriptlet context actions with custom H3 actions
     2	// ============================================================
     3	
     4	#[test]
     5	fn scriptlet_context_includes_shortcut_and_alias_dynamics() {
     6	    // Scriptlet with shortcut + alias
     7	    let info = ScriptInfo::scriptlet(
     8	        "Quick Open",
     9	        "/path/to/urls.md#quick-open",
    10	        Some("cmd+o".into()),
    11	        Some("qo".into()),
    12	    );
    13	    let actions = get_scriptlet_context_actions_with_custom(&info, None);
    14	    let ids = action_ids(&actions);
    15	
    16	    // Should have update/remove (not add) for both shortcut and alias
    17	    assert!(ids.contains(&"update_shortcut"));
    18	    assert!(ids.contains(&"remove_shortcut"));
    19	    assert!(!ids.contains(&"add_shortcut"));
    20	
 succeeded in 50ms:
   260	    let action_ids_list = ["submit", "new_chat", "delete_chat"];
   261	    for id in &action_ids_list {
   262	        let a = find_action(&actions, id).unwrap();
   263	        assert_eq!(
   264	            a.section.as_deref(),
   265	            Some("Actions"),
   266	            "{} should be in Actions section",
   267	            id
   268	        );
   269	    }
   270	}
   271	
   272	#[test]
   273	fn ai_command_bar_actions_have_icons() {
   274	    let actions = get_ai_command_bar_actions();
   275	
   276	    for action in &actions {
   277	        assert!(
   278	            action.icon.is_some(),
   279	            "AI command bar action '{}' should have an icon",

thinking
**Inspecting script context usage**
exec
/bin/zsh -lc "nl -ba src/actions/builders_tests/part_04.rs | sed -n '130,280p'" in /Users/johnlindquist/dev/script-kit-gpui succeeded in 51ms:
   130	        display_name: "MO".into(),
   131	        provider: "p".into(),
   132	        provider_display_name: "P".into(),
   133	    }];
   134	
   135	    let actions = get_new_chat_actions(&last_used, &presets, &models);
   136	    for action in &actions {
   137	        assert!(
   138	            action.icon.is_some(),
   139	            "New chat action '{}' should have an icon",
   140	            action.id
   141	        );
   142	    }
   143	}
   144	
   145	// ============================================================
   146	// 13. Agent-specific script context actions
   147	// ============================================================
   148	
   149	#[test]

thinking
**Assessing error handling patterns**
exec
/bin/zsh -lc "rg -n \"target: \\\"script_kit::actions\\\"|return vec"'!'"\\[\\]|invalid .*action|empty action\" src -g '*.rs'" in /Users/johnlindquist/dev/script-kit-gpui succeeded in 51ms:
src/ai/window/theme_helpers.rs:14:            return vec![];
src/protocol/io/tests/parsing.rs:118:    // Known type "windowAction" with invalid enum value for "action"
src/protocol/io/tests/parsing.rs:129:                "error should mention invalid action field, got: {error}"
src/ai/config.rs:342:            return vec![];
src/ai/config.rs:374:            return vec![];
src/app_impl/prompt_ai.rs:114:            return vec![];
src/notes/actions_panel.rs:566:            return vec![]; // No shadows for vibrancy - matches POC behavior
src/scripts/loader.rs:38:            return vec![];
src/scripts/loader.rs:44:        return vec![];
src/actions/dialog_builtin_action_validation_tests_35/part_03.rs:400:// 27. Cross-context: all contexts produce non-empty actions
src/actions/dialog_builtin_action_validation_tests_45/part_02.rs:326:// =========== 18. Scriptlet defined: empty actions → empty result ===========
src/actions/dialog_builtin_action_validation_tests_46/part_03.rs:134:// =========== 25. New chat: empty inputs produce empty actions ===========
src/actions/dialog/part_02/part_02.rs:49:                target: "script_kit::actions",
src/actions/builders/clipboard.rs:28:        target: "script_kit::actions",
src/actions/builders/clipboard.rs:220:        target: "script_kit::actions",
src/actions/builders/script_context.rs:11:        target: "script_kit::actions",
src/actions/builders/script_context.rs:295:            target: "script_kit::actions",
src/actions/builders/script_context.rs:303:        target: "script_kit::actions",
src/actions/builders/file_path.rs:16:        target: "script_kit::actions",
src/actions/builders/scriptlet.rs:21:            target: "script_kit::actions",

thinking
**Inspecting tests for invalid input**
exec
/bin/zsh -lc "rg -n \"script_context|scriptlet|notes|note_switcher|get_.*actions.*empty|invalid\" src/actions/tests/dialog_builtin_validation src/actions/dialog_builtin_action_validation_tests_* -g '*.rs'" in /Users/johnlindquist/dev/script-kit-gpui succeeded in 51ms:
Total output lines: 7316

src/actions/dialog_builtin_action_validation_tests_9.rs:13://! 9. ScriptInfo mixed agent+scriptlet flag precedence
src/actions/dialog_builtin_action_validation_tests_9.rs:17://! 13. Note switcher empty notes placeholder action
src/actions/dialog_builtin_action_validation_tests_5.rs:9://! - Large-scale stress (many notes, models, presets)
src/actions/dialog_builtin_action_validation_tests_6.rs:5://! - ScriptInfo impossible flag combinations (is_script+is_scriptlet, is_script+is_agent)
src/actions/dialog_builtin_action_validation_tests_40.rs:16://! - Script context: scriptlet is_scriptlet true has edit_scriptlet
src/actions/dialog_builtin_action_validation_tests_40.rs:25://! - Notes: browse_notes always present
src/actions/dialog_builtin_action_validation_tests_40.rs:30://! - Note switcher: empty notes produces no_notes action
src/actions/dialog_builtin_action_validation_tests_39.rs:6://! - ScriptInfo::scriptlet constructor field validation
src/actions/dialog_builtin_action_validation_tests_7.rs:14://! 9. Script vs scriptlet action set symmetric difference
src/actions/dialog_builtin_action_validation_tests_7.rs:27://! 22. ScriptInfo scriptlet flag exclusivity with agent
src/actions/dialog_builtin_action_validation_tests_8.rs:20://! 15. CommandBarConfig notes_style detailed fields
src/actions/dialog_builtin_action_validation_tests_8.rs:30://! 25. Multiple scriptlet custom actions ordering
src/actions/dialog_builtin_action_validation_tests_7/tests_part_03.rs:35:    fn notes_command_bar_shortcuts_unique() {
src/actions/dialog_builtin_action_validation_tests_7/tests_part_03.rs:41:        let actions = get_notes_command_bar_actions(&info);
src/actions/dialog_builtin_action_validation_tests_46/part_01.rs:62:    let a = Action::new("test", "browse notes", None, ActionCategory::ScriptContext);
src/actions/dialog_builtin_action_validation_tests_46/part_01.rs:63:    assert_eq!(a.title_lower, "browse notes");
src/actions/dialog_builtin_action_validation_tests_9/tests_part_02.rs:29:    fn all_script_context_shortcuts_use_symbols() {
src/actions/dialog_builtin_action_validation_tests_9/tests_part_02.rs:31:        let actions = get_script_context_actions(&script);

thinking
**Targeting invalid input tests**
exec
/bin/zsh -lc "rg -n \"returns_empty|return[s]? empty|invalid input|malformed|warn|drops_action|no_notes|get_script_context_actions\\(&ScriptInfo::default\\)|ScriptInfo::default\\(\" src/actions/builders src/actions/builders_tests src/actions/tests/dialog_builtin_validation -g '*.rs'" in /Users/johnlindquist/dev/script-kit-gpui succeeded in 51ms:
src/actions/builders_tests/part_03.rs:110:fn note_switcher_empty_shows_no_notes_message() {
src/actions/builders_tests/part_03.rs:114:    assert_eq!(actions[0].id, "no_notes");
src/actions/builders/scriptlet.rs:20:        tracing::warn!(
src/actions/builders/scriptlet.rs:24:            "Failed to parse scriptlet H3 action id; dropping malformed action"
src/actions/builders/scriptlet.rs:329:    fn test_get_scriptlet_defined_actions_drops_action_when_command_is_empty() {
src/actions/builders/notes.rs:501:                "no_notes",
src/actions/builders/script_context.rs:294:        tracing::warn!(
src/actions/tests/dialog_builtin_validation/dialog_builtin_action_validation_tests_40.rs:30:// - Note switcher: empty notes produces no_notes action
src/actions/tests/dialog_builtin_validation/dialog_builtin_action_validation_tests_46/part_03.rs:243:fn note_switcher_empty_has_no_notes_message() {
src/actions/tests/dialog_builtin_validation/dialog_builtin_action_validation_tests_46/part_03.rs:246:    assert_eq!(actions[0].id, "no_notes");
src/actions/tests/dialog_builtin_validation/dialog_builtin_action_validation_tests_46/part_03.rs:250:fn note_switcher_no_notes_title() {
src/actions/tests/dialog_builtin_validation/dialog_builtin_action_validation_tests_46/part_03.rs:256:fn note_switcher_no_notes_icon() {
src/actions/tests/dialog_builtin_validation/dialog_builtin_action_validation_tests_46/part_03.rs:262:fn note_switcher_no_notes_desc_mentions_cmd_n() {
src/actions/tests/dialog_builtin_validation/dialog_builtin_action_validation_tests_22/part_01.rs:188:fn batch22_deeplink_all_special_chars_returns_empty() {
src/actions/tests/dialog_builtin_validation/dialog_builtin_action_validation_tests_22/part_02.rs:354:fn batch22_new_chat_empty_all_returns_empty() {
src/actions/tests/dialog_builtin_validation/dialog_builtin_action_validation_tests_32/part_03.rs:132:fn batch32_grouped_items_empty_returns_empty() {
src/actions/tests/dialog_builtin_validation/dialog_builtin_action_validation_tests_8/tests_part_02.rs:42:        assert_eq!(actions[0].id, "no_notes");
src/actions/tests/dialog_builtin_validation/dialog_builtin_action_validation_tests_35/part_02.rs:335:// 13. Note switcher: empty notes produces no_notes action
src/actions/tests/dialog_builtin_validation/dialog_builtin_action_validation_tests_35/part_02.rs:339:fn note_switcher_empty_has_no_notes() {
src/actions/tests/dialog_builtin_validation/dialog_builtin_action_validation_tests_35/part_02.rs:342:    assert_eq!(actions[0].id, "no_notes");

thinking
**Searching invalid input handling**
exec
/bin/zsh -lc 'rg -n "tracing::warn!'"\\([\\s\\S]{0,200}return vec"'!'"\\[\\]\" src/actions src/scripts src/notes -g '*.rs'" in /Users/johnlindquist/dev/script-kit-gpui exited 1 in 51ms:


thinking
**Inspecting invalid input handling**
exec
/bin/zsh -lc "nl -ba src/scripts/loader.rs | sed -n '1,120p'" in /Users/johnlindquist/dev/script-kit-gpui succeeded in 51ms:
     1	//! Script loading from file system
     2	//!
     3	//! This module provides functions for loading scripts from the
     4	//! ~/.scriptkit/*/scripts/ directories.
     5	
     6	use std::path::{Path, PathBuf};
     7	use std::sync::Arc;
     8	use tracing::{debug, instrument, warn};
     9	
    10	use glob::glob;
    11	
    12	use crate::setup::get_kit_path;
    13	
    14	use super::metadata::extract_metadata_full;
    15	use super::scriptlet_loader::extract_kit_from_path;
    16	use super::types::Script;
    17	
    18	/// Reads scripts from ~/.scriptkit/*/scripts/ directories
    19	/// Returns a sorted list of Arc-wrapped Script structs for .ts and .js files
    20	/// Returns empty vec if directory doesn't exist or is inaccessible

thinking
**Assessing input validation needs**
exec
/bin/zsh -lc "rg -n \"pub struct Scriptlet|impl Scriptlet|pub struct ScriptletAction\" src/scriptlets -g '*.rs' && nl -ba src/scriptlets/types.rs | sed -n '1,260p'" in /Users/johnlindquist/dev/script-kit-gpui succeeded in 50ms:
src/scriptlets/part_000.rs:150:pub struct ScriptletValidationError {
src/scriptlets/part_000.rs:161:impl ScriptletValidationError {
src/scriptlets/part_000.rs:193:pub struct ScriptletParseResult {
src/scriptlets/part_000.rs:203:pub struct ScriptletMetadata {
src/scriptlets/part_000.rs:245:pub struct ScriptletAction {
src/scriptlets/part_000.rs:261:impl ScriptletAction {
src/scriptlets/part_000.rs:270:pub struct Scriptlet {
src/scriptlets/part_000.rs:299:impl Scriptlet {
nl: src/scriptlets/types.rs: No such file or directory

thinking
**Planning scriptlet struct**
exec
/bin/zsh -lc "nl -ba src/scriptlets/part_000.rs | sed -n '230,390p'" in /Users/johnlindquist/dev/script-kit-gpui succeeded in 51ms:
   230	/// These actions appear in the Actions Menu when the scriptlet is focused.
   231	/// Example markdown:
   232	/// ```markdown
   233	/// ## My Scriptlet
   234	/// ```bash
   235	/// main code
   236	/// ```
   237	///
   238	/// ### Copy to Clipboard
   239	/// <!-- shortcut: cmd+c -->
   240	/// ```bash
   241	/// echo "{{selection}}" | pbcopy
   242	/// ```
   243	/// ```
   244	#[derive(Clone, Debug, Serialize, Deserialize, PartialEq)]
   245	pub struct ScriptletAction {
   246	    /// Name from H3 header (e.g., "Copy to Clipboard")
   247	    pub name: String,
   248	    /// Slugified command identifier
   249	    pub command: String,

thinking
**Reviewing string validation helpers**
exec
/bin/zsh -lc "nl -ba src/actions/builders/shared.rs | sed -n '1,220p'" in /Users/johnlindquist/dev/script-kit-gpui succeeded in 52ms:
     1	/// Convert a script name to a deeplink-safe format (lowercase, hyphenated)
     2	///
     3	/// Examples:
     4	/// - "My Script" -> "my-script"
     5	/// - "Clipboard History" -> "clipboard-history"
     6	/// - "hello_world" -> "hello-world"
     7	/// - "Café Script" -> "caf%C3%A9-script"
     8	pub fn to_deeplink_name(name: &str) -> String {
     9	    let normalized = name
    10	        .to_lowercase()
    11	        .chars()
    12	        .map(|c| if c.is_alphanumeric() { c } else { '-' })
    13	        .collect::<String>()
    14	        .split('-')
    15	        .filter(|s| !s.is_empty())
    16	        .collect::<Vec<_>>()
    17	        .join("-");
    18	
    19	    if normalized.is_empty() {
    20	        return "_unnamed".to_string();

thinking
**Planning consistent error handling**
exec
/bin/zsh -lc "rg -n \"get_notes_command_bar_actions|get_note_switcher_actions|get_new_chat_actions|get_script_context_actions|get_scriptlet_context_actions_with_custom|get_scriptlet_defined_actions\" src -g '*.rs'" in /Users/johnlindquist/dev/script-kit-gpui succeeded in 51ms:
Total output lines: 4245

src/app_actions/handle_action.rs:195:                        actions.extend(crate::actions::get_scriptlet_context_actions_with_custom(
src/app_actions/handle_action.rs:199:                        actions.extend(crate::actions::get_script_context_actions(script));
src/ai/window/command_bar.rs:98:            get_new_chat_actions, NewChatModelInfo, NewChatPresetInfo, WindowPosition,
src/ai/window/command_bar.rs:151:        let actions = get_new_chat_actions(&last_used, &presets, &models);
src/notes/window.rs:35:    get_note_switcher_actions, get_notes_command_bar_actions, CommandBar, CommandBarConfig,
src/notes/window/init.rs:97:        let note_switcher_actions = get_note_switcher_actions(
src/notes/window/init.rs:142:                get_notes_command_bar_actions(&NotesInfo {
src/notes/window/panels.rs:45:        let actions = get_notes_command_bar_actions(&NotesInfo {
src/notes/window/panels.rs:313:        let note_switcher_actions = get_note_switcher_actions(
src/actions/dialog_builtin_action_validation_tests_7/tests_part_03.rs:41:        let actions = get_notes_command_bar_actions(&info);
src/actions/dialog_builtin_action_validation_tests_8/tests_part_03.rs:9:        let actions = get_new_chat_actions(&last_used, &[], &[]);
src/actions/dialog_builtin_action_validation_tests_8/tests_part_03.rs:21:        let actions = get_new_chat_actions(&[], &[], &models);
src/actions/dialog_builtin_action_validation_tests_8/tests_part_03.rs:32:        let actions = get_script_context_actions(&script);
src/actions/dialog_builtin_action_validation_tests_8/tests_part_03.rs:44:        let actions = get_script_context_actions(&script);
src/actions/dialog_builtin_action_validation_tests_8/tests_part_03.rs:422:        let script_actions = get_script_context_actions(&script);
src/actions/dialog_builtin_action_validation_tests_8/tests_part_03.rs:423:        let builtin_actions = get_script_context_actions(&builtin);
src/actions/dialog_builtin_action_validation_tests_8/tests_part_03.rs:435:        let via_script = get_script_context_actions(&script);
src/actions/dialog_builtin_action_validation_tests_8/tests_part_03.rs:436:        let via_scriptlet = get_scriptlet_context_actions_with_custom(&script, None);

thinking
**Planning targeted invalid input search**
exec
/bin/zsh -lc "rg -n \"ScriptInfo::default\\(|name:\\s*\\\"\\\"|action_verb:\\s*\\\"\\\"|id:\\s*\\\"\\\"|title:\\s*\\\"\\\"|NewChatModelInfo\\s*\\{["'^}]*model_id:'"\\s*\\\"\\\"|NewChatPresetInfo\\s*\\{["'^}]*id:'"\\s*\\\"\\\"\" src/actions/builders_tests src/actions/tests/dialog_builtin_validation src/actions/dialog_builtin_action_validation_tests_* -g '*.rs'" in /Users/johnlindquist/dev/script-kit-gpui exited 1 in 51ms:


thinking
**Assessing error handling consistency**
exec
/bin/zsh -lc 'git status --short' in /Users/johnlindquist/dev/script-kit-gpui succeeded in 51ms:
 M .ai/logs/codex-audit-act-description-quality-v2.final.md
 M .ai/logs/codex-audit-act-execution-builtin.final.md
 M .ai/logs/codex-audit-act-execution-scripts.final.md
 M .ai/logs/codex-audit-act-keyboard-nav.final.md
 M .ai/logs/codex-audit-act-section-grouping.final.md
 M .ai/logs/codex-audit-act-theme-dialog-render.final.md
 M .ai/roster.json
 M src/actions/builders/chat.rs
 M src/actions/builders/clipboard.rs
 M src/actions/builders/file_path.rs
 M src/actions/builders/notes.rs
 M src/actions/builders/scriptlet.rs
 M src/actions/builders/shared.rs
 M src/actions/command_bar/part_01.rs
 M src/actions/command_bar/part_02.rs
 M src/actions/constants.rs
 M src/actions/dialog/part_01.rs
 M src/actions/dialog/part_02/part_01.rs
 M src/actions/dialog/part_02/part_03.rs
 M src/actions/dialog/part_04/body_part_02.rs

thinking
**Inspecting file diffs to avoid conflicts**
codex
I’m now checking the current diffs for your scoped files before touching code, because this tree is heavily dirty and I need to preserve any pre-existing in-flight changes exactly.
exec
/bin/zsh -lc "git diff -- src/actions/builders/notes.rs | sed -n '1,260p'" in /Users/johnlindquist/dev/script-kit-gpuiexec
/bin/zsh -lc "git diff -- src/actions/builders/script_context.rs | sed -n '1,260p'" in /Users/johnlindquist/dev/script-kit-gpui succeeded in 51ms:
diff --git a/src/actions/builders/notes.rs b/src/actions/builders/notes.rs
index 12a4478..48ba267 100644
--- a/src/actions/builders/notes.rs
+++ b/src/actions/builders/notes.rs
@@ -43,18 +43,43 @@ pub fn get_notes_command_bar_actions(info: &NotesInfo) -> Vec<Action> {
         .with_section("Notes"),
     );
 
-    if info.has_selection && !info.is_trash_view {
-        actions.push(
-            Action::new(
-                "duplicate_note",
-                "Duplicate Note",
-                Some("Create a copy of the current note".to_string()),
-                ActionCategory::ScriptContext,
-            )
-            .with_shortcut("⌘D")
-            .with_icon(IconName::Copy)
-            .with_section("Notes"),
-        );
 succeeded in 50ms:


thinking
**Noticing external script modifications**
exec
/bin/zsh -lc "git diff -- src/actions/builders/scriptlet.rs | sed -n '1,260p'" in /Users/johnlindquist/dev/script-kit-gpui succeeded in 51ms:
diff --git a/src/actions/builders/scriptlet.rs b/src/actions/builders/scriptlet.rs
index 1c7ba50..5e3b0b9 100644
--- a/src/actions/builders/scriptlet.rs
+++ b/src/actions/builders/scriptlet.rs
@@ -1,15 +1,65 @@
 use super::shared::{format_shortcut_hint, to_deeplink_name};
 use super::types::{Action, ActionCategory, ScriptInfo};
 use crate::scriptlets::Scriptlet;
+use std::collections::HashSet;
+
+const SCRIPTLET_ACTION_ID_PREFIX: &str = "scriptlet_action:";
+
+fn parse_scriptlet_action_command(action_id: &str) -> Option<&str> {
+    action_id
+        .strip_prefix(SCRIPTLET_ACTION_ID_PREFIX)
+        .filter(|command| !command.trim().is_empty())
+}
+
+fn unique_scriptlet_action_id(
+    raw_action_id: &str,

thinking
**Planning validation and logging consistency**
exec
/bin/zsh -lc "rg -n \"NoteSwitcherNoteInfo \\{|title:\\s*\\\"\\\"|id:\\s*\\\"\\\"\" src/actions -g '*.rs' | head -n 120" in /Users/johnlindquist/dev/script-kit-gpui succeeded in 51ms:
src/actions/dialog_builtin_action_validation_tests_32/part_02.rs:182:    let notes = vec![NoteSwitcherNoteInfo {
src/actions/dialog_builtin_action_validation_tests_32/part_02.rs:202:    let notes = vec![NoteSwitcherNoteInfo {
src/actions/dialog_builtin_action_validation_tests_32/part_02.rs:223:    let notes = vec![NoteSwitcherNoteInfo {
src/actions/dialog_builtin_action_validation_tests_32/part_02.rs:243:    let notes = vec![NoteSwitcherNoteInfo {
src/actions/dialog_builtin_action_validation_tests_32/part_02.rs:258:    let notes = vec![NoteSwitcherNoteInfo {
src/actions/dialog_builtin_action_validation_tests_32/part_02.rs:273:    let notes = vec![NoteSwitcherNoteInfo {
src/actions/dialog_builtin_action_validation_tests_35/part_02.rs:369:    let notes = vec![NoteSwitcherNoteInfo {
src/actions/dialog_builtin_action_validation_tests_35/part_02.rs:384:    let notes = vec![NoteSwitcherNoteInfo {
src/actions/dialog_builtin_action_validation_tests_35/part_02.rs:399:    let notes = vec![NoteSwitcherNoteInfo {
src/actions/dialog_builtin_action_validation_tests_35/part_02.rs:414:    let notes = vec![NoteSwitcherNoteInfo {
src/actions/dialog_builtin_action_validation_tests_15/tests_part_03.rs:254:        let notes = vec![NoteSwitcherNoteInfo {
src/actions/dialog_builtin_action_validation_tests_15/tests_part_03.rs:269:        let notes = vec![NoteSwitcherNoteInfo {
src/actions/dialog_builtin_action_validation_tests_15/tests_part_03.rs:284:        let notes = vec![NoteSwitcherNoteInfo {
src/actions/dialog_builtin_action_validation_tests_15/tests_part_03.rs:299:        let notes = vec![NoteSwitcherNoteInfo {
src/actions/dialog_builtin_action_validation_tests_15/tests_part_03.rs:318:        let notes = vec![NoteSwitcherNoteInfo {
src/actions/dialog_builtin_action_validation_tests_15/tests_part_03.rs:333:        let notes = vec![NoteSwitcherNoteInfo {
src/actions/dialog_builtin_action_validation_tests_15/tests_part_03.rs:349:            NoteSwitcherNoteInfo {
src/actions/dialog_builtin_action_validation_tests_15/tests_part_03.rs:358:            NoteSwitcherNoteInfo {
src/actions/dialog_builtin_action_validation_tests_15/tests_part_03.rs:386:        let notes = vec![NoteSwitcherNoteInfo {
src/actions/dialog_builtin_action_validation_tests_15/tests_part_03.rs:405:        let notes = vec![NoteSwitcherNoteInfo {

thinking
**Planning targeted empty field detection**
exec
/bin/zsh -lc "rg -n \"id:\\s*\\\"\\\"|title:\\s*\\\"\\\"|provider:\\s*\\\"\\\"|model_id:\\s*\\\"\\\"|name:\\s*\\\"\\\"\" src/actions -g '*.rs'" in /Users/johnlindquist/dev/script-kit-gpui exited 1 in 50ms:


thinking
**Assessing scriptlet test coverage**
exec
/bin/zsh -lc "rg -n \"get_scriptlet_context_actions_with_custom\\(\" src/actions -g '*.rs' | head -n 200" in /Users/johnlindquist/dev/script-kit-gpui succeeded in 51ms:
src/actions/dialog_builtin_action_validation_tests_32/part_01.rs:91:    let actions = get_scriptlet_context_actions_with_custom(&script, None);
src/actions/dialog_builtin_action_validation_tests_32/part_01.rs:105:    let actions = get_scriptlet_context_actions_with_custom(&script, None);
src/actions/dialog_builtin_action_validation_tests_32/part_01.rs:112:    let actions = get_scriptlet_context_actions_with_custom(&script, None);
src/actions/dialog_builtin_action_validation_tests_32/part_01.rs:119:    let actions = get_scriptlet_context_actions_with_custom(&script, None);
src/actions/dialog_builtin_action_validation_tests_35/part_01.rs:351:    let actions = get_scriptlet_context_actions_with_custom(&script, Some(&s));
src/actions/dialog_builtin_action_validation_tests_35/part_01.rs:368:    let actions = get_scriptlet_context_actions_with_custom(&script, Some(&s));
src/actions/dialog_builtin_action_validation_tests_35/part_01.rs:389:    let actions = get_scriptlet_context_actions_with_custom(&script, Some(&s));
src/actions/dialog_builtin_action_validation_tests_35/part_01.rs:400:    let actions = get_scriptlet_context_actions_with_custom(&script, None);
src/actions/dialog_builtin_action_validation_tests_35/part_01.rs:427:    let actions = get_scriptlet_context_actions_with_custom(&script, Some(&s));
src/actions/dialog_builtin_action_validation_tests_35/part_02.rs:15:    let actions = get_scriptlet_context_actions_with_custom(&script, Some(&s));
src/actions/dialog_builtin_action_validation_tests_35/part_02.rs:36:    let actions = get_scriptlet_context_actions_with_custom(&script, Some(&s));
src/actions/dialog_builtin_action_validation_tests_35/part_02.rs:57:    let actions = get_scriptlet_context_actions_with_custom(&script, Some(&s));
src/actions/dialog_window_tests/part_03.rs:155:    let actions = get_scriptlet_context_actions_with_custom(&script, Some(&scriptlet));
src/actions/dialog_window_tests/part_03.rs:333:    let actions = get_scriptlet_context_actions_with_custom(&script, None);
src/actions/dialog_builtin_action_validation_tests_2/part_04.rs:196:    let actions = get_scriptlet_context_actions_with_custom(&script, Some(&scriptlet));
src/actions/dialog_builtin_action_validation_tests_2/part_04.rs:222:    let actions = get_scriptlet_context_actions_with_custom(&script, Some(&scriptlet));
src/actions/dialog_builtin_action_validation_tests_2/part_05.rs:37:    let actions_tmp = get_scriptlet_context_actions_with_custom(&script, None);
src/actions/dialog_builtin_action_validation_tests_2/part_05.rs:47:    let actions_tmp = get_scriptlet_context_actions_with_custom(&script, None);
src/actions/dialog_builtin_action_validation_tests_34/part_02.rs:248:    let actions = get_scriptlet_context_actions_with_custom(&script, None);
src/actions/dialog_builtin_action_validation_tests_34/part_02.rs:261:    let actions = get_scriptlet_context_actions_with_custom(&script, None);

thinking
**Evaluating scriptlet context checks**
exec
/bin/zsh -lc "rg -n \"get_scriptlet_context_actions_with_custom\\(&ScriptInfo::new|get_scriptlet_context_actions_with_custom\\(&ScriptInfo::builtin|get_scriptlet_context_actions_with_custom\\(&ScriptInfo::default\" src/actions -g '*.rs'" in /Users/johnlindquist/dev/script-kit-gpui exited 1 in 50ms:


thinking
**Designing consistent input validation and logging**
codex
I’m about to edit `notes.rs` to add explicit input validation branches that warn and return `Vec::new()` for malformed new-chat and note-switcher inputs, plus focused tests for each new branch.

thinking
**Analyzing patch mismatch causes**
exec
/bin/zsh -lc "nl -ba src/actions/builders/notes.rs | sed -n '1,260p' && nl -ba src/actions/builders/notes.rs | sed -n '260,560p'" in /Users/johnlindquist/dev/script-kit-gpui succeeded in 51ms:
     1	use super::types::{Action, ActionCategory};
     2	use crate::designs::icon_variations::IconName;
     3	
     4	/// Information about a model for the new chat dropdown
     5	#[derive(Debug, Clone)]
     6	#[allow(dead_code)]
     7	pub struct NewChatModelInfo {
     8	    pub model_id: String,
     9	    pub display_name: String,
    10	    pub provider: String,
    11	    pub provider_display_name: String,
    12	}
    13	
    14	/// Information about a preset for the new chat dropdown
    15	#[derive(Debug, Clone)]
    16	pub struct NewChatPresetInfo {
    17	    pub id: String,
    18	    pub name: String,
    19	    pub icon: IconName,
    20	}

thinking
**Planning incremental patching**
file update
M /Users/johnlindquist/dev/script-kit-gpui/src/actions/builders/notes.rs
@@ -29,2 +29,21 @@
 
+fn is_blank(value: &str) -> bool {
+    value.trim().is_empty()
+}
+
+fn has_invalid_new_chat_model_info(model: &NewChatModelInfo) -> bool {
+    is_blank(&model.model_id)
+        || is_blank(&model.display_name)
+        || is_blank(&model.provider)
+        || is_blank(&model.provider_display_name)
+}
+
+fn has_invalid_new_chat_preset_info(preset: &NewChatPresetInfo) -> bool {
+    is_blank(&preset.id) || is_blank(&preset.name)
+}
+
+fn has_invalid_note_switcher_note_info(note: &NoteSwitcherNoteInfo) -> bool {
+    is_blank(&note.id) || is_blank(&note.title)
+}
+
 /// Get actions for the Notes window command bar (Cmd+K menu).
apply_patch(auto_approved=true) exited 0 in 13ms:
Success. Updated the following files:
M src/actions/builders/notes.rs
file update:
diff --git a/src/actions/builders/notes.rs b/src/actions/builders/notes.rs
index 48ba267e97bf2f3da7ecf1a3f78fea59dbc9acab..6e726899f2fd2260a72cc86e015581f106a20d7f
--- a/src/actions/builders/notes.rs
+++ b/src/actions/builders/notes.rs
@@ -27,6 +27,25 @@
     pub auto_sizing_enabled: bool,
 }
 
+fn is_blank(value: &str) -> bool {
+    value.trim().is_empty()
+}
+
+fn has_invalid_new_chat_model_info(model: &NewChatModelInfo) -> bool {
+    is_blank(&model.model_id)
+        || is_blank(&model.display_name)
+        || is_blank(&model.provider)
+        || is_blank(&model.provider_display_name)
+}
+
+fn has_invalid_new_chat_preset_info(preset: &NewChatPresetInfo) -> bool {
+    is_blank(&preset.id) || is_blank(&preset.name)
+}
+
+fn has_invalid_note_switcher_note_info(note: &NoteSwitcherNoteInfo) -> bool {
+    is_blank(&note.id) || is_blank(&note.title)
+}
+
 /// Get actions for the Notes window command bar (Cmd+K menu).
 pub fn get_notes_command_bar_actions(info: &NotesInfo) -> Vec<Action> {
     let mut actions = Vec::new();

file update:
diff --git a/src/actions/builders/notes.rs b/src/actions/builders/notes.rs
index 48ba267e97bf2f3da7ecf1a3f78fea59dbc9acab..6e726899f2fd2260a72cc86e015581f106a20d7f
--- a/src/actions/builders/notes.rs
+++ b/src/actions/builders/notes.rs
@@ -27,6 +27,25 @@
     pub auto_sizing_enabled: bool,
 }
 
+fn is_blank(value: &str) -> bool {
+    value.trim().is_empty()
+}
+
+fn has_invalid_new_chat_model_info(model: &NewChatModelInfo) -> bool {
+    is_blank(&model.model_id)
+        || is_blank(&model.display_name)
+        || is_blank(&model.provider)
+        || is_blank(&model.provider_display_name)
+}
+
+fn has_invalid_new_chat_preset_info(preset: &NewChatPresetInfo) -> bool {
+    is_blank(&preset.id) || is_blank(&preset.name)
+}
+
+fn has_invalid_note_switcher_note_info(note: &NoteSwitcherNoteInfo) -> bool {
+    is_blank(&note.id) || is_blank(&note.title)
+}
+
 /// Get actions for the Notes window command bar (Cmd+K menu).
 pub fn get_notes_command_bar_actions(info: &NotesInfo) -> Vec<Action> {
     let mut actions = Vec::new();


thinking
**Preparing to extend chat actions**
codex
I’ve inserted shared validation helpers in `notes.rs`; next I’m wiring early-return warn branches into `get_new_chat_actions` and `get_note_switcher_actions`, then I’ll add tests for those paths.
file update
M /Users/johnlindquist/dev/script-kit-gpui/src/actions/builders/notes.rs
@@ -397,2 +397,44 @@
 ) -> Vec<Action> {
+    let invalid_last_used_count = last_used
+        .iter()
+        .filter(|model| has_invalid_new_chat_model_info(model))
+        .count();
+    if invalid_last_used_count > 0 {
+        tracing::warn!(
+            target: "script_kit::actions",
+            builder = "notes_new_chat",
+            invalid_last_used_count,
+            "Invalid last-used chat model input; returning empty actions"
+        );
+        return vec![];
+    }
+
+    let invalid_preset_count = presets
+        .iter()
+        .filter(|preset| has_invalid_new_chat_preset_info(preset))
+        .count();
+    if invalid_preset_count > 0 {
+        tracing::warn!(
+            target: "script_kit::actions",
+            builder = "notes_new_chat",
+            invalid_preset_count,
+            "Invalid chat preset input; returning empty actions"
+        );
+        return vec![];
+    }
+
+    let invalid_model_count = models
+        .iter()
+        .filter(|model| has_invalid_new_chat_model_info(model))
+        .count();
+    if invalid_model_count > 0 {
+        tracing::warn!(
+            target: "script_kit::actions",
+            builder = "notes_new_chat",
+            invalid_model_count,
+            "Invalid chat model input; returning empty actions"
+        );
+        return vec![];
+    }
+
     let mut actions = Vec::new();
apply_patch(auto_approved=true) exited 0 in 16ms:
Success. Updated the following files:
M src/actions/builders/notes.rs
file update:
diff --git a/src/actions/builders/notes.rs b/src/actions/builders/notes.rs
index 48ba267e97bf2f3da7ecf1a3f78fea59dbc9acab..41045914899e03b31f6d5c15534e8dc3a589d18b
--- a/src/actions/builders/notes.rs
+++ b/src/actions/builders/notes.rs
@@ -27,6 +27,25 @@
     pub auto_sizing_enabled: bool,
 }
 
+fn is_blank(value: &str) -> bool {
+    value.trim().is_empty()
+}
+
+fn has_invalid_new_chat_model_info(model: &NewChatModelInfo) -> bool {
+    is_blank(&model.model_id)
+        || is_blank(&model.display_name)
+        || is_blank(&model.provider)
+        || is_blank(&model.provider_display_name)
+}
+
+fn has_invalid_new_chat_preset_info(preset: &NewChatPresetInfo) -> bool {
+    is_blank(&preset.id) || is_blank(&preset.name)
+}
+
+fn has_invalid_note_switcher_note_info(note: &NoteSwitcherNoteInfo) -> bool {
+    is_blank(&note.id) || is_blank(&note.title)
+}
+
 /// Get actions for the Notes window command bar (Cmd+K menu).
 pub fn get_notes_command_bar_actions(info: &NotesInfo) -> Vec<Action> {
     let mut actions = Vec::new();
@@ -376,6 +395,48 @@
     presets: &[NewChatPresetInfo],
     models: &[NewChatModelInfo],
 ) -> Vec<Action> {
+    let invalid_last_used_count = last_used
+        .iter()
+        .filter(|model| has_invalid_new_chat_model_info(model))
+        .count();
+    if invalid_last_used_count > 0 {
+        tracing::warn!(
+            target: "script_kit::actions",
+            builder = "notes_new_chat",
+            invalid_last_used_count,
+            "Invalid last-used chat model input; returning empty actions"
+        );
+        return vec![];
+    }
+
+    let invalid_preset_count = presets
+        .iter()
+        .filter(|preset| has_invalid_new_chat_preset_info(preset))
+        .count();
+    if invalid_preset_count > 0 {
+        tracing::warn!(
+            target: "script_kit::actions",
+            builder = "notes_new_chat",
+            invalid_preset_count,
+            "Invalid chat preset input; returning empty actions"
+        );
+        return vec![];
+    }
+
+    let invalid_model_count = models
+        .iter()
+        .filter(|model| has_invalid_new_chat_model_info(model))
+        .count();
+    if invalid_model_count > 0 {
+        tracing::warn!(
+            target: "script_kit::actions",
+            builder = "notes_new_chat",
+            invalid_model_count,
+            "Invalid chat model input; returning empty actions"
+        );
+        return vec![];
+    }
+
     let mut actions = Vec::new();
 
     for setting in last_used {

file update:
diff --git a/src/actions/builders/notes.rs b/src/actions/builders/notes.rs
index 48ba267e97bf2f3da7ecf1a3f78fea59dbc9acab..41045914899e03b31f6d5c15534e8dc3a589d18b
--- a/src/actions/builders/notes.rs
+++ b/src/actions/builders/notes.rs
@@ -27,6 +27,25 @@
     pub auto_sizing_enabled: bool,
 }
 
+fn is_blank(value: &str) -> bool {
+    value.trim().is_empty()
+}
+
+fn has_invalid_new_chat_model_info(model: &NewChatModelInfo) -> bool {
+    is_blank(&model.model_id)
+        || is_blank(&model.display_name)
+        || is_blank(&model.provider)
+        || is_blank(&model.provider_display_name)
+}
+
+fn has_invalid_new_chat_preset_info(preset: &NewChatPresetInfo) -> bool {
+    is_blank(&preset.id) || is_blank(&preset.name)
+}
+
+fn has_invalid_note_switcher_note_info(note: &NoteSwitcherNoteInfo) -> bool {
+    is_blank(&note.id) || is_blank(&note.title)
+}
+
 /// Get actions for the Notes window command bar (Cmd+K menu).
 pub fn get_notes_command_bar_actions(info: &NotesInfo) -> Vec<Action> {
     let mut actions = Vec::new();
@@ -376,6 +395,48 @@
     presets: &[NewChatPresetInfo],
     models: &[NewChatModelInfo],
 ) -> Vec<Action> {
+    let invalid_last_used_count = last_used
+        .iter()
+        .filter(|model| has_invalid_new_chat_model_info(model))
+        .count();
+    if invalid_last_used_count > 0 {
+        tracing::warn!(
+            target: "script_kit::actions",
+            builder = "notes_new_chat",
+            invalid_last_used_count,
+            "Invalid last-used chat model input; returning empty actions"
+        );
+        return vec![];
+    }
+
+    let invalid_preset_count = presets
+        .iter()
+        .filter(|preset| has_invalid_new_chat_preset_info(preset))
+        .count();
+    if invalid_preset_count > 0 {
+        tracing::warn!(
+            target: "script_kit::actions",
+            builder = "notes_new_chat",
+            invalid_preset_count,
+            "Invalid chat preset input; returning empty actions"
+        );
+        return vec![];
+    }
+
+    let invalid_model_count = models
+        .iter()
+        .filter(|model| has_invalid_new_chat_model_info(model))
+        .count();
+    if invalid_model_count > 0 {
+        tracing::warn!(
+            target: "script_kit::actions",
+            builder = "notes_new_chat",
+            invalid_model_count,
+            "Invalid chat model input; returning empty actions"
+        );
+        return vec![];
+    }
+
     let mut actions = Vec::new();
 
     for setting in last_used {


thinking
**Starting patch note switcher**
file update
M /Users/johnlindquist/dev/script-kit-gpui/src/actions/builders/notes.rs
@@ -505,2 +505,17 @@
 pub fn get_note_switcher_actions(notes: &[NoteSwitcherNoteInfo]) -> Vec<Action> {
+    let invalid_note_count = notes
+        .iter()
+        .filter(|note| has_invalid_note_switcher_note_info(note))
+        .count();
+    if invalid_note_count > 0 {
+        tracing::warn!(
+            target: "script_kit::actions",
+            builder = "note_switcher",
+            note_count = notes.len(),
+            invalid_note_count,
+            "Invalid note switcher input; returning empty actions"
+        );
+        return vec![];
+    }
+
     let mut actions = Vec::new();
apply_patch(auto_approved=true) exited 0 in 13ms:
Success. Updated the following files:
M src/actions/builders/notes.rs
file update:
diff --git a/src/actions/builders/notes.rs b/src/actions/builders/notes.rs
index 48ba267e97bf2f3da7ecf1a3f78fea59dbc9acab..8e88ec3bcf4879329d27465dfa6cfab12678c98c
--- a/src/actions/builders/notes.rs
+++ b/src/actions/builders/notes.rs
@@ -27,6 +27,25 @@
     pub auto_sizing_enabled: bool,
 }
 
+fn is_blank(value: &str) -> bool {
+    value.trim().is_empty()
+}
+
+fn has_invalid_new_chat_model_info(model: &NewChatModelInfo) -> bool {
+    is_blank(&model.model_id)
+        || is_blank(&model.display_name)
+        || is_blank(&model.provider)
+        || is_blank(&model.provider_display_name)
+}
+
+fn has_invalid_new_chat_preset_info(preset: &NewChatPresetInfo) -> bool {
+    is_blank(&preset.id) || is_blank(&preset.name)
+}
+
+fn has_invalid_note_switcher_note_info(note: &NoteSwitcherNoteInfo) -> bool {
+    is_blank(&note.id) || is_blank(&note.title)
+}
+
 /// Get actions for the Notes window command bar (Cmd+K menu).
 pub fn get_notes_command_bar_actions(info: &NotesInfo) -> Vec<Action> {
     let mut actions = Vec::new();
@@ -376,6 +395,48 @@
     presets: &[NewChatPresetInfo],
     models: &[NewChatModelInfo],
 ) -> Vec<Action> {
+    let invalid_last_used_count = last_used
+        .iter()
+        .filter(|model| has_invalid_new_chat_model_info(model))
+        .count();
+    if invalid_last_used_count > 0 {
+        tracing::warn!(
+            target: "script_kit::actions",
+            builder = "notes_new_chat",
+            invalid_last_used_count,
+            "Invalid last-used chat model input; returning empty actions"
+        );
+        return vec![];
+    }
+
+    let invalid_preset_count = presets
+        .iter()
+        .filter(|preset| has_invalid_new_chat_preset_info(preset))
+        .count();
+    if invalid_preset_count > 0 {
+        tracing::warn!(
+            target: "script_kit::actions",
+            builder = "notes_new_chat",
+            invalid_preset_count,
+            "Invalid chat preset input; returning empty actions"
+        );
+        return vec![];
+    }
+
+    let invalid_model_count = models
+        .iter()
+        .filter(|model| has_invalid_new_chat_model_info(model))
+        .count();
+    if invalid_model_count > 0 {
+        tracing::warn!(
+            target: "script_kit::actions",
+            builder = "notes_new_chat",
+            invalid_model_count,
+            "Invalid chat model input; returning empty actions"
+        );
+        return vec![];
+    }
+
     let mut actions = Vec::new();
 
     for setting in last_used {
@@ -442,6 +503,21 @@
 
 /// Get actions for the note switcher dialog (Cmd+P in Notes window).
 pub fn get_note_switcher_actions(notes: &[NoteSwitcherNoteInfo]) -> Vec<Action> {
+    let invalid_note_count = notes
+        .iter()
+        .filter(|note| has_invalid_note_switcher_note_info(note))
+        .count();
+    if invalid_note_count > 0 {
+        tracing::warn!(
+            target: "script_kit::actions",
+            builder = "note_switcher",
+            note_count = notes.len(),
+            invalid_note_count,
+            "Invalid note switcher input; returning empty actions"
+        );
+        return vec![];
+    }
+
     let mut actions = Vec::new();
 
     for note in notes {

file update:
diff --git a/src/actions/builders/notes.rs b/src/actions/builders/notes.rs
index 48ba267e97bf2f3da7ecf1a3f78fea59dbc9acab..8e88ec3bcf4879329d27465dfa6cfab12678c98c
--- a/src/actions/builders/notes.rs
+++ b/src/actions/builders/notes.rs
@@ -27,6 +27,25 @@
     pub auto_sizing_enabled: bool,
 }
 
+fn is_blank(value: &str) -> bool {
+    value.trim().is_empty()
+}
+
+fn has_invalid_new_chat_model_info(model: &NewChatModelInfo) -> bool {
+    is_blank(&model.model_id)
+        || is_blank(&model.display_name)
+        || is_blank(&model.provider)
+        || is_blank(&model.provider_display_name)
+}
+
+fn has_invalid_new_chat_preset_info(preset: &NewChatPresetInfo) -> bool {
+    is_blank(&preset.id) || is_blank(&preset.name)
+}
+
+fn has_invalid_note_switcher_note_info(note: &NoteSwitcherNoteInfo) -> bool {
+    is_blank(&note.id) || is_blank(&note.title)
+}
+
 /// Get actions for the Notes window command bar (Cmd+K menu).
 pub fn get_notes_command_bar_actions(info: &NotesInfo) -> Vec<Action> {
     let mut actions = Vec::new();
@@ -376,6 +395,48 @@
     presets: &[NewChatPresetInfo],
     models: &[NewChatModelInfo],
 ) -> Vec<Action> {
+    let invalid_last_used_count = last_used
+        .iter()
+        .filter(|model| has_invalid_new_chat_model_info(model))
+        .count();
+    if invalid_last_used_count > 0 {
+        tracing::warn!(
+            target: "script_kit::actions",
+            builder = "notes_new_chat",
+            invalid_last_used_count,
+            "Invalid last-used chat model input; returning empty actions"
+        );
+        return vec![];
+    }
+
+    let invalid_preset_count = presets
+        .iter()
+        .filter(|preset| has_invalid_new_chat_preset_info(preset))
+        .count();
+    if invalid_preset_count > 0 {
+        tracing::warn!(
+            target: "script_kit::actions",
+            builder = "notes_new_chat",
+            invalid_preset_count,
+            "Invalid chat preset input; returning empty actions"
+        );
+        return vec![];
+    }
+
+    let invalid_model_count = models
+        .iter()
+        .filter(|model| has_invalid_new_chat_model_info(model))
+        .count();
+    if invalid_model_count > 0 {
+        tracing::warn!(
+            target: "script_kit::actions",
+            builder = "notes_new_chat",
+            invalid_model_count,
+            "Invalid chat model input; returning empty actions"
+        );
+        return vec![];
+    }
+
     let mut actions = Vec::new();
 
     for setting in last_used {
@@ -442,6 +503,21 @@
 
 /// Get actions for the note switcher dialog (Cmd+P in Notes window).
 pub fn get_note_switcher_actions(notes: &[NoteSwitcherNoteInfo]) -> Vec<Action> {
+    let invalid_note_count = notes
+        .iter()
+        .filter(|note| has_invalid_note_switcher_note_info(note))
+        .count();
+    if invalid_note_count > 0 {
+        tracing::warn!(
+            target: "script_kit::actions",
+            builder = "note_switcher",
+            note_count = notes.len(),
+            invalid_note_count,
+            "Invalid note switcher input; returning empty actions"
+        );
+        return vec![];
+    }
+
     let mut actions = Vec::new();
 
     for note in notes {


thinking
**Adding tests near existing ones**
file update
M /Users/johnlindquist/dev/script-kit-gpui/src/actions/builders/notes.rs
@@ -388,2 +388,72 @@
     }
+
+    #[test]
+    fn test_get_new_chat_actions_returns_empty_when_last_used_model_input_is_invalid() {
+        let last_used = vec![NewChatModelInfo {
+            model_id: "   ".to_string(),
+            display_name: "GPT-4o Mini".to_string(),
+            provider: "openai".to_string(),
+            provider_display_name: "OpenAI".to_string(),
+        }];
+        let presets = vec![NewChatPresetInfo {
+            id: "focused-writing".to_string(),
+            name: "Focused Writing".to_string(),
+            icon: IconName::Pencil,
+        }];
+
+        let actions = get_new_chat_actions(&last_used, &presets, &[]);
+        assert!(actions.is_empty());
+    }
+
+    #[test]
+    fn test_get_new_chat_actions_returns_empty_when_preset_input_is_invalid() {
+        let last_used = vec![NewChatModelInfo {
+            model_id: "gpt-4o-mini".to_string(),
+            display_name: "GPT-4o Mini".to_string(),
+            provider: "openai".to_string(),
+            provider_display_name: "OpenAI".to_string(),
+        }];
+        let presets = vec![NewChatPresetInfo {
+            id: "   ".to_string(),
+            name: "Focused Writing".to_string(),
+            icon: IconName::Pencil,
+        }];
+
+        let actions = get_new_chat_actions(&last_used, &presets, &[]);
+        assert!(actions.is_empty());
+    }
+
+    #[test]
+    fn test_get_new_chat_actions_returns_empty_when_model_input_is_invalid() {
+        let presets = vec![NewChatPresetInfo {
+            id: "focused-writing".to_string(),
+            name: "Focused Writing".to_string(),
+            icon: IconName::Pencil,
+        }];
+        let models = vec![NewChatModelInfo {
+            model_id: "claude-3-5-sonnet".to_string(),
+            display_name: "Claude 3.5 Sonnet".to_string(),
+            provider: "   ".to_string(),
+            provider_display_name: "Anthropic".to_string(),
+        }];
+
+        let actions = get_new_chat_actions(&[], &presets, &models);
+        assert!(actions.is_empty());
+    }
+
+    #[test]
+    fn test_get_note_switcher_actions_returns_empty_when_note_input_is_invalid() {
+        let notes = vec![NoteSwitcherNoteInfo {
+            id: "   ".to_string(),
+            title: "Missing ID".to_string(),
+            char_count: 5,
+            is_current: false,
+            is_pinned: false,
+            preview: "Preview".to_string(),
+            relative_time: "1m ago".to_string(),
+        }];
+
+        let actions = get_note_switcher_actions(&notes);
+        assert!(actions.is_empty());
+    }
 }
apply_patch(auto_approved=true) exited 0 in 13ms:
Success. Updated the following files:
M src/actions/builders/notes.rs
file update:
diff --git a/src/actions/builders/notes.rs b/src/actions/builders/notes.rs
index 48ba267e97bf2f3da7ecf1a3f78fea59dbc9acab..a2f0007d3327b005960130e6e30f524ceb6b3e9f
--- a/src/actions/builders/notes.rs
+++ b/src/actions/builders/notes.rs
@@ -27,6 +27,25 @@
     pub auto_sizing_enabled: bool,
 }
 
+fn is_blank(value: &str) -> bool {
+    value.trim().is_empty()
+}
+
+fn has_invalid_new_chat_model_info(model: &NewChatModelInfo) -> bool {
+    is_blank(&model.model_id)
+        || is_blank(&model.display_name)
+        || is_blank(&model.provider)
+        || is_blank(&model.provider_display_name)
+}
+
+fn has_invalid_new_chat_preset_info(preset: &NewChatPresetInfo) -> bool {
+    is_blank(&preset.id) || is_blank(&preset.name)
+}
+
+fn has_invalid_note_switcher_note_info(note: &NoteSwitcherNoteInfo) -> bool {
+    is_blank(&note.id) || is_blank(&note.title)
+}
+
 /// Get actions for the Notes window command bar (Cmd+K menu).
 pub fn get_notes_command_bar_actions(info: &NotesInfo) -> Vec<Action> {
     let mut actions = Vec::new();
@@ -367,6 +386,76 @@
             Some("Use Focused Writing preset")
         );
     }
+
+    #[test]
+    fn test_get_new_chat_actions_returns_empty_when_last_used_model_input_is_invalid() {
+        let last_used = vec![NewChatModelInfo {
+            model_id: "   ".to_string(),
+            display_name: "GPT-4o Mini".to_string(),
+            provider: "openai".to_string(),
+            provider_display_name: "OpenAI".to_string(),
+        }];
+        let presets = vec![NewChatPresetInfo {
+            id: "focused-writing".to_string(),
+            name: "Focused Writing".to_string(),
+            icon: IconName::Pencil,
+        }];
+
+        let actions = get_new_chat_actions(&last_used, &presets, &[]);
+        assert!(actions.is_empty());
+    }
+
+    #[test]
+    fn test_get_new_chat_actions_returns_empty_when_preset_input_is_invalid() {
+        let last_used = vec![NewChatModelInfo {
+            model_id: "gpt-4o-mini".to_string(),
+            display_name: "GPT-4o Mini".to_string(),
+            provider: "openai".to_string(),
+            provider_display_name: "OpenAI".to_string(),
+        }];
+        let presets = vec![NewChatPresetInfo {
+            id: "   ".to_string(),
+            name: "Focused Writing".to_string(),
+            icon: IconName::Pencil,
+        }];
+
+        let actions = get_new_chat_actions(&last_used, &presets, &[]);
+        assert!(actions.is_empty());
+    }
+
+    #[test]
+    fn test_get_new_chat_actions_returns_empty_when_model_input_is_invalid() {
+        let presets = vec![NewChatPresetInfo {
+            id: "focused-writing".to_string(),
+            name: "Focused Writing".to_string(),
+            icon: IconName::Pencil,
+        }];
+        let models = vec![NewChatModelInfo {
+            model_id: "claude-3-5-sonnet".to_string(),
+            display_name: "Claude 3.5 Sonnet".to_string(),
+            provider: "   ".to_string(),
+            provider_display_name: "Anthropic".to_string(),
+        }];
+
+        let actions = get_new_chat_actions(&[], &presets, &models);
+        assert!(actions.is_empty());
+    }
+
+    #[test]
+    fn test_get_note_switcher_actions_returns_empty_when_note_input_is_invalid() {
+        let notes = vec![NoteSwitcherNoteInfo {
+            id: "   ".to_string(),
+            title: "Missing ID".to_string(),
+            char_count: 5,
+            is_current: false,
+            is_pinned: false,
+            preview: "Preview".to_string(),
+            relative_time: "1m ago".to_string(),
+        }];
+
+        let actions = get_note_switcher_actions(&notes);
+        assert!(actions.is_empty());
+    }
 }
 
 /// Build actions for the AI new chat dropdown.
@@ -376,6 +465,48 @@
     presets: &[NewChatPresetInfo],
     models: &[NewChatModelInfo],
 ) -> Vec<Action> {
+    let invalid_last_used_count = last_used
+        .iter()
+        .filter(|model| has_invalid_new_chat_model_info(model))
+        .count();
+    if invalid_last_used_count > 0 {
+        tracing::warn!(
+            target: "script_kit::actions",
+            builder = "notes_new_chat",
+            invalid_last_used_count,
+            "Invalid last-used chat model input; returning empty actions"
+        );
+        return vec![];
+    }
+
+    let invalid_preset_count = presets
+        .iter()
+        .filter(|preset| has_invalid_new_chat_preset_info(preset))
+        .count();
+    if invalid_preset_count > 0 {
+        tracing::warn!(
+            target: "script_kit::actions",
+            builder = "notes_new_chat",
+            invalid_preset_count,
+            "Invalid chat preset input; returning empty actions"
+        );
+        return vec![];
+    }
+
+    let invalid_model_count = models
+        .iter()
+        .filter(|model| has_invalid_new_chat_model_info(model))
+        .count();
+    if invalid_model_count > 0 {
+        tracing::warn!(
+            target: "script_kit::actions",
+            builder = "notes_new_chat",
+            invalid_model_count,
+            "Invalid chat model input; returning empty actions"
+        );
+        return vec![];
+    }
+
     let mut actions = Vec::new();
 
     for setting in last_used {
@@ -442,6 +573,21 @@
 
 /// Get actions for the note switcher dialog (Cmd+P in Notes window).
 pub fn get_note_switcher_actions(notes: &[NoteSwitcherNoteInfo]) -> Vec<Action> {
+    let invalid_note_count = notes
+        .iter()
+        .filter(|note| has_invalid_note_switcher_note_info(note))
+        .count();
+    if invalid_note_count > 0 {
+        tracing::warn!(
+            target: "script_kit::actions",
+            builder = "note_switcher",
+            note_count = notes.len(),
+            invalid_note_count,
+            "Invalid note switcher input; returning empty actions"
+        );
+        return vec![];
+    }
+
     let mut actions = Vec::new();
 
     for note in notes {

file update:
diff --git a/src/actions/builders/notes.rs b/src/actions/builders/notes.rs
index 48ba267e97bf2f3da7ecf1a3f78fea59dbc9acab..a2f0007d3327b005960130e6e30f524ceb6b3e9f
--- a/src/actions/builders/notes.rs
+++ b/src/actions/builders/notes.rs
@@ -27,6 +27,25 @@
     pub auto_sizing_enabled: bool,
 }
 
+fn is_blank(value: &str) -> bool {
+    value.trim().is_empty()
+}
+
+fn has_invalid_new_chat_model_info(model: &NewChatModelInfo) -> bool {
+    is_blank(&model.model_id)
+        || is_blank(&model.display_name)
+        || is_blank(&model.provider)
+        || is_blank(&model.provider_display_name)
+}
+
+fn has_invalid_new_chat_preset_info(preset: &NewChatPresetInfo) -> bool {
+    is_blank(&preset.id) || is_blank(&preset.name)
+}
+
+fn has_invalid_note_switcher_note_info(note: &NoteSwitcherNoteInfo) -> bool {
+    is_blank(&note.id) || is_blank(&note.title)
+}
+
 /// Get actions for the Notes window command bar (Cmd+K menu).
 pub fn get_notes_command_bar_actions(info: &NotesInfo) -> Vec<Action> {
     let mut actions = Vec::new();
@@ -367,6 +386,76 @@
             Some("Use Focused Writing preset")
         );
     }
+
+    #[test]
+    fn test_get_new_chat_actions_returns_empty_when_last_used_model_input_is_invalid() {
+        let last_used = vec![NewChatModelInfo {
+            model_id: "   ".to_string(),
+            display_name: "GPT-4o Mini".to_string(),
+            provider: "openai".to_string(),
+            provider_display_name: "OpenAI".to_string(),
+        }];
+        let presets = vec![NewChatPresetInfo {
+            id: "focused-writing".to_string(),
+            name: "Focused Writing".to_string(),
+            icon: IconName::Pencil,
+        }];
+
+        let actions = get_new_chat_actions(&last_used, &presets, &[]);
+        assert!(actions.is_empty());
+    }
+
+    #[test]
+    fn test_get_new_chat_actions_returns_empty_when_preset_input_is_invalid() {
+        let last_used = vec![NewChatModelInfo {
+            model_id: "gpt-4o-mini".to_string(),
+            display_name: "GPT-4o Mini".to_string(),
+            provider: "openai".to_string(),
+            provider_display_name: "OpenAI".to_string(),
+        }];
+        let presets = vec![NewChatPresetInfo {
+            id: "   ".to_string(),
+            name: "Focused Writing".to_string(),
+            icon: IconName::Pencil,
+        }];
+
+        let actions = get_new_chat_actions(&last_used, &presets, &[]);
+        assert!(actions.is_empty());
+    }
+
+    #[test]
+    fn test_get_new_chat_actions_returns_empty_when_model_input_is_invalid() {
+        let presets = vec![NewChatPresetInfo {
+            id: "focused-writing".to_string(),
+            name: "Focused Writing".to_string(),
+            icon: IconName::Pencil,
+        }];
+        let models = vec![NewChatModelInfo {
+            model_id: "claude-3-5-sonnet".to_string(),
+            display_name: "Claude 3.5 Sonnet".to_string(),
+            provider: "   ".to_string(),
+            provider_display_name: "Anthropic".to_string(),
+        }];
+
+        let actions = get_new_chat_actions(&[], &presets, &models);
+        assert!(actions.is_empty());
+    }
+
+    #[test]
+    fn test_get_note_switcher_actions_returns_empty_when_note_input_is_invalid() {
+        let notes = vec![NoteSwitcherNoteInfo {
+            id: "   ".to_string(),
+            title: "Missing ID".to_string(),
+            char_count: 5,
+            is_current: false,
+            is_pinned: false,
+            preview: "Preview".to_string(),
+            relative_time: "1m ago".to_string(),
+        }];
+
+        let actions = get_note_switcher_actions(&notes);
+        assert!(actions.is_empty());
+    }
 }
 
 /// Build actions for the AI new chat dropdown.
@@ -376,6 +465,48 @@
     presets: &[NewChatPresetInfo],
     models: &[NewChatModelInfo],
 ) -> Vec<Action> {
+    let invalid_last_used_count = last_used
+        .iter()
+        .filter(|model| has_invalid_new_chat_model_info(model))
+        .count();
+    if invalid_last_used_count > 0 {
+        tracing::warn!(
+            target: "script_kit::actions",
+            builder = "notes_new_chat",
+            invalid_last_used_count,
+            "Invalid last-used chat model input; returning empty actions"
+        );
+        return vec![];
+    }
+
+    let invalid_preset_count = presets
+        .iter()
+        .filter(|preset| has_invalid_new_chat_preset_info(preset))
+        .count();
+    if invalid_preset_count > 0 {
+        tracing::warn!(
+            target: "script_kit::actions",
+            builder = "notes_new_chat",
+            invalid_preset_count,
+            "Invalid chat preset input; returning empty actions"
+        );
+        return vec![];
+    }
+
+    let invalid_model_count = models
+        .iter()
+        .filter(|model| has_invalid_new_chat_model_info(model))
+        .count();
+    if invalid_model_count > 0 {
+        tracing::warn!(
+            target: "script_kit::actions",
+            builder = "notes_new_chat",
+            invalid_model_count,
+            "Invalid chat model input; returning empty actions"
+        );
+        return vec![];
+    }
+
     let mut actions = Vec::new();
 
     for setting in last_used {
@@ -442,6 +573,21 @@
 
 /// Get actions for the note switcher dialog (Cmd+P in Notes window).
 pub fn get_note_switcher_actions(notes: &[NoteSwitcherNoteInfo]) -> Vec<Action> {
+    let invalid_note_count = notes
+        .iter()
+        .filter(|note| has_invalid_note_switcher_note_info(note))
+        .count();
+    if invalid_note_count > 0 {
+        tracing::warn!(
+            target: "script_kit::actions",
+            builder = "note_switcher",
+            note_count = notes.len(),
+            invalid_note_count,
+            "Invalid note switcher input; returning empty actions"
+        );
+        return vec![];
+    }
+
     let mut actions = Vec::new();
 
     for note in notes {


thinking
**Adding validation helper and early return in script context**
codex
I’m moving to `script_context.rs` now: adding one strict input validator at function entry and a small test module to lock the empty-name/empty-verb behavior.
file update
M /Users/johnlindquist/dev/script-kit-gpui/src/actions/builders/script_context.rs
@@ -4,4 +4,19 @@
 
+fn has_invalid_script_context_input(script: &ScriptInfo) -> bool {
+    script.name.trim().is_empty() || script.action_verb.trim().is_empty()
+}
+
 /// Get actions specific to the focused script.
 pub fn get_script_context_actions(script: &ScriptInfo) -> Vec<Action> {
+    if has_invalid_script_context_input(script) {
+        tracing::warn!(
+            target: "script_kit::actions",
+            builder = "script_context",
+            name = %script.name,
+            action_verb = %script.action_verb,
+            "Invalid script context input; returning empty actions"
+        );
+        return vec![];
+    }
+
     let mut actions = Vec::new();
@@ -316 +331,24 @@
 }
+
+#[cfg(test)]
+mod tests {
+    use super::*;
+
+    #[test]
+    fn test_get_script_context_actions_returns_empty_when_name_is_blank() {
+        let mut script = ScriptInfo::new("Valid", "/tmp/valid.ts");
+        script.name = "   ".to_string();
+
+        let actions = get_script_context_actions(&script);
+        assert!(actions.is_empty());
+    }
+
+    #[test]
+    fn test_get_script_context_actions_returns_empty_when_action_verb_is_blank() {
+        let mut script = ScriptInfo::new("Valid", "/tmp/valid.ts");
+        script.action_verb = "   ".to_string();
+
+        let actions = get_script_context_actions(&script);
+        assert!(actions.is_empty());
+    }
+}
apply_patch(auto_approved=true) exited 0 in 17ms:
Success. Updated the following files:
M src/actions/builders/script_context.rs
file update:
diff --git a/src/actions/builders/notes.rs b/src/actions/builders/notes.rs
index 48ba267e97bf2f3da7ecf1a3f78fea59dbc9acab..a2f0007d3327b005960130e6e30f524ceb6b3e9f
--- a/src/actions/builders/notes.rs
+++ b/src/actions/builders/notes.rs
@@ -27,6 +27,25 @@
     pub auto_sizing_enabled: bool,
 }
 
+fn is_blank(value: &str) -> bool {
+    value.trim().is_empty()
+}
+
+fn has_invalid_new_chat_model_info(model: &NewChatModelInfo) -> bool {
+    is_blank(&model.model_id)
+        || is_blank(&model.display_name)
+        || is_blank(&model.provider)
+        || is_blank(&model.provider_display_name)
+}
+
+fn has_invalid_new_chat_preset_info(preset: &NewChatPresetInfo) -> bool {
+    is_blank(&preset.id) || is_blank(&preset.name)
+}
+
+fn has_invalid_note_switcher_note_info(note: &NoteSwitcherNoteInfo) -> bool {
+    is_blank(&note.id) || is_blank(&note.title)
+}
+
 /// Get actions for the Notes window command bar (Cmd+K menu).
 pub fn get_notes_command_bar_actions(info: &NotesInfo) -> Vec<Action> {
     let mut actions = Vec::new();
@@ -367,6 +386,76 @@
             Some("Use Focused Writing preset")
         );
     }
+
+    #[test]
+    fn test_get_new_chat_actions_returns_empty_when_last_used_model_input_is_invalid() {
+        let last_used = vec![NewChatModelInfo {
+            model_id: "   ".to_string(),
+            display_name: "GPT-4o Mini".to_string(),
+            provider: "openai".to_string(),
+            provider_display_name: "OpenAI".to_string(),
+        }];
+        let presets = vec![NewChatPresetInfo {
+            id: "focused-writing".to_string(),
+            name: "Focused Writing".to_string(),
+            icon: IconName::Pencil,
+        }];
+
+        let actions = get_new_chat_actions(&last_used, &presets, &[]);
+        assert!(actions.is_empty());
+    }
+
+    #[test]
+    fn test_get_new_chat_actions_returns_empty_when_preset_input_is_invalid() {
+        let last_used = vec![NewChatModelInfo {
+            model_id: "gpt-4o-mini".to_string(),
+            display_name: "GPT-4o Mini".to_string(),
+            provider: "openai".to_string(),
+            provider_display_name: "OpenAI".to_string(),
+        }];
+        let presets = vec![NewChatPresetInfo {
+            id: "   ".to_string(),
+            name: "Focused Writing".to_string(),
+            icon: IconName::Pencil,
+        }];
+
+        let actions = get_new_chat_actions(&last_used, &presets, &[]);
+        assert!(actions.is_empty());
+    }
+
+    #[test]
+    fn test_get_new_chat_actions_returns_empty_when_model_input_is_invalid() {
+        let presets = vec![NewChatPresetInfo {
+            id: "focused-writing".to_string(),
+            name: "Focused Writing".to_string(),
+            icon: IconName::Pencil,
+        }];
+        let models = vec![NewChatModelInfo {
+            model_id: "claude-3-5-sonnet".to_string(),
+            display_name: "Claude 3.5 Sonnet".to_string(),
+            provider: "   ".to_string(),
+            provider_display_name: "Anthropic".to_string(),
+        }];
+
+        let actions = get_new_chat_actions(&[], &presets, &models);
+        assert!(actions.is_empty());
+    }
+
+    #[test]
+    fn test_get_note_switcher_actions_returns_empty_when_note_input_is_invalid() {
+        let notes = vec![NoteSwitcherNoteInfo {
+            id: "   ".to_string(),
+            title: "Missing ID".to_string(),
+            char_count: 5,
+            is_current: false,
+            is_pinned: false,
+            preview: "Preview".to_string(),
+            relative_time: "1m ago".to_string(),
+        }];
+
+        let actions = get_note_switcher_actions(&notes);
+        assert!(actions.is_empty());
+    }
 }
 
 /// Build actions for the AI new chat dropdown.
@@ -376,6 +465,48 @@
     presets: &[NewChatPresetInfo],
     models: &[NewChatModelInfo],
 ) -> Vec<Action> {
+    let invalid_last_used_count = last_used
+        .iter()
+        .filter(|model| has_invalid_new_chat_model_info(model))
+        .count();
+    if invalid_last_used_count > 0 {
+        tracing::warn!(
+            target: "script_kit::actions",
+            builder = "notes_new_chat",
+            invalid_last_used_count,
+            "Invalid last-used chat model input; returning empty actions"
+        );
+        return vec![];
+    }
+
+    let invalid_preset_count = presets
+        .iter()
+        .filter(|preset| has_invalid_new_chat_preset_info(preset))
+        .count();
+    if invalid_preset_count > 0 {
+        tracing::warn!(
+            target: "script_kit::actions",
+            builder = "notes_new_chat",
+            invalid_preset_count,
+            "Invalid chat preset input; returning empty actions"
+        );
+        return vec![];
+    }
+
+    let invalid_model_count = models
+        .iter()
+        .filter(|model| has_invalid_new_chat_model_info(model))
+        .count();
+    if invalid_model_count > 0 {
+        tracing::warn!(
+            target: "script_kit::actions",
+            builder = "notes_new_chat",
+            invalid_model_count,
+            "Invalid chat model input; returning empty actions"
+        );
+        return vec![];
+    }
+
     let mut actions = Vec::new();
 
     for setting in last_used {
@@ -442,6 +573,21 @@
 
 /// Get actions for the note switcher dialog (Cmd+P in Notes window).
 pub fn get_note_switcher_actions(notes: &[NoteSwitcherNoteInfo]) -> Vec<Action> {
+    let invalid_note_count = notes
+        .iter()
+        .filter(|note| has_invalid_note_switcher_note_info(note))
+        .count();
+    if invalid_note_count > 0 {
+        tracing::warn!(
+            target: "script_kit::actions",
+            builder = "note_switcher",
+            note_count = notes.len(),
+            invalid_note_count,
+            "Invalid note switcher input; returning empty actions"
+        );
+        return vec![];
+    }
+
     let mut actions = Vec::new();
 
     for note in notes {
diff --git a/src/actions/builders/script_context.rs b/src/actions/builders/script_context.rs
index d48add6d0604e4fc8ab6bc1d9a9cdc328a6037ab..c09068069325e288d1c697a6ed9aa07944aadf61
--- a/src/actions/builders/script_context.rs
+++ b/src/actions/builders/script_context.rs
@@ -2,8 +2,23 @@
 use super::types::{Action, ActionCategory, ScriptInfo};
 use std::collections::HashSet;
 
+fn has_invalid_script_context_input(script: &ScriptInfo) -> bool {
+    script.name.trim().is_empty() || script.action_verb.trim().is_empty()
+}
+
 /// Get actions specific to the focused script.
 pub fn get_script_context_actions(script: &ScriptInfo) -> Vec<Action> {
+    if has_invalid_script_context_input(script) {
+        tracing::warn!(
+            target: "script_kit::actions",
+            builder = "script_context",
+            name = %script.name,
+            action_verb = %script.action_verb,
+            "Invalid script context input; returning empty actions"
+        );
+        return vec![];
+    }
+
     let mut actions = Vec::new();
     let mut destructive_actions = Vec::new();
 
@@ -314,3 +329,26 @@
 pub fn get_global_actions() -> Vec<Action> {
     vec![]
 }
+
+#[cfg(test)]
+mod tests {
+    use super::*;
+
+    #[test]
+    fn test_get_script_context_actions_returns_empty_when_name_is_blank() {
+        let mut script = ScriptInfo::new("Valid", "/tmp/valid.ts");
+        script.name = "   ".to_string();
+
+        let actions = get_script_context_actions(&script);
+        assert!(actions.is_empty());
+    }
+
+    #[test]
+    fn test_get_script_context_actions_returns_empty_when_action_verb_is_blank() {
+        let mut script = ScriptInfo::new("Valid", "/tmp/valid.ts");
+        script.action_verb = "   ".to_string();
+
+        let actions = get_script_context_actions(&script);
+        assert!(actions.is_empty());
+    }
+}

file update:
diff --git a/src/actions/builders/notes.rs b/src/actions/builders/notes.rs
index 48ba267e97bf2f3da7ecf1a3f78fea59dbc9acab..a2f0007d3327b005960130e6e30f524ceb6b3e9f
--- a/src/actions/builders/notes.rs
+++ b/src/actions/builders/notes.rs
@@ -27,6 +27,25 @@
     pub auto_sizing_enabled: bool,
 }
 
+fn is_blank(value: &str) -> bool {
+    value.trim().is_empty()
+}
+
+fn has_invalid_new_chat_model_info(model: &NewChatModelInfo) -> bool {
+    is_blank(&model.model_id)
+        || is_blank(&model.display_name)
+        || is_blank(&model.provider)
+        || is_blank(&model.provider_display_name)
+}
+
+fn has_invalid_new_chat_preset_info(preset: &NewChatPresetInfo) -> bool {
+    is_blank(&preset.id) || is_blank(&preset.name)
+}
+
+fn has_invalid_note_switcher_note_info(note: &NoteSwitcherNoteInfo) -> bool {
+    is_blank(&note.id) || is_blank(&note.title)
+}
+
 /// Get actions for the Notes window command bar (Cmd+K menu).
 pub fn get_notes_command_bar_actions(info: &NotesInfo) -> Vec<Action> {
     let mut actions = Vec::new();
@@ -367,6 +386,76 @@
             Some("Use Focused Writing preset")
         );
     }
+
+    #[test]
+    fn test_get_new_chat_actions_returns_empty_when_last_used_model_input_is_invalid() {
+        let last_used = vec![NewChatModelInfo {
+            model_id: "   ".to_string(),
+            display_name: "GPT-4o Mini".to_string(),
+            provider: "openai".to_string(),
+            provider_display_name: "OpenAI".to_string(),
+        }];
+        let presets = vec![NewChatPresetInfo {
+            id: "focused-writing".to_string(),
+            name: "Focused Writing".to_string(),
+            icon: IconName::Pencil,
+        }];
+
+        let actions = get_new_chat_actions(&last_used, &presets, &[]);
+        assert!(actions.is_empty());
+    }
+
+    #[test]
+    fn test_get_new_chat_actions_returns_empty_when_preset_input_is_invalid() {
+        let last_used = vec![NewChatModelInfo {
+            model_id: "gpt-4o-mini".to_string(),
+            display_name: "GPT-4o Mini".to_string(),
+            provider: "openai".to_string(),
+            provider_display_name: "OpenAI".to_string(),
+        }];
+        let presets = vec![NewChatPresetInfo {
+            id: "   ".to_string(),
+            name: "Focused Writing".to_string(),
+            icon: IconName::Pencil,
+        }];
+
+        let actions = get_new_chat_actions(&last_used, &presets, &[]);
+        assert!(actions.is_empty());
+    }
+
+    #[test]
+    fn test_get_new_chat_actions_returns_empty_when_model_input_is_invalid() {
+        let presets = vec![NewChatPresetInfo {
+            id: "focused-writing".to_string(),
+            name: "Focused Writing".to_string(),
+            icon: IconName::Pencil,
+        }];
+        let models = vec![NewChatModelInfo {
+            model_id: "claude-3-5-sonnet".to_string(),
+            display_name: "Claude 3.5 Sonnet".to_string(),
+            provider: "   ".to_string(),
+            provider_display_name: "Anthropic".to_string(),
+        }];
+
+        let actions = get_new_chat_actions(&[], &presets, &models);
+        assert!(actions.is_empty());
+    }
+
+    #[test]
+    fn test_get_note_switcher_actions_returns_empty_when_note_input_is_invalid() {
+        let notes = vec![NoteSwitcherNoteInfo {
+            id: "   ".to_string(),
+            title: "Missing ID".to_string(),
+            char_count: 5,
+            is_current: false,
+            is_pinned: false,
+            preview: "Preview".to_string(),
+            relative_time: "1m ago".to_string(),
+        }];
+
+        let actions = get_note_switcher_actions(&notes);
+        assert!(actions.is_empty());
+    }
 }
 
 /// Build actions for the AI new chat dropdown.
@@ -376,6 +465,48 @@
     presets: &[NewChatPresetInfo],
     models: &[NewChatModelInfo],
 ) -> Vec<Action> {
+    let invalid_last_used_count = last_used
+        .iter()
+        .filter(|model| has_invalid_new_chat_model_info(model))
+        .count();
+    if invalid_last_used_count > 0 {
+        tracing::warn!(
+            target: "script_kit::actions",
+            builder = "notes_new_chat",
+            invalid_last_used_count,
+            "Invalid last-used chat model input; returning empty actions"
+        );
+        return vec![];
+    }
+
+    let invalid_preset_count = presets
+        .iter()
+        .filter(|preset| has_invalid_new_chat_preset_info(preset))
+        .count();
+    if invalid_preset_count > 0 {
+        tracing::warn!(
+            target: "script_kit::actions",
+            builder = "notes_new_chat",
+            invalid_preset_count,
+            "Invalid chat preset input; returning empty actions"
+        );
+        return vec![];
+    }
+
+    let invalid_model_count = models
+        .iter()
+        .filter(|model| has_invalid_new_chat_model_info(model))
+        .count();
+    if invalid_model_count > 0 {
+        tracing::warn!(
+            target: "script_kit::actions",
+            builder = "notes_new_chat",
+            invalid_model_count,
+            "Invalid chat model input; returning empty actions"
+        );
+        return vec![];
+    }
+
     let mut actions = Vec::new();
 
     for setting in last_used {
@@ -442,6 +573,21 @@
 
 /// Get actions for the note switcher dialog (Cmd+P in Notes window).
 pub fn get_note_switcher_actions(notes: &[NoteSwitcherNoteInfo]) -> Vec<Action> {
+    let invalid_note_count = notes
+        .iter()
+        .filter(|note| has_invalid_note_switcher_note_info(note))
+        .count();
+    if invalid_note_count > 0 {
+        tracing::warn!(
+            target: "script_kit::actions",
+            builder = "note_switcher",
+            note_count = notes.len(),
+            invalid_note_count,
+            "Invalid note switcher input; returning empty actions"
+        );
+        return vec![];
+    }
+
     let mut actions = Vec::new();
 
     for note in notes {
diff --git a/src/actions/builders/script_context.rs b/src/actions/builders/script_context.rs
index d48add6d0604e4fc8ab6bc1d9a9cdc328a6037ab..c09068069325e288d1c697a6ed9aa07944aadf61
--- a/src/actions/builders/script_context.rs
+++ b/src/actions/builders/script_context.rs
@@ -2,8 +2,23 @@
 use super::types::{Action, ActionCategory, ScriptInfo};
 use std::collections::HashSet;
 
+fn has_invalid_script_context_input(script: &ScriptInfo) -> bool {
+    script.name.trim().is_empty() || script.action_verb.trim().is_empty()
+}
+
 /// Get actions specific to the focused script.
 pub fn get_script_context_actions(script: &ScriptInfo) -> Vec<Action> {
+    if has_invalid_script_context_input(script) {
+        tracing::warn!(
+            target: "script_kit::actions",
+            builder = "script_context",
+            name = %script.name,
+            action_verb = %script.action_verb,
+            "Invalid script context input; returning empty actions"
+        );
+        return vec![];
+    }
+
     let mut actions = Vec::new();
     let mut destructive_actions = Vec::new();
 
@@ -314,3 +329,26 @@
 pub fn get_global_actions() -> Vec<Action> {
     vec![]
 }
+
+#[cfg(test)]
+mod tests {
+    use super::*;
+
+    #[test]
+    fn test_get_script_context_actions_returns_empty_when_name_is_blank() {
+        let mut script = ScriptInfo::new("Valid", "/tmp/valid.ts");
+        script.name = "   ".to_string();
+
+        let actions = get_script_context_actions(&script);
+        assert!(actions.is_empty());
+    }
+
+    #[test]
+    fn test_get_script_context_actions_returns_empty_when_action_verb_is_blank() {
+        let mut script = ScriptInfo::new("Valid", "/tmp/valid.ts");
+        script.action_verb = "   ".to_string();
+
+        let actions = get_script_context_actions(&script);
+        assert!(actions.is_empty());
+    }
+}


thinking
**Planning scriptlet claim and formatting**
codex
`notes.rs` and `script_context.rs` are updated with warn+empty invalid-input guards and tests. I’m now waiting to claim `scriptlet.rs` (currently held by another agent) so I can finish the same consistency pass there.
exec
/bin/zsh -lc '~/.claude/bin/swarm.ts claim --wait --id codex-fix-builder-error-consistency-2 src/actions/builders/scriptlet.rs' in /Users/johnlindquist/dev/script-kit-gpuifile update:
diff --git a/src/actions/builders/notes.rs b/src/actions/builders/notes.rs
index 48ba267e97bf2f3da7ecf1a3f78fea59dbc9acab..a2f0007d3327b005960130e6e30f524ceb6b3e9f
--- a/src/actions/builders/notes.rs
+++ b/src/actions/builders/notes.rs
@@ -27,6 +27,25 @@
     pub auto_sizing_enabled: bool,
 }
 
+fn is_blank(value: &str) -> bool {
+    value.trim().is_empty()
+}
+
+fn has_invalid_new_chat_model_info(model: &NewChatModelInfo) -> bool {
+    is_blank(&model.model_id)
+        || is_blank(&model.display_name)
+        || is_blank(&model.provider)
+        || is_blank(&model.provider_display_name)
+}
+
+fn has_invalid_new_chat_preset_info(preset: &NewChatPresetInfo) -> bool {
+    is_blank(&preset.id) || is_blank(&preset.name)
+}
+
+fn has_invalid_note_switcher_note_info(note: &NoteSwitcherNoteInfo) -> bool {
+    is_blank(&note.id) || is_blank(&note.title)
+}
+
 /// Get actions for the Notes window command bar (Cmd+K menu).
 pub fn get_notes_command_bar_actions(info: &NotesInfo) -> Vec<Action> {
     let mut actions = Vec::new();
@@ -367,6 +386,76 @@
             Some("Use Focused Writing preset")
         );
     }
+
+    #[test]
+    fn test_get_new_chat_actions_returns_empty_when_last_used_model_input_is_invalid() {
+        let last_used = vec![NewChatModelInfo {
+            model_id: "   ".to_string(),
+            display_name: "GPT-4o Mini".to_string(),
+            provider: "openai".to_string(),
+            provider_display_name: "OpenAI".to_string(),
+        }];
+        let presets = vec![NewChatPresetInfo {
+            id: "focused-writing".to_string(),
+            name: "Focused Writing".to_string(),
+            icon: IconName::Pencil,
+        }];
+
+        let actions = get_new_chat_actions(&last_used, &presets, &[]);
+        assert!(actions.is_empty());
+    }
+
+    #[test]
+    fn test_get_new_chat_actions_returns_empty_when_preset_input_is_invalid() {
+        let last_used = vec![NewChatModelInfo {
+            model_id: "gpt-4o-mini".to_string(),
+            display_name: "GPT-4o Mini".to_string(),
+            provider: "openai".to_string(),
+            provider_display_name: "OpenAI".to_string(),
+        }];
+        let presets = vec![NewChatPresetInfo {
+            id: "   ".to_string(),
+            name: "Focused Writing".to_string(),
+            icon: IconName::Pencil,
+        }];
+
+        let actions = get_new_chat_actions(&last_used, &presets, &[]);
+        assert!(actions.is_empty());
+    }
+
+    #[test]
+    fn test_get_new_chat_actions_returns_empty_when_model_input_is_invalid() {
+        let presets = vec![NewChatPresetInfo {
+            id: "focused-writing".to_string(),
+            name: "Focused Writing".to_string(),
+            icon: IconName::Pencil,
+        }];
+        let models = vec![NewChatModelInfo {
+            model_id: "claude-3-5-sonnet".to_string(),
+            display_name: "Claude 3.5 Sonnet".to_string(),
+            provider: "   ".to_string(),
+            provider_display_name: "Anthropic".to_string(),
+        }];
+
+        let actions = get_new_chat_actions(&[], &presets, &models);
+        assert!(actions.is_empty());
+    }
+
+    #[test]
+    fn test_get_note_switcher_actions_returns_empty_when_note_input_is_invalid() {
+        let notes = vec![NoteSwitcherNoteInfo {
+            id: "   ".to_string(),
+            title: "Missing ID".to_string(),
+            char_count: 5,
+            is_current: false,
+            is_pinned: false,
+            preview: "Preview".to_string(),
+            relative_time: "1m ago".to_string(),
+        }];
+
+        let actions = get_note_switcher_actions(&notes);
+        assert!(actions.is_empty());
+    }
 }
 
 /// Build actions for the AI new chat dropdown.
@@ -376,6 +465,48 @@
     presets: &[NewChatPresetInfo],
     models: &[NewChatModelInfo],
 ) -> Vec<Action> {
+    let invalid_last_used_count = last_used
+        .iter()
+        .filter(|model| has_invalid_new_chat_model_info(model))
+        .count();
+    if invalid_last_used_count > 0 {
+        tracing::warn!(
+            target: "script_kit::actions",
+            builder = "notes_new_chat",
+            invalid_last_used_count,
+            "Invalid last-used chat model input; returning empty actions"
+        );
+        return vec![];
+    }
+
+    let invalid_preset_count = presets
+        .iter()
+        .filter(|preset| has_invalid_new_chat_preset_info(preset))
+        .count();
+    if invalid_preset_count > 0 {
+        tracing::warn!(
+            target: "script_kit::actions",
+            builder = "notes_new_chat",
+            invalid_preset_count,
+            "Invalid chat preset input; returning empty actions"
+        );
+        return vec![];
+    }
+
+    let invalid_model_count = models
+        .iter()
+        .filter(|model| has_invalid_new_chat_model_info(model))
+        .count();
+    if invalid_model_count > 0 {
+        tracing::warn!(
+            target: "script_kit::actions",
+            builder = "notes_new_chat",
+            invalid_model_count,
+            "Invalid chat model input; returning empty actions"
+        );
+        return vec![];
+    }
+
     let mut actions = Vec::new();
 
     for setting in last_used {
@@ -442,6 +573,21 @@
 
 /// Get actions for the note switcher dialog (Cmd+P in Notes window).
 pub fn get_note_switcher_actions(notes: &[NoteSwitcherNoteInfo]) -> Vec<Action> {
+    let invalid_note_count = notes
+        .iter()
+        .filter(|note| has_invalid_note_switcher_note_info(note))
+        .count();
+    if invalid_note_count > 0 {
+        tracing::warn!(
+            target: "script_kit::actions",
+            builder = "note_switcher",
+            note_count = notes.len(),
+            invalid_note_count,
+            "Invalid note switcher input; returning empty actions"
+        );
+        return vec![];
+    }
+
     let mut actions = Vec::new();
 
     for note in notes {
diff --git a/src/actions/builders/script_context.rs b/src/actions/builders/script_context.rs
index d48add6d0604e4fc8ab6bc1d9a9cdc328a6037ab..c09068069325e288d1c697a6ed9aa07944aadf61
--- a/src/actions/builders/script_context.rs
+++ b/src/actions/builders/script_context.rs
@@ -2,8 +2,23 @@
 use super::types::{Action, ActionCategory, ScriptInfo};
 use std::collections::HashSet;
 
+fn has_invalid_script_context_input(script: &ScriptInfo) -> bool {
+    script.name.trim().is_empty() || script.action_verb.trim().is_empty()
+}
+
 /// Get actions specific to the focused script.
 pub fn get_script_context_actions(script: &ScriptInfo) -> Vec<Action> {
+    if has_invalid_script_context_input(script) {
+        tracing::warn!(
+            target: "script_kit::actions",
+            builder = "script_context",
+            name = %script.name,
+            action_verb = %script.action_verb,
+            "Invalid script context input; returning empty actions"
+        );
+        return vec![];
+    }
+
     let mut actions = Vec::new();
     let mut destructive_actions = Vec::new();
 
@@ -314,3 +329,26 @@
 pub fn get_global_actions() -> Vec<Action> {
     vec![]
 }
+
+#[cfg(test)]
+mod tests {
+    use super::*;
+
+    #[test]
+    fn test_get_script_context_actions_returns_empty_when_name_is_blank() {
+        let mut script = ScriptInfo::new("Valid", "/tmp/valid.ts");
+        script.name = "   ".to_string();
+
+        let actions = get_script_context_actions(&script);
+        assert!(actions.is_empty());
+    }
+
+    #[test]
+    fn test_get_script_context_actions_returns_empty_when_action_verb_is_blank() {
+        let mut script = ScriptInfo::new("Valid", "/tmp/valid.ts");
+        script.action_verb = "   ".to_string();
+
+        let actions = get_script_context_actions(&script);
+        assert!(actions.is_empty());
+    }
+}


thinking
**Planning polling for claim acquisition**
codex
I’m blocked on the `scriptlet.rs` claim right now and polling the lock; as soon as it’s released I’ll apply the same invalid-input guard pattern there and run the scoped checks.
file update:
diff --git a/src/actions/builders/notes.rs b/src/actions/builders/notes.rs
index 48ba267e97bf2f3da7ecf1a3f78fea59dbc9acab..a2f0007d3327b005960130e6e30f524ceb6b3e9f
--- a/src/actions/builders/notes.rs
+++ b/src/actions/builders/notes.rs
@@ -27,6 +27,25 @@
     pub auto_sizing_enabled: bool,
 }
 
+fn is_blank(value: &str) -> bool {
+    value.trim().is_empty()
+}
+
+fn has_invalid_new_chat_model_info(model: &NewChatModelInfo) -> bool {
+    is_blank(&model.model_id)
+        || is_blank(&model.display_name)
+        || is_blank(&model.provider)
+        || is_blank(&model.provider_display_name)
+}
+
+fn has_invalid_new_chat_preset_info(preset: &NewChatPresetInfo) -> bool {
+    is_blank(&preset.id) || is_blank(&preset.name)
+}
+
+fn has_invalid_note_switcher_note_info(note: &NoteSwitcherNoteInfo) -> bool {
+    is_blank(&note.id) || is_blank(&note.title)
+}
+
 /// Get actions for the Notes window command bar (Cmd+K menu).
 pub fn get_notes_command_bar_actions(info: &NotesInfo) -> Vec<Action> {
     let mut actions = Vec::new();
@@ -367,6 +386,76 @@
             Some("Use Focused Writing preset")
         );
     }
+
+    #[test]
+    fn test_get_new_chat_actions_returns_empty_when_last_used_model_input_is_invalid() {
+        let last_used = vec![NewChatModelInfo {
+            model_id: "   ".to_string(),
+            display_name: "GPT-4o Mini".to_string(),
+            provider: "openai".to_string(),
+            provider_display_name: "OpenAI".to_string(),
+        }];
+        let presets = vec![NewChatPresetInfo {
+            id: "focused-writing".to_string(),
+            name: "Focused Writing".to_string(),
+            icon: IconName::Pencil,
+        }];
+
+        let actions = get_new_chat_actions(&last_used, &presets, &[]);
+        assert!(actions.is_empty());
+    }
+
+    #[test]
+    fn test_get_new_chat_actions_returns_empty_when_preset_input_is_invalid() {
+        let last_used = vec![NewChatModelInfo {
+            model_id: "gpt-4o-mini".to_string(),
+            display_name: "GPT-4o Mini".to_string(),
+            provider: "openai".to_string(),
+            provider_display_name: "OpenAI".to_string(),
+        }];
+        let presets = vec![NewChatPresetInfo {
+            id: "   ".to_string(),
+            name: "Focused Writing".to_string(),
+            icon: IconName::Pencil,
+        }];
+
+        let actions = get_new_chat_actions(&last_used, &presets, &[]);
+        assert!(actions.is_empty());
+    }
+
+    #[test]
+    fn test_get_new_chat_actions_returns_empty_when_model_input_is_invalid() {
+        let presets = vec![NewChatPresetInfo {
+            id: "focused-writing".to_string(),
+            name: "Focused Writing".to_string(),
+            icon: IconName::Pencil,
+        }];
+        let models = vec![NewChatModelInfo {
+            model_id: "claude-3-5-sonnet".to_string(),
+            display_name: "Claude 3.5 Sonnet".to_string(),
+            provider: "   ".to_string(),
+            provider_display_name: "Anthropic".to_string(),
+        }];
+
+        let actions = get_new_chat_actions(&[], &presets, &models);
+        assert!(actions.is_empty());
+    }
+
+    #[test]
+    fn test_get_note_switcher_actions_returns_empty_when_note_input_is_invalid() {
+        let notes = vec![NoteSwitcherNoteInfo {
+            id: "   ".to_string(),
+            title: "Missing ID".to_string(),
+            char_count: 5,
+            is_current: false,
+            is_pinned: false,
+            preview: "Preview".to_string(),
+            relative_time: "1m ago".to_string(),
+        }];
+
+        let actions = get_note_switcher_actions(&notes);
+        assert!(actions.is_empty());
+    }
 }
 
 /// Build actions for the AI new chat dropdown.
@@ -376,6 +465,48 @@
     presets: &[NewChatPresetInfo],
     models: &[NewChatModelInfo],
 ) -> Vec<Action> {
+    let invalid_last_used_count = last_used
+        .iter()
+        .filter(|model| has_invalid_new_chat_model_info(model))
+        .count();
+    if invalid_last_used_count > 0 {
+        tracing::warn!(
+            target: "script_kit::actions",
+            builder = "notes_new_chat",
+            invalid_last_used_count,
+            "Invalid last-used chat model input; returning empty actions"
+        );
+        return vec![];
+    }
+
+    let invalid_preset_count = presets
+        .iter()
+        .filter(|preset| has_invalid_new_chat_preset_info(preset))
+        .count();
+    if invalid_preset_count > 0 {
+        tracing::warn!(
+            target: "script_kit::actions",
+            builder = "notes_new_chat",
+            invalid_preset_count,
+            "Invalid chat preset input; returning empty actions"
+        );
+        return vec![];
+    }
+
+    let invalid_model_count = models
+        .iter()
+        .filter(|model| has_invalid_new_chat_model_info(model))
+        .count();
+    if invalid_model_count > 0 {
+        tracing::warn!(
+            target: "script_kit::actions",
+            builder = "notes_new_chat",
+            invalid_model_count,
+            "Invalid chat model input; returning empty actions"
+        );
+        return vec![];
+    }
+
     let mut actions = Vec::new();
 
     for setting in last_used {
@@ -442,6 +573,21 @@
 
 /// Get actions for the note switcher dialog (Cmd+P in Notes window).
 pub fn get_note_switcher_actions(notes: &[NoteSwitcherNoteInfo]) -> Vec<Action> {
+    let invalid_note_count = notes
+        .iter()
+        .filter(|note| has_invalid_note_switcher_note_info(note))
+        .count();
+    if invalid_note_count > 0 {
+        tracing::warn!(
+            target: "script_kit::actions",
+            builder = "note_switcher",
+            note_count = notes.len(),
+            invalid_note_count,
+            "Invalid note switcher input; returning empty actions"
+        );
+        return vec![];
+    }
+
     let mut actions = Vec::new();
 
     for note in notes {
diff --git a/src/actions/builders/script_context.rs b/src/actions/builders/script_context.rs
index d48add6d0604e4fc8ab6bc1d9a9cdc328a6037ab..c09068069325e288d1c697a6ed9aa07944aadf61
--- a/src/actions/builders/script_context.rs
+++ b/src/actions/builders/script_context.rs
@@ -2,8 +2,23 @@
 use super::types::{Action, ActionCategory, ScriptInfo};
 use std::collections::HashSet;
 
+fn has_invalid_script_context_input(script: &ScriptInfo) -> bool {
+    script.name.trim().is_empty() || script.action_verb.trim().is_empty()
+}
+
 /// Get actions specific to the focused script.
 pub fn get_script_context_actions(script: &ScriptInfo) -> Vec<Action> {
+    if has_invalid_script_context_input(script) {
+        tracing::warn!(
+            target: "script_kit::actions",
+            builder = "script_context",
+            name = %script.name,
+            action_verb = %script.action_verb,
+            "Invalid script context input; returning empty actions"
+        );
+        return vec![];
+    }
+
     let mut actions = Vec::new();
     let mut destructive_actions = Vec::new();
 
@@ -314,3 +329,26 @@
 pub fn get_global_actions() -> Vec<Action> {
     vec![]
 }
+
+#[cfg(test)]
+mod tests {
+    use super::*;
+
+    #[test]
+    fn test_get_script_context_actions_returns_empty_when_name_is_blank() {
+        let mut script = ScriptInfo::new("Valid", "/tmp/valid.ts");
+        script.name = "   ".to_string();
+
+        let actions = get_script_context_actions(&script);
+        assert!(actions.is_empty());
+    }
+
+    #[test]
+    fn test_get_script_context_actions_returns_empty_when_action_verb_is_blank() {
+        let mut script = ScriptInfo::new("Valid", "/tmp/valid.ts");
+        script.action_verb = "   ".to_string();
+
+        let actions = get_script_context_actions(&script);
+        assert!(actions.is_empty());
+    }
+}

file update:
diff --git a/src/actions/builders/notes.rs b/src/actions/builders/notes.rs
index 48ba267e97bf2f3da7ecf1a3f78fea59dbc9acab..a2f0007d3327b005960130e6e30f524ceb6b3e9f
--- a/src/actions/builders/notes.rs
+++ b/src/actions/builders/notes.rs
@@ -27,6 +27,25 @@
     pub auto_sizing_enabled: bool,
 }
 
+fn is_blank(value: &str) -> bool {
+    value.trim().is_empty()
+}
+
+fn has_invalid_new_chat_model_info(model: &NewChatModelInfo) -> bool {
+    is_blank(&model.model_id)
+        || is_blank(&model.display_name)
+        || is_blank(&model.provider)
+        || is_blank(&model.provider_display_name)
+}
+
+fn has_invalid_new_chat_preset_info(preset: &NewChatPresetInfo) -> bool {
+    is_blank(&preset.id) || is_blank(&preset.name)
+}
+
+fn has_invalid_note_switcher_note_info(note: &NoteSwitcherNoteInfo) -> bool {
+    is_blank(&note.id) || is_blank(&note.title)
+}
+
 /// Get actions for the Notes window command bar (Cmd+K menu).
 pub fn get_notes_command_bar_actions(info: &NotesInfo) -> Vec<Action> {
     let mut actions = Vec::new();
@@ -367,6 +386,76 @@
             Some("Use Focused Writing preset")
         );
     }
+
+    #[test]
+    fn test_get_new_chat_actions_returns_empty_when_last_used_model_input_is_invalid() {
+        let last_used = vec![NewChatModelInfo {
+            model_id: "   ".to_string(),
+            display_name: "GPT-4o Mini".to_string(),
+            provider: "openai".to_string(),
+            provider_display_name: "OpenAI".to_string(),
+        }];
+        let presets = vec![NewChatPresetInfo {
+            id: "focused-writing".to_string(),
+            name: "Focused Writing".to_string(),
+            icon: IconName::Pencil,
+        }];
+
+        let actions = get_new_chat_actions(&last_used, &presets, &[]);
+        assert!(actions.is_empty());
+    }
+
+    #[test]
+    fn test_get_new_chat_actions_returns_empty_when_preset_input_is_invalid() {
+        let last_used = vec![NewChatModelInfo {
+            model_id: "gpt-4o-mini".to_string(),
+            display_name: "GPT-4o Mini".to_string(),
+            provider: "openai".to_string(),
+            provider_display_name: "OpenAI".to_string(),
+        }];
+        let presets = vec![NewChatPresetInfo {
+            id: "   ".to_string(),
+            name: "Focused Writing".to_string(),
+            icon: IconName::Pencil,
+        }];
+
+        let actions = get_new_chat_actions(&last_used, &presets, &[]);
+        assert!(actions.is_empty());
+    }
+
+    #[test]
+    fn test_get_new_chat_actions_returns_empty_when_model_input_is_invalid() {
+        let presets = vec![NewChatPresetInfo {
+            id: "focused-writing".to_string(),
+            name: "Focused Writing".to_string(),
+            icon: IconName::Pencil,
+        }];
+        let models = vec![NewChatModelInfo {
+            model_id: "claude-3-5-sonnet".to_string(),
+            display_name: "Claude 3.5 Sonnet".to_string(),
+            provider: "   ".to_string(),
+            provider_display_name: "Anthropic".to_string(),
+        }];
+
+        let actions = get_new_chat_actions(&[], &presets, &models);
+        assert!(actions.is_empty());
+    }
+
+    #[test]
+    fn test_get_note_switcher_actions_returns_empty_when_note_input_is_invalid() {
+        let notes = vec![NoteSwitcherNoteInfo {
+            id: "   ".to_string(),
+            title: "Missing ID".to_string(),
+            char_count: 5,
+            is_current: false,
+            is_pinned: false,
+            preview: "Preview".to_string(),
+            relative_time: "1m ago".to_string(),
+        }];
+
+        let actions = get_note_switcher_actions(&notes);
+        assert!(actions.is_empty());
+    }
 }
 
 /// Build actions for the AI new chat dropdown.
@@ -376,6 +465,48 @@
     presets: &[NewChatPresetInfo],
     models: &[NewChatModelInfo],
 ) -> Vec<Action> {
+    let invalid_last_used_count = last_used
+        .iter()
+        .filter(|model| has_invalid_new_chat_model_info(model))
+        .count();
+    if invalid_last_used_count > 0 {
+        tracing::warn!(
+            target: "script_kit::actions",
+            builder = "notes_new_chat",
+            invalid_last_used_count,
+            "Invalid last-used chat model input; returning empty actions"
+        );
+        return vec![];
+    }
+
+    let invalid_preset_count = presets
+        .iter()
+        .filter(|preset| has_invalid_new_chat_preset_info(preset))
+        .count();
+    if invalid_preset_count > 0 {
+        tracing::warn!(
+            target: "script_kit::actions",
+            builder = "notes_new_chat",
+            invalid_preset_count,
+            "Invalid chat preset input; returning empty actions"
+        );
+        return vec![];
+    }
+
+    let invalid_model_count = models
+        .iter()
+        .filter(|model| has_invalid_new_chat_model_info(model))
+        .count();
+    if invalid_model_count > 0 {
+        tracing::warn!(
+            target: "script_kit::actions",
+            builder = "notes_new_chat",
+            invalid_model_count,
+            "Invalid chat model input; returning empty actions"
+        );
+        return vec![];
+    }
+
     let mut actions = Vec::new();
 
     for setting in last_used {
@@ -442,6 +573,21 @@
 
 /// Get actions for the note switcher dialog (Cmd+P in Notes window).
 pub fn get_note_switcher_actions(notes: &[NoteSwitcherNoteInfo]) -> Vec<Action> {
+    let invalid_note_count = notes
+        .iter()
+        .filter(|note| has_invalid_note_switcher_note_info(note))
+        .count();
+    if invalid_note_count > 0 {
+        tracing::warn!(
+            target: "script_kit::actions",
+            builder = "note_switcher",
+            note_count = notes.len(),
+            invalid_note_count,
+            "Invalid note switcher input; returning empty actions"
+        );
+        return vec![];
+    }
+
     let mut actions = Vec::new();
 
     for note in notes {
diff --git a/src/actions/builders/script_context.rs b/src/actions/builders/script_context.rs
index d48add6d0604e4fc8ab6bc1d9a9cdc328a6037ab..c09068069325e288d1c697a6ed9aa07944aadf61
--- a/src/actions/builders/script_context.rs
+++ b/src/actions/builders/script_context.rs
@@ -2,8 +2,23 @@
 use super::types::{Action, ActionCategory, ScriptInfo};
 use std::collections::HashSet;
 
+fn has_invalid_script_context_input(script: &ScriptInfo) -> bool {
+    script.name.trim().is_empty() || script.action_verb.trim().is_empty()
+}
+
 /// Get actions specific to the focused script.
 pub fn get_script_context_actions(script: &ScriptInfo) -> Vec<Action> {
+    if has_invalid_script_context_input(script) {
+        tracing::warn!(
+            target: "script_kit::actions",
+            builder = "script_context",
+            name = %script.name,
+            action_verb = %script.action_verb,
+            "Invalid script context input; returning empty actions"
+        );
+        return vec![];
+    }
+
     let mut actions = Vec::new();
     let mut destructive_actions = Vec::new();
 
@@ -314,3 +329,26 @@
 pub fn get_global_actions() -> Vec<Action> {
     vec![]
 }
+
+#[cfg(test)]
+mod tests {
+    use super::*;
+
+    #[test]
+    fn test_get_script_context_actions_returns_empty_when_name_is_blank() {
+        let mut script = ScriptInfo::new("Valid", "/tmp/valid.ts");
+        script.name = "   ".to_string();
+
+        let actions = get_script_context_actions(&script);
+        assert!(actions.is_empty());
+    }
+
+    #[test]
+    fn test_get_script_context_actions_returns_empty_when_action_verb_is_blank() {
+        let mut script = ScriptInfo::new("Valid", "/tmp/valid.ts");
+        script.action_verb = "   ".to_string();
+
+        let actions = get_script_context_actions(&script);
+        assert!(actions.is_empty());
+    }
+}


thinking
**Planning blocked status update**
exec
/bin/zsh -lc '~/.claude/bin/swarm.ts update --id codex-fix-builder-error-consistency-2 --status blocked --notes "waiting on claim for src/actions/builders/scriptlet.rs held by codex-fix-scriptlet-dedup"' in /Users/johnlindquist/dev/script-kit-gpui succeeded in 51ms:
Updated: codex-fix-builder-error-consistency-2
file update:
diff --git a/src/actions/builders/notes.rs b/src/actions/builders/notes.rs
index 48ba267e97bf2f3da7ecf1a3f78fea59dbc9acab..a2f0007d3327b005960130e6e30f524ceb6b3e9f
--- a/src/actions/builders/notes.rs
+++ b/src/actions/builders/notes.rs
@@ -27,6 +27,25 @@
     pub auto_sizing_enabled: bool,
 }
 
+fn is_blank(value: &str) -> bool {
+    value.trim().is_empty()
+}
+
+fn has_invalid_new_chat_model_info(model: &NewChatModelInfo) -> bool {
+    is_blank(&model.model_id)
+        || is_blank(&model.display_name)
+        || is_blank(&model.provider)
+        || is_blank(&model.provider_display_name)
+}
+
+fn has_invalid_new_chat_preset_info(preset: &NewChatPresetInfo) -> bool {
+    is_blank(&preset.id) || is_blank(&preset.name)
+}
+
+fn has_invalid_note_switcher_note_info(note: &NoteSwitcherNoteInfo) -> bool {
+    is_blank(&note.id) || is_blank(&note.title)
+}
+
 /// Get actions for the Notes window command bar (Cmd+K menu).
 pub fn get_notes_command_bar_actions(info: &NotesInfo) -> Vec<Action> {
     let mut actions = Vec::new();
@@ -367,6 +386,76 @@
             Some("Use Focused Writing preset")
         );
     }
+
+    #[test]
+    fn test_get_new_chat_actions_returns_empty_when_last_used_model_input_is_invalid() {
+        let last_used = vec![NewChatModelInfo {
+            model_id: "   ".to_string(),
+            display_name: "GPT-4o Mini".to_string(),
+            provider: "openai".to_string(),
+            provider_display_name: "OpenAI".to_string(),
+        }];
+        let presets = vec![NewChatPresetInfo {
+            id: "focused-writing".to_string(),
+            name: "Focused Writing".to_string(),
+            icon: IconName::Pencil,
+        }];
+
+        let actions = get_new_chat_actions(&last_used, &presets, &[]);
+        assert!(actions.is_empty());
+    }
+
+    #[test]
+    fn test_get_new_chat_actions_returns_empty_when_preset_input_is_invalid() {
+        let last_used = vec![NewChatModelInfo {
+            model_id: "gpt-4o-mini".to_string(),
+            display_name: "GPT-4o Mini".to_string(),
+            provider: "openai".to_string(),
+            provider_display_name: "OpenAI".to_string(),
+        }];
+        let presets = vec![NewChatPresetInfo {
+            id: "   ".to_string(),
+            name: "Focused Writing".to_string(),
+            icon: IconName::Pencil,
+        }];
+
+        let actions = get_new_chat_actions(&last_used, &presets, &[]);
+        assert!(actions.is_empty());
+    }
+
+    #[test]
+    fn test_get_new_chat_actions_returns_empty_when_model_input_is_invalid() {
+        let presets = vec![NewChatPresetInfo {
+            id: "focused-writing".to_string(),
+            name: "Focused Writing".to_string(),
+            icon: IconName::Pencil,
+        }];
+        let models = vec![NewChatModelInfo {
+            model_id: "claude-3-5-sonnet".to_string(),
+            display_name: "Claude 3.5 Sonnet".to_string(),
+            provider: "   ".to_string(),
+            provider_display_name: "Anthropic".to_string(),
+        }];
+
+        let actions = get_new_chat_actions(&[], &presets, &models);
+        assert!(actions.is_empty());
+    }
+
+    #[test]
+    fn test_get_note_switcher_actions_returns_empty_when_note_input_is_invalid() {
+        let notes = vec![NoteSwitcherNoteInfo {
+            id: "   ".to_string(),
+            title: "Missing ID".to_string(),
+            char_count: 5,
+            is_current: false,
+            is_pinned: false,
+            preview: "Preview".to_string(),
+            relative_time: "1m ago".to_string(),
+        }];
+
+        let actions = get_note_switcher_actions(&notes);
+        assert!(actions.is_empty());
+    }
 }
 
 /// Build actions for the AI new chat dropdown.
@@ -376,6 +465,48 @@
     presets: &[NewChatPresetInfo],
     models: &[NewChatModelInfo],
 ) -> Vec<Action> {
+    let invalid_last_used_count = last_used
+        .iter()
+        .filter(|model| has_invalid_new_chat_model_info(model))
+        .count();
+    if invalid_last_used_count > 0 {
+        tracing::warn!(
+            target: "script_kit::actions",
+            builder = "notes_new_chat",
+            invalid_last_used_count,
+            "Invalid last-used chat model input; returning empty actions"
+        );
+        return vec![];
+    }
+
+    let invalid_preset_count = presets
+        .iter()
+        .filter(|preset| has_invalid_new_chat_preset_info(preset))
+        .count();
+    if invalid_preset_count > 0 {
+        tracing::warn!(
+            target: "script_kit::actions",
+            builder = "notes_new_chat",
+            invalid_preset_count,
+            "Invalid chat preset input; returning empty actions"
+        );
+        return vec![];
+    }
+
+    let invalid_model_count = models
+        .iter()
+        .filter(|model| has_invalid_new_chat_model_info(model))
+        .count();
+    if invalid_model_count > 0 {
+        tracing::warn!(
+            target: "script_kit::actions",
+            builder = "notes_new_chat",
+            invalid_model_count,
+            "Invalid chat model input; returning empty actions"
+        );
+        return vec![];
+    }
+
     let mut actions = Vec::new();
 
     for setting in last_used {
@@ -442,6 +573,21 @@
 
 /// Get actions for the note switcher dialog (Cmd+P in Notes window).
 pub fn get_note_switcher_actions(notes: &[NoteSwitcherNoteInfo]) -> Vec<Action> {
+    let invalid_note_count = notes
+        .iter()
+        .filter(|note| has_invalid_note_switcher_note_info(note))
+        .count();
+    if invalid_note_count > 0 {
+        tracing::warn!(
+            target: "script_kit::actions",
+            builder = "note_switcher",
+            note_count = notes.len(),
+            invalid_note_count,
+            "Invalid note switcher input; returning empty actions"
+        );
+        return vec![];
+    }
+
     let mut actions = Vec::new();
 
     for note in notes {
diff --git a/src/actions/builders/script_context.rs b/src/actions/builders/script_context.rs
index d48add6d0604e4fc8ab6bc1d9a9cdc328a6037ab..c09068069325e288d1c697a6ed9aa07944aadf61
--- a/src/actions/builders/script_context.rs
+++ b/src/actions/builders/script_context.rs
@@ -2,8 +2,23 @@
 use super::types::{Action, ActionCategory, ScriptInfo};
 use std::collections::HashSet;
 
+fn has_invalid_script_context_input(script: &ScriptInfo) -> bool {
+    script.name.trim().is_empty() || script.action_verb.trim().is_empty()
+}
+
 /// Get actions specific to the focused script.
 pub fn get_script_context_actions(script: &ScriptInfo) -> Vec<Action> {
+    if has_invalid_script_context_input(script) {
+        tracing::warn!(
+            target: "script_kit::actions",
+            builder = "script_context",
+            name = %script.name,
+            action_verb = %script.action_verb,
+            "Invalid script context input; returning empty actions"
+        );
+        return vec![];
+    }
+
     let mut actions = Vec::new();
     let mut destructive_actions = Vec::new();
 
@@ -314,3 +329,26 @@
 pub fn get_global_actions() -> Vec<Action> {
     vec![]
 }
+
+#[cfg(test)]
+mod tests {
+    use super::*;
+
+    #[test]
+    fn test_get_script_context_actions_returns_empty_when_name_is_blank() {
+        let mut script = ScriptInfo::new("Valid", "/tmp/valid.ts");
+        script.name = "   ".to_string();
+
+        let actions = get_script_context_actions(&script);
+        assert!(actions.is_empty());
+    }
+
+    #[test]
+    fn test_get_script_context_actions_returns_empty_when_action_verb_is_blank() {
+        let mut script = ScriptInfo::new("Valid", "/tmp/valid.ts");
+        script.action_verb = "   ".to_string();
+
+        let actions = get_script_context_actions(&script);
+        assert!(actions.is_empty());
+    }
+}


thinking
**Continuing claim session polling**
file update:
diff --git a/src/actions/builders/notes.rs b/src/actions/builders/notes.rs
index 48ba267e97bf2f3da7ecf1a3f78fea59dbc9acab..a2f0007d3327b005960130e6e30f524ceb6b3e9f
--- a/src/actions/builders/notes.rs
+++ b/src/actions/builders/notes.rs
@@ -27,6 +27,25 @@
     pub auto_sizing_enabled: bool,
 }
 
+fn is_blank(value: &str) -> bool {
+    value.trim().is_empty()
+}
+
+fn has_invalid_new_chat_model_info(model: &NewChatModelInfo) -> bool {
+    is_blank(&model.model_id)
+        || is_blank(&model.display_name)
+        || is_blank(&model.provider)
+        || is_blank(&model.provider_display_name)
+}
+
+fn has_invalid_new_chat_preset_info(preset: &NewChatPresetInfo) -> bool {
+    is_blank(&preset.id) || is_blank(&preset.name)
+}
+
+fn has_invalid_note_switcher_note_info(note: &NoteSwitcherNoteInfo) -> bool {
+    is_blank(&note.id) || is_blank(&note.title)
+}
+
 /// Get actions for the Notes window command bar (Cmd+K menu).
 pub fn get_notes_command_bar_actions(info: &NotesInfo) -> Vec<Action> {
     let mut actions = Vec::new();
@@ -367,6 +386,76 @@
             Some("Use Focused Writing preset")
         );
     }
+
+    #[test]
+    fn test_get_new_chat_actions_returns_empty_when_last_used_model_input_is_invalid() {
+        let last_used = vec![NewChatModelInfo {
+            model_id: "   ".to_string(),
+            display_name: "GPT-4o Mini".to_string(),
+            provider: "openai".to_string(),
+            provider_display_name: "OpenAI".to_string(),
+        }];
+        let presets = vec![NewChatPresetInfo {
+            id: "focused-writing".to_string(),
+            name: "Focused Writing".to_string(),
+            icon: IconName::Pencil,
+        }];
+
+        let actions = get_new_chat_actions(&last_used, &presets, &[]);
+        assert!(actions.is_empty());
+    }
+
+    #[test]
+    fn test_get_new_chat_actions_returns_empty_when_preset_input_is_invalid() {
+        let last_used = vec![NewChatModelInfo {
+            model_id: "gpt-4o-mini".to_string(),
+            display_name: "GPT-4o Mini".to_string(),
+            provider: "openai".to_string(),
+            provider_display_name: "OpenAI".to_string(),
+        }];
+        let presets = vec![NewChatPresetInfo {
+            id: "   ".to_string(),
+            name: "Focused Writing".to_string(),
+            icon: IconName::Pencil,
+        }];
+
+        let actions = get_new_chat_actions(&last_used, &presets, &[]);
+        assert!(actions.is_empty());
+    }
+
+    #[test]
+    fn test_get_new_chat_actions_returns_empty_when_model_input_is_invalid() {
+        let presets = vec![NewChatPresetInfo {
+            id: "focused-writing".to_string(),
+            name: "Focused Writing".to_string(),
+            icon: IconName::Pencil,
+        }];
+        let models = vec![NewChatModelInfo {
+            model_id: "claude-3-5-sonnet".to_string(),
+            display_name: "Claude 3.5 Sonnet".to_string(),
+            provider: "   ".to_string(),
+            provider_display_name: "Anthropic".to_string(),
+        }];
+
+        let actions = get_new_chat_actions(&[], &presets, &models);
+        assert!(actions.is_empty());
+    }
+
+    #[test]
+    fn test_get_note_switcher_actions_returns_empty_when_note_input_is_invalid() {
+        let notes = vec![NoteSwitcherNoteInfo {
+            id: "   ".to_string(),
+            title: "Missing ID".to_string(),
+            char_count: 5,
+            is_current: false,
+            is_pinned: false,
+            preview: "Preview".to_string(),
+            relative_time: "1m ago".to_string(),
+        }];
+
+        let actions = get_note_switcher_actions(&notes);
+        assert!(actions.is_empty());
+    }
 }
 
 /// Build actions for the AI new chat dropdown.
@@ -376,6 +465,48 @@
     presets: &[NewChatPresetInfo],
     models: &[NewChatModelInfo],
 ) -> Vec<Action> {
+    let invalid_last_used_count = last_used
+        .iter()
+        .filter(|model| has_invalid_new_chat_model_info(model))
+        .count();
+    if invalid_last_used_count > 0 {
+        tracing::warn!(
+            target: "script_kit::actions",
+            builder = "notes_new_chat",
+            invalid_last_used_count,
+            "Invalid last-used chat model input; returning empty actions"
+        );
+        return vec![];
+    }
+
+    let invalid_preset_count = presets
+        .iter()
+        .filter(|preset| has_invalid_new_chat_preset_info(preset))
+        .count();
+    if invalid_preset_count > 0 {
+        tracing::warn!(
+            target: "script_kit::actions",
+            builder = "notes_new_chat",
+            invalid_preset_count,
+            "Invalid chat preset input; returning empty actions"
+        );
+        return vec![];
+    }
+
+    let invalid_model_count = models
+        .iter()
+        .filter(|model| has_invalid_new_chat_model_info(model))
+        .count();
+    if invalid_model_count > 0 {
+        tracing::warn!(
+            target: "script_kit::actions",
+            builder = "notes_new_chat",
+            invalid_model_count,
+            "Invalid chat model input; returning empty actions"
+        );
+        return vec![];
+    }
+
     let mut actions = Vec::new();
 
     for setting in last_used {
@@ -442,6 +573,21 @@
 
 /// Get actions for the note switcher dialog (Cmd+P in Notes window).
 pub fn get_note_switcher_actions(notes: &[NoteSwitcherNoteInfo]) -> Vec<Action> {
+    let invalid_note_count = notes
+        .iter()
+        .filter(|note| has_invalid_note_switcher_note_info(note))
+        .count();
+    if invalid_note_count > 0 {
+        tracing::warn!(
+            target: "script_kit::actions",
+            builder = "note_switcher",
+            note_count = notes.len(),
+            invalid_note_count,
+            "Invalid note switcher input; returning empty actions"
+        );
+        return vec![];
+    }
+
     let mut actions = Vec::new();
 
     for note in notes {
diff --git a/src/actions/builders/script_context.rs b/src/actions/builders/script_context.rs
index d48add6d0604e4fc8ab6bc1d9a9cdc328a6037ab..c09068069325e288d1c697a6ed9aa07944aadf61
--- a/src/actions/builders/script_context.rs
+++ b/src/actions/builders/script_context.rs
@@ -2,8 +2,23 @@
 use super::types::{Action, ActionCategory, ScriptInfo};
 use std::collections::HashSet;
 
+fn has_invalid_script_context_input(script: &ScriptInfo) -> bool {
+    script.name.trim().is_empty() || script.action_verb.trim().is_empty()
+}
+
 /// Get actions specific to the focused script.
 pub fn get_script_context_actions(script: &ScriptInfo) -> Vec<Action> {
+    if has_invalid_script_context_input(script) {
+        tracing::warn!(
+            target: "script_kit::actions",
+            builder = "script_context",
+            name = %script.name,
+            action_verb = %script.action_verb,
+            "Invalid script context input; returning empty actions"
+        );
+        return vec![];
+    }
+
     let mut actions = Vec::new();
     let mut destructive_actions = Vec::new();
 
@@ -314,3 +329,26 @@
 pub fn get_global_actions() -> Vec<Action> {
     vec![]
 }
+
+#[cfg(test)]
+mod tests {
+    use super::*;
+
+    #[test]
+    fn test_get_script_context_actions_returns_empty_when_name_is_blank() {
+        let mut script = ScriptInfo::new("Valid", "/tmp/valid.ts");
+        script.name = "   ".to_string();
+
+        let actions = get_script_context_actions(&script);
+        assert!(actions.is_empty());
+    }
+
+    #[test]
+    fn test_get_script_context_actions_returns_empty_when_action_verb_is_blank() {
+        let mut script = ScriptInfo::new("Valid", "/tmp/valid.ts");
+        script.action_verb = "   ".to_string();
+
+        let actions = get_script_context_actions(&script);
+        assert!(actions.is_empty());
+    }
+}

file update:
diff --git a/src/actions/builders/notes.rs b/src/actions/builders/notes.rs
index 48ba267e97bf2f3da7ecf1a3f78fea59dbc9acab..a2f0007d3327b005960130e6e30f524ceb6b3e9f
--- a/src/actions/builders/notes.rs
+++ b/src/actions/builders/notes.rs
@@ -27,6 +27,25 @@
     pub auto_sizing_enabled: bool,
 }
 
+fn is_blank(value: &str) -> bool {
+    value.trim().is_empty()
+}
+
+fn has_invalid_new_chat_model_info(model: &NewChatModelInfo) -> bool {
+    is_blank(&model.model_id)
+        || is_blank(&model.display_name)
+        || is_blank(&model.provider)
+        || is_blank(&model.provider_display_name)
+}
+
+fn has_invalid_new_chat_preset_info(preset: &NewChatPresetInfo) -> bool {
+    is_blank(&preset.id) || is_blank(&preset.name)
+}
+
+fn has_invalid_note_switcher_note_info(note: &NoteSwitcherNoteInfo) -> bool {
+    is_blank(&note.id) || is_blank(&note.title)
+}
+
 /// Get actions for the Notes window command bar (Cmd+K menu).
 pub fn get_notes_command_bar_actions(info: &NotesInfo) -> Vec<Action> {
     let mut actions = Vec::new();
@@ -367,6 +386,76 @@
             Some("Use Focused Writing preset")
         );
     }
+
+    #[test]
+    fn test_get_new_chat_actions_returns_empty_when_last_used_model_input_is_invalid() {
+        let last_used = vec![NewChatModelInfo {
+            model_id: "   ".to_string(),
+            display_name: "GPT-4o Mini".to_string(),
+            provider: "openai".to_string(),
+            provider_display_name: "OpenAI".to_string(),
+        }];
+        let presets = vec![NewChatPresetInfo {
+            id: "focused-writing".to_string(),
+            name: "Focused Writing".to_string(),
+            icon: IconName::Pencil,
+        }];
+
+        let actions = get_new_chat_actions(&last_used, &presets, &[]);
+        assert!(actions.is_empty());
+    }
+
+    #[test]
+    fn test_get_new_chat_actions_returns_empty_when_preset_input_is_invalid() {
+        let last_used = vec![NewChatModelInfo {
+            model_id: "gpt-4o-mini".to_string(),
+            display_name: "GPT-4o Mini".to_string(),
+            provider: "openai".to_string(),
+            provider_display_name: "OpenAI".to_string(),
+        }];
+        let presets = vec![NewChatPresetInfo {
+            id: "   ".to_string(),
+            name: "Focused Writing".to_string(),
+            icon: IconName::Pencil,
+        }];
+
+        let actions = get_new_chat_actions(&last_used, &presets, &[]);
+        assert!(actions.is_empty());
+    }
+
+    #[test]
+    fn test_get_new_chat_actions_returns_empty_when_model_input_is_invalid() {
+        let presets = vec![NewChatPresetInfo {
+            id: "focused-writing".to_string(),
+            name: "Focused Writing".to_string(),
+            icon: IconName::Pencil,
+        }];
+        let models = vec![NewChatModelInfo {
+            model_id: "claude-3-5-sonnet".to_string(),
+            display_name: "Claude 3.5 Sonnet".to_string(),
+            provider: "   ".to_string(),
+            provider_display_name: "Anthropic".to_string(),
+        }];
+
+        let actions = get_new_chat_actions(&[], &presets, &models);
+        assert!(actions.is_empty());
+    }
+
+    #[test]
+    fn test_get_note_switcher_actions_returns_empty_when_note_input_is_invalid() {
+        let notes = vec![NoteSwitcherNoteInfo {
+            id: "   ".to_string(),
+            title: "Missing ID".to_string(),
+            char_count: 5,
+            is_current: false,
+            is_pinned: false,
+            preview: "Preview".to_string(),
+            relative_time: "1m ago".to_string(),
+        }];
+
+        let actions = get_note_switcher_actions(&notes);
+        assert!(actions.is_empty());
+    }
 }
 
 /// Build actions for the AI new chat dropdown.
@@ -376,6 +465,48 @@
     presets: &[NewChatPresetInfo],
     models: &[NewChatModelInfo],
 ) -> Vec<Action> {
+    let invalid_last_used_count = last_used
+        .iter()
+        .filter(|model| has_invalid_new_chat_model_info(model))
+        .count();
+    if invalid_last_used_count > 0 {
+        tracing::warn!(
+            target: "script_kit::actions",
+            builder = "notes_new_chat",
+            invalid_last_used_count,
+            "Invalid last-used chat model input; returning empty actions"
+        );
+        return vec![];
+    }
+
+    let invalid_preset_count = presets
+        .iter()
+        .filter(|preset| has_invalid_new_chat_preset_info(preset))
+        .count();
+    if invalid_preset_count > 0 {
+        tracing::warn!(
+            target: "script_kit::actions",
+            builder = "notes_new_chat",
+            invalid_preset_count,
+            "Invalid chat preset input; returning empty actions"
+        );
+        return vec![];
+    }
+
+    let invalid_model_count = models
+        .iter()
+        .filter(|model| has_invalid_new_chat_model_info(model))
+        .count();
+    if invalid_model_count > 0 {
+        tracing::warn!(
+            target: "script_kit::actions",
+            builder = "notes_new_chat",
+            invalid_model_count,
+            "Invalid chat model input; returning empty actions"
+        );
+        return vec![];
+    }
+
     let mut actions = Vec::new();
 
     for setting in last_used {
@@ -442,6 +573,21 @@
 
 /// Get actions for the note switcher dialog (Cmd+P in Notes window).
 pub fn get_note_switcher_actions(notes: &[NoteSwitcherNoteInfo]) -> Vec<Action> {
+    let invalid_note_count = notes
+        .iter()
+        .filter(|note| has_invalid_note_switcher_note_info(note))
+        .count();
+    if invalid_note_count > 0 {
+        tracing::warn!(
+            target: "script_kit::actions",
+            builder = "note_switcher",
+            note_count = notes.len(),
+            invalid_note_count,
+            "Invalid note switcher input; returning empty actions"
+        );
+        return vec![];
+    }
+
     let mut actions = Vec::new();
 
     for note in notes {
diff --git a/src/actions/builders/script_context.rs b/src/actions/builders/script_context.rs
index d48add6d0604e4fc8ab6bc1d9a9cdc328a6037ab..c09068069325e288d1c697a6ed9aa07944aadf61
--- a/src/actions/builders/script_context.rs
+++ b/src/actions/builders/script_context.rs
@@ -2,8 +2,23 @@
 use super::types::{Action, ActionCategory, ScriptInfo};
 use std::collections::HashSet;
 
+fn has_invalid_script_context_input(script: &ScriptInfo) -> bool {
+    script.name.trim().is_empty() || script.action_verb.trim().is_empty()
+}
+
 /// Get actions specific to the focused script.
 pub fn get_script_context_actions(script: &ScriptInfo) -> Vec<Action> {
+    if has_invalid_script_context_input(script) {
+        tracing::warn!(
+            target: "script_kit::actions",
+            builder = "script_context",
+            name = %script.name,
+            action_verb = %script.action_verb,
+            "Invalid script context input; returning empty actions"
+        );
+        return vec![];
+    }
+
     let mut actions = Vec::new();
     let mut destructive_actions = Vec::new();
 
@@ -314,3 +329,26 @@
 pub fn get_global_actions() -> Vec<Action> {
     vec![]
 }
+
+#[cfg(test)]
+mod tests {
+    use super::*;
+
+    #[test]
+    fn test_get_script_context_actions_returns_empty_when_name_is_blank() {
+        let mut script = ScriptInfo::new("Valid", "/tmp/valid.ts");
+        script.name = "   ".to_string();
+
+        let actions = get_script_context_actions(&script);
+        assert!(actions.is_empty());
+    }
+
+    #[test]
+    fn test_get_script_context_actions_returns_empty_when_action_verb_is_blank() {
+        let mut script = ScriptInfo::new("Valid", "/tmp/valid.ts");
+        script.action_verb = "   ".to_string();
+
+        let actions = get_script_context_actions(&script);
+        assert!(actions.is_empty());
+    }
+}

codex
Still waiting on `scriptlet.rs` lock; I’ve marked this agent as blocked in swarm and I’m continuing to poll until the other agent releases the file.
file update:
diff --git a/src/actions/builders/notes.rs b/src/actions/builders/notes.rs
index 48ba267e97bf2f3da7ecf1a3f78fea59dbc9acab..a2f0007d3327b005960130e6e30f524ceb6b3e9f
--- a/src/actions/builders/notes.rs
+++ b/src/actions/builders/notes.rs
@@ -27,6 +27,25 @@
     pub auto_sizing_enabled: bool,
 }
 
+fn is_blank(value: &str) -> bool {
+    value.trim().is_empty()
+}
+
+fn has_invalid_new_chat_model_info(model: &NewChatModelInfo) -> bool {
+    is_blank(&model.model_id)
+        || is_blank(&model.display_name)
+        || is_blank(&model.provider)
+        || is_blank(&model.provider_display_name)
+}
+
+fn has_invalid_new_chat_preset_info(preset: &NewChatPresetInfo) -> bool {
+    is_blank(&preset.id) || is_blank(&preset.name)
+}
+
+fn has_invalid_note_switcher_note_info(note: &NoteSwitcherNoteInfo) -> bool {
+    is_blank(&note.id) || is_blank(&note.title)
+}
+
 /// Get actions for the Notes window command bar (Cmd+K menu).
 pub fn get_notes_command_bar_actions(info: &NotesInfo) -> Vec<Action> {
     let mut actions = Vec::new();
@@ -367,6 +386,76 @@
             Some("Use Focused Writing preset")
         );
     }
+
+    #[test]
+    fn test_get_new_chat_actions_returns_empty_when_last_used_model_input_is_invalid() {
+        let last_used = vec![NewChatModelInfo {
+            model_id: "   ".to_string(),
+            display_name: "GPT-4o Mini".to_string(),
+            provider: "openai".to_string(),
+            provider_display_name: "OpenAI".to_string(),
+        }];
+        let presets = vec![NewChatPresetInfo {
+            id: "focused-writing".to_string(),
+            name: "Focused Writing".to_string(),
+            icon: IconName::Pencil,
+        }];
+
+        let actions = get_new_chat_actions(&last_used, &presets, &[]);
+        assert!(actions.is_empty());
+    }
+
+    #[test]
+    fn test_get_new_chat_actions_returns_empty_when_preset_input_is_invalid() {
+        let last_used = vec![NewChatModelInfo {
+            model_id: "gpt-4o-mini".to_string(),
+            display_name: "GPT-4o Mini".to_string(),
+            provider: "openai".to_string(),
+            provider_display_name: "OpenAI".to_string(),
+        }];
+        let presets = vec![NewChatPresetInfo {
+            id: "   ".to_string(),
+            name: "Focused Writing".to_string(),
+            icon: IconName::Pencil,
+        }];
+
+        let actions = get_new_chat_actions(&last_used, &presets, &[]);
+        assert!(actions.is_empty());
+    }
+
+    #[test]
+    fn test_get_new_chat_actions_returns_empty_when_model_input_is_invalid() {
+        let presets = vec![NewChatPresetInfo {
+            id: "focused-writing".to_string(),
+            name: "Focused Writing".to_string(),
+            icon: IconName::Pencil,
+        }];
+        let models = vec![NewChatModelInfo {
+            model_id: "claude-3-5-sonnet".to_string(),
+            display_name: "Claude 3.5 Sonnet".to_string(),
+            provider: "   ".to_string(),
+            provider_display_name: "Anthropic".to_string(),
+        }];
+
+        let actions = get_new_chat_actions(&[], &presets, &models);
+        assert!(actions.is_empty());
+    }
+
+    #[test]
+    fn test_get_note_switcher_actions_returns_empty_when_note_input_is_invalid() {
+        let notes = vec![NoteSwitcherNoteInfo {
+            id: "   ".to_string(),
+            title: "Missing ID".to_string(),
+            char_count: 5,
+            is_current: false,
+            is_pinned: false,
+            preview: "Preview".to_string(),
+            relative_time: "1m ago".to_string(),
+        }];
+
+        let actions = get_note_switcher_actions(&notes);
+        assert!(actions.is_empty());
+    }
 }
 
 /// Build actions for the AI new chat dropdown.
@@ -376,6 +465,48 @@
     presets: &[NewChatPresetInfo],
     models: &[NewChatModelInfo],
 ) -> Vec<Action> {
+    let invalid_last_used_count = last_used
+        .iter()
+        .filter(|model| has_invalid_new_chat_model_info(model))
+        .count();
+    if invalid_last_used_count > 0 {
+        tracing::warn!(
+            target: "script_kit::actions",
+            builder = "notes_new_chat",
+            invalid_last_used_count,
+            "Invalid last-used chat model input; returning empty actions"
+        );
+        return vec![];
+    }
+
+    let invalid_preset_count = presets
+        .iter()
+        .filter(|preset| has_invalid_new_chat_preset_info(preset))
+        .count();
+    if invalid_preset_count > 0 {
+        tracing::warn!(
+            target: "script_kit::actions",
+            builder = "notes_new_chat",
+            invalid_preset_count,
+            "Invalid chat preset input; returning empty actions"
+        );
+        return vec![];
+    }
+
+    let invalid_model_count = models
+        .iter()
+        .filter(|model| has_invalid_new_chat_model_info(model))
+        .count();
+    if invalid_model_count > 0 {
+        tracing::warn!(
+            target: "script_kit::actions",
+            builder = "notes_new_chat",
+            invalid_model_count,
+            "Invalid chat model input; returning empty actions"
+        );
+        return vec![];
+    }
+
     let mut actions = Vec::new();
 
     for setting in last_used {
@@ -442,6 +573,21 @@
 
 /// Get actions for the note switcher dialog (Cmd+P in Notes window).
 pub fn get_note_switcher_actions(notes: &[NoteSwitcherNoteInfo]) -> Vec<Action> {
+    let invalid_note_count = notes
+        .iter()
+        .filter(|note| has_invalid_note_switcher_note_info(note))
+        .count();
+    if invalid_note_count > 0 {
+        tracing::warn!(
+            target: "script_kit::actions",
+            builder = "note_switcher",
+            note_count = notes.len(),
+            invalid_note_count,
+            "Invalid note switcher input; returning empty actions"
+        );
+        return vec![];
+    }
+
     let mut actions = Vec::new();
 
     for note in notes {
diff --git a/src/actions/builders/script_context.rs b/src/actions/builders/script_context.rs
index d48add6d0604e4fc8ab6bc1d9a9cdc328a6037ab..c09068069325e288d1c697a6ed9aa07944aadf61
--- a/src/actions/builders/script_context.rs
+++ b/src/actions/builders/script_context.rs
@@ -2,8 +2,23 @@
 use super::types::{Action, ActionCategory, ScriptInfo};
 use std::collections::HashSet;
 
+fn has_invalid_script_context_input(script: &ScriptInfo) -> bool {
+    script.name.trim().is_empty() || script.action_verb.trim().is_empty()
+}
+
 /// Get actions specific to the focused script.
 pub fn get_script_context_actions(script: &ScriptInfo) -> Vec<Action> {
+    if has_invalid_script_context_input(script) {
+        tracing::warn!(
+            target: "script_kit::actions",
+            builder = "script_context",
+            name = %script.name,
+            action_verb = %script.action_verb,
+            "Invalid script context input; returning empty actions"
+        );
+        return vec![];
+    }
+
     let mut actions = Vec::new();
     let mut destructive_actions = Vec::new();
 
@@ -314,3 +329,26 @@
 pub fn get_global_actions() -> Vec<Action> {
     vec![]
 }
+
+#[cfg(test)]
+mod tests {
+    use super::*;
+
+    #[test]
+    fn test_get_script_context_actions_returns_empty_when_name_is_blank() {
+        let mut script = ScriptInfo::new("Valid", "/tmp/valid.ts");
+        script.name = "   ".to_string();
+
+        let actions = get_script_context_actions(&script);
+        assert!(actions.is_empty());
+    }
+
+    #[test]
+    fn test_get_script_context_actions_returns_empty_when_action_verb_is_blank() {
+        let mut script = ScriptInfo::new("Valid", "/tmp/valid.ts");
+        script.action_verb = "   ".to_string();
+
+        let actions = get_script_context_actions(&script);
+        assert!(actions.is_empty());
+    }
+}


thinking
**Considering separate status polling**
exec
/bin/zsh -lc "~/.claude/bin/swarm.ts status | sed -n '1,120p'" in /Users/johnlindquist/dev/script-kit-gpui succeeded in 52ms:
Repo: /Users/johnlindquist/dev/script-kit-gpui
Updated: 2026-02-08T00:21:11.376Z

Active agents (4):
codex-fix-builder-error-consistency [in_progress] codex/gpt-5.3-codex/exec
  task: CONSISTENCY FIX: Make error handling consistent across all action builders. Currently some builders silently return emp…
  scope: src/actions/builders/chat.rs,src/actions/builders/clipboard.rs,src/actions/builders/file_path.rs
  claims(3): src/actions/builders/chat.rs, src/actions/builders/clipboard.rs, src/actions/builders/file_path.rs
  notes: claimed chat/clipboard/file_path; auditing for invalid input handling, unwrap/panic elimination, and consistent warn-level logging | [claim-wait] codex-fix… | [claim-wait] codex-f…

codex-fix-builder-error-consistency-2 [blocked] codex/gpt-5.3-codex/exec
  task: CONSISTENCY FIX: Make error handling consistent across action builders part 2. Ensure builders in src/actions/builders/…
  scope: src/actions/builders/notes.rs,src/actions/builders/script_context.rs,src/actions/builders/scriptlet.rs
  claims(2): src/actions/builders/notes.rs, src/actions/builders/script_context.rs
  notes: waiting on claim for src/actions/builders/scriptlet.rs held by codex-fix-scriptlet-dedup

codex-fix-description-style [in_progress] codex/gpt-5.3-codex/exec
  task: CONSISTENCY FIX: Make action descriptions consistent in style across all builders. All descriptions should: (1) Start w…
  scope: src/actions/builders/chat.rs,src/actions/builders/clipboard.rs,src/actions/builders/file_path.rs,src/actions/builders/n…
  claims: (none)
file update:
diff --git a/src/actions/builders/notes.rs b/src/actions/builders/notes.rs
index 48ba267e97bf2f3da7ecf1a3f78fea59dbc9acab..a2f0007d3327b005960130e6e30f524ceb6b3e9f
--- a/src/actions/builders/notes.rs
+++ b/src/actions/builders/notes.rs
@@ -27,6 +27,25 @@
     pub auto_sizing_enabled: bool,
 }
 
+fn is_blank(value: &str) -> bool {
+    value.trim().is_empty()
+}
+
+fn has_invalid_new_chat_model_info(model: &NewChatModelInfo) -> bool {
+    is_blank(&model.model_id)
+        || is_blank(&model.display_name)
+        || is_blank(&model.provider)
+        || is_blank(&model.provider_display_name)
+}
+
+fn has_invalid_new_chat_preset_info(preset: &NewChatPresetInfo) -> bool {
+    is_blank(&preset.id) || is_blank(&preset.name)
+}
+
+fn has_invalid_note_switcher_note_info(note: &NoteSwitcherNoteInfo) -> bool {
+    is_blank(&note.id) || is_blank(&note.title)
+}
+
 /// Get actions for the Notes window command bar (Cmd+K menu).
 pub fn get_notes_command_bar_actions(info: &NotesInfo) -> Vec<Action> {
     let mut actions = Vec::new();
@@ -367,6 +386,76 @@
             Some("Use Focused Writing preset")
         );
     }
+
+    #[test]
+    fn test_get_new_chat_actions_returns_empty_when_last_used_model_input_is_invalid() {
+        let last_used = vec![NewChatModelInfo {
+            model_id: "   ".to_string(),
+            display_name: "GPT-4o Mini".to_string(),
+            provider: "openai".to_string(),
+            provider_display_name: "OpenAI".to_string(),
+        }];
+        let presets = vec![NewChatPresetInfo {
+            id: "focused-writing".to_string(),
+            name: "Focused Writing".to_string(),
+            icon: IconName::Pencil,
+        }];
+
+        let actions = get_new_chat_actions(&last_used, &presets, &[]);
+        assert!(actions.is_empty());
+    }
+
+    #[test]
+    fn test_get_new_chat_actions_returns_empty_when_preset_input_is_invalid() {
+        let last_used = vec![NewChatModelInfo {
+            model_id: "gpt-4o-mini".to_string(),
+            display_name: "GPT-4o Mini".to_string(),
+            provider: "openai".to_string(),
+            provider_display_name: "OpenAI".to_string(),
+        }];
+        let presets = vec![NewChatPresetInfo {
+            id: "   ".to_string(),
+            name: "Focused Writing".to_string(),
+            icon: IconName::Pencil,
+        }];
+
+        let actions = get_new_chat_actions(&last_used, &presets, &[]);
+        assert!(actions.is_empty());
+    }
+
+    #[test]
+    fn test_get_new_chat_actions_returns_empty_when_model_input_is_invalid() {
+        let presets = vec![NewChatPresetInfo {
+            id: "focused-writing".to_string(),
+            name: "Focused Writing".to_string(),
+            icon: IconName::Pencil,
+        }];
+        let models = vec![NewChatModelInfo {
+            model_id: "claude-3-5-sonnet".to_string(),
+            display_name: "Claude 3.5 Sonnet".to_string(),
+            provider: "   ".to_string(),
+            provider_display_name: "Anthropic".to_string(),
+        }];
+
+        let actions = get_new_chat_actions(&[], &presets, &models);
+        assert!(actions.is_empty());
+    }
+
+    #[test]
+    fn test_get_note_switcher_actions_returns_empty_when_note_input_is_invalid() {
+        let notes = vec![NoteSwitcherNoteInfo {
+            id: "   ".to_string(),
+            title: "Missing ID".to_string(),
+            char_count: 5,
+            is_current: false,
+            is_pinned: false,
+            preview: "Preview".to_string(),
+            relative_time: "1m ago".to_string(),
+        }];
+
+        let actions = get_note_switcher_actions(&notes);
+        assert!(actions.is_empty());
+    }
 }
 
 /// Build actions for the AI new chat dropdown.
@@ -376,6 +465,48 @@
     presets: &[NewChatPresetInfo],
     models: &[NewChatModelInfo],
 ) -> Vec<Action> {
+    let invalid_last_used_count = last_used
+        .iter()
+        .filter(|model| has_invalid_new_chat_model_info(model))
+        .count();
+    if invalid_last_used_count > 0 {
+        tracing::warn!(
+            target: "script_kit::actions",
+            builder = "notes_new_chat",
+            invalid_last_used_count,
+            "Invalid last-used chat model input; returning empty actions"
+        );
+        return vec![];
+    }
+
+    let invalid_preset_count = presets
+        .iter()
+        .filter(|preset| has_invalid_new_chat_preset_info(preset))
+        .count();
+    if invalid_preset_count > 0 {
+        tracing::warn!(
+            target: "script_kit::actions",
+            builder = "notes_new_chat",
+            invalid_preset_count,
+            "Invalid chat preset input; returning empty actions"
+        );
+        return vec![];
+    }
+
+    let invalid_model_count = models
+        .iter()
+        .filter(|model| has_invalid_new_chat_model_info(model))
+        .count();
+    if invalid_model_count > 0 {
+        tracing::warn!(
+            target: "script_kit::actions",
+            builder = "notes_new_chat",
+            invalid_model_count,
+            "Invalid chat model input; returning empty actions"
+        );
+        return vec![];
+    }
+
     let mut actions = Vec::new();
 
     for setting in last_used {
@@ -442,6 +573,21 @@
 
 /// Get actions for the note switcher dialog (Cmd+P in Notes window).
 pub fn get_note_switcher_actions(notes: &[NoteSwitcherNoteInfo]) -> Vec<Action> {
+    let invalid_note_count = notes
+        .iter()
+        .filter(|note| has_invalid_note_switcher_note_info(note))
+        .count();
+    if invalid_note_count > 0 {
+        tracing::warn!(
+            target: "script_kit::actions",
+            builder = "note_switcher",
+            note_count = notes.len(),
+            invalid_note_count,
+            "Invalid note switcher input; returning empty actions"
+        );
+        return vec![];
+    }
+
     let mut actions = Vec::new();
 
     for note in notes {
diff --git a/src/actions/builders/script_context.rs b/src/actions/builders/script_context.rs
index d48add6d0604e4fc8ab6bc1d9a9cdc328a6037ab..c09068069325e288d1c697a6ed9aa07944aadf61
--- a/src/actions/builders/script_context.rs
+++ b/src/actions/builders/script_context.rs
@@ -2,8 +2,23 @@
 use super::types::{Action, ActionCategory, ScriptInfo};
 use std::collections::HashSet;
 
+fn has_invalid_script_context_input(script: &ScriptInfo) -> bool {
+    script.name.trim().is_empty() || script.action_verb.trim().is_empty()
+}
+
 /// Get actions specific to the focused script.
 pub fn get_script_context_actions(script: &ScriptInfo) -> Vec<Action> {
+    if has_invalid_script_context_input(script) {
+        tracing::warn!(
+            target: "script_kit::actions",
+            builder = "script_context",
+            name = %script.name,
+            action_verb = %script.action_verb,
+            "Invalid script context input; returning empty actions"
+        );
+        return vec![];
+    }
+
     let mut actions = Vec::new();
     let mut destructive_actions = Vec::new();
 
@@ -314,3 +329,26 @@
 pub fn get_global_actions() -> Vec<Action> {
     vec![]
 }
+
+#[cfg(test)]
+mod tests {
+    use super::*;
+
+    #[test]
+    fn test_get_script_context_actions_returns_empty_when_name_is_blank() {
+        let mut script = ScriptInfo::new("Valid", "/tmp/valid.ts");
+        script.name = "   ".to_string();
+
+        let actions = get_script_context_actions(&script);
+        assert!(actions.is_empty());
+    }
+
+    #[test]
+    fn test_get_script_context_actions_returns_empty_when_action_verb_is_blank() {
+        let mut script = ScriptInfo::new("Valid", "/tmp/valid.ts");
+        script.action_verb = "   ".to_string();
+
+        let actions = get_script_context_actions(&script);
+        assert!(actions.is_empty());
+    }
+}


thinking
**Waiting on claim acquisition**
file update:
diff --git a/src/actions/builders/notes.rs b/src/actions/builders/notes.rs
index 48ba267e97bf2f3da7ecf1a3f78fea59dbc9acab..a2f0007d3327b005960130e6e30f524ceb6b3e9f
--- a/src/actions/builders/notes.rs
+++ b/src/actions/builders/notes.rs
@@ -27,6 +27,25 @@
     pub auto_sizing_enabled: bool,
 }
 
+fn is_blank(value: &str) -> bool {
+    value.trim().is_empty()
+}
+
+fn has_invalid_new_chat_model_info(model: &NewChatModelInfo) -> bool {
+    is_blank(&model.model_id)
+        || is_blank(&model.display_name)
+        || is_blank(&model.provider)
+        || is_blank(&model.provider_display_name)
+}
+
+fn has_invalid_new_chat_preset_info(preset: &NewChatPresetInfo) -> bool {
+    is_blank(&preset.id) || is_blank(&preset.name)
+}
+
+fn has_invalid_note_switcher_note_info(note: &NoteSwitcherNoteInfo) -> bool {
+    is_blank(&note.id) || is_blank(&note.title)
+}
+
 /// Get actions for the Notes window command bar (Cmd+K menu).
 pub fn get_notes_command_bar_actions(info: &NotesInfo) -> Vec<Action> {
     let mut actions = Vec::new();
@@ -367,6 +386,76 @@
             Some("Use Focused Writing preset")
         );
     }
+
+    #[test]
+    fn test_get_new_chat_actions_returns_empty_when_last_used_model_input_is_invalid() {
+        let last_used = vec![NewChatModelInfo {
+            model_id: "   ".to_string(),
+            display_name: "GPT-4o Mini".to_string(),
+            provider: "openai".to_string(),
+            provider_display_name: "OpenAI".to_string(),
+        }];
+        let presets = vec![NewChatPresetInfo {
+            id: "focused-writing".to_string(),
+            name: "Focused Writing".to_string(),
+            icon: IconName::Pencil,
+        }];
+
+        let actions = get_new_chat_actions(&last_used, &presets, &[]);
+        assert!(actions.is_empty());
+    }
+
+    #[test]
+    fn test_get_new_chat_actions_returns_empty_when_preset_input_is_invalid() {
+        let last_used = vec![NewChatModelInfo {
+            model_id: "gpt-4o-mini".to_string(),
+            display_name: "GPT-4o Mini".to_string(),
+            provider: "openai".to_string(),
+            provider_display_name: "OpenAI".to_string(),
+        }];
+        let presets = vec![NewChatPresetInfo {
+            id: "   ".to_string(),
+            name: "Focused Writing".to_string(),
+            icon: IconName::Pencil,
+        }];
+
+        let actions = get_new_chat_actions(&last_used, &presets, &[]);
+        assert!(actions.is_empty());
+    }
+
+    #[test]
+    fn test_get_new_chat_actions_returns_empty_when_model_input_is_invalid() {
+        let presets = vec![NewChatPresetInfo {
+            id: "focused-writing".to_string(),
+            name: "Focused Writing".to_string(),
+            icon: IconName::Pencil,
+        }];
+        let models = vec![NewChatModelInfo {
+            model_id: "claude-3-5-sonnet".to_string(),
+            display_name: "Claude 3.5 Sonnet".to_string(),
+            provider: "   ".to_string(),
+            provider_display_name: "Anthropic".to_string(),
+        }];
+
+        let actions = get_new_chat_actions(&[], &presets, &models);
+        assert!(actions.is_empty());
+    }
+
+    #[test]
+    fn test_get_note_switcher_actions_returns_empty_when_note_input_is_invalid() {
+        let notes = vec![NoteSwitcherNoteInfo {
+            id: "   ".to_string(),
+            title: "Missing ID".to_string(),
+            char_count: 5,
+            is_current: false,
+            is_pinned: false,
+            preview: "Preview".to_string(),
+            relative_time: "1m ago".to_string(),
+        }];
+
+        let actions = get_note_switcher_actions(&notes);
+        assert!(actions.is_empty());
+    }
 }
 
 /// Build actions for the AI new chat dropdown.
@@ -376,6 +465,48 @@
     presets: &[NewChatPresetInfo],
     models: &[NewChatModelInfo],
 ) -> Vec<Action> {
+    let invalid_last_used_count = last_used
+        .iter()
+        .filter(|model| has_invalid_new_chat_model_info(model))
+        .count();
+    if invalid_last_used_count > 0 {
+        tracing::warn!(
+            target: "script_kit::actions",
+            builder = "notes_new_chat",
+            invalid_last_used_count,
+            "Invalid last-used chat model input; returning empty actions"
+        );
+        return vec![];
+    }
+
+    let invalid_preset_count = presets
+        .iter()
+        .filter(|preset| has_invalid_new_chat_preset_info(preset))
+        .count();
+    if invalid_preset_count > 0 {
+        tracing::warn!(
+            target: "script_kit::actions",
+            builder = "notes_new_chat",
+            invalid_preset_count,
+            "Invalid chat preset input; returning empty actions"
+        );
+        return vec![];
+    }
+
+    let invalid_model_count = models
+        .iter()
+        .filter(|model| has_invalid_new_chat_model_info(model))
+        .count();
+    if invalid_model_count > 0 {
+        tracing::warn!(
+            target: "script_kit::actions",
+            builder = "notes_new_chat",
+            invalid_model_count,
+            "Invalid chat model input; returning empty actions"
+        );
+        return vec![];
+    }
+
     let mut actions = Vec::new();
 
     for setting in last_used {
@@ -442,6 +573,21 @@
 
 /// Get actions for the note switcher dialog (Cmd+P in Notes window).
 pub fn get_note_switcher_actions(notes: &[NoteSwitcherNoteInfo]) -> Vec<Action> {
+    let invalid_note_count = notes
+        .iter()
+        .filter(|note| has_invalid_note_switcher_note_info(note))
+        .count();
+    if invalid_note_count > 0 {
+        tracing::warn!(
+            target: "script_kit::actions",
+            builder = "note_switcher",
+            note_count = notes.len(),
+            invalid_note_count,
+            "Invalid note switcher input; returning empty actions"
+        );
+        return vec![];
+    }
+
     let mut actions = Vec::new();
 
     for note in notes {
diff --git a/src/actions/builders/script_context.rs b/src/actions/builders/script_context.rs
index d48add6d0604e4fc8ab6bc1d9a9cdc328a6037ab..c09068069325e288d1c697a6ed9aa07944aadf61
--- a/src/actions/builders/script_context.rs
+++ b/src/actions/builders/script_context.rs
@@ -2,8 +2,23 @@
 use super::types::{Action, ActionCategory, ScriptInfo};
 use std::collections::HashSet;
 
+fn has_invalid_script_context_input(script: &ScriptInfo) -> bool {
+    script.name.trim().is_empty() || script.action_verb.trim().is_empty()
+}
+
 /// Get actions specific to the focused script.
 pub fn get_script_context_actions(script: &ScriptInfo) -> Vec<Action> {
+    if has_invalid_script_context_input(script) {
+        tracing::warn!(
+            target: "script_kit::actions",
+            builder = "script_context",
+            name = %script.name,
+            action_verb = %script.action_verb,
+            "Invalid script context input; returning empty actions"
+        );
+        return vec![];
+    }
+
     let mut actions = Vec::new();
     let mut destructive_actions = Vec::new();
 
@@ -314,3 +329,26 @@
 pub fn get_global_actions() -> Vec<Action> {
     vec![]
 }
+
+#[cfg(test)]
+mod tests {
+    use super::*;
+
+    #[test]
+    fn test_get_script_context_actions_returns_empty_when_name_is_blank() {
+        let mut script = ScriptInfo::new("Valid", "/tmp/valid.ts");
+        script.name = "   ".to_string();
+
+        let actions = get_script_context_actions(&script);
+        assert!(actions.is_empty());
+    }
+
+    #[test]
+    fn test_get_script_context_actions_returns_empty_when_action_verb_is_blank() {
+        let mut script = ScriptInfo::new("Valid", "/tmp/valid.ts");
+        script.action_verb = "   ".to_string();
+
+        let actions = get_script_context_actions(&script);
+        assert!(actions.is_empty());
+    }
+}


thinking
**Running targeted Rust tests concurrently**
codex
While `scriptlet.rs` remains locked, I’m validating the two files already changed by running targeted tests for the new invalid-input branches in `notes.rs` and `script_context.rs`.
exec
/bin/zsh -lc 'cargo test -p script-kit-gpui test_get_new_chat_actions_returns_empty_when_last_used_model_input_is_invalid -- --exact' in /Users/johnlindquist/dev/script-kit-gpuiexec
/bin/zsh -lc 'cargo test -p script-kit-gpui test_get_script_context_actions_returns_empty_when_name_is_blank -- --exact' in /Users/johnlindquist/dev/script-kit-gpui succeeded in 1m 07s:
Claimed for codex-fix-builder-error-consistency-2: src/actions/builders/scriptlet.rs
 exited 101 in 19.19s:
    Blocking waiting for file lock on package cache
    Blocking waiting for file lock on package cache
    Blocking waiting for file lock on package cache
   Compiling script-kit-gpui v0.1.0 (/Users/johnlindquist/dev/script-kit-gpui)
error[E0761]: file for module `tests` found at both "src/protocol/message/tests.rs" and "src/protocol/message/tests/mod.rs"
  --> src/protocol/message/mod.rs:87:1
   |
87 | mod tests;
   | ^^^^^^^^^^
   |
   = help: delete or rename one of them to remove the ambiguity

error[E0761]: file for module `tests` found at both "src/designs/core/tests.rs" and "src/designs/core/tests/mod.rs"
 --> src/designs/core/part_04.rs:2:1
  |
2 | mod tests;
  | ^^^^^^^^^^
  |
  = help: delete or rename one of them to remove the ambiguity

file update:
diff --git a/src/actions/builders/notes.rs b/src/actions/builders/notes.rs
index 48ba267e97bf2f3da7ecf1a3f78fea59dbc9acab..a2f0007d3327b005960130e6e30f524ceb6b3e9f
--- a/src/actions/builders/notes.rs
+++ b/src/actions/builders/notes.rs
@@ -27,6 +27,25 @@
     pub auto_sizing_enabled: bool,
 }
 
+fn is_blank(value: &str) -> bool {
+    value.trim().is_empty()
+}
+
+fn has_invalid_new_chat_model_info(model: &NewChatModelInfo) -> bool {
+    is_blank(&model.model_id)
+        || is_blank(&model.display_name)
+        || is_blank(&model.provider)
+        || is_blank(&model.provider_display_name)
+}
+
+fn has_invalid_new_chat_preset_info(preset: &NewChatPresetInfo) -> bool {
+    is_blank(&preset.id) || is_blank(&preset.name)
+}
+
+fn has_invalid_note_switcher_note_info(note: &NoteSwitcherNoteInfo) -> bool {
+    is_blank(&note.id) || is_blank(&note.title)
+}
+
 /// Get actions for the Notes window command bar (Cmd+K menu).
 pub fn get_notes_command_bar_actions(info: &NotesInfo) -> Vec<Action> {
     let mut actions = Vec::new();
@@ -367,6 +386,76 @@
             Some("Use Focused Writing preset")
         );
     }
+
+    #[test]
+    fn test_get_new_chat_actions_returns_empty_when_last_used_model_input_is_invalid() {
+        let last_used = vec![NewChatModelInfo {
+            model_id: "   ".to_string(),
+            display_name: "GPT-4o Mini".to_string(),
+            provider: "openai".to_string(),
+            provider_display_name: "OpenAI".to_string(),
+        }];
+        let presets = vec![NewChatPresetInfo {
+            id: "focused-writing".to_string(),
+            name: "Focused Writing".to_string(),
+            icon: IconName::Pencil,
+        }];
+
+        let actions = get_new_chat_actions(&last_used, &presets, &[]);
+        assert!(actions.is_empty());
+    }
+
+    #[test]
+    fn test_get_new_chat_actions_returns_empty_when_preset_input_is_invalid() {
+        let last_used = vec![NewChatModelInfo {
+            model_id: "gpt-4o-mini".to_string(),
+            display_name: "GPT-4o Mini".to_string(),
+            provider: "openai".to_string(),
+            provider_display_name: "OpenAI".to_string(),
+        }];
+        let presets = vec![NewChatPresetInfo {
+            id: "   ".to_string(),
+            name: "Focused Writing".to_string(),
+            icon: IconName::Pencil,
+        }];
+
+        let actions = get_new_chat_actions(&last_used, &presets, &[]);
+        assert!(actions.is_empty());
+    }
+
+    #[test]
+    fn test_get_new_chat_actions_returns_empty_when_model_input_is_invalid() {
+        let presets = vec![NewChatPresetInfo {
+            id: "focused-writing".to_string(),
+            name: "Focused Writing".to_string(),
+            icon: IconName::Pencil,
+        }];
+        let models = vec![NewChatModelInfo {
+            model_id: "claude-3-5-sonnet".to_string(),
+            display_name: "Claude 3.5 Sonnet".to_string(),
+            provider: "   ".to_string(),
+            provider_display_name: "Anthropic".to_string(),
+        }];
+
+        let actions = get_new_chat_actions(&[], &presets, &models);
+        assert!(actions.is_empty());
+    }
+
+    #[test]
+    fn test_get_note_switcher_actions_returns_empty_when_note_input_is_invalid() {
+        let notes = vec![NoteSwitcherNoteInfo {
+            id: "   ".to_string(),
+            title: "Missing ID".to_string(),
+            char_count: 5,
+            is_current: false,
+            is_pinned: false,
+            preview: "Preview".to_string(),
+            relative_time: "1m ago".to_string(),
+        }];
+
+        let actions = get_note_switcher_actions(&notes);
+        assert!(actions.is_empty());
+    }
 }
 
 /// Build actions for the AI new chat dropdown.
@@ -376,6 +465,48 @@
     presets: &[NewChatPresetInfo],
     models: &[NewChatModelInfo],
 ) -> Vec<Action> {
+    let invalid_last_used_count = last_used
+        .iter()
+        .filter(|model| has_invalid_new_chat_model_info(model))
+        .count();
+    if invalid_last_used_count > 0 {
+        tracing::warn!(
+            target: "script_kit::actions",
+            builder = "notes_new_chat",
+            invalid_last_used_count,
+            "Invalid last-used chat model input; returning empty actions"
+        );
+        return vec![];
+    }
+
+    let invalid_preset_count = presets
+        .iter()
+        .filter(|preset| has_invalid_new_chat_preset_info(preset))
+        .count();
+    if invalid_preset_count > 0 {
+        tracing::warn!(
+            target: "script_kit::actions",
+            builder = "notes_new_chat",
+            invalid_preset_count,
+            "Invalid chat preset input; returning empty actions"
+        );
+        return vec![];
+    }
+
+    let invalid_model_count = models
+        .iter()
+        .filter(|model| has_invalid_new_chat_model_info(model))
+        .count();
+    if invalid_model_count > 0 {
+        tracing::warn!(
+            target: "script_kit::actions",
+            builder = "notes_new_chat",
+            invalid_model_count,
+            "Invalid chat model input; returning empty actions"
+        );
+        return vec![];
+    }
+
     let mut actions = Vec::new();
 
     for setting in last_used {
@@ -442,6 +573,21 @@
 
 /// Get actions for the note switcher dialog (Cmd+P in Notes window).
 pub fn get_note_switcher_actions(notes: &[NoteSwitcherNoteInfo]) -> Vec<Action> {
+    let invalid_note_count = notes
+        .iter()
+        .filter(|note| has_invalid_note_switcher_note_info(note))
+        .count();
+    if invalid_note_count > 0 {
+        tracing::warn!(
+            target: "script_kit::actions",
+            builder = "note_switcher",
+            note_count = notes.len(),
+            invalid_note_count,
+            "Invalid note switcher input; returning empty actions"
+        );
+        return vec![];
+    }
+
     let mut actions = Vec::new();
 
     for note in notes {
diff --git a/src/actions/builders/script_context.rs b/src/actions/builders/script_context.rs
index d48add6d0604e4fc8ab6bc1d9a9cdc328a6037ab..c09068069325e288d1c697a6ed9aa07944aadf61
--- a/src/actions/builders/script_context.rs
+++ b/src/actions/builders/script_context.rs
@@ -2,8 +2,23 @@
 use super::types::{Action, ActionCategory, ScriptInfo};
 use std::collections::HashSet;
 
+fn has_invalid_script_context_input(script: &ScriptInfo) -> bool {
+    script.name.trim().is_empty() || script.action_verb.trim().is_empty()
+}
+
 /// Get actions specific to the focused script.
 pub fn get_script_context_actions(script: &ScriptInfo) -> Vec<Action> {
+    if has_invalid_script_context_input(script) {
+        tracing::warn!(
+            target: "script_kit::actions",
+            builder = "script_context",
+            name = %script.name,
+            action_verb = %script.action_verb,
+            "Invalid script context input; returning empty actions"
+        );
+        return vec![];
+    }
+
     let mut actions = Vec::new();
     let mut destructive_actions = Vec::new();
 
@@ -314,3 +329,26 @@
 pub fn get_global_actions() -> Vec<Action> {
     vec![]
 }
+
+#[cfg(test)]
+mod tests {
+    use super::*;
+
+    #[test]
+    fn test_get_script_context_actions_returns_empty_when_name_is_blank() {
+        let mut script = ScriptInfo::new("Valid", "/tmp/valid.ts");
+        script.name = "   ".to_string();
+
+        let actions = get_script_context_actions(&script);
+        assert!(actions.is_empty());
+    }
+
+    #[test]
+    fn test_get_script_context_actions_returns_empty_when_action_verb_is_blank() {
+        let mut script = ScriptInfo::new("Valid", "/tmp/valid.ts");
+        script.action_verb = "   ".to_string();
+
+        let actions = get_script_context_actions(&script);
+        assert!(actions.is_empty());
+    }
+}

 exited 101 in 37.79s:
    Blocking waiting for file lock on package cache
    Blocking waiting for file lock on package cache
    Blocking waiting for file lock on build directory
   Compiling script-kit-gpui v0.1.0 (/Users/johnlindquist/dev/script-kit-gpui)
error[E0761]: file for module `tests` found at both "src/protocol/message/tests.rs" and "src/protocol/message/tests/mod.rs"
  --> src/protocol/message/mod.rs:87:1
   |
87 | mod tests;
   | ^^^^^^^^^^
   |
   = help: delete or rename one of them to remove the ambiguity

error[E0761]: file for module `tests` found at both "src/designs/core/tests.rs" and "src/designs/core/tests/mod.rs"
 --> src/designs/core/part_04.rs:2:1
  |
2 | mod tests;
  | ^^^^^^^^^^
  |
  = help: delete or rename one of them to remove the ambiguity

context compacted
Reconnecting... 1/5 (stream disconnected before completion: websocket closed by server before response.completed)

thinking
**Preparing status check and skill review**
codex
Continuing from the blocked state: I’m checking current swarm locks, then I’ll claim `src/actions/builders/scriptlet.rs`, finish the remaining consistency changes there, and run the required scoped verification commands.
exec
/bin/zsh -lc '~/.claude/bin/swarm.ts status' in /Users/johnlindquist/dev/script-kit-gpuiexec
/bin/zsh -lc 'git status --short' in /Users/johnlindquist/dev/script-kit-gpui succeeded in 52ms:
Repo: /Users/johnlindquist/dev/script-kit-gpui
Updated: 2026-02-08T00:22:21.735Z

Active agents (4):
codex-fix-builder-error-consistency-2 [blocked] codex/gpt-5.3-codex/exec
  task: CONSISTENCY FIX: Make error handling consistent across action builders part 2. Ensure builders in src/actions/builders/…
  scope: src/actions/builders/notes.rs,src/actions/builders/script_context.rs,src/actions/builders/scriptlet.rs
  claims(3): src/actions/builders/notes.rs, src/actions/builders/script_context.rs, src/actions/builders/scriptlet.rs
  notes: waiting on claim for src/actions/builders/scriptlet.rs held by codex-fix-scriptlet-dedup

codex-fix-description-style [in_progress] codex/gpt-5.3-codex/exec
  task: CONSISTENCY FIX: Make action descriptions consistent in style across all builders. All descriptions should: (1) Start w…
  scope: src/actions/builders/chat.rs,src/actions/builders/clipboard.rs,src/actions/builders/file_path.rs,src/actions/builders/n…
  claims: (none)
  notes: claiming builder files for description-style consistency pass

codex-fix-icon-consistency [in_progress] codex/gpt-5.3-codex/exec
  task: CONSISTENCY FIX: Ensure all actions have appropriate icons from IconName. Review all Action::new calls in src/actions/b…
  scope: src/actions/builders/chat.rs,src/actions/builders/clipboard.rs,src/actions/builders/file_path.rs,src/actions/builders/n…
  claims(2): src/actions/builders/chat.rs, src/actions/builders/clipboard.rs
 succeeded in 51ms:
 M .ai/logs/codex-audit-act-description-quality-v2.final.md
 M .ai/logs/codex-audit-act-execution-builtin.final.md
 M .ai/logs/codex-audit-act-execution-scripts.final.md
 M .ai/logs/codex-audit-act-keyboard-nav.final.md
 M .ai/logs/codex-audit-act-section-grouping.final.md
 M .ai/logs/codex-audit-act-theme-dialog-render.final.md
 M .ai/roster.json
 M src/actions/builders/chat.rs
 M src/actions/builders/clipboard.rs
 M src/actions/builders/file_path.rs
 M src/actions/builders/notes.rs
 M src/actions/builders/script_context.rs
 M src/actions/builders/scriptlet.rs
 M src/actions/builders/shared.rs
 M src/actions/command_bar/part_01.rs
 M src/actions/command_bar/part_02.rs
 M src/actions/constants.rs
 M src/actions/dialog/part_01.rs
 M src/actions/dialog/part_02/part_01.rs
 M src/actions/dialog/part_02/part_03.rs
file update:
diff --git a/src/actions/builders/notes.rs b/src/actions/builders/notes.rs
index 48ba267e97bf2f3da7ecf1a3f78fea59dbc9acab..a2f0007d3327b005960130e6e30f524ceb6b3e9f
--- a/src/actions/builders/notes.rs
+++ b/src/actions/builders/notes.rs
@@ -27,6 +27,25 @@
     pub auto_sizing_enabled: bool,
 }
 
+fn is_blank(value: &str) -> bool {
+    value.trim().is_empty()
+}
+
+fn has_invalid_new_chat_model_info(model: &NewChatModelInfo) -> bool {
+    is_blank(&model.model_id)
+        || is_blank(&model.display_name)
+        || is_blank(&model.provider)
+        || is_blank(&model.provider_display_name)
+}
+
+fn has_invalid_new_chat_preset_info(preset: &NewChatPresetInfo) -> bool {
+    is_blank(&preset.id) || is_blank(&preset.name)
+}
+
+fn has_invalid_note_switcher_note_info(note: &NoteSwitcherNoteInfo) -> bool {
+    is_blank(&note.id) || is_blank(&note.title)
+}
+
 /// Get actions for the Notes window command bar (Cmd+K menu).
 pub fn get_notes_command_bar_actions(info: &NotesInfo) -> Vec<Action> {
     let mut actions = Vec::new();
@@ -367,6 +386,76 @@
             Some("Use Focused Writing preset")
         );
     }
+
+    #[test]
+    fn test_get_new_chat_actions_returns_empty_when_last_used_model_input_is_invalid() {
+        let last_used = vec![NewChatModelInfo {
+            model_id: "   ".to_string(),
+            display_name: "GPT-4o Mini".to_string(),
+            provider: "openai".to_string(),
+            provider_display_name: "OpenAI".to_string(),
+        }];
+        let presets = vec![NewChatPresetInfo {
+            id: "focused-writing".to_string(),
+            name: "Focused Writing".to_string(),
+            icon: IconName::Pencil,
+        }];
+
+        let actions = get_new_chat_actions(&last_used, &presets, &[]);
+        assert!(actions.is_empty());
+    }
+
+    #[test]
+    fn test_get_new_chat_actions_returns_empty_when_preset_input_is_invalid() {
+        let last_used = vec![NewChatModelInfo {
+            model_id: "gpt-4o-mini".to_string(),
+            display_name: "GPT-4o Mini".to_string(),
+            provider: "openai".to_string(),
+            provider_display_name: "OpenAI".to_string(),
+        }];
+        let presets = vec![NewChatPresetInfo {
+            id: "   ".to_string(),
+            name: "Focused Writing".to_string(),
+            icon: IconName::Pencil,
+        }];
+
+        let actions = get_new_chat_actions(&last_used, &presets, &[]);
+        assert!(actions.is_empty());
+    }
+
+    #[test]
+    fn test_get_new_chat_actions_returns_empty_when_model_input_is_invalid() {
+        let presets = vec![NewChatPresetInfo {
+            id: "focused-writing".to_string(),
+            name: "Focused Writing".to_string(),
+            icon: IconName::Pencil,
+        }];
+        let models = vec![NewChatModelInfo {
+            model_id: "claude-3-5-sonnet".to_string(),
+            display_name: "Claude 3.5 Sonnet".to_string(),
+            provider: "   ".to_string(),
+            provider_display_name: "Anthropic".to_string(),
+        }];
+
+        let actions = get_new_chat_actions(&[], &presets, &models);
+        assert!(actions.is_empty());
+    }
+
+    #[test]
+    fn test_get_note_switcher_actions_returns_empty_when_note_input_is_invalid() {
+        let notes = vec![NoteSwitcherNoteInfo {
+            id: "   ".to_string(),
+            title: "Missing ID".to_string(),
+            char_count: 5,
+            is_current: false,
+            is_pinned: false,
+            preview: "Preview".to_string(),
+            relative_time: "1m ago".to_string(),
+        }];
+
+        let actions = get_note_switcher_actions(&notes);
+        assert!(actions.is_empty());
+    }
 }
 
 /// Build actions for the AI new chat dropdown.
@@ -376,6 +465,48 @@
     presets: &[NewChatPresetInfo],
     models: &[NewChatModelInfo],
 ) -> Vec<Action> {
+    let invalid_last_used_count = last_used
+        .iter()
+        .filter(|model| has_invalid_new_chat_model_info(model))
+        .count();
+    if invalid_last_used_count > 0 {
+        tracing::warn!(
+            target: "script_kit::actions",
+            builder = "notes_new_chat",
+            invalid_last_used_count,
+            "Invalid last-used chat model input; returning empty actions"
+        );
+        return vec![];
+    }
+
+    let invalid_preset_count = presets
+        .iter()
+        .filter(|preset| has_invalid_new_chat_preset_info(preset))
+        .count();
+    if invalid_preset_count > 0 {
+        tracing::warn!(
+            target: "script_kit::actions",
+            builder = "notes_new_chat",
+            invalid_preset_count,
+            "Invalid chat preset input; returning empty actions"
+        );
+        return vec![];
+    }
+
+    let invalid_model_count = models
+        .iter()
+        .filter(|model| has_invalid_new_chat_model_info(model))
+        .count();
+    if invalid_model_count > 0 {
+        tracing::warn!(
+            target: "script_kit::actions",
+            builder = "notes_new_chat",
+            invalid_model_count,
+            "Invalid chat model input; returning empty actions"
+        );
+        return vec![];
+    }
+
     let mut actions = Vec::new();
 
     for setting in last_used {
@@ -442,6 +573,21 @@
 
 /// Get actions for the note switcher dialog (Cmd+P in Notes window).
 pub fn get_note_switcher_actions(notes: &[NoteSwitcherNoteInfo]) -> Vec<Action> {
+    let invalid_note_count = notes
+        .iter()
+        .filter(|note| has_invalid_note_switcher_note_info(note))
+        .count();
+    if invalid_note_count > 0 {
+        tracing::warn!(
+            target: "script_kit::actions",
+            builder = "note_switcher",
+            note_count = notes.len(),
+            invalid_note_count,
+            "Invalid note switcher input; returning empty actions"
+        );
+        return vec![];
+    }
+
     let mut actions = Vec::new();
 
     for note in notes {
diff --git a/src/actions/builders/script_context.rs b/src/actions/builders/script_context.rs
index d48add6d0604e4fc8ab6bc1d9a9cdc328a6037ab..c09068069325e288d1c697a6ed9aa07944aadf61
--- a/src/actions/builders/script_context.rs
+++ b/src/actions/builders/script_context.rs
@@ -2,8 +2,23 @@
 use super::types::{Action, ActionCategory, ScriptInfo};
 use std::collections::HashSet;
 
+fn has_invalid_script_context_input(script: &ScriptInfo) -> bool {
+    script.name.trim().is_empty() || script.action_verb.trim().is_empty()
+}
+
 /// Get actions specific to the focused script.
 pub fn get_script_context_actions(script: &ScriptInfo) -> Vec<Action> {
+    if has_invalid_script_context_input(script) {
+        tracing::warn!(
+            target: "script_kit::actions",
+            builder = "script_context",
+            name = %script.name,
+            action_verb = %script.action_verb,
+            "Invalid script context input; returning empty actions"
+        );
+        return vec![];
+    }
+
     let mut actions = Vec::new();
     let mut destructive_actions = Vec::new();
 
@@ -314,3 +329,26 @@
 pub fn get_global_actions() -> Vec<Action> {
     vec![]
 }
+
+#[cfg(test)]
+mod tests {
+    use super::*;
+
+    #[test]
+    fn test_get_script_context_actions_returns_empty_when_name_is_blank() {
+        let mut script = ScriptInfo::new("Valid", "/tmp/valid.ts");
+        script.name = "   ".to_string();
+
+        let actions = get_script_context_actions(&script);
+        assert!(actions.is_empty());
+    }
+
+    #[test]
+    fn test_get_script_context_actions_returns_empty_when_action_verb_is_blank() {
+        let mut script = ScriptInfo::new("Valid", "/tmp/valid.ts");
+        script.action_verb = "   ".to_string();
+
+        let actions = get_script_context_actions(&script);
+        assert!(actions.is_empty());
+    }
+}


thinking
**Updating claim status and inspecting file changes**
codex
I now hold all three file claims, including `scriptlet.rs`. Next I’ll inspect current contents of the scoped builders, finish any missing consistency guards, and then run `cargo check` and `cargo clippy` as requested.
exec
/bin/zsh -lc "sed -n '1,260p' src/actions/builders/notes.rs" in /Users/johnlindquist/dev/script-kit-gpuiexec
/bin/zsh -lc "sed -n '1,260p' src/actions/builders/scriptlet.rs" in /Users/johnlindquist/dev/script-kit-gpuiexec
/bin/zsh -lc "sed -n '1,260p' src/actions/builders/script_context.rs" in /Users/johnlindquist/dev/script-kit-gpuiexec
/bin/zsh -lc '~/.claude/bin/swarm.ts update --id codex-fix-builder-error-consistency-2 --status in_progress --notes "claimed notes/script_context/scriptlet; implementing invalid-input warn+empty-vec consistency"' in /Users/johnlindquist/dev/script-kit-gpui succeeded in 50ms:
use super::shared::{format_shortcut_hint, to_deeplink_name};
use super::types::{Action, ActionCategory, ScriptInfo};
use crate::designs::icon_variations::IconName;
use crate::scriptlets::Scriptlet;
use std::collections::HashSet;

const SCRIPTLET_ACTION_ID_PREFIX: &str = "scriptlet_action:";

fn parse_scriptlet_action_command(action_id: &str) -> Option<&str> {
    action_id
        .strip_prefix(SCRIPTLET_ACTION_ID_PREFIX)
        .filter(|command| !command.trim().is_empty())
}

fn unique_scriptlet_action_id(
    raw_action_id: &str,
    action_name: &str,
    used_action_ids: &mut HashSet<String>,
) -> Option<String> {
    let Some(action_command) = parse_scriptlet_action_command(raw_action_id) else {
 succeeded in 50ms:
use super::types::{Action, ActionCategory};
use crate::designs::icon_variations::IconName;

/// Information about a model for the new chat dropdown
#[derive(Debug, Clone)]
#[allow(dead_code)]
pub struct NewChatModelInfo {
    pub model_id: String,
    pub display_name: String,
    pub provider: String,
    pub provider_display_name: String,
}

/// Information about a preset for the new chat dropdown
#[derive(Debug, Clone)]
pub struct NewChatPresetInfo {
    pub id: String,
    pub name: String,
    pub icon: IconName,
}
 succeeded in 50ms:
use super::shared::to_deeplink_name;
use super::types::{Action, ActionCategory, ScriptInfo};
use std::collections::HashSet;

fn has_invalid_script_context_input(script: &ScriptInfo) -> bool {
    script.name.trim().is_empty() || script.action_verb.trim().is_empty()
}

/// Get actions specific to the focused script.
pub fn get_script_context_actions(script: &ScriptInfo) -> Vec<Action> {
    if has_invalid_script_context_input(script) {
        tracing::warn!(
            target: "script_kit::actions",
            builder = "script_context",
            name = %script.name,
            action_verb = %script.action_verb,
            "Invalid script context input; returning empty actions"
        );
        return vec![];
    }
 succeeded in 51ms:
Updated: codex-fix-builder-error-consistency-2
file update:
diff --git a/src/actions/builders/notes.rs b/src/actions/builders/notes.rs
index 48ba267e97bf2f3da7ecf1a3f78fea59dbc9acab..a2f0007d3327b005960130e6e30f524ceb6b3e9f
--- a/src/actions/builders/notes.rs
+++ b/src/actions/builders/notes.rs
@@ -27,6 +27,25 @@
     pub auto_sizing_enabled: bool,
 }
 
+fn is_blank(value: &str) -> bool {
+    value.trim().is_empty()
+}
+
+fn has_invalid_new_chat_model_info(model: &NewChatModelInfo) -> bool {
+    is_blank(&model.model_id)
+        || is_blank(&model.display_name)
+        || is_blank(&model.provider)
+        || is_blank(&model.provider_display_name)
+}
+
+fn has_invalid_new_chat_preset_info(preset: &NewChatPresetInfo) -> bool {
+    is_blank(&preset.id) || is_blank(&preset.name)
+}
+
+fn has_invalid_note_switcher_note_info(note: &NoteSwitcherNoteInfo) -> bool {
+    is_blank(&note.id) || is_blank(&note.title)
+}
+
 /// Get actions for the Notes window command bar (Cmd+K menu).
 pub fn get_notes_command_bar_actions(info: &NotesInfo) -> Vec<Action> {
     let mut actions = Vec::new();
@@ -367,6 +386,76 @@
             Some("Use Focused Writing preset")
         );
     }
+
+    #[test]
+    fn test_get_new_chat_actions_returns_empty_when_last_used_model_input_is_invalid() {
+        let last_used = vec![NewChatModelInfo {
+            model_id: "   ".to_string(),
+            display_name: "GPT-4o Mini".to_string(),
+            provider: "openai".to_string(),
+            provider_display_name: "OpenAI".to_string(),
+        }];
+        let presets = vec![NewChatPresetInfo {
+            id: "focused-writing".to_string(),
+            name: "Focused Writing".to_string(),
+            icon: IconName::Pencil,
+        }];
+
+        let actions = get_new_chat_actions(&last_used, &presets, &[]);
+        assert!(actions.is_empty());
+    }
+
+    #[test]
+    fn test_get_new_chat_actions_returns_empty_when_preset_input_is_invalid() {
+        let last_used = vec![NewChatModelInfo {
+            model_id: "gpt-4o-mini".to_string(),
+            display_name: "GPT-4o Mini".to_string(),
+            provider: "openai".to_string(),
+            provider_display_name: "OpenAI".to_string(),
+        }];
+        let presets = vec![NewChatPresetInfo {
+            id: "   ".to_string(),
+            name: "Focused Writing".to_string(),
+            icon: IconName::Pencil,
+        }];
+
+        let actions = get_new_chat_actions(&last_used, &presets, &[]);
+        assert!(actions.is_empty());
+    }
+
+    #[test]
+    fn test_get_new_chat_actions_returns_empty_when_model_input_is_invalid() {
+        let presets = vec![NewChatPresetInfo {
+            id: "focused-writing".to_string(),
+            name: "Focused Writing".to_string(),
+            icon: IconName::Pencil,
+        }];
+        let models = vec![NewChatModelInfo {
+            model_id: "claude-3-5-sonnet".to_string(),
+            display_name: "Claude 3.5 Sonnet".to_string(),
+            provider: "   ".to_string(),
+            provider_display_name: "Anthropic".to_string(),
+        }];
+
+        let actions = get_new_chat_actions(&[], &presets, &models);
+        assert!(actions.is_empty());
+    }
+
+    #[test]
+    fn test_get_note_switcher_actions_returns_empty_when_note_input_is_invalid() {
+        let notes = vec![NoteSwitcherNoteInfo {
+            id: "   ".to_string(),
+            title: "Missing ID".to_string(),
+            char_count: 5,
+            is_current: false,
+            is_pinned: false,
+            preview: "Preview".to_string(),
+            relative_time: "1m ago".to_string(),
+        }];
+
+        let actions = get_note_switcher_actions(&notes);
+        assert!(actions.is_empty());
+    }
 }
 
 /// Build actions for the AI new chat dropdown.
@@ -376,6 +465,48 @@
     presets: &[NewChatPresetInfo],
     models: &[NewChatModelInfo],
 ) -> Vec<Action> {
+    let invalid_last_used_count = last_used
+        .iter()
+        .filter(|model| has_invalid_new_chat_model_info(model))
+        .count();
+    if invalid_last_used_count > 0 {
+        tracing::warn!(
+            target: "script_kit::actions",
+            builder = "notes_new_chat",
+            invalid_last_used_count,
+            "Invalid last-used chat model input; returning empty actions"
+        );
+        return vec![];
+    }
+
+    let invalid_preset_count = presets
+        .iter()
+        .filter(|preset| has_invalid_new_chat_preset_info(preset))
+        .count();
+    if invalid_preset_count > 0 {
+        tracing::warn!(
+            target: "script_kit::actions",
+            builder = "notes_new_chat",
+            invalid_preset_count,
+            "Invalid chat preset input; returning empty actions"
+        );
+        return vec![];
+    }
+
+    let invalid_model_count = models
+        .iter()
+        .filter(|model| has_invalid_new_chat_model_info(model))
+        .count();
+    if invalid_model_count > 0 {
+        tracing::warn!(
+            target: "script_kit::actions",
+            builder = "notes_new_chat",
+            invalid_model_count,
+            "Invalid chat model input; returning empty actions"
+        );
+        return vec![];
+    }
+
     let mut actions = Vec::new();
 
     for setting in last_used {
@@ -442,6 +573,21 @@
 
 /// Get actions for the note switcher dialog (Cmd+P in Notes window).
 pub fn get_note_switcher_actions(notes: &[NoteSwitcherNoteInfo]) -> Vec<Action> {
+    let invalid_note_count = notes
+        .iter()
+        .filter(|note| has_invalid_note_switcher_note_info(note))
+        .count();
+    if invalid_note_count > 0 {
+        tracing::warn!(
+            target: "script_kit::actions",
+            builder = "note_switcher",
+            note_count = notes.len(),
+            invalid_note_count,
+            "Invalid note switcher input; returning empty actions"
+        );
+        return vec![];
+    }
+
     let mut actions = Vec::new();
 
     for note in notes {
diff --git a/src/actions/builders/script_context.rs b/src/actions/builders/script_context.rs
index d48add6d0604e4fc8ab6bc1d9a9cdc328a6037ab..c09068069325e288d1c697a6ed9aa07944aadf61
--- a/src/actions/builders/script_context.rs
+++ b/src/actions/builders/script_context.rs
@@ -2,8 +2,23 @@
 use super::types::{Action, ActionCategory, ScriptInfo};
 use std::collections::HashSet;
 
+fn has_invalid_script_context_input(script: &ScriptInfo) -> bool {
+    script.name.trim().is_empty() || script.action_verb.trim().is_empty()
+}
+
 /// Get actions specific to the focused script.
 pub fn get_script_context_actions(script: &ScriptInfo) -> Vec<Action> {
+    if has_invalid_script_context_input(script) {
+        tracing::warn!(
+            target: "script_kit::actions",
+            builder = "script_context",
+            name = %script.name,
+            action_verb = %script.action_verb,
+            "Invalid script context input; returning empty actions"
+        );
+        return vec![];
+    }
+
     let mut actions = Vec::new();
     let mut destructive_actions = Vec::new();
 
@@ -314,3 +329,26 @@
 pub fn get_global_actions() -> Vec<Action> {
     vec![]
 }
+
+#[cfg(test)]
+mod tests {
+    use super::*;
+
+    #[test]
+    fn test_get_script_context_actions_returns_empty_when_name_is_blank() {
+        let mut script = ScriptInfo::new("Valid", "/tmp/valid.ts");
+        script.name = "   ".to_string();
+
+        let actions = get_script_context_actions(&script);
+        assert!(actions.is_empty());
+    }
+
+    #[test]
+    fn test_get_script_context_actions_returns_empty_when_action_verb_is_blank() {
+        let mut script = ScriptInfo::new("Valid", "/tmp/valid.ts");
+        script.action_verb = "   ".to_string();
+
+        let actions = get_script_context_actions(&script);
+        assert!(actions.is_empty());
+    }
+}


thinking
**Investigating partial script content**
exec
/bin/zsh -lc 'wc -l src/actions/builders/notes.rs src/actions/builders/script_context.rs src/actions/builders/scriptlet.rs' in /Users/johnlindquist/dev/script-kit-gpuiexec
/bin/zsh -lc "sed -n '261,520p' src/actions/builders/script_context.rs" in /Users/johnlindquist/dev/script-kit-gpuiexec
/bin/zsh -lc "sed -n '261,520p' src/actions/builders/scriptlet.rs" in /Users/johnlindquist/dev/script-kit-gpui succeeded in 51ms:
     658 src/actions/builders/notes.rs
     354 src/actions/builders/script_context.rs
     394 src/actions/builders/scriptlet.rs
    1406 total
 succeeded in 50ms:
            .with_section("Share"),
        );
    }

    let deeplink_name = to_deeplink_name(&script.name);
    actions.push(
        Action::new(
            "copy_deeplink",
            "Copy Deeplink",
            Some(format!(
                "Copy scriptkit://run/{} URL to clipboard",
                deeplink_name
            )),
            ActionCategory::ScriptContext,
        )
        .with_shortcut("⌘⇧D")
        .with_section("Share"),
    );

    if script.is_suggested {
 succeeded in 50ms:
    );

    if script.is_suggested {
        destructive_actions.push(
            Action::new(
                "reset_ranking",
                "Reset Ranking",
                Some("Remove this item from Suggested section".to_string()),
                ActionCategory::ScriptContext,
            )
            .with_shortcut("⌃⌘R")
            .with_icon(IconName::Refresh)
            .with_section("Destructive"),
        );
    }

    actions.extend(destructive_actions);
    actions
}

file update:
diff --git a/src/actions/builders/notes.rs b/src/actions/builders/notes.rs
index 48ba267e97bf2f3da7ecf1a3f78fea59dbc9acab..a2f0007d3327b005960130e6e30f524ceb6b3e9f
--- a/src/actions/builders/notes.rs
+++ b/src/actions/builders/notes.rs
@@ -27,6 +27,25 @@
     pub auto_sizing_enabled: bool,
 }
 
+fn is_blank(value: &str) -> bool {
+    value.trim().is_empty()
+}
+
+fn has_invalid_new_chat_model_info(model: &NewChatModelInfo) -> bool {
+    is_blank(&model.model_id)
+        || is_blank(&model.display_name)
+        || is_blank(&model.provider)
+        || is_blank(&model.provider_display_name)
+}
+
+fn has_invalid_new_chat_preset_info(preset: &NewChatPresetInfo) -> bool {
+    is_blank(&preset.id) || is_blank(&preset.name)
+}
+
+fn has_invalid_note_switcher_note_info(note: &NoteSwitcherNoteInfo) -> bool {
+    is_blank(&note.id) || is_blank(&note.title)
+}
+
 /// Get actions for the Notes window command bar (Cmd+K menu).
 pub fn get_notes_command_bar_actions(info: &NotesInfo) -> Vec<Action> {
     let mut actions = Vec::new();
@@ -367,6 +386,76 @@
             Some("Use Focused Writing preset")
         );
     }
+
+    #[test]
+    fn test_get_new_chat_actions_returns_empty_when_last_used_model_input_is_invalid() {
+        let last_used = vec![NewChatModelInfo {
+            model_id: "   ".to_string(),
+            display_name: "GPT-4o Mini".to_string(),
+            provider: "openai".to_string(),
+            provider_display_name: "OpenAI".to_string(),
+        }];
+        let presets = vec![NewChatPresetInfo {
+            id: "focused-writing".to_string(),
+            name: "Focused Writing".to_string(),
+            icon: IconName::Pencil,
+        }];
+
+        let actions = get_new_chat_actions(&last_used, &presets, &[]);
+        assert!(actions.is_empty());
+    }
+
+    #[test]
+    fn test_get_new_chat_actions_returns_empty_when_preset_input_is_invalid() {
+        let last_used = vec![NewChatModelInfo {
+            model_id: "gpt-4o-mini".to_string(),
+            display_name: "GPT-4o Mini".to_string(),
+            provider: "openai".to_string(),
+            provider_display_name: "OpenAI".to_string(),
+        }];
+        let presets = vec![NewChatPresetInfo {
+            id: "   ".to_string(),
+            name: "Focused Writing".to_string(),
+            icon: IconName::Pencil,
+        }];
+
+        let actions = get_new_chat_actions(&last_used, &presets, &[]);
+        assert!(actions.is_empty());
+    }
+
+    #[test]
+    fn test_get_new_chat_actions_returns_empty_when_model_input_is_invalid() {
+        let presets = vec![NewChatPresetInfo {
+            id: "focused-writing".to_string(),
+            name: "Focused Writing".to_string(),
+            icon: IconName::Pencil,
+        }];
+        let models = vec![NewChatModelInfo {
+            model_id: "claude-3-5-sonnet".to_string(),
+            display_name: "Claude 3.5 Sonnet".to_string(),
+            provider: "   ".to_string(),
+            provider_display_name: "Anthropic".to_string(),
+        }];
+
+        let actions = get_new_chat_actions(&[], &presets, &models);
+        assert!(actions.is_empty());
+    }
+
+    #[test]
+    fn test_get_note_switcher_actions_returns_empty_when_note_input_is_invalid() {
+        let notes = vec![NoteSwitcherNoteInfo {
+            id: "   ".to_string(),
+            title: "Missing ID".to_string(),
+            char_count: 5,
+            is_current: false,
+            is_pinned: false,
+            preview: "Preview".to_string(),
+            relative_time: "1m ago".to_string(),
+        }];
+
+        let actions = get_note_switcher_actions(&notes);
+        assert!(actions.is_empty());
+    }
 }
 
 /// Build actions for the AI new chat dropdown.
@@ -376,6 +465,48 @@
     presets: &[NewChatPresetInfo],
     models: &[NewChatModelInfo],
 ) -> Vec<Action> {
+    let invalid_last_used_count = last_used
+        .iter()
+        .filter(|model| has_invalid_new_chat_model_info(model))
+        .count();
+    if invalid_last_used_count > 0 {
+        tracing::warn!(
+            target: "script_kit::actions",
+            builder = "notes_new_chat",
+            invalid_last_used_count,
+            "Invalid last-used chat model input; returning empty actions"
+        );
+        return vec![];
+    }
+
+    let invalid_preset_count = presets
+        .iter()
+        .filter(|preset| has_invalid_new_chat_preset_info(preset))
+        .count();
+    if invalid_preset_count > 0 {
+        tracing::warn!(
+            target: "script_kit::actions",
+            builder = "notes_new_chat",
+            invalid_preset_count,
+            "Invalid chat preset input; returning empty actions"
+        );
+        return vec![];
+    }
+
+    let invalid_model_count = models
+        .iter()
+        .filter(|model| has_invalid_new_chat_model_info(model))
+        .count();
+    if invalid_model_count > 0 {
+        tracing::warn!(
+            target: "script_kit::actions",
+            builder = "notes_new_chat",
+            invalid_model_count,
+            "Invalid chat model input; returning empty actions"
+        );
+        return vec![];
+    }
+
     let mut actions = Vec::new();
 
     for setting in last_used {
@@ -442,6 +573,21 @@
 
 /// Get actions for the note switcher dialog (Cmd+P in Notes window).
 pub fn get_note_switcher_actions(notes: &[NoteSwitcherNoteInfo]) -> Vec<Action> {
+    let invalid_note_count = notes
+        .iter()
+        .filter(|note| has_invalid_note_switcher_note_info(note))
+        .count();
+    if invalid_note_count > 0 {
+        tracing::warn!(
+            target: "script_kit::actions",
+            builder = "note_switcher",
+            note_count = notes.len(),
+            invalid_note_count,
+            "Invalid note switcher input; returning empty actions"
+        );
+        return vec![];
+    }
+
     let mut actions = Vec::new();
 
     for note in notes {
diff --git a/src/actions/builders/script_context.rs b/src/actions/builders/script_context.rs
index d48add6d0604e4fc8ab6bc1d9a9cdc328a6037ab..c09068069325e288d1c697a6ed9aa07944aadf61
--- a/src/actions/builders/script_context.rs
+++ b/src/actions/builders/script_context.rs
@@ -2,8 +2,23 @@
 use super::types::{Action, ActionCategory, ScriptInfo};
 use std::collections::HashSet;
 
+fn has_invalid_script_context_input(script: &ScriptInfo) -> bool {
+    script.name.trim().is_empty() || script.action_verb.trim().is_empty()
+}
+
 /// Get actions specific to the focused script.
 pub fn get_script_context_actions(script: &ScriptInfo) -> Vec<Action> {
+    if has_invalid_script_context_input(script) {
+        tracing::warn!(
+            target: "script_kit::actions",
+            builder = "script_context",
+            name = %script.name,
+            action_verb = %script.action_verb,
+            "Invalid script context input; returning empty actions"
+        );
+        return vec![];
+    }
+
     let mut actions = Vec::new();
     let mut destructive_actions = Vec::new();
 
@@ -314,3 +329,26 @@
 pub fn get_global_actions() -> Vec<Action> {
     vec![]
 }
+
+#[cfg(test)]
+mod tests {
+    use super::*;
+
+    #[test]
+    fn test_get_script_context_actions_returns_empty_when_name_is_blank() {
+        let mut script = ScriptInfo::new("Valid", "/tmp/valid.ts");
+        script.name = "   ".to_string();
+
+        let actions = get_script_context_actions(&script);
+        assert!(actions.is_empty());
+    }
+
+    #[test]
+    fn test_get_script_context_actions_returns_empty_when_action_verb_is_blank() {
+        let mut script = ScriptInfo::new("Valid", "/tmp/valid.ts");
+        script.action_verb = "   ".to_string();
+
+        let actions = get_script_context_actions(&script);
+        assert!(actions.is_empty());
+    }
+}


thinking
**Identifying missing script input validation**
exec
/bin/zsh -lc "sed -n '260,520p' src/actions/builders/notes.rs" in /Users/johnlindquist/dev/script-kit-gpuiexec
/bin/zsh -lc "sed -n '520,720p' src/actions/builders/notes.rs" in /Users/johnlindquist/dev/script-kit-gpuiexec
/bin/zsh -lc 'rg -n "pub fn get_(new_chat_actions|note_switcher_actions|notes_command_bar_actions)|Invalid|warn!|unwrap'"\\(|expect\\(\" src/actions/builders/notes.rs src/actions/builders/script_context.rs src/actions/builders/scriptlet.rs" in /Users/johnlindquist/dev/script-kit-gpui succeeded in 50ms:
            .with_section("Last Used Settings")
            .with_icon(IconName::BoltFilled),
        );
    }

    for preset in presets {
        actions.push(
            Action::new(
                format!("preset_{}", preset.id),
                &preset.name,
                Some(new_chat_preset_description(preset)),
                ActionCategory::ScriptContext,
            )
            .with_section("Presets")
            .with_icon(preset.icon),
        );
    }

    for model in models {
        actions.push(
 succeeded in 50ms:

    #[test]
    fn test_get_notes_command_bar_actions_includes_trash_actions_when_selected_in_trash() {
        let info = NotesInfo {
            has_selection: true,
            is_trash_view: true,
            auto_sizing_enabled: true,
        };

        let actions = get_notes_command_bar_actions(&info);
        let restore_note = actions
            .iter()
            .find(|action| action.id == "restore_note")
            .expect("missing restore_note action");
        let permanently_delete_note = actions
            .iter()
            .find(|action| action.id == "permanently_delete_note")
            .expect("missing permanently_delete_note action");

        assert_eq!(restore_note.title, "Restore Note");
 succeeded in 51ms:
src/actions/builders/notes.rs:50:pub fn get_notes_command_bar_actions(info: &NotesInfo) -> Vec<Action> {
src/actions/builders/notes.rs:225:            .expect("missing copy_note_as action");
src/actions/builders/notes.rs:229:            .expect("missing export action");
src/actions/builders/notes.rs:255:            .expect("missing copy_deeplink action");
src/actions/builders/notes.rs:273:            .expect("missing restore_note action");
src/actions/builders/notes.rs:277:            .expect("missing permanently_delete_note action");
src/actions/builders/notes.rs:382:            .expect("missing preset action");
src/actions/builders/notes.rs:463:pub fn get_new_chat_actions(
src/actions/builders/notes.rs:473:        tracing::warn!(
src/actions/builders/notes.rs:477:            "Invalid last-used chat model input; returning empty actions"
src/actions/builders/notes.rs:487:        tracing::warn!(
src/actions/builders/notes.rs:491:            "Invalid chat preset input; returning empty actions"
src/actions/builders/notes.rs:501:        tracing::warn!(
src/actions/builders/notes.rs:505:            "Invalid chat model input; returning empty actions"
src/actions/builders/notes.rs:575:pub fn get_note_switcher_actions(notes: &[NoteSwitcherNoteInfo]) -> Vec<Action> {
src/actions/builders/notes.rs:581:        tracing::warn!(
src/actions/builders/notes.rs:586:            "Invalid note switcher input; returning empty actions"
src/actions/builders/scriptlet.rs:21:        tracing::warn!(
src/actions/builders/scriptlet.rs:365:            .expect("missing run_script action");
src/actions/builders/scriptlet.rs:369:            .expect("missing edit_scriptlet action");
file update:
diff --git a/src/actions/builders/notes.rs b/src/actions/builders/notes.rs
index 48ba267e97bf2f3da7ecf1a3f78fea59dbc9acab..a2f0007d3327b005960130e6e30f524ceb6b3e9f
--- a/src/actions/builders/notes.rs
+++ b/src/actions/builders/notes.rs
@@ -27,6 +27,25 @@
     pub auto_sizing_enabled: bool,
 }
 
+fn is_blank(value: &str) -> bool {
+    value.trim().is_empty()
+}
+
+fn has_invalid_new_chat_model_info(model: &NewChatModelInfo) -> bool {
+    is_blank(&model.model_id)
+        || is_blank(&model.display_name)
+        || is_blank(&model.provider)
+        || is_blank(&model.provider_display_name)
+}
+
+fn has_invalid_new_chat_preset_info(preset: &NewChatPresetInfo) -> bool {
+    is_blank(&preset.id) || is_blank(&preset.name)
+}
+
+fn has_invalid_note_switcher_note_info(note: &NoteSwitcherNoteInfo) -> bool {
+    is_blank(&note.id) || is_blank(&note.title)
+}
+
 /// Get actions for the Notes window command bar (Cmd+K menu).
 pub fn get_notes_command_bar_actions(info: &NotesInfo) -> Vec<Action> {
     let mut actions = Vec::new();
@@ -367,6 +386,76 @@
             Some("Use Focused Writing preset")
         );
     }
+
+    #[test]
+    fn test_get_new_chat_actions_returns_empty_when_last_used_model_input_is_invalid() {
+        let last_used = vec![NewChatModelInfo {
+            model_id: "   ".to_string(),
+            display_name: "GPT-4o Mini".to_string(),
+            provider: "openai".to_string(),
+            provider_display_name: "OpenAI".to_string(),
+        }];
+        let presets = vec![NewChatPresetInfo {
+            id: "focused-writing".to_string(),
+            name: "Focused Writing".to_string(),
+            icon: IconName::Pencil,
+        }];
+
+        let actions = get_new_chat_actions(&last_used, &presets, &[]);
+        assert!(actions.is_empty());
+    }
+
+    #[test]
+    fn test_get_new_chat_actions_returns_empty_when_preset_input_is_invalid() {
+        let last_used = vec![NewChatModelInfo {
+            model_id: "gpt-4o-mini".to_string(),
+            display_name: "GPT-4o Mini".to_string(),
+            provider: "openai".to_string(),
+            provider_display_name: "OpenAI".to_string(),
+        }];
+        let presets = vec![NewChatPresetInfo {
+            id: "   ".to_string(),
+            name: "Focused Writing".to_string(),
+            icon: IconName::Pencil,
+        }];
+
+        let actions = get_new_chat_actions(&last_used, &presets, &[]);
+        assert!(actions.is_empty());
+    }
+
+    #[test]
+    fn test_get_new_chat_actions_returns_empty_when_model_input_is_invalid() {
+        let presets = vec![NewChatPresetInfo {
+            id: "focused-writing".to_string(),
+            name: "Focused Writing".to_string(),
+            icon: IconName::Pencil,
+        }];
+        let models = vec![NewChatModelInfo {
+            model_id: "claude-3-5-sonnet".to_string(),
+            display_name: "Claude 3.5 Sonnet".to_string(),
+            provider: "   ".to_string(),
+            provider_display_name: "Anthropic".to_string(),
+        }];
+
+        let actions = get_new_chat_actions(&[], &presets, &models);
+        assert!(actions.is_empty());
+    }
+
+    #[test]
+    fn test_get_note_switcher_actions_returns_empty_when_note_input_is_invalid() {
+        let notes = vec![NoteSwitcherNoteInfo {
+            id: "   ".to_string(),
+            title: "Missing ID".to_string(),
+            char_count: 5,
+            is_current: false,
+            is_pinned: false,
+            preview: "Preview".to_string(),
+            relative_time: "1m ago".to_string(),
+        }];
+
+        let actions = get_note_switcher_actions(&notes);
+        assert!(actions.is_empty());
+    }
 }
 
 /// Build actions for the AI new chat dropdown.
@@ -376,6 +465,48 @@
     presets: &[NewChatPresetInfo],
     models: &[NewChatModelInfo],
 ) -> Vec<Action> {
+    let invalid_last_used_count = last_used
+        .iter()
+        .filter(|model| has_invalid_new_chat_model_info(model))
+        .count();
+    if invalid_last_used_count > 0 {
+        tracing::warn!(
+            target: "script_kit::actions",
+            builder = "notes_new_chat",
+            invalid_last_used_count,
+            "Invalid last-used chat model input; returning empty actions"
+        );
+        return vec![];
+    }
+
+    let invalid_preset_count = presets
+        .iter()
+        .filter(|preset| has_invalid_new_chat_preset_info(preset))
+        .count();
+    if invalid_preset_count > 0 {
+        tracing::warn!(
+            target: "script_kit::actions",
+            builder = "notes_new_chat",
+            invalid_preset_count,
+            "Invalid chat preset input; returning empty actions"
+        );
+        return vec![];
+    }
+
+    let invalid_model_count = models
+        .iter()
+        .filter(|model| has_invalid_new_chat_model_info(model))
+        .count();
+    if invalid_model_count > 0 {
+        tracing::warn!(
+            target: "script_kit::actions",
+            builder = "notes_new_chat",
+            invalid_model_count,
+            "Invalid chat model input; returning empty actions"
+        );
+        return vec![];
+    }
+
     let mut actions = Vec::new();
 
     for setting in last_used {
@@ -442,6 +573,21 @@
 
 /// Get actions for the note switcher dialog (Cmd+P in Notes window).
 pub fn get_note_switcher_actions(notes: &[NoteSwitcherNoteInfo]) -> Vec<Action> {
+    let invalid_note_count = notes
+        .iter()
+        .filter(|note| has_invalid_note_switcher_note_info(note))
+        .count();
+    if invalid_note_count > 0 {
+        tracing::warn!(
+            target: "script_kit::actions",
+            builder = "note_switcher",
+            note_count = notes.len(),
+            invalid_note_count,
+            "Invalid note switcher input; returning empty actions"
+        );
+        return vec![];
+    }
+
     let mut actions = Vec::new();
 
     for note in notes {
diff --git a/src/actions/builders/script_context.rs b/src/actions/builders/script_context.rs
index d48add6d0604e4fc8ab6bc1d9a9cdc328a6037ab..c09068069325e288d1c697a6ed9aa07944aadf61
--- a/src/actions/builders/script_context.rs
+++ b/src/actions/builders/script_context.rs
@@ -2,8 +2,23 @@
 use super::types::{Action, ActionCategory, ScriptInfo};
 use std::collections::HashSet;
 
+fn has_invalid_script_context_input(script: &ScriptInfo) -> bool {
+    script.name.trim().is_empty() || script.action_verb.trim().is_empty()
+}
+
 /// Get actions specific to the focused script.
 pub fn get_script_context_actions(script: &ScriptInfo) -> Vec<Action> {
+    if has_invalid_script_context_input(script) {
+        tracing::warn!(
+            target: "script_kit::actions",
+            builder = "script_context",
+            name = %script.name,
+            action_verb = %script.action_verb,
+            "Invalid script context input; returning empty actions"
+        );
+        return vec![];
+    }
+
     let mut actions = Vec::new();
     let mut destructive_actions = Vec::new();
 
@@ -314,3 +329,26 @@
 pub fn get_global_actions() -> Vec<Action> {
     vec![]
 }
+
+#[cfg(test)]
+mod tests {
+    use super::*;
+
+    #[test]
+    fn test_get_script_context_actions_returns_empty_when_name_is_blank() {
+        let mut script = ScriptInfo::new("Valid", "/tmp/valid.ts");
+        script.name = "   ".to_string();
+
+        let actions = get_script_context_actions(&script);
+        assert!(actions.is_empty());
+    }
+
+    #[test]
+    fn test_get_script_context_actions_returns_empty_when_action_verb_is_blank() {
+        let mut script = ScriptInfo::new("Valid", "/tmp/valid.ts");
+        script.action_verb = "   ".to_string();
+
+        let actions = get_script_context_actions(&script);
+        assert!(actions.is_empty());
+    }
+}


thinking
**Aligning builder validation patterns**
codex
I found the remaining gap in `scriptlet.rs`: malformed scriptlet action commands are currently dropped per-item instead of treating input as invalid for the whole builder. I’m aligning that file to the same warn-and-return-empty pattern used in the other builders, with tests.
exec
/bin/zsh -lc "sed -n '1,220p' src/actions/builders/scriptlet.rs" in /Users/johnlindquist/dev/script-kit-gpuiexec
/bin/zsh -lc 'rg -n "Invalid .*returning empty actions|builder =|return vec!'"\\[\\]\" src/actions/builders/chat.rs src/actions/builders/clipboard.rs src/actions/builders/file_path.rs src/actions/builders/notes.rs src/actions/builders/script_context.rs src/actions/builders/scriptlet.rs" in /Users/johnlindquist/dev/script-kit-gpui succeeded in 51ms:
use super::shared::{format_shortcut_hint, to_deeplink_name};
use super::types::{Action, ActionCategory, ScriptInfo};
use crate::designs::icon_variations::IconName;
use crate::scriptlets::Scriptlet;
use std::collections::HashSet;

const SCRIPTLET_ACTION_ID_PREFIX: &str = "scriptlet_action:";

fn parse_scriptlet_action_command(action_id: &str) -> Option<&str> {
    action_id
        .strip_prefix(SCRIPTLET_ACTION_ID_PREFIX)
        .filter(|command| !command.trim().is_empty())
}

fn unique_scriptlet_action_id(
    raw_action_id: &str,
    action_name: &str,
    used_action_ids: &mut HashSet<String>,
) -> Option<String> {
    let Some(action_command) = parse_scriptlet_action_command(raw_action_id) else {
 succeeded in 50ms:
src/actions/builders/notes.rs:475:            builder = "notes_new_chat",
src/actions/builders/notes.rs:477:            "Invalid last-used chat model input; returning empty actions"
src/actions/builders/notes.rs:479:        return vec![];
src/actions/builders/notes.rs:489:            builder = "notes_new_chat",
src/actions/builders/notes.rs:491:            "Invalid chat preset input; returning empty actions"
src/actions/builders/notes.rs:493:        return vec![];
src/actions/builders/notes.rs:503:            builder = "notes_new_chat",
src/actions/builders/notes.rs:505:            "Invalid chat model input; returning empty actions"
src/actions/builders/notes.rs:507:        return vec![];
src/actions/builders/notes.rs:583:            builder = "note_switcher",
src/actions/builders/notes.rs:586:            "Invalid note switcher input; returning empty actions"
src/actions/builders/notes.rs:588:        return vec![];
src/actions/builders/script_context.rs:14:            builder = "script_context",
src/actions/builders/script_context.rs:17:            "Invalid script context input; returning empty actions"
src/actions/builders/script_context.rs:19:        return vec![];
file update:
diff --git a/src/actions/builders/notes.rs b/src/actions/builders/notes.rs
index 48ba267e97bf2f3da7ecf1a3f78fea59dbc9acab..a2f0007d3327b005960130e6e30f524ceb6b3e9f
--- a/src/actions/builders/notes.rs
+++ b/src/actions/builders/notes.rs
@@ -27,6 +27,25 @@
     pub auto_sizing_enabled: bool,
 }
 
+fn is_blank(value: &str) -> bool {
+    value.trim().is_empty()
+}
+
+fn has_invalid_new_chat_model_info(model: &NewChatModelInfo) -> bool {
+    is_blank(&model.model_id)
+        || is_blank(&model.display_name)
+        || is_blank(&model.provider)
+        || is_blank(&model.provider_display_name)
+}
+
+fn has_invalid_new_chat_preset_info(preset: &NewChatPresetInfo) -> bool {
+    is_blank(&preset.id) || is_blank(&preset.name)
+}
+
+fn has_invalid_note_switcher_note_info(note: &NoteSwitcherNoteInfo) -> bool {
+    is_blank(&note.id) || is_blank(&note.title)
+}
+
 /// Get actions for the Notes window command bar (Cmd+K menu).
 pub fn get_notes_command_bar_actions(info: &NotesInfo) -> Vec<Action> {
     let mut actions = Vec::new();
@@ -367,6 +386,76 @@
             Some("Use Focused Writing preset")
         );
     }
+
+    #[test]
+    fn test_get_new_chat_actions_returns_empty_when_last_used_model_input_is_invalid() {
+        let last_used = vec![NewChatModelInfo {
+            model_id: "   ".to_string(),
+            display_name: "GPT-4o Mini".to_string(),
+            provider: "openai".to_string(),
+            provider_display_name: "OpenAI".to_string(),
+        }];
+        let presets = vec![NewChatPresetInfo {
+            id: "focused-writing".to_string(),
+            name: "Focused Writing".to_string(),
+            icon: IconName::Pencil,
+        }];
+
+        let actions = get_new_chat_actions(&last_used, &presets, &[]);
+        assert!(actions.is_empty());
+    }
+
+    #[test]
+    fn test_get_new_chat_actions_returns_empty_when_preset_input_is_invalid() {
+        let last_used = vec![NewChatModelInfo {
+            model_id: "gpt-4o-mini".to_string(),
+            display_name: "GPT-4o Mini".to_string(),
+            provider: "openai".to_string(),
+            provider_display_name: "OpenAI".to_string(),
+        }];
+        let presets = vec![NewChatPresetInfo {
+            id: "   ".to_string(),
+            name: "Focused Writing".to_string(),
+            icon: IconName::Pencil,
+        }];
+
+        let actions = get_new_chat_actions(&last_used, &presets, &[]);
+        assert!(actions.is_empty());
+    }
+
+    #[test]
+    fn test_get_new_chat_actions_returns_empty_when_model_input_is_invalid() {
+        let presets = vec![NewChatPresetInfo {
+            id: "focused-writing".to_string(),
+            name: "Focused Writing".to_string(),
+            icon: IconName::Pencil,
+        }];
+        let models = vec![NewChatModelInfo {
+            model_id: "claude-3-5-sonnet".to_string(),
+            display_name: "Claude 3.5 Sonnet".to_string(),
+            provider: "   ".to_string(),
+            provider_display_name: "Anthropic".to_string(),
+        }];
+
+        let actions = get_new_chat_actions(&[], &presets, &models);
+        assert!(actions.is_empty());
+    }
+
+    #[test]
+    fn test_get_note_switcher_actions_returns_empty_when_note_input_is_invalid() {
+        let notes = vec![NoteSwitcherNoteInfo {
+            id: "   ".to_string(),
+            title: "Missing ID".to_string(),
+            char_count: 5,
+            is_current: false,
+            is_pinned: false,
+            preview: "Preview".to_string(),
+            relative_time: "1m ago".to_string(),
+        }];
+
+        let actions = get_note_switcher_actions(&notes);
+        assert!(actions.is_empty());
+    }
 }
 
 /// Build actions for the AI new chat dropdown.
@@ -376,6 +465,48 @@
     presets: &[NewChatPresetInfo],
     models: &[NewChatModelInfo],
 ) -> Vec<Action> {
+    let invalid_last_used_count = last_used
+        .iter()
+        .filter(|model| has_invalid_new_chat_model_info(model))
+        .count();
+    if invalid_last_used_count > 0 {
+        tracing::warn!(
+            target: "script_kit::actions",
+            builder = "notes_new_chat",
+            invalid_last_used_count,
+            "Invalid last-used chat model input; returning empty actions"
+        );
+        return vec![];
+    }
+
+    let invalid_preset_count = presets
+        .iter()
+        .filter(|preset| has_invalid_new_chat_preset_info(preset))
+        .count();
+    if invalid_preset_count > 0 {
+        tracing::warn!(
+            target: "script_kit::actions",
+            builder = "notes_new_chat",
+            invalid_preset_count,
+            "Invalid chat preset input; returning empty actions"
+        );
+        return vec![];
+    }
+
+    let invalid_model_count = models
+        .iter()
+        .filter(|model| has_invalid_new_chat_model_info(model))
+        .count();
+    if invalid_model_count > 0 {
+        tracing::warn!(
+            target: "script_kit::actions",
+            builder = "notes_new_chat",
+            invalid_model_count,
+            "Invalid chat model input; returning empty actions"
+        );
+        return vec![];
+    }
+
     let mut actions = Vec::new();
 
     for setting in last_used {
@@ -442,6 +573,21 @@
 
 /// Get actions for the note switcher dialog (Cmd+P in Notes window).
 pub fn get_note_switcher_actions(notes: &[NoteSwitcherNoteInfo]) -> Vec<Action> {
+    let invalid_note_count = notes
+        .iter()
+        .filter(|note| has_invalid_note_switcher_note_info(note))
+        .count();
+    if invalid_note_count > 0 {
+        tracing::warn!(
+            target: "script_kit::actions",
+            builder = "note_switcher",
+            note_count = notes.len(),
+            invalid_note_count,
+            "Invalid note switcher input; returning empty actions"
+        );
+        return vec![];
+    }
+
     let mut actions = Vec::new();
 
     for note in notes {
diff --git a/src/actions/builders/script_context.rs b/src/actions/builders/script_context.rs
index d48add6d0604e4fc8ab6bc1d9a9cdc328a6037ab..c09068069325e288d1c697a6ed9aa07944aadf61
--- a/src/actions/builders/script_context.rs
+++ b/src/actions/builders/script_context.rs
@@ -2,8 +2,23 @@
 use super::types::{Action, ActionCategory, ScriptInfo};
 use std::collections::HashSet;
 
+fn has_invalid_script_context_input(script: &ScriptInfo) -> bool {
+    script.name.trim().is_empty() || script.action_verb.trim().is_empty()
+}
+
 /// Get actions specific to the focused script.
 pub fn get_script_context_actions(script: &ScriptInfo) -> Vec<Action> {
+    if has_invalid_script_context_input(script) {
+        tracing::warn!(
+            target: "script_kit::actions",
+            builder = "script_context",
+            name = %script.name,
+            action_verb = %script.action_verb,
+            "Invalid script context input; returning empty actions"
+        );
+        return vec![];
+    }
+
     let mut actions = Vec::new();
     let mut destructive_actions = Vec::new();
 
@@ -314,3 +329,26 @@
 pub fn get_global_actions() -> Vec<Action> {
     vec![]
 }
+
+#[cfg(test)]
+mod tests {
+    use super::*;
+
+    #[test]
+    fn test_get_script_context_actions_returns_empty_when_name_is_blank() {
+        let mut script = ScriptInfo::new("Valid", "/tmp/valid.ts");
+        script.name = "   ".to_string();
+
+        let actions = get_script_context_actions(&script);
+        assert!(actions.is_empty());
+    }
+
+    #[test]
+    fn test_get_script_context_actions_returns_empty_when_action_verb_is_blank() {
+        let mut script = ScriptInfo::new("Valid", "/tmp/valid.ts");
+        script.action_verb = "   ".to_string();
+
+        let actions = get_script_context_actions(&script);
+        assert!(actions.is_empty());
+    }
+}


thinking
**Planning remaining scriptlet inspection**
exec
/bin/zsh -lc "sed -n '220,430p' src/actions/builders/scriptlet.rs" in /Users/johnlindquist/dev/script-kit-gpui succeeded in 51ms:
        .with_section("Share"),
    );

    actions.push(
        Action::new(
            "copy_scriptlet_path",
            "Copy Path",
            Some("Copy scriptlet bundle path to clipboard".to_string()),
            ActionCategory::ScriptContext,
        )
        .with_shortcut("⌘⇧C")
        .with_icon(IconName::Copy)
        .with_section("Share"),
    );

    actions.push(
        Action::new(
            "copy_content",
            "Copy Content",
            Some("Copy entire file content to clipboard".to_string()),
file update:
diff --git a/src/actions/builders/notes.rs b/src/actions/builders/notes.rs
index 48ba267e97bf2f3da7ecf1a3f78fea59dbc9acab..a2f0007d3327b005960130e6e30f524ceb6b3e9f
--- a/src/actions/builders/notes.rs
+++ b/src/actions/builders/notes.rs
@@ -27,6 +27,25 @@
     pub auto_sizing_enabled: bool,
 }
 
+fn is_blank(value: &str) -> bool {
+    value.trim().is_empty()
+}
+
+fn has_invalid_new_chat_model_info(model: &NewChatModelInfo) -> bool {
+    is_blank(&model.model_id)
+        || is_blank(&model.display_name)
+        || is_blank(&model.provider)
+        || is_blank(&model.provider_display_name)
+}
+
+fn has_invalid_new_chat_preset_info(preset: &NewChatPresetInfo) -> bool {
+    is_blank(&preset.id) || is_blank(&preset.name)
+}
+
+fn has_invalid_note_switcher_note_info(note: &NoteSwitcherNoteInfo) -> bool {
+    is_blank(&note.id) || is_blank(&note.title)
+}
+
 /// Get actions for the Notes window command bar (Cmd+K menu).
 pub fn get_notes_command_bar_actions(info: &NotesInfo) -> Vec<Action> {
     let mut actions = Vec::new();
@@ -367,6 +386,76 @@
             Some("Use Focused Writing preset")
         );
     }
+
+    #[test]
+    fn test_get_new_chat_actions_returns_empty_when_last_used_model_input_is_invalid() {
+        let last_used = vec![NewChatModelInfo {
+            model_id: "   ".to_string(),
+            display_name: "GPT-4o Mini".to_string(),
+            provider: "openai".to_string(),
+            provider_display_name: "OpenAI".to_string(),
+        }];
+        let presets = vec![NewChatPresetInfo {
+            id: "focused-writing".to_string(),
+            name: "Focused Writing".to_string(),
+            icon: IconName::Pencil,
+        }];
+
+        let actions = get_new_chat_actions(&last_used, &presets, &[]);
+        assert!(actions.is_empty());
+    }
+
+    #[test]
+    fn test_get_new_chat_actions_returns_empty_when_preset_input_is_invalid() {
+        let last_used = vec![NewChatModelInfo {
+            model_id: "gpt-4o-mini".to_string(),
+            display_name: "GPT-4o Mini".to_string(),
+            provider: "openai".to_string(),
+            provider_display_name: "OpenAI".to_string(),
+        }];
+        let presets = vec![NewChatPresetInfo {
+            id: "   ".to_string(),
+            name: "Focused Writing".to_string(),
+            icon: IconName::Pencil,
+        }];
+
+        let actions = get_new_chat_actions(&last_used, &presets, &[]);
+        assert!(actions.is_empty());
+    }
+
+    #[test]
+    fn test_get_new_chat_actions_returns_empty_when_model_input_is_invalid() {
+        let presets = vec![NewChatPresetInfo {
+            id: "focused-writing".to_string(),
+            name: "Focused Writing".to_string(),
+            icon: IconName::Pencil,
+        }];
+        let models = vec![NewChatModelInfo {
+            model_id: "claude-3-5-sonnet".to_string(),
+            display_name: "Claude 3.5 Sonnet".to_string(),
+            provider: "   ".to_string(),
+            provider_display_name: "Anthropic".to_string(),
+        }];
+
+        let actions = get_new_chat_actions(&[], &presets, &models);
+        assert!(actions.is_empty());
+    }
+
+    #[test]
+    fn test_get_note_switcher_actions_returns_empty_when_note_input_is_invalid() {
+        let notes = vec![NoteSwitcherNoteInfo {
+            id: "   ".to_string(),
+            title: "Missing ID".to_string(),
+            char_count: 5,
+            is_current: false,
+            is_pinned: false,
+            preview: "Preview".to_string(),
+            relative_time: "1m ago".to_string(),
+        }];
+
+        let actions = get_note_switcher_actions(&notes);
+        assert!(actions.is_empty());
+    }
 }
 
 /// Build actions for the AI new chat dropdown.
@@ -376,6 +465,48 @@
     presets: &[NewChatPresetInfo],
     models: &[NewChatModelInfo],
 ) -> Vec<Action> {
+    let invalid_last_used_count = last_used
+        .iter()
+        .filter(|model| has_invalid_new_chat_model_info(model))
+        .count();
+    if invalid_last_used_count > 0 {
+        tracing::warn!(
+            target: "script_kit::actions",
+            builder = "notes_new_chat",
+            invalid_last_used_count,
+            "Invalid last-used chat model input; returning empty actions"
+        );
+        return vec![];
+    }
+
+    let invalid_preset_count = presets
+        .iter()
+        .filter(|preset| has_invalid_new_chat_preset_info(preset))
+        .count();
+    if invalid_preset_count > 0 {
+        tracing::warn!(
+            target: "script_kit::actions",
+            builder = "notes_new_chat",
+            invalid_preset_count,
+            "Invalid chat preset input; returning empty actions"
+        );
+        return vec![];
+    }
+
+    let invalid_model_count = models
+        .iter()
+        .filter(|model| has_invalid_new_chat_model_info(model))
+        .count();
+    if invalid_model_count > 0 {
+        tracing::warn!(
+            target: "script_kit::actions",
+            builder = "notes_new_chat",
+            invalid_model_count,
+            "Invalid chat model input; returning empty actions"
+        );
+        return vec![];
+    }
+
     let mut actions = Vec::new();
 
     for setting in last_used {
@@ -442,6 +573,21 @@
 
 /// Get actions for the note switcher dialog (Cmd+P in Notes window).
 pub fn get_note_switcher_actions(notes: &[NoteSwitcherNoteInfo]) -> Vec<Action> {
+    let invalid_note_count = notes
+        .iter()
+        .filter(|note| has_invalid_note_switcher_note_info(note))
+        .count();
+    if invalid_note_count > 0 {
+        tracing::warn!(
+            target: "script_kit::actions",
+            builder = "note_switcher",
+            note_count = notes.len(),
+            invalid_note_count,
+            "Invalid note switcher input; returning empty actions"
+        );
+        return vec![];
+    }
+
     let mut actions = Vec::new();
 
     for note in notes {
diff --git a/src/actions/builders/script_context.rs b/src/actions/builders/script_context.rs
index d48add6d0604e4fc8ab6bc1d9a9cdc328a6037ab..c09068069325e288d1c697a6ed9aa07944aadf61
--- a/src/actions/builders/script_context.rs
+++ b/src/actions/builders/script_context.rs
@@ -2,8 +2,23 @@
 use super::types::{Action, ActionCategory, ScriptInfo};
 use std::collections::HashSet;
 
+fn has_invalid_script_context_input(script: &ScriptInfo) -> bool {
+    script.name.trim().is_empty() || script.action_verb.trim().is_empty()
+}
+
 /// Get actions specific to the focused script.
 pub fn get_script_context_actions(script: &ScriptInfo) -> Vec<Action> {
+    if has_invalid_script_context_input(script) {
+        tracing::warn!(
+            target: "script_kit::actions",
+            builder = "script_context",
+            name = %script.name,
+            action_verb = %script.action_verb,
+            "Invalid script context input; returning empty actions"
+        );
+        return vec![];
+    }
+
     let mut actions = Vec::new();
     let mut destructive_actions = Vec::new();
 
@@ -314,3 +329,26 @@
 pub fn get_global_actions() -> Vec<Action> {
     vec![]
 }
+
+#[cfg(test)]
+mod tests {
+    use super::*;
+
+    #[test]
+    fn test_get_script_context_actions_returns_empty_when_name_is_blank() {
+        let mut script = ScriptInfo::new("Valid", "/tmp/valid.ts");
+        script.name = "   ".to_string();
+
+        let actions = get_script_context_actions(&script);
+        assert!(actions.is_empty());
+    }
+
+    #[test]
+    fn test_get_script_context_actions_returns_empty_when_action_verb_is_blank() {
+        let mut script = ScriptInfo::new("Valid", "/tmp/valid.ts");
+        script.action_verb = "   ".to_string();
+
+        let actions = get_script_context_actions(&script);
+        assert!(actions.is_empty());
+    }
+}


thinking
**Evaluating scriptlet action validity criteria**
exec
/bin/zsh -lc "rg -n \"struct ScriptletAction|impl ScriptletAction|fn action_id\\(\" src/scriptlets -g'*.rs'" in /Users/johnlindquist/dev/script-kit-gpui succeeded in 50ms:
src/scriptlets/part_000.rs:245:pub struct ScriptletAction {
src/scriptlets/part_000.rs:261:impl ScriptletAction {
src/scriptlets/part_000.rs:264:    pub fn action_id(&self) -> String {
file update:
diff --git a/src/actions/builders/notes.rs b/src/actions/builders/notes.rs
index 48ba267e97bf2f3da7ecf1a3f78fea59dbc9acab..a2f0007d3327b005960130e6e30f524ceb6b3e9f
--- a/src/actions/builders/notes.rs
+++ b/src/actions/builders/notes.rs
@@ -27,6 +27,25 @@
     pub auto_sizing_enabled: bool,
 }
 
+fn is_blank(value: &str) -> bool {
+    value.trim().is_empty()
+}
+
+fn has_invalid_new_chat_model_info(model: &NewChatModelInfo) -> bool {
+    is_blank(&model.model_id)
+        || is_blank(&model.display_name)
+        || is_blank(&model.provider)
+        || is_blank(&model.provider_display_name)
+}
+
+fn has_invalid_new_chat_preset_info(preset: &NewChatPresetInfo) -> bool {
+    is_blank(&preset.id) || is_blank(&preset.name)
+}
+
+fn has_invalid_note_switcher_note_info(note: &NoteSwitcherNoteInfo) -> bool {
+    is_blank(&note.id) || is_blank(&note.title)
+}
+
 /// Get actions for the Notes window command bar (Cmd+K menu).
 pub fn get_notes_command_bar_actions(info: &NotesInfo) -> Vec<Action> {
     let mut actions = Vec::new();
@@ -367,6 +386,76 @@
             Some("Use Focused Writing preset")
         );
     }
+
+    #[test]
+    fn test_get_new_chat_actions_returns_empty_when_last_used_model_input_is_invalid() {
+        let last_used = vec![NewChatModelInfo {
+            model_id: "   ".to_string(),
+            display_name: "GPT-4o Mini".to_string(),
+            provider: "openai".to_string(),
+            provider_display_name: "OpenAI".to_string(),
+        }];
+        let presets = vec![NewChatPresetInfo {
+            id: "focused-writing".to_string(),
+            name: "Focused Writing".to_string(),
+            icon: IconName::Pencil,
+        }];
+
+        let actions = get_new_chat_actions(&last_used, &presets, &[]);
+        assert!(actions.is_empty());
+    }
+
+    #[test]
+    fn test_get_new_chat_actions_returns_empty_when_preset_input_is_invalid() {
+        let last_used = vec![NewChatModelInfo {
+            model_id: "gpt-4o-mini".to_string(),
+            display_name: "GPT-4o Mini".to_string(),
+            provider: "openai".to_string(),
+            provider_display_name: "OpenAI".to_string(),
+        }];
+        let presets = vec![NewChatPresetInfo {
+            id: "   ".to_string(),
+            name: "Focused Writing".to_string(),
+            icon: IconName::Pencil,
+        }];
+
+        let actions = get_new_chat_actions(&last_used, &presets, &[]);
+        assert!(actions.is_empty());
+    }
+
+    #[test]
+    fn test_get_new_chat_actions_returns_empty_when_model_input_is_invalid() {
+        let presets = vec![NewChatPresetInfo {
+            id: "focused-writing".to_string(),
+            name: "Focused Writing".to_string(),
+            icon: IconName::Pencil,
+        }];
+        let models = vec![NewChatModelInfo {
+            model_id: "claude-3-5-sonnet".to_string(),
+            display_name: "Claude 3.5 Sonnet".to_string(),
+            provider: "   ".to_string(),
+            provider_display_name: "Anthropic".to_string(),
+        }];
+
+        let actions = get_new_chat_actions(&[], &presets, &models);
+        assert!(actions.is_empty());
+    }
+
+    #[test]
+    fn test_get_note_switcher_actions_returns_empty_when_note_input_is_invalid() {
+        let notes = vec![NoteSwitcherNoteInfo {
+            id: "   ".to_string(),
+            title: "Missing ID".to_string(),
+            char_count: 5,
+            is_current: false,
+            is_pinned: false,
+            preview: "Preview".to_string(),
+            relative_time: "1m ago".to_string(),
+        }];
+
+        let actions = get_note_switcher_actions(&notes);
+        assert!(actions.is_empty());
+    }
 }
 
 /// Build actions for the AI new chat dropdown.
@@ -376,6 +465,48 @@
     presets: &[NewChatPresetInfo],
     models: &[NewChatModelInfo],
 ) -> Vec<Action> {
+    let invalid_last_used_count = last_used
+        .iter()
+        .filter(|model| has_invalid_new_chat_model_info(model))
+        .count();
+    if invalid_last_used_count > 0 {
+        tracing::warn!(
+            target: "script_kit::actions",
+            builder = "notes_new_chat",
+            invalid_last_used_count,
+            "Invalid last-used chat model input; returning empty actions"
+        );
+        return vec![];
+    }
+
+    let invalid_preset_count = presets
+        .iter()
+        .filter(|preset| has_invalid_new_chat_preset_info(preset))
+        .count();
+    if invalid_preset_count > 0 {
+        tracing::warn!(
+            target: "script_kit::actions",
+            builder = "notes_new_chat",
+            invalid_preset_count,
+            "Invalid chat preset input; returning empty actions"
+        );
+        return vec![];
+    }
+
+    let invalid_model_count = models
+        .iter()
+        .filter(|model| has_invalid_new_chat_model_info(model))
+        .count();
+    if invalid_model_count > 0 {
+        tracing::warn!(
+            target: "script_kit::actions",
+            builder = "notes_new_chat",
+            invalid_model_count,
+            "Invalid chat model input; returning empty actions"
+        );
+        return vec![];
+    }
+
     let mut actions = Vec::new();
 
     for setting in last_used {
@@ -442,6 +573,21 @@
 
 /// Get actions for the note switcher dialog (Cmd+P in Notes window).
 pub fn get_note_switcher_actions(notes: &[NoteSwitcherNoteInfo]) -> Vec<Action> {
+    let invalid_note_count = notes
+        .iter()
+        .filter(|note| has_invalid_note_switcher_note_info(note))
+        .count();
+    if invalid_note_count > 0 {
+        tracing::warn!(
+            target: "script_kit::actions",
+            builder = "note_switcher",
+            note_count = notes.len(),
+            invalid_note_count,
+            "Invalid note switcher input; returning empty actions"
+        );
+        return vec![];
+    }
+
     let mut actions = Vec::new();
 
     for note in notes {
diff --git a/src/actions/builders/script_context.rs b/src/actions/builders/script_context.rs
index d48add6d0604e4fc8ab6bc1d9a9cdc328a6037ab..c09068069325e288d1c697a6ed9aa07944aadf61
--- a/src/actions/builders/script_context.rs
+++ b/src/actions/builders/script_context.rs
@@ -2,8 +2,23 @@
 use super::types::{Action, ActionCategory, ScriptInfo};
 use std::collections::HashSet;
 
+fn has_invalid_script_context_input(script: &ScriptInfo) -> bool {
+    script.name.trim().is_empty() || script.action_verb.trim().is_empty()
+}
+
 /// Get actions specific to the focused script.
 pub fn get_script_context_actions(script: &ScriptInfo) -> Vec<Action> {
+    if has_invalid_script_context_input(script) {
+        tracing::warn!(
+            target: "script_kit::actions",
+            builder = "script_context",
+            name = %script.name,
+            action_verb = %script.action_verb,
+            "Invalid script context input; returning empty actions"
+        );
+        return vec![];
+    }
+
     let mut actions = Vec::new();
     let mut destructive_actions = Vec::new();
 
@@ -314,3 +329,26 @@
 pub fn get_global_actions() -> Vec<Action> {
     vec![]
 }
+
+#[cfg(test)]
+mod tests {
+    use super::*;
+
+    #[test]
+    fn test_get_script_context_actions_returns_empty_when_name_is_blank() {
+        let mut script = ScriptInfo::new("Valid", "/tmp/valid.ts");
+        script.name = "   ".to_string();
+
+        let actions = get_script_context_actions(&script);
+        assert!(actions.is_empty());
+    }
+
+    #[test]
+    fn test_get_script_context_actions_returns_empty_when_action_verb_is_blank() {
+        let mut script = ScriptInfo::new("Valid", "/tmp/valid.ts");
+        script.action_verb = "   ".to_string();
+
+        let actions = get_script_context_actions(&script);
+        assert!(actions.is_empty());
+    }
+}

exec
/bin/zsh -lc "sed -n '220,330p' src/scriptlets/part_000.rs" in /Users/johnlindquist/dev/script-kit-gpui succeeded in 50ms:
    /// Text expansion trigger (e.g., "type,,")
    pub keyword: Option<String>,
    /// Alias trigger - when user types alias + space, immediately run script
    pub alias: Option<String>,
    /// Any additional metadata key-value pairs
    #[serde(flatten)]
    pub extra: HashMap<String, String>,
}
/// An action defined within a scriptlet via H3 header + codefence
///
/// These actions appear in the Actions Menu when the scriptlet is focused.
/// Example markdown:
/// ```markdown
/// ## My Scriptlet
/// ```bash
/// main code
/// ```
///
/// ### Copy to Clipboard
/// <!-- shortcut: cmd+c -->
file update:
diff --git a/src/actions/builders/notes.rs b/src/actions/builders/notes.rs
index 48ba267e97bf2f3da7ecf1a3f78fea59dbc9acab..a2f0007d3327b005960130e6e30f524ceb6b3e9f
--- a/src/actions/builders/notes.rs
+++ b/src/actions/builders/notes.rs
@@ -27,6 +27,25 @@
     pub auto_sizing_enabled: bool,
 }
 
+fn is_blank(value: &str) -> bool {
+    value.trim().is_empty()
+}
+
+fn has_invalid_new_chat_model_info(model: &NewChatModelInfo) -> bool {
+    is_blank(&model.model_id)
+        || is_blank(&model.display_name)
+        || is_blank(&model.provider)
+        || is_blank(&model.provider_display_name)
+}
+
+fn has_invalid_new_chat_preset_info(preset: &NewChatPresetInfo) -> bool {
+    is_blank(&preset.id) || is_blank(&preset.name)
+}
+
+fn has_invalid_note_switcher_note_info(note: &NoteSwitcherNoteInfo) -> bool {
+    is_blank(&note.id) || is_blank(&note.title)
+}
+
 /// Get actions for the Notes window command bar (Cmd+K menu).
 pub fn get_notes_command_bar_actions(info: &NotesInfo) -> Vec<Action> {
     let mut actions = Vec::new();
@@ -367,6 +386,76 @@
             Some("Use Focused Writing preset")
         );
     }
+
+    #[test]
+    fn test_get_new_chat_actions_returns_empty_when_last_used_model_input_is_invalid() {
+        let last_used = vec![NewChatModelInfo {
+            model_id: "   ".to_string(),
+            display_name: "GPT-4o Mini".to_string(),
+            provider: "openai".to_string(),
+            provider_display_name: "OpenAI".to_string(),
+        }];
+        let presets = vec![NewChatPresetInfo {
+            id: "focused-writing".to_string(),
+            name: "Focused Writing".to_string(),
+            icon: IconName::Pencil,
+        }];
+
+        let actions = get_new_chat_actions(&last_used, &presets, &[]);
+        assert!(actions.is_empty());
+    }
+
+    #[test]
+    fn test_get_new_chat_actions_returns_empty_when_preset_input_is_invalid() {
+        let last_used = vec![NewChatModelInfo {
+            model_id: "gpt-4o-mini".to_string(),
+            display_name: "GPT-4o Mini".to_string(),
+            provider: "openai".to_string(),
+            provider_display_name: "OpenAI".to_string(),
+        }];
+        let presets = vec![NewChatPresetInfo {
+            id: "   ".to_string(),
+            name: "Focused Writing".to_string(),
+            icon: IconName::Pencil,
+        }];
+
+        let actions = get_new_chat_actions(&last_used, &presets, &[]);
+        assert!(actions.is_empty());
+    }
+
+    #[test]
+    fn test_get_new_chat_actions_returns_empty_when_model_input_is_invalid() {
+        let presets = vec![NewChatPresetInfo {
+            id: "focused-writing".to_string(),
+            name: "Focused Writing".to_string(),
+            icon: IconName::Pencil,
+        }];
+        let models = vec![NewChatModelInfo {
+            model_id: "claude-3-5-sonnet".to_string(),
+            display_name: "Claude 3.5 Sonnet".to_string(),
+            provider: "   ".to_string(),
+            provider_display_name: "Anthropic".to_string(),
+        }];
+
+        let actions = get_new_chat_actions(&[], &presets, &models);
+        assert!(actions.is_empty());
+    }
+
+    #[test]
+    fn test_get_note_switcher_actions_returns_empty_when_note_input_is_invalid() {
+        let notes = vec![NoteSwitcherNoteInfo {
+            id: "   ".to_string(),
+            title: "Missing ID".to_string(),
+            char_count: 5,
+            is_current: false,
+            is_pinned: false,
+            preview: "Preview".to_string(),
+            relative_time: "1m ago".to_string(),
+        }];
+
+        let actions = get_note_switcher_actions(&notes);
+        assert!(actions.is_empty());
+    }
 }
 
 /// Build actions for the AI new chat dropdown.
@@ -376,6 +465,48 @@
     presets: &[NewChatPresetInfo],
     models: &[NewChatModelInfo],
 ) -> Vec<Action> {
+    let invalid_last_used_count = last_used
+        .iter()
+        .filter(|model| has_invalid_new_chat_model_info(model))
+        .count();
+    if invalid_last_used_count > 0 {
+        tracing::warn!(
+            target: "script_kit::actions",
+            builder = "notes_new_chat",
+            invalid_last_used_count,
+            "Invalid last-used chat model input; returning empty actions"
+        );
+        return vec![];
+    }
+
+    let invalid_preset_count = presets
+        .iter()
+        .filter(|preset| has_invalid_new_chat_preset_info(preset))
+        .count();
+    if invalid_preset_count > 0 {
+        tracing::warn!(
+            target: "script_kit::actions",
+            builder = "notes_new_chat",
+            invalid_preset_count,
+            "Invalid chat preset input; returning empty actions"
+        );
+        return vec![];
+    }
+
+    let invalid_model_count = models
+        .iter()
+        .filter(|model| has_invalid_new_chat_model_info(model))
+        .count();
+    if invalid_model_count > 0 {
+        tracing::warn!(
+            target: "script_kit::actions",
+            builder = "notes_new_chat",
+            invalid_model_count,
+            "Invalid chat model input; returning empty actions"
+        );
+        return vec![];
+    }
+
     let mut actions = Vec::new();
 
     for setting in last_used {
@@ -442,6 +573,21 @@
 
 /// Get actions for the note switcher dialog (Cmd+P in Notes window).
 pub fn get_note_switcher_actions(notes: &[NoteSwitcherNoteInfo]) -> Vec<Action> {
+    let invalid_note_count = notes
+        .iter()
+        .filter(|note| has_invalid_note_switcher_note_info(note))
+        .count();
+    if invalid_note_count > 0 {
+        tracing::warn!(
+            target: "script_kit::actions",
+            builder = "note_switcher",
+            note_count = notes.len(),
+            invalid_note_count,
+            "Invalid note switcher input; returning empty actions"
+        );
+        return vec![];
+    }
+
     let mut actions = Vec::new();
 
     for note in notes {
diff --git a/src/actions/builders/script_context.rs b/src/actions/builders/script_context.rs
index d48add6d0604e4fc8ab6bc1d9a9cdc328a6037ab..c09068069325e288d1c697a6ed9aa07944aadf61
--- a/src/actions/builders/script_context.rs
+++ b/src/actions/builders/script_context.rs
@@ -2,8 +2,23 @@
 use super::types::{Action, ActionCategory, ScriptInfo};
 use std::collections::HashSet;
 
+fn has_invalid_script_context_input(script: &ScriptInfo) -> bool {
+    script.name.trim().is_empty() || script.action_verb.trim().is_empty()
+}
+
 /// Get actions specific to the focused script.
 pub fn get_script_context_actions(script: &ScriptInfo) -> Vec<Action> {
+    if has_invalid_script_context_input(script) {
+        tracing::warn!(
+            target: "script_kit::actions",
+            builder = "script_context",
+            name = %script.name,
+            action_verb = %script.action_verb,
+            "Invalid script context input; returning empty actions"
+        );
+        return vec![];
+    }
+
     let mut actions = Vec::new();
     let mut destructive_actions = Vec::new();
 
@@ -314,3 +329,26 @@
 pub fn get_global_actions() -> Vec<Action> {
     vec![]
 }
+
+#[cfg(test)]
+mod tests {
+    use super::*;
+
+    #[test]
+    fn test_get_script_context_actions_returns_empty_when_name_is_blank() {
+        let mut script = ScriptInfo::new("Valid", "/tmp/valid.ts");
+        script.name = "   ".to_string();
+
+        let actions = get_script_context_actions(&script);
+        assert!(actions.is_empty());
+    }
+
+    #[test]
+    fn test_get_script_context_actions_returns_empty_when_action_verb_is_blank() {
+        let mut script = ScriptInfo::new("Valid", "/tmp/valid.ts");
+        script.action_verb = "   ".to_string();
+
+        let actions = get_script_context_actions(&script);
+        assert!(actions.is_empty());
+    }
+}


thinking
**Designing comprehensive scriptlet validation**
codex
I’m editing `scriptlet.rs` now: adding explicit invalid-input guards (warn + empty vec), removing partial malformed-action drops, and updating tests so invalid custom actions fail the whole builder consistently.
file update
M /Users/johnlindquist/dev/script-kit-gpui/src/actions/builders/scriptlet.rs
@@ -3,3 +3,3 @@
 use crate::designs::icon_variations::IconName;
-use crate::scriptlets::Scriptlet;
+use crate::scriptlets::{Scriptlet, ScriptletAction};
 use std::collections::HashSet;
@@ -8,2 +8,22 @@
 
+fn is_blank(value: &str) -> bool {
+    value.trim().is_empty()
+}
+
+fn has_invalid_scriptlet_context_input(script: &ScriptInfo) -> bool {
+    is_blank(&script.name) || is_blank(&script.action_verb)
+}
+
+fn has_invalid_scriptlet_action_input(action: &ScriptletAction) -> bool {
+    is_blank(&action.name) || is_blank(&action.command)
+}
+
+fn count_invalid_scriptlet_actions(scriptlet: &Scriptlet) -> usize {
+    scriptlet
+        .actions
+        .iter()
+        .filter(|action| has_invalid_scriptlet_action_input(action))
+        .count()
+}
+
 fn parse_scriptlet_action_command(action_id: &str) -> Option<&str> {
@@ -16,14 +36,5 @@
     raw_action_id: &str,
-    action_name: &str,
     used_action_ids: &mut HashSet<String>,
 ) -> Option<String> {
-    let Some(action_command) = parse_scriptlet_action_command(raw_action_id) else {
-        tracing::warn!(
-            target: "script_kit::actions",
-            action_name = %action_name,
-            action_id = %raw_action_id,
-            "Failed to parse scriptlet H3 action id; dropping malformed action"
-        );
-        return None;
-    };
+    let action_command = parse_scriptlet_action_command(raw_action_id)?;
 
@@ -53,36 +64,58 @@
 pub fn get_scriptlet_defined_actions(scriptlet: &Scriptlet) -> Vec<Action> {
+    let invalid_action_count = count_invalid_scriptlet_actions(scriptlet);
+    if invalid_action_count > 0 {
+        tracing::warn!(
+            target: "script_kit::actions",
+            builder = "scriptlet_defined",
+            scriptlet_name = %scriptlet.name,
+            action_count = scriptlet.actions.len(),
+            invalid_action_count,
+            "Invalid scriptlet-defined action input; returning empty actions"
+        );
+        return vec![];
+    }
+
     let mut used_action_ids = HashSet::new();
-    let actions: Vec<Action> = scriptlet
-        .actions
-        .iter()
-        .filter_map(|sa| {
-            let raw_action_id = sa.action_id();
-            let action_id =
-                unique_scriptlet_action_id(&raw_action_id, &sa.name, &mut used_action_ids)?;
-            let mut action = Action::new(
-                action_id,
-                &sa.name,
-                sa.description.clone(),
-                ActionCategory::ScriptContext,
+    let mut actions: Vec<Action> = Vec::with_capacity(scriptlet.actions.len());
+
+    for sa in &scriptlet.actions {
+        let raw_action_id = sa.action_id();
+        let Some(action_id) = unique_scriptlet_action_id(&raw_action_id, &mut used_action_ids)
+        else {
+            tracing::warn!(
+                target: "script_kit::actions",
+                builder = "scriptlet_defined",
+                scriptlet_name = %scriptlet.name,
+                action_name = %sa.name,
+                action_id = %raw_action_id,
+                "Invalid scriptlet action id input; returning empty actions"
             );
+            return vec![];
+        };
 
-            if let Some(ref shortcut) = sa.shortcut {
-                action = action.with_shortcut(format_shortcut_hint(shortcut));
-            }
+        let mut action = Action::new(
+            action_id,
+            &sa.name,
+            sa.description.clone(),
+            ActionCategory::ScriptContext,
+        );
 
-            action = action.with_icon(IconName::PlayFilled).with_section("Actions");
-            action.has_action = true;
-            action.value = Some(sa.command.clone());
+        if let Some(ref shortcut) = sa.shortcut {
+            action = action.with_shortcut(format_shortcut_hint(shortcut));
+        }
 
-            tracing::debug!(
-                target: "script_kit::actions",
-                action_id = %action.id,
-                has_action = action.has_action,
-                has_shortcut = action.shortcut.is_some(),
-                "Created scriptlet-defined action (has_action=true)"
-            );
+        action = action.with_icon(IconName::PlayFilled).with_section("Actions");
+        action.has_action = true;
+        action.value = Some(sa.command.clone());
+
+        tracing::debug!(
+            target: "script_kit::actions",
+            action_id = %action.id,
+            has_action = action.has_action,
+            has_shortcut = action.shortcut.is_some(),
+            "Created scriptlet-defined action (has_action=true)"
+        );
 
-            Some(action)
-        })
-        .collect();
+        actions.push(action);
+    }
 
@@ -105,2 +138,28 @@
 ) -> Vec<Action> {
+    if has_invalid_scriptlet_context_input(script) {
+        tracing::warn!(
+            target: "script_kit::actions",
+            builder = "scriptlet_context",
+            name = %script.name,
+            action_verb = %script.action_verb,
+            "Invalid scriptlet context input; returning empty actions"
+        );
+        return vec![];
+    }
+
+    if let Some(scriptlet) = scriptlet {
+        let invalid_action_count = count_invalid_scriptlet_actions(scriptlet);
+        if invalid_action_count > 0 {
+            tracing::warn!(
+                target: "script_kit::actions",
+                builder = "scriptlet_context",
+                scriptlet_name = %scriptlet.name,
+                action_count = scriptlet.actions.len(),
+                invalid_action_count,
+                "Invalid scriptlet-defined action input; returning empty actions"
+            );
+            return vec![];
+        }
+    }
+
     let mut actions = Vec::new();
@@ -344,3 +403,3 @@
     #[test]
-    fn test_get_scriptlet_defined_actions_drops_action_when_command_is_empty() {
+    fn test_get_scriptlet_defined_actions_returns_empty_when_command_is_empty() {
         let mut scriptlet = Scriptlet::new(
@@ -357,2 +416,49 @@
     #[test]
+    fn test_get_scriptlet_defined_actions_returns_empty_when_any_action_is_invalid() {
+        let mut scriptlet = Scriptlet::new(
+            "Mixed".to_string(),
+            "bash".to_string(),
+            "echo".to_string(),
+        );
+        scriptlet.actions = vec![
+            scriptlet_action("Valid", "copy"),
+            scriptlet_action("   ", "invalid"),
+        ];
+
+        let actions = get_scriptlet_defined_actions(&scriptlet);
+        assert!(actions.is_empty());
+    }
+
+    #[test]
+    fn test_get_scriptlet_context_actions_returns_empty_when_script_name_is_blank() {
+        let mut script =
+            ScriptInfo::scriptlet("Demo", "/tmp/demo.md", Some("cmd d".to_string()), None);
+        script.name = "   ".to_string();
+
+        let actions = get_scriptlet_context_actions_with_custom(&script, None);
+        assert!(actions.is_empty());
+    }
+
+    #[test]
+    fn test_get_scriptlet_context_actions_returns_empty_when_action_verb_is_blank() {
+        let mut script =
+            ScriptInfo::scriptlet("Demo", "/tmp/demo.md", Some("cmd d".to_string()), None);
+        script.action_verb = "   ".to_string();
+
+        let actions = get_scriptlet_context_actions_with_custom(&script, None);
+        assert!(actions.is_empty());
+    }
+
+    #[test]
+    fn test_get_scriptlet_context_actions_returns_empty_when_scriptlet_action_input_is_invalid() {
+        let script = ScriptInfo::scriptlet("Demo", "/tmp/demo.md", Some("cmd d".to_string()), None);
+        let mut scriptlet =
+            Scriptlet::new("Malformed".to_string(), "bash".to_string(), "echo".to_string());
+        scriptlet.actions = vec![scriptlet_action("Bad", "   ")];
+
+        let actions = get_scriptlet_context_actions_with_custom(&script, Some(&scriptlet));
+        assert!(actions.is_empty());
+    }
+
+    #[test]
     fn test_get_scriptlet_context_actions_assigns_consistent_primary_icons() {
apply_patch(auto_approved=true) exited 0 in 20ms:
Success. Updated the following files:
M src/actions/builders/scriptlet.rs
file update:
diff --git a/src/actions/builders/notes.rs b/src/actions/builders/notes.rs
index 48ba267e97bf2f3da7ecf1a3f78fea59dbc9acab..a2f0007d3327b005960130e6e30f524ceb6b3e9f
--- a/src/actions/builders/notes.rs
+++ b/src/actions/builders/notes.rs
@@ -27,6 +27,25 @@
     pub auto_sizing_enabled: bool,
 }
 
+fn is_blank(value: &str) -> bool {
+    value.trim().is_empty()
+}
+
+fn has_invalid_new_chat_model_info(model: &NewChatModelInfo) -> bool {
+    is_blank(&model.model_id)
+        || is_blank(&model.display_name)
+        || is_blank(&model.provider)
+        || is_blank(&model.provider_display_name)
+}
+
+fn has_invalid_new_chat_preset_info(preset: &NewChatPresetInfo) -> bool {
+    is_blank(&preset.id) || is_blank(&preset.name)
+}
+
+fn has_invalid_note_switcher_note_info(note: &NoteSwitcherNoteInfo) -> bool {
+    is_blank(&note.id) || is_blank(&note.title)
+}
+
 /// Get actions for the Notes window command bar (Cmd+K menu).
 pub fn get_notes_command_bar_actions(info: &NotesInfo) -> Vec<Action> {
     let mut actions = Vec::new();
@@ -367,6 +386,76 @@
             Some("Use Focused Writing preset")
         );
     }
+
+    #[test]
+    fn test_get_new_chat_actions_returns_empty_when_last_used_model_input_is_invalid() {
+        let last_used = vec![NewChatModelInfo {
+            model_id: "   ".to_string(),
+            display_name: "GPT-4o Mini".to_string(),
+            provider: "openai".to_string(),
+            provider_display_name: "OpenAI".to_string(),
+        }];
+        let presets = vec![NewChatPresetInfo {
+            id: "focused-writing".to_string(),
+            name: "Focused Writing".to_string(),
+            icon: IconName::Pencil,
+        }];
+
+        let actions = get_new_chat_actions(&last_used, &presets, &[]);
+        assert!(actions.is_empty());
+    }
+
+    #[test]
+    fn test_get_new_chat_actions_returns_empty_when_preset_input_is_invalid() {
+        let last_used = vec![NewChatModelInfo {
+            model_id: "gpt-4o-mini".to_string(),
+            display_name: "GPT-4o Mini".to_string(),
+            provider: "openai".to_string(),
+            provider_display_name: "OpenAI".to_string(),
+        }];
+        let presets = vec![NewChatPresetInfo {
+            id: "   ".to_string(),
+            name: "Focused Writing".to_string(),
+            icon: IconName::Pencil,
+        }];
+
+        let actions = get_new_chat_actions(&last_used, &presets, &[]);
+        assert!(actions.is_empty());
+    }
+
+    #[test]
+    fn test_get_new_chat_actions_returns_empty_when_model_input_is_invalid() {
+        let presets = vec![NewChatPresetInfo {
+            id: "focused-writing".to_string(),
+            name: "Focused Writing".to_string(),
+            icon: IconName::Pencil,
+        }];
+        let models = vec![NewChatModelInfo {
+            model_id: "claude-3-5-sonnet".to_string(),
+            display_name: "Claude 3.5 Sonnet".to_string(),
+            provider: "   ".to_string(),
+            provider_display_name: "Anthropic".to_string(),
+        }];
+
+        let actions = get_new_chat_actions(&[], &presets, &models);
+        assert!(actions.is_empty());
+    }
+
+    #[test]
+    fn test_get_note_switcher_actions_returns_empty_when_note_input_is_invalid() {
+        let notes = vec![NoteSwitcherNoteInfo {
+            id: "   ".to_string(),
+            title: "Missing ID".to_string(),
+            char_count: 5,
+            is_current: false,
+            is_pinned: false,
+            preview: "Preview".to_string(),
+            relative_time: "1m ago".to_string(),
+        }];
+
+        let actions = get_note_switcher_actions(&notes);
+        assert!(actions.is_empty());
+    }
 }
 
 /// Build actions for the AI new chat dropdown.
@@ -376,6 +465,48 @@
     presets: &[NewChatPresetInfo],
     models: &[NewChatModelInfo],
 ) -> Vec<Action> {
+    let invalid_last_used_count = last_used
+        .iter()
+        .filter(|model| has_invalid_new_chat_model_info(model))
+        .count();
+    if invalid_last_used_count > 0 {
+        tracing::warn!(
+            target: "script_kit::actions",
+            builder = "notes_new_chat",
+            invalid_last_used_count,
+            "Invalid last-used chat model input; returning empty actions"
+        );
+        return vec![];
+    }
+
+    let invalid_preset_count = presets
+        .iter()
+        .filter(|preset| has_invalid_new_chat_preset_info(preset))
+        .count();
+    if invalid_preset_count > 0 {
+        tracing::warn!(
+            target: "script_kit::actions",
+            builder = "notes_new_chat",
+            invalid_preset_count,
+            "Invalid chat preset input; returning empty actions"
+        );
+        return vec![];
+    }
+
+    let invalid_model_count = models
+        .iter()
+        .filter(|model| has_invalid_new_chat_model_info(model))
+        .count();
+    if invalid_model_count > 0 {
+        tracing::warn!(
+            target: "script_kit::actions",
+            builder = "notes_new_chat",
+            invalid_model_count,
+            "Invalid chat model input; returning empty actions"
+        );
+        return vec![];
+    }
+
     let mut actions = Vec::new();
 
     for setting in last_used {
@@ -442,6 +573,21 @@
 
 /// Get actions for the note switcher dialog (Cmd+P in Notes window).
 pub fn get_note_switcher_actions(notes: &[NoteSwitcherNoteInfo]) -> Vec<Action> {
+    let invalid_note_count = notes
+        .iter()
+        .filter(|note| has_invalid_note_switcher_note_info(note))
+        .count();
+    if invalid_note_count > 0 {
+        tracing::warn!(
+            target: "script_kit::actions",
+            builder = "note_switcher",
+            note_count = notes.len(),
+            invalid_note_count,
+            "Invalid note switcher input; returning empty actions"
+        );
+        return vec![];
+    }
+
     let mut actions = Vec::new();
 
     for note in notes {
diff --git a/src/actions/builders/script_context.rs b/src/actions/builders/script_context.rs
index d48add6d0604e4fc8ab6bc1d9a9cdc328a6037ab..c09068069325e288d1c697a6ed9aa07944aadf61
--- a/src/actions/builders/script_context.rs
+++ b/src/actions/builders/script_context.rs
@@ -2,8 +2,23 @@
 use super::types::{Action, ActionCategory, ScriptInfo};
 use std::collections::HashSet;
 
+fn has_invalid_script_context_input(script: &ScriptInfo) -> bool {
+    script.name.trim().is_empty() || script.action_verb.trim().is_empty()
+}
+
 /// Get actions specific to the focused script.
 pub fn get_script_context_actions(script: &ScriptInfo) -> Vec<Action> {
+    if has_invalid_script_context_input(script) {
+        tracing::warn!(
+            target: "script_kit::actions",
+            builder = "script_context",
+            name = %script.name,
+            action_verb = %script.action_verb,
+            "Invalid script context input; returning empty actions"
+        );
+        return vec![];
+    }
+
     let mut actions = Vec::new();
     let mut destructive_actions = Vec::new();
 
@@ -314,3 +329,26 @@
 pub fn get_global_actions() -> Vec<Action> {
     vec![]
 }
+
+#[cfg(test)]
+mod tests {
+    use super::*;
+
+    #[test]
+    fn test_get_script_context_actions_returns_empty_when_name_is_blank() {
+        let mut script = ScriptInfo::new("Valid", "/tmp/valid.ts");
+        script.name = "   ".to_string();
+
+        let actions = get_script_context_actions(&script);
+        assert!(actions.is_empty());
+    }
+
+    #[test]
+    fn test_get_script_context_actions_returns_empty_when_action_verb_is_blank() {
+        let mut script = ScriptInfo::new("Valid", "/tmp/valid.ts");
+        script.action_verb = "   ".to_string();
+
+        let actions = get_script_context_actions(&script);
+        assert!(actions.is_empty());
+    }
+}
diff --git a/src/actions/builders/scriptlet.rs b/src/actions/builders/scriptlet.rs
index 371dbac6d433b01ee915aebdcd5f371b952065da..29d118adfe8a10c98b5c24a331a6773a556b1b80
--- a/src/actions/builders/scriptlet.rs
+++ b/src/actions/builders/scriptlet.rs
@@ -1,11 +1,31 @@
 use super::shared::{format_shortcut_hint, to_deeplink_name};
 use super::types::{Action, ActionCategory, ScriptInfo};
 use crate::designs::icon_variations::IconName;
-use crate::scriptlets::Scriptlet;
+use crate::scriptlets::{Scriptlet, ScriptletAction};
 use std::collections::HashSet;
 
 const SCRIPTLET_ACTION_ID_PREFIX: &str = "scriptlet_action:";
 
+fn is_blank(value: &str) -> bool {
+    value.trim().is_empty()
+}
+
+fn has_invalid_scriptlet_context_input(script: &ScriptInfo) -> bool {
+    is_blank(&script.name) || is_blank(&script.action_verb)
+}
+
+fn has_invalid_scriptlet_action_input(action: &ScriptletAction) -> bool {
+    is_blank(&action.name) || is_blank(&action.command)
+}
+
+fn count_invalid_scriptlet_actions(scriptlet: &Scriptlet) -> usize {
+    scriptlet
+        .actions
+        .iter()
+        .filter(|action| has_invalid_scriptlet_action_input(action))
+        .count()
+}
+
 fn parse_scriptlet_action_command(action_id: &str) -> Option<&str> {
     action_id
         .strip_prefix(SCRIPTLET_ACTION_ID_PREFIX)
@@ -14,18 +34,9 @@
 
 fn unique_scriptlet_action_id(
     raw_action_id: &str,
-    action_name: &str,
     used_action_ids: &mut HashSet<String>,
 ) -> Option<String> {
-    let Some(action_command) = parse_scriptlet_action_command(raw_action_id) else {
-        tracing::warn!(
-            target: "script_kit::actions",
-            action_name = %action_name,
-            action_id = %raw_action_id,
-            "Failed to parse scriptlet H3 action id; dropping malformed action"
-        );
-        return None;
-    };
+    let action_command = parse_scriptlet_action_command(raw_action_id)?;
 
     let mut unique_action_id = raw_action_id.to_string();
     let mut duplicate_index = 2;
@@ -51,40 +62,62 @@
 
 /// Convert scriptlet-defined actions (from H3 headers) to Action structs for the UI.
 pub fn get_scriptlet_defined_actions(scriptlet: &Scriptlet) -> Vec<Action> {
+    let invalid_action_count = count_invalid_scriptlet_actions(scriptlet);
+    if invalid_action_count > 0 {
+        tracing::warn!(
+            target: "script_kit::actions",
+            builder = "scriptlet_defined",
+            scriptlet_name = %scriptlet.name,
+            action_count = scriptlet.actions.len(),
+            invalid_action_count,
+            "Invalid scriptlet-defined action input; returning empty actions"
+        );
+        return vec![];
+    }
+
     let mut used_action_ids = HashSet::new();
-    let actions: Vec<Action> = scriptlet
-        .actions
-        .iter()
-        .filter_map(|sa| {
-            let raw_action_id = sa.action_id();
-            let action_id =
-                unique_scriptlet_action_id(&raw_action_id, &sa.name, &mut used_action_ids)?;
-            let mut action = Action::new(
-                action_id,
-                &sa.name,
-                sa.description.clone(),
-                ActionCategory::ScriptContext,
+    let mut actions: Vec<Action> = Vec::with_capacity(scriptlet.actions.len());
+
+    for sa in &scriptlet.actions {
+        let raw_action_id = sa.action_id();
+        let Some(action_id) = unique_scriptlet_action_id(&raw_action_id, &mut used_action_ids)
+        else {
+            tracing::warn!(
+                target: "script_kit::actions",
+                builder = "scriptlet_defined",
+                scriptlet_name = %scriptlet.name,
+                action_name = %sa.name,
+                action_id = %raw_action_id,
+                "Invalid scriptlet action id input; returning empty actions"
             );
+            return vec![];
+        };
 
-            if let Some(ref shortcut) = sa.shortcut {
-                action = action.with_shortcut(format_shortcut_hint(shortcut));
-            }
+        let mut action = Action::new(
+            action_id,
+            &sa.name,
+            sa.description.clone(),
+            ActionCategory::ScriptContext,
+        );
 
-            action = action.with_icon(IconName::PlayFilled).with_section("Actions");
-            action.has_action = true;
-            action.value = Some(sa.command.clone());
+        if let Some(ref shortcut) = sa.shortcut {
+            action = action.with_shortcut(format_shortcut_hint(shortcut));
+        }
 
-            tracing::debug!(
-                target: "script_kit::actions",
-                action_id = %action.id,
-                has_action = action.has_action,
-                has_shortcut = action.shortcut.is_some(),
-                "Created scriptlet-defined action (has_action=true)"
-            );
+        action = action.with_icon(IconName::PlayFilled).with_section("Actions");
+        action.has_action = true;
+        action.value = Some(sa.command.clone());
+
+        tracing::debug!(
+            target: "script_kit::actions",
+            action_id = %action.id,
+            has_action = action.has_action,
+            has_shortcut = action.shortcut.is_some(),
+            "Created scriptlet-defined action (has_action=true)"
+        );
 
-            Some(action)
-        })
-        .collect();
+        actions.push(action);
+    }
 
     if !actions.is_empty() {
         tracing::debug!(
@@ -103,6 +136,32 @@
     script: &ScriptInfo,
     scriptlet: Option<&Scriptlet>,
 ) -> Vec<Action> {
+    if has_invalid_scriptlet_context_input(script) {
+        tracing::warn!(
+            target: "script_kit::actions",
+            builder = "scriptlet_context",
+            name = %script.name,
+            action_verb = %script.action_verb,
+            "Invalid scriptlet context input; returning empty actions"
+        );
+        return vec![];
+    }
+
+    if let Some(scriptlet) = scriptlet {
+        let invalid_action_count = count_invalid_scriptlet_actions(scriptlet);
+        if invalid_action_count > 0 {
+            tracing::warn!(
+                target: "script_kit::actions",
+                builder = "scriptlet_context",
+                scriptlet_name = %scriptlet.name,
+                action_count = scriptlet.actions.len(),
+                invalid_action_count,
+                "Invalid scriptlet-defined action input; returning empty actions"
+            );
+            return vec![];
+        }
+    }
+
     let mut actions = Vec::new();
     let mut destructive_actions = Vec::new();
 
@@ -342,7 +401,7 @@
     }
 
     #[test]
-    fn test_get_scriptlet_defined_actions_drops_action_when_command_is_empty() {
+    fn test_get_scriptlet_defined_actions_returns_empty_when_command_is_empty() {
         let mut scriptlet = Scriptlet::new(
             "Malformed".to_string(),
             "bash".to_string(),
@@ -355,6 +414,53 @@
     }
 
     #[test]
+    fn test_get_scriptlet_defined_actions_returns_empty_when_any_action_is_invalid() {
+        let mut scriptlet = Scriptlet::new(
+            "Mixed".to_string(),
+            "bash".to_string(),
+            "echo".to_string(),
+        );
+        scriptlet.actions = vec![
+            scriptlet_action("Valid", "copy"),
+            scriptlet_action("   ", "invalid"),
+        ];
+
+        let actions = get_scriptlet_defined_actions(&scriptlet);
+        assert!(actions.is_empty());
+    }
+
+    #[test]
+    fn test_get_scriptlet_context_actions_returns_empty_when_script_name_is_blank() {
+        let mut script =
+            ScriptInfo::scriptlet("Demo", "/tmp/demo.md", Some("cmd d".to_string()), None);
+        script.name = "   ".to_string();
+
+        let actions = get_scriptlet_context_actions_with_custom(&script, None);
+        assert!(actions.is_empty());
+    }
+
+    #[test]
+    fn test_get_scriptlet_context_actions_returns_empty_when_action_verb_is_blank() {
+        let mut script =
+            ScriptInfo::scriptlet("Demo", "/tmp/demo.md", Some("cmd d".to_string()), None);
+        script.action_verb = "   ".to_string();
+
+        let actions = get_scriptlet_context_actions_with_custom(&script, None);
+        assert!(actions.is_empty());
+    }
+
+    #[test]
+    fn test_get_scriptlet_context_actions_returns_empty_when_scriptlet_action_input_is_invalid() {
+        let script = ScriptInfo::scriptlet("Demo", "/tmp/demo.md", Some("cmd d".to_string()), None);
+        let mut scriptlet =
+            Scriptlet::new("Malformed".to_string(), "bash".to_string(), "echo".to_string());
+        scriptlet.actions = vec![scriptlet_action("Bad", "   ")];
+
+        let actions = get_scriptlet_context_actions_with_custom(&script, Some(&scriptlet));
+        assert!(actions.is_empty());
+    }
+
+    #[test]
     fn test_get_scriptlet_context_actions_assigns_consistent_primary_icons() {
         let script = ScriptInfo::scriptlet("Demo", "/tmp/demo.md", Some("cmd d".to_string()), None);
         let actions = get_scriptlet_context_actions_with_custom(&script, None);

file update:
diff --git a/src/actions/builders/notes.rs b/src/actions/builders/notes.rs
index 48ba267e97bf2f3da7ecf1a3f78fea59dbc9acab..a2f0007d3327b005960130e6e30f524ceb6b3e9f
--- a/src/actions/builders/notes.rs
+++ b/src/actions/builders/notes.rs
@@ -27,6 +27,25 @@
     pub auto_sizing_enabled: bool,
 }
 
+fn is_blank(value: &str) -> bool {
+    value.trim().is_empty()
+}
+
+fn has_invalid_new_chat_model_info(model: &NewChatModelInfo) -> bool {
+    is_blank(&model.model_id)
+        || is_blank(&model.display_name)
+        || is_blank(&model.provider)
+        || is_blank(&model.provider_display_name)
+}
+
+fn has_invalid_new_chat_preset_info(preset: &NewChatPresetInfo) -> bool {
+    is_blank(&preset.id) || is_blank(&preset.name)
+}
+
+fn has_invalid_note_switcher_note_info(note: &NoteSwitcherNoteInfo) -> bool {
+    is_blank(&note.id) || is_blank(&note.title)
+}
+
 /// Get actions for the Notes window command bar (Cmd+K menu).
 pub fn get_notes_command_bar_actions(info: &NotesInfo) -> Vec<Action> {
     let mut actions = Vec::new();
@@ -367,6 +386,76 @@
             Some("Use Focused Writing preset")
         );
     }
+
+    #[test]
+    fn test_get_new_chat_actions_returns_empty_when_last_used_model_input_is_invalid() {
+        let last_used = vec![NewChatModelInfo {
+            model_id: "   ".to_string(),
+            display_name: "GPT-4o Mini".to_string(),
+            provider: "openai".to_string(),
+            provider_display_name: "OpenAI".to_string(),
+        }];
+        let presets = vec![NewChatPresetInfo {
+            id: "focused-writing".to_string(),
+            name: "Focused Writing".to_string(),
+            icon: IconName::Pencil,
+        }];
+
+        let actions = get_new_chat_actions(&last_used, &presets, &[]);
+        assert!(actions.is_empty());
+    }
+
+    #[test]
+    fn test_get_new_chat_actions_returns_empty_when_preset_input_is_invalid() {
+        let last_used = vec![NewChatModelInfo {
+            model_id: "gpt-4o-mini".to_string(),
+            display_name: "GPT-4o Mini".to_string(),
+            provider: "openai".to_string(),
+            provider_display_name: "OpenAI".to_string(),
+        }];
+        let presets = vec![NewChatPresetInfo {
+            id: "   ".to_string(),
+            name: "Focused Writing".to_string(),
+            icon: IconName::Pencil,
+        }];
+
+        let actions = get_new_chat_actions(&last_used, &presets, &[]);
+        assert!(actions.is_empty());
+    }
+
+    #[test]
+    fn test_get_new_chat_actions_returns_empty_when_model_input_is_invalid() {
+        let presets = vec![NewChatPresetInfo {
+            id: "focused-writing".to_string(),
+            name: "Focused Writing".to_string(),
+            icon: IconName::Pencil,
+        }];
+        let models = vec![NewChatModelInfo {
+            model_id: "claude-3-5-sonnet".to_string(),
+            display_name: "Claude 3.5 Sonnet".to_string(),
+            provider: "   ".to_string(),
+            provider_display_name: "Anthropic".to_string(),
+        }];
+
+        let actions = get_new_chat_actions(&[], &presets, &models);
+        assert!(actions.is_empty());
+    }
+
+    #[test]
+    fn test_get_note_switcher_actions_returns_empty_when_note_input_is_invalid() {
+        let notes = vec![NoteSwitcherNoteInfo {
+            id: "   ".to_string(),
+            title: "Missing ID".to_string(),
+            char_count: 5,
+            is_current: false,
+            is_pinned: false,
+            preview: "Preview".to_string(),
+            relative_time: "1m ago".to_string(),
+        }];
+
+        let actions = get_note_switcher_actions(&notes);
+        assert!(actions.is_empty());
+    }
 }
 
 /// Build actions for the AI new chat dropdown.
@@ -376,6 +465,48 @@
     presets: &[NewChatPresetInfo],
     models: &[NewChatModelInfo],
 ) -> Vec<Action> {
+    let invalid_last_used_count = last_used
+        .iter()
+        .filter(|model| has_invalid_new_chat_model_info(model))
+        .count();
+    if invalid_last_used_count > 0 {
+        tracing::warn!(
+            target: "script_kit::actions",
+            builder = "notes_new_chat",
+            invalid_last_used_count,
+            "Invalid last-used chat model input; returning empty actions"
+        );
+        return vec![];
+    }
+
+    let invalid_preset_count = presets
+        .iter()
+        .filter(|preset| has_invalid_new_chat_preset_info(preset))
+        .count();
+    if invalid_preset_count > 0 {
+        tracing::warn!(
+            target: "script_kit::actions",
+            builder = "notes_new_chat",
+            invalid_preset_count,
+            "Invalid chat preset input; returning empty actions"
+        );
+        return vec![];
+    }
+
+    let invalid_model_count = models
+        .iter()
+        .filter(|model| has_invalid_new_chat_model_info(model))
+        .count();
+    if invalid_model_count > 0 {
+        tracing::warn!(
+            target: "script_kit::actions",
+            builder = "notes_new_chat",
+            invalid_model_count,
+            "Invalid chat model input; returning empty actions"
+        );
+        return vec![];
+    }
+
     let mut actions = Vec::new();
 
     for setting in last_used {
@@ -442,6 +573,21 @@
 
 /// Get actions for the note switcher dialog (Cmd+P in Notes window).
 pub fn get_note_switcher_actions(notes: &[NoteSwitcherNoteInfo]) -> Vec<Action> {
+    let invalid_note_count = notes
+        .iter()
+        .filter(|note| has_invalid_note_switcher_note_info(note))
+        .count();
+    if invalid_note_count > 0 {
+        tracing::warn!(
+            target: "script_kit::actions",
+            builder = "note_switcher",
+            note_count = notes.len(),
+            invalid_note_count,
+            "Invalid note switcher input; returning empty actions"
+        );
+        return vec![];
+    }
+
     let mut actions = Vec::new();
 
     for note in notes {
diff --git a/src/actions/builders/script_context.rs b/src/actions/builders/script_context.rs
index d48add6d0604e4fc8ab6bc1d9a9cdc328a6037ab..c09068069325e288d1c697a6ed9aa07944aadf61
--- a/src/actions/builders/script_context.rs
+++ b/src/actions/builders/script_context.rs
@@ -2,8 +2,23 @@
 use super::types::{Action, ActionCategory, ScriptInfo};
 use std::collections::HashSet;
 
+fn has_invalid_script_context_input(script: &ScriptInfo) -> bool {
+    script.name.trim().is_empty() || script.action_verb.trim().is_empty()
+}
+
 /// Get actions specific to the focused script.
 pub fn get_script_context_actions(script: &ScriptInfo) -> Vec<Action> {
+    if has_invalid_script_context_input(script) {
+        tracing::warn!(
+            target: "script_kit::actions",
+            builder = "script_context",
+            name = %script.name,
+            action_verb = %script.action_verb,
+            "Invalid script context input; returning empty actions"
+        );
+        return vec![];
+    }
+
     let mut actions = Vec::new();
     let mut destructive_actions = Vec::new();
 
@@ -314,3 +329,26 @@
 pub fn get_global_actions() -> Vec<Action> {
     vec![]
 }
+
+#[cfg(test)]
+mod tests {
+    use super::*;
+
+    #[test]
+    fn test_get_script_context_actions_returns_empty_when_name_is_blank() {
+        let mut script = ScriptInfo::new("Valid", "/tmp/valid.ts");
+        script.name = "   ".to_string();
+
+        let actions = get_script_context_actions(&script);
+        assert!(actions.is_empty());
+    }
+
+    #[test]
+    fn test_get_script_context_actions_returns_empty_when_action_verb_is_blank() {
+        let mut script = ScriptInfo::new("Valid", "/tmp/valid.ts");
+        script.action_verb = "   ".to_string();
+
+        let actions = get_script_context_actions(&script);
+        assert!(actions.is_empty());
+    }
+}
diff --git a/src/actions/builders/scriptlet.rs b/src/actions/builders/scriptlet.rs
index 371dbac6d433b01ee915aebdcd5f371b952065da..29d118adfe8a10c98b5c24a331a6773a556b1b80
--- a/src/actions/builders/scriptlet.rs
+++ b/src/actions/builders/scriptlet.rs
@@ -1,11 +1,31 @@
 use super::shared::{format_shortcut_hint, to_deeplink_name};
 use super::types::{Action, ActionCategory, ScriptInfo};
 use crate::designs::icon_variations::IconName;
-use crate::scriptlets::Scriptlet;
+use crate::scriptlets::{Scriptlet, ScriptletAction};
 use std::collections::HashSet;
 
 const SCRIPTLET_ACTION_ID_PREFIX: &str = "scriptlet_action:";
 
+fn is_blank(value: &str) -> bool {
+    value.trim().is_empty()
+}
+
+fn has_invalid_scriptlet_context_input(script: &ScriptInfo) -> bool {
+    is_blank(&script.name) || is_blank(&script.action_verb)
+}
+
+fn has_invalid_scriptlet_action_input(action: &ScriptletAction) -> bool {
+    is_blank(&action.name) || is_blank(&action.command)
+}
+
+fn count_invalid_scriptlet_actions(scriptlet: &Scriptlet) -> usize {
+    scriptlet
+        .actions
+        .iter()
+        .filter(|action| has_invalid_scriptlet_action_input(action))
+        .count()
+}
+
 fn parse_scriptlet_action_command(action_id: &str) -> Option<&str> {
     action_id
         .strip_prefix(SCRIPTLET_ACTION_ID_PREFIX)
@@ -14,18 +34,9 @@
 
 fn unique_scriptlet_action_id(
     raw_action_id: &str,
-    action_name: &str,
     used_action_ids: &mut HashSet<String>,
 ) -> Option<String> {
-    let Some(action_command) = parse_scriptlet_action_command(raw_action_id) else {
-        tracing::warn!(
-            target: "script_kit::actions",
-            action_name = %action_name,
-            action_id = %raw_action_id,
-            "Failed to parse scriptlet H3 action id; dropping malformed action"
-        );
-        return None;
-    };
+    let action_command = parse_scriptlet_action_command(raw_action_id)?;
 
     let mut unique_action_id = raw_action_id.to_string();
     let mut duplicate_index = 2;
@@ -51,40 +62,62 @@
 
 /// Convert scriptlet-defined actions (from H3 headers) to Action structs for the UI.
 pub fn get_scriptlet_defined_actions(scriptlet: &Scriptlet) -> Vec<Action> {
+    let invalid_action_count = count_invalid_scriptlet_actions(scriptlet);
+    if invalid_action_count > 0 {
+        tracing::warn!(
+            target: "script_kit::actions",
+            builder = "scriptlet_defined",
+            scriptlet_name = %scriptlet.name,
+            action_count = scriptlet.actions.len(),
+            invalid_action_count,
+            "Invalid scriptlet-defined action input; returning empty actions"
+        );
+        return vec![];
+    }
+
     let mut used_action_ids = HashSet::new();
-    let actions: Vec<Action> = scriptlet
-        .actions
-        .iter()
-        .filter_map(|sa| {
-            let raw_action_id = sa.action_id();
-            let action_id =
-                unique_scriptlet_action_id(&raw_action_id, &sa.name, &mut used_action_ids)?;
-            let mut action = Action::new(
-                action_id,
-                &sa.name,
-                sa.description.clone(),
-                ActionCategory::ScriptContext,
+    let mut actions: Vec<Action> = Vec::with_capacity(scriptlet.actions.len());
+
+    for sa in &scriptlet.actions {
+        let raw_action_id = sa.action_id();
+        let Some(action_id) = unique_scriptlet_action_id(&raw_action_id, &mut used_action_ids)
+        else {
+            tracing::warn!(
+                target: "script_kit::actions",
+                builder = "scriptlet_defined",
+                scriptlet_name = %scriptlet.name,
+                action_name = %sa.name,
+                action_id = %raw_action_id,
+                "Invalid scriptlet action id input; returning empty actions"
             );
+            return vec![];
+        };
 
-            if let Some(ref shortcut) = sa.shortcut {
-                action = action.with_shortcut(format_shortcut_hint(shortcut));
-            }
+        let mut action = Action::new(
+            action_id,
+            &sa.name,
+            sa.description.clone(),
+            ActionCategory::ScriptContext,
+        );
 
-            action = action.with_icon(IconName::PlayFilled).with_section("Actions");
-            action.has_action = true;
-            action.value = Some(sa.command.clone());
+        if let Some(ref shortcut) = sa.shortcut {
+            action = action.with_shortcut(format_shortcut_hint(shortcut));
+        }
 
-            tracing::debug!(
-                target: "script_kit::actions",
-                action_id = %action.id,
-                has_action = action.has_action,
-                has_shortcut = action.shortcut.is_some(),
-                "Created scriptlet-defined action (has_action=true)"
-            );
+        action = action.with_icon(IconName::PlayFilled).with_section("Actions");
+        action.has_action = true;
+        action.value = Some(sa.command.clone());
+
+        tracing::debug!(
+            target: "script_kit::actions",
+            action_id = %action.id,
+            has_action = action.has_action,
+            has_shortcut = action.shortcut.is_some(),
+            "Created scriptlet-defined action (has_action=true)"
+        );
 
-            Some(action)
-        })
-        .collect();
+        actions.push(action);
+    }
 
     if !actions.is_empty() {
         tracing::debug!(
@@ -103,6 +136,32 @@
     script: &ScriptInfo,
     scriptlet: Option<&Scriptlet>,
 ) -> Vec<Action> {
+    if has_invalid_scriptlet_context_input(script) {
+        tracing::warn!(
+            target: "script_kit::actions",
+            builder = "scriptlet_context",
+            name = %script.name,
+            action_verb = %script.action_verb,
+            "Invalid scriptlet context input; returning empty actions"
+        );
+        return vec![];
+    }
+
+    if let Some(scriptlet) = scriptlet {
+        let invalid_action_count = count_invalid_scriptlet_actions(scriptlet);
+        if invalid_action_count > 0 {
+            tracing::warn!(
+                target: "script_kit::actions",
+                builder = "scriptlet_context",
+                scriptlet_name = %scriptlet.name,
+                action_count = scriptlet.actions.len(),
+                invalid_action_count,
+                "Invalid scriptlet-defined action input; returning empty actions"
+            );
+            return vec![];
+        }
+    }
+
     let mut actions = Vec::new();
     let mut destructive_actions = Vec::new();
 
@@ -342,7 +401,7 @@
     }
 
     #[test]
-    fn test_get_scriptlet_defined_actions_drops_action_when_command_is_empty() {
+    fn test_get_scriptlet_defined_actions_returns_empty_when_command_is_empty() {
         let mut scriptlet = Scriptlet::new(
             "Malformed".to_string(),
             "bash".to_string(),
@@ -355,6 +414,53 @@
     }
 
     #[test]
+    fn test_get_scriptlet_defined_actions_returns_empty_when_any_action_is_invalid() {
+        let mut scriptlet = Scriptlet::new(
+            "Mixed".to_string(),
+            "bash".to_string(),
+            "echo".to_string(),
+        );
+        scriptlet.actions = vec![
+            scriptlet_action("Valid", "copy"),
+            scriptlet_action("   ", "invalid"),
+        ];
+
+        let actions = get_scriptlet_defined_actions(&scriptlet);
+        assert!(actions.is_empty());
+    }
+
+    #[test]
+    fn test_get_scriptlet_context_actions_returns_empty_when_script_name_is_blank() {
+        let mut script =
+            ScriptInfo::scriptlet("Demo", "/tmp/demo.md", Some("cmd d".to_string()), None);
+        script.name = "   ".to_string();
+
+        let actions = get_scriptlet_context_actions_with_custom(&script, None);
+        assert!(actions.is_empty());
+    }
+
+    #[test]
+    fn test_get_scriptlet_context_actions_returns_empty_when_action_verb_is_blank() {
+        let mut script =
+            ScriptInfo::scriptlet("Demo", "/tmp/demo.md", Some("cmd d".to_string()), None);
+        script.action_verb = "   ".to_string();
+
+        let actions = get_scriptlet_context_actions_with_custom(&script, None);
+        assert!(actions.is_empty());
+    }
+
+    #[test]
+    fn test_get_scriptlet_context_actions_returns_empty_when_scriptlet_action_input_is_invalid() {
+        let script = ScriptInfo::scriptlet("Demo", "/tmp/demo.md", Some("cmd d".to_string()), None);
+        let mut scriptlet =
+            Scriptlet::new("Malformed".to_string(), "bash".to_string(), "echo".to_string());
+        scriptlet.actions = vec![scriptlet_action("Bad", "   ")];
+
+        let actions = get_scriptlet_context_actions_with_custom(&script, Some(&scriptlet));
+        assert!(actions.is_empty());
+    }
+
+    #[test]
     fn test_get_scriptlet_context_actions_assigns_consistent_primary_icons() {
         let script = ScriptInfo::scriptlet("Demo", "/tmp/demo.md", Some("cmd d".to_string()), None);
         let actions = get_scriptlet_context_actions_with_custom(&script, None);


thinking
**Planning selective checks and tests**
codex
`scriptlet.rs` edits are in. I’m running scoped Rust tests for the new/changed builder behaviors next, then I’ll run `cargo check` and `cargo clippy` in package scope to satisfy the assignment while avoiding full-workspace commands.
exec
/bin/zsh -lc 'cargo test -p script-kit-gpui test_get_new_chat_actions_returns_empty_when_model_input_is_invalid -- --exact' in /Users/johnlindquist/dev/script-kit-gpuiexec
/bin/zsh -lc 'cargo test -p script-kit-gpui test_get_script_context_actions_returns_empty_when_action_verb_is_blank -- --exact' in /Users/johnlindquist/dev/script-kit-gpuiexec
/bin/zsh -lc 'cargo test -p script-kit-gpui test_get_scriptlet_context_actions_returns_empty_when_scriptlet_action_input_is_invalid -- --exact' in /Users/johnlindquist/dev/script-kit-gpui exited 101 in 19.00s:
    Blocking waiting for file lock on package cache
    Blocking waiting for file lock on package cache
   Compiling script-kit-gpui v0.1.0 (/Users/johnlindquist/dev/script-kit-gpui)
error[E0761]: file for module `tests` found at both "src/protocol/message/tests.rs" and "src/protocol/message/tests/mod.rs"
  --> src/protocol/message/mod.rs:87:1
   |
87 | mod tests;
   | ^^^^^^^^^^
   |
   = help: delete or rename one of them to remove the ambiguity

error[E0761]: file for module `tests` found at both "src/designs/core/tests.rs" and "src/designs/core/tests/mod.rs"
 --> src/designs/core/part_04.rs:2:1
  |
2 | mod tests;
  | ^^^^^^^^^^
  |
  = help: delete or rename one of them to remove the ambiguity

error[E0425]: cannot find value `action_name` in this scope
file update:
diff --git a/src/actions/builders/notes.rs b/src/actions/builders/notes.rs
index 48ba267e97bf2f3da7ecf1a3f78fea59dbc9acab..a2f0007d3327b005960130e6e30f524ceb6b3e9f
--- a/src/actions/builders/notes.rs
+++ b/src/actions/builders/notes.rs
@@ -27,6 +27,25 @@
     pub auto_sizing_enabled: bool,
 }
 
+fn is_blank(value: &str) -> bool {
+    value.trim().is_empty()
+}
+
+fn has_invalid_new_chat_model_info(model: &NewChatModelInfo) -> bool {
+    is_blank(&model.model_id)
+        || is_blank(&model.display_name)
+        || is_blank(&model.provider)
+        || is_blank(&model.provider_display_name)
+}
+
+fn has_invalid_new_chat_preset_info(preset: &NewChatPresetInfo) -> bool {
+    is_blank(&preset.id) || is_blank(&preset.name)
+}
+
+fn has_invalid_note_switcher_note_info(note: &NoteSwitcherNoteInfo) -> bool {
+    is_blank(&note.id) || is_blank(&note.title)
+}
+
 /// Get actions for the Notes window command bar (Cmd+K menu).
 pub fn get_notes_command_bar_actions(info: &NotesInfo) -> Vec<Action> {
     let mut actions = Vec::new();
@@ -367,6 +386,76 @@
             Some("Use Focused Writing preset")
         );
     }
+
+    #[test]
+    fn test_get_new_chat_actions_returns_empty_when_last_used_model_input_is_invalid() {
+        let last_used = vec![NewChatModelInfo {
+            model_id: "   ".to_string(),
+            display_name: "GPT-4o Mini".to_string(),
+            provider: "openai".to_string(),
+            provider_display_name: "OpenAI".to_string(),
+        }];
+        let presets = vec![NewChatPresetInfo {
+            id: "focused-writing".to_string(),
+            name: "Focused Writing".to_string(),
+            icon: IconName::Pencil,
+        }];
+
+        let actions = get_new_chat_actions(&last_used, &presets, &[]);
+        assert!(actions.is_empty());
+    }
+
+    #[test]
+    fn test_get_new_chat_actions_returns_empty_when_preset_input_is_invalid() {
+        let last_used = vec![NewChatModelInfo {
+            model_id: "gpt-4o-mini".to_string(),
+            display_name: "GPT-4o Mini".to_string(),
+            provider: "openai".to_string(),
+            provider_display_name: "OpenAI".to_string(),
+        }];
+        let presets = vec![NewChatPresetInfo {
+            id: "   ".to_string(),
+            name: "Focused Writing".to_string(),
+            icon: IconName::Pencil,
+        }];
+
+        let actions = get_new_chat_actions(&last_used, &presets, &[]);
+        assert!(actions.is_empty());
+    }
+
+    #[test]
+    fn test_get_new_chat_actions_returns_empty_when_model_input_is_invalid() {
+        let presets = vec![NewChatPresetInfo {
+            id: "focused-writing".to_string(),
+            name: "Focused Writing".to_string(),
+            icon: IconName::Pencil,
+        }];
+        let models = vec![NewChatModelInfo {
+            model_id: "claude-3-5-sonnet".to_string(),
+            display_name: "Claude 3.5 Sonnet".to_string(),
+            provider: "   ".to_string(),
+            provider_display_name: "Anthropic".to_string(),
+        }];
+
+        let actions = get_new_chat_actions(&[], &presets, &models);
+        assert!(actions.is_empty());
+    }
+
+    #[test]
+    fn test_get_note_switcher_actions_returns_empty_when_note_input_is_invalid() {
+        let notes = vec![NoteSwitcherNoteInfo {
+            id: "   ".to_string(),
+            title: "Missing ID".to_string(),
+            char_count: 5,
+            is_current: false,
+            is_pinned: false,
+            preview: "Preview".to_string(),
+            relative_time: "1m ago".to_string(),
+        }];
+
+        let actions = get_note_switcher_actions(&notes);
+        assert!(actions.is_empty());
+    }
 }
 
 /// Build actions for the AI new chat dropdown.
@@ -376,6 +465,48 @@
     presets: &[NewChatPresetInfo],
     models: &[NewChatModelInfo],
 ) -> Vec<Action> {
+    let invalid_last_used_count = last_used
+        .iter()
+        .filter(|model| has_invalid_new_chat_model_info(model))
+        .count();
+    if invalid_last_used_count > 0 {
+        tracing::warn!(
+            target: "script_kit::actions",
+            builder = "notes_new_chat",
+            invalid_last_used_count,
+            "Invalid last-used chat model input; returning empty actions"
+        );
+        return vec![];
+    }
+
+    let invalid_preset_count = presets
+        .iter()
+        .filter(|preset| has_invalid_new_chat_preset_info(preset))
+        .count();
+    if invalid_preset_count > 0 {
+        tracing::warn!(
+            target: "script_kit::actions",
+            builder = "notes_new_chat",
+            invalid_preset_count,
+            "Invalid chat preset input; returning empty actions"
+        );
+        return vec![];
+    }
+
+    let invalid_model_count = models
+        .iter()
+        .filter(|model| has_invalid_new_chat_model_info(model))
+        .count();
+    if invalid_model_count > 0 {
+        tracing::warn!(
+            target: "script_kit::actions",
+            builder = "notes_new_chat",
+            invalid_model_count,
+            "Invalid chat model input; returning empty actions"
+        );
+        return vec![];
+    }
+
     let mut actions = Vec::new();
 
     for setting in last_used {
@@ -442,6 +573,21 @@
 
 /// Get actions for the note switcher dialog (Cmd+P in Notes window).
 pub fn get_note_switcher_actions(notes: &[NoteSwitcherNoteInfo]) -> Vec<Action> {
+    let invalid_note_count = notes
+        .iter()
+        .filter(|note| has_invalid_note_switcher_note_info(note))
+        .count();
+    if invalid_note_count > 0 {
+        tracing::warn!(
+            target: "script_kit::actions",
+            builder = "note_switcher",
+            note_count = notes.len(),
+            invalid_note_count,
+            "Invalid note switcher input; returning empty actions"
+        );
+        return vec![];
+    }
+
     let mut actions = Vec::new();
 
     for note in notes {
diff --git a/src/actions/builders/script_context.rs b/src/actions/builders/script_context.rs
index d48add6d0604e4fc8ab6bc1d9a9cdc328a6037ab..c09068069325e288d1c697a6ed9aa07944aadf61
--- a/src/actions/builders/script_context.rs
+++ b/src/actions/builders/script_context.rs
@@ -2,8 +2,23 @@
 use super::types::{Action, ActionCategory, ScriptInfo};
 use std::collections::HashSet;
 
+fn has_invalid_script_context_input(script: &ScriptInfo) -> bool {
+    script.name.trim().is_empty() || script.action_verb.trim().is_empty()
+}
+
 /// Get actions specific to the focused script.
 pub fn get_script_context_actions(script: &ScriptInfo) -> Vec<Action> {
+    if has_invalid_script_context_input(script) {
+        tracing::warn!(
+            target: "script_kit::actions",
+            builder = "script_context",
+            name = %script.name,
+            action_verb = %script.action_verb,
+            "Invalid script context input; returning empty actions"
+        );
+        return vec![];
+    }
+
     let mut actions = Vec::new();
     let mut destructive_actions = Vec::new();
 
@@ -314,3 +329,26 @@
 pub fn get_global_actions() -> Vec<Action> {
     vec![]
 }
+
+#[cfg(test)]
+mod tests {
+    use super::*;
+
+    #[test]
+    fn test_get_script_context_actions_returns_empty_when_name_is_blank() {
+        let mut script = ScriptInfo::new("Valid", "/tmp/valid.ts");
+        script.name = "   ".to_string();
+
+        let actions = get_script_context_actions(&script);
+        assert!(actions.is_empty());
+    }
+
+    #[test]
+    fn test_get_script_context_actions_returns_empty_when_action_verb_is_blank() {
+        let mut script = ScriptInfo::new("Valid", "/tmp/valid.ts");
+        script.action_verb = "   ".to_string();
+
+        let actions = get_script_context_actions(&script);
+        assert!(actions.is_empty());
+    }
+}
diff --git a/src/actions/builders/scriptlet.rs b/src/actions/builders/scriptlet.rs
index 371dbac6d433b01ee915aebdcd5f371b952065da..29d118adfe8a10c98b5c24a331a6773a556b1b80
--- a/src/actions/builders/scriptlet.rs
+++ b/src/actions/builders/scriptlet.rs
@@ -1,11 +1,31 @@
 use super::shared::{format_shortcut_hint, to_deeplink_name};
 use super::types::{Action, ActionCategory, ScriptInfo};
 use crate::designs::icon_variations::IconName;
-use crate::scriptlets::Scriptlet;
+use crate::scriptlets::{Scriptlet, ScriptletAction};
 use std::collections::HashSet;
 
 const SCRIPTLET_ACTION_ID_PREFIX: &str = "scriptlet_action:";
 
+fn is_blank(value: &str) -> bool {
+    value.trim().is_empty()
+}
+
+fn has_invalid_scriptlet_context_input(script: &ScriptInfo) -> bool {
+    is_blank(&script.name) || is_blank(&script.action_verb)
+}
+
+fn has_invalid_scriptlet_action_input(action: &ScriptletAction) -> bool {
+    is_blank(&action.name) || is_blank(&action.command)
+}
+
+fn count_invalid_scriptlet_actions(scriptlet: &Scriptlet) -> usize {
+    scriptlet
+        .actions
+        .iter()
+        .filter(|action| has_invalid_scriptlet_action_input(action))
+        .count()
+}
+
 fn parse_scriptlet_action_command(action_id: &str) -> Option<&str> {
     action_id
         .strip_prefix(SCRIPTLET_ACTION_ID_PREFIX)
@@ -14,18 +34,9 @@
 
 fn unique_scriptlet_action_id(
     raw_action_id: &str,
-    action_name: &str,
     used_action_ids: &mut HashSet<String>,
 ) -> Option<String> {
-    let Some(action_command) = parse_scriptlet_action_command(raw_action_id) else {
-        tracing::warn!(
-            target: "script_kit::actions",
-            action_name = %action_name,
-            action_id = %raw_action_id,
-            "Failed to parse scriptlet H3 action id; dropping malformed action"
-        );
-        return None;
-    };
+    let action_command = parse_scriptlet_action_command(raw_action_id)?;
 
     let mut unique_action_id = raw_action_id.to_string();
     let mut duplicate_index = 2;
@@ -51,40 +62,62 @@
 
 /// Convert scriptlet-defined actions (from H3 headers) to Action structs for the UI.
 pub fn get_scriptlet_defined_actions(scriptlet: &Scriptlet) -> Vec<Action> {
+    let invalid_action_count = count_invalid_scriptlet_actions(scriptlet);
+    if invalid_action_count > 0 {
+        tracing::warn!(
+            target: "script_kit::actions",
+            builder = "scriptlet_defined",
+            scriptlet_name = %scriptlet.name,
+            action_count = scriptlet.actions.len(),
+            invalid_action_count,
+            "Invalid scriptlet-defined action input; returning empty actions"
+        );
+        return vec![];
+    }
+
     let mut used_action_ids = HashSet::new();
-    let actions: Vec<Action> = scriptlet
-        .actions
-        .iter()
-        .filter_map(|sa| {
-            let raw_action_id = sa.action_id();
-            let action_id =
-                unique_scriptlet_action_id(&raw_action_id, &sa.name, &mut used_action_ids)?;
-            let mut action = Action::new(
-                action_id,
-                &sa.name,
-                sa.description.clone(),
-                ActionCategory::ScriptContext,
+    let mut actions: Vec<Action> = Vec::with_capacity(scriptlet.actions.len());
+
+    for sa in &scriptlet.actions {
+        let raw_action_id = sa.action_id();
+        let Some(action_id) = unique_scriptlet_action_id(&raw_action_id, &mut used_action_ids)
+        else {
+            tracing::warn!(
+                target: "script_kit::actions",
+                builder = "scriptlet_defined",
+                scriptlet_name = %scriptlet.name,
+                action_name = %sa.name,
+                action_id = %raw_action_id,
+                "Invalid scriptlet action id input; returning empty actions"
             );
+            return vec![];
+        };
 
-            if let Some(ref shortcut) = sa.shortcut {
-                action = action.with_shortcut(format_shortcut_hint(shortcut));
-            }
+        let mut action = Action::new(
+            action_id,
+            &sa.name,
+            sa.description.clone(),
+            ActionCategory::ScriptContext,
+        );
 
-            action = action.with_icon(IconName::PlayFilled).with_section("Actions");
-            action.has_action = true;
-            action.value = Some(sa.command.clone());
+        if let Some(ref shortcut) = sa.shortcut {
+            action = action.with_shortcut(format_shortcut_hint(shortcut));
+        }
 
-            tracing::debug!(
-                target: "script_kit::actions",
-                action_id = %action.id,
-                has_action = action.has_action,
-                has_shortcut = action.shortcut.is_some(),
-                "Created scriptlet-defined action (has_action=true)"
-            );
+        action = action.with_icon(IconName::PlayFilled).with_section("Actions");
+        action.has_action = true;
+        action.value = Some(sa.command.clone());
+
+        tracing::debug!(
+            target: "script_kit::actions",
+            action_id = %action.id,
+            has_action = action.has_action,
+            has_shortcut = action.shortcut.is_some(),
+            "Created scriptlet-defined action (has_action=true)"
+        );
 
-            Some(action)
-        })
-        .collect();
+        actions.push(action);
+    }
 
     if !actions.is_empty() {
         tracing::debug!(
@@ -103,6 +136,32 @@
     script: &ScriptInfo,
     scriptlet: Option<&Scriptlet>,
 ) -> Vec<Action> {
+    if has_invalid_scriptlet_context_input(script) {
+        tracing::warn!(
+            target: "script_kit::actions",
+            builder = "scriptlet_context",
+            name = %script.name,
+            action_verb = %script.action_verb,
+            "Invalid scriptlet context input; returning empty actions"
+        );
+        return vec![];
+    }
+
+    if let Some(scriptlet) = scriptlet {
+        let invalid_action_count = count_invalid_scriptlet_actions(scriptlet);
+        if invalid_action_count > 0 {
+            tracing::warn!(
+                target: "script_kit::actions",
+                builder = "scriptlet_context",
+                scriptlet_name = %scriptlet.name,
+                action_count = scriptlet.actions.len(),
+                invalid_action_count,
+                "Invalid scriptlet-defined action input; returning empty actions"
+            );
+            return vec![];
+        }
+    }
+
     let mut actions = Vec::new();
     let mut destructive_actions = Vec::new();
 
@@ -342,7 +401,7 @@
     }
 
     #[test]
-    fn test_get_scriptlet_defined_actions_drops_action_when_command_is_empty() {
+    fn test_get_scriptlet_defined_actions_returns_empty_when_command_is_empty() {
         let mut scriptlet = Scriptlet::new(
             "Malformed".to_string(),
             "bash".to_string(),
@@ -355,6 +414,53 @@
     }
 
     #[test]
+    fn test_get_scriptlet_defined_actions_returns_empty_when_any_action_is_invalid() {
+        let mut scriptlet = Scriptlet::new(
+            "Mixed".to_string(),
+            "bash".to_string(),
+            "echo".to_string(),
+        );
+        scriptlet.actions = vec![
+            scriptlet_action("Valid", "copy"),
+            scriptlet_action("   ", "invalid"),
+        ];
+
+        let actions = get_scriptlet_defined_actions(&scriptlet);
+        assert!(actions.is_empty());
+    }
+
+    #[test]
+    fn test_get_scriptlet_context_actions_returns_empty_when_script_name_is_blank() {
+        let mut script =
+            ScriptInfo::scriptlet("Demo", "/tmp/demo.md", Some("cmd d".to_string()), None);
+        script.name = "   ".to_string();
+
+        let actions = get_scriptlet_context_actions_with_custom(&script, None);
+        assert!(actions.is_empty());
+    }
+
+    #[test]
+    fn test_get_scriptlet_context_actions_returns_empty_when_action_verb_is_blank() {
+        let mut script =
+            ScriptInfo::scriptlet("Demo", "/tmp/demo.md", Some("cmd d".to_string()), None);
+        script.action_verb = "   ".to_string();
+
+        let actions = get_scriptlet_context_actions_with_custom(&script, None);
+        assert!(actions.is_empty());
+    }
+
+    #[test]
+    fn test_get_scriptlet_context_actions_returns_empty_when_scriptlet_action_input_is_invalid() {
+        let script = ScriptInfo::scriptlet("Demo", "/tmp/demo.md", Some("cmd d".to_string()), None);
+        let mut scriptlet =
+            Scriptlet::new("Malformed".to_string(), "bash".to_string(), "echo".to_string());
+        scriptlet.actions = vec![scriptlet_action("Bad", "   ")];
+
+        let actions = get_scriptlet_context_actions_with_custom(&script, Some(&scriptlet));
+        assert!(actions.is_empty());
+    }
+
+    #[test]
     fn test_get_scriptlet_context_actions_assigns_consistent_primary_icons() {
         let script = ScriptInfo::scriptlet("Demo", "/tmp/demo.md", Some("cmd d".to_string()), None);
         let actions = get_scriptlet_context_actions_with_custom(&script, None);

Reconnecting... 1/5 (stream disconnected before completion: websocket closed by server before response.completed)

thinking
**Polling running sessions while fixing compile error**
codex
The first test compile exposed one issue from my edit (`action_name` reference in `scriptlet.rs`). I’m fixing that now, then rerunning scoped verification; the remaining failures are from unrelated concurrent files.
exec
/bin/zsh -lc "sed -n '34,72p' src/actions/builders/scriptlet.rs" in /Users/johnlindquist/dev/script-kit-gpui exited 101 in 37.38s:
    Blocking waiting for file lock on package cache
    Blocking waiting for file lock on package cache
    Blocking waiting for file lock on package cache
    Blocking waiting for file lock on build directory
   Compiling script-kit-gpui v0.1.0 (/Users/johnlindquist/dev/script-kit-gpui)
error[E0761]: file for module `tests` found at both "src/protocol/message/tests.rs" and "src/protocol/message/tests/mod.rs"
  --> src/protocol/message/mod.rs:87:1
   |
87 | mod tests;
   | ^^^^^^^^^^
   |
   = help: delete or rename one of them to remove the ambiguity

error[E0761]: file for module `tests` found at both "src/designs/core/tests.rs" and "src/designs/core/tests/mod.rs"
 --> src/designs/core/part_04.rs:2:1
  |
2 | mod tests;
  | ^^^^^^^^^^
  |
  = help: delete or rename one of them to remove the ambiguity
 succeeded in 51ms:

fn unique_scriptlet_action_id(
    raw_action_id: &str,
    used_action_ids: &mut HashSet<String>,
) -> Option<String> {
    let action_command = parse_scriptlet_action_command(raw_action_id)?;

    let mut unique_action_id = raw_action_id.to_string();
    let mut duplicate_index = 2;
    while used_action_ids.contains(&unique_action_id) {
        unique_action_id =
            format!("{SCRIPTLET_ACTION_ID_PREFIX}{action_command}__{duplicate_index}");
        duplicate_index += 1;
    }

    if unique_action_id != raw_action_id {
        tracing::debug!(
            target: "script_kit::actions",
            action_name = %action_name,
            original_action_id = %raw_action_id,
file update:
diff --git a/src/actions/builders/notes.rs b/src/actions/builders/notes.rs
index 48ba267e97bf2f3da7ecf1a3f78fea59dbc9acab..a2f0007d3327b005960130e6e30f524ceb6b3e9f
--- a/src/actions/builders/notes.rs
+++ b/src/actions/builders/notes.rs
@@ -27,6 +27,25 @@
     pub auto_sizing_enabled: bool,
 }
 
+fn is_blank(value: &str) -> bool {
+    value.trim().is_empty()
+}
+
+fn has_invalid_new_chat_model_info(model: &NewChatModelInfo) -> bool {
+    is_blank(&model.model_id)
+        || is_blank(&model.display_name)
+        || is_blank(&model.provider)
+        || is_blank(&model.provider_display_name)
+}
+
+fn has_invalid_new_chat_preset_info(preset: &NewChatPresetInfo) -> bool {
+    is_blank(&preset.id) || is_blank(&preset.name)
+}
+
+fn has_invalid_note_switcher_note_info(note: &NoteSwitcherNoteInfo) -> bool {
+    is_blank(&note.id) || is_blank(&note.title)
+}
+
 /// Get actions for the Notes window command bar (Cmd+K menu).
 pub fn get_notes_command_bar_actions(info: &NotesInfo) -> Vec<Action> {
     let mut actions = Vec::new();
@@ -367,6 +386,76 @@
             Some("Use Focused Writing preset")
         );
     }
+
+    #[test]
+    fn test_get_new_chat_actions_returns_empty_when_last_used_model_input_is_invalid() {
+        let last_used = vec![NewChatModelInfo {
+            model_id: "   ".to_string(),
+            display_name: "GPT-4o Mini".to_string(),
+            provider: "openai".to_string(),
+            provider_display_name: "OpenAI".to_string(),
+        }];
+        let presets = vec![NewChatPresetInfo {
+            id: "focused-writing".to_string(),
+            name: "Focused Writing".to_string(),
+            icon: IconName::Pencil,
+        }];
+
+        let actions = get_new_chat_actions(&last_used, &presets, &[]);
+        assert!(actions.is_empty());
+    }
+
+    #[test]
+    fn test_get_new_chat_actions_returns_empty_when_preset_input_is_invalid() {
+        let last_used = vec![NewChatModelInfo {
+            model_id: "gpt-4o-mini".to_string(),
+            display_name: "GPT-4o Mini".to_string(),
+            provider: "openai".to_string(),
+            provider_display_name: "OpenAI".to_string(),
+        }];
+        let presets = vec![NewChatPresetInfo {
+            id: "   ".to_string(),
+            name: "Focused Writing".to_string(),
+            icon: IconName::Pencil,
+        }];
+
+        let actions = get_new_chat_actions(&last_used, &presets, &[]);
+        assert!(actions.is_empty());
+    }
+
+    #[test]
+    fn test_get_new_chat_actions_returns_empty_when_model_input_is_invalid() {
+        let presets = vec![NewChatPresetInfo {
+            id: "focused-writing".to_string(),
+            name: "Focused Writing".to_string(),
+            icon: IconName::Pencil,
+        }];
+        let models = vec![NewChatModelInfo {
+            model_id: "claude-3-5-sonnet".to_string(),
+            display_name: "Claude 3.5 Sonnet".to_string(),
+            provider: "   ".to_string(),
+            provider_display_name: "Anthropic".to_string(),
+        }];
+
+        let actions = get_new_chat_actions(&[], &presets, &models);
+        assert!(actions.is_empty());
+    }
+
+    #[test]
+    fn test_get_note_switcher_actions_returns_empty_when_note_input_is_invalid() {
+        let notes = vec![NoteSwitcherNoteInfo {
+            id: "   ".to_string(),
+            title: "Missing ID".to_string(),
+            char_count: 5,
+            is_current: false,
+            is_pinned: false,
+            preview: "Preview".to_string(),
+            relative_time: "1m ago".to_string(),
+        }];
+
+        let actions = get_note_switcher_actions(&notes);
+        assert!(actions.is_empty());
+    }
 }
 
 /// Build actions for the AI new chat dropdown.
@@ -376,6 +465,48 @@
     presets: &[NewChatPresetInfo],
     models: &[NewChatModelInfo],
 ) -> Vec<Action> {
+    let invalid_last_used_count = last_used
+        .iter()
+        .filter(|model| has_invalid_new_chat_model_info(model))
+        .count();
+    if invalid_last_used_count > 0 {
+        tracing::warn!(
+            target: "script_kit::actions",
+            builder = "notes_new_chat",
+            invalid_last_used_count,
+            "Invalid last-used chat model input; returning empty actions"
+        );
+        return vec![];
+    }
+
+    let invalid_preset_count = presets
+        .iter()
+        .filter(|preset| has_invalid_new_chat_preset_info(preset))
+        .count();
+    if invalid_preset_count > 0 {
+        tracing::warn!(
+            target: "script_kit::actions",
+            builder = "notes_new_chat",
+            invalid_preset_count,
+            "Invalid chat preset input; returning empty actions"
+        );
+        return vec![];
+    }
+
+    let invalid_model_count = models
+        .iter()
+        .filter(|model| has_invalid_new_chat_model_info(model))
+        .count();
+    if invalid_model_count > 0 {
+        tracing::warn!(
+            target: "script_kit::actions",
+            builder = "notes_new_chat",
+            invalid_model_count,
+            "Invalid chat model input; returning empty actions"
+        );
+        return vec![];
+    }
+
     let mut actions = Vec::new();
 
     for setting in last_used {
@@ -442,6 +573,21 @@
 
 /// Get actions for the note switcher dialog (Cmd+P in Notes window).
 pub fn get_note_switcher_actions(notes: &[NoteSwitcherNoteInfo]) -> Vec<Action> {
+    let invalid_note_count = notes
+        .iter()
+        .filter(|note| has_invalid_note_switcher_note_info(note))
+        .count();
+    if invalid_note_count > 0 {
+        tracing::warn!(
+            target: "script_kit::actions",
+            builder = "note_switcher",
+            note_count = notes.len(),
+            invalid_note_count,
+            "Invalid note switcher input; returning empty actions"
+        );
+        return vec![];
+    }
+
     let mut actions = Vec::new();
 
     for note in notes {
diff --git a/src/actions/builders/script_context.rs b/src/actions/builders/script_context.rs
index d48add6d0604e4fc8ab6bc1d9a9cdc328a6037ab..c09068069325e288d1c697a6ed9aa07944aadf61
--- a/src/actions/builders/script_context.rs
+++ b/src/actions/builders/script_context.rs
@@ -2,8 +2,23 @@
 use super::types::{Action, ActionCategory, ScriptInfo};
 use std::collections::HashSet;
 
+fn has_invalid_script_context_input(script: &ScriptInfo) -> bool {
+    script.name.trim().is_empty() || script.action_verb.trim().is_empty()
+}
+
 /// Get actions specific to the focused script.
 pub fn get_script_context_actions(script: &ScriptInfo) -> Vec<Action> {
+    if has_invalid_script_context_input(script) {
+        tracing::warn!(
+            target: "script_kit::actions",
+            builder = "script_context",
+            name = %script.name,
+            action_verb = %script.action_verb,
+            "Invalid script context input; returning empty actions"
+        );
+        return vec![];
+    }
+
     let mut actions = Vec::new();
     let mut destructive_actions = Vec::new();
 
@@ -314,3 +329,26 @@
 pub fn get_global_actions() -> Vec<Action> {
     vec![]
 }
+
+#[cfg(test)]
+mod tests {
+    use super::*;
+
+    #[test]
+    fn test_get_script_context_actions_returns_empty_when_name_is_blank() {
+        let mut script = ScriptInfo::new("Valid", "/tmp/valid.ts");
+        script.name = "   ".to_string();
+
+        let actions = get_script_context_actions(&script);
+        assert!(actions.is_empty());
+    }
+
+    #[test]
+    fn test_get_script_context_actions_returns_empty_when_action_verb_is_blank() {
+        let mut script = ScriptInfo::new("Valid", "/tmp/valid.ts");
+        script.action_verb = "   ".to_string();
+
+        let actions = get_script_context_actions(&script);
+        assert!(actions.is_empty());
+    }
+}
diff --git a/src/actions/builders/scriptlet.rs b/src/actions/builders/scriptlet.rs
index 371dbac6d433b01ee915aebdcd5f371b952065da..29d118adfe8a10c98b5c24a331a6773a556b1b80
--- a/src/actions/builders/scriptlet.rs
+++ b/src/actions/builders/scriptlet.rs
@@ -1,11 +1,31 @@
 use super::shared::{format_shortcut_hint, to_deeplink_name};
 use super::types::{Action, ActionCategory, ScriptInfo};
 use crate::designs::icon_variations::IconName;
-use crate::scriptlets::Scriptlet;
+use crate::scriptlets::{Scriptlet, ScriptletAction};
 use std::collections::HashSet;
 
 const SCRIPTLET_ACTION_ID_PREFIX: &str = "scriptlet_action:";
 
+fn is_blank(value: &str) -> bool {
+    value.trim().is_empty()
+}
+
+fn has_invalid_scriptlet_context_input(script: &ScriptInfo) -> bool {
+    is_blank(&script.name) || is_blank(&script.action_verb)
+}
+
+fn has_invalid_scriptlet_action_input(action: &ScriptletAction) -> bool {
+    is_blank(&action.name) || is_blank(&action.command)
+}
+
+fn count_invalid_scriptlet_actions(scriptlet: &Scriptlet) -> usize {
+    scriptlet
+        .actions
+        .iter()
+        .filter(|action| has_invalid_scriptlet_action_input(action))
+        .count()
+}
+
 fn parse_scriptlet_action_command(action_id: &str) -> Option<&str> {
     action_id
         .strip_prefix(SCRIPTLET_ACTION_ID_PREFIX)
@@ -14,18 +34,9 @@
 
 fn unique_scriptlet_action_id(
     raw_action_id: &str,
-    action_name: &str,
     used_action_ids: &mut HashSet<String>,
 ) -> Option<String> {
-    let Some(action_command) = parse_scriptlet_action_command(raw_action_id) else {
-        tracing::warn!(
-            target: "script_kit::actions",
-            action_name = %action_name,
-            action_id = %raw_action_id,
-            "Failed to parse scriptlet H3 action id; dropping malformed action"
-        );
-        return None;
-    };
+    let action_command = parse_scriptlet_action_command(raw_action_id)?;
 
     let mut unique_action_id = raw_action_id.to_string();
     let mut duplicate_index = 2;
@@ -51,40 +62,62 @@
 
 /// Convert scriptlet-defined actions (from H3 headers) to Action structs for the UI.
 pub fn get_scriptlet_defined_actions(scriptlet: &Scriptlet) -> Vec<Action> {
+    let invalid_action_count = count_invalid_scriptlet_actions(scriptlet);
+    if invalid_action_count > 0 {
+        tracing::warn!(
+            target: "script_kit::actions",
+            builder = "scriptlet_defined",
+            scriptlet_name = %scriptlet.name,
+            action_count = scriptlet.actions.len(),
+            invalid_action_count,
+            "Invalid scriptlet-defined action input; returning empty actions"
+        );
+        return vec![];
+    }
+
     let mut used_action_ids = HashSet::new();
-    let actions: Vec<Action> = scriptlet
-        .actions
-        .iter()
-        .filter_map(|sa| {
-            let raw_action_id = sa.action_id();
-            let action_id =
-                unique_scriptlet_action_id(&raw_action_id, &sa.name, &mut used_action_ids)?;
-            let mut action = Action::new(
-                action_id,
-                &sa.name,
-                sa.description.clone(),
-                ActionCategory::ScriptContext,
+    let mut actions: Vec<Action> = Vec::with_capacity(scriptlet.actions.len());
+
+    for sa in &scriptlet.actions {
+        let raw_action_id = sa.action_id();
+        let Some(action_id) = unique_scriptlet_action_id(&raw_action_id, &mut used_action_ids)
+        else {
+            tracing::warn!(
+                target: "script_kit::actions",
+                builder = "scriptlet_defined",
+                scriptlet_name = %scriptlet.name,
+                action_name = %sa.name,
+                action_id = %raw_action_id,
+                "Invalid scriptlet action id input; returning empty actions"
             );
+            return vec![];
+        };
 
-            if let Some(ref shortcut) = sa.shortcut {
-                action = action.with_shortcut(format_shortcut_hint(shortcut));
-            }
+        let mut action = Action::new(
+            action_id,
+            &sa.name,
+            sa.description.clone(),
+            ActionCategory::ScriptContext,
+        );
 
-            action = action.with_icon(IconName::PlayFilled).with_section("Actions");
-            action.has_action = true;
-            action.value = Some(sa.command.clone());
+        if let Some(ref shortcut) = sa.shortcut {
+            action = action.with_shortcut(format_shortcut_hint(shortcut));
+        }
 
-            tracing::debug!(
-                target: "script_kit::actions",
-                action_id = %action.id,
-                has_action = action.has_action,
-                has_shortcut = action.shortcut.is_some(),
-                "Created scriptlet-defined action (has_action=true)"
-            );
+        action = action.with_icon(IconName::PlayFilled).with_section("Actions");
+        action.has_action = true;
+        action.value = Some(sa.command.clone());
+
+        tracing::debug!(
+            target: "script_kit::actions",
+            action_id = %action.id,
+            has_action = action.has_action,
+            has_shortcut = action.shortcut.is_some(),
+            "Created scriptlet-defined action (has_action=true)"
+        );
 
-            Some(action)
-        })
-        .collect();
+        actions.push(action);
+    }
 
     if !actions.is_empty() {
         tracing::debug!(
@@ -103,6 +136,32 @@
     script: &ScriptInfo,
     scriptlet: Option<&Scriptlet>,
 ) -> Vec<Action> {
+    if has_invalid_scriptlet_context_input(script) {
+        tracing::warn!(
+            target: "script_kit::actions",
+            builder = "scriptlet_context",
+            name = %script.name,
+            action_verb = %script.action_verb,
+            "Invalid scriptlet context input; returning empty actions"
+        );
+        return vec![];
+    }
+
+    if let Some(scriptlet) = scriptlet {
+        let invalid_action_count = count_invalid_scriptlet_actions(scriptlet);
+        if invalid_action_count > 0 {
+            tracing::warn!(
+                target: "script_kit::actions",
+                builder = "scriptlet_context",
+                scriptlet_name = %scriptlet.name,
+                action_count = scriptlet.actions.len(),
+                invalid_action_count,
+                "Invalid scriptlet-defined action input; returning empty actions"
+            );
+            return vec![];
+        }
+    }
+
     let mut actions = Vec::new();
     let mut destructive_actions = Vec::new();
 
@@ -342,7 +401,7 @@
     }
 
     #[test]
-    fn test_get_scriptlet_defined_actions_drops_action_when_command_is_empty() {
+    fn test_get_scriptlet_defined_actions_returns_empty_when_command_is_empty() {
         let mut scriptlet = Scriptlet::new(
             "Malformed".to_string(),
             "bash".to_string(),
@@ -355,6 +414,53 @@
     }
 
     #[test]
+    fn test_get_scriptlet_defined_actions_returns_empty_when_any_action_is_invalid() {
+        let mut scriptlet = Scriptlet::new(
+            "Mixed".to_string(),
+            "bash".to_string(),
+            "echo".to_string(),
+        );
+        scriptlet.actions = vec![
+            scriptlet_action("Valid", "copy"),
+            scriptlet_action("   ", "invalid"),
+        ];
+
+        let actions = get_scriptlet_defined_actions(&scriptlet);
+        assert!(actions.is_empty());
+    }
+
+    #[test]
+    fn test_get_scriptlet_context_actions_returns_empty_when_script_name_is_blank() {
+        let mut script =
+            ScriptInfo::scriptlet("Demo", "/tmp/demo.md", Some("cmd d".to_string()), None);
+        script.name = "   ".to_string();
+
+        let actions = get_scriptlet_context_actions_with_custom(&script, None);
+        assert!(actions.is_empty());
+    }
+
+    #[test]
+    fn test_get_scriptlet_context_actions_returns_empty_when_action_verb_is_blank() {
+        let mut script =
+            ScriptInfo::scriptlet("Demo", "/tmp/demo.md", Some("cmd d".to_string()), None);
+        script.action_verb = "   ".to_string();
+
+        let actions = get_scriptlet_context_actions_with_custom(&script, None);
+        assert!(actions.is_empty());
+    }
+
+    #[test]
+    fn test_get_scriptlet_context_actions_returns_empty_when_scriptlet_action_input_is_invalid() {
+        let script = ScriptInfo::scriptlet("Demo", "/tmp/demo.md", Some("cmd d".to_string()), None);
+        let mut scriptlet =
+            Scriptlet::new("Malformed".to_string(), "bash".to_string(), "echo".to_string());
+        scriptlet.actions = vec![scriptlet_action("Bad", "   ")];
+
+        let actions = get_scriptlet_context_actions_with_custom(&script, Some(&scriptlet));
+        assert!(actions.is_empty());
+    }
+
+    #[test]
     fn test_get_scriptlet_context_actions_assigns_consistent_primary_icons() {
         let script = ScriptInfo::scriptlet("Demo", "/tmp/demo.md", Some("cmd d".to_string()), None);
         let actions = get_scriptlet_context_actions_with_custom(&script, None);


thinking
**Removing unused debug variable**
codex
I confirmed the local compile break is the stale `action_name` field in a debug log. I’m removing that field now and rerunning verification commands.
file update
M /Users/johnlindquist/dev/script-kit-gpui/src/actions/builders/scriptlet.rs
@@ -51,3 +51,2 @@
             target: "script_kit::actions",
-            action_name = %action_name,
             original_action_id = %raw_action_id,
apply_patch(auto_approved=true) exited 0 in 24ms:
Success. Updated the following files:
M src/actions/builders/scriptlet.rs
file update:
diff --git a/src/actions/builders/notes.rs b/src/actions/builders/notes.rs
index 48ba267e97bf2f3da7ecf1a3f78fea59dbc9acab..a2f0007d3327b005960130e6e30f524ceb6b3e9f
--- a/src/actions/builders/notes.rs
+++ b/src/actions/builders/notes.rs
@@ -27,6 +27,25 @@
     pub auto_sizing_enabled: bool,
 }
 
+fn is_blank(value: &str) -> bool {
+    value.trim().is_empty()
+}
+
+fn has_invalid_new_chat_model_info(model: &NewChatModelInfo) -> bool {
+    is_blank(&model.model_id)
+        || is_blank(&model.display_name)
+        || is_blank(&model.provider)
+        || is_blank(&model.provider_display_name)
+}
+
+fn has_invalid_new_chat_preset_info(preset: &NewChatPresetInfo) -> bool {
+    is_blank(&preset.id) || is_blank(&preset.name)
+}
+
+fn has_invalid_note_switcher_note_info(note: &NoteSwitcherNoteInfo) -> bool {
+    is_blank(&note.id) || is_blank(&note.title)
+}
+
 /// Get actions for the Notes window command bar (Cmd+K menu).
 pub fn get_notes_command_bar_actions(info: &NotesInfo) -> Vec<Action> {
     let mut actions = Vec::new();
@@ -367,6 +386,76 @@
             Some("Use Focused Writing preset")
         );
     }
+
+    #[test]
+    fn test_get_new_chat_actions_returns_empty_when_last_used_model_input_is_invalid() {
+        let last_used = vec![NewChatModelInfo {
+            model_id: "   ".to_string(),
+            display_name: "GPT-4o Mini".to_string(),
+            provider: "openai".to_string(),
+            provider_display_name: "OpenAI".to_string(),
+        }];
+        let presets = vec![NewChatPresetInfo {
+            id: "focused-writing".to_string(),
+            name: "Focused Writing".to_string(),
+            icon: IconName::Pencil,
+        }];
+
+        let actions = get_new_chat_actions(&last_used, &presets, &[]);
+        assert!(actions.is_empty());
+    }
+
+    #[test]
+    fn test_get_new_chat_actions_returns_empty_when_preset_input_is_invalid() {
+        let last_used = vec![NewChatModelInfo {
+            model_id: "gpt-4o-mini".to_string(),
+            display_name: "GPT-4o Mini".to_string(),
+            provider: "openai".to_string(),
+            provider_display_name: "OpenAI".to_string(),
+        }];
+        let presets = vec![NewChatPresetInfo {
+            id: "   ".to_string(),
+            name: "Focused Writing".to_string(),
+            icon: IconName::Pencil,
+        }];
+
+        let actions = get_new_chat_actions(&last_used, &presets, &[]);
+        assert!(actions.is_empty());
+    }
+
+    #[test]
+    fn test_get_new_chat_actions_returns_empty_when_model_input_is_invalid() {
+        let presets = vec![NewChatPresetInfo {
+            id: "focused-writing".to_string(),
+            name: "Focused Writing".to_string(),
+            icon: IconName::Pencil,
+        }];
+        let models = vec![NewChatModelInfo {
+            model_id: "claude-3-5-sonnet".to_string(),
+            display_name: "Claude 3.5 Sonnet".to_string(),
+            provider: "   ".to_string(),
+            provider_display_name: "Anthropic".to_string(),
+        }];
+
+        let actions = get_new_chat_actions(&[], &presets, &models);
+        assert!(actions.is_empty());
+    }
+
+    #[test]
+    fn test_get_note_switcher_actions_returns_empty_when_note_input_is_invalid() {
+        let notes = vec![NoteSwitcherNoteInfo {
+            id: "   ".to_string(),
+            title: "Missing ID".to_string(),
+            char_count: 5,
+            is_current: false,
+            is_pinned: false,
+            preview: "Preview".to_string(),
+            relative_time: "1m ago".to_string(),
+        }];
+
+        let actions = get_note_switcher_actions(&notes);
+        assert!(actions.is_empty());
+    }
 }
 
 /// Build actions for the AI new chat dropdown.
@@ -376,6 +465,48 @@
     presets: &[NewChatPresetInfo],
     models: &[NewChatModelInfo],
 ) -> Vec<Action> {
+    let invalid_last_used_count = last_used
+        .iter()
+        .filter(|model| has_invalid_new_chat_model_info(model))
+        .count();
+    if invalid_last_used_count > 0 {
+        tracing::warn!(
+            target: "script_kit::actions",
+            builder = "notes_new_chat",
+            invalid_last_used_count,
+            "Invalid last-used chat model input; returning empty actions"
+        );
+        return vec![];
+    }
+
+    let invalid_preset_count = presets
+        .iter()
+        .filter(|preset| has_invalid_new_chat_preset_info(preset))
+        .count();
+    if invalid_preset_count > 0 {
+        tracing::warn!(
+            target: "script_kit::actions",
+            builder = "notes_new_chat",
+            invalid_preset_count,
+            "Invalid chat preset input; returning empty actions"
+        );
+        return vec![];
+    }
+
+    let invalid_model_count = models
+        .iter()
+        .filter(|model| has_invalid_new_chat_model_info(model))
+        .count();
+    if invalid_model_count > 0 {
+        tracing::warn!(
+            target: "script_kit::actions",
+            builder = "notes_new_chat",
+            invalid_model_count,
+            "Invalid chat model input; returning empty actions"
+        );
+        return vec![];
+    }
+
     let mut actions = Vec::new();
 
     for setting in last_used {
@@ -442,6 +573,21 @@
 
 /// Get actions for the note switcher dialog (Cmd+P in Notes window).
 pub fn get_note_switcher_actions(notes: &[NoteSwitcherNoteInfo]) -> Vec<Action> {
+    let invalid_note_count = notes
+        .iter()
+        .filter(|note| has_invalid_note_switcher_note_info(note))
+        .count();
+    if invalid_note_count > 0 {
+        tracing::warn!(
+            target: "script_kit::actions",
+            builder = "note_switcher",
+            note_count = notes.len(),
+            invalid_note_count,
+            "Invalid note switcher input; returning empty actions"
+        );
+        return vec![];
+    }
+
     let mut actions = Vec::new();
 
     for note in notes {
diff --git a/src/actions/builders/script_context.rs b/src/actions/builders/script_context.rs
index d48add6d0604e4fc8ab6bc1d9a9cdc328a6037ab..c09068069325e288d1c697a6ed9aa07944aadf61
--- a/src/actions/builders/script_context.rs
+++ b/src/actions/builders/script_context.rs
@@ -2,8 +2,23 @@
 use super::types::{Action, ActionCategory, ScriptInfo};
 use std::collections::HashSet;
 
+fn has_invalid_script_context_input(script: &ScriptInfo) -> bool {
+    script.name.trim().is_empty() || script.action_verb.trim().is_empty()
+}
+
 /// Get actions specific to the focused script.
 pub fn get_script_context_actions(script: &ScriptInfo) -> Vec<Action> {
+    if has_invalid_script_context_input(script) {
+        tracing::warn!(
+            target: "script_kit::actions",
+            builder = "script_context",
+            name = %script.name,
+            action_verb = %script.action_verb,
+            "Invalid script context input; returning empty actions"
+        );
+        return vec![];
+    }
+
     let mut actions = Vec::new();
     let mut destructive_actions = Vec::new();
 
@@ -314,3 +329,26 @@
 pub fn get_global_actions() -> Vec<Action> {
     vec![]
 }
+
+#[cfg(test)]
+mod tests {
+    use super::*;
+
+    #[test]
+    fn test_get_script_context_actions_returns_empty_when_name_is_blank() {
+        let mut script = ScriptInfo::new("Valid", "/tmp/valid.ts");
+        script.name = "   ".to_string();
+
+        let actions = get_script_context_actions(&script);
+        assert!(actions.is_empty());
+    }
+
+    #[test]
+    fn test_get_script_context_actions_returns_empty_when_action_verb_is_blank() {
+        let mut script = ScriptInfo::new("Valid", "/tmp/valid.ts");
+        script.action_verb = "   ".to_string();
+
+        let actions = get_script_context_actions(&script);
+        assert!(actions.is_empty());
+    }
+}
diff --git a/src/actions/builders/scriptlet.rs b/src/actions/builders/scriptlet.rs
index 371dbac6d433b01ee915aebdcd5f371b952065da..fec3eaa1d184df4366bf235fd3293d99a97cb120
--- a/src/actions/builders/scriptlet.rs
+++ b/src/actions/builders/scriptlet.rs
@@ -1,11 +1,31 @@
 use super::shared::{format_shortcut_hint, to_deeplink_name};
 use super::types::{Action, ActionCategory, ScriptInfo};
 use crate::designs::icon_variations::IconName;
-use crate::scriptlets::Scriptlet;
+use crate::scriptlets::{Scriptlet, ScriptletAction};
 use std::collections::HashSet;
 
 const SCRIPTLET_ACTION_ID_PREFIX: &str = "scriptlet_action:";
 
+fn is_blank(value: &str) -> bool {
+    value.trim().is_empty()
+}
+
+fn has_invalid_scriptlet_context_input(script: &ScriptInfo) -> bool {
+    is_blank(&script.name) || is_blank(&script.action_verb)
+}
+
+fn has_invalid_scriptlet_action_input(action: &ScriptletAction) -> bool {
+    is_blank(&action.name) || is_blank(&action.command)
+}
+
+fn count_invalid_scriptlet_actions(scriptlet: &Scriptlet) -> usize {
+    scriptlet
+        .actions
+        .iter()
+        .filter(|action| has_invalid_scriptlet_action_input(action))
+        .count()
+}
+
 fn parse_scriptlet_action_command(action_id: &str) -> Option<&str> {
     action_id
         .strip_prefix(SCRIPTLET_ACTION_ID_PREFIX)
@@ -14,18 +34,9 @@
 
 fn unique_scriptlet_action_id(
     raw_action_id: &str,
-    action_name: &str,
     used_action_ids: &mut HashSet<String>,
 ) -> Option<String> {
-    let Some(action_command) = parse_scriptlet_action_command(raw_action_id) else {
-        tracing::warn!(
-            target: "script_kit::actions",
-            action_name = %action_name,
-            action_id = %raw_action_id,
-            "Failed to parse scriptlet H3 action id; dropping malformed action"
-        );
-        return None;
-    };
+    let action_command = parse_scriptlet_action_command(raw_action_id)?;
 
     let mut unique_action_id = raw_action_id.to_string();
     let mut duplicate_index = 2;
@@ -38,7 +49,6 @@
     if unique_action_id != raw_action_id {
         tracing::debug!(
             target: "script_kit::actions",
-            action_name = %action_name,
             original_action_id = %raw_action_id,
             deduped_action_id = %unique_action_id,
             "Deduplicated scriptlet H3 action id"
@@ -51,40 +61,62 @@
 
 /// Convert scriptlet-defined actions (from H3 headers) to Action structs for the UI.
 pub fn get_scriptlet_defined_actions(scriptlet: &Scriptlet) -> Vec<Action> {
+    let invalid_action_count = count_invalid_scriptlet_actions(scriptlet);
+    if invalid_action_count > 0 {
+        tracing::warn!(
+            target: "script_kit::actions",
+            builder = "scriptlet_defined",
+            scriptlet_name = %scriptlet.name,
+            action_count = scriptlet.actions.len(),
+            invalid_action_count,
+            "Invalid scriptlet-defined action input; returning empty actions"
+        );
+        return vec![];
+    }
+
     let mut used_action_ids = HashSet::new();
-    let actions: Vec<Action> = scriptlet
-        .actions
-        .iter()
-        .filter_map(|sa| {
-            let raw_action_id = sa.action_id();
-            let action_id =
-                unique_scriptlet_action_id(&raw_action_id, &sa.name, &mut used_action_ids)?;
-            let mut action = Action::new(
-                action_id,
-                &sa.name,
-                sa.description.clone(),
-                ActionCategory::ScriptContext,
+    let mut actions: Vec<Action> = Vec::with_capacity(scriptlet.actions.len());
+
+    for sa in &scriptlet.actions {
+        let raw_action_id = sa.action_id();
+        let Some(action_id) = unique_scriptlet_action_id(&raw_action_id, &mut used_action_ids)
+        else {
+            tracing::warn!(
+                target: "script_kit::actions",
+                builder = "scriptlet_defined",
+                scriptlet_name = %scriptlet.name,
+                action_name = %sa.name,
+                action_id = %raw_action_id,
+                "Invalid scriptlet action id input; returning empty actions"
             );
+            return vec![];
+        };
 
-            if let Some(ref shortcut) = sa.shortcut {
-                action = action.with_shortcut(format_shortcut_hint(shortcut));
-            }
+        let mut action = Action::new(
+            action_id,
+            &sa.name,
+            sa.description.clone(),
+            ActionCategory::ScriptContext,
+        );
 
-            action = action.with_icon(IconName::PlayFilled).with_section("Actions");
-            action.has_action = true;
-            action.value = Some(sa.command.clone());
+        if let Some(ref shortcut) = sa.shortcut {
+            action = action.with_shortcut(format_shortcut_hint(shortcut));
+        }
 
-            tracing::debug!(
-                target: "script_kit::actions",
-                action_id = %action.id,
-                has_action = action.has_action,
-                has_shortcut = action.shortcut.is_some(),
-                "Created scriptlet-defined action (has_action=true)"
-            );
+        action = action.with_icon(IconName::PlayFilled).with_section("Actions");
+        action.has_action = true;
+        action.value = Some(sa.command.clone());
+
+        tracing::debug!(
+            target: "script_kit::actions",
+            action_id = %action.id,
+            has_action = action.has_action,
+            has_shortcut = action.shortcut.is_some(),
+            "Created scriptlet-defined action (has_action=true)"
+        );
 
-            Some(action)
-        })
-        .collect();
+        actions.push(action);
+    }
 
     if !actions.is_empty() {
         tracing::debug!(
@@ -103,6 +135,32 @@
     script: &ScriptInfo,
     scriptlet: Option<&Scriptlet>,
 ) -> Vec<Action> {
+    if has_invalid_scriptlet_context_input(script) {
+        tracing::warn!(
+            target: "script_kit::actions",
+            builder = "scriptlet_context",
+            name = %script.name,
+            action_verb = %script.action_verb,
+            "Invalid scriptlet context input; returning empty actions"
+        );
+        return vec![];
+    }
+
+    if let Some(scriptlet) = scriptlet {
+        let invalid_action_count = count_invalid_scriptlet_actions(scriptlet);
+        if invalid_action_count > 0 {
+            tracing::warn!(
+                target: "script_kit::actions",
+                builder = "scriptlet_context",
+                scriptlet_name = %scriptlet.name,
+                action_count = scriptlet.actions.len(),
+                invalid_action_count,
+                "Invalid scriptlet-defined action input; returning empty actions"
+            );
+            return vec![];
+        }
+    }
+
     let mut actions = Vec::new();
     let mut destructive_actions = Vec::new();
 
@@ -342,7 +400,7 @@
     }
 
     #[test]
-    fn test_get_scriptlet_defined_actions_drops_action_when_command_is_empty() {
+    fn test_get_scriptlet_defined_actions_returns_empty_when_command_is_empty() {
         let mut scriptlet = Scriptlet::new(
             "Malformed".to_string(),
             "bash".to_string(),
@@ -355,6 +413,53 @@
     }
 
     #[test]
+    fn test_get_scriptlet_defined_actions_returns_empty_when_any_action_is_invalid() {
+        let mut scriptlet = Scriptlet::new(
+            "Mixed".to_string(),
+            "bash".to_string(),
+            "echo".to_string(),
+        );
+        scriptlet.actions = vec![
+            scriptlet_action("Valid", "copy"),
+            scriptlet_action("   ", "invalid"),
+        ];
+
+        let actions = get_scriptlet_defined_actions(&scriptlet);
+        assert!(actions.is_empty());
+    }
+
+    #[test]
+    fn test_get_scriptlet_context_actions_returns_empty_when_script_name_is_blank() {
+        let mut script =
+            ScriptInfo::scriptlet("Demo", "/tmp/demo.md", Some("cmd d".to_string()), None);
+        script.name = "   ".to_string();
+
+        let actions = get_scriptlet_context_actions_with_custom(&script, None);
+        assert!(actions.is_empty());
+    }
+
+    #[test]
+    fn test_get_scriptlet_context_actions_returns_empty_when_action_verb_is_blank() {
+        let mut script =
+            ScriptInfo::scriptlet("Demo", "/tmp/demo.md", Some("cmd d".to_string()), None);
+        script.action_verb = "   ".to_string();
+
+        let actions = get_scriptlet_context_actions_with_custom(&script, None);
+        assert!(actions.is_empty());
+    }
+
+    #[test]
+    fn test_get_scriptlet_context_actions_returns_empty_when_scriptlet_action_input_is_invalid() {
+        let script = ScriptInfo::scriptlet("Demo", "/tmp/demo.md", Some("cmd d".to_string()), None);
+        let mut scriptlet =
+            Scriptlet::new("Malformed".to_string(), "bash".to_string(), "echo".to_string());
+        scriptlet.actions = vec![scriptlet_action("Bad", "   ")];
+
+        let actions = get_scriptlet_context_actions_with_custom(&script, Some(&scriptlet));
+        assert!(actions.is_empty());
+    }
+
+    #[test]
     fn test_get_scriptlet_context_actions_assigns_consistent_primary_icons() {
         let script = ScriptInfo::scriptlet("Demo", "/tmp/demo.md", Some("cmd d".to_string()), None);
         let actions = get_scriptlet_context_actions_with_custom(&script, None);

file update:
diff --git a/src/actions/builders/notes.rs b/src/actions/builders/notes.rs
index 48ba267e97bf2f3da7ecf1a3f78fea59dbc9acab..a2f0007d3327b005960130e6e30f524ceb6b3e9f
--- a/src/actions/builders/notes.rs
+++ b/src/actions/builders/notes.rs
@@ -27,6 +27,25 @@
     pub auto_sizing_enabled: bool,
 }
 
+fn is_blank(value: &str) -> bool {
+    value.trim().is_empty()
+}
+
+fn has_invalid_new_chat_model_info(model: &NewChatModelInfo) -> bool {
+    is_blank(&model.model_id)
+        || is_blank(&model.display_name)
+        || is_blank(&model.provider)
+        || is_blank(&model.provider_display_name)
+}
+
+fn has_invalid_new_chat_preset_info(preset: &NewChatPresetInfo) -> bool {
+    is_blank(&preset.id) || is_blank(&preset.name)
+}
+
+fn has_invalid_note_switcher_note_info(note: &NoteSwitcherNoteInfo) -> bool {
+    is_blank(&note.id) || is_blank(&note.title)
+}
+
 /// Get actions for the Notes window command bar (Cmd+K menu).
 pub fn get_notes_command_bar_actions(info: &NotesInfo) -> Vec<Action> {
     let mut actions = Vec::new();
@@ -367,6 +386,76 @@
             Some("Use Focused Writing preset")
         );
     }
+
+    #[test]
+    fn test_get_new_chat_actions_returns_empty_when_last_used_model_input_is_invalid() {
+        let last_used = vec![NewChatModelInfo {
+            model_id: "   ".to_string(),
+            display_name: "GPT-4o Mini".to_string(),
+            provider: "openai".to_string(),
+            provider_display_name: "OpenAI".to_string(),
+        }];
+        let presets = vec![NewChatPresetInfo {
+            id: "focused-writing".to_string(),
+            name: "Focused Writing".to_string(),
+            icon: IconName::Pencil,
+        }];
+
+        let actions = get_new_chat_actions(&last_used, &presets, &[]);
+        assert!(actions.is_empty());
+    }
+
+    #[test]
+    fn test_get_new_chat_actions_returns_empty_when_preset_input_is_invalid() {
+        let last_used = vec![NewChatModelInfo {
+            model_id: "gpt-4o-mini".to_string(),
+            display_name: "GPT-4o Mini".to_string(),
+            provider: "openai".to_string(),
+            provider_display_name: "OpenAI".to_string(),
+        }];
+        let presets = vec![NewChatPresetInfo {
+            id: "   ".to_string(),
+            name: "Focused Writing".to_string(),
+            icon: IconName::Pencil,
+        }];
+
+        let actions = get_new_chat_actions(&last_used, &presets, &[]);
+        assert!(actions.is_empty());
+    }
+
+    #[test]
+    fn test_get_new_chat_actions_returns_empty_when_model_input_is_invalid() {
+        let presets = vec![NewChatPresetInfo {
+            id: "focused-writing".to_string(),
+            name: "Focused Writing".to_string(),
+            icon: IconName::Pencil,
+        }];
+        let models = vec![NewChatModelInfo {
+            model_id: "claude-3-5-sonnet".to_string(),
+            display_name: "Claude 3.5 Sonnet".to_string(),
+            provider: "   ".to_string(),
+            provider_display_name: "Anthropic".to_string(),
+        }];
+
+        let actions = get_new_chat_actions(&[], &presets, &models);
+        assert!(actions.is_empty());
+    }
+
+    #[test]
+    fn test_get_note_switcher_actions_returns_empty_when_note_input_is_invalid() {
+        let notes = vec![NoteSwitcherNoteInfo {
+            id: "   ".to_string(),
+            title: "Missing ID".to_string(),
+            char_count: 5,
+            is_current: false,
+            is_pinned: false,
+            preview: "Preview".to_string(),
+            relative_time: "1m ago".to_string(),
+        }];
+
+        let actions = get_note_switcher_actions(&notes);
+        assert!(actions.is_empty());
+    }
 }
 
 /// Build actions for the AI new chat dropdown.
@@ -376,6 +465,48 @@
     presets: &[NewChatPresetInfo],
     models: &[NewChatModelInfo],
 ) -> Vec<Action> {
+    let invalid_last_used_count = last_used
+        .iter()
+        .filter(|model| has_invalid_new_chat_model_info(model))
+        .count();
+    if invalid_last_used_count > 0 {
+        tracing::warn!(
+            target: "script_kit::actions",
+            builder = "notes_new_chat",
+            invalid_last_used_count,
+            "Invalid last-used chat model input; returning empty actions"
+        );
+        return vec![];
+    }
+
+    let invalid_preset_count = presets
+        .iter()
+        .filter(|preset| has_invalid_new_chat_preset_info(preset))
+        .count();
+    if invalid_preset_count > 0 {
+        tracing::warn!(
+            target: "script_kit::actions",
+            builder = "notes_new_chat",
+            invalid_preset_count,
+            "Invalid chat preset input; returning empty actions"
+        );
+        return vec![];
+    }
+
+    let invalid_model_count = models
+        .iter()
+        .filter(|model| has_invalid_new_chat_model_info(model))
+        .count();
+    if invalid_model_count > 0 {
+        tracing::warn!(
+            target: "script_kit::actions",
+            builder = "notes_new_chat",
+            invalid_model_count,
+            "Invalid chat model input; returning empty actions"
+        );
+        return vec![];
+    }
+
     let mut actions = Vec::new();
 
     for setting in last_used {
@@ -442,6 +573,21 @@
 
 /// Get actions for the note switcher dialog (Cmd+P in Notes window).
 pub fn get_note_switcher_actions(notes: &[NoteSwitcherNoteInfo]) -> Vec<Action> {
+    let invalid_note_count = notes
+        .iter()
+        .filter(|note| has_invalid_note_switcher_note_info(note))
+        .count();
+    if invalid_note_count > 0 {
+        tracing::warn!(
+            target: "script_kit::actions",
+            builder = "note_switcher",
+            note_count = notes.len(),
+            invalid_note_count,
+            "Invalid note switcher input; returning empty actions"
+        );
+        return vec![];
+    }
+
     let mut actions = Vec::new();
 
     for note in notes {
diff --git a/src/actions/builders/script_context.rs b/src/actions/builders/script_context.rs
index d48add6d0604e4fc8ab6bc1d9a9cdc328a6037ab..c09068069325e288d1c697a6ed9aa07944aadf61
--- a/src/actions/builders/script_context.rs
+++ b/src/actions/builders/script_context.rs
@@ -2,8 +2,23 @@
 use super::types::{Action, ActionCategory, ScriptInfo};
 use std::collections::HashSet;
 
+fn has_invalid_script_context_input(script: &ScriptInfo) -> bool {
+    script.name.trim().is_empty() || script.action_verb.trim().is_empty()
+}
+
 /// Get actions specific to the focused script.
 pub fn get_script_context_actions(script: &ScriptInfo) -> Vec<Action> {
+    if has_invalid_script_context_input(script) {
+        tracing::warn!(
+            target: "script_kit::actions",
+            builder = "script_context",
+            name = %script.name,
+            action_verb = %script.action_verb,
+            "Invalid script context input; returning empty actions"
+        );
+        return vec![];
+    }
+
     let mut actions = Vec::new();
     let mut destructive_actions = Vec::new();
 
@@ -314,3 +329,26 @@
 pub fn get_global_actions() -> Vec<Action> {
     vec![]
 }
+
+#[cfg(test)]
+mod tests {
+    use super::*;
+
+    #[test]
+    fn test_get_script_context_actions_returns_empty_when_name_is_blank() {
+        let mut script = ScriptInfo::new("Valid", "/tmp/valid.ts");
+        script.name = "   ".to_string();
+
+        let actions = get_script_context_actions(&script);
+        assert!(actions.is_empty());
+    }
+
+    #[test]
+    fn test_get_script_context_actions_returns_empty_when_action_verb_is_blank() {
+        let mut script = ScriptInfo::new("Valid", "/tmp/valid.ts");
+        script.action_verb = "   ".to_string();
+
+        let actions = get_script_context_actions(&script);
+        assert!(actions.is_empty());
+    }
+}
diff --git a/src/actions/builders/scriptlet.rs b/src/actions/builders/scriptlet.rs
index 371dbac6d433b01ee915aebdcd5f371b952065da..fec3eaa1d184df4366bf235fd3293d99a97cb120
--- a/src/actions/builders/scriptlet.rs
+++ b/src/actions/builders/scriptlet.rs
@@ -1,11 +1,31 @@
 use super::shared::{format_shortcut_hint, to_deeplink_name};
 use super::types::{Action, ActionCategory, ScriptInfo};
 use crate::designs::icon_variations::IconName;
-use crate::scriptlets::Scriptlet;
+use crate::scriptlets::{Scriptlet, ScriptletAction};
 use std::collections::HashSet;
 
 const SCRIPTLET_ACTION_ID_PREFIX: &str = "scriptlet_action:";
 
+fn is_blank(value: &str) -> bool {
+    value.trim().is_empty()
+}
+
+fn has_invalid_scriptlet_context_input(script: &ScriptInfo) -> bool {
+    is_blank(&script.name) || is_blank(&script.action_verb)
+}
+
+fn has_invalid_scriptlet_action_input(action: &ScriptletAction) -> bool {
+    is_blank(&action.name) || is_blank(&action.command)
+}
+
+fn count_invalid_scriptlet_actions(scriptlet: &Scriptlet) -> usize {
+    scriptlet
+        .actions
+        .iter()
+        .filter(|action| has_invalid_scriptlet_action_input(action))
+        .count()
+}
+
 fn parse_scriptlet_action_command(action_id: &str) -> Option<&str> {
     action_id
         .strip_prefix(SCRIPTLET_ACTION_ID_PREFIX)
@@ -14,18 +34,9 @@
 
 fn unique_scriptlet_action_id(
     raw_action_id: &str,
-    action_name: &str,
     used_action_ids: &mut HashSet<String>,
 ) -> Option<String> {
-    let Some(action_command) = parse_scriptlet_action_command(raw_action_id) else {
-        tracing::warn!(
-            target: "script_kit::actions",
-            action_name = %action_name,
-            action_id = %raw_action_id,
-            "Failed to parse scriptlet H3 action id; dropping malformed action"
-        );
-        return None;
-    };
+    let action_command = parse_scriptlet_action_command(raw_action_id)?;
 
     let mut unique_action_id = raw_action_id.to_string();
     let mut duplicate_index = 2;
@@ -38,7 +49,6 @@
     if unique_action_id != raw_action_id {
         tracing::debug!(
             target: "script_kit::actions",
-            action_name = %action_name,
             original_action_id = %raw_action_id,
             deduped_action_id = %unique_action_id,
             "Deduplicated scriptlet H3 action id"
@@ -51,40 +61,62 @@
 
 /// Convert scriptlet-defined actions (from H3 headers) to Action structs for the UI.
 pub fn get_scriptlet_defined_actions(scriptlet: &Scriptlet) -> Vec<Action> {
+    let invalid_action_count = count_invalid_scriptlet_actions(scriptlet);
+    if invalid_action_count > 0 {
+        tracing::warn!(
+            target: "script_kit::actions",
+            builder = "scriptlet_defined",
+            scriptlet_name = %scriptlet.name,
+            action_count = scriptlet.actions.len(),
+            invalid_action_count,
+            "Invalid scriptlet-defined action input; returning empty actions"
+        );
+        return vec![];
+    }
+
     let mut used_action_ids = HashSet::new();
-    let actions: Vec<Action> = scriptlet
-        .actions
-        .iter()
-        .filter_map(|sa| {
-            let raw_action_id = sa.action_id();
-            let action_id =
-                unique_scriptlet_action_id(&raw_action_id, &sa.name, &mut used_action_ids)?;
-            let mut action = Action::new(
-                action_id,
-                &sa.name,
-                sa.description.clone(),
-                ActionCategory::ScriptContext,
+    let mut actions: Vec<Action> = Vec::with_capacity(scriptlet.actions.len());
+
+    for sa in &scriptlet.actions {
+        let raw_action_id = sa.action_id();
+        let Some(action_id) = unique_scriptlet_action_id(&raw_action_id, &mut used_action_ids)
+        else {
+            tracing::warn!(
+                target: "script_kit::actions",
+                builder = "scriptlet_defined",
+                scriptlet_name = %scriptlet.name,
+                action_name = %sa.name,
+                action_id = %raw_action_id,
+                "Invalid scriptlet action id input; returning empty actions"
             );
+            return vec![];
+        };
 
-            if let Some(ref shortcut) = sa.shortcut {
-                action = action.with_shortcut(format_shortcut_hint(shortcut));
-            }
+        let mut action = Action::new(
+            action_id,
+            &sa.name,
+            sa.description.clone(),
+            ActionCategory::ScriptContext,
+        );
 
-            action = action.with_icon(IconName::PlayFilled).with_section("Actions");
-            action.has_action = true;
-            action.value = Some(sa.command.clone());
+        if let Some(ref shortcut) = sa.shortcut {
+            action = action.with_shortcut(format_shortcut_hint(shortcut));
+        }
 
-            tracing::debug!(
-                target: "script_kit::actions",
-                action_id = %action.id,
-                has_action = action.has_action,
-                has_shortcut = action.shortcut.is_some(),
-                "Created scriptlet-defined action (has_action=true)"
-            );
+        action = action.with_icon(IconName::PlayFilled).with_section("Actions");
+        action.has_action = true;
+        action.value = Some(sa.command.clone());
+
+        tracing::debug!(
+            target: "script_kit::actions",
+            action_id = %action.id,
+            has_action = action.has_action,
+            has_shortcut = action.shortcut.is_some(),
+            "Created scriptlet-defined action (has_action=true)"
+        );
 
-            Some(action)
-        })
-        .collect();
+        actions.push(action);
+    }
 
     if !actions.is_empty() {
         tracing::debug!(
@@ -103,6 +135,32 @@
     script: &ScriptInfo,
     scriptlet: Option<&Scriptlet>,
 ) -> Vec<Action> {
+    if has_invalid_scriptlet_context_input(script) {
+        tracing::warn!(
+            target: "script_kit::actions",
+            builder = "scriptlet_context",
+            name = %script.name,
+            action_verb = %script.action_verb,
+            "Invalid scriptlet context input; returning empty actions"
+        );
+        return vec![];
+    }
+
+    if let Some(scriptlet) = scriptlet {
+        let invalid_action_count = count_invalid_scriptlet_actions(scriptlet);
+        if invalid_action_count > 0 {
+            tracing::warn!(
+                target: "script_kit::actions",
+                builder = "scriptlet_context",
+                scriptlet_name = %scriptlet.name,
+                action_count = scriptlet.actions.len(),
+                invalid_action_count,
+                "Invalid scriptlet-defined action input; returning empty actions"
+            );
+            return vec![];
+        }
+    }
+
     let mut actions = Vec::new();
     let mut destructive_actions = Vec::new();
 
@@ -342,7 +400,7 @@
     }
 
     #[test]
-    fn test_get_scriptlet_defined_actions_drops_action_when_command_is_empty() {
+    fn test_get_scriptlet_defined_actions_returns_empty_when_command_is_empty() {
         let mut scriptlet = Scriptlet::new(
             "Malformed".to_string(),
             "bash".to_string(),
@@ -355,6 +413,53 @@
     }
 
     #[test]
+    fn test_get_scriptlet_defined_actions_returns_empty_when_any_action_is_invalid() {
+        let mut scriptlet = Scriptlet::new(
+            "Mixed".to_string(),
+            "bash".to_string(),
+            "echo".to_string(),
+        );
+        scriptlet.actions = vec![
+            scriptlet_action("Valid", "copy"),
+            scriptlet_action("   ", "invalid"),
+        ];
+
+        let actions = get_scriptlet_defined_actions(&scriptlet);
+        assert!(actions.is_empty());
+    }
+
+    #[test]
+    fn test_get_scriptlet_context_actions_returns_empty_when_script_name_is_blank() {
+        let mut script =
+            ScriptInfo::scriptlet("Demo", "/tmp/demo.md", Some("cmd d".to_string()), None);
+        script.name = "   ".to_string();
+
+        let actions = get_scriptlet_context_actions_with_custom(&script, None);
+        assert!(actions.is_empty());
+    }
+
+    #[test]
+    fn test_get_scriptlet_context_actions_returns_empty_when_action_verb_is_blank() {
+        let mut script =
+            ScriptInfo::scriptlet("Demo", "/tmp/demo.md", Some("cmd d".to_string()), None);
+        script.action_verb = "   ".to_string();
+
+        let actions = get_scriptlet_context_actions_with_custom(&script, None);
+        assert!(actions.is_empty());
+    }
+
+    #[test]
+    fn test_get_scriptlet_context_actions_returns_empty_when_scriptlet_action_input_is_invalid() {
+        let script = ScriptInfo::scriptlet("Demo", "/tmp/demo.md", Some("cmd d".to_string()), None);
+        let mut scriptlet =
+            Scriptlet::new("Malformed".to_string(), "bash".to_string(), "echo".to_string());
+        scriptlet.actions = vec![scriptlet_action("Bad", "   ")];
+
+        let actions = get_scriptlet_context_actions_with_custom(&script, Some(&scriptlet));
+        assert!(actions.is_empty());
+    }
+
+    #[test]
     fn test_get_scriptlet_context_actions_assigns_consistent_primary_icons() {
         let script = ScriptInfo::scriptlet("Demo", "/tmp/demo.md", Some("cmd d".to_string()), None);
         let actions = get_scriptlet_context_actions_with_custom(&script, None);


thinking
**Handling possible lingering session**
file update:
diff --git a/src/actions/builders/notes.rs b/src/actions/builders/notes.rs
index 48ba267e97bf2f3da7ecf1a3f78fea59dbc9acab..a2f0007d3327b005960130e6e30f524ceb6b3e9f
--- a/src/actions/builders/notes.rs
+++ b/src/actions/builders/notes.rs
@@ -27,6 +27,25 @@
     pub auto_sizing_enabled: bool,
 }
 
+fn is_blank(value: &str) -> bool {
+    value.trim().is_empty()
+}
+
+fn has_invalid_new_chat_model_info(model: &NewChatModelInfo) -> bool {
+    is_blank(&model.model_id)
+        || is_blank(&model.display_name)
+        || is_blank(&model.provider)
+        || is_blank(&model.provider_display_name)
+}
+
+fn has_invalid_new_chat_preset_info(preset: &NewChatPresetInfo) -> bool {
+    is_blank(&preset.id) || is_blank(&preset.name)
+}
+
+fn has_invalid_note_switcher_note_info(note: &NoteSwitcherNoteInfo) -> bool {
+    is_blank(&note.id) || is_blank(&note.title)
+}
+
 /// Get actions for the Notes window command bar (Cmd+K menu).
 pub fn get_notes_command_bar_actions(info: &NotesInfo) -> Vec<Action> {
     let mut actions = Vec::new();
@@ -367,6 +386,76 @@
             Some("Use Focused Writing preset")
         );
     }
+
+    #[test]
+    fn test_get_new_chat_actions_returns_empty_when_last_used_model_input_is_invalid() {
+        let last_used = vec![NewChatModelInfo {
+            model_id: "   ".to_string(),
+            display_name: "GPT-4o Mini".to_string(),
+            provider: "openai".to_string(),
+            provider_display_name: "OpenAI".to_string(),
+        }];
+        let presets = vec![NewChatPresetInfo {
+            id: "focused-writing".to_string(),
+            name: "Focused Writing".to_string(),
+            icon: IconName::Pencil,
+        }];
+
+        let actions = get_new_chat_actions(&last_used, &presets, &[]);
+        assert!(actions.is_empty());
+    }
+
+    #[test]
+    fn test_get_new_chat_actions_returns_empty_when_preset_input_is_invalid() {
+        let last_used = vec![NewChatModelInfo {
+            model_id: "gpt-4o-mini".to_string(),
+            display_name: "GPT-4o Mini".to_string(),
+            provider: "openai".to_string(),
+            provider_display_name: "OpenAI".to_string(),
+        }];
+        let presets = vec![NewChatPresetInfo {
+            id: "   ".to_string(),
+            name: "Focused Writing".to_string(),
+            icon: IconName::Pencil,
+        }];
+
+        let actions = get_new_chat_actions(&last_used, &presets, &[]);
+        assert!(actions.is_empty());
+    }
+
+    #[test]
+    fn test_get_new_chat_actions_returns_empty_when_model_input_is_invalid() {
+        let presets = vec![NewChatPresetInfo {
+            id: "focused-writing".to_string(),
+            name: "Focused Writing".to_string(),
+            icon: IconName::Pencil,
+        }];
+        let models = vec![NewChatModelInfo {
+            model_id: "claude-3-5-sonnet".to_string(),
+            display_name: "Claude 3.5 Sonnet".to_string(),
+            provider: "   ".to_string(),
+            provider_display_name: "Anthropic".to_string(),
+        }];
+
+        let actions = get_new_chat_actions(&[], &presets, &models);
+        assert!(actions.is_empty());
+    }
+
+    #[test]
+    fn test_get_note_switcher_actions_returns_empty_when_note_input_is_invalid() {
+        let notes = vec![NoteSwitcherNoteInfo {
+            id: "   ".to_string(),
+            title: "Missing ID".to_string(),
+            char_count: 5,
+            is_current: false,
+            is_pinned: false,
+            preview: "Preview".to_string(),
+            relative_time: "1m ago".to_string(),
+        }];
+
+        let actions = get_note_switcher_actions(&notes);
+        assert!(actions.is_empty());
+    }
 }
 
 /// Build actions for the AI new chat dropdown.
@@ -376,6 +465,48 @@
     presets: &[NewChatPresetInfo],
     models: &[NewChatModelInfo],
 ) -> Vec<Action> {
+    let invalid_last_used_count = last_used
+        .iter()
+        .filter(|model| has_invalid_new_chat_model_info(model))
+        .count();
+    if invalid_last_used_count > 0 {
+        tracing::warn!(
+            target: "script_kit::actions",
+            builder = "notes_new_chat",
+            invalid_last_used_count,
+            "Invalid last-used chat model input; returning empty actions"
+        );
+        return vec![];
+    }
+
+    let invalid_preset_count = presets
+        .iter()
+        .filter(|preset| has_invalid_new_chat_preset_info(preset))
+        .count();
+    if invalid_preset_count > 0 {
+        tracing::warn!(
+            target: "script_kit::actions",
+            builder = "notes_new_chat",
+            invalid_preset_count,
+            "Invalid chat preset input; returning empty actions"
+        );
+        return vec![];
+    }
+
+    let invalid_model_count = models
+        .iter()
+        .filter(|model| has_invalid_new_chat_model_info(model))
+        .count();
+    if invalid_model_count > 0 {
+        tracing::warn!(
+            target: "script_kit::actions",
+            builder = "notes_new_chat",
+            invalid_model_count,
+            "Invalid chat model input; returning empty actions"
+        );
+        return vec![];
+    }
+
     let mut actions = Vec::new();
 
     for setting in last_used {
@@ -442,6 +573,21 @@
 
 /// Get actions for the note switcher dialog (Cmd+P in Notes window).
 pub fn get_note_switcher_actions(notes: &[NoteSwitcherNoteInfo]) -> Vec<Action> {
+    let invalid_note_count = notes
+        .iter()
+        .filter(|note| has_invalid_note_switcher_note_info(note))
+        .count();
+    if invalid_note_count > 0 {
+        tracing::warn!(
+            target: "script_kit::actions",
+            builder = "note_switcher",
+            note_count = notes.len(),
+            invalid_note_count,
+            "Invalid note switcher input; returning empty actions"
+        );
+        return vec![];
+    }
+
     let mut actions = Vec::new();
 
     for note in notes {
diff --git a/src/actions/builders/script_context.rs b/src/actions/builders/script_context.rs
index d48add6d0604e4fc8ab6bc1d9a9cdc328a6037ab..c09068069325e288d1c697a6ed9aa07944aadf61
--- a/src/actions/builders/script_context.rs
+++ b/src/actions/builders/script_context.rs
@@ -2,8 +2,23 @@
 use super::types::{Action, ActionCategory, ScriptInfo};
 use std::collections::HashSet;
 
+fn has_invalid_script_context_input(script: &ScriptInfo) -> bool {
+    script.name.trim().is_empty() || script.action_verb.trim().is_empty()
+}
+
 /// Get actions specific to the focused script.
 pub fn get_script_context_actions(script: &ScriptInfo) -> Vec<Action> {
+    if has_invalid_script_context_input(script) {
+        tracing::warn!(
+            target: "script_kit::actions",
+            builder = "script_context",
+            name = %script.name,
+            action_verb = %script.action_verb,
+            "Invalid script context input; returning empty actions"
+        );
+        return vec![];
+    }
+
     let mut actions = Vec::new();
     let mut destructive_actions = Vec::new();
 
@@ -314,3 +329,26 @@
 pub fn get_global_actions() -> Vec<Action> {
     vec![]
 }
+
+#[cfg(test)]
+mod tests {
+    use super::*;
+
+    #[test]
+    fn test_get_script_context_actions_returns_empty_when_name_is_blank() {
+        let mut script = ScriptInfo::new("Valid", "/tmp/valid.ts");
+        script.name = "   ".to_string();
+
+        let actions = get_script_context_actions(&script);
+        assert!(actions.is_empty());
+    }
+
+    #[test]
+    fn test_get_script_context_actions_returns_empty_when_action_verb_is_blank() {
+        let mut script = ScriptInfo::new("Valid", "/tmp/valid.ts");
+        script.action_verb = "   ".to_string();
+
+        let actions = get_script_context_actions(&script);
+        assert!(actions.is_empty());
+    }
+}
diff --git a/src/actions/builders/scriptlet.rs b/src/actions/builders/scriptlet.rs
index 371dbac6d433b01ee915aebdcd5f371b952065da..fec3eaa1d184df4366bf235fd3293d99a97cb120
--- a/src/actions/builders/scriptlet.rs
+++ b/src/actions/builders/scriptlet.rs
@@ -1,11 +1,31 @@
 use super::shared::{format_shortcut_hint, to_deeplink_name};
 use super::types::{Action, ActionCategory, ScriptInfo};
 use crate::designs::icon_variations::IconName;
-use crate::scriptlets::Scriptlet;
+use crate::scriptlets::{Scriptlet, ScriptletAction};
 use std::collections::HashSet;
 
 const SCRIPTLET_ACTION_ID_PREFIX: &str = "scriptlet_action:";
 
+fn is_blank(value: &str) -> bool {
+    value.trim().is_empty()
+}
+
+fn has_invalid_scriptlet_context_input(script: &ScriptInfo) -> bool {
+    is_blank(&script.name) || is_blank(&script.action_verb)
+}
+
+fn has_invalid_scriptlet_action_input(action: &ScriptletAction) -> bool {
+    is_blank(&action.name) || is_blank(&action.command)
+}
+
+fn count_invalid_scriptlet_actions(scriptlet: &Scriptlet) -> usize {
+    scriptlet
+        .actions
+        .iter()
+        .filter(|action| has_invalid_scriptlet_action_input(action))
+        .count()
+}
+
 fn parse_scriptlet_action_command(action_id: &str) -> Option<&str> {
     action_id
         .strip_prefix(SCRIPTLET_ACTION_ID_PREFIX)
@@ -14,18 +34,9 @@
 
 fn unique_scriptlet_action_id(
     raw_action_id: &str,
-    action_name: &str,
     used_action_ids: &mut HashSet<String>,
 ) -> Option<String> {
-    let Some(action_command) = parse_scriptlet_action_command(raw_action_id) else {
-        tracing::warn!(
-            target: "script_kit::actions",
-            action_name = %action_name,
-            action_id = %raw_action_id,
-            "Failed to parse scriptlet H3 action id; dropping malformed action"
-        );
-        return None;
-    };
+    let action_command = parse_scriptlet_action_command(raw_action_id)?;
 
     let mut unique_action_id = raw_action_id.to_string();
     let mut duplicate_index = 2;
@@ -38,7 +49,6 @@
     if unique_action_id != raw_action_id {
         tracing::debug!(
             target: "script_kit::actions",
-            action_name = %action_name,
             original_action_id = %raw_action_id,
             deduped_action_id = %unique_action_id,
             "Deduplicated scriptlet H3 action id"
@@ -51,40 +61,62 @@
 
 /// Convert scriptlet-defined actions (from H3 headers) to Action structs for the UI.
 pub fn get_scriptlet_defined_actions(scriptlet: &Scriptlet) -> Vec<Action> {
+    let invalid_action_count = count_invalid_scriptlet_actions(scriptlet);
+    if invalid_action_count > 0 {
+        tracing::warn!(
+            target: "script_kit::actions",
+            builder = "scriptlet_defined",
+            scriptlet_name = %scriptlet.name,
+            action_count = scriptlet.actions.len(),
+            invalid_action_count,
+            "Invalid scriptlet-defined action input; returning empty actions"
+        );
+        return vec![];
+    }
+
     let mut used_action_ids = HashSet::new();
-    let actions: Vec<Action> = scriptlet
-        .actions
-        .iter()
-        .filter_map(|sa| {
-            let raw_action_id = sa.action_id();
-            let action_id =
-                unique_scriptlet_action_id(&raw_action_id, &sa.name, &mut used_action_ids)?;
-            let mut action = Action::new(
-                action_id,
-                &sa.name,
-                sa.description.clone(),
-                ActionCategory::ScriptContext,
+    let mut actions: Vec<Action> = Vec::with_capacity(scriptlet.actions.len());
+
+    for sa in &scriptlet.actions {
+        let raw_action_id = sa.action_id();
+        let Some(action_id) = unique_scriptlet_action_id(&raw_action_id, &mut used_action_ids)
+        else {
+            tracing::warn!(
+                target: "script_kit::actions",
+                builder = "scriptlet_defined",
+                scriptlet_name = %scriptlet.name,
+                action_name = %sa.name,
+                action_id = %raw_action_id,
+                "Invalid scriptlet action id input; returning empty actions"
             );
+            return vec![];
+        };
 
-            if let Some(ref shortcut) = sa.shortcut {
-                action = action.with_shortcut(format_shortcut_hint(shortcut));
-            }
+        let mut action = Action::new(
+            action_id,
+            &sa.name,
+            sa.description.clone(),
+            ActionCategory::ScriptContext,
+        );
 
-            action = action.with_icon(IconName::PlayFilled).with_section("Actions");
-            action.has_action = true;
-            action.value = Some(sa.command.clone());
+        if let Some(ref shortcut) = sa.shortcut {
+            action = action.with_shortcut(format_shortcut_hint(shortcut));
+        }
 
-            tracing::debug!(
-                target: "script_kit::actions",
-                action_id = %action.id,
-                has_action = action.has_action,
-                has_shortcut = action.shortcut.is_some(),
-                "Created scriptlet-defined action (has_action=true)"
-            );
+        action = action.with_icon(IconName::PlayFilled).with_section("Actions");
+        action.has_action = true;
+        action.value = Some(sa.command.clone());
+
+        tracing::debug!(
+            target: "script_kit::actions",
+            action_id = %action.id,
+            has_action = action.has_action,
+            has_shortcut = action.shortcut.is_some(),
+            "Created scriptlet-defined action (has_action=true)"
+        );
 
-            Some(action)
-        })
-        .collect();
+        actions.push(action);
+    }
 
     if !actions.is_empty() {
         tracing::debug!(
@@ -103,6 +135,32 @@
     script: &ScriptInfo,
     scriptlet: Option<&Scriptlet>,
 ) -> Vec<Action> {
+    if has_invalid_scriptlet_context_input(script) {
+        tracing::warn!(
+            target: "script_kit::actions",
+            builder = "scriptlet_context",
+            name = %script.name,
+            action_verb = %script.action_verb,
+            "Invalid scriptlet context input; returning empty actions"
+        );
+        return vec![];
+    }
+
+    if let Some(scriptlet) = scriptlet {
+        let invalid_action_count = count_invalid_scriptlet_actions(scriptlet);
+        if invalid_action_count > 0 {
+            tracing::warn!(
+                target: "script_kit::actions",
+                builder = "scriptlet_context",
+                scriptlet_name = %scriptlet.name,
+                action_count = scriptlet.actions.len(),
+                invalid_action_count,
+                "Invalid scriptlet-defined action input; returning empty actions"
+            );
+            return vec![];
+        }
+    }
+
     let mut actions = Vec::new();
     let mut destructive_actions = Vec::new();
 
@@ -342,7 +400,7 @@
     }
 
     #[test]
-    fn test_get_scriptlet_defined_actions_drops_action_when_command_is_empty() {
+    fn test_get_scriptlet_defined_actions_returns_empty_when_command_is_empty() {
         let mut scriptlet = Scriptlet::new(
             "Malformed".to_string(),
             "bash".to_string(),
@@ -355,6 +413,53 @@
     }
 
     #[test]
+    fn test_get_scriptlet_defined_actions_returns_empty_when_any_action_is_invalid() {
+        let mut scriptlet = Scriptlet::new(
+            "Mixed".to_string(),
+            "bash".to_string(),
+            "echo".to_string(),
+        );
+        scriptlet.actions = vec![
+            scriptlet_action("Valid", "copy"),
+            scriptlet_action("   ", "invalid"),
+        ];
+
+        let actions = get_scriptlet_defined_actions(&scriptlet);
+        assert!(actions.is_empty());
+    }
+
+    #[test]
+    fn test_get_scriptlet_context_actions_returns_empty_when_script_name_is_blank() {
+        let mut script =
+            ScriptInfo::scriptlet("Demo", "/tmp/demo.md", Some("cmd d".to_string()), None);
+        script.name = "   ".to_string();
+
+        let actions = get_scriptlet_context_actions_with_custom(&script, None);
+        assert!(actions.is_empty());
+    }
+
+    #[test]
+    fn test_get_scriptlet_context_actions_returns_empty_when_action_verb_is_blank() {
+        let mut script =
+            ScriptInfo::scriptlet("Demo", "/tmp/demo.md", Some("cmd d".to_string()), None);
+        script.action_verb = "   ".to_string();
+
+        let actions = get_scriptlet_context_actions_with_custom(&script, None);
+        assert!(actions.is_empty());
+    }
+
+    #[test]
+    fn test_get_scriptlet_context_actions_returns_empty_when_scriptlet_action_input_is_invalid() {
+        let script = ScriptInfo::scriptlet("Demo", "/tmp/demo.md", Some("cmd d".to_string()), None);
+        let mut scriptlet =
+            Scriptlet::new("Malformed".to_string(), "bash".to_string(), "echo".to_string());
+        scriptlet.actions = vec![scriptlet_action("Bad", "   ")];
+
+        let actions = get_scriptlet_context_actions_with_custom(&script, Some(&scriptlet));
+        assert!(actions.is_empty());
+    }
+
+    #[test]
     fn test_get_scriptlet_context_actions_assigns_consistent_primary_icons() {
         let script = ScriptInfo::scriptlet("Demo", "/tmp/demo.md", Some("cmd d".to_string()), None);
         let actions = get_scriptlet_context_actions_with_custom(&script, None);


thinking
**Stopping lingering process**
file update:
diff --git a/src/actions/builders/notes.rs b/src/actions/builders/notes.rs
index 48ba267e97bf2f3da7ecf1a3f78fea59dbc9acab..a2f0007d3327b005960130e6e30f524ceb6b3e9f
--- a/src/actions/builders/notes.rs
+++ b/src/actions/builders/notes.rs
@@ -27,6 +27,25 @@
     pub auto_sizing_enabled: bool,
 }
 
+fn is_blank(value: &str) -> bool {
+    value.trim().is_empty()
+}
+
+fn has_invalid_new_chat_model_info(model: &NewChatModelInfo) -> bool {
+    is_blank(&model.model_id)
+        || is_blank(&model.display_name)
+        || is_blank(&model.provider)
+        || is_blank(&model.provider_display_name)
+}
+
+fn has_invalid_new_chat_preset_info(preset: &NewChatPresetInfo) -> bool {
+    is_blank(&preset.id) || is_blank(&preset.name)
+}
+
+fn has_invalid_note_switcher_note_info(note: &NoteSwitcherNoteInfo) -> bool {
+    is_blank(&note.id) || is_blank(&note.title)
+}
+
 /// Get actions for the Notes window command bar (Cmd+K menu).
 pub fn get_notes_command_bar_actions(info: &NotesInfo) -> Vec<Action> {
     let mut actions = Vec::new();
@@ -367,6 +386,76 @@
             Some("Use Focused Writing preset")
         );
     }
+
+    #[test]
+    fn test_get_new_chat_actions_returns_empty_when_last_used_model_input_is_invalid() {
+        let last_used = vec![NewChatModelInfo {
+            model_id: "   ".to_string(),
+            display_name: "GPT-4o Mini".to_string(),
+            provider: "openai".to_string(),
+            provider_display_name: "OpenAI".to_string(),
+        }];
+        let presets = vec![NewChatPresetInfo {
+            id: "focused-writing".to_string(),
+            name: "Focused Writing".to_string(),
+            icon: IconName::Pencil,
+        }];
+
+        let actions = get_new_chat_actions(&last_used, &presets, &[]);
+        assert!(actions.is_empty());
+    }
+
+    #[test]
+    fn test_get_new_chat_actions_returns_empty_when_preset_input_is_invalid() {
+        let last_used = vec![NewChatModelInfo {
+            model_id: "gpt-4o-mini".to_string(),
+            display_name: "GPT-4o Mini".to_string(),
+            provider: "openai".to_string(),
+            provider_display_name: "OpenAI".to_string(),
+        }];
+        let presets = vec![NewChatPresetInfo {
+            id: "   ".to_string(),
+            name: "Focused Writing".to_string(),
+            icon: IconName::Pencil,
+        }];
+
+        let actions = get_new_chat_actions(&last_used, &presets, &[]);
+        assert!(actions.is_empty());
+    }
+
+    #[test]
+    fn test_get_new_chat_actions_returns_empty_when_model_input_is_invalid() {
+        let presets = vec![NewChatPresetInfo {
+            id: "focused-writing".to_string(),
+            name: "Focused Writing".to_string(),
+            icon: IconName::Pencil,
+        }];
+        let models = vec![NewChatModelInfo {
+            model_id: "claude-3-5-sonnet".to_string(),
+            display_name: "Claude 3.5 Sonnet".to_string(),
+            provider: "   ".to_string(),
+            provider_display_name: "Anthropic".to_string(),
+        }];
+
+        let actions = get_new_chat_actions(&[], &presets, &models);
+        assert!(actions.is_empty());
+    }
+
+    #[test]
+    fn test_get_note_switcher_actions_returns_empty_when_note_input_is_invalid() {
+        let notes = vec![NoteSwitcherNoteInfo {
+            id: "   ".to_string(),
+            title: "Missing ID".to_string(),
+            char_count: 5,
+            is_current: false,
+            is_pinned: false,
+            preview: "Preview".to_string(),
+            relative_time: "1m ago".to_string(),
+        }];
+
+        let actions = get_note_switcher_actions(&notes);
+        assert!(actions.is_empty());
+    }
 }
 
 /// Build actions for the AI new chat dropdown.
@@ -376,6 +465,48 @@
     presets: &[NewChatPresetInfo],
     models: &[NewChatModelInfo],
 ) -> Vec<Action> {
+    let invalid_last_used_count = last_used
+        .iter()
+        .filter(|model| has_invalid_new_chat_model_info(model))
+        .count();
+    if invalid_last_used_count > 0 {
+        tracing::warn!(
+            target: "script_kit::actions",
+            builder = "notes_new_chat",
+            invalid_last_used_count,
+            "Invalid last-used chat model input; returning empty actions"
+        );
+        return vec![];
+    }
+
+    let invalid_preset_count = presets
+        .iter()
+        .filter(|preset| has_invalid_new_chat_preset_info(preset))
+        .count();
+    if invalid_preset_count > 0 {
+        tracing::warn!(
+            target: "script_kit::actions",
+            builder = "notes_new_chat",
+            invalid_preset_count,
+            "Invalid chat preset input; returning empty actions"
+        );
+        return vec![];
+    }
+
+    let invalid_model_count = models
+        .iter()
+        .filter(|model| has_invalid_new_chat_model_info(model))
+        .count();
+    if invalid_model_count > 0 {
+        tracing::warn!(
+            target: "script_kit::actions",
+            builder = "notes_new_chat",
+            invalid_model_count,
+            "Invalid chat model input; returning empty actions"
+        );
+        return vec![];
+    }
+
     let mut actions = Vec::new();
 
     for setting in last_used {
@@ -442,6 +573,21 @@
 
 /// Get actions for the note switcher dialog (Cmd+P in Notes window).
 pub fn get_note_switcher_actions(notes: &[NoteSwitcherNoteInfo]) -> Vec<Action> {
+    let invalid_note_count = notes
+        .iter()
+        .filter(|note| has_invalid_note_switcher_note_info(note))
+        .count();
+    if invalid_note_count > 0 {
+        tracing::warn!(
+            target: "script_kit::actions",
+            builder = "note_switcher",
+            note_count = notes.len(),
+            invalid_note_count,
+            "Invalid note switcher input; returning empty actions"
+        );
+        return vec![];
+    }
+
     let mut actions = Vec::new();
 
     for note in notes {
diff --git a/src/actions/builders/script_context.rs b/src/actions/builders/script_context.rs
index d48add6d0604e4fc8ab6bc1d9a9cdc328a6037ab..c09068069325e288d1c697a6ed9aa07944aadf61
--- a/src/actions/builders/script_context.rs
+++ b/src/actions/builders/script_context.rs
@@ -2,8 +2,23 @@
 use super::types::{Action, ActionCategory, ScriptInfo};
 use std::collections::HashSet;
 
+fn has_invalid_script_context_input(script: &ScriptInfo) -> bool {
+    script.name.trim().is_empty() || script.action_verb.trim().is_empty()
+}
+
 /// Get actions specific to the focused script.
 pub fn get_script_context_actions(script: &ScriptInfo) -> Vec<Action> {
+    if has_invalid_script_context_input(script) {
+        tracing::warn!(
+            target: "script_kit::actions",
+            builder = "script_context",
+            name = %script.name,
+            action_verb = %script.action_verb,
+            "Invalid script context input; returning empty actions"
+        );
+        return vec![];
+    }
+
     let mut actions = Vec::new();
     let mut destructive_actions = Vec::new();
 
@@ -314,3 +329,26 @@
 pub fn get_global_actions() -> Vec<Action> {
     vec![]
 }
+
+#[cfg(test)]
+mod tests {
+    use super::*;
+
+    #[test]
+    fn test_get_script_context_actions_returns_empty_when_name_is_blank() {
+        let mut script = ScriptInfo::new("Valid", "/tmp/valid.ts");
+        script.name = "   ".to_string();
+
+        let actions = get_script_context_actions(&script);
+        assert!(actions.is_empty());
+    }
+
+    #[test]
+    fn test_get_script_context_actions_returns_empty_when_action_verb_is_blank() {
+        let mut script = ScriptInfo::new("Valid", "/tmp/valid.ts");
+        script.action_verb = "   ".to_string();
+
+        let actions = get_script_context_actions(&script);
+        assert!(actions.is_empty());
+    }
+}
diff --git a/src/actions/builders/scriptlet.rs b/src/actions/builders/scriptlet.rs
index 371dbac6d433b01ee915aebdcd5f371b952065da..fec3eaa1d184df4366bf235fd3293d99a97cb120
--- a/src/actions/builders/scriptlet.rs
+++ b/src/actions/builders/scriptlet.rs
@@ -1,11 +1,31 @@
 use super::shared::{format_shortcut_hint, to_deeplink_name};
 use super::types::{Action, ActionCategory, ScriptInfo};
 use crate::designs::icon_variations::IconName;
-use crate::scriptlets::Scriptlet;
+use crate::scriptlets::{Scriptlet, ScriptletAction};
 use std::collections::HashSet;
 
 const SCRIPTLET_ACTION_ID_PREFIX: &str = "scriptlet_action:";
 
+fn is_blank(value: &str) -> bool {
+    value.trim().is_empty()
+}
+
+fn has_invalid_scriptlet_context_input(script: &ScriptInfo) -> bool {
+    is_blank(&script.name) || is_blank(&script.action_verb)
+}
+
+fn has_invalid_scriptlet_action_input(action: &ScriptletAction) -> bool {
+    is_blank(&action.name) || is_blank(&action.command)
+}
+
+fn count_invalid_scriptlet_actions(scriptlet: &Scriptlet) -> usize {
+    scriptlet
+        .actions
+        .iter()
+        .filter(|action| has_invalid_scriptlet_action_input(action))
+        .count()
+}
+
 fn parse_scriptlet_action_command(action_id: &str) -> Option<&str> {
     action_id
         .strip_prefix(SCRIPTLET_ACTION_ID_PREFIX)
@@ -14,18 +34,9 @@
 
 fn unique_scriptlet_action_id(
     raw_action_id: &str,
-    action_name: &str,
     used_action_ids: &mut HashSet<String>,
 ) -> Option<String> {
-    let Some(action_command) = parse_scriptlet_action_command(raw_action_id) else {
-        tracing::warn!(
-            target: "script_kit::actions",
-            action_name = %action_name,
-            action_id = %raw_action_id,
-            "Failed to parse scriptlet H3 action id; dropping malformed action"
-        );
-        return None;
-    };
+    let action_command = parse_scriptlet_action_command(raw_action_id)?;
 
     let mut unique_action_id = raw_action_id.to_string();
     let mut duplicate_index = 2;
@@ -38,7 +49,6 @@
     if unique_action_id != raw_action_id {
         tracing::debug!(
             target: "script_kit::actions",
-            action_name = %action_name,
             original_action_id = %raw_action_id,
             deduped_action_id = %unique_action_id,
             "Deduplicated scriptlet H3 action id"
@@ -51,40 +61,62 @@
 
 /// Convert scriptlet-defined actions (from H3 headers) to Action structs for the UI.
 pub fn get_scriptlet_defined_actions(scriptlet: &Scriptlet) -> Vec<Action> {
+    let invalid_action_count = count_invalid_scriptlet_actions(scriptlet);
+    if invalid_action_count > 0 {
+        tracing::warn!(
+            target: "script_kit::actions",
+            builder = "scriptlet_defined",
+            scriptlet_name = %scriptlet.name,
+            action_count = scriptlet.actions.len(),
+            invalid_action_count,
+            "Invalid scriptlet-defined action input; returning empty actions"
+        );
+        return vec![];
+    }
+
     let mut used_action_ids = HashSet::new();
-    let actions: Vec<Action> = scriptlet
-        .actions
-        .iter()
-        .filter_map(|sa| {
-            let raw_action_id = sa.action_id();
-            let action_id =
-                unique_scriptlet_action_id(&raw_action_id, &sa.name, &mut used_action_ids)?;
-            let mut action = Action::new(
-                action_id,
-                &sa.name,
-                sa.description.clone(),
-                ActionCategory::ScriptContext,
+    let mut actions: Vec<Action> = Vec::with_capacity(scriptlet.actions.len());
+
+    for sa in &scriptlet.actions {
+        let raw_action_id = sa.action_id();
+        let Some(action_id) = unique_scriptlet_action_id(&raw_action_id, &mut used_action_ids)
+        else {
+            tracing::warn!(
+                target: "script_kit::actions",
+                builder = "scriptlet_defined",
+                scriptlet_name = %scriptlet.name,
+                action_name = %sa.name,
+                action_id = %raw_action_id,
+                "Invalid scriptlet action id input; returning empty actions"
             );
+            return vec![];
+        };
 
-            if let Some(ref shortcut) = sa.shortcut {
-                action = action.with_shortcut(format_shortcut_hint(shortcut));
-            }
+        let mut action = Action::new(
+            action_id,
+            &sa.name,
+            sa.description.clone(),
+            ActionCategory::ScriptContext,
+        );
 
-            action = action.with_icon(IconName::PlayFilled).with_section("Actions");
-            action.has_action = true;
-            action.value = Some(sa.command.clone());
+        if let Some(ref shortcut) = sa.shortcut {
+            action = action.with_shortcut(format_shortcut_hint(shortcut));
+        }
 
-            tracing::debug!(
-                target: "script_kit::actions",
-                action_id = %action.id,
-                has_action = action.has_action,
-                has_shortcut = action.shortcut.is_some(),
-                "Created scriptlet-defined action (has_action=true)"
-            );
+        action = action.with_icon(IconName::PlayFilled).with_section("Actions");
+        action.has_action = true;
+        action.value = Some(sa.command.clone());
+
+        tracing::debug!(
+            target: "script_kit::actions",
+            action_id = %action.id,
+            has_action = action.has_action,
+            has_shortcut = action.shortcut.is_some(),
+            "Created scriptlet-defined action (has_action=true)"
+        );
 
-            Some(action)
-        })
-        .collect();
+        actions.push(action);
+    }
 
     if !actions.is_empty() {
         tracing::debug!(
@@ -103,6 +135,32 @@
     script: &ScriptInfo,
     scriptlet: Option<&Scriptlet>,
 ) -> Vec<Action> {
+    if has_invalid_scriptlet_context_input(script) {
+        tracing::warn!(
+            target: "script_kit::actions",
+            builder = "scriptlet_context",
+            name = %script.name,
+            action_verb = %script.action_verb,
+            "Invalid scriptlet context input; returning empty actions"
+        );
+        return vec![];
+    }
+
+    if let Some(scriptlet) = scriptlet {
+        let invalid_action_count = count_invalid_scriptlet_actions(scriptlet);
+        if invalid_action_count > 0 {
+            tracing::warn!(
+                target: "script_kit::actions",
+                builder = "scriptlet_context",
+                scriptlet_name = %scriptlet.name,
+                action_count = scriptlet.actions.len(),
+                invalid_action_count,
+                "Invalid scriptlet-defined action input; returning empty actions"
+            );
+            return vec![];
+        }
+    }
+
     let mut actions = Vec::new();
     let mut destructive_actions = Vec::new();
 
@@ -342,7 +400,7 @@
     }
 
     #[test]
-    fn test_get_scriptlet_defined_actions_drops_action_when_command_is_empty() {
+    fn test_get_scriptlet_defined_actions_returns_empty_when_command_is_empty() {
         let mut scriptlet = Scriptlet::new(
             "Malformed".to_string(),
             "bash".to_string(),
@@ -355,6 +413,53 @@
     }
 
     #[test]
+    fn test_get_scriptlet_defined_actions_returns_empty_when_any_action_is_invalid() {
+        let mut scriptlet = Scriptlet::new(
+            "Mixed".to_string(),
+            "bash".to_string(),
+            "echo".to_string(),
+        );
+        scriptlet.actions = vec![
+            scriptlet_action("Valid", "copy"),
+            scriptlet_action("   ", "invalid"),
+        ];
+
+        let actions = get_scriptlet_defined_actions(&scriptlet);
+        assert!(actions.is_empty());
+    }
+
+    #[test]
+    fn test_get_scriptlet_context_actions_returns_empty_when_script_name_is_blank() {
+        let mut script =
+            ScriptInfo::scriptlet("Demo", "/tmp/demo.md", Some("cmd d".to_string()), None);
+        script.name = "   ".to_string();
+
+        let actions = get_scriptlet_context_actions_with_custom(&script, None);
+        assert!(actions.is_empty());
+    }
+
+    #[test]
+    fn test_get_scriptlet_context_actions_returns_empty_when_action_verb_is_blank() {
+        let mut script =
+            ScriptInfo::scriptlet("Demo", "/tmp/demo.md", Some("cmd d".to_string()), None);
+        script.action_verb = "   ".to_string();
+
+        let actions = get_scriptlet_context_actions_with_custom(&script, None);
+        assert!(actions.is_empty());
+    }
+
+    #[test]
+    fn test_get_scriptlet_context_actions_returns_empty_when_scriptlet_action_input_is_invalid() {
+        let script = ScriptInfo::scriptlet("Demo", "/tmp/demo.md", Some("cmd d".to_string()), None);
+        let mut scriptlet =
+            Scriptlet::new("Malformed".to_string(), "bash".to_string(), "echo".to_string());
+        scriptlet.actions = vec![scriptlet_action("Bad", "   ")];
+
+        let actions = get_scriptlet_context_actions_with_custom(&script, Some(&scriptlet));
+        assert!(actions.is_empty());
+    }
+
+    #[test]
     fn test_get_scriptlet_context_actions_assigns_consistent_primary_icons() {
         let script = ScriptInfo::scriptlet("Demo", "/tmp/demo.md", Some("cmd d".to_string()), None);
         let actions = get_scriptlet_context_actions_with_custom(&script, None);

 exited 101 in 55.80s:
    Blocking waiting for file lock on package cache
    Blocking waiting for file lock on package cache
    Blocking waiting for file lock on build directory
   Compiling script-kit-gpui v0.1.0 (/Users/johnlindquist/dev/script-kit-gpui)
error[E0761]: file for module `tests` found at both "src/protocol/message/tests.rs" and "src/protocol/message/tests/mod.rs"
  --> src/protocol/message/mod.rs:87:1
   |
87 | mod tests;
   | ^^^^^^^^^^
   |
   = help: delete or rename one of them to remove the ambiguity

error[E0761]: file for module `tests` found at both "src/designs/core/tests.rs" and "src/designs/core/tests/mod.rs"
 --> src/designs/core/part_04.rs:2:1
  |
2 | mod tests;
  | ^^^^^^^^^^
  |
  = help: delete or rename one of them to remove the ambiguity


thinking
**Preparing targeted test run**
exec
/bin/zsh -lc 'rg -n "action_name" src/actions/builders/scriptlet.rs' in /Users/johnlindquist/dev/script-kit-gpui succeeded in 50ms:
88:                action_name = %sa.name,
file update:
diff --git a/src/actions/builders/notes.rs b/src/actions/builders/notes.rs
index 48ba267e97bf2f3da7ecf1a3f78fea59dbc9acab..a2f0007d3327b005960130e6e30f524ceb6b3e9f
--- a/src/actions/builders/notes.rs
+++ b/src/actions/builders/notes.rs
@@ -27,6 +27,25 @@
     pub auto_sizing_enabled: bool,
 }
 
+fn is_blank(value: &str) -> bool {
+    value.trim().is_empty()
+}
+
+fn has_invalid_new_chat_model_info(model: &NewChatModelInfo) -> bool {
+    is_blank(&model.model_id)
+        || is_blank(&model.display_name)
+        || is_blank(&model.provider)
+        || is_blank(&model.provider_display_name)
+}
+
+fn has_invalid_new_chat_preset_info(preset: &NewChatPresetInfo) -> bool {
+    is_blank(&preset.id) || is_blank(&preset.name)
+}
+
+fn has_invalid_note_switcher_note_info(note: &NoteSwitcherNoteInfo) -> bool {
+    is_blank(&note.id) || is_blank(&note.title)
+}
+
 /// Get actions for the Notes window command bar (Cmd+K menu).
 pub fn get_notes_command_bar_actions(info: &NotesInfo) -> Vec<Action> {
     let mut actions = Vec::new();
@@ -367,6 +386,76 @@
             Some("Use Focused Writing preset")
         );
     }
+
+    #[test]
+    fn test_get_new_chat_actions_returns_empty_when_last_used_model_input_is_invalid() {
+        let last_used = vec![NewChatModelInfo {
+            model_id: "   ".to_string(),
+            display_name: "GPT-4o Mini".to_string(),
+            provider: "openai".to_string(),
+            provider_display_name: "OpenAI".to_string(),
+        }];
+        let presets = vec![NewChatPresetInfo {
+            id: "focused-writing".to_string(),
+            name: "Focused Writing".to_string(),
+            icon: IconName::Pencil,
+        }];
+
+        let actions = get_new_chat_actions(&last_used, &presets, &[]);
+        assert!(actions.is_empty());
+    }
+
+    #[test]
+    fn test_get_new_chat_actions_returns_empty_when_preset_input_is_invalid() {
+        let last_used = vec![NewChatModelInfo {
+            model_id: "gpt-4o-mini".to_string(),
+            display_name: "GPT-4o Mini".to_string(),
+            provider: "openai".to_string(),
+            provider_display_name: "OpenAI".to_string(),
+        }];
+        let presets = vec![NewChatPresetInfo {
+            id: "   ".to_string(),
+            name: "Focused Writing".to_string(),
+            icon: IconName::Pencil,
+        }];
+
+        let actions = get_new_chat_actions(&last_used, &presets, &[]);
+        assert!(actions.is_empty());
+    }
+
+    #[test]
+    fn test_get_new_chat_actions_returns_empty_when_model_input_is_invalid() {
+        let presets = vec![NewChatPresetInfo {
+            id: "focused-writing".to_string(),
+            name: "Focused Writing".to_string(),
+            icon: IconName::Pencil,
+        }];
+        let models = vec![NewChatModelInfo {
+            model_id: "claude-3-5-sonnet".to_string(),
+            display_name: "Claude 3.5 Sonnet".to_string(),
+            provider: "   ".to_string(),
+            provider_display_name: "Anthropic".to_string(),
+        }];
+
+        let actions = get_new_chat_actions(&[], &presets, &models);
+        assert!(actions.is_empty());
+    }
+
+    #[test]
+    fn test_get_note_switcher_actions_returns_empty_when_note_input_is_invalid() {
+        let notes = vec![NoteSwitcherNoteInfo {
+            id: "   ".to_string(),
+            title: "Missing ID".to_string(),
+            char_count: 5,
+            is_current: false,
+            is_pinned: false,
+            preview: "Preview".to_string(),
+            relative_time: "1m ago".to_string(),
+        }];
+
+        let actions = get_note_switcher_actions(&notes);
+        assert!(actions.is_empty());
+    }
 }
 
 /// Build actions for the AI new chat dropdown.
@@ -376,6 +465,48 @@
     presets: &[NewChatPresetInfo],
     models: &[NewChatModelInfo],
 ) -> Vec<Action> {
+    let invalid_last_used_count = last_used
+        .iter()
+        .filter(|model| has_invalid_new_chat_model_info(model))
+        .count();
+    if invalid_last_used_count > 0 {
+        tracing::warn!(
+            target: "script_kit::actions",
+            builder = "notes_new_chat",
+            invalid_last_used_count,
+            "Invalid last-used chat model input; returning empty actions"
+        );
+        return vec![];
+    }
+
+    let invalid_preset_count = presets
+        .iter()
+        .filter(|preset| has_invalid_new_chat_preset_info(preset))
+        .count();
+    if invalid_preset_count > 0 {
+        tracing::warn!(
+            target: "script_kit::actions",
+            builder = "notes_new_chat",
+            invalid_preset_count,
+            "Invalid chat preset input; returning empty actions"
+        );
+        return vec![];
+    }
+
+    let invalid_model_count = models
+        .iter()
+        .filter(|model| has_invalid_new_chat_model_info(model))
+        .count();
+    if invalid_model_count > 0 {
+        tracing::warn!(
+            target: "script_kit::actions",
+            builder = "notes_new_chat",
+            invalid_model_count,
+            "Invalid chat model input; returning empty actions"
+        );
+        return vec![];
+    }
+
     let mut actions = Vec::new();
 
     for setting in last_used {
@@ -442,6 +573,21 @@
 
 /// Get actions for the note switcher dialog (Cmd+P in Notes window).
 pub fn get_note_switcher_actions(notes: &[NoteSwitcherNoteInfo]) -> Vec<Action> {
+    let invalid_note_count = notes
+        .iter()
+        .filter(|note| has_invalid_note_switcher_note_info(note))
+        .count();
+    if invalid_note_count > 0 {
+        tracing::warn!(
+            target: "script_kit::actions",
+            builder = "note_switcher",
+            note_count = notes.len(),
+            invalid_note_count,
+            "Invalid note switcher input; returning empty actions"
+        );
+        return vec![];
+    }
+
     let mut actions = Vec::new();
 
     for note in notes {
diff --git a/src/actions/builders/script_context.rs b/src/actions/builders/script_context.rs
index d48add6d0604e4fc8ab6bc1d9a9cdc328a6037ab..c09068069325e288d1c697a6ed9aa07944aadf61
--- a/src/actions/builders/script_context.rs
+++ b/src/actions/builders/script_context.rs
@@ -2,8 +2,23 @@
 use super::types::{Action, ActionCategory, ScriptInfo};
 use std::collections::HashSet;
 
+fn has_invalid_script_context_input(script: &ScriptInfo) -> bool {
+    script.name.trim().is_empty() || script.action_verb.trim().is_empty()
+}
+
 /// Get actions specific to the focused script.
 pub fn get_script_context_actions(script: &ScriptInfo) -> Vec<Action> {
+    if has_invalid_script_context_input(script) {
+        tracing::warn!(
+            target: "script_kit::actions",
+            builder = "script_context",
+            name = %script.name,
+            action_verb = %script.action_verb,
+            "Invalid script context input; returning empty actions"
+        );
+        return vec![];
+    }
+
     let mut actions = Vec::new();
     let mut destructive_actions = Vec::new();
 
@@ -314,3 +329,26 @@
 pub fn get_global_actions() -> Vec<Action> {
     vec![]
 }
+
+#[cfg(test)]
+mod tests {
+    use super::*;
+
+    #[test]
+    fn test_get_script_context_actions_returns_empty_when_name_is_blank() {
+        let mut script = ScriptInfo::new("Valid", "/tmp/valid.ts");
+        script.name = "   ".to_string();
+
+        let actions = get_script_context_actions(&script);
+        assert!(actions.is_empty());
+    }
+
+    #[test]
+    fn test_get_script_context_actions_returns_empty_when_action_verb_is_blank() {
+        let mut script = ScriptInfo::new("Valid", "/tmp/valid.ts");
+        script.action_verb = "   ".to_string();
+
+        let actions = get_script_context_actions(&script);
+        assert!(actions.is_empty());
+    }
+}
diff --git a/src/actions/builders/scriptlet.rs b/src/actions/builders/scriptlet.rs
index 371dbac6d433b01ee915aebdcd5f371b952065da..fec3eaa1d184df4366bf235fd3293d99a97cb120
--- a/src/actions/builders/scriptlet.rs
+++ b/src/actions/builders/scriptlet.rs
@@ -1,11 +1,31 @@
 use super::shared::{format_shortcut_hint, to_deeplink_name};
 use super::types::{Action, ActionCategory, ScriptInfo};
 use crate::designs::icon_variations::IconName;
-use crate::scriptlets::Scriptlet;
+use crate::scriptlets::{Scriptlet, ScriptletAction};
 use std::collections::HashSet;
 
 const SCRIPTLET_ACTION_ID_PREFIX: &str = "scriptlet_action:";
 
+fn is_blank(value: &str) -> bool {
+    value.trim().is_empty()
+}
+
+fn has_invalid_scriptlet_context_input(script: &ScriptInfo) -> bool {
+    is_blank(&script.name) || is_blank(&script.action_verb)
+}
+
+fn has_invalid_scriptlet_action_input(action: &ScriptletAction) -> bool {
+    is_blank(&action.name) || is_blank(&action.command)
+}
+
+fn count_invalid_scriptlet_actions(scriptlet: &Scriptlet) -> usize {
+    scriptlet
+        .actions
+        .iter()
+        .filter(|action| has_invalid_scriptlet_action_input(action))
+        .count()
+}
+
 fn parse_scriptlet_action_command(action_id: &str) -> Option<&str> {
     action_id
         .strip_prefix(SCRIPTLET_ACTION_ID_PREFIX)
@@ -14,18 +34,9 @@
 
 fn unique_scriptlet_action_id(
     raw_action_id: &str,
-    action_name: &str,
     used_action_ids: &mut HashSet<String>,
 ) -> Option<String> {
-    let Some(action_command) = parse_scriptlet_action_command(raw_action_id) else {
-        tracing::warn!(
-            target: "script_kit::actions",
-            action_name = %action_name,
-            action_id = %raw_action_id,
-            "Failed to parse scriptlet H3 action id; dropping malformed action"
-        );
-        return None;
-    };
+    let action_command = parse_scriptlet_action_command(raw_action_id)?;
 
     let mut unique_action_id = raw_action_id.to_string();
     let mut duplicate_index = 2;
@@ -38,7 +49,6 @@
     if unique_action_id != raw_action_id {
         tracing::debug!(
             target: "script_kit::actions",
-            action_name = %action_name,
             original_action_id = %raw_action_id,
             deduped_action_id = %unique_action_id,
             "Deduplicated scriptlet H3 action id"
@@ -51,40 +61,62 @@
 
 /// Convert scriptlet-defined actions (from H3 headers) to Action structs for the UI.
 pub fn get_scriptlet_defined_actions(scriptlet: &Scriptlet) -> Vec<Action> {
+    let invalid_action_count = count_invalid_scriptlet_actions(scriptlet);
+    if invalid_action_count > 0 {
+        tracing::warn!(
+            target: "script_kit::actions",
+            builder = "scriptlet_defined",
+            scriptlet_name = %scriptlet.name,
+            action_count = scriptlet.actions.len(),
+            invalid_action_count,
+            "Invalid scriptlet-defined action input; returning empty actions"
+        );
+        return vec![];
+    }
+
     let mut used_action_ids = HashSet::new();
-    let actions: Vec<Action> = scriptlet
-        .actions
-        .iter()
-        .filter_map(|sa| {
-            let raw_action_id = sa.action_id();
-            let action_id =
-                unique_scriptlet_action_id(&raw_action_id, &sa.name, &mut used_action_ids)?;
-            let mut action = Action::new(
-                action_id,
-                &sa.name,
-                sa.description.clone(),
-                ActionCategory::ScriptContext,
+    let mut actions: Vec<Action> = Vec::with_capacity(scriptlet.actions.len());
+
+    for sa in &scriptlet.actions {
+        let raw_action_id = sa.action_id();
+        let Some(action_id) = unique_scriptlet_action_id(&raw_action_id, &mut used_action_ids)
+        else {
+            tracing::warn!(
+                target: "script_kit::actions",
+                builder = "scriptlet_defined",
+                scriptlet_name = %scriptlet.name,
+                action_name = %sa.name,
+                action_id = %raw_action_id,
+                "Invalid scriptlet action id input; returning empty actions"
             );
+            return vec![];
+        };
 
-            if let Some(ref shortcut) = sa.shortcut {
-                action = action.with_shortcut(format_shortcut_hint(shortcut));
-            }
+        let mut action = Action::new(
+            action_id,
+            &sa.name,
+            sa.description.clone(),
+            ActionCategory::ScriptContext,
+        );
 
-            action = action.with_icon(IconName::PlayFilled).with_section("Actions");
-            action.has_action = true;
-            action.value = Some(sa.command.clone());
+        if let Some(ref shortcut) = sa.shortcut {
+            action = action.with_shortcut(format_shortcut_hint(shortcut));
+        }
 
-            tracing::debug!(
-                target: "script_kit::actions",
-                action_id = %action.id,
-                has_action = action.has_action,
-                has_shortcut = action.shortcut.is_some(),
-                "Created scriptlet-defined action (has_action=true)"
-            );
+        action = action.with_icon(IconName::PlayFilled).with_section("Actions");
+        action.has_action = true;
+        action.value = Some(sa.command.clone());
+
+        tracing::debug!(
+            target: "script_kit::actions",
+            action_id = %action.id,
+            has_action = action.has_action,
+            has_shortcut = action.shortcut.is_some(),
+            "Created scriptlet-defined action (has_action=true)"
+        );
 
-            Some(action)
-        })
-        .collect();
+        actions.push(action);
+    }
 
     if !actions.is_empty() {
         tracing::debug!(
@@ -103,6 +135,32 @@
     script: &ScriptInfo,
     scriptlet: Option<&Scriptlet>,
 ) -> Vec<Action> {
+    if has_invalid_scriptlet_context_input(script) {
+        tracing::warn!(
+            target: "script_kit::actions",
+            builder = "scriptlet_context",
+            name = %script.name,
+            action_verb = %script.action_verb,
+            "Invalid scriptlet context input; returning empty actions"
+        );
+        return vec![];
+    }
+
+    if let Some(scriptlet) = scriptlet {
+        let invalid_action_count = count_invalid_scriptlet_actions(scriptlet);
+        if invalid_action_count > 0 {
+            tracing::warn!(
+                target: "script_kit::actions",
+                builder = "scriptlet_context",
+                scriptlet_name = %scriptlet.name,
+                action_count = scriptlet.actions.len(),
+                invalid_action_count,
+                "Invalid scriptlet-defined action input; returning empty actions"
+            );
+            return vec![];
+        }
+    }
+
     let mut actions = Vec::new();
     let mut destructive_actions = Vec::new();
 
@@ -342,7 +400,7 @@
     }
 
     #[test]
-    fn test_get_scriptlet_defined_actions_drops_action_when_command_is_empty() {
+    fn test_get_scriptlet_defined_actions_returns_empty_when_command_is_empty() {
         let mut scriptlet = Scriptlet::new(
             "Malformed".to_string(),
             "bash".to_string(),
@@ -355,6 +413,53 @@
     }
 
     #[test]
+    fn test_get_scriptlet_defined_actions_returns_empty_when_any_action_is_invalid() {
+        let mut scriptlet = Scriptlet::new(
+            "Mixed".to_string(),
+            "bash".to_string(),
+            "echo".to_string(),
+        );
+        scriptlet.actions = vec![
+            scriptlet_action("Valid", "copy"),
+            scriptlet_action("   ", "invalid"),
+        ];
+
+        let actions = get_scriptlet_defined_actions(&scriptlet);
+        assert!(actions.is_empty());
+    }
+
+    #[test]
+    fn test_get_scriptlet_context_actions_returns_empty_when_script_name_is_blank() {
+        let mut script =
+            ScriptInfo::scriptlet("Demo", "/tmp/demo.md", Some("cmd d".to_string()), None);
+        script.name = "   ".to_string();
+
+        let actions = get_scriptlet_context_actions_with_custom(&script, None);
+        assert!(actions.is_empty());
+    }
+
+    #[test]
+    fn test_get_scriptlet_context_actions_returns_empty_when_action_verb_is_blank() {
+        let mut script =
+            ScriptInfo::scriptlet("Demo", "/tmp/demo.md", Some("cmd d".to_string()), None);
+        script.action_verb = "   ".to_string();
+
+        let actions = get_scriptlet_context_actions_with_custom(&script, None);
+        assert!(actions.is_empty());
+    }
+
+    #[test]
+    fn test_get_scriptlet_context_actions_returns_empty_when_scriptlet_action_input_is_invalid() {
+        let script = ScriptInfo::scriptlet("Demo", "/tmp/demo.md", Some("cmd d".to_string()), None);
+        let mut scriptlet =
+            Scriptlet::new("Malformed".to_string(), "bash".to_string(), "echo".to_string());
+        scriptlet.actions = vec![scriptlet_action("Bad", "   ")];
+
+        let actions = get_scriptlet_context_actions_with_custom(&script, Some(&scriptlet));
+        assert!(actions.is_empty());
+    }
+
+    #[test]
     fn test_get_scriptlet_context_actions_assigns_consistent_primary_icons() {
         let script = ScriptInfo::scriptlet("Demo", "/tmp/demo.md", Some("cmd d".to_string()), None);
         let actions = get_scriptlet_context_actions_with_custom(&script, None);


thinking
**Planning targeted verification tests**
codex
I fixed the only regression from my edit. I’ll now rerun one scoped builder test and then the requested `cargo check` and `cargo clippy` (package-scoped); I expect unrelated in-progress workspace failures to remain.
exec
/bin/zsh -lc 'cargo test -p script-kit-gpui test_get_scriptlet_context_actions_returns_empty_when_scriptlet_action_input_is_invalid -- --exact' in /Users/johnlindquist/dev/script-kit-gpuiexec
/bin/zsh -lc 'cargo check -p script-kit-gpui' in /Users/johnlindquist/dev/script-kit-gpuiexec
/bin/zsh -lc 'cargo clippy -p script-kit-gpui --all-targets -- -D warnings' in /Users/johnlindquist/dev/script-kit-gpui exited 101 in 19.61s:
    Blocking waiting for file lock on package cache
    Blocking waiting for file lock on package cache
    Blocking waiting for file lock on build directory
   Compiling script-kit-gpui v0.1.0 (/Users/johnlindquist/dev/script-kit-gpui)
error[E0761]: file for module `tests` found at both "src/protocol/message/tests.rs" and "src/protocol/message/tests/mod.rs"
  --> src/protocol/message/mod.rs:87:1
   |
87 | mod tests;
   | ^^^^^^^^^^
   |
   = help: delete or rename one of them to remove the ambiguity

error[E0761]: file for module `tests` found at both "src/designs/core/tests.rs" and "src/designs/core/tests/mod.rs"
 --> src/designs/core/part_04.rs:2:1
  |
2 | mod tests;
  | ^^^^^^^^^^
  |
  = help: delete or rename one of them to remove the ambiguity

 exited 101 in 29.02s:
    Blocking waiting for file lock on package cache
    Blocking waiting for file lock on package cache
    Blocking waiting for file lock on package cache
    Blocking waiting for file lock on build directory
    Checking script-kit-gpui v0.1.0 (/Users/johnlindquist/dev/script-kit-gpui)
warning: glob import doesn't reexport anything with visibility `pub(in crate::prompts)` because no imported item is public enough
  --> src/prompts/div/mod.rs:32:16
   |
32 | pub(super) use inline::*;
   |                ^^^^^^^^^
   |
note: the most public imported item is `pub(self)`
  --> src/prompts/div/mod.rs:32:16
   |
32 | pub(super) use inline::*;
   |                ^^^^^^^^^
   = help: reduce the glob import's visibility or increase visibility of imported items
   = note: `#[warn(unused_imports)]` (part of `#[warn(unused)]`) on by default

warning: glob import doesn't reexport anything with visibility `pub(in crate::prompts)` because no imported item is public enough
file update:
diff --git a/src/actions/builders/notes.rs b/src/actions/builders/notes.rs
index 48ba267e97bf2f3da7ecf1a3f78fea59dbc9acab..a2f0007d3327b005960130e6e30f524ceb6b3e9f
--- a/src/actions/builders/notes.rs
+++ b/src/actions/builders/notes.rs
@@ -27,6 +27,25 @@
     pub auto_sizing_enabled: bool,
 }
 
+fn is_blank(value: &str) -> bool {
+    value.trim().is_empty()
+}
+
+fn has_invalid_new_chat_model_info(model: &NewChatModelInfo) -> bool {
+    is_blank(&model.model_id)
+        || is_blank(&model.display_name)
+        || is_blank(&model.provider)
+        || is_blank(&model.provider_display_name)
+}
+
+fn has_invalid_new_chat_preset_info(preset: &NewChatPresetInfo) -> bool {
+    is_blank(&preset.id) || is_blank(&preset.name)
+}
+
+fn has_invalid_note_switcher_note_info(note: &NoteSwitcherNoteInfo) -> bool {
+    is_blank(&note.id) || is_blank(&note.title)
+}
+
 /// Get actions for the Notes window command bar (Cmd+K menu).
 pub fn get_notes_command_bar_actions(info: &NotesInfo) -> Vec<Action> {
     let mut actions = Vec::new();
@@ -367,6 +386,76 @@
             Some("Use Focused Writing preset")
         );
     }
+
+    #[test]
+    fn test_get_new_chat_actions_returns_empty_when_last_used_model_input_is_invalid() {
+        let last_used = vec![NewChatModelInfo {
+            model_id: "   ".to_string(),
+            display_name: "GPT-4o Mini".to_string(),
+            provider: "openai".to_string(),
+            provider_display_name: "OpenAI".to_string(),
+        }];
+        let presets = vec![NewChatPresetInfo {
+            id: "focused-writing".to_string(),
+            name: "Focused Writing".to_string(),
+            icon: IconName::Pencil,
+        }];
+
+        let actions = get_new_chat_actions(&last_used, &presets, &[]);
+        assert!(actions.is_empty());
+    }
+
+    #[test]
+    fn test_get_new_chat_actions_returns_empty_when_preset_input_is_invalid() {
+        let last_used = vec![NewChatModelInfo {
+            model_id: "gpt-4o-mini".to_string(),
+            display_name: "GPT-4o Mini".to_string(),
+            provider: "openai".to_string(),
+            provider_display_name: "OpenAI".to_string(),
+        }];
+        let presets = vec![NewChatPresetInfo {
+            id: "   ".to_string(),
+            name: "Focused Writing".to_string(),
+            icon: IconName::Pencil,
+        }];
+
+        let actions = get_new_chat_actions(&last_used, &presets, &[]);
+        assert!(actions.is_empty());
+    }
+
+    #[test]
+    fn test_get_new_chat_actions_returns_empty_when_model_input_is_invalid() {
+        let presets = vec![NewChatPresetInfo {
+            id: "focused-writing".to_string(),
+            name: "Focused Writing".to_string(),
+            icon: IconName::Pencil,
+        }];
+        let models = vec![NewChatModelInfo {
+            model_id: "claude-3-5-sonnet".to_string(),
+            display_name: "Claude 3.5 Sonnet".to_string(),
+            provider: "   ".to_string(),
+            provider_display_name: "Anthropic".to_string(),
+        }];
+
+        let actions = get_new_chat_actions(&[], &presets, &models);
+        assert!(actions.is_empty());
+    }
+
+    #[test]
+    fn test_get_note_switcher_actions_returns_empty_when_note_input_is_invalid() {
+        let notes = vec![NoteSwitcherNoteInfo {
+            id: "   ".to_string(),
+            title: "Missing ID".to_string(),
+            char_count: 5,
+            is_current: false,
+            is_pinned: false,
+            preview: "Preview".to_string(),
+            relative_time: "1m ago".to_string(),
+        }];
+
+        let actions = get_note_switcher_actions(&notes);
+        assert!(actions.is_empty());
+    }
 }
 
 /// Build actions for the AI new chat dropdown.
@@ -376,6 +465,48 @@
     presets: &[NewChatPresetInfo],
     models: &[NewChatModelInfo],
 ) -> Vec<Action> {
+    let invalid_last_used_count = last_used
+        .iter()
+        .filter(|model| has_invalid_new_chat_model_info(model))
+        .count();
+    if invalid_last_used_count > 0 {
+        tracing::warn!(
+            target: "script_kit::actions",
+            builder = "notes_new_chat",
+            invalid_last_used_count,
+            "Invalid last-used chat model input; returning empty actions"
+        );
+        return vec![];
+    }
+
+    let invalid_preset_count = presets
+        .iter()
+        .filter(|preset| has_invalid_new_chat_preset_info(preset))
+        .count();
+    if invalid_preset_count > 0 {
+        tracing::warn!(
+            target: "script_kit::actions",
+            builder = "notes_new_chat",
+            invalid_preset_count,
+            "Invalid chat preset input; returning empty actions"
+        );
+        return vec![];
+    }
+
+    let invalid_model_count = models
+        .iter()
+        .filter(|model| has_invalid_new_chat_model_info(model))
+        .count();
+    if invalid_model_count > 0 {
+        tracing::warn!(
+            target: "script_kit::actions",
+            builder = "notes_new_chat",
+            invalid_model_count,
+            "Invalid chat model input; returning empty actions"
+        );
+        return vec![];
+    }
+
     let mut actions = Vec::new();
 
     for setting in last_used {
@@ -442,6 +573,21 @@
 
 /// Get actions for the note switcher dialog (Cmd+P in Notes window).
 pub fn get_note_switcher_actions(notes: &[NoteSwitcherNoteInfo]) -> Vec<Action> {
+    let invalid_note_count = notes
+        .iter()
+        .filter(|note| has_invalid_note_switcher_note_info(note))
+        .count();
+    if invalid_note_count > 0 {
+        tracing::warn!(
+            target: "script_kit::actions",
+            builder = "note_switcher",
+            note_count = notes.len(),
+            invalid_note_count,
+            "Invalid note switcher input; returning empty actions"
+        );
+        return vec![];
+    }
+
     let mut actions = Vec::new();
 
     for note in notes {
diff --git a/src/actions/builders/script_context.rs b/src/actions/builders/script_context.rs
index d48add6d0604e4fc8ab6bc1d9a9cdc328a6037ab..c09068069325e288d1c697a6ed9aa07944aadf61
--- a/src/actions/builders/script_context.rs
+++ b/src/actions/builders/script_context.rs
@@ -2,8 +2,23 @@
 use super::types::{Action, ActionCategory, ScriptInfo};
 use std::collections::HashSet;
 
+fn has_invalid_script_context_input(script: &ScriptInfo) -> bool {
+    script.name.trim().is_empty() || script.action_verb.trim().is_empty()
+}
+
 /// Get actions specific to the focused script.
 pub fn get_script_context_actions(script: &ScriptInfo) -> Vec<Action> {
+    if has_invalid_script_context_input(script) {
+        tracing::warn!(
+            target: "script_kit::actions",
+            builder = "script_context",
+            name = %script.name,
+            action_verb = %script.action_verb,
+            "Invalid script context input; returning empty actions"
+        );
+        return vec![];
+    }
+
     let mut actions = Vec::new();
     let mut destructive_actions = Vec::new();
 
@@ -314,3 +329,26 @@
 pub fn get_global_actions() -> Vec<Action> {
     vec![]
 }
+
+#[cfg(test)]
+mod tests {
+    use super::*;
+
+    #[test]
+    fn test_get_script_context_actions_returns_empty_when_name_is_blank() {
+        let mut script = ScriptInfo::new("Valid", "/tmp/valid.ts");
+        script.name = "   ".to_string();
+
+        let actions = get_script_context_actions(&script);
+        assert!(actions.is_empty());
+    }
+
+    #[test]
+    fn test_get_script_context_actions_returns_empty_when_action_verb_is_blank() {
+        let mut script = ScriptInfo::new("Valid", "/tmp/valid.ts");
+        script.action_verb = "   ".to_string();
+
+        let actions = get_script_context_actions(&script);
+        assert!(actions.is_empty());
+    }
+}
diff --git a/src/actions/builders/scriptlet.rs b/src/actions/builders/scriptlet.rs
index 371dbac6d433b01ee915aebdcd5f371b952065da..fec3eaa1d184df4366bf235fd3293d99a97cb120
--- a/src/actions/builders/scriptlet.rs
+++ b/src/actions/builders/scriptlet.rs
@@ -1,11 +1,31 @@
 use super::shared::{format_shortcut_hint, to_deeplink_name};
 use super::types::{Action, ActionCategory, ScriptInfo};
 use crate::designs::icon_variations::IconName;
-use crate::scriptlets::Scriptlet;
+use crate::scriptlets::{Scriptlet, ScriptletAction};
 use std::collections::HashSet;
 
 const SCRIPTLET_ACTION_ID_PREFIX: &str = "scriptlet_action:";
 
+fn is_blank(value: &str) -> bool {
+    value.trim().is_empty()
+}
+
+fn has_invalid_scriptlet_context_input(script: &ScriptInfo) -> bool {
+    is_blank(&script.name) || is_blank(&script.action_verb)
+}
+
+fn has_invalid_scriptlet_action_input(action: &ScriptletAction) -> bool {
+    is_blank(&action.name) || is_blank(&action.command)
+}
+
+fn count_invalid_scriptlet_actions(scriptlet: &Scriptlet) -> usize {
+    scriptlet
+        .actions
+        .iter()
+        .filter(|action| has_invalid_scriptlet_action_input(action))
+        .count()
+}
+
 fn parse_scriptlet_action_command(action_id: &str) -> Option<&str> {
     action_id
         .strip_prefix(SCRIPTLET_ACTION_ID_PREFIX)
@@ -14,18 +34,9 @@
 
 fn unique_scriptlet_action_id(
     raw_action_id: &str,
-    action_name: &str,
     used_action_ids: &mut HashSet<String>,
 ) -> Option<String> {
-    let Some(action_command) = parse_scriptlet_action_command(raw_action_id) else {
-        tracing::warn!(
-            target: "script_kit::actions",
-            action_name = %action_name,
-            action_id = %raw_action_id,
-            "Failed to parse scriptlet H3 action id; dropping malformed action"
-        );
-        return None;
-    };
+    let action_command = parse_scriptlet_action_command(raw_action_id)?;
 
     let mut unique_action_id = raw_action_id.to_string();
     let mut duplicate_index = 2;
@@ -38,7 +49,6 @@
     if unique_action_id != raw_action_id {
         tracing::debug!(
             target: "script_kit::actions",
-            action_name = %action_name,
             original_action_id = %raw_action_id,
             deduped_action_id = %unique_action_id,
             "Deduplicated scriptlet H3 action id"
@@ -51,40 +61,62 @@
 
 /// Convert scriptlet-defined actions (from H3 headers) to Action structs for the UI.
 pub fn get_scriptlet_defined_actions(scriptlet: &Scriptlet) -> Vec<Action> {
+    let invalid_action_count = count_invalid_scriptlet_actions(scriptlet);
+    if invalid_action_count > 0 {
+        tracing::warn!(
+            target: "script_kit::actions",
+            builder = "scriptlet_defined",
+            scriptlet_name = %scriptlet.name,
+            action_count = scriptlet.actions.len(),
+            invalid_action_count,
+            "Invalid scriptlet-defined action input; returning empty actions"
+        );
+        return vec![];
+    }
+
     let mut used_action_ids = HashSet::new();
-    let actions: Vec<Action> = scriptlet
-        .actions
-        .iter()
-        .filter_map(|sa| {
-            let raw_action_id = sa.action_id();
-            let action_id =
-                unique_scriptlet_action_id(&raw_action_id, &sa.name, &mut used_action_ids)?;
-            let mut action = Action::new(
-                action_id,
-                &sa.name,
-                sa.description.clone(),
-                ActionCategory::ScriptContext,
+    let mut actions: Vec<Action> = Vec::with_capacity(scriptlet.actions.len());
+
+    for sa in &scriptlet.actions {
+        let raw_action_id = sa.action_id();
+        let Some(action_id) = unique_scriptlet_action_id(&raw_action_id, &mut used_action_ids)
+        else {
+            tracing::warn!(
+                target: "script_kit::actions",
+                builder = "scriptlet_defined",
+                scriptlet_name = %scriptlet.name,
+                action_name = %sa.name,
+                action_id = %raw_action_id,
+                "Invalid scriptlet action id input; returning empty actions"
             );
+            return vec![];
+        };
 
-            if let Some(ref shortcut) = sa.shortcut {
-                action = action.with_shortcut(format_shortcut_hint(shortcut));
-            }
+        let mut action = Action::new(
+            action_id,
+            &sa.name,
+            sa.description.clone(),
+            ActionCategory::ScriptContext,
+        );
 
-            action = action.with_icon(IconName::PlayFilled).with_section("Actions");
-            action.has_action = true;
-            action.value = Some(sa.command.clone());
+        if let Some(ref shortcut) = sa.shortcut {
+            action = action.with_shortcut(format_shortcut_hint(shortcut));
+        }
 
-            tracing::debug!(
-                target: "script_kit::actions",
-                action_id = %action.id,
-                has_action = action.has_action,
-                has_shortcut = action.shortcut.is_some(),
-                "Created scriptlet-defined action (has_action=true)"
-            );
+        action = action.with_icon(IconName::PlayFilled).with_section("Actions");
+        action.has_action = true;
+        action.value = Some(sa.command.clone());
+
+        tracing::debug!(
+            target: "script_kit::actions",
+            action_id = %action.id,
+            has_action = action.has_action,
+            has_shortcut = action.shortcut.is_some(),
+            "Created scriptlet-defined action (has_action=true)"
+        );
 
-            Some(action)
-        })
-        .collect();
+        actions.push(action);
+    }
 
     if !actions.is_empty() {
         tracing::debug!(
@@ -103,6 +135,32 @@
     script: &ScriptInfo,
     scriptlet: Option<&Scriptlet>,
 ) -> Vec<Action> {
+    if has_invalid_scriptlet_context_input(script) {
+        tracing::warn!(
+            target: "script_kit::actions",
+            builder = "scriptlet_context",
+            name = %script.name,
+            action_verb = %script.action_verb,
+            "Invalid scriptlet context input; returning empty actions"
+        );
+        return vec![];
+    }
+
+    if let Some(scriptlet) = scriptlet {
+        let invalid_action_count = count_invalid_scriptlet_actions(scriptlet);
+        if invalid_action_count > 0 {
+            tracing::warn!(
+                target: "script_kit::actions",
+                builder = "scriptlet_context",
+                scriptlet_name = %scriptlet.name,
+                action_count = scriptlet.actions.len(),
+                invalid_action_count,
+                "Invalid scriptlet-defined action input; returning empty actions"
+            );
+            return vec![];
+        }
+    }
+
     let mut actions = Vec::new();
     let mut destructive_actions = Vec::new();
 
@@ -342,7 +400,7 @@
     }
 
     #[test]
-    fn test_get_scriptlet_defined_actions_drops_action_when_command_is_empty() {
+    fn test_get_scriptlet_defined_actions_returns_empty_when_command_is_empty() {
         let mut scriptlet = Scriptlet::new(
             "Malformed".to_string(),
             "bash".to_string(),
@@ -355,6 +413,53 @@
     }
 
     #[test]
+    fn test_get_scriptlet_defined_actions_returns_empty_when_any_action_is_invalid() {
+        let mut scriptlet = Scriptlet::new(
+            "Mixed".to_string(),
+            "bash".to_string(),
+            "echo".to_string(),
+        );
+        scriptlet.actions = vec![
+            scriptlet_action("Valid", "copy"),
+            scriptlet_action("   ", "invalid"),
+        ];
+
+        let actions = get_scriptlet_defined_actions(&scriptlet);
+        assert!(actions.is_empty());
+    }
+
+    #[test]
+    fn test_get_scriptlet_context_actions_returns_empty_when_script_name_is_blank() {
+        let mut script =
+            ScriptInfo::scriptlet("Demo", "/tmp/demo.md", Some("cmd d".to_string()), None);
+        script.name = "   ".to_string();
+
+        let actions = get_scriptlet_context_actions_with_custom(&script, None);
+        assert!(actions.is_empty());
+    }
+
+    #[test]
+    fn test_get_scriptlet_context_actions_returns_empty_when_action_verb_is_blank() {
+        let mut script =
+            ScriptInfo::scriptlet("Demo", "/tmp/demo.md", Some("cmd d".to_string()), None);
+        script.action_verb = "   ".to_string();
+
+        let actions = get_scriptlet_context_actions_with_custom(&script, None);
+        assert!(actions.is_empty());
+    }
+
+    #[test]
+    fn test_get_scriptlet_context_actions_returns_empty_when_scriptlet_action_input_is_invalid() {
+        let script = ScriptInfo::scriptlet("Demo", "/tmp/demo.md", Some("cmd d".to_string()), None);
+        let mut scriptlet =
+            Scriptlet::new("Malformed".to_string(), "bash".to_string(), "echo".to_string());
+        scriptlet.actions = vec![scriptlet_action("Bad", "   ")];
+
+        let actions = get_scriptlet_context_actions_with_custom(&script, Some(&scriptlet));
+        assert!(actions.is_empty());
+    }
+
+    #[test]
     fn test_get_scriptlet_context_actions_assigns_consistent_primary_icons() {
         let script = ScriptInfo::scriptlet("Demo", "/tmp/demo.md", Some("cmd d".to_string()), None);
         let actions = get_scriptlet_context_actions_with_custom(&script, None);

Reconnecting... 1/5 (stream disconnected before completion: websocket closed by server before response.completed)

thinking
**Polling for completion status**
file update:
diff --git a/src/actions/builders/notes.rs b/src/actions/builders/notes.rs
index 48ba267e97bf2f3da7ecf1a3f78fea59dbc9acab..a2f0007d3327b005960130e6e30f524ceb6b3e9f
--- a/src/actions/builders/notes.rs
+++ b/src/actions/builders/notes.rs
@@ -27,6 +27,25 @@
     pub auto_sizing_enabled: bool,
 }
 
+fn is_blank(value: &str) -> bool {
+    value.trim().is_empty()
+}
+
+fn has_invalid_new_chat_model_info(model: &NewChatModelInfo) -> bool {
+    is_blank(&model.model_id)
+        || is_blank(&model.display_name)
+        || is_blank(&model.provider)
+        || is_blank(&model.provider_display_name)
+}
+
+fn has_invalid_new_chat_preset_info(preset: &NewChatPresetInfo) -> bool {
+    is_blank(&preset.id) || is_blank(&preset.name)
+}
+
+fn has_invalid_note_switcher_note_info(note: &NoteSwitcherNoteInfo) -> bool {
+    is_blank(&note.id) || is_blank(&note.title)
+}
+
 /// Get actions for the Notes window command bar (Cmd+K menu).
 pub fn get_notes_command_bar_actions(info: &NotesInfo) -> Vec<Action> {
     let mut actions = Vec::new();
@@ -367,6 +386,76 @@
             Some("Use Focused Writing preset")
         );
     }
+
+    #[test]
+    fn test_get_new_chat_actions_returns_empty_when_last_used_model_input_is_invalid() {
+        let last_used = vec![NewChatModelInfo {
+            model_id: "   ".to_string(),
+            display_name: "GPT-4o Mini".to_string(),
+            provider: "openai".to_string(),
+            provider_display_name: "OpenAI".to_string(),
+        }];
+        let presets = vec![NewChatPresetInfo {
+            id: "focused-writing".to_string(),
+            name: "Focused Writing".to_string(),
+            icon: IconName::Pencil,
+        }];
+
+        let actions = get_new_chat_actions(&last_used, &presets, &[]);
+        assert!(actions.is_empty());
+    }
+
+    #[test]
+    fn test_get_new_chat_actions_returns_empty_when_preset_input_is_invalid() {
+        let last_used = vec![NewChatModelInfo {
+            model_id: "gpt-4o-mini".to_string(),
+            display_name: "GPT-4o Mini".to_string(),
+            provider: "openai".to_string(),
+            provider_display_name: "OpenAI".to_string(),
+        }];
+        let presets = vec![NewChatPresetInfo {
+            id: "   ".to_string(),
+            name: "Focused Writing".to_string(),
+            icon: IconName::Pencil,
+        }];
+
+        let actions = get_new_chat_actions(&last_used, &presets, &[]);
+        assert!(actions.is_empty());
+    }
+
+    #[test]
+    fn test_get_new_chat_actions_returns_empty_when_model_input_is_invalid() {
+        let presets = vec![NewChatPresetInfo {
+            id: "focused-writing".to_string(),
+            name: "Focused Writing".to_string(),
+            icon: IconName::Pencil,
+        }];
+        let models = vec![NewChatModelInfo {
+            model_id: "claude-3-5-sonnet".to_string(),
+            display_name: "Claude 3.5 Sonnet".to_string(),
+            provider: "   ".to_string(),
+            provider_display_name: "Anthropic".to_string(),
+        }];
+
+        let actions = get_new_chat_actions(&[], &presets, &models);
+        assert!(actions.is_empty());
+    }
+
+    #[test]
+    fn test_get_note_switcher_actions_returns_empty_when_note_input_is_invalid() {
+        let notes = vec![NoteSwitcherNoteInfo {
+            id: "   ".to_string(),
+            title: "Missing ID".to_string(),
+            char_count: 5,
+            is_current: false,
+            is_pinned: false,
+            preview: "Preview".to_string(),
+            relative_time: "1m ago".to_string(),
+        }];
+
+        let actions = get_note_switcher_actions(&notes);
+        assert!(actions.is_empty());
+    }
 }
 
 /// Build actions for the AI new chat dropdown.
@@ -376,6 +465,48 @@
     presets: &[NewChatPresetInfo],
     models: &[NewChatModelInfo],
 ) -> Vec<Action> {
+    let invalid_last_used_count = last_used
+        .iter()
+        .filter(|model| has_invalid_new_chat_model_info(model))
+        .count();
+    if invalid_last_used_count > 0 {
+        tracing::warn!(
+            target: "script_kit::actions",
+            builder = "notes_new_chat",
+            invalid_last_used_count,
+            "Invalid last-used chat model input; returning empty actions"
+        );
+        return vec![];
+    }
+
+    let invalid_preset_count = presets
+        .iter()
+        .filter(|preset| has_invalid_new_chat_preset_info(preset))
+        .count();
+    if invalid_preset_count > 0 {
+        tracing::warn!(
+            target: "script_kit::actions",
+            builder = "notes_new_chat",
+            invalid_preset_count,
+            "Invalid chat preset input; returning empty actions"
+        );
+        return vec![];
+    }
+
+    let invalid_model_count = models
+        .iter()
+        .filter(|model| has_invalid_new_chat_model_info(model))
+        .count();
+    if invalid_model_count > 0 {
+        tracing::warn!(
+            target: "script_kit::actions",
+            builder = "notes_new_chat",
+            invalid_model_count,
+            "Invalid chat model input; returning empty actions"
+        );
+        return vec![];
+    }
+
     let mut actions = Vec::new();
 
     for setting in last_used {
@@ -442,6 +573,21 @@
 
 /// Get actions for the note switcher dialog (Cmd+P in Notes window).
 pub fn get_note_switcher_actions(notes: &[NoteSwitcherNoteInfo]) -> Vec<Action> {
+    let invalid_note_count = notes
+        .iter()
+        .filter(|note| has_invalid_note_switcher_note_info(note))
+        .count();
+    if invalid_note_count > 0 {
+        tracing::warn!(
+            target: "script_kit::actions",
+            builder = "note_switcher",
+            note_count = notes.len(),
+            invalid_note_count,
+            "Invalid note switcher input; returning empty actions"
+        );
+        return vec![];
+    }
+
     let mut actions = Vec::new();
 
     for note in notes {
diff --git a/src/actions/builders/script_context.rs b/src/actions/builders/script_context.rs
index d48add6d0604e4fc8ab6bc1d9a9cdc328a6037ab..c09068069325e288d1c697a6ed9aa07944aadf61
--- a/src/actions/builders/script_context.rs
+++ b/src/actions/builders/script_context.rs
@@ -2,8 +2,23 @@
 use super::types::{Action, ActionCategory, ScriptInfo};
 use std::collections::HashSet;
 
+fn has_invalid_script_context_input(script: &ScriptInfo) -> bool {
+    script.name.trim().is_empty() || script.action_verb.trim().is_empty()
+}
+
 /// Get actions specific to the focused script.
 pub fn get_script_context_actions(script: &ScriptInfo) -> Vec<Action> {
+    if has_invalid_script_context_input(script) {
+        tracing::warn!(
+            target: "script_kit::actions",
+            builder = "script_context",
+            name = %script.name,
+            action_verb = %script.action_verb,
+            "Invalid script context input; returning empty actions"
+        );
+        return vec![];
+    }
+
     let mut actions = Vec::new();
     let mut destructive_actions = Vec::new();
 
@@ -314,3 +329,26 @@
 pub fn get_global_actions() -> Vec<Action> {
     vec![]
 }
+
+#[cfg(test)]
+mod tests {
+    use super::*;
+
+    #[test]
+    fn test_get_script_context_actions_returns_empty_when_name_is_blank() {
+        let mut script = ScriptInfo::new("Valid", "/tmp/valid.ts");
+        script.name = "   ".to_string();
+
+        let actions = get_script_context_actions(&script);
+        assert!(actions.is_empty());
+    }
+
+    #[test]
+    fn test_get_script_context_actions_returns_empty_when_action_verb_is_blank() {
+        let mut script = ScriptInfo::new("Valid", "/tmp/valid.ts");
+        script.action_verb = "   ".to_string();
+
+        let actions = get_script_context_actions(&script);
+        assert!(actions.is_empty());
+    }
+}
diff --git a/src/actions/builders/scriptlet.rs b/src/actions/builders/scriptlet.rs
index 371dbac6d433b01ee915aebdcd5f371b952065da..fec3eaa1d184df4366bf235fd3293d99a97cb120
--- a/src/actions/builders/scriptlet.rs
+++ b/src/actions/builders/scriptlet.rs
@@ -1,11 +1,31 @@
 use super::shared::{format_shortcut_hint, to_deeplink_name};
 use super::types::{Action, ActionCategory, ScriptInfo};
 use crate::designs::icon_variations::IconName;
-use crate::scriptlets::Scriptlet;
+use crate::scriptlets::{Scriptlet, ScriptletAction};
 use std::collections::HashSet;
 
 const SCRIPTLET_ACTION_ID_PREFIX: &str = "scriptlet_action:";
 
+fn is_blank(value: &str) -> bool {
+    value.trim().is_empty()
+}
+
+fn has_invalid_scriptlet_context_input(script: &ScriptInfo) -> bool {
+    is_blank(&script.name) || is_blank(&script.action_verb)
+}
+
+fn has_invalid_scriptlet_action_input(action: &ScriptletAction) -> bool {
+    is_blank(&action.name) || is_blank(&action.command)
+}
+
+fn count_invalid_scriptlet_actions(scriptlet: &Scriptlet) -> usize {
+    scriptlet
+        .actions
+        .iter()
+        .filter(|action| has_invalid_scriptlet_action_input(action))
+        .count()
+}
+
 fn parse_scriptlet_action_command(action_id: &str) -> Option<&str> {
     action_id
         .strip_prefix(SCRIPTLET_ACTION_ID_PREFIX)
@@ -14,18 +34,9 @@
 
 fn unique_scriptlet_action_id(
     raw_action_id: &str,
-    action_name: &str,
     used_action_ids: &mut HashSet<String>,
 ) -> Option<String> {
-    let Some(action_command) = parse_scriptlet_action_command(raw_action_id) else {
-        tracing::warn!(
-            target: "script_kit::actions",
-            action_name = %action_name,
-            action_id = %raw_action_id,
-            "Failed to parse scriptlet H3 action id; dropping malformed action"
-        );
-        return None;
-    };
+    let action_command = parse_scriptlet_action_command(raw_action_id)?;
 
     let mut unique_action_id = raw_action_id.to_string();
     let mut duplicate_index = 2;
@@ -38,7 +49,6 @@
     if unique_action_id != raw_action_id {
         tracing::debug!(
             target: "script_kit::actions",
-            action_name = %action_name,
             original_action_id = %raw_action_id,
             deduped_action_id = %unique_action_id,
             "Deduplicated scriptlet H3 action id"
@@ -51,40 +61,62 @@
 
 /// Convert scriptlet-defined actions (from H3 headers) to Action structs for the UI.
 pub fn get_scriptlet_defined_actions(scriptlet: &Scriptlet) -> Vec<Action> {
+    let invalid_action_count = count_invalid_scriptlet_actions(scriptlet);
+    if invalid_action_count > 0 {
+        tracing::warn!(
+            target: "script_kit::actions",
+            builder = "scriptlet_defined",
+            scriptlet_name = %scriptlet.name,
+            action_count = scriptlet.actions.len(),
+            invalid_action_count,
+            "Invalid scriptlet-defined action input; returning empty actions"
+        );
+        return vec![];
+    }
+
     let mut used_action_ids = HashSet::new();
-    let actions: Vec<Action> = scriptlet
-        .actions
-        .iter()
-        .filter_map(|sa| {
-            let raw_action_id = sa.action_id();
-            let action_id =
-                unique_scriptlet_action_id(&raw_action_id, &sa.name, &mut used_action_ids)?;
-            let mut action = Action::new(
-                action_id,
-                &sa.name,
-                sa.description.clone(),
-                ActionCategory::ScriptContext,
+    let mut actions: Vec<Action> = Vec::with_capacity(scriptlet.actions.len());
+
+    for sa in &scriptlet.actions {
+        let raw_action_id = sa.action_id();
+        let Some(action_id) = unique_scriptlet_action_id(&raw_action_id, &mut used_action_ids)
+        else {
+            tracing::warn!(
+                target: "script_kit::actions",
+                builder = "scriptlet_defined",
+                scriptlet_name = %scriptlet.name,
+                action_name = %sa.name,
+                action_id = %raw_action_id,
+                "Invalid scriptlet action id input; returning empty actions"
             );
+            return vec![];
+        };
 
-            if let Some(ref shortcut) = sa.shortcut {
-                action = action.with_shortcut(format_shortcut_hint(shortcut));
-            }
+        let mut action = Action::new(
+            action_id,
+            &sa.name,
+            sa.description.clone(),
+            ActionCategory::ScriptContext,
+        );
 
-            action = action.with_icon(IconName::PlayFilled).with_section("Actions");
-            action.has_action = true;
-            action.value = Some(sa.command.clone());
+        if let Some(ref shortcut) = sa.shortcut {
+            action = action.with_shortcut(format_shortcut_hint(shortcut));
+        }
 
-            tracing::debug!(
-                target: "script_kit::actions",
-                action_id = %action.id,
-                has_action = action.has_action,
-                has_shortcut = action.shortcut.is_some(),
-                "Created scriptlet-defined action (has_action=true)"
-            );
+        action = action.with_icon(IconName::PlayFilled).with_section("Actions");
+        action.has_action = true;
+        action.value = Some(sa.command.clone());
+
+        tracing::debug!(
+            target: "script_kit::actions",
+            action_id = %action.id,
+            has_action = action.has_action,
+            has_shortcut = action.shortcut.is_some(),
+            "Created scriptlet-defined action (has_action=true)"
+        );
 
-            Some(action)
-        })
-        .collect();
+        actions.push(action);
+    }
 
     if !actions.is_empty() {
         tracing::debug!(
@@ -103,6 +135,32 @@
     script: &ScriptInfo,
     scriptlet: Option<&Scriptlet>,
 ) -> Vec<Action> {
+    if has_invalid_scriptlet_context_input(script) {
+        tracing::warn!(
+            target: "script_kit::actions",
+            builder = "scriptlet_context",
+            name = %script.name,
+            action_verb = %script.action_verb,
+            "Invalid scriptlet context input; returning empty actions"
+        );
+        return vec![];
+    }
+
+    if let Some(scriptlet) = scriptlet {
+        let invalid_action_count = count_invalid_scriptlet_actions(scriptlet);
+        if invalid_action_count > 0 {
+            tracing::warn!(
+                target: "script_kit::actions",
+                builder = "scriptlet_context",
+                scriptlet_name = %scriptlet.name,
+                action_count = scriptlet.actions.len(),
+                invalid_action_count,
+                "Invalid scriptlet-defined action input; returning empty actions"
+            );
+            return vec![];
+        }
+    }
+
     let mut actions = Vec::new();
     let mut destructive_actions = Vec::new();
 
@@ -342,7 +400,7 @@
     }
 
     #[test]
-    fn test_get_scriptlet_defined_actions_drops_action_when_command_is_empty() {
+    fn test_get_scriptlet_defined_actions_returns_empty_when_command_is_empty() {
         let mut scriptlet = Scriptlet::new(
             "Malformed".to_string(),
             "bash".to_string(),
@@ -355,6 +413,53 @@
     }
 
     #[test]
+    fn test_get_scriptlet_defined_actions_returns_empty_when_any_action_is_invalid() {
+        let mut scriptlet = Scriptlet::new(
+            "Mixed".to_string(),
+            "bash".to_string(),
+            "echo".to_string(),
+        );
+        scriptlet.actions = vec![
+            scriptlet_action("Valid", "copy"),
+            scriptlet_action("   ", "invalid"),
+        ];
+
+        let actions = get_scriptlet_defined_actions(&scriptlet);
+        assert!(actions.is_empty());
+    }
+
+    #[test]
+    fn test_get_scriptlet_context_actions_returns_empty_when_script_name_is_blank() {
+        let mut script =
+            ScriptInfo::scriptlet("Demo", "/tmp/demo.md", Some("cmd d".to_string()), None);
+        script.name = "   ".to_string();
+
+        let actions = get_scriptlet_context_actions_with_custom(&script, None);
+        assert!(actions.is_empty());
+    }
+
+    #[test]
+    fn test_get_scriptlet_context_actions_returns_empty_when_action_verb_is_blank() {
+        let mut script =
+            ScriptInfo::scriptlet("Demo", "/tmp/demo.md", Some("cmd d".to_string()), None);
+        script.action_verb = "   ".to_string();
+
+        let actions = get_scriptlet_context_actions_with_custom(&script, None);
+        assert!(actions.is_empty());
+    }
+
+    #[test]
+    fn test_get_scriptlet_context_actions_returns_empty_when_scriptlet_action_input_is_invalid() {
+        let script = ScriptInfo::scriptlet("Demo", "/tmp/demo.md", Some("cmd d".to_string()), None);
+        let mut scriptlet =
+            Scriptlet::new("Malformed".to_string(), "bash".to_string(), "echo".to_string());
+        scriptlet.actions = vec![scriptlet_action("Bad", "   ")];
+
+        let actions = get_scriptlet_context_actions_with_custom(&script, Some(&scriptlet));
+        assert!(actions.is_empty());
+    }
+
+    #[test]
     fn test_get_scriptlet_context_actions_assigns_consistent_primary_icons() {
         let script = ScriptInfo::scriptlet("Demo", "/tmp/demo.md", Some("cmd d".to_string()), None);
         let actions = get_scriptlet_context_actions_with_custom(&script, None);


[swarm-timeout] max runtime 600s reached; sending SIGTERM


==== exit @ 2026-02-08T00:25:57.064Z code=0 status=needs_split ====
