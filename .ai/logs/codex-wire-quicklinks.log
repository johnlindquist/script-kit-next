==== spawn @ 2026-02-08T02:57:24.006Z ====
cmd: codex "exec" "--cd" "/Users/johnlindquist/dev/script-kit-gpui" "--model" "gpt-5.3-codex" "-c" "model_reasoning_effort=\"xhigh\"" "-c" "model_auto_compact_token_limit=120000" "-c" "developer_instructions=\"You are Codex implementer agent \\\"codex-wire-quicklinks\\\".\\n\\n## Coordination\\nThis repo runs parallel agents in ONE working tree. Before editing any file, you MUST claim it.\\nCommands (run via shell):\\n  - View roster: ~/.claude/bin/swarm.ts status\\n  - Claim files (blocks until free): ~/.claude/bin/swarm.ts claim --wait --id codex-wire-quicklinks path/to/file\\n  - Release: ~/.claude/bin/swarm.ts release --id codex-wire-quicklinks path/to/file\\n  - Update status/notes: ~/.claude/bin/swarm.ts update --id codex-wire-quicklinks --status in_progress --notes \\\"...\\\"\\nRules:\\n  - Never edit a file you haven't claimed.\\n  - Keep claims tight (claim only what you're actively changing).\\n  - If blocked, set status=blocked and say what you're waiting on.\\n  - When finished, set status=done and release claims.\\n\\n## Development practices (this code is maintained by AI agents)\\n  - Log state transitions with enough context to diagnose failures from logs alone.\\n  - Structured errors: include what was attempted, what failed, and current state.\\n  - Name things for grepability â€” unique identifiers agents can find on the first search.\\n  - Every behavior change gets a test. Untested code is invisible to the next agent.\\n  - Test names describe the scenario: test_X_does_Y_when_Z.\\n  - Keep functions small and single-purpose. 500-line functions burn agent context.\\n  - Use types to encode constraints (enums > strings for errors).\\n\\n## CRITICAL: Parallel-safe verification\\n  - Other agents are modifying other files RIGHT NOW. Full test suites WILL show their failures.\\n  - ONLY run tests that cover YOUR changed files. Scope every test/check command:\\n    Rust: cargo test -p your-crate -- module::test_name | JS: npx jest your/file.test.ts\\n  - Do NOT run: cargo test (unscoped), cargo check (whole workspace), npm test (unscoped).\\n  - If a scoped test fails, it's YOUR bug â€” fix it. If tests outside your scope fail, ignore them.\\n\\n## Git commit discipline\\n  - NEVER commit unverified work. Run tests/lints/type-checks FIRST. If it fails, fix it before committing.\\n  - A commit is a declaration: \\\"this works and here's the proof.\\\"\\n  - Commit FREQUENTLY â€” after each meaningful unit of VERIFIED work, not just at the end.\\n  - A \\\"unit\\\" = one logical change that passes verification (new function, bug fix, refactor, test added).\\n  - NEVER batch an entire task into one giant commit. Small commits are searchable; big ones aren't.\\n  - Commit message format:\\n      Line 1: <type>(<scope>): <what changed> (imperative, max 72 chars)\\n      Line 3+: WHY this change was made, WHAT was verified, and HOW to test it.\\n    Types: feat, fix, refactor, test, docs, chore\\n    Example:\\n      feat(auth): add refresh token rotation\\n      \\n      Tokens now rotate on each refresh call to prevent replay attacks.\\n      The old token is invalidated immediately on rotation.\\n      \\n      Verified: cargo test --lib -- auth::refresh (4 tests pass)\\n      Verified: manual smoke test via curl â€” token rotates, old token returns 401\\n  - The \\\"Verified:\\\" lines are REQUIRED. Future agents will read git log to understand\\n    what was tested and how to re-verify. This is the most valuable part of the message.\\n  - In your final message, list all commits you made with their hashes.\\n\\n## Time budget\\nYou have approximately 10 minutes. If your task is too broad to complete in time:\\n(1) Commit any verified progress.\\n(2) Run: ~/.claude/bin/swarm.ts update --id YOUR_ID --status needs_split --notes 'suggest: 1) sub-task-desc scope:files 2) sub-task-desc scope:files'.\\n(3) Exit cleanly. The dispatcher will read your suggestions and spawn narrower workers.\"" "--output-last-message" "/Users/johnlindquist/dev/script-kit-gpui/.ai/logs/codex-wire-quicklinks.final.md" "--yolo" "You are agent codex-wire-quicklinks.\n\nCurrent parallel-agent roster (read this first):\n```\nSWARM SNAPSHOT @ 2026-02-08T02:57:24.003Z\n- codex-wire-favorites [in_progress] scope=src/favorites/**,src/builtins/part_000.rs,src/builtins/part_001_entries/**,src/app_execute/builtin_execution.rs,src/actions/builders/script_context.rs task=Wire up the existing src/favorites/mod.rs storage module into the app as a working feature. The module already has loadâ€¦\n  notes: Inspecting favorites wiring points and planning minimal scoped edits\n- codex-wire-quicklinks [starting] scope=src/quicklinks/**,src/builtins/part_000.rs,src/builtins/part_001_entries/**,src/app_execute/builtin_execution.rs task=Wire up the existing src/quicklinks/mod.rs storage module into the app as a working built-in feature. The module alreadâ€¦\n```\n\nYour assignment:\n- Task: Wire up the existing src/quicklinks/mod.rs storage module into the app as a working built-in feature. The module already has create/load/save/delete/expand_url APIs backed by ~/.scriptkit/quicklinks.json. You need to: (1) Add a BuiltInFeature::Quicklinks variant in src/builtins/part_000.rs with a descriptive entry in get_builtin_entries(), (2) Add execute_builtin handling in src/app_execute/builtin_execution.rs that shows a list of quicklinks, (3) Allow users to add/edit/delete quicklinks and open them (expanding {query} placeholders). The UI should list existing quicklinks and have an option to create new ones. Run cargo check && cargo clippy --all-targets -- -D warnings && cargo test after changes.\n- Scope: src/quicklinks/**,src/builtins/part_000.rs,src/builtins/part_001_entries/**,src/app_execute/builtin_execution.rs\n\nOperating constraints:\n- Single working tree (no worktrees, no patches).\n- You MUST claim files before editing (~/.claude/bin/swarm.ts claim --wait ...).\n\nDeliverables:\n- Make the code changes required by the task.\n- Run the most relevant tests/linters.\n- In your FINAL message, include: changed files, how to test, and any risks/known gaps."

OpenAI Codex v0.98.0 (research preview)
--------
workdir: /Users/johnlindquist/dev/script-kit-gpui
model: gpt-5.3-codex
provider: openai
approval: never
sandbox: danger-full-access
reasoning effort: xhigh
reasoning summaries: auto
session id: 019c3b2e-ba57-72f0-8ce2-b418c9db67fa
--------
user
You are agent codex-wire-quicklinks.

Current parallel-agent roster (read this first):
```
SWARM SNAPSHOT @ 2026-02-08T02:57:24.003Z
- codex-wire-favorites [in_progress] scope=src/favorites/**,src/builtins/part_000.rs,src/builtins/part_001_entries/**,src/app_execute/builtin_execution.rs,src/actions/builders/script_context.rs task=Wire up the existing src/favorites/mod.rs storage module into the app as a working feature. The module already has loadâ€¦
  notes: Inspecting favorites wiring points and planning minimal scoped edits
- codex-wire-quicklinks [starting] scope=src/quicklinks/**,src/builtins/part_000.rs,src/builtins/part_001_entries/**,src/app_execute/builtin_execution.rs task=Wire up the existing src/quicklinks/mod.rs storage module into the app as a working built-in feature. The module alreadâ€¦
```

Your assignment:
- Task: Wire up the existing src/quicklinks/mod.rs storage module into the app as a working built-in feature. The module already has create/load/save/delete/expand_url APIs backed by ~/.scriptkit/quicklinks.json. You need to: (1) Add a BuiltInFeature::Quicklinks variant in src/builtins/part_000.rs with a descriptive entry in get_builtin_entries(), (2) Add execute_builtin handling in src/app_execute/builtin_execution.rs that shows a list of quicklinks, (3) Allow users to add/edit/delete quicklinks and open them (expanding {query} placeholders). The UI should list existing quicklinks and have an option to create new ones. Run cargo check && cargo clippy --all-targets -- -D warnings && cargo test after changes.
- Scope: src/quicklinks/**,src/builtins/part_000.rs,src/builtins/part_001_entries/**,src/app_execute/builtin_execution.rs

Operating constraints:
- Single working tree (no worktrees, no patches).
- You MUST claim files before editing (~/.claude/bin/swarm.ts claim --wait ...).

Deliverables:
- Make the code changes required by the task.
- Run the most relevant tests/linters.
- In your FINAL message, include: changed files, how to test, and any risks/known gaps.
warning: Under-development features enabled: responses_websockets. Under-development features are incomplete and may behave unpredictably. To suppress this warning, set `suppress_unstable_features_warning = true` in /Users/johnlindquist/.codex/config.toml.
mcp: deepwiki starting
mcp: deepwiki ready
mcp startup: ready: deepwiki

thinking
**Reconciling verification strategy**
codex
Iâ€™m taking the `codex-wire-quicklinks` task and will first inspect the existing quicklinks module plus builtin wiring points so I can implement only the required integration. Iâ€™ll verify current patterns before claiming files for edits.
exec
/bin/zsh -lc "rg --files src | rg 'quicklinks|builtins/part_000|app_execute/builtin_execution|part_001_entries'" in /Users/johnlindquist/dev/script-kit-gpuiexec
/bin/zsh -lc '~/.claude/bin/swarm.ts status' in /Users/johnlindquist/dev/script-kit-gpui succeeded in 50ms:
src/builtins/part_000.rs
src/builtins/part_001_entries/entries_000.rs
src/builtins/part_001_entries/entries_001.rs
src/builtins/part_001_entries/entries_002.rs
src/builtins/part_001_entries/entries_003.rs
src/quicklinks/mod.rs
src/app_execute/builtin_execution.rs
src/app_execute/builtin_execution/feature_02.rs
src/app_execute/builtin_execution/feature_03.rs
src/app_execute/builtin_execution/feature_01.rs
 succeeded in 52ms:
Repo: /Users/johnlindquist/dev/script-kit-gpui
Updated: 2026-02-08T02:57:37.352Z

Active agents (2):
codex-wire-favorites [in_progress] codex/gpt-5.3-codex/exec
  task: Wire up the existing src/favorites/mod.rs storage module into the app as a working feature. The module already has loadâ€¦
  scope: src/favorites/**,src/builtins/part_000.rs,src/builtins/part_001_entries/**,src/app_execute/builtin_execution.rs,src/actâ€¦
  claims: (none)
  notes: Inspecting favorites wiring points and planning minimal scoped edits

codex-wire-quicklinks [in_progress] codex/gpt-5.3-codex/exec
  task: Wire up the existing src/quicklinks/mod.rs storage module into the app as a working built-in feature. The module alreadâ€¦
  scope: src/quicklinks/**,src/builtins/part_000.rs,src/builtins/part_001_entries/**,src/app_execute/builtin_execution.rs
  claims: (none)
  notes: spawned codex (exec)

Inactive agents (255):
- codex-accessibility [done] done. exit=0. final=.ai/logs/codex-accessibility.final.md. See final message file.
- codex-action-labels [failed] failed. exit=1. final=.ai/logs/codex-action-labels.final.md.
- codex-actions-audit [failed] failed. exit=1. final=.ai/logs/codex-actions-audit.final.md. See final message file.

thinking
**Inspecting quicklinks and builtins**
codex
I found the target files and confirmed no claims are active yet. Next Iâ€™m reading the quicklinks APIs and existing built-in execution patterns so the new feature matches current architecture.
exec
/bin/zsh -lc "sed -n '1,260p' src/quicklinks/mod.rs" in /Users/johnlindquist/dev/script-kit-gpui succeeded in 51ms:
//! Quicklinks data model and JSON storage.

use std::fs;
use std::path::{Path, PathBuf};

use serde::{Deserialize, Serialize};
use uuid::Uuid;

const QUICKLINKS_FILE: &str = "quicklinks.json";
const QUERY_PLACEHOLDER: &str = "{query}";

#[derive(Clone, Debug, Serialize, Deserialize, PartialEq, Eq)]
pub struct Quicklink {
    pub id: String,
    pub name: String,
    pub url_template: String,
    #[serde(default)]
    pub icon: Option<String>,
}

exec
/bin/zsh -lc "sed -n '1,280p' src/builtins/part_000.rs" in /Users/johnlindquist/dev/script-kit-gpuiexec
/bin/zsh -lc "sed -n '1,320p' src/app_execute/builtin_execution.rs" in /Users/johnlindquist/dev/script-kit-gpui succeeded in 51ms:
use crate::config::BuiltInConfig;
use crate::menu_bar::MenuBarItem;
use tracing::debug;
// ============================================================================
// Command Type Enums
// ============================================================================

/// System action types for macOS system commands
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum SystemActionType {
    // Power management
    EmptyTrash,
    LockScreen,
    Sleep,
    Restart,
    ShutDown,
    LogOut,

    // UI controls
    ToggleDarkMode,
 succeeded in 52ms:
fn ai_open_failure_message(error: impl std::fmt::Display) -> String {
    format!("Failed to open AI: {}", error)
}

impl ScriptListApp {
    fn system_action_feedback_message(
        &self,
        action_type: &builtins::SystemActionType,
    ) -> Option<String> {
        let dark_mode_enabled = if matches!(action_type, builtins::SystemActionType::ToggleDarkMode)
        {
            system_actions::is_dark_mode().ok()
        } else {
            None
        };

        builtins::system_action_hud_message(*action_type, dark_mode_enabled)
    }

    fn execute_builtin(&mut self, entry: &builtins::BuiltInEntry, cx: &mut Context<Self>) {

thinking
**Exploring builtin execution and match arms**
exec
/bin/zsh -lc 'rg -n "get_builtin_entries|BuiltInFeature::|Quicklink|quicklink|quicklinks|FrecencyCommand|UtilityCommand|KitStoreCommand|FileSearch|Webcam" src/builtins/part_000.rs src/builtins/part_001_entries -S' in /Users/johnlindquist/dev/script-kit-gpuiexec
/bin/zsh -lc "rg -n \"BuiltInFeature::|current_view = AppView::|AppView::|Quicklink|quicklink|quicklinks|open_url|open\\(\" src/app_execute/builtin_execution.rs src/app_execute/builtin_execution/*.rs -S" in /Users/johnlindquist/dev/script-kit-gpui succeeded in 52ms:
src/app_execute/builtin_execution.rs:127:            builtins::BuiltInFeature::ClipboardHistory => {
src/app_execute/builtin_execution.rs:148:                self.current_view = AppView::ClipboardHistoryView {
src/app_execute/builtin_execution.rs:162:            builtins::BuiltInFeature::AppLauncher => {
src/app_execute/builtin_execution.rs:177:                self.current_view = AppView::AppLauncherView {
src/app_execute/builtin_execution.rs:191:            builtins::BuiltInFeature::App(app_name) => {
src/app_execute/builtin_execution.rs:213:            builtins::BuiltInFeature::WindowSwitcher => {
src/app_execute/builtin_execution.rs:225:                        self.current_view = AppView::WindowSwitcherView {
src/app_execute/builtin_execution.rs:251:            builtins::BuiltInFeature::DesignGallery => {
src/app_execute/builtin_execution.rs:257:                self.current_view = AppView::DesignGalleryView {
src/app_execute/builtin_execution.rs:271:            builtins::BuiltInFeature::AiChat => {
src/app_execute/builtin_execution.rs:306:            builtins::BuiltInFeature::Notes => {
src/app_execute/builtin_execution.rs:324:            builtins::BuiltInFeature::MenuBarAction(action) => {
src/app_execute/builtin_execution.rs:374:            builtins::BuiltInFeature::SystemAction(action_type) => {
src/app_execute/builtin_execution.rs:509:            builtins::BuiltInFeature::NotesCommand(cmd_type) => {
src/app_execute/builtin_execution.rs:542:            builtins::BuiltInFeature::AiCommand(cmd_type) => {
src/app_execute/builtin_execution.rs:1000:            builtins::BuiltInFeature::ScriptCommand(cmd_type) => {
src/app_execute/builtin_execution.rs:1061:            builtins::BuiltInFeature::PermissionCommand(cmd_type) => {
src/app_execute/builtin_execution.rs:1141:            builtins::BuiltInFeature::FrecencyCommand(cmd_type) => {
src/app_execute/builtin_execution.rs:1186:            builtins::BuiltInFeature::SettingsCommand(cmd_type) => {
src/app_execute/builtin_execution.rs:1252:                        self.current_view = AppView::ThemeChooserView {
 succeeded in 52ms:
src/builtins/part_000.rs:133:pub enum FrecencyCommandType {
src/builtins/part_000.rs:152:pub enum UtilityCommandType {
src/builtins/part_000.rs:164:pub enum KitStoreCommandType {
src/builtins/part_000.rs:225:    FrecencyCommand(FrecencyCommandType),
src/builtins/part_000.rs:229:    UtilityCommand(UtilityCommandType),
src/builtins/part_000.rs:231:    KitStoreCommand(KitStoreCommandType),
src/builtins/part_000.rs:233:    FileSearch,
src/builtins/part_000.rs:234:    /// Webcam capture
src/builtins/part_000.rs:235:    Webcam,
src/builtins/part_001_entries/entries_000.rs:8:            BuiltInFeature::ClipboardHistory,
src/builtins/part_001_entries/entries_000.rs:26:            BuiltInFeature::WindowSwitcher,
src/builtins/part_001_entries/entries_000.rs:47:        BuiltInFeature::AiChat,
src/builtins/part_001_entries/entries_000.rs:67:        BuiltInFeature::Notes,
src/builtins/part_001_entries/entries_000.rs:88:            BuiltInFeature::DesignGallery,
src/builtins/part_001_entries/entries_000.rs:99:            BuiltInFeature::SystemAction(SystemActionType::TestConfirmation),
src/builtins/part_001_entries/entries_001.rs:11:        BuiltInFeature::SystemAction(SystemActionType::EmptyTrash),
src/builtins/part_001_entries/entries_001.rs:20:        BuiltInFeature::SystemAction(SystemActionType::LockScreen),
src/builtins/part_001_entries/entries_001.rs:29:        BuiltInFeature::SystemAction(SystemActionType::Sleep),
src/builtins/part_001_entries/entries_001.rs:38:        BuiltInFeature::SystemAction(SystemActionType::Restart),
src/builtins/part_001_entries/entries_001.rs:47:        BuiltInFeature::SystemAction(SystemActionType::ShutDown),

thinking
**Inspecting builtins entries logic**
exec
/bin/zsh -lc "sed -n '280,560p' src/builtins/part_000.rs" in /Users/johnlindquist/dev/script-kit-gpuiexec
/bin/zsh -lc "sed -n '1,340p' src/builtins/part_001_entries/entries_003.rs" in /Users/johnlindquist/dev/script-kit-gpuiexec
/bin/zsh -lc "sed -n '1,280p' src/builtins/part_001_entries/entries_000.rs" in /Users/johnlindquist/dev/script-kit-gpui succeeded in 52ms:
        name: impl Into<String>,
        description: impl Into<String>,
        keywords: Vec<&str>,
        feature: BuiltInFeature,
        icon: impl Into<String>,
    ) -> Self {
        BuiltInEntry {
            id: id.into(),
            name: name.into(),
            description: description.into(),
            keywords: keywords.into_iter().map(String::from).collect(),
            feature,
            icon: Some(icon.into()),
            group: BuiltInGroup::Core,
        }
    }

    /// Create a new built-in entry with icon and group
    #[allow(dead_code)]
    pub fn new_with_group(
 succeeded in 50ms:
{
    // Settings Commands
    // =========================================================================

    // Only show reset if there are custom positions
    if crate::window_state::has_custom_positions() {
        entries.push(BuiltInEntry::new_with_icon(
            "builtin-reset-window-positions",
            "Reset Window Positions",
            "Restore all windows to default positions",
            vec![
                "reset", "window", "position", "default", "restore", "layout", "location",
            ],
            BuiltInFeature::SettingsCommand(SettingsCommandType::ResetWindowPositions),
            "ðŸ”„",
        ));
    }

    // API Key Configuration
    entries.push(BuiltInEntry::new_with_icon(
 succeeded in 50ms:
{
    if config.clipboard_history {
        entries.push(BuiltInEntry::new_with_icon(
            "builtin-clipboard-history",
            "Clipboard History",
            "Open clipboard history to view, search, and reuse copied items",
            vec!["clipboard", "history", "paste", "copy"],
            BuiltInFeature::ClipboardHistory,
            "ðŸ“‹",
        ));
        debug!("Added Clipboard History built-in entry");
    }

    // Note: AppLauncher built-in removed - apps now appear directly in main search
    // The app_launcher config flag is kept for future use (e.g., to disable app search entirely)
    if config.app_launcher {
        debug!("app_launcher enabled - apps will appear in main search");
    }

    if config.window_switcher {

thinking
**Inspecting builtins module structure**
exec
/bin/zsh -lc "sed -n '1,280p' src/builtins/mod.rs" in /Users/johnlindquist/dev/script-kit-gpui succeeded in 51ms:
//! Built-in Features Registry
//!
//! Provides a registry of built-in features that appear in the main search
//! alongside scripts. Features like Clipboard History and App Launcher are
//! configurable and can be enabled/disabled via config.
//!
//! ## Command Types
//!
//! The registry supports various command types organized by category:
//! - **System Actions**: Power management, UI controls, volume/brightness
//! - **Window Actions**: Window tiling and management for the frontmost window
//! - **Notes Commands**: Notes window operations
//! - **AI Commands**: AI chat window operations  
//! - **Script Commands**: Create new scripts and scriptlets
//! - **Permission Commands**: Accessibility permission management
//!

include!("part_000.rs");
include!("part_001.rs");
include!("part_002.rs");

thinking
**Reviewing builtin entries**
exec
/bin/zsh -lc "sed -n '1,260p' src/builtins/part_001.rs" in /Users/johnlindquist/dev/script-kit-gpuiexec
/bin/zsh -lc "sed -n '1,260p' src/builtins/part_003.rs" in /Users/johnlindquist/dev/script-kit-gpuiexec
/bin/zsh -lc "sed -n '1,260p' src/builtins/part_002.rs" in /Users/johnlindquist/dev/script-kit-gpui succeeded in 50ms:
/// Get the list of enabled built-in entries based on configuration
///
/// # Arguments
/// * `config` - The built-in features configuration
///
/// # Returns
/// A vector of enabled built-in entries that should appear in the main search
///
/// Note: AppLauncher built-in is no longer used since apps now appear directly
/// in the main search results. The config option is retained for future use
/// (e.g., to control whether apps are included in search at all).
pub fn get_builtin_entries(config: &BuiltInConfig) -> Vec<BuiltInEntry> {
    let mut entries = Vec::new();

    include!("part_001_entries/entries_000.rs");
    include!("part_001_entries/entries_001.rs");
    include!("part_001_entries/entries_002.rs");
    include!("part_001_entries/entries_003.rs");

    debug!(count = entries.len(), "Built-in entries loaded");
 succeeded in 51ms:
#[cfg(test)]
mod tests {
    include!("tests/part_000.rs");
    include!("tests/part_001.rs");
}
 succeeded in 51ms:
// ============================================================================
// Menu Bar Item Conversion
// ============================================================================

/// Convert menu bar items to built-in entries for search
///
/// This flattens the menu hierarchy into searchable entries, skipping the
/// Apple menu (first item) and only including leaf items (no submenus).
///
/// # Arguments
/// * `items` - The menu bar items from the frontmost application
/// * `bundle_id` - The bundle identifier of the application (e.g., "com.apple.Safari")
/// * `app_name` - The display name of the application (e.g., "Safari")
///
/// # Returns
/// A vector of `BuiltInEntry` items that can be added to search results
#[allow(dead_code)] // Will be used when menu bar integration is complete
pub fn menu_bar_items_to_entries(
    items: &[MenuBarItem],
    bundle_id: &str,

thinking
**Exploring app view architecture**
codex
Iâ€™ve confirmed built-ins are split across `entries_*.rs`; next Iâ€™m tracing how existing built-ins present list UIs and action handling so quicklinks can reuse those patterns without broad refactors.
exec
/bin/zsh -lc 'rg -n "enum AppView|AppView::|ProcessManager|ScratchPad|ThemeChooserView|ClipboardHistoryView|opened_from_main_menu|actions_popup" src -S' in /Users/johnlindquist/dev/script-kit-gpuiexec
/bin/zsh -lc 'rg -n "quicklinks|quicklink|favorites|favorite|open::that|open::|browser|url" src -S' in /Users/johnlindquist/dev/script-kit-gpui succeeded in 51ms:
Total output lines: 768

src/app_actions/handle_action.rs:161:    /// Return the currently selected clipboard entry metadata when in ClipboardHistoryView.
src/app_actions/handle_action.rs:173:        let AppView::ClipboardHistoryView {
src/app_actions/handle_action.rs:188:            AppView::ClipboardHistoryView { .. } => self.selected_clipboard_entry().is_some(),
src/app_actions/handle_action.rs:214:        self.current_view = AppView::ScriptList;
src/app_actions/handle_action.rs:274:                        if let AppView::ClipboardHistoryView {
src/app_actions/handle_action.rs:1577:                    AppView::ClipboardHistoryView { filter, .. } => filter.trim().to_string(),
src/app_actions/handle_action.rs:1697:                        if let AppView::ClipboardHistoryView { selected_index, .. } =
src/app_actions/handle_action.rs:1738:                        // Update selection in ClipboardHistoryView
src/app_actions/handle_action.rs:1739:                        if let AppView::ClipboardHistoryView {
src/app_actions/handle_action.rs:1885:                                if let AppView::ClipboardHistoryView { selected_index, .. } =
src/app_actions/handle_action.rs:2426:                // The actions dialog is already closed by setting current_view = AppView::ScriptList
src/app_actions/handle_action/main_actions_06.rs:160:                // The actions dialog is already closed by setting current_view = AppView::ScriptList
src/app_actions/handle_action/clipboard_actions.rs:19:                        if let AppView::ClipboardHistoryView {
src/app_actions/handle_action/main_actions_04.rs:3:                    AppView::ClipboardHistoryView { filter, .. } => filter.trim().to_string(),
src/app_actions/handle_action/main_actions_04.rs:123:                        if let AppView::ClipboardHistoryView { selected_index, .. } =
src/app_actions/handle_action/main_actions_04.rs:164:                        // Update selection in ClipboardHistoryView
src/app_actions/handle_action/main_actions_04.rs:165:                        if let AppView::ClipboardHistoryView {
src/app_actions/handle_action/main_actions_04.rs:311:                                if let AppView::ClipboardHistoryView { selected_index, .. } =
 succeeded in 51ms:
Total output lines: 1204

src/app_actions/handle_action.rs:218:    /// Simple percent-encoding for URL query strings.
src/app_actions/handle_action.rs:219:    fn percent_encode_for_url(&self, input: &str) -> String {
src/app_actions/handle_action.rs:701:                    let deeplink_url = format!("scriptkit://run/{}", deeplink_name);
src/app_actions/handle_action.rs:705:                        match self.pbcopy(&deeplink_url) {
src/app_actions/handle_action.rs:709:                                    &format!("Copied deeplink to clipboard: {}", deeplink_url),
src/app_actions/handle_action.rs:711:                                self.show_hud(format!("Copied: {}", deeplink_url), Some(2000), cx);
src/app_actions/handle_action.rs:727:                        match Clipboard::new().and_then(|mut c| c.set_text(&deeplink_url)) {
src/app_actions/handle_action.rs:731:                                    &format!("Copied deeplink to clipboard: {}", deeplink_url),
src/app_actions/handle_action.rs:733:                                self.show_hud(format!("Copied: {}", deeplink_url), Some(2000), cx);
src/app_actions/handle_action.rs:1382:                    let url = "cleanshot://open-from-clipboard";
src/app_actions/handle_action.rs:1383:                    match std::process::Command::new("open").arg(url).spawn() {
src/app_actions/handle_action.rs:1441:                    let encoded_path = self.percent_encode_for_url(&path_str);
src/app_actions/handle_action.rs:1442:                    let url = format!(
src/app_actions/handle_action.rs:1447:                    match std::process::Command::new("open").arg(&url).spawn() {
src/app_actions/handle_action.rs:2496:                                        // parent's code (e.g., the URL for `open` tool scriptlets)
src/app_actions/handle_action/main_actions_03.rs:135:                    let url = "cleanshot://open-from-clipboard";
src/app_actions/handle_action/main_actions_03.rs:136:                    match std::process::Command::new("open").arg(url).spawn() {
src/app_actions/handle_action/main_actions_03.rs:194:                    let encoded_path = self.percent_encode_for_url(&path_str);

thinking
**Assessing built-in command integration**
exec
/bin/zsh -lc "sed -n '1160,1445p' src/app_execute/builtin_execution.rs" in /Users/johnlindquist/dev/script-kit-gpui succeeded in 51ms:
                                .duration_ms(Some(5000)),
                            );
                        } else {
                            logging::log("EXEC", "Cleared all suggested items");
                            // Invalidate the grouped cache so the UI updates
                            self.invalidate_grouped_cache();
                            // Reset the main input and window to clean state
                            self.reset_to_script_list(cx);
                            resize_to_view_sync(ViewType::ScriptList, 0);
                            self.toast_manager.push(
                                components::toast::Toast::success(
                                    "Suggested items cleared",
                                    &self.theme,
                                )
                                .duration_ms(Some(3000)),
                            );
                        }
                        // Note: cx.notify() is called by reset_to_script_list, but we still need it for error case
                        cx.notify();
                    }

thinking
**Assessing quicklinks integration approach**
exec
/bin/zsh -lc 'rg -n "create_quicklink|quicklink|quicklinks|Quicklink|expand_url|delete_quicklink|load_quicklinks|save_quicklinks" src -S' in /Users/johnlindquist/dev/script-kit-gpui succeeded in 51ms:
src/notes/window/notes_actions.rs:141:    pub(super) fn create_note_quicklink(&mut self) {
src/notes/window/notes_actions.rs:142:        let Some((id, note)) = self.selected_note_for_action("create_note_quicklink") else {
src/notes/window/notes_actions.rs:151:        let quicklink = format!("[{}]({})", title, deeplink);
src/notes/window/notes_actions.rs:152:        self.copy_text_to_clipboard(&quicklink);
src/setup/part_000.rs:32:    include_str!("../../kit-init/extensions/quicklinks/main.md");
src/setup/part_000.rs:33:/// Embedded Quick Links shared actions (built-in actions for all quicklinks scriptlets)
src/setup/part_000.rs:35:    include_str!("../../kit-init/extensions/quicklinks/main.actions.md");
src/notes/window/panels.rs:18:                    | NotesAction::CreateQuicklink
src/notes/window/panels.rs:211:            NotesAction::CreateQuicklink => self.create_note_quicklink(),
src/notes/window/panels.rs:248:            "create_quicklink" => Some(NotesAction::CreateQuicklink),
src/setup/part_006.rs:335:        let quicklinks_dir = kit_dir.join("quicklinks").join("extensions");
src/setup/part_006.rs:337:            quicklinks_dir.exists(),
src/setup/part_006.rs:338:            "kit/quicklinks/extensions/ should exist"
src/setup/part_006.rs:340:        let quicklinks_extension = quicklinks_dir.join("main.md");
src/setup/part_006.rs:342:            quicklinks_extension.exists(),
src/setup/part_006.rs:343:            "kit/quicklinks/extensions/main.md should exist"
src/setup/part_006.rs:345:        let quicklinks_content = fs::read_to_string(&quicklinks_extension).unwrap();
src/setup/part_006.rs:347:            quicklinks_content.contains("Quick Links"),
src/setup/part_006.rs:351:            quicklinks_content.contains("https://github.com"),
src/setup/part_006.rs:355:            quicklinks_content.contains("https://www.google.com"),

thinking
**Assessing existing quicklinks scripts**
codex
I confirmed thereâ€™s no existing Rust-side quicklinks UI yet. Iâ€™m now checking the bundled quicklinks script templates to mirror expected behaviors (open, add, edit, delete, `{query}` expansion) in the built-in implementation.
exec
/bin/zsh -lc "sed -n '1,260p' kit-init/extensions/quicklinks/main.actions.md" in /Users/johnlindquist/dev/script-kit-gpuiexec
/bin/zsh -lc "sed -n '1,260p' kit-init/extensions/quicklinks/main.md" in /Users/johnlindquist/dev/script-kit-gpui succeeded in 51ms:
# URL Actions

Shared actions for all Quick Links scriptlets.
The `{{content}}` variable contains the parent scriptlet's code (the URL for `open` tool).

### Copy URL
<!-- shortcut: cmd+c -->
<!-- description: Copy the URL to clipboard -->
```bash
echo -n "{{content}}" | pbcopy
```

### Open in Safari
<!-- shortcut: cmd+shift+s -->
<!-- description: Open URL in Safari -->
```bash
open -a Safari "{{content}}"
```

### Open in Firefox
 succeeded in 51ms:
---
name: Quick Links
description: Quick access to commonly used websites
author: Script Kit
icon: link
---

# Quick Links

Instantly open your most frequently used websites.

---

## Google Search

<!--
description: Open Google Search
-->

```open

thinking
**Inspecting favorites module**
exec
/bin/zsh -lc "sed -n '1,260p' src/favorites/mod.rs" in /Users/johnlindquist/dev/script-kit-gpui succeeded in 51ms:
use anyhow::{Context, Result};
use serde::{Deserialize, Serialize};
use std::fs;
use std::path::{Path, PathBuf};

#[derive(Debug, Clone, Default, Serialize, Deserialize, PartialEq, Eq)]
pub struct Favorites {
    pub script_ids: Vec<String>,
}

fn favorites_file_path() -> PathBuf {
    dirs::home_dir()
        .map(|home| home.join(".scriptkit").join("favorites.json"))
        .unwrap_or_else(|| PathBuf::from(".scriptkit").join("favorites.json"))
}

fn load_favorites_from_path(path: &Path) -> Result<Favorites> {
    if !path.exists() {
        return Ok(Favorites::default());
    }

thinking
**Planning quicklinks CRUD modal**
exec
/bin/zsh -lc "rg -n \"fn show_api_key_prompt|show_.*prompt\\(|open_.*prompt|Prompt\" src/app_execute src/app_impl src/render_builtins -S" in /Users/johnlindquist/dev/script-kit-gpui succeeded in 51ms:
src/app_execute/utility_views.rs:20:        match term_prompt::TermPrompt::with_height(
src/app_execute/utility_views.rs:33:                self.pending_focus = Some(FocusTarget::TermPrompt);
src/app_execute/utility_views.rs:38:                    resize_to_view_sync(ViewType::TermPrompt, 0);
src/app_execute/utility_views.rs:282:        match term_prompt::TermPrompt::with_height(
src/app_execute/utility_views.rs:295:                self.pending_focus = Some(FocusTarget::TermPrompt);
src/app_execute/utility_views.rs:300:                    resize_to_view_sync(ViewType::TermPrompt, 0);
src/app_execute/utility_views.rs:332:        let webcam_prompt = prompts::WebcamPrompt::new(
src/app_execute/utility_views.rs:367:                resize_to_view_sync(ViewType::DivPrompt, 0);
src/app_execute/utility_views.rs:422:        resize_to_view_sync(ViewType::DivPrompt, 0);
src/app_execute/utility_views.rs:435:        let webcam_prompt = prompts::WebcamPrompt::new(
src/app_execute/utility_views.rs:461:        resize_to_view_sync(ViewType::DivPrompt, 0);
src/app_impl/startup_new_actions.rs:32:                        // Handle Cmd+K to toggle actions popup (works in ScriptList, FileSearchView, ArgPrompt)
src/app_impl/startup_new_actions.rs:87:                                AppView::ArgPrompt { .. } => {
src/app_impl/startup_new_actions.rs:89:                                    logging::log("KEY", "Interceptor: Cmd+K -> toggle_arg_actions (ArgPrompt)");
src/app_impl/startup_new_actions.rs:94:                                AppView::ChatPrompt { .. } => {
src/app_impl/startup_new_actions.rs:96:                                    logging::log("KEY", "Interceptor: Cmd+K -> toggle_chat_actions (ChatPrompt)");
src/app_impl/startup_new_actions.rs:202:                                AppView::ChatPrompt { .. } => Some(ActionsDialogHost::ChatPrompt),
src/app_impl/startup_new_actions.rs:203:                                AppView::ArgPrompt { .. } => Some(ActionsDialogHost::ArgPrompt),
src/app_impl/startup_new_actions.rs:204:                                AppView::DivPrompt { .. } => Some(ActionsDialogHost::DivPrompt),
src/app_impl/startup_new_actions.rs:205:                                AppView::EditorPrompt { .. } => Some(ActionsDialogHost::EditorPrompt),

thinking
**Evaluating prompt reuse to avoid enum changes**
exec
/bin/zsh -lc 'rg -n "ArgPrompt::new|AppView::ArgPrompt|choices: Vec<Choice>|Choice::new|PromptChoice|selected_index" src/app_execute src/app_impl src/prompts -S' in /Users/johnlindquist/dev/script-kit-gpui succeeded in 51ms:
src/app_execute/utility_views.rs:68:    //        selected_index: usize,
src/app_execute/utility_views.rs:88:    //    AppView::FileSearchView { query, selected_index } => {
src/app_execute/utility_views.rs:89:    //        self.render_file_search(query.clone(), *selected_index, cx)
src/app_execute/utility_views.rs:169:            selected_index: 0,
src/app_impl/filter_input_change.rs:29:                selected_index,
src/app_impl/filter_input_change.rs:31:                if Self::sync_builtin_query_state(filter, selected_index, &new_text) {
src/app_impl/filter_input_change.rs:46:                    .get(*selected_index)
src/app_impl/filter_input_change.rs:53:                selected_index,
src/app_impl/filter_input_change.rs:55:                if Self::sync_builtin_query_state(filter, selected_index, &new_text) {
src/app_impl/filter_input_change.rs:64:                selected_index,
src/app_impl/filter_input_change.rs:66:                if Self::sync_builtin_query_state(filter, selected_index, &new_text) {
src/app_impl/filter_input_change.rs:75:                selected_index,
src/app_impl/filter_input_change.rs:77:                if Self::sync_builtin_query_state(filter, selected_index, &new_text) {
src/app_impl/filter_input_change.rs:86:                selected_index,
src/app_impl/filter_input_change.rs:88:                if Self::sync_builtin_query_state(filter, selected_index, &new_text) {
src/app_impl/filter_input_change.rs:97:                selected_index,
src/app_impl/filter_input_change.rs:123:                    *selected_index = 0;
src/app_impl/filter_input_change.rs:238:                                                    // Reset selected_index when results finish loading
src/app_impl/filter_input_change.rs:240:                                                        selected_index,
src/app_impl/filter_input_change.rs:244:                                                        *selected_index = 0;

thinking
**Inspecting argument prompt structure**
exec
/bin/zsh -lc 'rg -n "pub enum AppView|enum AppView" src -S' in /Users/johnlindquist/dev/script-kit-gpui succeeded in 51ms:
src/main_sections/app_view_state.rs:3:enum AppView {
exec
/bin/zsh -lc "sed -n '1,340p' src/main_sections/app_view_state.rs" in /Users/johnlindquist/dev/script-kit-gpui succeeded in 51ms:
/// Application state - what view are we currently showing
#[derive(Debug, Clone)]
enum AppView {
    /// Showing the script list
    ScriptList,
    /// Showing the actions dialog (mini searchable popup)
    #[allow(dead_code)]
    ActionsDialog,
    /// Showing an arg prompt from a script
    ArgPrompt {
        id: String,
        placeholder: String,
        choices: Vec<Choice>,
        actions: Option<Vec<ProtocolAction>>,
    },
    /// Showing a div prompt from a script
    DivPrompt {
        #[allow(dead_code)]
        id: String,
        entity: Entity<DivPrompt>,

thinking
**Planning structured prompt components**
exec
/bin/zsh -lc 'rg -n "pub struct Choice|struct Choice" src -S | head' in /Users/johnlindquist/dev/script-kit-gpui succeeded in 52ms:
src/editor/part_000.rs:84:pub struct ChoicesPopupState {
src/protocol/types/primitives.rs:116:pub struct Choice {
src/prompts/select/types.rs:4:pub(super) struct ChoiceDisplayMetadata {
exec
/bin/zsh -lc "sed -n '90,230p' src/protocol/types/primitives.rs" in /Users/johnlindquist/dev/script-kit-gpui succeeded in 51ms:
        SubmitValue::Text(s.to_string())
    }
}

impl From<serde_json::Value> for SubmitValue {
    fn from(v: serde_json::Value) -> Self {
        // If it's a string JSON value, convert to Text for consistency
        if let serde_json::Value::String(s) = v {
            SubmitValue::Text(s)
        } else {
            SubmitValue::Json(v)
        }
    }
}

impl Default for SubmitValue {
    fn default() -> Self {
        SubmitValue::Text(String::new())
    }
}

thinking
**Identifying action type need**
exec
/bin/zsh -lc 'rg -n "pub struct ProtocolAction|enum ProtocolAction|type ProtocolAction" src/protocol src/actions -S' in /Users/johnlindquist/dev/script-kit-gpui succeeded in 51ms:
src/protocol/types/elements_actions_scriptlets.rs:129:pub struct ProtocolAction {
exec
/bin/zsh -lc "sed -n '100,260p' src/protocol/types/elements_actions_scriptlets.rs" in /Users/johnlindquist/dev/script-kit-gpui succeeded in 51ms:
            value: None,
            selected: None,
            focused: None,
            index: None,
        }
    }

    /// Create a new ElementInfo for a list element
    pub fn list(name: &str, item_count: usize) -> Self {
        ElementInfo {
            semantic_id: generate_semantic_id_named("list", name),
            element_type: ElementType::List,
            text: Some(format!("{} items", item_count)),
            value: None,
            selected: None,
            focused: None,
            index: None,
        }
    }
}

thinking
**Investigating argument prompt execution**
exec
/bin/zsh -lc "rg -n \"AppView::ArgPrompt \\{|toggle_arg_actions|arg_selected_index|submit_value|selected_choice|ActionTriggered|onAction|choices\\.get|enter\" src/app_impl src/main_entry src/render_prompts -S" in /Users/johnlindquist/dev/script-kit-gpuiexec
/bin/zsh -lc "sed -n '1,260p' src/render_prompts/arg.rs" in /Users/johnlindquist/dev/script-kit-gpui succeeded in 51ms:
src/render_prompts/editor.rs:40:        "enter" | "return" => Some("submit"),
src/render_prompts/editor.rs:141:                    this.toggle_arg_actions(cx, window);
src/render_prompts/editor.rs:302:                                this.toggle_arg_actions(cx, window);
src/render_prompts/editor.rs:371:    fn test_editor_footer_displays_cmd_enter_and_cmd_s_submit_hints() {
src/app_impl/startup_new_actions.rs:87:                                AppView::ArgPrompt { .. } => {
src/app_impl/startup_new_actions.rs:89:                                    logging::log("KEY", "Interceptor: Cmd+K -> toggle_arg_actions (ArgPrompt)");
src/app_impl/startup_new_actions.rs:90:                                    this.toggle_arg_actions(cx, window);
src/app_impl/startup_new_actions.rs:197:                            // This ensures enter, escape, backspace, and character keys are
src/app_impl/startup_new_actions.rs:203:                                AppView::ArgPrompt { .. } => Some(ActionsDialogHost::ArgPrompt),
src/app_impl/startup_new_actions.rs:262:                        if key == "enter" {
src/render_prompts/path.rs:291:                        "enter" | "return" => {
src/render_prompts/path.rs:308:                                    this.path_prompt_close_actions_popup(window, cx, "enter");
src/main_entry/runtime_stdin.rs:321:                                                "enter" => {
src/main_entry/runtime_stdin.rs:351:                                                "enter" => {
src/main_entry/runtime_stdin.rs:389:                                                    "enter" => path_prompt.handle_enter(path_cx),
src/main_entry/runtime_stdin.rs:400:                                    AppView::ArgPrompt { id, .. } => {
src/main_entry/runtime_stdin.rs:407:                                            view.toggle_arg_actions(ctx, window);
src/main_entry/runtime_stdin.rs:420:                                                    "enter" => {
src/main_entry/runtime_stdin.rs:452:                                                    if view.arg_selected_index > 0 {
src/main_entry/runtime_stdin.rs:453:                                                        view.arg_selected_index -= 1;
 succeeded in 51ms:
mod __render_prompts_arg_docs {
    //! Arg prompt rendering helpers and `ScriptListApp::render_arg_prompt` implementation.
    //! Key routines include prompt-footer/status helpers and `render_arg_input_text` for visual state.
    //! This fragment depends on `panel`, `components`, and actions-dialog flow and is included by `main.rs`.
}

// Arg prompt render method - extracted from render_prompts.rs
// This file is included via include!() macro in main.rs

include!("arg/helpers.rs");
include!("arg/render.rs");

#[cfg(test)]
include!("arg/tests.rs");

thinking
**Inspecting render argument behavior**
exec
/bin/zsh -lc "sed -n '120,290p' src/render_prompts/arg/render.rs" in /Users/johnlindquist/dev/script-kit-gpui succeeded in 51ms:
                if this.shortcut_recorder_state.is_some() {
                    return;
                }

                // Global shortcuts (Cmd+W, ESC for dismissable prompts)
                // Note: Escape when actions popup is open should close the popup, not dismiss prompt
                if !this.show_actions_popup
                    && this.handle_global_shortcut_with_options(event, true, cx)
                {
                    return;
                }

                let key = event.keystroke.key.as_str();
                let key_char = event.keystroke.key_char.as_deref();
                let has_cmd = event.keystroke.modifiers.platform;
                let modifiers = &event.keystroke.modifiers;

                // Check for Cmd+K to toggle actions popup (if actions are available)
                if has_cmd && ui_foundation::is_key_k(key) && has_actions_for_handler {
                    logging::log("KEY", "Cmd+K in ArgPrompt - calling toggle_arg_actions");

thinking
**Investigating argument submission method**
exec
/bin/zsh -lc 'rg -n "fn submit_arg_prompt_from_current_state|submit_arg_prompt|arg_prompt" src/app_impl src/render_prompts/arg -S' in /Users/johnlindquist/dev/script-kit-gpui succeeded in 51ms:
src/render_prompts/arg/helpers.rs:136:    fn arg_prompt_has_choices(&self) -> bool {
src/render_prompts/arg/helpers.rs:141:    fn sync_arg_prompt_after_text_change(
src/render_prompts/arg/helpers.rs:147:        let has_choices = self.arg_prompt_has_choices();
src/render_prompts/arg/helpers.rs:188:    fn submit_arg_prompt_from_current_state(&mut self, prompt_id: &str, cx: &mut Context<Self>) {
src/render_prompts/arg/helpers.rs:221:        self.sync_arg_prompt_after_text_change(prev_original_idx, window, cx);
src/render_prompts/arg/render_prompt.rs:1:    fn render_arg_prompt(
src/render_prompts/arg/render_prompt.rs:134:                    this.submit_arg_prompt_from_current_state(&prompt_id, cx);
src/render_prompts/arg/render_prompt.rs:160:                        this.sync_arg_prompt_after_text_change(prev_original_idx, window, cx);
src/render_prompts/arg/render_prompt.rs:246:            .key_context("arg_prompt")
src/render_prompts/arg/render_prompt.rs:356:                                this.submit_arg_prompt_from_current_state(
src/render_prompts/arg/render.rs:85:    fn render_arg_prompt(
src/render_prompts/arg/render.rs:218:                    this.submit_arg_prompt_from_current_state(&prompt_id, cx);
src/render_prompts/arg/render.rs:244:                        this.sync_arg_prompt_after_text_change(prev_original_idx, window, cx);
src/render_prompts/arg/render.rs:330:            .key_context("arg_prompt")
src/render_prompts/arg/render.rs:439:                                this.submit_arg_prompt_from_current_state(
src/render_prompts/arg/render.rs:506:mod arg_prompt_render_backdrop_tests {
exec
/bin/zsh -lc "sed -n '150,260p' src/render_prompts/arg/helpers.rs" in /Users/johnlindquist/dev/script-kit-gpui succeeded in 51ms:
            let new_idx = if let Some(prev_idx) = prev_original_idx {
                filtered
                    .iter()
                    .position(|(orig_idx, _)| *orig_idx == prev_idx)
                    .unwrap_or(0)
            } else {
                0
            };

            (new_idx, filtered.len())
        };

        self.arg_selected_index = new_selected_idx;

        // Defer resize through window_ops to avoid RefCell borrow conflicts during native callbacks.
        let (view_type, item_count) = if filtered_len == 0 {
            if has_choices {
                (ViewType::ArgPromptWithChoices, 0)
            } else {
                (ViewType::ArgPromptNoChoices, 0)

thinking
**Evaluating prompt submission handling**
exec
/bin/zsh -lc "rg -n \"fn submit_prompt_response\\(|submit_prompt_response\\(\" src -S" in /Users/johnlindquist/dev/script-kit-gpui succeeded in 51ms:
src/render_prompts/editor.rs:287:                                    this.submit_prompt_response(
src/render_prompts/arg/helpers.rs:191:                self.submit_prompt_response(prompt_id.to_string(), Some(value), cx);
src/app_impl/prompt_ai.rs:215:    pub(crate) fn submit_prompt_response(
src/render_prompts/div.rs:187:                                this.submit_prompt_response(id, None, cx);
src/render_prompts/form/render.rs:129:                        this.submit_prompt_response(prompt_id_for_key.clone(), Some(values), cx);
src/prompt_handler/part_001.rs:1108:                    self.submit_prompt_response(id, Some(value_str), cx);
src/prompt_handler/part_001_arms/arms_003.rs:67:                    self.submit_prompt_response(id, Some(value_str), cx);
src/main_entry/runtime_stdin.rs:471:                                                        view.submit_prompt_response(prompt_id, Some(value), ctx);
src/main_entry/runtime_stdin.rs:474:                                                        view.submit_prompt_response(prompt_id, Some(value), ctx);
src/main_entry/runtime_stdin.rs:479:                                                    view.submit_prompt_response(prompt_id, None, ctx);
src/main_entry/runtime_stdin.rs:553:                                            view.submit_prompt_response(prompt_id_clone.clone(), Some(content), ctx);
src/main_entry/runtime_stdin.rs:556:                                            view.submit_prompt_response(prompt_id_clone.clone(), None, ctx);
src/main_entry/runtime_stdin_match_simulate_key.rs:192:                                                        view.submit_prompt_response(prompt_id, Some(value), ctx);
src/main_entry/runtime_stdin_match_simulate_key.rs:195:                                                        view.submit_prompt_response(prompt_id, Some(value), ctx);
src/main_entry/runtime_stdin_match_simulate_key.rs:200:                                                    view.submit_prompt_response(prompt_id, None, ctx);
src/main_entry/runtime_stdin_match_simulate_key.rs:274:                                            view.submit_prompt_response(prompt_id_clone.clone(), Some(content), ctx);
src/main_entry/runtime_stdin_match_simulate_key.rs:277:                                            view.submit_prompt_response(prompt_id_clone.clone(), None, ctx);
src/main_entry/app_run_setup.rs:1673:                                                        view.submit_prompt_response(prompt_id, Some(value), ctx);
src/main_entry/app_run_setup.rs:1676:                                                        view.submit_prompt_response(prompt_id, Some(value), ctx);
src/main_entry/app_run_setup.rs:1681:                                                    view.submit_prompt_response(prompt_id, None, ctx);
exec
/bin/zsh -lc "sed -n '180,320p' src/app_impl/prompt_ai.rs" in /Users/johnlindquist/dev/script-kit-gpui succeeded in 51ms:
    })?;

    crate::script_creation::open_in_editor(&script_path, config).with_context(|| {
        format!(
            "state={} attempted=open_in_editor path={} failure=open_editor_failed",
            AiScriptGenerationStage::OpenEditor.as_str(),
            script_path.display()
        )
    })?;

    Ok(script_path)
}

impl ScriptListApp {
    pub(crate) fn is_in_prompt(&self) -> bool {
        matches!(
            self.current_view,
            AppView::ArgPrompt { .. }
                | AppView::DivPrompt { .. }
                | AppView::FormPrompt { .. }

thinking
**Scoping built-in prompt handling**
exec
/bin/zsh -lc "sed -n '500,1080p' src/app_execute/builtin_execution.rs" in /Users/johnlindquist/dev/script-kit-gpui succeeded in 51ms:
            }

            // NOTE: Window Actions removed - now handled by window-management extension
            // SDK tileWindow() still works via protocol messages in execute_script.rs

            // =========================================================================
            // Notes Commands
            // =========================================================================

            builtins::BuiltInFeature::NotesCommand(cmd_type) => {
                logging::log("EXEC", &format!("Executing notes command: {:?}", cmd_type));

                use builtins::NotesCommandType;

                // All notes commands: reset state, hide main window, open notes
                script_kit_gpui::set_main_window_visible(false);
                self.reset_to_script_list(cx);
                platform::hide_main_window();

                let result = match cmd_type {

thinking
**Assessing key handling for quicklinks**
exec
/bin/zsh -lc "sed -n '1,440p' src/app_impl/selection_fallback.rs" in /Users/johnlindquist/dev/script-kit-gpui succeeded in 51ms:
use super::*;

fn resolve_grouped_result_index(
    grouped_items: &[GroupedListItem],
    selected_index: usize,
) -> Option<(usize, usize)> {
    let coerced_index = crate::list_item::coerce_selection(grouped_items, selected_index)?;
    match grouped_items.get(coerced_index) {
        Some(GroupedListItem::Item(result_idx)) => Some((coerced_index, *result_idx)),
        _ => None,
    }
}

impl ScriptListApp {
    #[allow(dead_code)]
    pub(crate) fn filtered_scripts(&self) -> Vec<Arc<scripts::Script>> {
        let filter_text = self.filter_text();
        if filter_text.is_empty() {
            self.scripts.clone()
        } else {

thinking
**Evaluating quicklinks integration options**
exec
/bin/zsh -lc "rg -n \"fn trigger_action_by_name|trigger_action_by_name\\(\" src -S" in /Users/johnlindquist/dev/script-kit-gpui succeeded in 51ms:
src/app_actions/sdk_actions.rs:79:    fn trigger_action_by_name(&mut self, action_name: &str, cx: &mut Context<Self>) -> bool {
src/main_entry/runtime_stdin.rs:432:                                                            view.trigger_action_by_name(&action_id, ctx);
src/main_entry/runtime_stdin_match_simulate_key.rs:153:                                                            view.trigger_action_by_name(&action_id, ctx);
src/main_entry/app_run_setup.rs:1634:                                                            view.trigger_action_by_name(&action_id, ctx);
src/render_script_list/part_000.rs:532:                        if this.trigger_action_by_name(&action_name, cx) {
src/render_script_list/part_000_body/body_001.rs:63:                        if this.trigger_action_by_name(&action_name, cx) {
src/app_impl/startup_new_actions.rs:232:                                                this.trigger_action_by_name(&action_id, cx);
src/render_prompts/editor.rs:157:                        this.trigger_action_by_name(&action_id, cx);
src/render_prompts/editor.rs:193:                    this.trigger_action_by_name(&action_name, cx);
src/render_prompts/arg/render_prompt.rs:70:                        this.trigger_action_by_name(&action_id, cx);
src/render_prompts/arg/render_prompt.rs:91:                    this.trigger_action_by_name(&action_name, cx);
src/render_prompts/arg/render.rs:154:                        this.trigger_action_by_name(&action_id, cx);
src/render_prompts/arg/render.rs:175:                    this.trigger_action_by_name(&action_name, cx);
src/render_prompts/div.rs:79:                        this.trigger_action_by_name(&action_id, cx);
src/render_prompts/div.rs:102:                            this.trigger_action_by_name(&action_name, cx);
src/render_prompts/term.rs:220:                        if this.trigger_action_by_name(&action_id, cx) {
src/render_prompts/term.rs:258:                    this.trigger_action_by_name(&action_name, cx);
src/app_impl/startup.rs:1351:                                                this.trigger_action_by_name(&action_id, cx);
src/render_prompts/form/render.rs:84:                        this.trigger_action_by_name(&action_id, cx);
src/render_prompts/form/render.rs:105:                    this.trigger_action_by_name(&action_name, cx);
exec
/bin/zsh -lc "sed -n '1,260p' src/app_actions/sdk_actions.rs" in /Users/johnlindquist/dev/script-kit-gpui succeeded in 52ms:
impl ScriptListApp {
    fn trigger_sdk_action_internal(&mut self, action_name: &str) {
        if let Some(ref actions) = self.sdk_actions {
            if let Some(action) = actions.iter().find(|a| a.name == action_name) {
                let send_result = if action.has_action {
                    logging::log(
                        "ACTIONS",
                        &format!(
                            "SDK action with handler: '{}' (has_action=true), sending ActionTriggered",
                            action_name
                        ),
                    );
                    if let Some(ref sender) = self.response_sender {
                        let msg = protocol::Message::action_triggered(
                            action_name.to_string(),
                            action.value.clone(),
                            self.arg_input.text().to_string(),
                        );
                        Some(sender.try_send(msg))
                    } else {

thinking
**Exploring quicklinks UI integration**
exec
/bin/zsh -lc 'rg -n "response_sender|builtin_confirm_sender|api_key_completion|inline_chat" src/main_sections src/app_impl/startup*.rs src/main.rs -S' in /Users/johnlindquist/dev/script-kit-gpui succeeded in 51ms:
src/app_impl/startup_new_state.rs:11:        let (inline_chat_escape_tx, inline_chat_escape_rx) = mpsc::sync_channel(4);
src/app_impl/startup_new_state.rs:13:        let (inline_chat_configure_tx, inline_chat_configure_rx) = mpsc::sync_channel(4);
src/app_impl/startup_new_state.rs:15:        let (inline_chat_claude_code_tx, inline_chat_claude_code_rx) = mpsc::sync_channel(4);
src/app_impl/startup_new_state.rs:49:            response_sender: None,
src/app_impl/startup_new_state.rs:166:            builtin_confirm_sender: builtin_confirm_tx,
src/app_impl/startup_new_state.rs:190:            api_key_completion_sender: api_key_tx,
src/app_impl/startup_new_state.rs:191:            api_key_completion_receiver: api_key_rx,
src/app_impl/startup_new_state.rs:195:            inline_chat_escape_sender: inline_chat_escape_tx,
src/app_impl/startup_new_state.rs:196:            inline_chat_escape_receiver: inline_chat_escape_rx,
src/app_impl/startup_new_state.rs:198:            inline_chat_configure_sender: inline_chat_configure_tx,
src/app_impl/startup_new_state.rs:199:            inline_chat_configure_receiver: inline_chat_configure_rx,
src/app_impl/startup_new_state.rs:201:            inline_chat_claude_code_sender: inline_chat_claude_code_tx,
src/app_impl/startup_new_state.rs:202:            inline_chat_claude_code_receiver: inline_chat_claude_code_rx,
src/app_impl/startup.rs:297:        let (inline_chat_escape_tx, inline_chat_escape_rx) = mpsc::sync_channel(4);
src/app_impl/startup.rs:299:        let (inline_chat_configure_tx, inline_chat_configure_rx) = mpsc::sync_channel(4);
src/app_impl/startup.rs:301:        let (inline_chat_claude_code_tx, inline_chat_claude_code_rx) = mpsc::sync_channel(4);
src/app_impl/startup.rs:335:            response_sender: None,
src/app_impl/startup.rs:452:            builtin_confirm_sender: builtin_confirm_tx,
src/app_impl/startup.rs:476:            api_key_completion_sender: api_key_tx,
src/app_impl/startup.rs:477:            api_key_completion_receiver: api_key_rx,

thinking
**Considering native dialog UI for quicklinks**
exec
/bin/zsh -lc 'rg -n "rfd::|tinyfiledialogs|native_dialog|dialog" src -S | head -n 80' in /Users/johnlindquist/dev/script-kit-gpui succeeded in 50ms:
src/menu_bar_tests.rs:36:    // Menu items that open dialogs often have ellipsis
src/app_actions/handle_action.rs:236:    /// Handle action selection from the actions dialog
src/app_actions/handle_action.rs:1120:                                    "Failed to open confirmation dialog".to_string(),
src/app_actions/handle_action.rs:1241:                logging::log("UI", "Actions dialog cancelled");
src/app_actions/handle_action.rs:1662:                                    "Failed to open confirmation dialog".to_string(),
src/app_actions/handle_action.rs:1853:                                    "Failed to open confirmation dialog".to_string(),
src/app_actions/handle_action.rs:2426:                // The actions dialog is already closed by setting current_view = AppView::ScriptList
src/app_actions/handle_action/main_actions_06.rs:160:                // The actions dialog is already closed by setting current_view = AppView::ScriptList
src/app_actions/handle_action/main_actions_02.rs:216:                                    "Failed to open confirmation dialog".to_string(),
src/app_actions/handle_action/main_actions_02.rs:337:                logging::log("UI", "Actions dialog cancelled");
src/builtins/part_001_entries/entries_000.rs:97:            "Open the confirmation dialog test tool (dev only)",
src/app_actions/handle_action/main_actions_04.rs:88:                                    "Failed to open confirmation dialog".to_string(),
src/app_actions/handle_action/main_actions_04.rs:279:                                    "Failed to open confirmation dialog".to_string(),
src/app_actions/helpers.rs:61:    matches!(current_view, AppView::ScriptList | AppView::ActionsDialog)
src/app_actions/helpers.rs:303:            &AppView::ActionsDialog
src/notification/mod.rs:4://! (toast, HUD, system notifications, dialogs) with consistent behavior.
src/notification/service.rs:180:            NotificationChannel::Dialog => {
src/notification/service.rs:181:                tracing::debug!("Routing to Dialog renderer");
src/notification/service.rs:182:                // Future: blocking dialog implementation
src/ui_foundation/part_000.rs:244:    /// Dialog/popup opacity

thinking
**Identifying use of AppleScript via osascript**
exec
/bin/zsh -lc 'rg -n "osascript|choose from list|display dialog|System Events|tell application" src -S' in /Users/johnlindquist/dev/script-kit-gpui succeeded in 52ms:
src/app_actions/helpers.rs:134:            r#"tell application "Finder"
src/app_actions/helpers.rs:140:        let status = std::process::Command::new("osascript")
src/app_actions/helpers.rs:143:            .map_err(|err| format!("failed to launch osascript: {err}"))?;
src/app_actions/helpers.rs:148:            Err(format!("osascript exited with status {}", status))
src/main_sections/fallbacks.rs:45:                            r#"tell application "Terminal"
src/main_sections/fallbacks.rs:51:                        match std::process::Command::new("osascript")
src/file_search/part_002.rs:23:            r#"tell application "Terminal"
src/file_search/part_002.rs:30:        Command::new("osascript")
src/file_search/part_002.rs:52:            r#"tell application "Finder"
src/file_search/part_002.rs:58:        let mut child = Command::new("osascript")
src/file_search/part_002.rs:108:            r#"tell application "Finder"
src/file_search/part_002.rs:115:        Command::new("osascript")
src/file_search/part_002.rs:137:            r#"tell application "Finder"
src/file_search/part_002.rs:144:        Command::new("osascript")
src/system_actions/part_000.rs:12:    let output = Command::new("osascript")
src/system_actions/part_000.rs:32:    let output = Command::new("osascript")
src/system_actions/part_000.rs:63:    run_applescript(r#"tell application "Finder" to empty trash"#)
src/system_actions/part_000.rs:76:        r#"tell application "System Events" to keystroke "q" using {command down, control down}"#,
src/system_actions/part_000.rs:84:    run_applescript(r#"tell application "System Events" to sleep"#)
src/system_actions/part_000.rs:91:    run_applescript(r#"tell application "System Events" to restart"#)

thinking
**Considering macOS UI integration**
exec
/bin/zsh -lc "sed -n '1,220p' src/file_search/part_002.rs" in /Users/johnlindquist/dev/script-kit-gpui succeeded in 51ms:
fn terminal_working_directory(path: &str, is_dir: bool) -> String {
    if is_dir {
        path.to_string()
    } else {
        std::path::Path::new(path)
            .parent()
            .map(|p| p.to_string_lossy().to_string())
            .unwrap_or_else(|| path.to_string())
    }
}
/// Open a terminal window at the target path.
///
/// Returns the resolved working directory used to launch the terminal.
pub fn open_in_terminal(path: &str, is_dir: bool) -> Result<String, String> {
    let dir_path = terminal_working_directory(path, is_dir);

    #[cfg(target_os = "macos")]
    {
        use std::process::Command;


thinking
**Exploring quicklinks UI integration**
exec
/bin/zsh -lc "rg -n \"fn escape_applescript_string|escape_applescript_string\\(\" src -S" in /Users/johnlindquist/dev/script-kit-gpui succeeded in 50ms:
src/app_actions/helpers.rs:132:        let escaped_path = crate::utils::escape_applescript_string(&path.to_string_lossy());
src/file_search/part_002.rs:21:        let escaped_dir_path = crate::utils::escape_applescript_string(&dir_path);
src/file_search/part_002.rs:50:        let escaped_path = crate::utils::escape_applescript_string(path);
src/file_search/part_002.rs:113:            crate::utils::escape_applescript_string(path)
src/file_search/part_002.rs:142:            crate::utils::escape_applescript_string(path)
src/utils/applescript.rs:7:pub fn escape_applescript_string(input: &str) -> String {
src/utils/applescript.rs:18:        let escaped = escape_applescript_string(input);
src/utils/applescript.rs:25:        let escaped = escape_applescript_string(input);
exec
/bin/zsh -lc "sed -n '1,120p' src/utils/applescript.rs" in /Users/johnlindquist/dev/script-kit-gpui succeeded in 51ms:
//! Utilities for constructing AppleScript string literals safely.

/// Escape characters that terminate or mutate AppleScript string literals.
///
/// AppleScript uses double-quoted strings; backslashes and double quotes must
/// be escaped before interpolating untrusted values.
pub fn escape_applescript_string(input: &str) -> String {
    input.replace('\\', "\\\\").replace('"', "\\\"")
}

#[cfg(test)]
mod tests {
    use super::escape_applescript_string;

    #[test]
    fn test_escape_applescript_string_escapes_double_quote_and_backslash() {
        let input = r#"folder "with"\slashes"#;
        let escaped = escape_applescript_string(input);
        assert_eq!(escaped, r#"folder \"with\"\\slashes"#);
    }

thinking
**Planning quicklinks integration**
exec
/bin/zsh -lc "sed -n '1,120p' src/app_execute/builtin_execution.rs" in /Users/johnlindquist/dev/script-kit-gpui succeeded in 51ms:
fn ai_open_failure_message(error: impl std::fmt::Display) -> String {
    format!("Failed to open AI: {}", error)
}

impl ScriptListApp {
    fn system_action_feedback_message(
        &self,
        action_type: &builtins::SystemActionType,
    ) -> Option<String> {
        let dark_mode_enabled = if matches!(action_type, builtins::SystemActionType::ToggleDarkMode)
        {
            system_actions::is_dark_mode().ok()
        } else {
            None
        };

        builtins::system_action_hud_message(*action_type, dark_mode_enabled)
    }

    fn execute_builtin(&mut self, entry: &builtins::BuiltInEntry, cx: &mut Context<Self>) {

thinking
**Inspecting builtins tests impact**
exec
/bin/zsh -lc "sed -n '1,260p' src/builtins/tests/part_000.rs" in /Users/johnlindquist/dev/script-kit-gpuiexec
/bin/zsh -lc "sed -n '1,320p' src/builtins/tests/part_001.rs" in /Users/johnlindquist/dev/script-kit-gpui succeeded in 50ms:
    use super::*;
    use crate::config::BuiltInConfig;
    #[test]
    fn test_builtin_config_default() {
        let config = BuiltInConfig::default();
        assert!(config.clipboard_history);
        assert!(config.app_launcher);
        assert!(config.window_switcher);
    }
    #[test]
    fn test_builtin_config_custom() {
        let config = BuiltInConfig {
            clipboard_history: false,
            app_launcher: true,
            window_switcher: false,
        };
        assert!(!config.clipboard_history);
        assert!(config.app_launcher);
        assert!(!config.window_switcher);
    }
 succeeded in 52ms:
    // NOTE: test_builtin_feature_window_action removed - WindowAction no longer in BuiltInFeature

    #[test]
    fn test_file_search_builtin_exists() {
        let config = BuiltInConfig::default();
        let entries = get_builtin_entries(&config);

        // Check that FileSearch entry exists
        let file_search = entries.iter().find(|e| e.id == "builtin-file-search");
        assert!(
            file_search.is_some(),
            "FileSearch builtin should exist in the main menu"
        );

        let file_search = file_search.unwrap();
        assert_eq!(file_search.name, "Search Files");
        assert_eq!(file_search.feature, BuiltInFeature::FileSearch);
        assert!(file_search.keywords.contains(&"file".to_string()));
        assert!(file_search.keywords.contains(&"search".to_string()));
        assert!(file_search.keywords.contains(&"find".to_string()));

thinking
**Planning quicklinks builtin design**
codex
I have enough context and Iâ€™m moving to implementation. Iâ€™ll claim `src/builtins/part_000.rs`, one `entries_*.rs` file for the built-in entry, `src/app_execute/builtin_execution.rs`, and `src/quicklinks/mod.rs`, then wire a quicklinks management flow with add/edit/delete/open and targeted tests.
exec
/bin/zsh -lc '~/.claude/bin/swarm.ts claim --wait --id codex-wire-quicklinks src/builtins/part_001_entries/entries_000.rs' in /Users/johnlindquist/dev/script-kit-gpui succeeded in 51ms:
Claimed for codex-wire-quicklinks: src/builtins/part_001_entries/entries_000.rs
exec
/bin/zsh -lc '~/.claude/bin/swarm.ts claim --wait --id codex-wire-quicklinks src/builtins/part_000.rs' in /Users/johnlindquist/dev/script-kit-gpuiexec
/bin/zsh -lc '~/.claude/bin/swarm.ts claim --wait --id codex-wire-quicklinks src/quicklinks/mod.rs' in /Users/johnlindquist/dev/script-kit-gpuiexec
/bin/zsh -lc '~/.claude/bin/swarm.ts claim --wait --id codex-wire-quicklinks src/app_execute/builtin_execution.rs' in /Users/johnlindquist/dev/script-kit-gpui succeeded in 51ms:
Claimed for codex-wire-quicklinks: src/quicklinks/mod.rs

thinking
**Monitoring session claim status**
codex
Two file claims are still waiting, likely because another agent currently holds them. Iâ€™m polling those claim sessions and will proceed as soon as theyâ€™re released.

thinking
**Checking claim and status commands**
exec
/bin/zsh -lc '~/.claude/bin/swarm.ts status' in /Users/johnlindquist/dev/script-kit-gpui succeeded in 50ms:
Repo: /Users/johnlindquist/dev/script-kit-gpui
Updated: 2026-02-08T03:01:15.939Z

Active agents (3):
codex-wire-clipboard-exclusions [in_progress] codex/gpt-5.3-codex/exec
  task: Wire up the existing clipboard password manager exclusion list (src/clipboard_history/exclusions.rs) into the actual clâ€¦
  scope: src/clipboard_history/**
  claims(2): src/clipboard_history/monitor.rs, src/clipboard_history/mod.rs
  notes: Claimed monitor/mod; wiring exclusion check before clipboard add_entry calls

codex-wire-favorites [in_progress] codex/gpt-5.3-codex/exec
  task: Wire up the existing src/favorites/mod.rs storage module into the app as a working feature. The module already has loadâ€¦
  scope: src/favorites/**,src/builtins/part_000.rs,src/builtins/part_001_entries/**,src/app_execute/builtin_execution.rs,src/actâ€¦
  claims(4): src/builtins/part_000.rs, src/builtins/part_001_entries/entries_003.rs, src/app_execute/builtin_execution.rs, src/actions/builders/script_context.rs
  notes: Claimed builtins/builtin_execution/script_context; implementing favorites builtin + toggle action wiring | [claim-wait] codex-wire-quicklinks waiting for src/builtins/part_000.rs

codex-wire-quicklinks [in_progress] codex/gpt-5.3-codex/exec
  task: Wire up the existing src/quicklinks/mod.rs storage module into the app as a working built-in feature. The module alreadâ€¦
  scope: src/quicklinks/**,src/builtins/part_000.rs,src/builtins/part_001_entries/**,src/app_execute/builtin_execution.rs
  claims(2): src/builtins/part_001_entries/entries_000.rs, src/quicklinks/mod.rs

thinking
**Updating swarm status to blocked**
exec
/bin/zsh -lc '~/.claude/bin/swarm.ts update --id codex-wire-quicklinks --status blocked --notes "Waiting on claims for src/builtins/part_000.rs and src/app_execute/builtin_execution.rs (held by codex-wire-favorites)"' in /Users/johnlindquist/dev/script-kit-gpui succeeded in 51ms:
Updated: codex-wire-quicklinks

thinking
**Adding quicklink update helpers**
codex
Iâ€™m using the claimed `src/quicklinks/mod.rs` first: adding a small update API and pure helper(s) with tests so builtin execution can implement edit/open behavior cleanly without duplicating file mutation logic.
file update
M /Users/johnlindquist/dev/script-kit-gpui/src/quicklinks/mod.rs
@@ -45,2 +45,10 @@
 
+pub fn has_query_placeholder(url_template: &str) -> bool {
+    url_template.contains(QUERY_PLACEHOLDER)
+}
+
+pub fn update_quicklink(id: &str, name: &str, url_template: &str) -> bool {
+    update_quicklink_from_path(id, name, url_template, &quicklinks_path())
+}
+
 fn quicklinks_path() -> PathBuf {
@@ -77,2 +85,13 @@
 
+fn update_quicklink_from_path(id: &str, name: &str, url_template: &str, path: &Path) -> bool {
+    let mut links = load_quicklinks_from_path(path);
+    if let Some(link) = links.iter_mut().find(|link| link.id == id) {
+        link.name = name.trim().to_string();
+        link.url_template = url_template.trim().to_string();
+        return save_quicklinks_to_path(&links, path).is_ok();
+    }
+
+    false
+}
+
 #[cfg(test)]
@@ -80,4 +99,4 @@
     use super::{
-        create_quicklink, delete_quicklink_from_path, expand_url, load_quicklinks_from_path,
-        save_quicklinks_to_path, Quicklink,
+        create_quicklink, delete_quicklink_from_path, expand_url, has_query_placeholder,
+        load_quicklinks_from_path, save_quicklinks_to_path, update_quicklink_from_path, Quicklink,
     };
@@ -107,2 +126,12 @@
     #[test]
+    fn test_has_query_placeholder_returns_true_when_template_contains_placeholder() {
+        assert!(has_query_placeholder("https://example.com?q={query}"));
+    }
+
+    #[test]
+    fn test_has_query_placeholder_returns_false_when_template_missing_placeholder() {
+        assert!(!has_query_placeholder("https://example.com"));
+    }
+
+    #[test]
     fn test_load_quicklinks_from_path_returns_empty_when_file_missing() {
@@ -176,2 +205,47 @@
     }
+
+    #[test]
+    fn test_update_quicklink_from_path_updates_name_and_url_template() {
+        let dir = tempfile::tempdir().expect("create temp dir");
+        let path = dir.path().join("quicklinks.json");
+        let links = vec![Quicklink {
+            id: "target".to_string(),
+            name: "Old".to_string(),
+            url_template: "https://old.example.com".to_string(),
+            icon: None,
+        }];
+
+        save_quicklinks_to_path(&links, &path).expect("seed quicklinks");
+        let updated = update_quicklink_from_path(
+            "target",
+            " New Name ",
+            " https://new.example.com?q={query} ",
+            &path,
+        );
+
+        assert!(updated);
+        let loaded = load_quicklinks_from_path(&path);
+        assert_eq!(loaded.len(), 1);
+        assert_eq!(loaded[0].name, "New Name");
+        assert_eq!(loaded[0].url_template, "https://new.example.com?q={query}");
+    }
+
+    #[test]
+    fn test_update_quicklink_from_path_returns_false_when_id_not_found() {
+        let dir = tempfile::tempdir().expect("create temp dir");
+        let path = dir.path().join("quicklinks.json");
+        let links = vec![Quicklink {
+            id: "target".to_string(),
+            name: "Keep".to_string(),
+            url_template: "https://example.com".to_string(),
+            icon: None,
+        }];
+
+        save_quicklinks_to_path(&links, &path).expect("seed quicklinks");
+        let updated = update_quicklink_from_path("missing", "Name", "https://updated.example.com", &path);
+
+        assert!(!updated);
+        let loaded = load_quicklinks_from_path(&path);
+        assert_eq!(loaded, links);
+    }
 }
apply_patch(auto_approved=true) exited 0 in 11ms:
Success. Updated the following files:
M /Users/johnlindquist/dev/script-kit-gpui/src/quicklinks/mod.rs
file update:
diff --git a/src/quicklinks/mod.rs b/src/quicklinks/mod.rs
index 08aeea02e216c8026f59f0d8fe5627ededb1dec0..e9e055c95e2b0cd21fbc8b79971df226a788899c
--- a/src/quicklinks/mod.rs
+++ b/src/quicklinks/mod.rs
@@ -43,6 +43,14 @@
     url_template.replace(QUERY_PLACEHOLDER, query)
 }
 
+pub fn has_query_placeholder(url_template: &str) -> bool {
+    url_template.contains(QUERY_PLACEHOLDER)
+}
+
+pub fn update_quicklink(id: &str, name: &str, url_template: &str) -> bool {
+    update_quicklink_from_path(id, name, url_template, &quicklinks_path())
+}
+
 fn quicklinks_path() -> PathBuf {
     dirs::home_dir()
         .map(|home| home.join(".scriptkit").join(QUICKLINKS_FILE))
@@ -75,11 +83,22 @@
     let _ = save_quicklinks_to_path(&links, path);
 }
 
+fn update_quicklink_from_path(id: &str, name: &str, url_template: &str, path: &Path) -> bool {
+    let mut links = load_quicklinks_from_path(path);
+    if let Some(link) = links.iter_mut().find(|link| link.id == id) {
+        link.name = name.trim().to_string();
+        link.url_template = url_template.trim().to_string();
+        return save_quicklinks_to_path(&links, path).is_ok();
+    }
+
+    false
+}
+
 #[cfg(test)]
 mod tests {
     use super::{
-        create_quicklink, delete_quicklink_from_path, expand_url, load_quicklinks_from_path,
-        save_quicklinks_to_path, Quicklink,
+        create_quicklink, delete_quicklink_from_path, expand_url, has_query_placeholder,
+        load_quicklinks_from_path, save_quicklinks_to_path, update_quicklink_from_path, Quicklink,
     };
 
     #[test]
@@ -105,6 +124,16 @@
     }
 
     #[test]
+    fn test_has_query_placeholder_returns_true_when_template_contains_placeholder() {
+        assert!(has_query_placeholder("https://example.com?q={query}"));
+    }
+
+    #[test]
+    fn test_has_query_placeholder_returns_false_when_template_missing_placeholder() {
+        assert!(!has_query_placeholder("https://example.com"));
+    }
+
+    #[test]
     fn test_load_quicklinks_from_path_returns_empty_when_file_missing() {
         let dir = tempfile::tempdir().expect("create temp dir");
         let path = dir.path().join("quicklinks.json");
@@ -174,4 +203,49 @@
         assert_eq!(loaded.len(), 1);
         assert_eq!(loaded[0].id, "keep");
     }
+
+    #[test]
+    fn test_update_quicklink_from_path_updates_name_and_url_template() {
+        let dir = tempfile::tempdir().expect("create temp dir");
+        let path = dir.path().join("quicklinks.json");
+        let links = vec![Quicklink {
+            id: "target".to_string(),
+            name: "Old".to_string(),
+            url_template: "https://old.example.com".to_string(),
+            icon: None,
+        }];
+
+        save_quicklinks_to_path(&links, &path).expect("seed quicklinks");
+        let updated = update_quicklink_from_path(
+            "target",
+            " New Name ",
+            " https://new.example.com?q={query} ",
+            &path,
+        );
+
+        assert!(updated);
+        let loaded = load_quicklinks_from_path(&path);
+        assert_eq!(loaded.len(), 1);
+        assert_eq!(loaded[0].name, "New Name");
+        assert_eq!(loaded[0].url_template, "https://new.example.com?q={query}");
+    }
+
+    #[test]
+    fn test_update_quicklink_from_path_returns_false_when_id_not_found() {
+        let dir = tempfile::tempdir().expect("create temp dir");
+        let path = dir.path().join("quicklinks.json");
+        let links = vec![Quicklink {
+            id: "target".to_string(),
+            name: "Keep".to_string(),
+            url_template: "https://example.com".to_string(),
+            icon: None,
+        }];
+
+        save_quicklinks_to_path(&links, &path).expect("seed quicklinks");
+        let updated = update_quicklink_from_path("missing", "Name", "https://updated.example.com", &path);
+
+        assert!(!updated);
+        let loaded = load_quicklinks_from_path(&path);
+        assert_eq!(loaded, links);
+    }
 }

file update:
diff --git a/src/quicklinks/mod.rs b/src/quicklinks/mod.rs
index 08aeea02e216c8026f59f0d8fe5627ededb1dec0..e9e055c95e2b0cd21fbc8b79971df226a788899c
--- a/src/quicklinks/mod.rs
+++ b/src/quicklinks/mod.rs
@@ -43,6 +43,14 @@
     url_template.replace(QUERY_PLACEHOLDER, query)
 }
 
+pub fn has_query_placeholder(url_template: &str) -> bool {
+    url_template.contains(QUERY_PLACEHOLDER)
+}
+
+pub fn update_quicklink(id: &str, name: &str, url_template: &str) -> bool {
+    update_quicklink_from_path(id, name, url_template, &quicklinks_path())
+}
+
 fn quicklinks_path() -> PathBuf {
     dirs::home_dir()
         .map(|home| home.join(".scriptkit").join(QUICKLINKS_FILE))
@@ -75,11 +83,22 @@
     let _ = save_quicklinks_to_path(&links, path);
 }
 
+fn update_quicklink_from_path(id: &str, name: &str, url_template: &str, path: &Path) -> bool {
+    let mut links = load_quicklinks_from_path(path);
+    if let Some(link) = links.iter_mut().find(|link| link.id == id) {
+        link.name = name.trim().to_string();
+        link.url_template = url_template.trim().to_string();
+        return save_quicklinks_to_path(&links, path).is_ok();
+    }
+
+    false
+}
+
 #[cfg(test)]
 mod tests {
     use super::{
-        create_quicklink, delete_quicklink_from_path, expand_url, load_quicklinks_from_path,
-        save_quicklinks_to_path, Quicklink,
+        create_quicklink, delete_quicklink_from_path, expand_url, has_query_placeholder,
+        load_quicklinks_from_path, save_quicklinks_to_path, update_quicklink_from_path, Quicklink,
     };
 
     #[test]
@@ -105,6 +124,16 @@
     }
 
     #[test]
+    fn test_has_query_placeholder_returns_true_when_template_contains_placeholder() {
+        assert!(has_query_placeholder("https://example.com?q={query}"));
+    }
+
+    #[test]
+    fn test_has_query_placeholder_returns_false_when_template_missing_placeholder() {
+        assert!(!has_query_placeholder("https://example.com"));
+    }
+
+    #[test]
     fn test_load_quicklinks_from_path_returns_empty_when_file_missing() {
         let dir = tempfile::tempdir().expect("create temp dir");
         let path = dir.path().join("quicklinks.json");
@@ -174,4 +203,49 @@
         assert_eq!(loaded.len(), 1);
         assert_eq!(loaded[0].id, "keep");
     }
+
+    #[test]
+    fn test_update_quicklink_from_path_updates_name_and_url_template() {
+        let dir = tempfile::tempdir().expect("create temp dir");
+        let path = dir.path().join("quicklinks.json");
+        let links = vec![Quicklink {
+            id: "target".to_string(),
+            name: "Old".to_string(),
+            url_template: "https://old.example.com".to_string(),
+            icon: None,
+        }];
+
+        save_quicklinks_to_path(&links, &path).expect("seed quicklinks");
+        let updated = update_quicklink_from_path(
+            "target",
+            " New Name ",
+            " https://new.example.com?q={query} ",
+            &path,
+        );
+
+        assert!(updated);
+        let loaded = load_quicklinks_from_path(&path);
+        assert_eq!(loaded.len(), 1);
+        assert_eq!(loaded[0].name, "New Name");
+        assert_eq!(loaded[0].url_template, "https://new.example.com?q={query}");
+    }
+
+    #[test]
+    fn test_update_quicklink_from_path_returns_false_when_id_not_found() {
+        let dir = tempfile::tempdir().expect("create temp dir");
+        let path = dir.path().join("quicklinks.json");
+        let links = vec![Quicklink {
+            id: "target".to_string(),
+            name: "Keep".to_string(),
+            url_template: "https://example.com".to_string(),
+            icon: None,
+        }];
+
+        save_quicklinks_to_path(&links, &path).expect("seed quicklinks");
+        let updated = update_quicklink_from_path("missing", "Name", "https://updated.example.com", &path);
+
+        assert!(!updated);
+        let loaded = load_quicklinks_from_path(&path);
+        assert_eq!(loaded, links);
+    }
 }


thinking
**Planning built-in entry insertion**
exec
/bin/zsh -lc "sed -n '1,200p' src/builtins/part_001_entries/entries_000.rs" in /Users/johnlindquist/dev/script-kit-gpui succeeded in 51ms:
{
    if config.clipboard_history {
        entries.push(BuiltInEntry::new_with_icon(
            "builtin-clipboard-history",
            "Clipboard History",
            "Open clipboard history to view, search, and reuse copied items",
            vec!["clipboard", "history", "paste", "copy"],
            BuiltInFeature::ClipboardHistory,
            "ðŸ“‹",
        ));
        debug!("Added Clipboard History built-in entry");
    }

    // Note: AppLauncher built-in removed - apps now appear directly in main search
    // The app_launcher config flag is kept for future use (e.g., to disable app search entirely)
    if config.app_launcher {
        debug!("app_launcher enabled - apps will appear in main search");
    }

    if config.window_switcher {
file update:
diff --git a/src/quicklinks/mod.rs b/src/quicklinks/mod.rs
index 08aeea02e216c8026f59f0d8fe5627ededb1dec0..e9e055c95e2b0cd21fbc8b79971df226a788899c
--- a/src/quicklinks/mod.rs
+++ b/src/quicklinks/mod.rs
@@ -43,6 +43,14 @@
     url_template.replace(QUERY_PLACEHOLDER, query)
 }
 
+pub fn has_query_placeholder(url_template: &str) -> bool {
+    url_template.contains(QUERY_PLACEHOLDER)
+}
+
+pub fn update_quicklink(id: &str, name: &str, url_template: &str) -> bool {
+    update_quicklink_from_path(id, name, url_template, &quicklinks_path())
+}
+
 fn quicklinks_path() -> PathBuf {
     dirs::home_dir()
         .map(|home| home.join(".scriptkit").join(QUICKLINKS_FILE))
@@ -75,11 +83,22 @@
     let _ = save_quicklinks_to_path(&links, path);
 }
 
+fn update_quicklink_from_path(id: &str, name: &str, url_template: &str, path: &Path) -> bool {
+    let mut links = load_quicklinks_from_path(path);
+    if let Some(link) = links.iter_mut().find(|link| link.id == id) {
+        link.name = name.trim().to_string();
+        link.url_template = url_template.trim().to_string();
+        return save_quicklinks_to_path(&links, path).is_ok();
+    }
+
+    false
+}
+
 #[cfg(test)]
 mod tests {
     use super::{
-        create_quicklink, delete_quicklink_from_path, expand_url, load_quicklinks_from_path,
-        save_quicklinks_to_path, Quicklink,
+        create_quicklink, delete_quicklink_from_path, expand_url, has_query_placeholder,
+        load_quicklinks_from_path, save_quicklinks_to_path, update_quicklink_from_path, Quicklink,
     };
 
     #[test]
@@ -105,6 +124,16 @@
     }
 
     #[test]
+    fn test_has_query_placeholder_returns_true_when_template_contains_placeholder() {
+        assert!(has_query_placeholder("https://example.com?q={query}"));
+    }
+
+    #[test]
+    fn test_has_query_placeholder_returns_false_when_template_missing_placeholder() {
+        assert!(!has_query_placeholder("https://example.com"));
+    }
+
+    #[test]
     fn test_load_quicklinks_from_path_returns_empty_when_file_missing() {
         let dir = tempfile::tempdir().expect("create temp dir");
         let path = dir.path().join("quicklinks.json");
@@ -174,4 +203,49 @@
         assert_eq!(loaded.len(), 1);
         assert_eq!(loaded[0].id, "keep");
     }
+
+    #[test]
+    fn test_update_quicklink_from_path_updates_name_and_url_template() {
+        let dir = tempfile::tempdir().expect("create temp dir");
+        let path = dir.path().join("quicklinks.json");
+        let links = vec![Quicklink {
+            id: "target".to_string(),
+            name: "Old".to_string(),
+            url_template: "https://old.example.com".to_string(),
+            icon: None,
+        }];
+
+        save_quicklinks_to_path(&links, &path).expect("seed quicklinks");
+        let updated = update_quicklink_from_path(
+            "target",
+            " New Name ",
+            " https://new.example.com?q={query} ",
+            &path,
+        );
+
+        assert!(updated);
+        let loaded = load_quicklinks_from_path(&path);
+        assert_eq!(loaded.len(), 1);
+        assert_eq!(loaded[0].name, "New Name");
+        assert_eq!(loaded[0].url_template, "https://new.example.com?q={query}");
+    }
+
+    #[test]
+    fn test_update_quicklink_from_path_returns_false_when_id_not_found() {
+        let dir = tempfile::tempdir().expect("create temp dir");
+        let path = dir.path().join("quicklinks.json");
+        let links = vec![Quicklink {
+            id: "target".to_string(),
+            name: "Keep".to_string(),
+            url_template: "https://example.com".to_string(),
+            icon: None,
+        }];
+
+        save_quicklinks_to_path(&links, &path).expect("seed quicklinks");
+        let updated = update_quicklink_from_path("missing", "Name", "https://updated.example.com", &path);
+
+        assert!(!updated);
+        let loaded = load_quicklinks_from_path(&path);
+        assert_eq!(loaded, links);
+    }
 }


thinking
**Adding placeholder quicklinks entry**
file update
M /Users/johnlindquist/dev/script-kit-gpui/src/builtins/part_001_entries/entries_000.rs
@@ -71,2 +71,20 @@
 
+    entries.push(BuiltInEntry::new_with_icon(
+        "builtin-quicklinks",
+        "Quicklinks",
+        "Manage quick links and open URLs with optional {query} expansion",
+        vec![
+            "quicklinks",
+            "quicklink",
+            "link",
+            "url",
+            "bookmark",
+            "open",
+            "search",
+        ],
+        BuiltInFeature::Quicklinks,
+        "ðŸ”—",
+    ));
+    debug!("Added Quicklinks built-in entry");
+
     // Design Gallery is only available in debug builds (developer tool)
apply_patch(auto_approved=true) exited 0 in 17ms:
Success. Updated the following files:
M /Users/johnlindquist/dev/script-kit-gpui/src/builtins/part_001_entries/entries_000.rs
file update:
diff --git a/src/builtins/part_001_entries/entries_000.rs b/src/builtins/part_001_entries/entries_000.rs
index 926be9edb8db75488c1894f105dba265b103c614..1b3e861bd2e0390edbd6aafc031907ffa15a7cd5
--- a/src/builtins/part_001_entries/entries_000.rs
+++ b/src/builtins/part_001_entries/entries_000.rs
@@ -69,6 +69,24 @@
     ));
     debug!("Added Notes built-in entry");
 
+    entries.push(BuiltInEntry::new_with_icon(
+        "builtin-quicklinks",
+        "Quicklinks",
+        "Manage quick links and open URLs with optional {query} expansion",
+        vec![
+            "quicklinks",
+            "quicklink",
+            "link",
+            "url",
+            "bookmark",
+            "open",
+            "search",
+        ],
+        BuiltInFeature::Quicklinks,
+        "ðŸ”—",
+    ));
+    debug!("Added Quicklinks built-in entry");
+
     // Design Gallery is only available in debug builds (developer tool)
     #[cfg(debug_assertions)]
     {
diff --git a/src/quicklinks/mod.rs b/src/quicklinks/mod.rs
index 08aeea02e216c8026f59f0d8fe5627ededb1dec0..e9e055c95e2b0cd21fbc8b79971df226a788899c
--- a/src/quicklinks/mod.rs
+++ b/src/quicklinks/mod.rs
@@ -43,6 +43,14 @@
     url_template.replace(QUERY_PLACEHOLDER, query)
 }
 
+pub fn has_query_placeholder(url_template: &str) -> bool {
+    url_template.contains(QUERY_PLACEHOLDER)
+}
+
+pub fn update_quicklink(id: &str, name: &str, url_template: &str) -> bool {
+    update_quicklink_from_path(id, name, url_template, &quicklinks_path())
+}
+
 fn quicklinks_path() -> PathBuf {
     dirs::home_dir()
         .map(|home| home.join(".scriptkit").join(QUICKLINKS_FILE))
@@ -75,11 +83,22 @@
     let _ = save_quicklinks_to_path(&links, path);
 }
 
+fn update_quicklink_from_path(id: &str, name: &str, url_template: &str, path: &Path) -> bool {
+    let mut links = load_quicklinks_from_path(path);
+    if let Some(link) = links.iter_mut().find(|link| link.id == id) {
+        link.name = name.trim().to_string();
+        link.url_template = url_template.trim().to_string();
+        return save_quicklinks_to_path(&links, path).is_ok();
+    }
+
+    false
+}
+
 #[cfg(test)]
 mod tests {
     use super::{
-        create_quicklink, delete_quicklink_from_path, expand_url, load_quicklinks_from_path,
-        save_quicklinks_to_path, Quicklink,
+        create_quicklink, delete_quicklink_from_path, expand_url, has_query_placeholder,
+        load_quicklinks_from_path, save_quicklinks_to_path, update_quicklink_from_path, Quicklink,
     };
 
     #[test]
@@ -105,6 +124,16 @@
     }
 
     #[test]
+    fn test_has_query_placeholder_returns_true_when_template_contains_placeholder() {
+        assert!(has_query_placeholder("https://example.com?q={query}"));
+    }
+
+    #[test]
+    fn test_has_query_placeholder_returns_false_when_template_missing_placeholder() {
+        assert!(!has_query_placeholder("https://example.com"));
+    }
+
+    #[test]
     fn test_load_quicklinks_from_path_returns_empty_when_file_missing() {
         let dir = tempfile::tempdir().expect("create temp dir");
         let path = dir.path().join("quicklinks.json");
@@ -174,4 +203,49 @@
         assert_eq!(loaded.len(), 1);
         assert_eq!(loaded[0].id, "keep");
     }
+
+    #[test]
+    fn test_update_quicklink_from_path_updates_name_and_url_template() {
+        let dir = tempfile::tempdir().expect("create temp dir");
+        let path = dir.path().join("quicklinks.json");
+        let links = vec![Quicklink {
+            id: "target".to_string(),
+            name: "Old".to_string(),
+            url_template: "https://old.example.com".to_string(),
+            icon: None,
+        }];
+
+        save_quicklinks_to_path(&links, &path).expect("seed quicklinks");
+        let updated = update_quicklink_from_path(
+            "target",
+            " New Name ",
+            " https://new.example.com?q={query} ",
+            &path,
+        );
+
+        assert!(updated);
+        let loaded = load_quicklinks_from_path(&path);
+        assert_eq!(loaded.len(), 1);
+        assert_eq!(loaded[0].name, "New Name");
+        assert_eq!(loaded[0].url_template, "https://new.example.com?q={query}");
+    }
+
+    #[test]
+    fn test_update_quicklink_from_path_returns_false_when_id_not_found() {
+        let dir = tempfile::tempdir().expect("create temp dir");
+        let path = dir.path().join("quicklinks.json");
+        let links = vec![Quicklink {
+            id: "target".to_string(),
+            name: "Keep".to_string(),
+            url_template: "https://example.com".to_string(),
+            icon: None,
+        }];
+
+        save_quicklinks_to_path(&links, &path).expect("seed quicklinks");
+        let updated = update_quicklink_from_path("missing", "Name", "https://updated.example.com", &path);
+
+        assert!(!updated);
+        let loaded = load_quicklinks_from_path(&path);
+        assert_eq!(loaded, links);
+    }
 }

file update:
diff --git a/src/builtins/part_001_entries/entries_000.rs b/src/builtins/part_001_entries/entries_000.rs
index 926be9edb8db75488c1894f105dba265b103c614..1b3e861bd2e0390edbd6aafc031907ffa15a7cd5
--- a/src/builtins/part_001_entries/entries_000.rs
+++ b/src/builtins/part_001_entries/entries_000.rs
@@ -69,6 +69,24 @@
     ));
     debug!("Added Notes built-in entry");
 
+    entries.push(BuiltInEntry::new_with_icon(
+        "builtin-quicklinks",
+        "Quicklinks",
+        "Manage quick links and open URLs with optional {query} expansion",
+        vec![
+            "quicklinks",
+            "quicklink",
+            "link",
+            "url",
+            "bookmark",
+            "open",
+            "search",
+        ],
+        BuiltInFeature::Quicklinks,
+        "ðŸ”—",
+    ));
+    debug!("Added Quicklinks built-in entry");
+
     // Design Gallery is only available in debug builds (developer tool)
     #[cfg(debug_assertions)]
     {
diff --git a/src/quicklinks/mod.rs b/src/quicklinks/mod.rs
index 08aeea02e216c8026f59f0d8fe5627ededb1dec0..e9e055c95e2b0cd21fbc8b79971df226a788899c
--- a/src/quicklinks/mod.rs
+++ b/src/quicklinks/mod.rs
@@ -43,6 +43,14 @@
     url_template.replace(QUERY_PLACEHOLDER, query)
 }
 
+pub fn has_query_placeholder(url_template: &str) -> bool {
+    url_template.contains(QUERY_PLACEHOLDER)
+}
+
+pub fn update_quicklink(id: &str, name: &str, url_template: &str) -> bool {
+    update_quicklink_from_path(id, name, url_template, &quicklinks_path())
+}
+
 fn quicklinks_path() -> PathBuf {
     dirs::home_dir()
         .map(|home| home.join(".scriptkit").join(QUICKLINKS_FILE))
@@ -75,11 +83,22 @@
     let _ = save_quicklinks_to_path(&links, path);
 }
 
+fn update_quicklink_from_path(id: &str, name: &str, url_template: &str, path: &Path) -> bool {
+    let mut links = load_quicklinks_from_path(path);
+    if let Some(link) = links.iter_mut().find(|link| link.id == id) {
+        link.name = name.trim().to_string();
+        link.url_template = url_template.trim().to_string();
+        return save_quicklinks_to_path(&links, path).is_ok();
+    }
+
+    false
+}
+
 #[cfg(test)]
 mod tests {
     use super::{
-        create_quicklink, delete_quicklink_from_path, expand_url, load_quicklinks_from_path,
-        save_quicklinks_to_path, Quicklink,
+        create_quicklink, delete_quicklink_from_path, expand_url, has_query_placeholder,
+        load_quicklinks_from_path, save_quicklinks_to_path, update_quicklink_from_path, Quicklink,
     };
 
     #[test]
@@ -105,6 +124,16 @@
     }
 
     #[test]
+    fn test_has_query_placeholder_returns_true_when_template_contains_placeholder() {
+        assert!(has_query_placeholder("https://example.com?q={query}"));
+    }
+
+    #[test]
+    fn test_has_query_placeholder_returns_false_when_template_missing_placeholder() {
+        assert!(!has_query_placeholder("https://example.com"));
+    }
+
+    #[test]
     fn test_load_quicklinks_from_path_returns_empty_when_file_missing() {
         let dir = tempfile::tempdir().expect("create temp dir");
         let path = dir.path().join("quicklinks.json");
@@ -174,4 +203,49 @@
         assert_eq!(loaded.len(), 1);
         assert_eq!(loaded[0].id, "keep");
     }
+
+    #[test]
+    fn test_update_quicklink_from_path_updates_name_and_url_template() {
+        let dir = tempfile::tempdir().expect("create temp dir");
+        let path = dir.path().join("quicklinks.json");
+        let links = vec![Quicklink {
+            id: "target".to_string(),
+            name: "Old".to_string(),
+            url_template: "https://old.example.com".to_string(),
+            icon: None,
+        }];
+
+        save_quicklinks_to_path(&links, &path).expect("seed quicklinks");
+        let updated = update_quicklink_from_path(
+            "target",
+            " New Name ",
+            " https://new.example.com?q={query} ",
+            &path,
+        );
+
+        assert!(updated);
+        let loaded = load_quicklinks_from_path(&path);
+        assert_eq!(loaded.len(), 1);
+        assert_eq!(loaded[0].name, "New Name");
+        assert_eq!(loaded[0].url_template, "https://new.example.com?q={query}");
+    }
+
+    #[test]
+    fn test_update_quicklink_from_path_returns_false_when_id_not_found() {
+        let dir = tempfile::tempdir().expect("create temp dir");
+        let path = dir.path().join("quicklinks.json");
+        let links = vec![Quicklink {
+            id: "target".to_string(),
+            name: "Keep".to_string(),
+            url_template: "https://example.com".to_string(),
+            icon: None,
+        }];
+
+        save_quicklinks_to_path(&links, &path).expect("seed quicklinks");
+        let updated = update_quicklink_from_path("missing", "Name", "https://updated.example.com", &path);
+
+        assert!(!updated);
+        let loaded = load_quicklinks_from_path(&path);
+        assert_eq!(loaded, links);
+    }
 }


thinking
**Waiting for file claim**
file update:
diff --git a/src/builtins/part_001_entries/entries_000.rs b/src/builtins/part_001_entries/entries_000.rs
index 926be9edb8db75488c1894f105dba265b103c614..1b3e861bd2e0390edbd6aafc031907ffa15a7cd5
--- a/src/builtins/part_001_entries/entries_000.rs
+++ b/src/builtins/part_001_entries/entries_000.rs
@@ -69,6 +69,24 @@
     ));
     debug!("Added Notes built-in entry");
 
+    entries.push(BuiltInEntry::new_with_icon(
+        "builtin-quicklinks",
+        "Quicklinks",
+        "Manage quick links and open URLs with optional {query} expansion",
+        vec![
+            "quicklinks",
+            "quicklink",
+            "link",
+            "url",
+            "bookmark",
+            "open",
+            "search",
+        ],
+        BuiltInFeature::Quicklinks,
+        "ðŸ”—",
+    ));
+    debug!("Added Quicklinks built-in entry");
+
     // Design Gallery is only available in debug builds (developer tool)
     #[cfg(debug_assertions)]
     {
diff --git a/src/quicklinks/mod.rs b/src/quicklinks/mod.rs
index 08aeea02e216c8026f59f0d8fe5627ededb1dec0..e9e055c95e2b0cd21fbc8b79971df226a788899c
--- a/src/quicklinks/mod.rs
+++ b/src/quicklinks/mod.rs
@@ -43,6 +43,14 @@
     url_template.replace(QUERY_PLACEHOLDER, query)
 }
 
+pub fn has_query_placeholder(url_template: &str) -> bool {
+    url_template.contains(QUERY_PLACEHOLDER)
+}
+
+pub fn update_quicklink(id: &str, name: &str, url_template: &str) -> bool {
+    update_quicklink_from_path(id, name, url_template, &quicklinks_path())
+}
+
 fn quicklinks_path() -> PathBuf {
     dirs::home_dir()
         .map(|home| home.join(".scriptkit").join(QUICKLINKS_FILE))
@@ -75,11 +83,22 @@
     let _ = save_quicklinks_to_path(&links, path);
 }
 
+fn update_quicklink_from_path(id: &str, name: &str, url_template: &str, path: &Path) -> bool {
+    let mut links = load_quicklinks_from_path(path);
+    if let Some(link) = links.iter_mut().find(|link| link.id == id) {
+        link.name = name.trim().to_string();
+        link.url_template = url_template.trim().to_string();
+        return save_quicklinks_to_path(&links, path).is_ok();
+    }
+
+    false
+}
+
 #[cfg(test)]
 mod tests {
     use super::{
-        create_quicklink, delete_quicklink_from_path, expand_url, load_quicklinks_from_path,
-        save_quicklinks_to_path, Quicklink,
+        create_quicklink, delete_quicklink_from_path, expand_url, has_query_placeholder,
+        load_quicklinks_from_path, save_quicklinks_to_path, update_quicklink_from_path, Quicklink,
     };
 
     #[test]
@@ -105,6 +124,16 @@
     }
 
     #[test]
+    fn test_has_query_placeholder_returns_true_when_template_contains_placeholder() {
+        assert!(has_query_placeholder("https://example.com?q={query}"));
+    }
+
+    #[test]
+    fn test_has_query_placeholder_returns_false_when_template_missing_placeholder() {
+        assert!(!has_query_placeholder("https://example.com"));
+    }
+
+    #[test]
     fn test_load_quicklinks_from_path_returns_empty_when_file_missing() {
         let dir = tempfile::tempdir().expect("create temp dir");
         let path = dir.path().join("quicklinks.json");
@@ -174,4 +203,49 @@
         assert_eq!(loaded.len(), 1);
         assert_eq!(loaded[0].id, "keep");
     }
+
+    #[test]
+    fn test_update_quicklink_from_path_updates_name_and_url_template() {
+        let dir = tempfile::tempdir().expect("create temp dir");
+        let path = dir.path().join("quicklinks.json");
+        let links = vec![Quicklink {
+            id: "target".to_string(),
+            name: "Old".to_string(),
+            url_template: "https://old.example.com".to_string(),
+            icon: None,
+        }];
+
+        save_quicklinks_to_path(&links, &path).expect("seed quicklinks");
+        let updated = update_quicklink_from_path(
+            "target",
+            " New Name ",
+            " https://new.example.com?q={query} ",
+            &path,
+        );
+
+        assert!(updated);
+        let loaded = load_quicklinks_from_path(&path);
+        assert_eq!(loaded.len(), 1);
+        assert_eq!(loaded[0].name, "New Name");
+        assert_eq!(loaded[0].url_template, "https://new.example.com?q={query}");
+    }
+
+    #[test]
+    fn test_update_quicklink_from_path_returns_false_when_id_not_found() {
+        let dir = tempfile::tempdir().expect("create temp dir");
+        let path = dir.path().join("quicklinks.json");
+        let links = vec![Quicklink {
+            id: "target".to_string(),
+            name: "Keep".to_string(),
+            url_template: "https://example.com".to_string(),
+            icon: None,
+        }];
+
+        save_quicklinks_to_path(&links, &path).expect("seed quicklinks");
+        let updated = update_quicklink_from_path("missing", "Name", "https://updated.example.com", &path);
+
+        assert!(!updated);
+        let loaded = load_quicklinks_from_path(&path);
+        assert_eq!(loaded, links);
+    }
 }


thinking
**Planning claim conflict handling**
codex
Iâ€™ve completed the quicklinks-module updates and added the new built-in entry file change, but the critical files `src/builtins/part_000.rs` and `src/app_execute/builtin_execution.rs` are still locked by `codex-wire-favorites`. Iâ€™m continuing to wait on the queued claims so I can finish wiring execution behavior without conflicting edits.
exec
/bin/zsh -lc '~/.claude/bin/swarm.ts update --id codex-wire-quicklinks --status blocked --notes "Added quicklinks module helpers/tests + builtin entry in entries_000.rs; waiting for claims on src/builtins/part_000.rs and src/app_execute/builtin_execution.rs"' in /Users/johnlindquist/dev/script-kit-gpui succeeded in 52ms:
Updated: codex-wire-quicklinks
file update:
diff --git a/src/builtins/part_001_entries/entries_000.rs b/src/builtins/part_001_entries/entries_000.rs
index 926be9edb8db75488c1894f105dba265b103c614..1b3e861bd2e0390edbd6aafc031907ffa15a7cd5
--- a/src/builtins/part_001_entries/entries_000.rs
+++ b/src/builtins/part_001_entries/entries_000.rs
@@ -69,6 +69,24 @@
     ));
     debug!("Added Notes built-in entry");
 
+    entries.push(BuiltInEntry::new_with_icon(
+        "builtin-quicklinks",
+        "Quicklinks",
+        "Manage quick links and open URLs with optional {query} expansion",
+        vec![
+            "quicklinks",
+            "quicklink",
+            "link",
+            "url",
+            "bookmark",
+            "open",
+            "search",
+        ],
+        BuiltInFeature::Quicklinks,
+        "ðŸ”—",
+    ));
+    debug!("Added Quicklinks built-in entry");
+
     // Design Gallery is only available in debug builds (developer tool)
     #[cfg(debug_assertions)]
     {
diff --git a/src/quicklinks/mod.rs b/src/quicklinks/mod.rs
index 08aeea02e216c8026f59f0d8fe5627ededb1dec0..e9e055c95e2b0cd21fbc8b79971df226a788899c
--- a/src/quicklinks/mod.rs
+++ b/src/quicklinks/mod.rs
@@ -43,6 +43,14 @@
     url_template.replace(QUERY_PLACEHOLDER, query)
 }
 
+pub fn has_query_placeholder(url_template: &str) -> bool {
+    url_template.contains(QUERY_PLACEHOLDER)
+}
+
+pub fn update_quicklink(id: &str, name: &str, url_template: &str) -> bool {
+    update_quicklink_from_path(id, name, url_template, &quicklinks_path())
+}
+
 fn quicklinks_path() -> PathBuf {
     dirs::home_dir()
         .map(|home| home.join(".scriptkit").join(QUICKLINKS_FILE))
@@ -75,11 +83,22 @@
     let _ = save_quicklinks_to_path(&links, path);
 }
 
+fn update_quicklink_from_path(id: &str, name: &str, url_template: &str, path: &Path) -> bool {
+    let mut links = load_quicklinks_from_path(path);
+    if let Some(link) = links.iter_mut().find(|link| link.id == id) {
+        link.name = name.trim().to_string();
+        link.url_template = url_template.trim().to_string();
+        return save_quicklinks_to_path(&links, path).is_ok();
+    }
+
+    false
+}
+
 #[cfg(test)]
 mod tests {
     use super::{
-        create_quicklink, delete_quicklink_from_path, expand_url, load_quicklinks_from_path,
-        save_quicklinks_to_path, Quicklink,
+        create_quicklink, delete_quicklink_from_path, expand_url, has_query_placeholder,
+        load_quicklinks_from_path, save_quicklinks_to_path, update_quicklink_from_path, Quicklink,
     };
 
     #[test]
@@ -105,6 +124,16 @@
     }
 
     #[test]
+    fn test_has_query_placeholder_returns_true_when_template_contains_placeholder() {
+        assert!(has_query_placeholder("https://example.com?q={query}"));
+    }
+
+    #[test]
+    fn test_has_query_placeholder_returns_false_when_template_missing_placeholder() {
+        assert!(!has_query_placeholder("https://example.com"));
+    }
+
+    #[test]
     fn test_load_quicklinks_from_path_returns_empty_when_file_missing() {
         let dir = tempfile::tempdir().expect("create temp dir");
         let path = dir.path().join("quicklinks.json");
@@ -174,4 +203,49 @@
         assert_eq!(loaded.len(), 1);
         assert_eq!(loaded[0].id, "keep");
     }
+
+    #[test]
+    fn test_update_quicklink_from_path_updates_name_and_url_template() {
+        let dir = tempfile::tempdir().expect("create temp dir");
+        let path = dir.path().join("quicklinks.json");
+        let links = vec![Quicklink {
+            id: "target".to_string(),
+            name: "Old".to_string(),
+            url_template: "https://old.example.com".to_string(),
+            icon: None,
+        }];
+
+        save_quicklinks_to_path(&links, &path).expect("seed quicklinks");
+        let updated = update_quicklink_from_path(
+            "target",
+            " New Name ",
+            " https://new.example.com?q={query} ",
+            &path,
+        );
+
+        assert!(updated);
+        let loaded = load_quicklinks_from_path(&path);
+        assert_eq!(loaded.len(), 1);
+        assert_eq!(loaded[0].name, "New Name");
+        assert_eq!(loaded[0].url_template, "https://new.example.com?q={query}");
+    }
+
+    #[test]
+    fn test_update_quicklink_from_path_returns_false_when_id_not_found() {
+        let dir = tempfile::tempdir().expect("create temp dir");
+        let path = dir.path().join("quicklinks.json");
+        let links = vec![Quicklink {
+            id: "target".to_string(),
+            name: "Keep".to_string(),
+            url_template: "https://example.com".to_string(),
+            icon: None,
+        }];
+
+        save_quicklinks_to_path(&links, &path).expect("seed quicklinks");
+        let updated = update_quicklink_from_path("missing", "Name", "https://updated.example.com", &path);
+
+        assert!(!updated);
+        let loaded = load_quicklinks_from_path(&path);
+        assert_eq!(loaded, links);
+    }
 }


thinking
**Considering release status check**
exec
/bin/zsh -lc '~/.claude/bin/swarm.ts status' in /Users/johnlindquist/dev/script-kit-gpui succeeded in 51ms:
Repo: /Users/johnlindquist/dev/script-kit-gpui
Updated: 2026-02-08T03:02:09.391Z

Active agents (4):
codex-wire-clipboard-exclusions [in_progress] codex/gpt-5.3-codex/exec
  task: Wire up the existing clipboard password manager exclusion list (src/clipboard_history/exclusions.rs) into the actual clâ€¦
  scope: src/clipboard_history/**
  claims(2): src/clipboard_history/monitor.rs, src/clipboard_history/mod.rs
  notes: Claimed monitor/mod; wiring exclusion check before clipboard add_entry calls

codex-wire-emoji [in_progress] codex/gpt-5.3-codex/exec
  task: Wire up the existing src/emoji/mod.rs static emoji database into the app as a working built-in feature. The module has â€¦
  scope: src/emoji/**,src/builtins/part_000.rs,src/builtins/part_001_entries/**,src/app_execute/builtin_execution.rs
  claims: (none)
  notes: Starting emoji built-in wiring; preparing claims and reading existing emoji + clipboard flow

codex-wire-favorites [in_progress] codex/gpt-5.3-codex/exec
  task: Wire up the existing src/favorites/mod.rs storage module into the app as a working feature. The module already has loadâ€¦
  scope: src/favorites/**,src/builtins/part_000.rs,src/builtins/part_001_entries/**,src/app_execute/builtin_execution.rs,src/actâ€¦
  claims(4): src/builtins/part_000.rs, src/builtins/part_001_entries/entries_003.rs, src/app_execute/builtin_execution.rs, src/actions/builders/script_context.rs
file update:
diff --git a/src/builtins/part_001_entries/entries_000.rs b/src/builtins/part_001_entries/entries_000.rs
index 926be9edb8db75488c1894f105dba265b103c614..1b3e861bd2e0390edbd6aafc031907ffa15a7cd5
--- a/src/builtins/part_001_entries/entries_000.rs
+++ b/src/builtins/part_001_entries/entries_000.rs
@@ -69,6 +69,24 @@
     ));
     debug!("Added Notes built-in entry");
 
+    entries.push(BuiltInEntry::new_with_icon(
+        "builtin-quicklinks",
+        "Quicklinks",
+        "Manage quick links and open URLs with optional {query} expansion",
+        vec![
+            "quicklinks",
+            "quicklink",
+            "link",
+            "url",
+            "bookmark",
+            "open",
+            "search",
+        ],
+        BuiltInFeature::Quicklinks,
+        "ðŸ”—",
+    ));
+    debug!("Added Quicklinks built-in entry");
+
     // Design Gallery is only available in debug builds (developer tool)
     #[cfg(debug_assertions)]
     {
diff --git a/src/quicklinks/mod.rs b/src/quicklinks/mod.rs
index 08aeea02e216c8026f59f0d8fe5627ededb1dec0..e9e055c95e2b0cd21fbc8b79971df226a788899c
--- a/src/quicklinks/mod.rs
+++ b/src/quicklinks/mod.rs
@@ -43,6 +43,14 @@
     url_template.replace(QUERY_PLACEHOLDER, query)
 }
 
+pub fn has_query_placeholder(url_template: &str) -> bool {
+    url_template.contains(QUERY_PLACEHOLDER)
+}
+
+pub fn update_quicklink(id: &str, name: &str, url_template: &str) -> bool {
+    update_quicklink_from_path(id, name, url_template, &quicklinks_path())
+}
+
 fn quicklinks_path() -> PathBuf {
     dirs::home_dir()
         .map(|home| home.join(".scriptkit").join(QUICKLINKS_FILE))
@@ -75,11 +83,22 @@
     let _ = save_quicklinks_to_path(&links, path);
 }
 
+fn update_quicklink_from_path(id: &str, name: &str, url_template: &str, path: &Path) -> bool {
+    let mut links = load_quicklinks_from_path(path);
+    if let Some(link) = links.iter_mut().find(|link| link.id == id) {
+        link.name = name.trim().to_string();
+        link.url_template = url_template.trim().to_string();
+        return save_quicklinks_to_path(&links, path).is_ok();
+    }
+
+    false
+}
+
 #[cfg(test)]
 mod tests {
     use super::{
-        create_quicklink, delete_quicklink_from_path, expand_url, load_quicklinks_from_path,
-        save_quicklinks_to_path, Quicklink,
+        create_quicklink, delete_quicklink_from_path, expand_url, has_query_placeholder,
+        load_quicklinks_from_path, save_quicklinks_to_path, update_quicklink_from_path, Quicklink,
     };
 
     #[test]
@@ -105,6 +124,16 @@
     }
 
     #[test]
+    fn test_has_query_placeholder_returns_true_when_template_contains_placeholder() {
+        assert!(has_query_placeholder("https://example.com?q={query}"));
+    }
+
+    #[test]
+    fn test_has_query_placeholder_returns_false_when_template_missing_placeholder() {
+        assert!(!has_query_placeholder("https://example.com"));
+    }
+
+    #[test]
     fn test_load_quicklinks_from_path_returns_empty_when_file_missing() {
         let dir = tempfile::tempdir().expect("create temp dir");
         let path = dir.path().join("quicklinks.json");
@@ -174,4 +203,49 @@
         assert_eq!(loaded.len(), 1);
         assert_eq!(loaded[0].id, "keep");
     }
+
+    #[test]
+    fn test_update_quicklink_from_path_updates_name_and_url_template() {
+        let dir = tempfile::tempdir().expect("create temp dir");
+        let path = dir.path().join("quicklinks.json");
+        let links = vec![Quicklink {
+            id: "target".to_string(),
+            name: "Old".to_string(),
+            url_template: "https://old.example.com".to_string(),
+            icon: None,
+        }];
+
+        save_quicklinks_to_path(&links, &path).expect("seed quicklinks");
+        let updated = update_quicklink_from_path(
+            "target",
+            " New Name ",
+            " https://new.example.com?q={query} ",
+            &path,
+        );
+
+        assert!(updated);
+        let loaded = load_quicklinks_from_path(&path);
+        assert_eq!(loaded.len(), 1);
+        assert_eq!(loaded[0].name, "New Name");
+        assert_eq!(loaded[0].url_template, "https://new.example.com?q={query}");
+    }
+
+    #[test]
+    fn test_update_quicklink_from_path_returns_false_when_id_not_found() {
+        let dir = tempfile::tempdir().expect("create temp dir");
+        let path = dir.path().join("quicklinks.json");
+        let links = vec![Quicklink {
+            id: "target".to_string(),
+            name: "Keep".to_string(),
+            url_template: "https://example.com".to_string(),
+            icon: None,
+        }];
+
+        save_quicklinks_to_path(&links, &path).expect("seed quicklinks");
+        let updated = update_quicklink_from_path("missing", "Name", "https://updated.example.com", &path);
+
+        assert!(!updated);
+        let loaded = load_quicklinks_from_path(&path);
+        assert_eq!(loaded, links);
+    }
 }


thinking
**Preparing patch for pending claims**
file update:
diff --git a/src/builtins/part_001_entries/entries_000.rs b/src/builtins/part_001_entries/entries_000.rs
index 926be9edb8db75488c1894f105dba265b103c614..1b3e861bd2e0390edbd6aafc031907ffa15a7cd5
--- a/src/builtins/part_001_entries/entries_000.rs
+++ b/src/builtins/part_001_entries/entries_000.rs
@@ -69,6 +69,24 @@
     ));
     debug!("Added Notes built-in entry");
 
+    entries.push(BuiltInEntry::new_with_icon(
+        "builtin-quicklinks",
+        "Quicklinks",
+        "Manage quick links and open URLs with optional {query} expansion",
+        vec![
+            "quicklinks",
+            "quicklink",
+            "link",
+            "url",
+            "bookmark",
+            "open",
+            "search",
+        ],
+        BuiltInFeature::Quicklinks,
+        "ðŸ”—",
+    ));
+    debug!("Added Quicklinks built-in entry");
+
     // Design Gallery is only available in debug builds (developer tool)
     #[cfg(debug_assertions)]
     {
diff --git a/src/quicklinks/mod.rs b/src/quicklinks/mod.rs
index 08aeea02e216c8026f59f0d8fe5627ededb1dec0..e9e055c95e2b0cd21fbc8b79971df226a788899c
--- a/src/quicklinks/mod.rs
+++ b/src/quicklinks/mod.rs
@@ -43,6 +43,14 @@
     url_template.replace(QUERY_PLACEHOLDER, query)
 }
 
+pub fn has_query_placeholder(url_template: &str) -> bool {
+    url_template.contains(QUERY_PLACEHOLDER)
+}
+
+pub fn update_quicklink(id: &str, name: &str, url_template: &str) -> bool {
+    update_quicklink_from_path(id, name, url_template, &quicklinks_path())
+}
+
 fn quicklinks_path() -> PathBuf {
     dirs::home_dir()
         .map(|home| home.join(".scriptkit").join(QUICKLINKS_FILE))
@@ -75,11 +83,22 @@
     let _ = save_quicklinks_to_path(&links, path);
 }
 
+fn update_quicklink_from_path(id: &str, name: &str, url_template: &str, path: &Path) -> bool {
+    let mut links = load_quicklinks_from_path(path);
+    if let Some(link) = links.iter_mut().find(|link| link.id == id) {
+        link.name = name.trim().to_string();
+        link.url_template = url_template.trim().to_string();
+        return save_quicklinks_to_path(&links, path).is_ok();
+    }
+
+    false
+}
+
 #[cfg(test)]
 mod tests {
     use super::{
-        create_quicklink, delete_quicklink_from_path, expand_url, load_quicklinks_from_path,
-        save_quicklinks_to_path, Quicklink,
+        create_quicklink, delete_quicklink_from_path, expand_url, has_query_placeholder,
+        load_quicklinks_from_path, save_quicklinks_to_path, update_quicklink_from_path, Quicklink,
     };
 
     #[test]
@@ -105,6 +124,16 @@
     }
 
     #[test]
+    fn test_has_query_placeholder_returns_true_when_template_contains_placeholder() {
+        assert!(has_query_placeholder("https://example.com?q={query}"));
+    }
+
+    #[test]
+    fn test_has_query_placeholder_returns_false_when_template_missing_placeholder() {
+        assert!(!has_query_placeholder("https://example.com"));
+    }
+
+    #[test]
     fn test_load_quicklinks_from_path_returns_empty_when_file_missing() {
         let dir = tempfile::tempdir().expect("create temp dir");
         let path = dir.path().join("quicklinks.json");
@@ -174,4 +203,49 @@
         assert_eq!(loaded.len(), 1);
         assert_eq!(loaded[0].id, "keep");
     }
+
+    #[test]
+    fn test_update_quicklink_from_path_updates_name_and_url_template() {
+        let dir = tempfile::tempdir().expect("create temp dir");
+        let path = dir.path().join("quicklinks.json");
+        let links = vec![Quicklink {
+            id: "target".to_string(),
+            name: "Old".to_string(),
+            url_template: "https://old.example.com".to_string(),
+            icon: None,
+        }];
+
+        save_quicklinks_to_path(&links, &path).expect("seed quicklinks");
+        let updated = update_quicklink_from_path(
+            "target",
+            " New Name ",
+            " https://new.example.com?q={query} ",
+            &path,
+        );
+
+        assert!(updated);
+        let loaded = load_quicklinks_from_path(&path);
+        assert_eq!(loaded.len(), 1);
+        assert_eq!(loaded[0].name, "New Name");
+        assert_eq!(loaded[0].url_template, "https://new.example.com?q={query}");
+    }
+
+    #[test]
+    fn test_update_quicklink_from_path_returns_false_when_id_not_found() {
+        let dir = tempfile::tempdir().expect("create temp dir");
+        let path = dir.path().join("quicklinks.json");
+        let links = vec![Quicklink {
+            id: "target".to_string(),
+            name: "Keep".to_string(),
+            url_template: "https://example.com".to_string(),
+            icon: None,
+        }];
+
+        save_quicklinks_to_path(&links, &path).expect("seed quicklinks");
+        let updated = update_quicklink_from_path("missing", "Name", "https://updated.example.com", &path);
+
+        assert!(!updated);
+        let loaded = load_quicklinks_from_path(&path);
+        assert_eq!(loaded, links);
+    }
 }


thinking
**Assessing claim acquisition and output timing**
codex
Iâ€™m still blocked by active claims on `part_000.rs` and `builtin_execution.rs`; my claim requests are queued and running. Once those unlock, Iâ€™ll immediately patch the new enum variant and execution flow, then run scoped verification.

thinking
**Continuing polling loop**
file update:
diff --git a/src/builtins/part_001_entries/entries_000.rs b/src/builtins/part_001_entries/entries_000.rs
index 926be9edb8db75488c1894f105dba265b103c614..1b3e861bd2e0390edbd6aafc031907ffa15a7cd5
--- a/src/builtins/part_001_entries/entries_000.rs
+++ b/src/builtins/part_001_entries/entries_000.rs
@@ -69,6 +69,24 @@
     ));
     debug!("Added Notes built-in entry");
 
+    entries.push(BuiltInEntry::new_with_icon(
+        "builtin-quicklinks",
+        "Quicklinks",
+        "Manage quick links and open URLs with optional {query} expansion",
+        vec![
+            "quicklinks",
+            "quicklink",
+            "link",
+            "url",
+            "bookmark",
+            "open",
+            "search",
+        ],
+        BuiltInFeature::Quicklinks,
+        "ðŸ”—",
+    ));
+    debug!("Added Quicklinks built-in entry");
+
     // Design Gallery is only available in debug builds (developer tool)
     #[cfg(debug_assertions)]
     {
diff --git a/src/quicklinks/mod.rs b/src/quicklinks/mod.rs
index 08aeea02e216c8026f59f0d8fe5627ededb1dec0..e9e055c95e2b0cd21fbc8b79971df226a788899c
--- a/src/quicklinks/mod.rs
+++ b/src/quicklinks/mod.rs
@@ -43,6 +43,14 @@
     url_template.replace(QUERY_PLACEHOLDER, query)
 }
 
+pub fn has_query_placeholder(url_template: &str) -> bool {
+    url_template.contains(QUERY_PLACEHOLDER)
+}
+
+pub fn update_quicklink(id: &str, name: &str, url_template: &str) -> bool {
+    update_quicklink_from_path(id, name, url_template, &quicklinks_path())
+}
+
 fn quicklinks_path() -> PathBuf {
     dirs::home_dir()
         .map(|home| home.join(".scriptkit").join(QUICKLINKS_FILE))
@@ -75,11 +83,22 @@
     let _ = save_quicklinks_to_path(&links, path);
 }
 
+fn update_quicklink_from_path(id: &str, name: &str, url_template: &str, path: &Path) -> bool {
+    let mut links = load_quicklinks_from_path(path);
+    if let Some(link) = links.iter_mut().find(|link| link.id == id) {
+        link.name = name.trim().to_string();
+        link.url_template = url_template.trim().to_string();
+        return save_quicklinks_to_path(&links, path).is_ok();
+    }
+
+    false
+}
+
 #[cfg(test)]
 mod tests {
     use super::{
-        create_quicklink, delete_quicklink_from_path, expand_url, load_quicklinks_from_path,
-        save_quicklinks_to_path, Quicklink,
+        create_quicklink, delete_quicklink_from_path, expand_url, has_query_placeholder,
+        load_quicklinks_from_path, save_quicklinks_to_path, update_quicklink_from_path, Quicklink,
     };
 
     #[test]
@@ -105,6 +124,16 @@
     }
 
     #[test]
+    fn test_has_query_placeholder_returns_true_when_template_contains_placeholder() {
+        assert!(has_query_placeholder("https://example.com?q={query}"));
+    }
+
+    #[test]
+    fn test_has_query_placeholder_returns_false_when_template_missing_placeholder() {
+        assert!(!has_query_placeholder("https://example.com"));
+    }
+
+    #[test]
     fn test_load_quicklinks_from_path_returns_empty_when_file_missing() {
         let dir = tempfile::tempdir().expect("create temp dir");
         let path = dir.path().join("quicklinks.json");
@@ -174,4 +203,49 @@
         assert_eq!(loaded.len(), 1);
         assert_eq!(loaded[0].id, "keep");
     }
+
+    #[test]
+    fn test_update_quicklink_from_path_updates_name_and_url_template() {
+        let dir = tempfile::tempdir().expect("create temp dir");
+        let path = dir.path().join("quicklinks.json");
+        let links = vec![Quicklink {
+            id: "target".to_string(),
+            name: "Old".to_string(),
+            url_template: "https://old.example.com".to_string(),
+            icon: None,
+        }];
+
+        save_quicklinks_to_path(&links, &path).expect("seed quicklinks");
+        let updated = update_quicklink_from_path(
+            "target",
+            " New Name ",
+            " https://new.example.com?q={query} ",
+            &path,
+        );
+
+        assert!(updated);
+        let loaded = load_quicklinks_from_path(&path);
+        assert_eq!(loaded.len(), 1);
+        assert_eq!(loaded[0].name, "New Name");
+        assert_eq!(loaded[0].url_template, "https://new.example.com?q={query}");
+    }
+
+    #[test]
+    fn test_update_quicklink_from_path_returns_false_when_id_not_found() {
+        let dir = tempfile::tempdir().expect("create temp dir");
+        let path = dir.path().join("quicklinks.json");
+        let links = vec![Quicklink {
+            id: "target".to_string(),
+            name: "Keep".to_string(),
+            url_template: "https://example.com".to_string(),
+            icon: None,
+        }];
+
+        save_quicklinks_to_path(&links, &path).expect("seed quicklinks");
+        let updated = update_quicklink_from_path("missing", "Name", "https://updated.example.com", &path);
+
+        assert!(!updated);
+        let loaded = load_quicklinks_from_path(&path);
+        assert_eq!(loaded, links);
+    }
 }


thinking
**Considering concurrency and locking strategy**
exec
/bin/zsh -lc '~/.claude/bin/swarm.ts status' in /Users/johnlindquist/dev/script-kit-gpui succeeded in 51ms:
Repo: /Users/johnlindquist/dev/script-kit-gpui
Updated: 2026-02-08T03:02:44.547Z

Active agents (4):
codex-wire-clipboard-exclusions [in_progress] codex/gpt-5.3-codex/exec
  task: Wire up the existing clipboard password manager exclusion list (src/clipboard_history/exclusions.rs) into the actual clâ€¦
  scope: src/clipboard_history/**
  claims(2): src/clipboard_history/monitor.rs, src/clipboard_history/mod.rs
  notes: Claimed monitor/mod; wiring exclusion check before clipboard add_entry calls

codex-wire-emoji [in_progress] codex/gpt-5.3-codex/exec
  task: Wire up the existing src/emoji/mod.rs static emoji database into the app as a working built-in feature. The module has â€¦
  scope: src/emoji/**,src/builtins/part_000.rs,src/builtins/part_001_entries/**,src/app_execute/builtin_execution.rs
  claims: (none)
  notes: Starting emoji built-in wiring; preparing claims and reading existing emoji + clipboard flow

codex-wire-favorites [in_progress] codex/gpt-5.3-codex/exec
  task: Wire up the existing src/favorites/mod.rs storage module into the app as a working feature. The module already has loadâ€¦
  scope: src/favorites/**,src/builtins/part_000.rs,src/builtins/part_001_entries/**,src/app_execute/builtin_execution.rs,src/actâ€¦
  claims(10): src/builtins/part_000.rs, src/builtins/part_001_entries/entries_003.rs, src/app_execute/builtin_execution.rs, src/actions/builders/script_context.rs, src/app_aâ€¦
file update:
diff --git a/src/builtins/part_001_entries/entries_000.rs b/src/builtins/part_001_entries/entries_000.rs
index 926be9edb8db75488c1894f105dba265b103c614..1b3e861bd2e0390edbd6aafc031907ffa15a7cd5
--- a/src/builtins/part_001_entries/entries_000.rs
+++ b/src/builtins/part_001_entries/entries_000.rs
@@ -69,6 +69,24 @@
     ));
     debug!("Added Notes built-in entry");
 
+    entries.push(BuiltInEntry::new_with_icon(
+        "builtin-quicklinks",
+        "Quicklinks",
+        "Manage quick links and open URLs with optional {query} expansion",
+        vec![
+            "quicklinks",
+            "quicklink",
+            "link",
+            "url",
+            "bookmark",
+            "open",
+            "search",
+        ],
+        BuiltInFeature::Quicklinks,
+        "ðŸ”—",
+    ));
+    debug!("Added Quicklinks built-in entry");
+
     // Design Gallery is only available in debug builds (developer tool)
     #[cfg(debug_assertions)]
     {
diff --git a/src/quicklinks/mod.rs b/src/quicklinks/mod.rs
index 08aeea02e216c8026f59f0d8fe5627ededb1dec0..e9e055c95e2b0cd21fbc8b79971df226a788899c
--- a/src/quicklinks/mod.rs
+++ b/src/quicklinks/mod.rs
@@ -43,6 +43,14 @@
     url_template.replace(QUERY_PLACEHOLDER, query)
 }
 
+pub fn has_query_placeholder(url_template: &str) -> bool {
+    url_template.contains(QUERY_PLACEHOLDER)
+}
+
+pub fn update_quicklink(id: &str, name: &str, url_template: &str) -> bool {
+    update_quicklink_from_path(id, name, url_template, &quicklinks_path())
+}
+
 fn quicklinks_path() -> PathBuf {
     dirs::home_dir()
         .map(|home| home.join(".scriptkit").join(QUICKLINKS_FILE))
@@ -75,11 +83,22 @@
     let _ = save_quicklinks_to_path(&links, path);
 }
 
+fn update_quicklink_from_path(id: &str, name: &str, url_template: &str, path: &Path) -> bool {
+    let mut links = load_quicklinks_from_path(path);
+    if let Some(link) = links.iter_mut().find(|link| link.id == id) {
+        link.name = name.trim().to_string();
+        link.url_template = url_template.trim().to_string();
+        return save_quicklinks_to_path(&links, path).is_ok();
+    }
+
+    false
+}
+
 #[cfg(test)]
 mod tests {
     use super::{
-        create_quicklink, delete_quicklink_from_path, expand_url, load_quicklinks_from_path,
-        save_quicklinks_to_path, Quicklink,
+        create_quicklink, delete_quicklink_from_path, expand_url, has_query_placeholder,
+        load_quicklinks_from_path, save_quicklinks_to_path, update_quicklink_from_path, Quicklink,
     };
 
     #[test]
@@ -105,6 +124,16 @@
     }
 
     #[test]
+    fn test_has_query_placeholder_returns_true_when_template_contains_placeholder() {
+        assert!(has_query_placeholder("https://example.com?q={query}"));
+    }
+
+    #[test]
+    fn test_has_query_placeholder_returns_false_when_template_missing_placeholder() {
+        assert!(!has_query_placeholder("https://example.com"));
+    }
+
+    #[test]
     fn test_load_quicklinks_from_path_returns_empty_when_file_missing() {
         let dir = tempfile::tempdir().expect("create temp dir");
         let path = dir.path().join("quicklinks.json");
@@ -174,4 +203,49 @@
         assert_eq!(loaded.len(), 1);
         assert_eq!(loaded[0].id, "keep");
     }
+
+    #[test]
+    fn test_update_quicklink_from_path_updates_name_and_url_template() {
+        let dir = tempfile::tempdir().expect("create temp dir");
+        let path = dir.path().join("quicklinks.json");
+        let links = vec![Quicklink {
+            id: "target".to_string(),
+            name: "Old".to_string(),
+            url_template: "https://old.example.com".to_string(),
+            icon: None,
+        }];
+
+        save_quicklinks_to_path(&links, &path).expect("seed quicklinks");
+        let updated = update_quicklink_from_path(
+            "target",
+            " New Name ",
+            " https://new.example.com?q={query} ",
+            &path,
+        );
+
+        assert!(updated);
+        let loaded = load_quicklinks_from_path(&path);
+        assert_eq!(loaded.len(), 1);
+        assert_eq!(loaded[0].name, "New Name");
+        assert_eq!(loaded[0].url_template, "https://new.example.com?q={query}");
+    }
+
+    #[test]
+    fn test_update_quicklink_from_path_returns_false_when_id_not_found() {
+        let dir = tempfile::tempdir().expect("create temp dir");
+        let path = dir.path().join("quicklinks.json");
+        let links = vec![Quicklink {
+            id: "target".to_string(),
+            name: "Keep".to_string(),
+            url_template: "https://example.com".to_string(),
+            icon: None,
+        }];
+
+        save_quicklinks_to_path(&links, &path).expect("seed quicklinks");
+        let updated = update_quicklink_from_path("missing", "Name", "https://updated.example.com", &path);
+
+        assert!(!updated);
+        let loaded = load_quicklinks_from_path(&path);
+        assert_eq!(loaded, links);
+    }
 }

 exited 1 in 2m 07s:
Error: ENOSPC: no space left on device, write

thinking
**Assessing claim block and wait strategy**
file update:
diff --git a/src/builtins/part_001_entries/entries_000.rs b/src/builtins/part_001_entries/entries_000.rs
index 926be9edb8db75488c1894f105dba265b103c614..1b3e861bd2e0390edbd6aafc031907ffa15a7cd5
--- a/src/builtins/part_001_entries/entries_000.rs
+++ b/src/builtins/part_001_entries/entries_000.rs
@@ -69,6 +69,24 @@
     ));
     debug!("Added Notes built-in entry");
 
+    entries.push(BuiltInEntry::new_with_icon(
+        "builtin-quicklinks",
+        "Quicklinks",
+        "Manage quick links and open URLs with optional {query} expansion",
+        vec![
+            "quicklinks",
+            "quicklink",
+            "link",
+            "url",
+            "bookmark",
+            "open",
+            "search",
+        ],
+        BuiltInFeature::Quicklinks,
+        "ðŸ”—",
+    ));
+    debug!("Added Quicklinks built-in entry");
+
     // Design Gallery is only available in debug builds (developer tool)
     #[cfg(debug_assertions)]
     {
diff --git a/src/quicklinks/mod.rs b/src/quicklinks/mod.rs
index 08aeea02e216c8026f59f0d8fe5627ededb1dec0..e9e055c95e2b0cd21fbc8b79971df226a788899c
--- a/src/quicklinks/mod.rs
+++ b/src/quicklinks/mod.rs
@@ -43,6 +43,14 @@
     url_template.replace(QUERY_PLACEHOLDER, query)
 }
 
+pub fn has_query_placeholder(url_template: &str) -> bool {
+    url_template.contains(QUERY_PLACEHOLDER)
+}
+
+pub fn update_quicklink(id: &str, name: &str, url_template: &str) -> bool {
+    update_quicklink_from_path(id, name, url_template, &quicklinks_path())
+}
+
 fn quicklinks_path() -> PathBuf {
     dirs::home_dir()
         .map(|home| home.join(".scriptkit").join(QUICKLINKS_FILE))
@@ -75,11 +83,22 @@
     let _ = save_quicklinks_to_path(&links, path);
 }
 
+fn update_quicklink_from_path(id: &str, name: &str, url_template: &str, path: &Path) -> bool {
+    let mut links = load_quicklinks_from_path(path);
+    if let Some(link) = links.iter_mut().find(|link| link.id == id) {
+        link.name = name.trim().to_string();
+        link.url_template = url_template.trim().to_string();
+        return save_quicklinks_to_path(&links, path).is_ok();
+    }
+
+    false
+}
+
 #[cfg(test)]
 mod tests {
     use super::{
-        create_quicklink, delete_quicklink_from_path, expand_url, load_quicklinks_from_path,
-        save_quicklinks_to_path, Quicklink,
+        create_quicklink, delete_quicklink_from_path, expand_url, has_query_placeholder,
+        load_quicklinks_from_path, save_quicklinks_to_path, update_quicklink_from_path, Quicklink,
     };
 
     #[test]
@@ -105,6 +124,16 @@
     }
 
     #[test]
+    fn test_has_query_placeholder_returns_true_when_template_contains_placeholder() {
+        assert!(has_query_placeholder("https://example.com?q={query}"));
+    }
+
+    #[test]
+    fn test_has_query_placeholder_returns_false_when_template_missing_placeholder() {
+        assert!(!has_query_placeholder("https://example.com"));
+    }
+
+    #[test]
     fn test_load_quicklinks_from_path_returns_empty_when_file_missing() {
         let dir = tempfile::tempdir().expect("create temp dir");
         let path = dir.path().join("quicklinks.json");
@@ -174,4 +203,49 @@
         assert_eq!(loaded.len(), 1);
         assert_eq!(loaded[0].id, "keep");
     }
+
+    #[test]
+    fn test_update_quicklink_from_path_updates_name_and_url_template() {
+        let dir = tempfile::tempdir().expect("create temp dir");
+        let path = dir.path().join("quicklinks.json");
+        let links = vec![Quicklink {
+            id: "target".to_string(),
+            name: "Old".to_string(),
+            url_template: "https://old.example.com".to_string(),
+            icon: None,
+        }];
+
+        save_quicklinks_to_path(&links, &path).expect("seed quicklinks");
+        let updated = update_quicklink_from_path(
+            "target",
+            " New Name ",
+            " https://new.example.com?q={query} ",
+            &path,
+        );
+
+        assert!(updated);
+        let loaded = load_quicklinks_from_path(&path);
+        assert_eq!(loaded.len(), 1);
+        assert_eq!(loaded[0].name, "New Name");
+        assert_eq!(loaded[0].url_template, "https://new.example.com?q={query}");
+    }
+
+    #[test]
+    fn test_update_quicklink_from_path_returns_false_when_id_not_found() {
+        let dir = tempfile::tempdir().expect("create temp dir");
+        let path = dir.path().join("quicklinks.json");
+        let links = vec![Quicklink {
+            id: "target".to_string(),
+            name: "Keep".to_string(),
+            url_template: "https://example.com".to_string(),
+            icon: None,
+        }];
+
+        save_quicklinks_to_path(&links, &path).expect("seed quicklinks");
+        let updated = update_quicklink_from_path("missing", "Name", "https://updated.example.com", &path);
+
+        assert!(!updated);
+        let loaded = load_quicklinks_from_path(&path);
+        assert_eq!(loaded, links);
+    }
 }


thinking
**Identifying failure cause and recovery plan**
codex
One of the queued claim processes failed with `ENOSPC` while waiting, so Iâ€™m re-issuing the failed claim request and continuing to wait for both locked files.

thinking
**Planning retry of claim commands**
exec
/bin/zsh -lc '~/.claude/bin/swarm.ts claim --wait --id codex-wire-quicklinks src/builtins/part_000.rs' in /Users/johnlindquist/dev/script-kit-gpuiexec
/bin/zsh -lc '~/.claude/bin/swarm.ts claim --wait --id codex-wire-quicklinks src/app_execute/builtin_execution.rs' in /Users/johnlindquist/dev/script-kit-gpuifile update:
diff --git a/src/builtins/part_001_entries/entries_000.rs b/src/builtins/part_001_entries/entries_000.rs
index 926be9edb8db75488c1894f105dba265b103c614..1b3e861bd2e0390edbd6aafc031907ffa15a7cd5
--- a/src/builtins/part_001_entries/entries_000.rs
+++ b/src/builtins/part_001_entries/entries_000.rs
@@ -69,6 +69,24 @@
     ));
     debug!("Added Notes built-in entry");
 
+    entries.push(BuiltInEntry::new_with_icon(
+        "builtin-quicklinks",
+        "Quicklinks",
+        "Manage quick links and open URLs with optional {query} expansion",
+        vec![
+            "quicklinks",
+            "quicklink",
+            "link",
+            "url",
+            "bookmark",
+            "open",
+            "search",
+        ],
+        BuiltInFeature::Quicklinks,
+        "ðŸ”—",
+    ));
+    debug!("Added Quicklinks built-in entry");
+
     // Design Gallery is only available in debug builds (developer tool)
     #[cfg(debug_assertions)]
     {
diff --git a/src/quicklinks/mod.rs b/src/quicklinks/mod.rs
index 08aeea02e216c8026f59f0d8fe5627ededb1dec0..e9e055c95e2b0cd21fbc8b79971df226a788899c
--- a/src/quicklinks/mod.rs
+++ b/src/quicklinks/mod.rs
@@ -43,6 +43,14 @@
     url_template.replace(QUERY_PLACEHOLDER, query)
 }
 
+pub fn has_query_placeholder(url_template: &str) -> bool {
+    url_template.contains(QUERY_PLACEHOLDER)
+}
+
+pub fn update_quicklink(id: &str, name: &str, url_template: &str) -> bool {
+    update_quicklink_from_path(id, name, url_template, &quicklinks_path())
+}
+
 fn quicklinks_path() -> PathBuf {
     dirs::home_dir()
         .map(|home| home.join(".scriptkit").join(QUICKLINKS_FILE))
@@ -75,11 +83,22 @@
     let _ = save_quicklinks_to_path(&links, path);
 }
 
+fn update_quicklink_from_path(id: &str, name: &str, url_template: &str, path: &Path) -> bool {
+    let mut links = load_quicklinks_from_path(path);
+    if let Some(link) = links.iter_mut().find(|link| link.id == id) {
+        link.name = name.trim().to_string();
+        link.url_template = url_template.trim().to_string();
+        return save_quicklinks_to_path(&links, path).is_ok();
+    }
+
+    false
+}
+
 #[cfg(test)]
 mod tests {
     use super::{
-        create_quicklink, delete_quicklink_from_path, expand_url, load_quicklinks_from_path,
-        save_quicklinks_to_path, Quicklink,
+        create_quicklink, delete_quicklink_from_path, expand_url, has_query_placeholder,
+        load_quicklinks_from_path, save_quicklinks_to_path, update_quicklink_from_path, Quicklink,
     };
 
     #[test]
@@ -105,6 +124,16 @@
     }
 
     #[test]
+    fn test_has_query_placeholder_returns_true_when_template_contains_placeholder() {
+        assert!(has_query_placeholder("https://example.com?q={query}"));
+    }
+
+    #[test]
+    fn test_has_query_placeholder_returns_false_when_template_missing_placeholder() {
+        assert!(!has_query_placeholder("https://example.com"));
+    }
+
+    #[test]
     fn test_load_quicklinks_from_path_returns_empty_when_file_missing() {
         let dir = tempfile::tempdir().expect("create temp dir");
         let path = dir.path().join("quicklinks.json");
@@ -174,4 +203,49 @@
         assert_eq!(loaded.len(), 1);
         assert_eq!(loaded[0].id, "keep");
     }
+
+    #[test]
+    fn test_update_quicklink_from_path_updates_name_and_url_template() {
+        let dir = tempfile::tempdir().expect("create temp dir");
+        let path = dir.path().join("quicklinks.json");
+        let links = vec![Quicklink {
+            id: "target".to_string(),
+            name: "Old".to_string(),
+            url_template: "https://old.example.com".to_string(),
+            icon: None,
+        }];
+
+        save_quicklinks_to_path(&links, &path).expect("seed quicklinks");
+        let updated = update_quicklink_from_path(
+            "target",
+            " New Name ",
+            " https://new.example.com?q={query} ",
+            &path,
+        );
+
+        assert!(updated);
+        let loaded = load_quicklinks_from_path(&path);
+        assert_eq!(loaded.len(), 1);
+        assert_eq!(loaded[0].name, "New Name");
+        assert_eq!(loaded[0].url_template, "https://new.example.com?q={query}");
+    }
+
+    #[test]
+    fn test_update_quicklink_from_path_returns_false_when_id_not_found() {
+        let dir = tempfile::tempdir().expect("create temp dir");
+        let path = dir.path().join("quicklinks.json");
+        let links = vec![Quicklink {
+            id: "target".to_string(),
+            name: "Keep".to_string(),
+            url_template: "https://example.com".to_string(),
+            icon: None,
+        }];
+
+        save_quicklinks_to_path(&links, &path).expect("seed quicklinks");
+        let updated = update_quicklink_from_path("missing", "Name", "https://updated.example.com", &path);
+
+        assert!(!updated);
+        let loaded = load_quicklinks_from_path(&path);
+        assert_eq!(loaded, links);
+    }
 }


thinking
**Considering session cleanup and polling**
file update:
diff --git a/src/builtins/part_001_entries/entries_000.rs b/src/builtins/part_001_entries/entries_000.rs
index 926be9edb8db75488c1894f105dba265b103c614..1b3e861bd2e0390edbd6aafc031907ffa15a7cd5
--- a/src/builtins/part_001_entries/entries_000.rs
+++ b/src/builtins/part_001_entries/entries_000.rs
@@ -69,6 +69,24 @@
     ));
     debug!("Added Notes built-in entry");
 
+    entries.push(BuiltInEntry::new_with_icon(
+        "builtin-quicklinks",
+        "Quicklinks",
+        "Manage quick links and open URLs with optional {query} expansion",
+        vec![
+            "quicklinks",
+            "quicklink",
+            "link",
+            "url",
+            "bookmark",
+            "open",
+            "search",
+        ],
+        BuiltInFeature::Quicklinks,
+        "ðŸ”—",
+    ));
+    debug!("Added Quicklinks built-in entry");
+
     // Design Gallery is only available in debug builds (developer tool)
     #[cfg(debug_assertions)]
     {
diff --git a/src/quicklinks/mod.rs b/src/quicklinks/mod.rs
index 08aeea02e216c8026f59f0d8fe5627ededb1dec0..e9e055c95e2b0cd21fbc8b79971df226a788899c
--- a/src/quicklinks/mod.rs
+++ b/src/quicklinks/mod.rs
@@ -43,6 +43,14 @@
     url_template.replace(QUERY_PLACEHOLDER, query)
 }
 
+pub fn has_query_placeholder(url_template: &str) -> bool {
+    url_template.contains(QUERY_PLACEHOLDER)
+}
+
+pub fn update_quicklink(id: &str, name: &str, url_template: &str) -> bool {
+    update_quicklink_from_path(id, name, url_template, &quicklinks_path())
+}
+
 fn quicklinks_path() -> PathBuf {
     dirs::home_dir()
         .map(|home| home.join(".scriptkit").join(QUICKLINKS_FILE))
@@ -75,11 +83,22 @@
     let _ = save_quicklinks_to_path(&links, path);
 }
 
+fn update_quicklink_from_path(id: &str, name: &str, url_template: &str, path: &Path) -> bool {
+    let mut links = load_quicklinks_from_path(path);
+    if let Some(link) = links.iter_mut().find(|link| link.id == id) {
+        link.name = name.trim().to_string();
+        link.url_template = url_template.trim().to_string();
+        return save_quicklinks_to_path(&links, path).is_ok();
+    }
+
+    false
+}
+
 #[cfg(test)]
 mod tests {
     use super::{
-        create_quicklink, delete_quicklink_from_path, expand_url, load_quicklinks_from_path,
-        save_quicklinks_to_path, Quicklink,
+        create_quicklink, delete_quicklink_from_path, expand_url, has_query_placeholder,
+        load_quicklinks_from_path, save_quicklinks_to_path, update_quicklink_from_path, Quicklink,
     };
 
     #[test]
@@ -105,6 +124,16 @@
     }
 
     #[test]
+    fn test_has_query_placeholder_returns_true_when_template_contains_placeholder() {
+        assert!(has_query_placeholder("https://example.com?q={query}"));
+    }
+
+    #[test]
+    fn test_has_query_placeholder_returns_false_when_template_missing_placeholder() {
+        assert!(!has_query_placeholder("https://example.com"));
+    }
+
+    #[test]
     fn test_load_quicklinks_from_path_returns_empty_when_file_missing() {
         let dir = tempfile::tempdir().expect("create temp dir");
         let path = dir.path().join("quicklinks.json");
@@ -174,4 +203,49 @@
         assert_eq!(loaded.len(), 1);
         assert_eq!(loaded[0].id, "keep");
     }
+
+    #[test]
+    fn test_update_quicklink_from_path_updates_name_and_url_template() {
+        let dir = tempfile::tempdir().expect("create temp dir");
+        let path = dir.path().join("quicklinks.json");
+        let links = vec![Quicklink {
+            id: "target".to_string(),
+            name: "Old".to_string(),
+            url_template: "https://old.example.com".to_string(),
+            icon: None,
+        }];
+
+        save_quicklinks_to_path(&links, &path).expect("seed quicklinks");
+        let updated = update_quicklink_from_path(
+            "target",
+            " New Name ",
+            " https://new.example.com?q={query} ",
+            &path,
+        );
+
+        assert!(updated);
+        let loaded = load_quicklinks_from_path(&path);
+        assert_eq!(loaded.len(), 1);
+        assert_eq!(loaded[0].name, "New Name");
+        assert_eq!(loaded[0].url_template, "https://new.example.com?q={query}");
+    }
+
+    #[test]
+    fn test_update_quicklink_from_path_returns_false_when_id_not_found() {
+        let dir = tempfile::tempdir().expect("create temp dir");
+        let path = dir.path().join("quicklinks.json");
+        let links = vec![Quicklink {
+            id: "target".to_string(),
+            name: "Keep".to_string(),
+            url_template: "https://example.com".to_string(),
+            icon: None,
+        }];
+
+        save_quicklinks_to_path(&links, &path).expect("seed quicklinks");
+        let updated = update_quicklink_from_path("missing", "Name", "https://updated.example.com", &path);
+
+        assert!(!updated);
+        let loaded = load_quicklinks_from_path(&path);
+        assert_eq!(loaded, links);
+    }
 }


thinking
**Delaying tests pending dependencies**
exec
/bin/zsh -lc '~/.claude/bin/swarm.ts status' in /Users/johnlindquist/dev/script-kit-gpui succeeded in 50ms:
Repo: /Users/johnlindquist/dev/script-kit-gpui
Updated: 2026-02-08T03:03:27.399Z

Active agents (3):
codex-wire-emoji [in_progress] codex/gpt-5.3-codex/exec
  task: Wire up the existing src/emoji/mod.rs static emoji database into the app as a working built-in feature. The module has â€¦
  scope: src/emoji/**,src/builtins/part_000.rs,src/builtins/part_001_entries/**,src/app_execute/builtin_execution.rs
  claims: (none)
  notes: Starting emoji built-in wiring; preparing claims and reading existing emoji + clipboard flow

codex-wire-favorites [in_progress] codex/gpt-5.3-codex/exec
  task: Wire up the existing src/favorites/mod.rs storage module into the app as a working feature. The module already has loadâ€¦
  scope: src/favorites/**,src/builtins/part_000.rs,src/builtins/part_001_entries/**,src/app_execute/builtin_execution.rs,src/actâ€¦
  claims(10): src/builtins/part_000.rs, src/builtins/part_001_entries/entries_003.rs, src/app_execute/builtin_execution.rs, src/actions/builders/script_context.rs, src/app_aâ€¦
  notes: Implementing Favorites builtin, action toggle handler, favorites prefix filter, and list indicator | [claim-wait] codex-wire-quicklinks waiting for src/app_execute/builtin_executiâ€¦

codex-wire-quicklinks [blocked] codex/gpt-5.3-codex/exec
  task: Wire up the existing src/quicklinks/mod.rs storage module into the app as a working built-in feature. The module alreadâ€¦
  scope: src/quicklinks/**,src/builtins/part_000.rs,src/builtins/part_001_entries/**,src/app_execute/builtin_execution.rs
  claims(2): src/builtins/part_001_entries/entries_000.rs, src/quicklinks/mod.rs
file update:
diff --git a/src/builtins/part_001_entries/entries_000.rs b/src/builtins/part_001_entries/entries_000.rs
index 926be9edb8db75488c1894f105dba265b103c614..1b3e861bd2e0390edbd6aafc031907ffa15a7cd5
--- a/src/builtins/part_001_entries/entries_000.rs
+++ b/src/builtins/part_001_entries/entries_000.rs
@@ -69,6 +69,24 @@
     ));
     debug!("Added Notes built-in entry");
 
+    entries.push(BuiltInEntry::new_with_icon(
+        "builtin-quicklinks",
+        "Quicklinks",
+        "Manage quick links and open URLs with optional {query} expansion",
+        vec![
+            "quicklinks",
+            "quicklink",
+            "link",
+            "url",
+            "bookmark",
+            "open",
+            "search",
+        ],
+        BuiltInFeature::Quicklinks,
+        "ðŸ”—",
+    ));
+    debug!("Added Quicklinks built-in entry");
+
     // Design Gallery is only available in debug builds (developer tool)
     #[cfg(debug_assertions)]
     {
diff --git a/src/quicklinks/mod.rs b/src/quicklinks/mod.rs
index 08aeea02e216c8026f59f0d8fe5627ededb1dec0..e9e055c95e2b0cd21fbc8b79971df226a788899c
--- a/src/quicklinks/mod.rs
+++ b/src/quicklinks/mod.rs
@@ -43,6 +43,14 @@
     url_template.replace(QUERY_PLACEHOLDER, query)
 }
 
+pub fn has_query_placeholder(url_template: &str) -> bool {
+    url_template.contains(QUERY_PLACEHOLDER)
+}
+
+pub fn update_quicklink(id: &str, name: &str, url_template: &str) -> bool {
+    update_quicklink_from_path(id, name, url_template, &quicklinks_path())
+}
+
 fn quicklinks_path() -> PathBuf {
     dirs::home_dir()
         .map(|home| home.join(".scriptkit").join(QUICKLINKS_FILE))
@@ -75,11 +83,22 @@
     let _ = save_quicklinks_to_path(&links, path);
 }
 
+fn update_quicklink_from_path(id: &str, name: &str, url_template: &str, path: &Path) -> bool {
+    let mut links = load_quicklinks_from_path(path);
+    if let Some(link) = links.iter_mut().find(|link| link.id == id) {
+        link.name = name.trim().to_string();
+        link.url_template = url_template.trim().to_string();
+        return save_quicklinks_to_path(&links, path).is_ok();
+    }
+
+    false
+}
+
 #[cfg(test)]
 mod tests {
     use super::{
-        create_quicklink, delete_quicklink_from_path, expand_url, load_quicklinks_from_path,
-        save_quicklinks_to_path, Quicklink,
+        create_quicklink, delete_quicklink_from_path, expand_url, has_query_placeholder,
+        load_quicklinks_from_path, save_quicklinks_to_path, update_quicklink_from_path, Quicklink,
     };
 
     #[test]
@@ -105,6 +124,16 @@
     }
 
     #[test]
+    fn test_has_query_placeholder_returns_true_when_template_contains_placeholder() {
+        assert!(has_query_placeholder("https://example.com?q={query}"));
+    }
+
+    #[test]
+    fn test_has_query_placeholder_returns_false_when_template_missing_placeholder() {
+        assert!(!has_query_placeholder("https://example.com"));
+    }
+
+    #[test]
     fn test_load_quicklinks_from_path_returns_empty_when_file_missing() {
         let dir = tempfile::tempdir().expect("create temp dir");
         let path = dir.path().join("quicklinks.json");
@@ -174,4 +203,49 @@
         assert_eq!(loaded.len(), 1);
         assert_eq!(loaded[0].id, "keep");
     }
+
+    #[test]
+    fn test_update_quicklink_from_path_updates_name_and_url_template() {
+        let dir = tempfile::tempdir().expect("create temp dir");
+        let path = dir.path().join("quicklinks.json");
+        let links = vec![Quicklink {
+            id: "target".to_string(),
+            name: "Old".to_string(),
+            url_template: "https://old.example.com".to_string(),
+            icon: None,
+        }];
+
+        save_quicklinks_to_path(&links, &path).expect("seed quicklinks");
+        let updated = update_quicklink_from_path(
+            "target",
+            " New Name ",
+            " https://new.example.com?q={query} ",
+            &path,
+        );
+
+        assert!(updated);
+        let loaded = load_quicklinks_from_path(&path);
+        assert_eq!(loaded.len(), 1);
+        assert_eq!(loaded[0].name, "New Name");
+        assert_eq!(loaded[0].url_template, "https://new.example.com?q={query}");
+    }
+
+    #[test]
+    fn test_update_quicklink_from_path_returns_false_when_id_not_found() {
+        let dir = tempfile::tempdir().expect("create temp dir");
+        let path = dir.path().join("quicklinks.json");
+        let links = vec![Quicklink {
+            id: "target".to_string(),
+            name: "Keep".to_string(),
+            url_template: "https://example.com".to_string(),
+            icon: None,
+        }];
+
+        save_quicklinks_to_path(&links, &path).expect("seed quicklinks");
+        let updated = update_quicklink_from_path("missing", "Name", "https://updated.example.com", &path);
+
+        assert!(!updated);
+        let loaded = load_quicklinks_from_path(&path);
+        assert_eq!(loaded, links);
+    }
 }


thinking
**Assessing push and exhaustive variant handling**
exec
/bin/zsh -lc "rg -n \"match\\s+.*BuiltInFeature|BuiltInFeature::[A-Za-z_]+\" src | head -n 200" in /Users/johnlindquist/dev/script-kit-gpui succeeded in 50ms:
src/app_render/group_header_item.rs:23:        builtins::BuiltInFeature::ClipboardHistory => "Clipboard History Manager".to_string(),
src/app_render/group_header_item.rs:24:        builtins::BuiltInFeature::AppLauncher => "Application Launcher".to_string(),
src/app_render/group_header_item.rs:25:        builtins::BuiltInFeature::App(name) => name.clone(),
src/app_render/group_header_item.rs:26:        builtins::BuiltInFeature::WindowSwitcher => "Window Manager".to_string(),
src/app_render/group_header_item.rs:27:        builtins::BuiltInFeature::DesignGallery => "Design Gallery".to_string(),
src/app_render/group_header_item.rs:28:        builtins::BuiltInFeature::AiChat => "AI Assistant".to_string(),
src/app_render/group_header_item.rs:29:        builtins::BuiltInFeature::Notes => "Notes & Scratchpad".to_string(),
src/app_render/group_header_item.rs:30:        builtins::BuiltInFeature::MenuBarAction(_) => "Menu Bar Action".to_string(),
src/app_render/group_header_item.rs:31:        builtins::BuiltInFeature::SystemAction(_) => "System Action".to_string(),
src/app_render/group_header_item.rs:32:        builtins::BuiltInFeature::NotesCommand(_) => "Notes Command".to_string(),
src/app_render/group_header_item.rs:33:        builtins::BuiltInFeature::AiCommand(_) => "AI Command".to_string(),
src/app_render/group_header_item.rs:34:        builtins::BuiltInFeature::ScriptCommand(_) => "Script Creation".to_string(),
src/app_render/group_header_item.rs:35:        builtins::BuiltInFeature::PermissionCommand(_) => "Permission Management".to_string(),
src/app_render/group_header_item.rs:36:        builtins::BuiltInFeature::FrecencyCommand(_) => "Suggested Items".to_string(),
src/app_render/group_header_item.rs:37:        builtins::BuiltInFeature::UtilityCommand(_) => "Quick Utility".to_string(),
src/app_render/group_header_item.rs:38:        builtins::BuiltInFeature::SettingsCommand(_) => "Settings".to_string(),
src/app_render/group_header_item.rs:39:        builtins::BuiltInFeature::KitStoreCommand(_) => "Kit Store".to_string(),
src/app_render/group_header_item.rs:40:        builtins::BuiltInFeature::FileSearch => "File Browser".to_string(),
src/app_render/group_header_item.rs:41:        builtins::BuiltInFeature::Webcam => "Webcam Capture".to_string(),
src/app_render/tests.rs:37:            builtin_feature_annotation(&BuiltInFeature::FileSearch),
file update:
diff --git a/src/builtins/part_001_entries/entries_000.rs b/src/builtins/part_001_entries/entries_000.rs
index 926be9edb8db75488c1894f105dba265b103c614..1b3e861bd2e0390edbd6aafc031907ffa15a7cd5
--- a/src/builtins/part_001_entries/entries_000.rs
+++ b/src/builtins/part_001_entries/entries_000.rs
@@ -69,6 +69,24 @@
     ));
     debug!("Added Notes built-in entry");
 
+    entries.push(BuiltInEntry::new_with_icon(
+        "builtin-quicklinks",
+        "Quicklinks",
+        "Manage quick links and open URLs with optional {query} expansion",
+        vec![
+            "quicklinks",
+            "quicklink",
+            "link",
+            "url",
+            "bookmark",
+            "open",
+            "search",
+        ],
+        BuiltInFeature::Quicklinks,
+        "ðŸ”—",
+    ));
+    debug!("Added Quicklinks built-in entry");
+
     // Design Gallery is only available in debug builds (developer tool)
     #[cfg(debug_assertions)]
     {
diff --git a/src/quicklinks/mod.rs b/src/quicklinks/mod.rs
index 08aeea02e216c8026f59f0d8fe5627ededb1dec0..e9e055c95e2b0cd21fbc8b79971df226a788899c
--- a/src/quicklinks/mod.rs
+++ b/src/quicklinks/mod.rs
@@ -43,6 +43,14 @@
     url_template.replace(QUERY_PLACEHOLDER, query)
 }
 
+pub fn has_query_placeholder(url_template: &str) -> bool {
+    url_template.contains(QUERY_PLACEHOLDER)
+}
+
+pub fn update_quicklink(id: &str, name: &str, url_template: &str) -> bool {
+    update_quicklink_from_path(id, name, url_template, &quicklinks_path())
+}
+
 fn quicklinks_path() -> PathBuf {
     dirs::home_dir()
         .map(|home| home.join(".scriptkit").join(QUICKLINKS_FILE))
@@ -75,11 +83,22 @@
     let _ = save_quicklinks_to_path(&links, path);
 }
 
+fn update_quicklink_from_path(id: &str, name: &str, url_template: &str, path: &Path) -> bool {
+    let mut links = load_quicklinks_from_path(path);
+    if let Some(link) = links.iter_mut().find(|link| link.id == id) {
+        link.name = name.trim().to_string();
+        link.url_template = url_template.trim().to_string();
+        return save_quicklinks_to_path(&links, path).is_ok();
+    }
+
+    false
+}
+
 #[cfg(test)]
 mod tests {
     use super::{
-        create_quicklink, delete_quicklink_from_path, expand_url, load_quicklinks_from_path,
-        save_quicklinks_to_path, Quicklink,
+        create_quicklink, delete_quicklink_from_path, expand_url, has_query_placeholder,
+        load_quicklinks_from_path, save_quicklinks_to_path, update_quicklink_from_path, Quicklink,
     };
 
     #[test]
@@ -105,6 +124,16 @@
     }
 
     #[test]
+    fn test_has_query_placeholder_returns_true_when_template_contains_placeholder() {
+        assert!(has_query_placeholder("https://example.com?q={query}"));
+    }
+
+    #[test]
+    fn test_has_query_placeholder_returns_false_when_template_missing_placeholder() {
+        assert!(!has_query_placeholder("https://example.com"));
+    }
+
+    #[test]
     fn test_load_quicklinks_from_path_returns_empty_when_file_missing() {
         let dir = tempfile::tempdir().expect("create temp dir");
         let path = dir.path().join("quicklinks.json");
@@ -174,4 +203,49 @@
         assert_eq!(loaded.len(), 1);
         assert_eq!(loaded[0].id, "keep");
     }
+
+    #[test]
+    fn test_update_quicklink_from_path_updates_name_and_url_template() {
+        let dir = tempfile::tempdir().expect("create temp dir");
+        let path = dir.path().join("quicklinks.json");
+        let links = vec![Quicklink {
+            id: "target".to_string(),
+            name: "Old".to_string(),
+            url_template: "https://old.example.com".to_string(),
+            icon: None,
+        }];
+
+        save_quicklinks_to_path(&links, &path).expect("seed quicklinks");
+        let updated = update_quicklink_from_path(
+            "target",
+            " New Name ",
+            " https://new.example.com?q={query} ",
+            &path,
+        );
+
+        assert!(updated);
+        let loaded = load_quicklinks_from_path(&path);
+        assert_eq!(loaded.len(), 1);
+        assert_eq!(loaded[0].name, "New Name");
+        assert_eq!(loaded[0].url_template, "https://new.example.com?q={query}");
+    }
+
+    #[test]
+    fn test_update_quicklink_from_path_returns_false_when_id_not_found() {
+        let dir = tempfile::tempdir().expect("create temp dir");
+        let path = dir.path().join("quicklinks.json");
+        let links = vec![Quicklink {
+            id: "target".to_string(),
+            name: "Keep".to_string(),
+            url_template: "https://example.com".to_string(),
+            icon: None,
+        }];
+
+        save_quicklinks_to_path(&links, &path).expect("seed quicklinks");
+        let updated = update_quicklink_from_path("missing", "Name", "https://updated.example.com", &path);
+
+        assert!(!updated);
+        let loaded = load_quicklinks_from_path(&path);
+        assert_eq!(loaded, links);
+    }
 }

context compacted
Reconnecting... 1/5 (stream disconnected before completion: An error occurred while processing your request. You can retry your request, or contact us through our help center at help.openai.com if the error persists. Please include the request ID 89faa3e4-0aca-424e-a02f-eb01c67392d9 in your message.)

thinking
**Planning scoped verification approach**
codex
Iâ€™m continuing the quicklinks wiring task and will first re-check swarm ownership so I can claim the remaining blocked files before editing. After claims are free, Iâ€™ll complete the built-in enum/execute wiring and run scoped verification.
exec
/bin/zsh -lc '~/.claude/bin/swarm.ts status' in /Users/johnlindquist/dev/script-kit-gpui succeeded in 52ms:
Repo: /Users/johnlindquist/dev/script-kit-gpui
Updated: 2026-02-08T03:04:02.015Z

Active agents (3):
codex-wire-emoji [in_progress] codex/gpt-5.3-codex/exec
  task: Wire up the existing src/emoji/mod.rs static emoji database into the app as a working built-in feature. The module has â€¦
  scope: src/emoji/**,src/builtins/part_000.rs,src/builtins/part_001_entries/**,src/app_execute/builtin_execution.rs
  claims: (none)
  notes: Starting emoji built-in wiring; preparing claims and reading existing emoji + clipboard flow

codex-wire-favorites [in_progress] codex/gpt-5.3-codex/exec
  task: Wire up the existing src/favorites/mod.rs storage module into the app as a working feature. The module already has loadâ€¦
  scope: src/favorites/**,src/builtins/part_000.rs,src/builtins/part_001_entries/**,src/app_execute/builtin_execution.rs,src/actâ€¦
  claims(10): src/builtins/part_000.rs, src/builtins/part_001_entries/entries_003.rs, src/app_execute/builtin_execution.rs, src/actions/builders/script_context.rs, src/app_aâ€¦
  notes: Implementing Favorites builtin, action toggle handler, favorites prefix filter, and list indicator | [claim-wait] codex-wire-quicklinks waiting for src/builtins/part_000.rs

codex-wire-quicklinks [blocked] codex/gpt-5.3-codex/exec
  task: Wire up the existing src/quicklinks/mod.rs storage module into the app as a working built-in feature. The module alreadâ€¦
  scope: src/quicklinks/**,src/builtins/part_000.rs,src/builtins/part_001_entries/**,src/app_execute/builtin_execution.rs
  claims(2): src/builtins/part_001_entries/entries_000.rs, src/quicklinks/mod.rs
file update:
diff --git a/src/builtins/part_001_entries/entries_000.rs b/src/builtins/part_001_entries/entries_000.rs
index 926be9edb8db75488c1894f105dba265b103c614..1b3e861bd2e0390edbd6aafc031907ffa15a7cd5
--- a/src/builtins/part_001_entries/entries_000.rs
+++ b/src/builtins/part_001_entries/entries_000.rs
@@ -69,6 +69,24 @@
     ));
     debug!("Added Notes built-in entry");
 
+    entries.push(BuiltInEntry::new_with_icon(
+        "builtin-quicklinks",
+        "Quicklinks",
+        "Manage quick links and open URLs with optional {query} expansion",
+        vec![
+            "quicklinks",
+            "quicklink",
+            "link",
+            "url",
+            "bookmark",
+            "open",
+            "search",
+        ],
+        BuiltInFeature::Quicklinks,
+        "ðŸ”—",
+    ));
+    debug!("Added Quicklinks built-in entry");
+
     // Design Gallery is only available in debug builds (developer tool)
     #[cfg(debug_assertions)]
     {
diff --git a/src/quicklinks/mod.rs b/src/quicklinks/mod.rs
index 08aeea02e216c8026f59f0d8fe5627ededb1dec0..e9e055c95e2b0cd21fbc8b79971df226a788899c
--- a/src/quicklinks/mod.rs
+++ b/src/quicklinks/mod.rs
@@ -43,6 +43,14 @@
     url_template.replace(QUERY_PLACEHOLDER, query)
 }
 
+pub fn has_query_placeholder(url_template: &str) -> bool {
+    url_template.contains(QUERY_PLACEHOLDER)
+}
+
+pub fn update_quicklink(id: &str, name: &str, url_template: &str) -> bool {
+    update_quicklink_from_path(id, name, url_template, &quicklinks_path())
+}
+
 fn quicklinks_path() -> PathBuf {
     dirs::home_dir()
         .map(|home| home.join(".scriptkit").join(QUICKLINKS_FILE))
@@ -75,11 +83,22 @@
     let _ = save_quicklinks_to_path(&links, path);
 }
 
+fn update_quicklink_from_path(id: &str, name: &str, url_template: &str, path: &Path) -> bool {
+    let mut links = load_quicklinks_from_path(path);
+    if let Some(link) = links.iter_mut().find(|link| link.id == id) {
+        link.name = name.trim().to_string();
+        link.url_template = url_template.trim().to_string();
+        return save_quicklinks_to_path(&links, path).is_ok();
+    }
+
+    false
+}
+
 #[cfg(test)]
 mod tests {
     use super::{
-        create_quicklink, delete_quicklink_from_path, expand_url, load_quicklinks_from_path,
-        save_quicklinks_to_path, Quicklink,
+        create_quicklink, delete_quicklink_from_path, expand_url, has_query_placeholder,
+        load_quicklinks_from_path, save_quicklinks_to_path, update_quicklink_from_path, Quicklink,
     };
 
     #[test]
@@ -105,6 +124,16 @@
     }
 
     #[test]
+    fn test_has_query_placeholder_returns_true_when_template_contains_placeholder() {
+        assert!(has_query_placeholder("https://example.com?q={query}"));
+    }
+
+    #[test]
+    fn test_has_query_placeholder_returns_false_when_template_missing_placeholder() {
+        assert!(!has_query_placeholder("https://example.com"));
+    }
+
+    #[test]
     fn test_load_quicklinks_from_path_returns_empty_when_file_missing() {
         let dir = tempfile::tempdir().expect("create temp dir");
         let path = dir.path().join("quicklinks.json");
@@ -174,4 +203,49 @@
         assert_eq!(loaded.len(), 1);
         assert_eq!(loaded[0].id, "keep");
     }
+
+    #[test]
+    fn test_update_quicklink_from_path_updates_name_and_url_template() {
+        let dir = tempfile::tempdir().expect("create temp dir");
+        let path = dir.path().join("quicklinks.json");
+        let links = vec![Quicklink {
+            id: "target".to_string(),
+            name: "Old".to_string(),
+            url_template: "https://old.example.com".to_string(),
+            icon: None,
+        }];
+
+        save_quicklinks_to_path(&links, &path).expect("seed quicklinks");
+        let updated = update_quicklink_from_path(
+            "target",
+            " New Name ",
+            " https://new.example.com?q={query} ",
+            &path,
+        );
+
+        assert!(updated);
+        let loaded = load_quicklinks_from_path(&path);
+        assert_eq!(loaded.len(), 1);
+        assert_eq!(loaded[0].name, "New Name");
+        assert_eq!(loaded[0].url_template, "https://new.example.com?q={query}");
+    }
+
+    #[test]
+    fn test_update_quicklink_from_path_returns_false_when_id_not_found() {
+        let dir = tempfile::tempdir().expect("create temp dir");
+        let path = dir.path().join("quicklinks.json");
+        let links = vec![Quicklink {
+            id: "target".to_string(),
+            name: "Keep".to_string(),
+            url_template: "https://example.com".to_string(),
+            icon: None,
+        }];
+
+        save_quicklinks_to_path(&links, &path).expect("seed quicklinks");
+        let updated = update_quicklink_from_path("missing", "Name", "https://updated.example.com", &path);
+
+        assert!(!updated);
+        let loaded = load_quicklinks_from_path(&path);
+        assert_eq!(loaded, links);
+    }
 }


thinking
**Assessing file claim conflicts**
codex
I confirmed Iâ€™m still blocked by `codex-wire-favorites` on the two core wiring files. Iâ€™m now checking local diffs so I can finish immediately once claims release.
exec
/bin/zsh -lc 'git status --short' in /Users/johnlindquist/dev/script-kit-gpui succeeded in 52ms:
 M .ai/logs/codex-audit-act-description-quality-v2.final.md
 M .ai/logs/codex-audit-act-execution-builtin.final.md
 M .ai/logs/codex-audit-act-execution-scripts.final.md
 M .ai/logs/codex-audit-act-keyboard-nav.final.md
 M .ai/logs/codex-audit-act-section-grouping.final.md
 M .ai/logs/codex-audit-act-theme-dialog-render.final.md
 M .ai/roster.json
 M src/actions/builders.rs
 M src/actions/builders/chat.rs
 M src/actions/builders/clipboard.rs
 M src/actions/builders/file_path.rs
 M src/actions/builders/notes.rs
 M src/actions/builders/script_context.rs
 M src/actions/builders/scriptlet.rs
 M src/actions/builders/shared.rs
 M src/actions/command_bar/part_01.rs
 M src/actions/command_bar/part_02.rs
 M src/actions/constants.rs
 M src/actions/dialog/part_01.rs
 M src/actions/dialog/part_02/part_01.rs
file update:
diff --git a/src/builtins/part_001_entries/entries_000.rs b/src/builtins/part_001_entries/entries_000.rs
index 926be9edb8db75488c1894f105dba265b103c614..1b3e861bd2e0390edbd6aafc031907ffa15a7cd5
--- a/src/builtins/part_001_entries/entries_000.rs
+++ b/src/builtins/part_001_entries/entries_000.rs
@@ -69,6 +69,24 @@
     ));
     debug!("Added Notes built-in entry");
 
+    entries.push(BuiltInEntry::new_with_icon(
+        "builtin-quicklinks",
+        "Quicklinks",
+        "Manage quick links and open URLs with optional {query} expansion",
+        vec![
+            "quicklinks",
+            "quicklink",
+            "link",
+            "url",
+            "bookmark",
+            "open",
+            "search",
+        ],
+        BuiltInFeature::Quicklinks,
+        "ðŸ”—",
+    ));
+    debug!("Added Quicklinks built-in entry");
+
     // Design Gallery is only available in debug builds (developer tool)
     #[cfg(debug_assertions)]
     {
diff --git a/src/quicklinks/mod.rs b/src/quicklinks/mod.rs
index 08aeea02e216c8026f59f0d8fe5627ededb1dec0..e9e055c95e2b0cd21fbc8b79971df226a788899c
--- a/src/quicklinks/mod.rs
+++ b/src/quicklinks/mod.rs
@@ -43,6 +43,14 @@
     url_template.replace(QUERY_PLACEHOLDER, query)
 }
 
+pub fn has_query_placeholder(url_template: &str) -> bool {
+    url_template.contains(QUERY_PLACEHOLDER)
+}
+
+pub fn update_quicklink(id: &str, name: &str, url_template: &str) -> bool {
+    update_quicklink_from_path(id, name, url_template, &quicklinks_path())
+}
+
 fn quicklinks_path() -> PathBuf {
     dirs::home_dir()
         .map(|home| home.join(".scriptkit").join(QUICKLINKS_FILE))
@@ -75,11 +83,22 @@
     let _ = save_quicklinks_to_path(&links, path);
 }
 
+fn update_quicklink_from_path(id: &str, name: &str, url_template: &str, path: &Path) -> bool {
+    let mut links = load_quicklinks_from_path(path);
+    if let Some(link) = links.iter_mut().find(|link| link.id == id) {
+        link.name = name.trim().to_string();
+        link.url_template = url_template.trim().to_string();
+        return save_quicklinks_to_path(&links, path).is_ok();
+    }
+
+    false
+}
+
 #[cfg(test)]
 mod tests {
     use super::{
-        create_quicklink, delete_quicklink_from_path, expand_url, load_quicklinks_from_path,
-        save_quicklinks_to_path, Quicklink,
+        create_quicklink, delete_quicklink_from_path, expand_url, has_query_placeholder,
+        load_quicklinks_from_path, save_quicklinks_to_path, update_quicklink_from_path, Quicklink,
     };
 
     #[test]
@@ -105,6 +124,16 @@
     }
 
     #[test]
+    fn test_has_query_placeholder_returns_true_when_template_contains_placeholder() {
+        assert!(has_query_placeholder("https://example.com?q={query}"));
+    }
+
+    #[test]
+    fn test_has_query_placeholder_returns_false_when_template_missing_placeholder() {
+        assert!(!has_query_placeholder("https://example.com"));
+    }
+
+    #[test]
     fn test_load_quicklinks_from_path_returns_empty_when_file_missing() {
         let dir = tempfile::tempdir().expect("create temp dir");
         let path = dir.path().join("quicklinks.json");
@@ -174,4 +203,49 @@
         assert_eq!(loaded.len(), 1);
         assert_eq!(loaded[0].id, "keep");
     }
+
+    #[test]
+    fn test_update_quicklink_from_path_updates_name_and_url_template() {
+        let dir = tempfile::tempdir().expect("create temp dir");
+        let path = dir.path().join("quicklinks.json");
+        let links = vec![Quicklink {
+            id: "target".to_string(),
+            name: "Old".to_string(),
+            url_template: "https://old.example.com".to_string(),
+            icon: None,
+        }];
+
+        save_quicklinks_to_path(&links, &path).expect("seed quicklinks");
+        let updated = update_quicklink_from_path(
+            "target",
+            " New Name ",
+            " https://new.example.com?q={query} ",
+            &path,
+        );
+
+        assert!(updated);
+        let loaded = load_quicklinks_from_path(&path);
+        assert_eq!(loaded.len(), 1);
+        assert_eq!(loaded[0].name, "New Name");
+        assert_eq!(loaded[0].url_template, "https://new.example.com?q={query}");
+    }
+
+    #[test]
+    fn test_update_quicklink_from_path_returns_false_when_id_not_found() {
+        let dir = tempfile::tempdir().expect("create temp dir");
+        let path = dir.path().join("quicklinks.json");
+        let links = vec![Quicklink {
+            id: "target".to_string(),
+            name: "Keep".to_string(),
+            url_template: "https://example.com".to_string(),
+            icon: None,
+        }];
+
+        save_quicklinks_to_path(&links, &path).expect("seed quicklinks");
+        let updated = update_quicklink_from_path("missing", "Name", "https://updated.example.com", &path);
+
+        assert!(!updated);
+        let loaded = load_quicklinks_from_path(&path);
+        assert_eq!(loaded, links);
+    }
 }


thinking
**Assessing existing quicklinks integration**
codex
The tree is very active with many unrelated edits, so Iâ€™ll isolate only quicklinks-related hunks. Iâ€™m now reading the target files to see whether other agents already added overlapping enum/dispatch changes.
exec
/bin/zsh -lc 'rg -n "Quicklinks|quicklinks" src/builtins/part_000.rs src/app_execute/builtin_execution.rs src/app_render/group_header_item.rs src/builtins/part_001_entries/entries_000.rs src/quicklinks/mod.rs' in /Users/johnlindquist/dev/script-kit-gpuiexec
/bin/zsh -lc "sed -n '1,220p' src/builtins/part_000.rs" in /Users/johnlindquist/dev/script-kit-gpuiexec
/bin/zsh -lc "sed -n '1,260p' src/app_execute/builtin_execution.rs" in /Users/johnlindquist/dev/script-kit-gpui succeeded in 51ms:
src/builtins/part_001_entries/entries_000.rs:73:        "builtin-quicklinks",
src/builtins/part_001_entries/entries_000.rs:74:        "Quicklinks",
src/builtins/part_001_entries/entries_000.rs:77:            "quicklinks",
src/builtins/part_001_entries/entries_000.rs:85:        BuiltInFeature::Quicklinks,
src/builtins/part_001_entries/entries_000.rs:88:    debug!("Added Quicklinks built-in entry");
src/quicklinks/mod.rs:1://! Quicklinks data model and JSON storage.
src/quicklinks/mod.rs:9:const QUICKLINKS_FILE: &str = "quicklinks.json";
src/quicklinks/mod.rs:21:pub fn load_quicklinks() -> Vec<Quicklink> {
src/quicklinks/mod.rs:22:    load_quicklinks_from_path(&quicklinks_path())
src/quicklinks/mod.rs:25:pub fn save_quicklinks(links: &[Quicklink]) {
src/quicklinks/mod.rs:26:    let _ = save_quicklinks_to_path(links, &quicklinks_path());
src/quicklinks/mod.rs:39:    delete_quicklink_from_path(id, &quicklinks_path());
src/quicklinks/mod.rs:51:    update_quicklink_from_path(id, name, url_template, &quicklinks_path())
src/quicklinks/mod.rs:54:fn quicklinks_path() -> PathBuf {
src/quicklinks/mod.rs:60:fn load_quicklinks_from_path(path: &Path) -> Vec<Quicklink> {
src/quicklinks/mod.rs:69:fn save_quicklinks_to_path(links: &[Quicklink], path: &Path) -> std::io::Result<()> {
src/quicklinks/mod.rs:81:    let mut links = load_quicklinks_from_path(path);
src/quicklinks/mod.rs:83:    let _ = save_quicklinks_to_path(&links, path);
src/quicklinks/mod.rs:87:    let mut links = load_quicklinks_from_path(path);
src/quicklinks/mod.rs:91:        return save_quicklinks_to_path(&links, path).is_ok();
 succeeded in 51ms:
use crate::config::BuiltInConfig;
use crate::menu_bar::MenuBarItem;
use tracing::debug;
// ============================================================================
// Command Type Enums
// ============================================================================

/// System action types for macOS system commands
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum SystemActionType {
    // Power management
    EmptyTrash,
    LockScreen,
    Sleep,
    Restart,
    ShutDown,
    LogOut,

    // UI controls
    ToggleDarkMode,
 succeeded in 51ms:
fn ai_open_failure_message(error: impl std::fmt::Display) -> String {
    format!("Failed to open AI: {}", error)
}

impl ScriptListApp {
    fn system_action_feedback_message(
        &self,
        action_type: &builtins::SystemActionType,
    ) -> Option<String> {
        let dark_mode_enabled = if matches!(action_type, builtins::SystemActionType::ToggleDarkMode)
        {
            system_actions::is_dark_mode().ok()
        } else {
            None
        };

        builtins::system_action_hud_message(*action_type, dark_mode_enabled)
    }

    fn execute_builtin(&mut self, entry: &builtins::BuiltInEntry, cx: &mut Context<Self>) {
file update:
diff --git a/src/builtins/part_001_entries/entries_000.rs b/src/builtins/part_001_entries/entries_000.rs
index 926be9edb8db75488c1894f105dba265b103c614..1b3e861bd2e0390edbd6aafc031907ffa15a7cd5
--- a/src/builtins/part_001_entries/entries_000.rs
+++ b/src/builtins/part_001_entries/entries_000.rs
@@ -69,6 +69,24 @@
     ));
     debug!("Added Notes built-in entry");
 
+    entries.push(BuiltInEntry::new_with_icon(
+        "builtin-quicklinks",
+        "Quicklinks",
+        "Manage quick links and open URLs with optional {query} expansion",
+        vec![
+            "quicklinks",
+            "quicklink",
+            "link",
+            "url",
+            "bookmark",
+            "open",
+            "search",
+        ],
+        BuiltInFeature::Quicklinks,
+        "ðŸ”—",
+    ));
+    debug!("Added Quicklinks built-in entry");
+
     // Design Gallery is only available in debug builds (developer tool)
     #[cfg(debug_assertions)]
     {
diff --git a/src/quicklinks/mod.rs b/src/quicklinks/mod.rs
index 08aeea02e216c8026f59f0d8fe5627ededb1dec0..e9e055c95e2b0cd21fbc8b79971df226a788899c
--- a/src/quicklinks/mod.rs
+++ b/src/quicklinks/mod.rs
@@ -43,6 +43,14 @@
     url_template.replace(QUERY_PLACEHOLDER, query)
 }
 
+pub fn has_query_placeholder(url_template: &str) -> bool {
+    url_template.contains(QUERY_PLACEHOLDER)
+}
+
+pub fn update_quicklink(id: &str, name: &str, url_template: &str) -> bool {
+    update_quicklink_from_path(id, name, url_template, &quicklinks_path())
+}
+
 fn quicklinks_path() -> PathBuf {
     dirs::home_dir()
         .map(|home| home.join(".scriptkit").join(QUICKLINKS_FILE))
@@ -75,11 +83,22 @@
     let _ = save_quicklinks_to_path(&links, path);
 }
 
+fn update_quicklink_from_path(id: &str, name: &str, url_template: &str, path: &Path) -> bool {
+    let mut links = load_quicklinks_from_path(path);
+    if let Some(link) = links.iter_mut().find(|link| link.id == id) {
+        link.name = name.trim().to_string();
+        link.url_template = url_template.trim().to_string();
+        return save_quicklinks_to_path(&links, path).is_ok();
+    }
+
+    false
+}
+
 #[cfg(test)]
 mod tests {
     use super::{
-        create_quicklink, delete_quicklink_from_path, expand_url, load_quicklinks_from_path,
-        save_quicklinks_to_path, Quicklink,
+        create_quicklink, delete_quicklink_from_path, expand_url, has_query_placeholder,
+        load_quicklinks_from_path, save_quicklinks_to_path, update_quicklink_from_path, Quicklink,
     };
 
     #[test]
@@ -105,6 +124,16 @@
     }
 
     #[test]
+    fn test_has_query_placeholder_returns_true_when_template_contains_placeholder() {
+        assert!(has_query_placeholder("https://example.com?q={query}"));
+    }
+
+    #[test]
+    fn test_has_query_placeholder_returns_false_when_template_missing_placeholder() {
+        assert!(!has_query_placeholder("https://example.com"));
+    }
+
+    #[test]
     fn test_load_quicklinks_from_path_returns_empty_when_file_missing() {
         let dir = tempfile::tempdir().expect("create temp dir");
         let path = dir.path().join("quicklinks.json");
@@ -174,4 +203,49 @@
         assert_eq!(loaded.len(), 1);
         assert_eq!(loaded[0].id, "keep");
     }
+
+    #[test]
+    fn test_update_quicklink_from_path_updates_name_and_url_template() {
+        let dir = tempfile::tempdir().expect("create temp dir");
+        let path = dir.path().join("quicklinks.json");
+        let links = vec![Quicklink {
+            id: "target".to_string(),
+            name: "Old".to_string(),
+            url_template: "https://old.example.com".to_string(),
+            icon: None,
+        }];
+
+        save_quicklinks_to_path(&links, &path).expect("seed quicklinks");
+        let updated = update_quicklink_from_path(
+            "target",
+            " New Name ",
+            " https://new.example.com?q={query} ",
+            &path,
+        );
+
+        assert!(updated);
+        let loaded = load_quicklinks_from_path(&path);
+        assert_eq!(loaded.len(), 1);
+        assert_eq!(loaded[0].name, "New Name");
+        assert_eq!(loaded[0].url_template, "https://new.example.com?q={query}");
+    }
+
+    #[test]
+    fn test_update_quicklink_from_path_returns_false_when_id_not_found() {
+        let dir = tempfile::tempdir().expect("create temp dir");
+        let path = dir.path().join("quicklinks.json");
+        let links = vec![Quicklink {
+            id: "target".to_string(),
+            name: "Keep".to_string(),
+            url_template: "https://example.com".to_string(),
+            icon: None,
+        }];
+
+        save_quicklinks_to_path(&links, &path).expect("seed quicklinks");
+        let updated = update_quicklink_from_path("missing", "Name", "https://updated.example.com", &path);
+
+        assert!(!updated);
+        let loaded = load_quicklinks_from_path(&path);
+        assert_eq!(loaded, links);
+    }
 }


thinking
**Planning concurrent claim management**
codex
I verified quicklinks references are present only in the module and entry list so far; enum and execute dispatch still need wiring. Iâ€™m now re-attempting claims on the blocked files so I can proceed with implementation.
exec
/bin/zsh -lc "ps -ax -o pid,command | rg 'swarm.ts claim --wait --id codex-wire-quicklinks'" in /Users/johnlindquist/dev/script-kit-gpui succeeded in 52ms:
  944 bun /Users/johnlindquist/.claude/bin/swarm.ts claim --wait --id codex-wire-quicklinks src/builtins/part_000.rs
 7914 bun /Users/johnlindquist/.claude/bin/swarm.ts claim --wait --id codex-wire-quicklinks src/builtins/part_000.rs
 7918 bun /Users/johnlindquist/.claude/bin/swarm.ts claim --wait --id codex-wire-quicklinks src/app_execute/builtin_execution.rs
12810 /bin/zsh -lc ps -ax -o pid,command | rg 'swarm.ts claim --wait --id codex-wire-quicklinks'
12816 rg swarm.ts claim --wait --id codex-wire-quicklinks
96435 node /Users/johnlindquist/.bun/bin/codex exec --cd /Users/johnlindquist/dev/script-kit-gpui --model gpt-5.3-codex -c model_reasoning_effort="xhigh" -c model_auto_compact_token_limit=120000 -c developer_instructions="You are Codex implementer agent \"codex-wire-quicklinks\".\n\n## Coordination\nThis repo runs parallel agents in ONE working tree. Before editing any file, you MUST claim it.\nCommands (run via shell):\n  - View roster: ~/.claude/bin/swarm.ts status\n  - Claim files (blocks until free): ~/.claude/bin/swarm.ts claim --wait --id codex-wire-quicklinks path/to/file\n  - Release: ~/.claude/bin/swarm.ts release --id codex-wire-quicklinks path/to/file\n  - Update status/notes: ~/.claude/bin/swarm.ts update --id codex-wire-quicklinks --status in_progress --notes \"...\"\nRules:\n  - Never edit a file you haven't claimed.\n  - Keep claims tight (claim only what you're actively changing).\n  - If blocked, set status=blocked and say what you're waiting on.\n  - When finished, set status=done and release claims.\n\n## Development practices (this code is maintained by AI agents)\n  - Log state transitions with enough context to diagnose failures from logs alone.\n  - Structured errors: include what was attempted, what failed, and current state.\n  - Name things for grepability â€” unique identifiers agents can find on the first search.\n  - Every behavior change gets a test. Untested code is invisible to the next agent.\n  - Test names describe the scenario: test_X_does_Y_when_Z.\n  - Keep functions small and single-purpose. 500-line functions burn agent context.\n  - Use types to encode constraints (enums > strings for errors).\n\n## CRITICAL: Parallel-safe verification\n  - Other agents are modifying other files RIGHT NOW. Full test suites WILL show their failures.\n  - ONLY run tests that cover YOUR changed files. Scope every test/check command:\n    Rust: cargo test -p your-crate -- module::test_name | JS: npx jest your/file.test.ts\n  - Do NOT run: cargo test (unscoped), cargo check (whole workspace), npm test (unscoped).\n  - If a scoped test fails, it's YOUR bug â€” fix it. If tests outside your scope fail, ignore them.\n\n## Git commit discipline\n  - NEVER commit unverified work. Run tests/lints/type-checks FIRST. If it fails, fix it before committing.\n  - A commit is a declaration: \"this works and here's the proof.\"\n  - Commit FREQUENTLY â€” after each meaningful unit of VERIFIED work, not just at the end.\n  - A \"unit\" = one logical change that passes verification (new function, bug fix, refactor, test added).\n  - NEVER batch an entire task into one giant commit. Small commits are searchable; big ones aren't.\n  - Commit message format:\n      Line 1: <type>(<scope>): <what changed> (imperative, max 72 chars)\n      Line 3+: WHY this change was made, WHAT was verified, and HOW to test it.\n    Types: feat, fix, refactor, test, docs, chore\n    Example:\n      feat(auth): add refresh token rotation\n      \n      Tokens now rotate on each refresh call to prevent replay attacks.\n      The old token is invalidated immediately on rotation.\n      \n      Verified: cargo test --lib -- auth::refresh (4 tests pass)\n      Verified: manual smoke test via curl â€” token rotates, old token returns 401\n  - The \"Verified:\" lines are REQUIRED. Future agents will read git log to understand\n    what was tested and how to re-verify. This is the most valuable part of the message.\n  - In your final message, list all commits you made with their hashes.\n\n## Time budget\nYou have approximately 10 minutes. If your task is too broad to complete in time:\n(1) Commit any verified progress.\n(2) Run: ~/.claude/bin/swarm.ts update --id YOUR_ID --status needs_split --notes 'suggest: 1) sub-task-desc scope:files 2) sub-task-desc scope:files'.\n(3) Exit cleanly. The dispatcher will read your suggestions and spawn narrower workers." --output-last-message /Users/johnlindquist/dev/script-kit-gpui/.ai/logs/codex-wire-quicklinks.final.md --yolo You are agent codex-wire-quicklinks.\012\012Current parallel-agent roster (read this first):\012```\012SWARM SNAPSHOT @ 2026-02-08T02:57:24.003Z\012- codex-wire-favorites [in_progress] scope=src/favorites/**,src/builtins/part_000.rs,src/builtins/part_001_entries/**,src/app_execute/builtin_execution.rs,src/actions/builders/script_context.rs task=Wire up the existing src/favorites/mod.rs storage module into the app as a working feature. The module already has loadâ€¦\012  notes: Inspecting favorites wiring points and planning minimal scoped edits\012- codex-wire-quicklinks [starting] scope=src/quicklinks/**,src/builtins/part_000.rs,src/builtins/part_001_entries/**,src/app_execute/builtin_execution.rs task=Wire up the existing src/quicklinks/mod.rs storage module into the app as a working built-in feature. The module alreadâ€¦\012```\012\012Your assignment:\012- Task: Wire up the existing src/quicklinks/mod.rs storage module into the app as a working built-in feature. The module already has create/load/save/delete/expand_url APIs backed by ~/.scriptkit/quicklinks.json. You need to: (1) Add a BuiltInFeature::Quicklinks variant in src/builtins/part_000.rs with a descriptive entry in get_builtin_entries(), (2) Add execute_builtin handling in src/app_execute/builtin_execution.rs that shows a list of quicklinks, (3) Allow users to add/edit/delete quicklinks and open them (expanding {query} placeholders). The UI should list existing quicklinks and have an option to create new ones. Run cargo check && cargo clippy --all-targets -- -D warnings && cargo test after changes.\012- Scope: src/quicklinks/**,src/builtins/part_000.rs,src/builtins/part_001_entries/**,src/app_execute/builtin_execution.rs\012\012Operating constraints:\012- Single working tree (no worktrees, no patches).\012- You MUST claim files before editing (~/.claude/bin/swarm.ts claim --wait ...).\012\012Deliverables:\012- Make the code changes required by the task.\012- Run the most relevant tests/linters.\012- In your FINAL message, include: changed files, how to test, and any risks/known gaps.
96466 /Users/johnlindquist/.bun/install/global/node_modules/@openai/codex/vendor/aarch64-apple-darwin/codex/codex exec --cd /Users/johnlindquist/dev/script-kit-gpui --model gpt-5.3-codex -c model_reasoning_effort="xhigh" -c model_auto_compact_token_limit=120000 -c developer_instructions="You are Codex implementer agent \"codex-wire-quicklinks\".\n\n## Coordination\nThis repo runs parallel agents in ONE working tree. Before editing any file, you MUST claim it.\nCommands (run via shell):\n  - View roster: ~/.claude/bin/swarm.ts status\n  - Claim files (blocks until free): ~/.claude/bin/swarm.ts claim --wait --id codex-wire-quicklinks path/to/file\n  - Release: ~/.claude/bin/swarm.ts release --id codex-wire-quicklinks path/to/file\n  - Update status/notes: ~/.claude/bin/swarm.ts update --id codex-wire-quicklinks --status in_progress --notes \"...\"\nRules:\n  - Never edit a file you haven't claimed.\n  - Keep claims tight (claim only what you're actively changing).\n  - If blocked, set status=blocked and say what you're waiting on.\n  - When finished, set status=done and release claims.\n\n## Development practices (this code is maintained by AI agents)\n  - Log state transitions with enough context to diagnose failures from logs alone.\n  - Structured errors: include what was attempted, what failed, and current state.\n  - Name things for grepability â€” unique identifiers agents can find on the first search.\n  - Every behavior change gets a test. Untested code is invisible to the next agent.\n  - Test names describe the scenario: test_X_does_Y_when_Z.\n  - Keep functions small and single-purpose. 500-line functions burn agent context.\n  - Use types to encode constraints (enums > strings for errors).\n\n## CRITICAL: Parallel-safe verification\n  - Other agents are modifying other files RIGHT NOW. Full test suites WILL show their failures.\n  - ONLY run tests that cover YOUR changed files. Scope every test/check command:\n    Rust: cargo test -p your-crate -- module::test_name | JS: npx jest your/file.test.ts\n  - Do NOT run: cargo test (unscoped), cargo check (whole workspace), npm test (unscoped).\n  - If a scoped test fails, it's YOUR bug â€” fix it. If tests outside your scope fail, ignore them.\n\n## Git commit discipline\n  - NEVER commit unverified work. Run tests/lints/type-checks FIRST. If it fails, fix it before committing.\n  - A commit is a declaration: \"this works and here's the proof.\"\n  - Commit FREQUENTLY â€” after each meaningful unit of VERIFIED work, not just at the end.\n  - A \"unit\" = one logical change that passes verification (new function, bug fix, refactor, test added).\n  - NEVER batch an entire task into one giant commit. Small commits are searchable; big ones aren't.\n  - Commit message format:\n      Line 1: <type>(<scope>): <what changed> (imperative, max 72 chars)\n      Line 3+: WHY this change was made, WHAT was verified, and HOW to test it.\n    Types: feat, fix, refactor, test, docs, chore\n    Example:\n      feat(auth): add refresh token rotation\n      \n      Tokens now rotate on each refresh call to prevent replay attacks.\n      The old token is invalidated immediately on rotation.\n      \n      Verified: cargo test --lib -- auth::refresh (4 tests pass)\n      Verified: manual smoke test via curl â€” token rotates, old token returns 401\n  - The \"Verified:\" lines are REQUIRED. Future agents will read git log to understand\n    what was tested and how to re-verify. This is the most valuable part of the message.\n  - In your final message, list all commits you made with their hashes.\n\n## Time budget\nYou have approximately 10 minutes. If your task is too broad to complete in time:\n(1) Commit any verified progress.\n(2) Run: ~/.claude/bin/swarm.ts update --id YOUR_ID --status needs_split --notes 'suggest: 1) sub-task-desc scope:files 2) sub-task-desc scope:files'.\n(3) Exit cleanly. The dispatcher will read your suggestions and spawn narrower workers." --output-last-message /Users/johnlindquist/dev/script-kit-gpui/.ai/logs/codex-wire-quicklinks.final.md --yolo You are agent codex-wire-quicklinks.\012\012Current parallel-agent roster (read this first):\012```\012SWARM SNAPSHOT @ 2026-02-08T02:57:24.003Z\012- codex-wire-favorites [in_progress] scope=src/favorites/**,src/builtins/part_000.rs,src/builtins/part_001_entries/**,src/app_execute/builtin_execution.rs,src/actions/builders/script_context.rs task=Wire up the existing src/favorites/mod.rs storage module into the app as a working feature. The module already has loadâ€¦\012  notes: Inspecting favorites wiring points and planning minimal scoped edits\012- codex-wire-quicklinks [starting] scope=src/quicklinks/**,src/builtins/part_000.rs,src/builtins/part_001_entries/**,src/app_execute/builtin_execution.rs task=Wire up the existing src/quicklinks/mod.rs storage module into the app as a working built-in feature. The module alreadâ€¦\012```\012\012Your assignment:\012- Task: Wire up the existing src/quicklinks/mod.rs storage module into the app as a working built-in feature. The module already has create/load/save/delete/expand_url APIs backed by ~/.scriptkit/quicklinks.json. You need to: (1) Add a BuiltInFeature::Quicklinks variant in src/builtins/part_000.rs with a descriptive entry in get_builtin_entries(), (2) Add execute_builtin handling in src/app_execute/builtin_execution.rs that shows a list of quicklinks, (3) Allow users to add/edit/delete quicklinks and open them (expanding {query} placeholders). The UI should list existing quicklinks and have an option to create new ones. Run cargo check && cargo clippy --all-targets -- -D warnings && cargo test after changes.\012- Scope: src/quicklinks/**,src/builtins/part_000.rs,src/builtins/part_001_entries/**,src/app_execute/builtin_execution.rs\012\012Operating constraints:\012- Single working tree (no worktrees, no patches).\012- You MUST claim files before editing (~/.claude/bin/swarm.ts claim --wait ...).\012\012Deliverables:\012- Make the code changes required by the task.\012- Run the most relevant tests/linters.\012- In your FINAL message, include: changed files, how to test, and any risks/known gaps.
file update:
diff --git a/src/builtins/part_001_entries/entries_000.rs b/src/builtins/part_001_entries/entries_000.rs
index 926be9edb8db75488c1894f105dba265b103c614..1b3e861bd2e0390edbd6aafc031907ffa15a7cd5
--- a/src/builtins/part_001_entries/entries_000.rs
+++ b/src/builtins/part_001_entries/entries_000.rs
@@ -69,6 +69,24 @@
     ));
     debug!("Added Notes built-in entry");
 
+    entries.push(BuiltInEntry::new_with_icon(
+        "builtin-quicklinks",
+        "Quicklinks",
+        "Manage quick links and open URLs with optional {query} expansion",
+        vec![
+            "quicklinks",
+            "quicklink",
+            "link",
+            "url",
+            "bookmark",
+            "open",
+            "search",
+        ],
+        BuiltInFeature::Quicklinks,
+        "ðŸ”—",
+    ));
+    debug!("Added Quicklinks built-in entry");
+
     // Design Gallery is only available in debug builds (developer tool)
     #[cfg(debug_assertions)]
     {
diff --git a/src/quicklinks/mod.rs b/src/quicklinks/mod.rs
index 08aeea02e216c8026f59f0d8fe5627ededb1dec0..e9e055c95e2b0cd21fbc8b79971df226a788899c
--- a/src/quicklinks/mod.rs
+++ b/src/quicklinks/mod.rs
@@ -43,6 +43,14 @@
     url_template.replace(QUERY_PLACEHOLDER, query)
 }
 
+pub fn has_query_placeholder(url_template: &str) -> bool {
+    url_template.contains(QUERY_PLACEHOLDER)
+}
+
+pub fn update_quicklink(id: &str, name: &str, url_template: &str) -> bool {
+    update_quicklink_from_path(id, name, url_template, &quicklinks_path())
+}
+
 fn quicklinks_path() -> PathBuf {
     dirs::home_dir()
         .map(|home| home.join(".scriptkit").join(QUICKLINKS_FILE))
@@ -75,11 +83,22 @@
     let _ = save_quicklinks_to_path(&links, path);
 }
 
+fn update_quicklink_from_path(id: &str, name: &str, url_template: &str, path: &Path) -> bool {
+    let mut links = load_quicklinks_from_path(path);
+    if let Some(link) = links.iter_mut().find(|link| link.id == id) {
+        link.name = name.trim().to_string();
+        link.url_template = url_template.trim().to_string();
+        return save_quicklinks_to_path(&links, path).is_ok();
+    }
+
+    false
+}
+
 #[cfg(test)]
 mod tests {
     use super::{
-        create_quicklink, delete_quicklink_from_path, expand_url, load_quicklinks_from_path,
-        save_quicklinks_to_path, Quicklink,
+        create_quicklink, delete_quicklink_from_path, expand_url, has_query_placeholder,
+        load_quicklinks_from_path, save_quicklinks_to_path, update_quicklink_from_path, Quicklink,
     };
 
     #[test]
@@ -105,6 +124,16 @@
     }
 
     #[test]
+    fn test_has_query_placeholder_returns_true_when_template_contains_placeholder() {
+        assert!(has_query_placeholder("https://example.com?q={query}"));
+    }
+
+    #[test]
+    fn test_has_query_placeholder_returns_false_when_template_missing_placeholder() {
+        assert!(!has_query_placeholder("https://example.com"));
+    }
+
+    #[test]
     fn test_load_quicklinks_from_path_returns_empty_when_file_missing() {
         let dir = tempfile::tempdir().expect("create temp dir");
         let path = dir.path().join("quicklinks.json");
@@ -174,4 +203,49 @@
         assert_eq!(loaded.len(), 1);
         assert_eq!(loaded[0].id, "keep");
     }
+
+    #[test]
+    fn test_update_quicklink_from_path_updates_name_and_url_template() {
+        let dir = tempfile::tempdir().expect("create temp dir");
+        let path = dir.path().join("quicklinks.json");
+        let links = vec![Quicklink {
+            id: "target".to_string(),
+            name: "Old".to_string(),
+            url_template: "https://old.example.com".to_string(),
+            icon: None,
+        }];
+
+        save_quicklinks_to_path(&links, &path).expect("seed quicklinks");
+        let updated = update_quicklink_from_path(
+            "target",
+            " New Name ",
+            " https://new.example.com?q={query} ",
+            &path,
+        );
+
+        assert!(updated);
+        let loaded = load_quicklinks_from_path(&path);
+        assert_eq!(loaded.len(), 1);
+        assert_eq!(loaded[0].name, "New Name");
+        assert_eq!(loaded[0].url_template, "https://new.example.com?q={query}");
+    }
+
+    #[test]
+    fn test_update_quicklink_from_path_returns_false_when_id_not_found() {
+        let dir = tempfile::tempdir().expect("create temp dir");
+        let path = dir.path().join("quicklinks.json");
+        let links = vec![Quicklink {
+            id: "target".to_string(),
+            name: "Keep".to_string(),
+            url_template: "https://example.com".to_string(),
+            icon: None,
+        }];
+
+        save_quicklinks_to_path(&links, &path).expect("seed quicklinks");
+        let updated = update_quicklink_from_path("missing", "Name", "https://updated.example.com", &path);
+
+        assert!(!updated);
+        let loaded = load_quicklinks_from_path(&path);
+        assert_eq!(loaded, links);
+    }
 }


thinking
**Assessing claim process management**
codex
I found multiple lingering `claim --wait` processes from earlier attempts; theyâ€™re harmless but indicate weâ€™re still waiting on file ownership. While blocked, Iâ€™m mapping existing quicklinks references to reuse existing UI/list patterns and minimize invasive changes.
exec
/bin/zsh -lc 'rg -n "quicklinks|Quicklinks|Quicklink" src | head -n 200' in /Users/johnlindquist/dev/script-kit-gpui succeeded in 51ms:
src/builtins/part_001_entries/entries_000.rs:73:        "builtin-quicklinks",
src/builtins/part_001_entries/entries_000.rs:74:        "Quicklinks",
src/builtins/part_001_entries/entries_000.rs:77:            "quicklinks",
src/builtins/part_001_entries/entries_000.rs:85:        BuiltInFeature::Quicklinks,
src/builtins/part_001_entries/entries_000.rs:88:    debug!("Added Quicklinks built-in entry");
src/setup/part_000.rs:32:    include_str!("../../kit-init/extensions/quicklinks/main.md");
src/setup/part_000.rs:33:/// Embedded Quick Links shared actions (built-in actions for all quicklinks scriptlets)
src/setup/part_000.rs:35:    include_str!("../../kit-init/extensions/quicklinks/main.actions.md");
src/setup/part_006.rs:335:        let quicklinks_dir = kit_dir.join("quicklinks").join("extensions");
src/setup/part_006.rs:337:            quicklinks_dir.exists(),
src/setup/part_006.rs:338:            "kit/quicklinks/extensions/ should exist"
src/setup/part_006.rs:340:        let quicklinks_extension = quicklinks_dir.join("main.md");
src/setup/part_006.rs:342:            quicklinks_extension.exists(),
src/setup/part_006.rs:343:            "kit/quicklinks/extensions/main.md should exist"
src/setup/part_006.rs:345:        let quicklinks_content = fs::read_to_string(&quicklinks_extension).unwrap();
src/setup/part_006.rs:347:            quicklinks_content.contains("Quick Links"),
src/setup/part_006.rs:351:            quicklinks_content.contains("https://github.com"),
src/setup/part_006.rs:355:            quicklinks_content.contains("https://www.google.com"),
src/setup/part_003.rs:83:        kit_dir.join("kit").join("quicklinks").join("extensions"),
src/setup/part_003.rs:151:    let quicklinks_path = kit_dir
file update:
diff --git a/src/builtins/part_001_entries/entries_000.rs b/src/builtins/part_001_entries/entries_000.rs
index 926be9edb8db75488c1894f105dba265b103c614..1b3e861bd2e0390edbd6aafc031907ffa15a7cd5
--- a/src/builtins/part_001_entries/entries_000.rs
+++ b/src/builtins/part_001_entries/entries_000.rs
@@ -69,6 +69,24 @@
     ));
     debug!("Added Notes built-in entry");
 
+    entries.push(BuiltInEntry::new_with_icon(
+        "builtin-quicklinks",
+        "Quicklinks",
+        "Manage quick links and open URLs with optional {query} expansion",
+        vec![
+            "quicklinks",
+            "quicklink",
+            "link",
+            "url",
+            "bookmark",
+            "open",
+            "search",
+        ],
+        BuiltInFeature::Quicklinks,
+        "ðŸ”—",
+    ));
+    debug!("Added Quicklinks built-in entry");
+
     // Design Gallery is only available in debug builds (developer tool)
     #[cfg(debug_assertions)]
     {
diff --git a/src/quicklinks/mod.rs b/src/quicklinks/mod.rs
index 08aeea02e216c8026f59f0d8fe5627ededb1dec0..e9e055c95e2b0cd21fbc8b79971df226a788899c
--- a/src/quicklinks/mod.rs
+++ b/src/quicklinks/mod.rs
@@ -43,6 +43,14 @@
     url_template.replace(QUERY_PLACEHOLDER, query)
 }
 
+pub fn has_query_placeholder(url_template: &str) -> bool {
+    url_template.contains(QUERY_PLACEHOLDER)
+}
+
+pub fn update_quicklink(id: &str, name: &str, url_template: &str) -> bool {
+    update_quicklink_from_path(id, name, url_template, &quicklinks_path())
+}
+
 fn quicklinks_path() -> PathBuf {
     dirs::home_dir()
         .map(|home| home.join(".scriptkit").join(QUICKLINKS_FILE))
@@ -75,11 +83,22 @@
     let _ = save_quicklinks_to_path(&links, path);
 }
 
+fn update_quicklink_from_path(id: &str, name: &str, url_template: &str, path: &Path) -> bool {
+    let mut links = load_quicklinks_from_path(path);
+    if let Some(link) = links.iter_mut().find(|link| link.id == id) {
+        link.name = name.trim().to_string();
+        link.url_template = url_template.trim().to_string();
+        return save_quicklinks_to_path(&links, path).is_ok();
+    }
+
+    false
+}
+
 #[cfg(test)]
 mod tests {
     use super::{
-        create_quicklink, delete_quicklink_from_path, expand_url, load_quicklinks_from_path,
-        save_quicklinks_to_path, Quicklink,
+        create_quicklink, delete_quicklink_from_path, expand_url, has_query_placeholder,
+        load_quicklinks_from_path, save_quicklinks_to_path, update_quicklink_from_path, Quicklink,
     };
 
     #[test]
@@ -105,6 +124,16 @@
     }
 
     #[test]
+    fn test_has_query_placeholder_returns_true_when_template_contains_placeholder() {
+        assert!(has_query_placeholder("https://example.com?q={query}"));
+    }
+
+    #[test]
+    fn test_has_query_placeholder_returns_false_when_template_missing_placeholder() {
+        assert!(!has_query_placeholder("https://example.com"));
+    }
+
+    #[test]
     fn test_load_quicklinks_from_path_returns_empty_when_file_missing() {
         let dir = tempfile::tempdir().expect("create temp dir");
         let path = dir.path().join("quicklinks.json");
@@ -174,4 +203,49 @@
         assert_eq!(loaded.len(), 1);
         assert_eq!(loaded[0].id, "keep");
     }
+
+    #[test]
+    fn test_update_quicklink_from_path_updates_name_and_url_template() {
+        let dir = tempfile::tempdir().expect("create temp dir");
+        let path = dir.path().join("quicklinks.json");
+        let links = vec![Quicklink {
+            id: "target".to_string(),
+            name: "Old".to_string(),
+            url_template: "https://old.example.com".to_string(),
+            icon: None,
+        }];
+
+        save_quicklinks_to_path(&links, &path).expect("seed quicklinks");
+        let updated = update_quicklink_from_path(
+            "target",
+            " New Name ",
+            " https://new.example.com?q={query} ",
+            &path,
+        );
+
+        assert!(updated);
+        let loaded = load_quicklinks_from_path(&path);
+        assert_eq!(loaded.len(), 1);
+        assert_eq!(loaded[0].name, "New Name");
+        assert_eq!(loaded[0].url_template, "https://new.example.com?q={query}");
+    }
+
+    #[test]
+    fn test_update_quicklink_from_path_returns_false_when_id_not_found() {
+        let dir = tempfile::tempdir().expect("create temp dir");
+        let path = dir.path().join("quicklinks.json");
+        let links = vec![Quicklink {
+            id: "target".to_string(),
+            name: "Keep".to_string(),
+            url_template: "https://example.com".to_string(),
+            icon: None,
+        }];
+
+        save_quicklinks_to_path(&links, &path).expect("seed quicklinks");
+        let updated = update_quicklink_from_path("missing", "Name", "https://updated.example.com", &path);
+
+        assert!(!updated);
+        let loaded = load_quicklinks_from_path(&path);
+        assert_eq!(loaded, links);
+    }
 }


thinking
**Investigating quicklinks implementation approach**
codex
I mapped quicklinks usage and confirmed there isnâ€™t an existing quicklinks UI implementation to reuse directly. Next Iâ€™m inspecting nearby built-in patterns for list rendering and CRUD interactions so the new feature fits current architecture.
exec
/bin/zsh -lc 'rg -n "create_.*from_input|prompt|Prompt|delete_.*|update_.*|open::|open_url|browser|webbrowser|ClipboardHistoryView|AppView::.*View" src/app_execute/builtin_execution.rs src/app_impl src/actions | head -n 250' in /Users/johnlindquist/dev/script-kit-gpuiexec
/bin/zsh -lc 'rg -n "enum AppView|ClipboardHistoryView|AppLauncherView|WindowSwitcherView|DesignGalleryView|Notes|Ai" src/app_state.rs src/app_impl src | head -n 250' in /Users/johnlindquist/dev/script-kit-gpui succeeded in 60ms:
src/app_execute/builtin_execution.rs:148:                self.current_view = AppView::ClipboardHistoryView {
src/app_execute/builtin_execution.rs:177:                self.current_view = AppView::AppLauncherView {
src/app_execute/builtin_execution.rs:225:                        self.current_view = AppView::WindowSwitcherView {
src/app_execute/builtin_execution.rs:257:                self.current_view = AppView::DesignGalleryView {
src/app_execute/builtin_execution.rs:547:                // Capture prompt text before reset for Shift+Tab/script-generation flows.
src/app_execute/builtin_execution.rs:548:                let script_generation_prompt = if matches!(cmd_type, AiCommandType::GenerateScript)
src/app_execute/builtin_execution.rs:556:                    && script_generation_prompt
src/app_execute/builtin_execution.rs:558:                        .is_some_and(|prompt| prompt.is_empty())
src/app_execute/builtin_execution.rs:562:                            "Type a prompt first, then run Generate Script with AI.",
src/app_execute/builtin_execution.rs:642:                        let Some(prompt_description) = script_generation_prompt.clone() else {
src/app_execute/builtin_execution.rs:645:                                "state=failed attempted=capture_prompt failure=missing_prompt",
src/app_execute/builtin_execution.rs:649:                                    "No prompt available for AI script generation",
src/app_execute/builtin_execution.rs:666:                                "state=queued attempted=builtin_generate_script prompt_len={}",
src/app_execute/builtin_execution.rs:667:                                prompt_description.len()
src/app_execute/builtin_execution.rs:673:                                ai::generate_script_from_prompt(&prompt_description, Some(&config))
src/app_execute/builtin_execution.rs:922:                        // Get browser URL and send to AI
src/app_execute/builtin_execution.rs:923:                        match platform::get_focused_browser_tab_url() {
src/app_execute/builtin_execution.rs:945:                                logging::log("ERROR", &format!("Failed to get browser URL: {}", e));
src/app_execute/builtin_execution.rs:948:                                        format!("Failed to get browser URL: {}", e),
src/app_execute/builtin_execution.rs:1218:                        self.show_api_key_prompt(
 succeeded in 53ms:
rg: src/app_state.rs: No such file or directory (os error 2)
src/app_impl/filter_input_change.rs:27:            AppView::ClipboardHistoryView {
src/app_impl/filter_input_change.rs:51:            AppView::AppLauncherView {
src/app_impl/filter_input_change.rs:62:            AppView::WindowSwitcherView {
src/app_impl/filter_input_change.rs:73:            AppView::DesignGalleryView {
src/app_impl/startup_new_actions.rs:7:                // CRITICAL: Skip processing if this keystroke is from Notes or AI window
src/app_impl/startup_new_actions.rs:107:                                AppView::ClipboardHistoryView { .. } => {
src/app_impl/startup_new_actions.rs:112:                                            "Interceptor: Cmd+K -> toggle_clipboard_actions (ClipboardHistoryView)",
src/app_impl/startup_new_actions.rs:201:                                AppView::ClipboardHistoryView { .. } => Some(ActionsDialogHost::ClipboardHistory),
src/app_impl/selection_fallback.rs:325:                        logging::log("FALLBACK", &format!("Failed to open Notes: {}", e));
src/app_impl/startup_new_arrow.rs:103:                                AppView::ClipboardHistoryView {
src/app_impl/startup_new_arrow.rs:158:                                AppView::AppLauncherView {
src/app_impl/startup_new_arrow.rs:175:                                AppView::WindowSwitcherView {
src/app_impl/startup_new_arrow.rs:317:                // Skip processing if this keystroke is from Notes or AI window
src/app_impl/ui_window.rs:65:            AppView::ClipboardHistoryView { filter, .. } => {
src/app_impl/ui_window.rs:78:            AppView::AppLauncherView { filter, .. } => {
src/app_impl/ui_window.rs:90:            AppView::WindowSwitcherView { filter, .. } => {
src/app_impl/ui_window.rs:106:            AppView::DesignGalleryView { filter, .. } => {
src/app_impl/prompt_ai.rs:5:enum AiScriptGenerationStage {
src/app_impl/prompt_ai.rs:15:impl AiScriptGenerationStage {
file update:
diff --git a/src/builtins/part_001_entries/entries_000.rs b/src/builtins/part_001_entries/entries_000.rs
index 926be9edb8db75488c1894f105dba265b103c614..1b3e861bd2e0390edbd6aafc031907ffa15a7cd5
--- a/src/builtins/part_001_entries/entries_000.rs
+++ b/src/builtins/part_001_entries/entries_000.rs
@@ -69,6 +69,24 @@
     ));
     debug!("Added Notes built-in entry");
 
+    entries.push(BuiltInEntry::new_with_icon(
+        "builtin-quicklinks",
+        "Quicklinks",
+        "Manage quick links and open URLs with optional {query} expansion",
+        vec![
+            "quicklinks",
+            "quicklink",
+            "link",
+            "url",
+            "bookmark",
+            "open",
+            "search",
+        ],
+        BuiltInFeature::Quicklinks,
+        "ðŸ”—",
+    ));
+    debug!("Added Quicklinks built-in entry");
+
     // Design Gallery is only available in debug builds (developer tool)
     #[cfg(debug_assertions)]
     {
diff --git a/src/quicklinks/mod.rs b/src/quicklinks/mod.rs
index 08aeea02e216c8026f59f0d8fe5627ededb1dec0..e9e055c95e2b0cd21fbc8b79971df226a788899c
--- a/src/quicklinks/mod.rs
+++ b/src/quicklinks/mod.rs
@@ -43,6 +43,14 @@
     url_template.replace(QUERY_PLACEHOLDER, query)
 }
 
+pub fn has_query_placeholder(url_template: &str) -> bool {
+    url_template.contains(QUERY_PLACEHOLDER)
+}
+
+pub fn update_quicklink(id: &str, name: &str, url_template: &str) -> bool {
+    update_quicklink_from_path(id, name, url_template, &quicklinks_path())
+}
+
 fn quicklinks_path() -> PathBuf {
     dirs::home_dir()
         .map(|home| home.join(".scriptkit").join(QUICKLINKS_FILE))
@@ -75,11 +83,22 @@
     let _ = save_quicklinks_to_path(&links, path);
 }
 
+fn update_quicklink_from_path(id: &str, name: &str, url_template: &str, path: &Path) -> bool {
+    let mut links = load_quicklinks_from_path(path);
+    if let Some(link) = links.iter_mut().find(|link| link.id == id) {
+        link.name = name.trim().to_string();
+        link.url_template = url_template.trim().to_string();
+        return save_quicklinks_to_path(&links, path).is_ok();
+    }
+
+    false
+}
+
 #[cfg(test)]
 mod tests {
     use super::{
-        create_quicklink, delete_quicklink_from_path, expand_url, load_quicklinks_from_path,
-        save_quicklinks_to_path, Quicklink,
+        create_quicklink, delete_quicklink_from_path, expand_url, has_query_placeholder,
+        load_quicklinks_from_path, save_quicklinks_to_path, update_quicklink_from_path, Quicklink,
     };
 
     #[test]
@@ -105,6 +124,16 @@
     }
 
     #[test]
+    fn test_has_query_placeholder_returns_true_when_template_contains_placeholder() {
+        assert!(has_query_placeholder("https://example.com?q={query}"));
+    }
+
+    #[test]
+    fn test_has_query_placeholder_returns_false_when_template_missing_placeholder() {
+        assert!(!has_query_placeholder("https://example.com"));
+    }
+
+    #[test]
     fn test_load_quicklinks_from_path_returns_empty_when_file_missing() {
         let dir = tempfile::tempdir().expect("create temp dir");
         let path = dir.path().join("quicklinks.json");
@@ -174,4 +203,49 @@
         assert_eq!(loaded.len(), 1);
         assert_eq!(loaded[0].id, "keep");
     }
+
+    #[test]
+    fn test_update_quicklink_from_path_updates_name_and_url_template() {
+        let dir = tempfile::tempdir().expect("create temp dir");
+        let path = dir.path().join("quicklinks.json");
+        let links = vec![Quicklink {
+            id: "target".to_string(),
+            name: "Old".to_string(),
+            url_template: "https://old.example.com".to_string(),
+            icon: None,
+        }];
+
+        save_quicklinks_to_path(&links, &path).expect("seed quicklinks");
+        let updated = update_quicklink_from_path(
+            "target",
+            " New Name ",
+            " https://new.example.com?q={query} ",
+            &path,
+        );
+
+        assert!(updated);
+        let loaded = load_quicklinks_from_path(&path);
+        assert_eq!(loaded.len(), 1);
+        assert_eq!(loaded[0].name, "New Name");
+        assert_eq!(loaded[0].url_template, "https://new.example.com?q={query}");
+    }
+
+    #[test]
+    fn test_update_quicklink_from_path_returns_false_when_id_not_found() {
+        let dir = tempfile::tempdir().expect("create temp dir");
+        let path = dir.path().join("quicklinks.json");
+        let links = vec![Quicklink {
+            id: "target".to_string(),
+            name: "Keep".to_string(),
+            url_template: "https://example.com".to_string(),
+            icon: None,
+        }];
+
+        save_quicklinks_to_path(&links, &path).expect("seed quicklinks");
+        let updated = update_quicklink_from_path("missing", "Name", "https://updated.example.com", &path);
+
+        assert!(!updated);
+        let loaded = load_quicklinks_from_path(&path);
+        assert_eq!(loaded, links);
+    }
 }


thinking
**Locating main enum definition**
exec
/bin/zsh -lc 'rg -n "pub enum AppView" src | head -n 20' in /Users/johnlindquist/dev/script-kit-gpui succeeded in 51ms:

file update:
diff --git a/src/builtins/part_001_entries/entries_000.rs b/src/builtins/part_001_entries/entries_000.rs
index 926be9edb8db75488c1894f105dba265b103c614..1b3e861bd2e0390edbd6aafc031907ffa15a7cd5
--- a/src/builtins/part_001_entries/entries_000.rs
+++ b/src/builtins/part_001_entries/entries_000.rs
@@ -69,6 +69,24 @@
     ));
     debug!("Added Notes built-in entry");
 
+    entries.push(BuiltInEntry::new_with_icon(
+        "builtin-quicklinks",
+        "Quicklinks",
+        "Manage quick links and open URLs with optional {query} expansion",
+        vec![
+            "quicklinks",
+            "quicklink",
+            "link",
+            "url",
+            "bookmark",
+            "open",
+            "search",
+        ],
+        BuiltInFeature::Quicklinks,
+        "ðŸ”—",
+    ));
+    debug!("Added Quicklinks built-in entry");
+
     // Design Gallery is only available in debug builds (developer tool)
     #[cfg(debug_assertions)]
     {
diff --git a/src/quicklinks/mod.rs b/src/quicklinks/mod.rs
index 08aeea02e216c8026f59f0d8fe5627ededb1dec0..e9e055c95e2b0cd21fbc8b79971df226a788899c
--- a/src/quicklinks/mod.rs
+++ b/src/quicklinks/mod.rs
@@ -43,6 +43,14 @@
     url_template.replace(QUERY_PLACEHOLDER, query)
 }
 
+pub fn has_query_placeholder(url_template: &str) -> bool {
+    url_template.contains(QUERY_PLACEHOLDER)
+}
+
+pub fn update_quicklink(id: &str, name: &str, url_template: &str) -> bool {
+    update_quicklink_from_path(id, name, url_template, &quicklinks_path())
+}
+
 fn quicklinks_path() -> PathBuf {
     dirs::home_dir()
         .map(|home| home.join(".scriptkit").join(QUICKLINKS_FILE))
@@ -75,11 +83,22 @@
     let _ = save_quicklinks_to_path(&links, path);
 }
 
+fn update_quicklink_from_path(id: &str, name: &str, url_template: &str, path: &Path) -> bool {
+    let mut links = load_quicklinks_from_path(path);
+    if let Some(link) = links.iter_mut().find(|link| link.id == id) {
+        link.name = name.trim().to_string();
+        link.url_template = url_template.trim().to_string();
+        return save_quicklinks_to_path(&links, path).is_ok();
+    }
+
+    false
+}
+
 #[cfg(test)]
 mod tests {
     use super::{
-        create_quicklink, delete_quicklink_from_path, expand_url, load_quicklinks_from_path,
-        save_quicklinks_to_path, Quicklink,
+        create_quicklink, delete_quicklink_from_path, expand_url, has_query_placeholder,
+        load_quicklinks_from_path, save_quicklinks_to_path, update_quicklink_from_path, Quicklink,
     };
 
     #[test]
@@ -105,6 +124,16 @@
     }
 
     #[test]
+    fn test_has_query_placeholder_returns_true_when_template_contains_placeholder() {
+        assert!(has_query_placeholder("https://example.com?q={query}"));
+    }
+
+    #[test]
+    fn test_has_query_placeholder_returns_false_when_template_missing_placeholder() {
+        assert!(!has_query_placeholder("https://example.com"));
+    }
+
+    #[test]
     fn test_load_quicklinks_from_path_returns_empty_when_file_missing() {
         let dir = tempfile::tempdir().expect("create temp dir");
         let path = dir.path().join("quicklinks.json");
@@ -174,4 +203,49 @@
         assert_eq!(loaded.len(), 1);
         assert_eq!(loaded[0].id, "keep");
     }
+
+    #[test]
+    fn test_update_quicklink_from_path_updates_name_and_url_template() {
+        let dir = tempfile::tempdir().expect("create temp dir");
+        let path = dir.path().join("quicklinks.json");
+        let links = vec![Quicklink {
+            id: "target".to_string(),
+            name: "Old".to_string(),
+            url_template: "https://old.example.com".to_string(),
+            icon: None,
+        }];
+
+        save_quicklinks_to_path(&links, &path).expect("seed quicklinks");
+        let updated = update_quicklink_from_path(
+            "target",
+            " New Name ",
+            " https://new.example.com?q={query} ",
+            &path,
+        );
+
+        assert!(updated);
+        let loaded = load_quicklinks_from_path(&path);
+        assert_eq!(loaded.len(), 1);
+        assert_eq!(loaded[0].name, "New Name");
+        assert_eq!(loaded[0].url_template, "https://new.example.com?q={query}");
+    }
+
+    #[test]
+    fn test_update_quicklink_from_path_returns_false_when_id_not_found() {
+        let dir = tempfile::tempdir().expect("create temp dir");
+        let path = dir.path().join("quicklinks.json");
+        let links = vec![Quicklink {
+            id: "target".to_string(),
+            name: "Keep".to_string(),
+            url_template: "https://example.com".to_string(),
+            icon: None,
+        }];
+
+        save_quicklinks_to_path(&links, &path).expect("seed quicklinks");
+        let updated = update_quicklink_from_path("missing", "Name", "https://updated.example.com", &path);
+
+        assert!(!updated);
+        let loaded = load_quicklinks_from_path(&path);
+        assert_eq!(loaded, links);
+    }
 }


thinking
**Checking enum visibility**
exec
/bin/zsh -lc 'rg -n "enum AppView" src | head -n 40' in /Users/johnlindquist/dev/script-kit-gpui succeeded in 52ms:
src/main_sections/app_view_state.rs:3:enum AppView {
file update:
diff --git a/src/builtins/part_001_entries/entries_000.rs b/src/builtins/part_001_entries/entries_000.rs
index 926be9edb8db75488c1894f105dba265b103c614..1b3e861bd2e0390edbd6aafc031907ffa15a7cd5
--- a/src/builtins/part_001_entries/entries_000.rs
+++ b/src/builtins/part_001_entries/entries_000.rs
@@ -69,6 +69,24 @@
     ));
     debug!("Added Notes built-in entry");
 
+    entries.push(BuiltInEntry::new_with_icon(
+        "builtin-quicklinks",
+        "Quicklinks",
+        "Manage quick links and open URLs with optional {query} expansion",
+        vec![
+            "quicklinks",
+            "quicklink",
+            "link",
+            "url",
+            "bookmark",
+            "open",
+            "search",
+        ],
+        BuiltInFeature::Quicklinks,
+        "ðŸ”—",
+    ));
+    debug!("Added Quicklinks built-in entry");
+
     // Design Gallery is only available in debug builds (developer tool)
     #[cfg(debug_assertions)]
     {
diff --git a/src/quicklinks/mod.rs b/src/quicklinks/mod.rs
index 08aeea02e216c8026f59f0d8fe5627ededb1dec0..e9e055c95e2b0cd21fbc8b79971df226a788899c
--- a/src/quicklinks/mod.rs
+++ b/src/quicklinks/mod.rs
@@ -43,6 +43,14 @@
     url_template.replace(QUERY_PLACEHOLDER, query)
 }
 
+pub fn has_query_placeholder(url_template: &str) -> bool {
+    url_template.contains(QUERY_PLACEHOLDER)
+}
+
+pub fn update_quicklink(id: &str, name: &str, url_template: &str) -> bool {
+    update_quicklink_from_path(id, name, url_template, &quicklinks_path())
+}
+
 fn quicklinks_path() -> PathBuf {
     dirs::home_dir()
         .map(|home| home.join(".scriptkit").join(QUICKLINKS_FILE))
@@ -75,11 +83,22 @@
     let _ = save_quicklinks_to_path(&links, path);
 }
 
+fn update_quicklink_from_path(id: &str, name: &str, url_template: &str, path: &Path) -> bool {
+    let mut links = load_quicklinks_from_path(path);
+    if let Some(link) = links.iter_mut().find(|link| link.id == id) {
+        link.name = name.trim().to_string();
+        link.url_template = url_template.trim().to_string();
+        return save_quicklinks_to_path(&links, path).is_ok();
+    }
+
+    false
+}
+
 #[cfg(test)]
 mod tests {
     use super::{
-        create_quicklink, delete_quicklink_from_path, expand_url, load_quicklinks_from_path,
-        save_quicklinks_to_path, Quicklink,
+        create_quicklink, delete_quicklink_from_path, expand_url, has_query_placeholder,
+        load_quicklinks_from_path, save_quicklinks_to_path, update_quicklink_from_path, Quicklink,
     };
 
     #[test]
@@ -105,6 +124,16 @@
     }
 
     #[test]
+    fn test_has_query_placeholder_returns_true_when_template_contains_placeholder() {
+        assert!(has_query_placeholder("https://example.com?q={query}"));
+    }
+
+    #[test]
+    fn test_has_query_placeholder_returns_false_when_template_missing_placeholder() {
+        assert!(!has_query_placeholder("https://example.com"));
+    }
+
+    #[test]
     fn test_load_quicklinks_from_path_returns_empty_when_file_missing() {
         let dir = tempfile::tempdir().expect("create temp dir");
         let path = dir.path().join("quicklinks.json");
@@ -174,4 +203,49 @@
         assert_eq!(loaded.len(), 1);
         assert_eq!(loaded[0].id, "keep");
     }
+
+    #[test]
+    fn test_update_quicklink_from_path_updates_name_and_url_template() {
+        let dir = tempfile::tempdir().expect("create temp dir");
+        let path = dir.path().join("quicklinks.json");
+        let links = vec![Quicklink {
+            id: "target".to_string(),
+            name: "Old".to_string(),
+            url_template: "https://old.example.com".to_string(),
+            icon: None,
+        }];
+
+        save_quicklinks_to_path(&links, &path).expect("seed quicklinks");
+        let updated = update_quicklink_from_path(
+            "target",
+            " New Name ",
+            " https://new.example.com?q={query} ",
+            &path,
+        );
+
+        assert!(updated);
+        let loaded = load_quicklinks_from_path(&path);
+        assert_eq!(loaded.len(), 1);
+        assert_eq!(loaded[0].name, "New Name");
+        assert_eq!(loaded[0].url_template, "https://new.example.com?q={query}");
+    }
+
+    #[test]
+    fn test_update_quicklink_from_path_returns_false_when_id_not_found() {
+        let dir = tempfile::tempdir().expect("create temp dir");
+        let path = dir.path().join("quicklinks.json");
+        let links = vec![Quicklink {
+            id: "target".to_string(),
+            name: "Keep".to_string(),
+            url_template: "https://example.com".to_string(),
+            icon: None,
+        }];
+
+        save_quicklinks_to_path(&links, &path).expect("seed quicklinks");
+        let updated = update_quicklink_from_path("missing", "Name", "https://updated.example.com", &path);
+
+        assert!(!updated);
+        let loaded = load_quicklinks_from_path(&path);
+        assert_eq!(loaded, links);
+    }
 }


thinking
**Inspecting file for quicklinks**
codex
I located the `AppView` enum in `src/main_sections/app_view_state.rs`; Iâ€™m checking whether quicklinks needs a new view variant or can be implemented as script-list entries without new view plumbing.
exec
/bin/zsh -lc "sed -n '1,280p' src/main_sections/app_view_state.rs" in /Users/johnlindquist/dev/script-kit-gpui succeeded in 51ms:
/// Application state - what view are we currently showing
#[derive(Debug, Clone)]
enum AppView {
    /// Showing the script list
    ScriptList,
    /// Showing the actions dialog (mini searchable popup)
    #[allow(dead_code)]
    ActionsDialog,
    /// Showing an arg prompt from a script
    ArgPrompt {
        id: String,
        placeholder: String,
        choices: Vec<Choice>,
        actions: Option<Vec<ProtocolAction>>,
    },
    /// Showing a div prompt from a script
    DivPrompt {
        #[allow(dead_code)]
        id: String,
        entity: Entity<DivPrompt>,
file update:
diff --git a/src/builtins/part_001_entries/entries_000.rs b/src/builtins/part_001_entries/entries_000.rs
index 926be9edb8db75488c1894f105dba265b103c614..1b3e861bd2e0390edbd6aafc031907ffa15a7cd5
--- a/src/builtins/part_001_entries/entries_000.rs
+++ b/src/builtins/part_001_entries/entries_000.rs
@@ -69,6 +69,24 @@
     ));
     debug!("Added Notes built-in entry");
 
+    entries.push(BuiltInEntry::new_with_icon(
+        "builtin-quicklinks",
+        "Quicklinks",
+        "Manage quick links and open URLs with optional {query} expansion",
+        vec![
+            "quicklinks",
+            "quicklink",
+            "link",
+            "url",
+            "bookmark",
+            "open",
+            "search",
+        ],
+        BuiltInFeature::Quicklinks,
+        "ðŸ”—",
+    ));
+    debug!("Added Quicklinks built-in entry");
+
     // Design Gallery is only available in debug builds (developer tool)
     #[cfg(debug_assertions)]
     {
diff --git a/src/quicklinks/mod.rs b/src/quicklinks/mod.rs
index 08aeea02e216c8026f59f0d8fe5627ededb1dec0..e9e055c95e2b0cd21fbc8b79971df226a788899c
--- a/src/quicklinks/mod.rs
+++ b/src/quicklinks/mod.rs
@@ -43,6 +43,14 @@
     url_template.replace(QUERY_PLACEHOLDER, query)
 }
 
+pub fn has_query_placeholder(url_template: &str) -> bool {
+    url_template.contains(QUERY_PLACEHOLDER)
+}
+
+pub fn update_quicklink(id: &str, name: &str, url_template: &str) -> bool {
+    update_quicklink_from_path(id, name, url_template, &quicklinks_path())
+}
+
 fn quicklinks_path() -> PathBuf {
     dirs::home_dir()
         .map(|home| home.join(".scriptkit").join(QUICKLINKS_FILE))
@@ -75,11 +83,22 @@
     let _ = save_quicklinks_to_path(&links, path);
 }
 
+fn update_quicklink_from_path(id: &str, name: &str, url_template: &str, path: &Path) -> bool {
+    let mut links = load_quicklinks_from_path(path);
+    if let Some(link) = links.iter_mut().find(|link| link.id == id) {
+        link.name = name.trim().to_string();
+        link.url_template = url_template.trim().to_string();
+        return save_quicklinks_to_path(&links, path).is_ok();
+    }
+
+    false
+}
+
 #[cfg(test)]
 mod tests {
     use super::{
-        create_quicklink, delete_quicklink_from_path, expand_url, load_quicklinks_from_path,
-        save_quicklinks_to_path, Quicklink,
+        create_quicklink, delete_quicklink_from_path, expand_url, has_query_placeholder,
+        load_quicklinks_from_path, save_quicklinks_to_path, update_quicklink_from_path, Quicklink,
     };
 
     #[test]
@@ -105,6 +124,16 @@
     }
 
     #[test]
+    fn test_has_query_placeholder_returns_true_when_template_contains_placeholder() {
+        assert!(has_query_placeholder("https://example.com?q={query}"));
+    }
+
+    #[test]
+    fn test_has_query_placeholder_returns_false_when_template_missing_placeholder() {
+        assert!(!has_query_placeholder("https://example.com"));
+    }
+
+    #[test]
     fn test_load_quicklinks_from_path_returns_empty_when_file_missing() {
         let dir = tempfile::tempdir().expect("create temp dir");
         let path = dir.path().join("quicklinks.json");
@@ -174,4 +203,49 @@
         assert_eq!(loaded.len(), 1);
         assert_eq!(loaded[0].id, "keep");
     }
+
+    #[test]
+    fn test_update_quicklink_from_path_updates_name_and_url_template() {
+        let dir = tempfile::tempdir().expect("create temp dir");
+        let path = dir.path().join("quicklinks.json");
+        let links = vec![Quicklink {
+            id: "target".to_string(),
+            name: "Old".to_string(),
+            url_template: "https://old.example.com".to_string(),
+            icon: None,
+        }];
+
+        save_quicklinks_to_path(&links, &path).expect("seed quicklinks");
+        let updated = update_quicklink_from_path(
+            "target",
+            " New Name ",
+            " https://new.example.com?q={query} ",
+            &path,
+        );
+
+        assert!(updated);
+        let loaded = load_quicklinks_from_path(&path);
+        assert_eq!(loaded.len(), 1);
+        assert_eq!(loaded[0].name, "New Name");
+        assert_eq!(loaded[0].url_template, "https://new.example.com?q={query}");
+    }
+
+    #[test]
+    fn test_update_quicklink_from_path_returns_false_when_id_not_found() {
+        let dir = tempfile::tempdir().expect("create temp dir");
+        let path = dir.path().join("quicklinks.json");
+        let links = vec![Quicklink {
+            id: "target".to_string(),
+            name: "Keep".to_string(),
+            url_template: "https://example.com".to_string(),
+            icon: None,
+        }];
+
+        save_quicklinks_to_path(&links, &path).expect("seed quicklinks");
+        let updated = update_quicklink_from_path("missing", "Name", "https://updated.example.com", &path);
+
+        assert!(!updated);
+        let loaded = load_quicklinks_from_path(&path);
+        assert_eq!(loaded, links);
+    }
 }


thinking
**Exploring quicklinks via scriptlist integration**
codex
I found existing URL-opening fallback logic that already handles `{query}` expansion for selected scriptlets. Iâ€™m inspecting it now to reuse the same behavior in the quicklinks built-in instead of inventing new URL handling.
exec
/bin/zsh -lc "sed -n '260,430p' src/app_impl/selection_fallback.rs" in /Users/johnlindquist/dev/script-kit-gpui succeeded in 51ms:
        {
            logging::log("EXEC", &format!("Executing fallback: {}", fallback.name()));

            // Check if this is a "stay open" action (opens its own view)
            let should_close = match &fallback {
                crate::fallbacks::FallbackItem::Builtin(builtin) => {
                    !matches!(builtin.id, "run-in-terminal" | "search-files")
                }
                crate::fallbacks::FallbackItem::Script(_) => false,
            };

            // Execute the fallback action
            match &fallback {
                crate::fallbacks::FallbackItem::Builtin(builtin) => {
                    let fallback_id = builtin.id.to_string();
                    self.execute_builtin_fallback_inline(&fallback_id, &input, cx);
                }
                crate::fallbacks::FallbackItem::Script(config) => {
                    self.execute_interactive(&config.script, cx);
                }
file update:
diff --git a/src/builtins/part_001_entries/entries_000.rs b/src/builtins/part_001_entries/entries_000.rs
index 926be9edb8db75488c1894f105dba265b103c614..1b3e861bd2e0390edbd6aafc031907ffa15a7cd5
--- a/src/builtins/part_001_entries/entries_000.rs
+++ b/src/builtins/part_001_entries/entries_000.rs
@@ -69,6 +69,24 @@
     ));
     debug!("Added Notes built-in entry");
 
+    entries.push(BuiltInEntry::new_with_icon(
+        "builtin-quicklinks",
+        "Quicklinks",
+        "Manage quick links and open URLs with optional {query} expansion",
+        vec![
+            "quicklinks",
+            "quicklink",
+            "link",
+            "url",
+            "bookmark",
+            "open",
+            "search",
+        ],
+        BuiltInFeature::Quicklinks,
+        "ðŸ”—",
+    ));
+    debug!("Added Quicklinks built-in entry");
+
     // Design Gallery is only available in debug builds (developer tool)
     #[cfg(debug_assertions)]
     {
diff --git a/src/quicklinks/mod.rs b/src/quicklinks/mod.rs
index 08aeea02e216c8026f59f0d8fe5627ededb1dec0..e9e055c95e2b0cd21fbc8b79971df226a788899c
--- a/src/quicklinks/mod.rs
+++ b/src/quicklinks/mod.rs
@@ -43,6 +43,14 @@
     url_template.replace(QUERY_PLACEHOLDER, query)
 }
 
+pub fn has_query_placeholder(url_template: &str) -> bool {
+    url_template.contains(QUERY_PLACEHOLDER)
+}
+
+pub fn update_quicklink(id: &str, name: &str, url_template: &str) -> bool {
+    update_quicklink_from_path(id, name, url_template, &quicklinks_path())
+}
+
 fn quicklinks_path() -> PathBuf {
     dirs::home_dir()
         .map(|home| home.join(".scriptkit").join(QUICKLINKS_FILE))
@@ -75,11 +83,22 @@
     let _ = save_quicklinks_to_path(&links, path);
 }
 
+fn update_quicklink_from_path(id: &str, name: &str, url_template: &str, path: &Path) -> bool {
+    let mut links = load_quicklinks_from_path(path);
+    if let Some(link) = links.iter_mut().find(|link| link.id == id) {
+        link.name = name.trim().to_string();
+        link.url_template = url_template.trim().to_string();
+        return save_quicklinks_to_path(&links, path).is_ok();
+    }
+
+    false
+}
+
 #[cfg(test)]
 mod tests {
     use super::{
-        create_quicklink, delete_quicklink_from_path, expand_url, load_quicklinks_from_path,
-        save_quicklinks_to_path, Quicklink,
+        create_quicklink, delete_quicklink_from_path, expand_url, has_query_placeholder,
+        load_quicklinks_from_path, save_quicklinks_to_path, update_quicklink_from_path, Quicklink,
     };
 
     #[test]
@@ -105,6 +124,16 @@
     }
 
     #[test]
+    fn test_has_query_placeholder_returns_true_when_template_contains_placeholder() {
+        assert!(has_query_placeholder("https://example.com?q={query}"));
+    }
+
+    #[test]
+    fn test_has_query_placeholder_returns_false_when_template_missing_placeholder() {
+        assert!(!has_query_placeholder("https://example.com"));
+    }
+
+    #[test]
     fn test_load_quicklinks_from_path_returns_empty_when_file_missing() {
         let dir = tempfile::tempdir().expect("create temp dir");
         let path = dir.path().join("quicklinks.json");
@@ -174,4 +203,49 @@
         assert_eq!(loaded.len(), 1);
         assert_eq!(loaded[0].id, "keep");
     }
+
+    #[test]
+    fn test_update_quicklink_from_path_updates_name_and_url_template() {
+        let dir = tempfile::tempdir().expect("create temp dir");
+        let path = dir.path().join("quicklinks.json");
+        let links = vec![Quicklink {
+            id: "target".to_string(),
+            name: "Old".to_string(),
+            url_template: "https://old.example.com".to_string(),
+            icon: None,
+        }];
+
+        save_quicklinks_to_path(&links, &path).expect("seed quicklinks");
+        let updated = update_quicklink_from_path(
+            "target",
+            " New Name ",
+            " https://new.example.com?q={query} ",
+            &path,
+        );
+
+        assert!(updated);
+        let loaded = load_quicklinks_from_path(&path);
+        assert_eq!(loaded.len(), 1);
+        assert_eq!(loaded[0].name, "New Name");
+        assert_eq!(loaded[0].url_template, "https://new.example.com?q={query}");
+    }
+
+    #[test]
+    fn test_update_quicklink_from_path_returns_false_when_id_not_found() {
+        let dir = tempfile::tempdir().expect("create temp dir");
+        let path = dir.path().join("quicklinks.json");
+        let links = vec![Quicklink {
+            id: "target".to_string(),
+            name: "Keep".to_string(),
+            url_template: "https://example.com".to_string(),
+            icon: None,
+        }];
+
+        save_quicklinks_to_path(&links, &path).expect("seed quicklinks");
+        let updated = update_quicklink_from_path("missing", "Name", "https://updated.example.com", &path);
+
+        assert!(!updated);
+        let loaded = load_quicklinks_from_path(&path);
+        assert_eq!(loaded, links);
+    }
 }


thinking
**Inspecting fallback quicklinks source**
exec
/bin/zsh -lc "rg -n \"quicklink|\\{query\\}|OpenUrl|FallbackResult::OpenUrl|expand_url\" src/fallbacks src/app_impl/selection_fallback.rs src | head -n 200" in /Users/johnlindquist/dev/script-kit-gpui succeeded in 52ms:
src/app_impl/selection_fallback.rs:334:                FallbackResult::OpenUrl { url } => {
src/app_impl/selection_fallback.rs:335:                    logging::log("FALLBACK", &format!("OpenUrl: {}", url));
src/fallbacks/builtins.rs:74:    /// Search using a URL template (input replaces {query})
src/fallbacks/builtins.rs:77:    OpenUrl,
src/fallbacks/builtins.rs:154:                let url = template.replace("{query}", &encoded);
src/fallbacks/builtins.rs:155:                Ok(FallbackResult::OpenUrl { url })
src/fallbacks/builtins.rs:158:            FallbackAction::OpenUrl => {
src/fallbacks/builtins.rs:160:                    Ok(FallbackResult::OpenUrl {
src/fallbacks/builtins.rs:210:            FallbackAction::OpenUrl => format!("Open {}", truncated),
src/fallbacks/builtins.rs:228:    OpenUrl { url: String },
src/fallbacks/builtins.rs:259:            action: FallbackAction::OpenUrl,
src/fallbacks/builtins.rs:321:                template: "http://g.ai/?q={query}".to_string(),
src/fallbacks/builtins.rs:333:                template: "https://www.google.com/search?q={query}".to_string(),
src/fallbacks/builtins.rs:345:                template: "https://duckduckgo.com/?q={query}".to_string(),
src/fallbacks/builtins.rs:511:            FallbackResult::OpenUrl { url } => {
src/fallbacks/builtins.rs:515:            _ => panic!("Expected OpenUrl result"),
src/fallbacks/builtins.rs:529:            FallbackResult::OpenUrl { url } => {
src/fallbacks/builtins.rs:533:            _ => panic!("Expected OpenUrl result"),
src/fallbacks/builtins.rs:545:                template: "https://example.com?q={query}".to_string(),
src/fallbacks/builtins.rs:553:            FallbackResult::OpenUrl { url } => {
file update:
diff --git a/src/builtins/part_001_entries/entries_000.rs b/src/builtins/part_001_entries/entries_000.rs
index 926be9edb8db75488c1894f105dba265b103c614..1b3e861bd2e0390edbd6aafc031907ffa15a7cd5
--- a/src/builtins/part_001_entries/entries_000.rs
+++ b/src/builtins/part_001_entries/entries_000.rs
@@ -69,6 +69,24 @@
     ));
     debug!("Added Notes built-in entry");
 
+    entries.push(BuiltInEntry::new_with_icon(
+        "builtin-quicklinks",
+        "Quicklinks",
+        "Manage quick links and open URLs with optional {query} expansion",
+        vec![
+            "quicklinks",
+            "quicklink",
+            "link",
+            "url",
+            "bookmark",
+            "open",
+            "search",
+        ],
+        BuiltInFeature::Quicklinks,
+        "ðŸ”—",
+    ));
+    debug!("Added Quicklinks built-in entry");
+
     // Design Gallery is only available in debug builds (developer tool)
     #[cfg(debug_assertions)]
     {
diff --git a/src/quicklinks/mod.rs b/src/quicklinks/mod.rs
index 08aeea02e216c8026f59f0d8fe5627ededb1dec0..e9e055c95e2b0cd21fbc8b79971df226a788899c
--- a/src/quicklinks/mod.rs
+++ b/src/quicklinks/mod.rs
@@ -43,6 +43,14 @@
     url_template.replace(QUERY_PLACEHOLDER, query)
 }
 
+pub fn has_query_placeholder(url_template: &str) -> bool {
+    url_template.contains(QUERY_PLACEHOLDER)
+}
+
+pub fn update_quicklink(id: &str, name: &str, url_template: &str) -> bool {
+    update_quicklink_from_path(id, name, url_template, &quicklinks_path())
+}
+
 fn quicklinks_path() -> PathBuf {
     dirs::home_dir()
         .map(|home| home.join(".scriptkit").join(QUICKLINKS_FILE))
@@ -75,11 +83,22 @@
     let _ = save_quicklinks_to_path(&links, path);
 }
 
+fn update_quicklink_from_path(id: &str, name: &str, url_template: &str, path: &Path) -> bool {
+    let mut links = load_quicklinks_from_path(path);
+    if let Some(link) = links.iter_mut().find(|link| link.id == id) {
+        link.name = name.trim().to_string();
+        link.url_template = url_template.trim().to_string();
+        return save_quicklinks_to_path(&links, path).is_ok();
+    }
+
+    false
+}
+
 #[cfg(test)]
 mod tests {
     use super::{
-        create_quicklink, delete_quicklink_from_path, expand_url, load_quicklinks_from_path,
-        save_quicklinks_to_path, Quicklink,
+        create_quicklink, delete_quicklink_from_path, expand_url, has_query_placeholder,
+        load_quicklinks_from_path, save_quicklinks_to_path, update_quicklink_from_path, Quicklink,
     };
 
     #[test]
@@ -105,6 +124,16 @@
     }
 
     #[test]
+    fn test_has_query_placeholder_returns_true_when_template_contains_placeholder() {
+        assert!(has_query_placeholder("https://example.com?q={query}"));
+    }
+
+    #[test]
+    fn test_has_query_placeholder_returns_false_when_template_missing_placeholder() {
+        assert!(!has_query_placeholder("https://example.com"));
+    }
+
+    #[test]
     fn test_load_quicklinks_from_path_returns_empty_when_file_missing() {
         let dir = tempfile::tempdir().expect("create temp dir");
         let path = dir.path().join("quicklinks.json");
@@ -174,4 +203,49 @@
         assert_eq!(loaded.len(), 1);
         assert_eq!(loaded[0].id, "keep");
     }
+
+    #[test]
+    fn test_update_quicklink_from_path_updates_name_and_url_template() {
+        let dir = tempfile::tempdir().expect("create temp dir");
+        let path = dir.path().join("quicklinks.json");
+        let links = vec![Quicklink {
+            id: "target".to_string(),
+            name: "Old".to_string(),
+            url_template: "https://old.example.com".to_string(),
+            icon: None,
+        }];
+
+        save_quicklinks_to_path(&links, &path).expect("seed quicklinks");
+        let updated = update_quicklink_from_path(
+            "target",
+            " New Name ",
+            " https://new.example.com?q={query} ",
+            &path,
+        );
+
+        assert!(updated);
+        let loaded = load_quicklinks_from_path(&path);
+        assert_eq!(loaded.len(), 1);
+        assert_eq!(loaded[0].name, "New Name");
+        assert_eq!(loaded[0].url_template, "https://new.example.com?q={query}");
+    }
+
+    #[test]
+    fn test_update_quicklink_from_path_returns_false_when_id_not_found() {
+        let dir = tempfile::tempdir().expect("create temp dir");
+        let path = dir.path().join("quicklinks.json");
+        let links = vec![Quicklink {
+            id: "target".to_string(),
+            name: "Keep".to_string(),
+            url_template: "https://example.com".to_string(),
+            icon: None,
+        }];
+
+        save_quicklinks_to_path(&links, &path).expect("seed quicklinks");
+        let updated = update_quicklink_from_path("missing", "Name", "https://updated.example.com", &path);
+
+        assert!(!updated);
+        let loaded = load_quicklinks_from_path(&path);
+        assert_eq!(loaded, links);
+    }
 }


thinking
**Examining builtin execution structure**
exec
/bin/zsh -lc "sed -n '260,640p' src/app_execute/builtin_execution.rs" in /Users/johnlindquist/dev/script-kit-gpui succeeded in 52ms:
                };
                self.hovered_index = None;
                // Mark as opened from main menu - ESC will return to main menu
                self.opened_from_main_menu = true;
                // Use standard height for design gallery view
                resize_to_view_sync(ViewType::ScriptList, 0);
                // Focus the main filter input so cursor blinks and typing works
                self.pending_focus = Some(FocusTarget::MainFilter);
                self.focused_input = FocusedInput::MainFilter;
                cx.notify();
            }
            builtins::BuiltInFeature::AiChat => {
                logging::log("EXEC", "Opening AI Chat window");
                // Reset state and hide main window first
                script_kit_gpui::set_main_window_visible(false);
                self.reset_to_script_list(cx);
                platform::hide_main_window();

                // Defer AI window creation to avoid RefCell borrow conflicts
                // The reset_to_script_list calls cx.notify() which schedules a render,
file update:
diff --git a/src/builtins/part_001_entries/entries_000.rs b/src/builtins/part_001_entries/entries_000.rs
index 926be9edb8db75488c1894f105dba265b103c614..1b3e861bd2e0390edbd6aafc031907ffa15a7cd5
--- a/src/builtins/part_001_entries/entries_000.rs
+++ b/src/builtins/part_001_entries/entries_000.rs
@@ -69,6 +69,24 @@
     ));
     debug!("Added Notes built-in entry");
 
+    entries.push(BuiltInEntry::new_with_icon(
+        "builtin-quicklinks",
+        "Quicklinks",
+        "Manage quick links and open URLs with optional {query} expansion",
+        vec![
+            "quicklinks",
+            "quicklink",
+            "link",
+            "url",
+            "bookmark",
+            "open",
+            "search",
+        ],
+        BuiltInFeature::Quicklinks,
+        "ðŸ”—",
+    ));
+    debug!("Added Quicklinks built-in entry");
+
     // Design Gallery is only available in debug builds (developer tool)
     #[cfg(debug_assertions)]
     {
diff --git a/src/quicklinks/mod.rs b/src/quicklinks/mod.rs
index 08aeea02e216c8026f59f0d8fe5627ededb1dec0..e9e055c95e2b0cd21fbc8b79971df226a788899c
--- a/src/quicklinks/mod.rs
+++ b/src/quicklinks/mod.rs
@@ -43,6 +43,14 @@
     url_template.replace(QUERY_PLACEHOLDER, query)
 }
 
+pub fn has_query_placeholder(url_template: &str) -> bool {
+    url_template.contains(QUERY_PLACEHOLDER)
+}
+
+pub fn update_quicklink(id: &str, name: &str, url_template: &str) -> bool {
+    update_quicklink_from_path(id, name, url_template, &quicklinks_path())
+}
+
 fn quicklinks_path() -> PathBuf {
     dirs::home_dir()
         .map(|home| home.join(".scriptkit").join(QUICKLINKS_FILE))
@@ -75,11 +83,22 @@
     let _ = save_quicklinks_to_path(&links, path);
 }
 
+fn update_quicklink_from_path(id: &str, name: &str, url_template: &str, path: &Path) -> bool {
+    let mut links = load_quicklinks_from_path(path);
+    if let Some(link) = links.iter_mut().find(|link| link.id == id) {
+        link.name = name.trim().to_string();
+        link.url_template = url_template.trim().to_string();
+        return save_quicklinks_to_path(&links, path).is_ok();
+    }
+
+    false
+}
+
 #[cfg(test)]
 mod tests {
     use super::{
-        create_quicklink, delete_quicklink_from_path, expand_url, load_quicklinks_from_path,
-        save_quicklinks_to_path, Quicklink,
+        create_quicklink, delete_quicklink_from_path, expand_url, has_query_placeholder,
+        load_quicklinks_from_path, save_quicklinks_to_path, update_quicklink_from_path, Quicklink,
     };
 
     #[test]
@@ -105,6 +124,16 @@
     }
 
     #[test]
+    fn test_has_query_placeholder_returns_true_when_template_contains_placeholder() {
+        assert!(has_query_placeholder("https://example.com?q={query}"));
+    }
+
+    #[test]
+    fn test_has_query_placeholder_returns_false_when_template_missing_placeholder() {
+        assert!(!has_query_placeholder("https://example.com"));
+    }
+
+    #[test]
     fn test_load_quicklinks_from_path_returns_empty_when_file_missing() {
         let dir = tempfile::tempdir().expect("create temp dir");
         let path = dir.path().join("quicklinks.json");
@@ -174,4 +203,49 @@
         assert_eq!(loaded.len(), 1);
         assert_eq!(loaded[0].id, "keep");
     }
+
+    #[test]
+    fn test_update_quicklink_from_path_updates_name_and_url_template() {
+        let dir = tempfile::tempdir().expect("create temp dir");
+        let path = dir.path().join("quicklinks.json");
+        let links = vec![Quicklink {
+            id: "target".to_string(),
+            name: "Old".to_string(),
+            url_template: "https://old.example.com".to_string(),
+            icon: None,
+        }];
+
+        save_quicklinks_to_path(&links, &path).expect("seed quicklinks");
+        let updated = update_quicklink_from_path(
+            "target",
+            " New Name ",
+            " https://new.example.com?q={query} ",
+            &path,
+        );
+
+        assert!(updated);
+        let loaded = load_quicklinks_from_path(&path);
+        assert_eq!(loaded.len(), 1);
+        assert_eq!(loaded[0].name, "New Name");
+        assert_eq!(loaded[0].url_template, "https://new.example.com?q={query}");
+    }
+
+    #[test]
+    fn test_update_quicklink_from_path_returns_false_when_id_not_found() {
+        let dir = tempfile::tempdir().expect("create temp dir");
+        let path = dir.path().join("quicklinks.json");
+        let links = vec![Quicklink {
+            id: "target".to_string(),
+            name: "Keep".to_string(),
+            url_template: "https://example.com".to_string(),
+            icon: None,
+        }];
+
+        save_quicklinks_to_path(&links, &path).expect("seed quicklinks");
+        let updated = update_quicklink_from_path("missing", "Name", "https://updated.example.com", &path);
+
+        assert!(!updated);
+        let loaded = load_quicklinks_from_path(&path);
+        assert_eq!(loaded, links);
+    }
 }


thinking
**Considering post-640 utility tasks**
exec
/bin/zsh -lc "sed -n '640,1120p' src/app_execute/builtin_execution.rs" in /Users/johnlindquist/dev/script-kit-gpui succeeded in 51ms:

                    AiCommandType::GenerateScript => {
                        let Some(prompt_description) = script_generation_prompt.clone() else {
                            logging::log(
                                "AI_SCRIPT_GEN",
                                "state=failed attempted=capture_prompt failure=missing_prompt",
                            );
                            self.toast_manager.push(
                                components::toast::Toast::error(
                                    "No prompt available for AI script generation",
                                    &self.theme,
                                )
                                .duration_ms(Some(5000)),
                            );
                            cx.notify();
                            return;
                        };

                        let config = self.config.clone();
                        let (tx, rx) = async_channel::bounded::<
file update:
diff --git a/src/builtins/part_001_entries/entries_000.rs b/src/builtins/part_001_entries/entries_000.rs
index 926be9edb8db75488c1894f105dba265b103c614..1b3e861bd2e0390edbd6aafc031907ffa15a7cd5
--- a/src/builtins/part_001_entries/entries_000.rs
+++ b/src/builtins/part_001_entries/entries_000.rs
@@ -69,6 +69,24 @@
     ));
     debug!("Added Notes built-in entry");
 
+    entries.push(BuiltInEntry::new_with_icon(
+        "builtin-quicklinks",
+        "Quicklinks",
+        "Manage quick links and open URLs with optional {query} expansion",
+        vec![
+            "quicklinks",
+            "quicklink",
+            "link",
+            "url",
+            "bookmark",
+            "open",
+            "search",
+        ],
+        BuiltInFeature::Quicklinks,
+        "ðŸ”—",
+    ));
+    debug!("Added Quicklinks built-in entry");
+
     // Design Gallery is only available in debug builds (developer tool)
     #[cfg(debug_assertions)]
     {
diff --git a/src/quicklinks/mod.rs b/src/quicklinks/mod.rs
index 08aeea02e216c8026f59f0d8fe5627ededb1dec0..e9e055c95e2b0cd21fbc8b79971df226a788899c
--- a/src/quicklinks/mod.rs
+++ b/src/quicklinks/mod.rs
@@ -43,6 +43,14 @@
     url_template.replace(QUERY_PLACEHOLDER, query)
 }
 
+pub fn has_query_placeholder(url_template: &str) -> bool {
+    url_template.contains(QUERY_PLACEHOLDER)
+}
+
+pub fn update_quicklink(id: &str, name: &str, url_template: &str) -> bool {
+    update_quicklink_from_path(id, name, url_template, &quicklinks_path())
+}
+
 fn quicklinks_path() -> PathBuf {
     dirs::home_dir()
         .map(|home| home.join(".scriptkit").join(QUICKLINKS_FILE))
@@ -75,11 +83,22 @@
     let _ = save_quicklinks_to_path(&links, path);
 }
 
+fn update_quicklink_from_path(id: &str, name: &str, url_template: &str, path: &Path) -> bool {
+    let mut links = load_quicklinks_from_path(path);
+    if let Some(link) = links.iter_mut().find(|link| link.id == id) {
+        link.name = name.trim().to_string();
+        link.url_template = url_template.trim().to_string();
+        return save_quicklinks_to_path(&links, path).is_ok();
+    }
+
+    false
+}
+
 #[cfg(test)]
 mod tests {
     use super::{
-        create_quicklink, delete_quicklink_from_path, expand_url, load_quicklinks_from_path,
-        save_quicklinks_to_path, Quicklink,
+        create_quicklink, delete_quicklink_from_path, expand_url, has_query_placeholder,
+        load_quicklinks_from_path, save_quicklinks_to_path, update_quicklink_from_path, Quicklink,
     };
 
     #[test]
@@ -105,6 +124,16 @@
     }
 
     #[test]
+    fn test_has_query_placeholder_returns_true_when_template_contains_placeholder() {
+        assert!(has_query_placeholder("https://example.com?q={query}"));
+    }
+
+    #[test]
+    fn test_has_query_placeholder_returns_false_when_template_missing_placeholder() {
+        assert!(!has_query_placeholder("https://example.com"));
+    }
+
+    #[test]
     fn test_load_quicklinks_from_path_returns_empty_when_file_missing() {
         let dir = tempfile::tempdir().expect("create temp dir");
         let path = dir.path().join("quicklinks.json");
@@ -174,4 +203,49 @@
         assert_eq!(loaded.len(), 1);
         assert_eq!(loaded[0].id, "keep");
     }
+
+    #[test]
+    fn test_update_quicklink_from_path_updates_name_and_url_template() {
+        let dir = tempfile::tempdir().expect("create temp dir");
+        let path = dir.path().join("quicklinks.json");
+        let links = vec![Quicklink {
+            id: "target".to_string(),
+            name: "Old".to_string(),
+            url_template: "https://old.example.com".to_string(),
+            icon: None,
+        }];
+
+        save_quicklinks_to_path(&links, &path).expect("seed quicklinks");
+        let updated = update_quicklink_from_path(
+            "target",
+            " New Name ",
+            " https://new.example.com?q={query} ",
+            &path,
+        );
+
+        assert!(updated);
+        let loaded = load_quicklinks_from_path(&path);
+        assert_eq!(loaded.len(), 1);
+        assert_eq!(loaded[0].name, "New Name");
+        assert_eq!(loaded[0].url_template, "https://new.example.com?q={query}");
+    }
+
+    #[test]
+    fn test_update_quicklink_from_path_returns_false_when_id_not_found() {
+        let dir = tempfile::tempdir().expect("create temp dir");
+        let path = dir.path().join("quicklinks.json");
+        let links = vec![Quicklink {
+            id: "target".to_string(),
+            name: "Keep".to_string(),
+            url_template: "https://example.com".to_string(),
+            icon: None,
+        }];
+
+        save_quicklinks_to_path(&links, &path).expect("seed quicklinks");
+        let updated = update_quicklink_from_path("missing", "Name", "https://updated.example.com", &path);
+
+        assert!(!updated);
+        let loaded = load_quicklinks_from_path(&path);
+        assert_eq!(loaded, links);
+    }
 }


thinking
**Inspecting end-of-match utilities**
exec
/bin/zsh -lc "sed -n '1120,1560p' src/app_execute/builtin_execution.rs" in /Users/johnlindquist/dev/script-kit-gpui succeeded in 52ms:
                                "ERROR",
                                &format!("Failed to open accessibility settings: {}", e),
                            );
                            self.toast_manager.push(
                                components::toast::Toast::error(
                                    format!("Failed to open settings: {}", e),
                                    &self.theme,
                                )
                                .duration_ms(Some(5000)),
                            );
                            cx.notify();
                        } else {
                            self.close_and_reset_window(cx);
                        }
                    }
                }
            }

            // =========================================================================
            // Frecency/Suggested Commands
file update:
diff --git a/src/builtins/part_001_entries/entries_000.rs b/src/builtins/part_001_entries/entries_000.rs
index 926be9edb8db75488c1894f105dba265b103c614..1b3e861bd2e0390edbd6aafc031907ffa15a7cd5
--- a/src/builtins/part_001_entries/entries_000.rs
+++ b/src/builtins/part_001_entries/entries_000.rs
@@ -69,6 +69,24 @@
     ));
     debug!("Added Notes built-in entry");
 
+    entries.push(BuiltInEntry::new_with_icon(
+        "builtin-quicklinks",
+        "Quicklinks",
+        "Manage quick links and open URLs with optional {query} expansion",
+        vec![
+            "quicklinks",
+            "quicklink",
+            "link",
+            "url",
+            "bookmark",
+            "open",
+            "search",
+        ],
+        BuiltInFeature::Quicklinks,
+        "ðŸ”—",
+    ));
+    debug!("Added Quicklinks built-in entry");
+
     // Design Gallery is only available in debug builds (developer tool)
     #[cfg(debug_assertions)]
     {
diff --git a/src/quicklinks/mod.rs b/src/quicklinks/mod.rs
index 08aeea02e216c8026f59f0d8fe5627ededb1dec0..e9e055c95e2b0cd21fbc8b79971df226a788899c
--- a/src/quicklinks/mod.rs
+++ b/src/quicklinks/mod.rs
@@ -43,6 +43,14 @@
     url_template.replace(QUERY_PLACEHOLDER, query)
 }
 
+pub fn has_query_placeholder(url_template: &str) -> bool {
+    url_template.contains(QUERY_PLACEHOLDER)
+}
+
+pub fn update_quicklink(id: &str, name: &str, url_template: &str) -> bool {
+    update_quicklink_from_path(id, name, url_template, &quicklinks_path())
+}
+
 fn quicklinks_path() -> PathBuf {
     dirs::home_dir()
         .map(|home| home.join(".scriptkit").join(QUICKLINKS_FILE))
@@ -75,11 +83,22 @@
     let _ = save_quicklinks_to_path(&links, path);
 }
 
+fn update_quicklink_from_path(id: &str, name: &str, url_template: &str, path: &Path) -> bool {
+    let mut links = load_quicklinks_from_path(path);
+    if let Some(link) = links.iter_mut().find(|link| link.id == id) {
+        link.name = name.trim().to_string();
+        link.url_template = url_template.trim().to_string();
+        return save_quicklinks_to_path(&links, path).is_ok();
+    }
+
+    false
+}
+
 #[cfg(test)]
 mod tests {
     use super::{
-        create_quicklink, delete_quicklink_from_path, expand_url, load_quicklinks_from_path,
-        save_quicklinks_to_path, Quicklink,
+        create_quicklink, delete_quicklink_from_path, expand_url, has_query_placeholder,
+        load_quicklinks_from_path, save_quicklinks_to_path, update_quicklink_from_path, Quicklink,
     };
 
     #[test]
@@ -105,6 +124,16 @@
     }
 
     #[test]
+    fn test_has_query_placeholder_returns_true_when_template_contains_placeholder() {
+        assert!(has_query_placeholder("https://example.com?q={query}"));
+    }
+
+    #[test]
+    fn test_has_query_placeholder_returns_false_when_template_missing_placeholder() {
+        assert!(!has_query_placeholder("https://example.com"));
+    }
+
+    #[test]
     fn test_load_quicklinks_from_path_returns_empty_when_file_missing() {
         let dir = tempfile::tempdir().expect("create temp dir");
         let path = dir.path().join("quicklinks.json");
@@ -174,4 +203,49 @@
         assert_eq!(loaded.len(), 1);
         assert_eq!(loaded[0].id, "keep");
     }
+
+    #[test]
+    fn test_update_quicklink_from_path_updates_name_and_url_template() {
+        let dir = tempfile::tempdir().expect("create temp dir");
+        let path = dir.path().join("quicklinks.json");
+        let links = vec![Quicklink {
+            id: "target".to_string(),
+            name: "Old".to_string(),
+            url_template: "https://old.example.com".to_string(),
+            icon: None,
+        }];
+
+        save_quicklinks_to_path(&links, &path).expect("seed quicklinks");
+        let updated = update_quicklink_from_path(
+            "target",
+            " New Name ",
+            " https://new.example.com?q={query} ",
+            &path,
+        );
+
+        assert!(updated);
+        let loaded = load_quicklinks_from_path(&path);
+        assert_eq!(loaded.len(), 1);
+        assert_eq!(loaded[0].name, "New Name");
+        assert_eq!(loaded[0].url_template, "https://new.example.com?q={query}");
+    }
+
+    #[test]
+    fn test_update_quicklink_from_path_returns_false_when_id_not_found() {
+        let dir = tempfile::tempdir().expect("create temp dir");
+        let path = dir.path().join("quicklinks.json");
+        let links = vec![Quicklink {
+            id: "target".to_string(),
+            name: "Keep".to_string(),
+            url_template: "https://example.com".to_string(),
+            icon: None,
+        }];
+
+        save_quicklinks_to_path(&links, &path).expect("seed quicklinks");
+        let updated = update_quicklink_from_path("missing", "Name", "https://updated.example.com", &path);
+
+        assert!(!updated);
+        let loaded = load_quicklinks_from_path(&path);
+        assert_eq!(loaded, links);
+    }
 }


thinking
**Assessing quicklinks UI approach**
exec
/bin/zsh -lc 'rg -n "AppView::ArgPrompt|show_arg|open_arg|ArgPrompt::new|arg prompt" src/app_execute src/app_impl src | head -n 200' in /Users/johnlindquist/dev/script-kit-gpui succeeded in 51ms:
src/app_impl/startup_new_actions.rs:87:                                AppView::ArgPrompt { .. } => {
src/app_impl/startup_new_actions.rs:88:                                    // Toggle actions for arg prompts (SDK setActions)
src/app_impl/startup_new_actions.rs:203:                                AppView::ArgPrompt { .. } => Some(ActionsDialogHost::ArgPrompt),
src/app_impl/ui_window.rs:41:            AppView::ArgPrompt { choices, .. } => {
src/app_impl/ui_window.rs:182:            AppView::ArgPrompt { .. } => {
src/app_impl/actions_toggle.rs:129:    /// Toggle actions dialog for arg prompts with SDK-defined actions
src/app_impl/actions_toggle.rs:150:                    // Open - push overlay to save arg prompt focus state
src/app_impl/actions_toggle.rs:160:                            None,                                 // No script info for arg prompts
src/app_impl/actions_toggle.rs:186:                logging::log("KEY", "No SDK actions defined for this arg prompt (None)");
src/app_impl/prompt_ai.rs:197:            AppView::ArgPrompt { .. }
src/app_impl/prompt_ai.rs:256:    /// Get filtered choices for arg prompt
src/app_impl/prompt_ai.rs:258:        if let AppView::ArgPrompt { choices, .. } = &self.current_view {
src/app_impl/prompt_ai.rs:276:        if let AppView::ArgPrompt { choices, .. } = &self.current_view {
src/app_impl/registries_state.rs:145:            AppView::ArgPrompt { .. } => "ArgPrompt",
src/app_impl/registries_state.rs:206:        // Clear arg prompt state
src/app_impl/startup.rs:1206:                                AppView::ArgPrompt { .. } => {
src/app_impl/startup.rs:1207:                                    // Toggle actions for arg prompts (SDK setActions)
src/app_impl/startup.rs:1322:                                AppView::ArgPrompt { .. } => Some(ActionsDialogHost::ArgPrompt),
src/components/prompt_input.rs:4://! across all prompt types (main menu, arg prompt, search command, etc.).
src/components/prompt_input.rs:20://! // For arg prompt with full features
file update:
diff --git a/src/builtins/part_001_entries/entries_000.rs b/src/builtins/part_001_entries/entries_000.rs
index 926be9edb8db75488c1894f105dba265b103c614..1b3e861bd2e0390edbd6aafc031907ffa15a7cd5
--- a/src/builtins/part_001_entries/entries_000.rs
+++ b/src/builtins/part_001_entries/entries_000.rs
@@ -69,6 +69,24 @@
     ));
     debug!("Added Notes built-in entry");
 
+    entries.push(BuiltInEntry::new_with_icon(
+        "builtin-quicklinks",
+        "Quicklinks",
+        "Manage quick links and open URLs with optional {query} expansion",
+        vec![
+            "quicklinks",
+            "quicklink",
+            "link",
+            "url",
+            "bookmark",
+            "open",
+            "search",
+        ],
+        BuiltInFeature::Quicklinks,
+        "ðŸ”—",
+    ));
+    debug!("Added Quicklinks built-in entry");
+
     // Design Gallery is only available in debug builds (developer tool)
     #[cfg(debug_assertions)]
     {
diff --git a/src/quicklinks/mod.rs b/src/quicklinks/mod.rs
index 08aeea02e216c8026f59f0d8fe5627ededb1dec0..e9e055c95e2b0cd21fbc8b79971df226a788899c
--- a/src/quicklinks/mod.rs
+++ b/src/quicklinks/mod.rs
@@ -43,6 +43,14 @@
     url_template.replace(QUERY_PLACEHOLDER, query)
 }
 
+pub fn has_query_placeholder(url_template: &str) -> bool {
+    url_template.contains(QUERY_PLACEHOLDER)
+}
+
+pub fn update_quicklink(id: &str, name: &str, url_template: &str) -> bool {
+    update_quicklink_from_path(id, name, url_template, &quicklinks_path())
+}
+
 fn quicklinks_path() -> PathBuf {
     dirs::home_dir()
         .map(|home| home.join(".scriptkit").join(QUICKLINKS_FILE))
@@ -75,11 +83,22 @@
     let _ = save_quicklinks_to_path(&links, path);
 }
 
+fn update_quicklink_from_path(id: &str, name: &str, url_template: &str, path: &Path) -> bool {
+    let mut links = load_quicklinks_from_path(path);
+    if let Some(link) = links.iter_mut().find(|link| link.id == id) {
+        link.name = name.trim().to_string();
+        link.url_template = url_template.trim().to_string();
+        return save_quicklinks_to_path(&links, path).is_ok();
+    }
+
+    false
+}
+
 #[cfg(test)]
 mod tests {
     use super::{
-        create_quicklink, delete_quicklink_from_path, expand_url, load_quicklinks_from_path,
-        save_quicklinks_to_path, Quicklink,
+        create_quicklink, delete_quicklink_from_path, expand_url, has_query_placeholder,
+        load_quicklinks_from_path, save_quicklinks_to_path, update_quicklink_from_path, Quicklink,
     };
 
     #[test]
@@ -105,6 +124,16 @@
     }
 
     #[test]
+    fn test_has_query_placeholder_returns_true_when_template_contains_placeholder() {
+        assert!(has_query_placeholder("https://example.com?q={query}"));
+    }
+
+    #[test]
+    fn test_has_query_placeholder_returns_false_when_template_missing_placeholder() {
+        assert!(!has_query_placeholder("https://example.com"));
+    }
+
+    #[test]
     fn test_load_quicklinks_from_path_returns_empty_when_file_missing() {
         let dir = tempfile::tempdir().expect("create temp dir");
         let path = dir.path().join("quicklinks.json");
@@ -174,4 +203,49 @@
         assert_eq!(loaded.len(), 1);
         assert_eq!(loaded[0].id, "keep");
     }
+
+    #[test]
+    fn test_update_quicklink_from_path_updates_name_and_url_template() {
+        let dir = tempfile::tempdir().expect("create temp dir");
+        let path = dir.path().join("quicklinks.json");
+        let links = vec![Quicklink {
+            id: "target".to_string(),
+            name: "Old".to_string(),
+            url_template: "https://old.example.com".to_string(),
+            icon: None,
+        }];
+
+        save_quicklinks_to_path(&links, &path).expect("seed quicklinks");
+        let updated = update_quicklink_from_path(
+            "target",
+            " New Name ",
+            " https://new.example.com?q={query} ",
+            &path,
+        );
+
+        assert!(updated);
+        let loaded = load_quicklinks_from_path(&path);
+        assert_eq!(loaded.len(), 1);
+        assert_eq!(loaded[0].name, "New Name");
+        assert_eq!(loaded[0].url_template, "https://new.example.com?q={query}");
+    }
+
+    #[test]
+    fn test_update_quicklink_from_path_returns_false_when_id_not_found() {
+        let dir = tempfile::tempdir().expect("create temp dir");
+        let path = dir.path().join("quicklinks.json");
+        let links = vec![Quicklink {
+            id: "target".to_string(),
+            name: "Keep".to_string(),
+            url_template: "https://example.com".to_string(),
+            icon: None,
+        }];
+
+        save_quicklinks_to_path(&links, &path).expect("seed quicklinks");
+        let updated = update_quicklink_from_path("missing", "Name", "https://updated.example.com", &path);
+
+        assert!(!updated);
+        let loaded = load_quicklinks_from_path(&path);
+        assert_eq!(loaded, links);
+    }
 }


thinking
**Exploring quicklinks integration options**
exec
/bin/zsh -lc 'rg -n "fn show_.*prompt|show_.*input|open_.*prompt|prompt_receiver|Prompt" src/app_impl src/app_execute | head -n 200' in /Users/johnlindquist/dev/script-kit-gpui succeeded in 51ms:
src/app_impl/alias_input.rs:4:    pub(crate) fn show_alias_input(
src/app_execute/utility_views.rs:20:        match term_prompt::TermPrompt::with_height(
src/app_execute/utility_views.rs:33:                self.pending_focus = Some(FocusTarget::TermPrompt);
src/app_execute/utility_views.rs:38:                    resize_to_view_sync(ViewType::TermPrompt, 0);
src/app_execute/utility_views.rs:282:        match term_prompt::TermPrompt::with_height(
src/app_execute/utility_views.rs:295:                self.pending_focus = Some(FocusTarget::TermPrompt);
src/app_execute/utility_views.rs:300:                    resize_to_view_sync(ViewType::TermPrompt, 0);
src/app_execute/utility_views.rs:332:        let webcam_prompt = prompts::WebcamPrompt::new(
src/app_execute/utility_views.rs:367:                resize_to_view_sync(ViewType::DivPrompt, 0);
src/app_execute/utility_views.rs:422:        resize_to_view_sync(ViewType::DivPrompt, 0);
src/app_execute/utility_views.rs:435:        let webcam_prompt = prompts::WebcamPrompt::new(
src/app_execute/utility_views.rs:461:        resize_to_view_sync(ViewType::DivPrompt, 0);
src/app_execute/execution_helpers.rs:47:    /// This creates an EnvPrompt that stores the key in the system keyring.
src/app_execute/execution_helpers.rs:51:    fn show_api_key_prompt(
src/app_execute/execution_helpers.rs:110:        // Create EnvPrompt entity
src/app_execute/execution_helpers.rs:112:        let env_prompt = prompts::EnvPrompt::new(
src/app_execute/execution_helpers.rs:126:        self.current_view = AppView::EnvPrompt { id, entity };
src/app_execute/execution_helpers.rs:127:        self.focused_input = FocusedInput::None; // EnvPrompt has its own focus handling
src/app_execute/execution_helpers.rs:128:        self.pending_focus = Some(FocusTarget::EnvPrompt);
src/app_execute/execution_helpers.rs:131:        resize_to_view_sync(ViewType::DivPrompt, 0);
file update:
diff --git a/src/builtins/part_001_entries/entries_000.rs b/src/builtins/part_001_entries/entries_000.rs
index 926be9edb8db75488c1894f105dba265b103c614..1b3e861bd2e0390edbd6aafc031907ffa15a7cd5
--- a/src/builtins/part_001_entries/entries_000.rs
+++ b/src/builtins/part_001_entries/entries_000.rs
@@ -69,6 +69,24 @@
     ));
     debug!("Added Notes built-in entry");
 
+    entries.push(BuiltInEntry::new_with_icon(
+        "builtin-quicklinks",
+        "Quicklinks",
+        "Manage quick links and open URLs with optional {query} expansion",
+        vec![
+            "quicklinks",
+            "quicklink",
+            "link",
+            "url",
+            "bookmark",
+            "open",
+            "search",
+        ],
+        BuiltInFeature::Quicklinks,
+        "ðŸ”—",
+    ));
+    debug!("Added Quicklinks built-in entry");
+
     // Design Gallery is only available in debug builds (developer tool)
     #[cfg(debug_assertions)]
     {
diff --git a/src/quicklinks/mod.rs b/src/quicklinks/mod.rs
index 08aeea02e216c8026f59f0d8fe5627ededb1dec0..e9e055c95e2b0cd21fbc8b79971df226a788899c
--- a/src/quicklinks/mod.rs
+++ b/src/quicklinks/mod.rs
@@ -43,6 +43,14 @@
     url_template.replace(QUERY_PLACEHOLDER, query)
 }
 
+pub fn has_query_placeholder(url_template: &str) -> bool {
+    url_template.contains(QUERY_PLACEHOLDER)
+}
+
+pub fn update_quicklink(id: &str, name: &str, url_template: &str) -> bool {
+    update_quicklink_from_path(id, name, url_template, &quicklinks_path())
+}
+
 fn quicklinks_path() -> PathBuf {
     dirs::home_dir()
         .map(|home| home.join(".scriptkit").join(QUICKLINKS_FILE))
@@ -75,11 +83,22 @@
     let _ = save_quicklinks_to_path(&links, path);
 }
 
+fn update_quicklink_from_path(id: &str, name: &str, url_template: &str, path: &Path) -> bool {
+    let mut links = load_quicklinks_from_path(path);
+    if let Some(link) = links.iter_mut().find(|link| link.id == id) {
+        link.name = name.trim().to_string();
+        link.url_template = url_template.trim().to_string();
+        return save_quicklinks_to_path(&links, path).is_ok();
+    }
+
+    false
+}
+
 #[cfg(test)]
 mod tests {
     use super::{
-        create_quicklink, delete_quicklink_from_path, expand_url, load_quicklinks_from_path,
-        save_quicklinks_to_path, Quicklink,
+        create_quicklink, delete_quicklink_from_path, expand_url, has_query_placeholder,
+        load_quicklinks_from_path, save_quicklinks_to_path, update_quicklink_from_path, Quicklink,
     };
 
     #[test]
@@ -105,6 +124,16 @@
     }
 
     #[test]
+    fn test_has_query_placeholder_returns_true_when_template_contains_placeholder() {
+        assert!(has_query_placeholder("https://example.com?q={query}"));
+    }
+
+    #[test]
+    fn test_has_query_placeholder_returns_false_when_template_missing_placeholder() {
+        assert!(!has_query_placeholder("https://example.com"));
+    }
+
+    #[test]
     fn test_load_quicklinks_from_path_returns_empty_when_file_missing() {
         let dir = tempfile::tempdir().expect("create temp dir");
         let path = dir.path().join("quicklinks.json");
@@ -174,4 +203,49 @@
         assert_eq!(loaded.len(), 1);
         assert_eq!(loaded[0].id, "keep");
     }
+
+    #[test]
+    fn test_update_quicklink_from_path_updates_name_and_url_template() {
+        let dir = tempfile::tempdir().expect("create temp dir");
+        let path = dir.path().join("quicklinks.json");
+        let links = vec![Quicklink {
+            id: "target".to_string(),
+            name: "Old".to_string(),
+            url_template: "https://old.example.com".to_string(),
+            icon: None,
+        }];
+
+        save_quicklinks_to_path(&links, &path).expect("seed quicklinks");
+        let updated = update_quicklink_from_path(
+            "target",
+            " New Name ",
+            " https://new.example.com?q={query} ",
+            &path,
+        );
+
+        assert!(updated);
+        let loaded = load_quicklinks_from_path(&path);
+        assert_eq!(loaded.len(), 1);
+        assert_eq!(loaded[0].name, "New Name");
+        assert_eq!(loaded[0].url_template, "https://new.example.com?q={query}");
+    }
+
+    #[test]
+    fn test_update_quicklink_from_path_returns_false_when_id_not_found() {
+        let dir = tempfile::tempdir().expect("create temp dir");
+        let path = dir.path().join("quicklinks.json");
+        let links = vec![Quicklink {
+            id: "target".to_string(),
+            name: "Keep".to_string(),
+            url_template: "https://example.com".to_string(),
+            icon: None,
+        }];
+
+        save_quicklinks_to_path(&links, &path).expect("seed quicklinks");
+        let updated = update_quicklink_from_path("missing", "Name", "https://updated.example.com", &path);
+
+        assert!(!updated);
+        let loaded = load_quicklinks_from_path(&path);
+        assert_eq!(loaded, links);
+    }
 }


thinking
**Investigating prompt submission flow**
exec
/bin/zsh -lc 'rg -n "submit_prompt_response|PromptResponse|selected_choice|ArgPrompt" src/app_impl src/main_entry src/prompt_handler | head -n 200' in /Users/johnlindquist/dev/script-kit-gpui succeeded in 50ms:
src/prompt_handler/part_001.rs:65:                self.current_view = AppView::ArgPrompt {
src/prompt_handler/part_001.rs:73:                self.focused_input = FocusedInput::ArgPrompt;
src/prompt_handler/part_001.rs:75:                self.pending_focus = Some(FocusTarget::AppRoot); // ArgPrompt uses parent focus
src/prompt_handler/part_001.rs:78:                    ViewType::ArgPromptNoChoices
src/prompt_handler/part_001.rs:80:                    ViewType::ArgPromptWithChoices
src/prompt_handler/part_001.rs:196:                    ViewType::ArgPromptWithChoices
src/prompt_handler/part_001.rs:710:                    AppView::ArgPrompt {
src/prompt_handler/part_001.rs:1085:                    AppView::ArgPrompt { id, .. } => Some(id.clone()),
src/prompt_handler/part_001.rs:1108:                    self.submit_prompt_response(id, Some(value_str), cx);
src/prompt_handler/part_001.rs:1482:                    ViewType::ArgPromptNoChoices
src/prompt_handler/part_001.rs:1484:                    ViewType::ArgPromptWithChoices
src/app_impl/startup_new_actions.rs:32:                        // Handle Cmd+K to toggle actions popup (works in ScriptList, FileSearchView, ArgPrompt)
src/app_impl/startup_new_actions.rs:87:                                AppView::ArgPrompt { .. } => {
src/app_impl/startup_new_actions.rs:89:                                    logging::log("KEY", "Interceptor: Cmd+K -> toggle_arg_actions (ArgPrompt)");
src/app_impl/startup_new_actions.rs:203:                                AppView::ArgPrompt { .. } => Some(ActionsDialogHost::ArgPrompt),
src/app_impl/startup_new_actions.rs:231:                                            ActionsDialogHost::ArgPrompt => {
src/main_entry/runtime_stdin.rs:400:                                    AppView::ArgPrompt { id, .. } => {
src/main_entry/runtime_stdin.rs:402:                                        logging::log("STDIN", &format!("SimulateKey: Dispatching '{}' to ArgPrompt (actions_popup={})", key_lower, view.show_actions_popup));
src/main_entry/runtime_stdin.rs:429:                                                                view.focused_input = FocusedInput::ArgPrompt;
src/main_entry/runtime_stdin.rs:439:                                                        view.focused_input = FocusedInput::ArgPrompt;
file update:
diff --git a/src/builtins/part_001_entries/entries_000.rs b/src/builtins/part_001_entries/entries_000.rs
index 926be9edb8db75488c1894f105dba265b103c614..1b3e861bd2e0390edbd6aafc031907ffa15a7cd5
--- a/src/builtins/part_001_entries/entries_000.rs
+++ b/src/builtins/part_001_entries/entries_000.rs
@@ -69,6 +69,24 @@
     ));
     debug!("Added Notes built-in entry");
 
+    entries.push(BuiltInEntry::new_with_icon(
+        "builtin-quicklinks",
+        "Quicklinks",
+        "Manage quick links and open URLs with optional {query} expansion",
+        vec![
+            "quicklinks",
+            "quicklink",
+            "link",
+            "url",
+            "bookmark",
+            "open",
+            "search",
+        ],
+        BuiltInFeature::Quicklinks,
+        "ðŸ”—",
+    ));
+    debug!("Added Quicklinks built-in entry");
+
     // Design Gallery is only available in debug builds (developer tool)
     #[cfg(debug_assertions)]
     {
diff --git a/src/quicklinks/mod.rs b/src/quicklinks/mod.rs
index 08aeea02e216c8026f59f0d8fe5627ededb1dec0..e9e055c95e2b0cd21fbc8b79971df226a788899c
--- a/src/quicklinks/mod.rs
+++ b/src/quicklinks/mod.rs
@@ -43,6 +43,14 @@
     url_template.replace(QUERY_PLACEHOLDER, query)
 }
 
+pub fn has_query_placeholder(url_template: &str) -> bool {
+    url_template.contains(QUERY_PLACEHOLDER)
+}
+
+pub fn update_quicklink(id: &str, name: &str, url_template: &str) -> bool {
+    update_quicklink_from_path(id, name, url_template, &quicklinks_path())
+}
+
 fn quicklinks_path() -> PathBuf {
     dirs::home_dir()
         .map(|home| home.join(".scriptkit").join(QUICKLINKS_FILE))
@@ -75,11 +83,22 @@
     let _ = save_quicklinks_to_path(&links, path);
 }
 
+fn update_quicklink_from_path(id: &str, name: &str, url_template: &str, path: &Path) -> bool {
+    let mut links = load_quicklinks_from_path(path);
+    if let Some(link) = links.iter_mut().find(|link| link.id == id) {
+        link.name = name.trim().to_string();
+        link.url_template = url_template.trim().to_string();
+        return save_quicklinks_to_path(&links, path).is_ok();
+    }
+
+    false
+}
+
 #[cfg(test)]
 mod tests {
     use super::{
-        create_quicklink, delete_quicklink_from_path, expand_url, load_quicklinks_from_path,
-        save_quicklinks_to_path, Quicklink,
+        create_quicklink, delete_quicklink_from_path, expand_url, has_query_placeholder,
+        load_quicklinks_from_path, save_quicklinks_to_path, update_quicklink_from_path, Quicklink,
     };
 
     #[test]
@@ -105,6 +124,16 @@
     }
 
     #[test]
+    fn test_has_query_placeholder_returns_true_when_template_contains_placeholder() {
+        assert!(has_query_placeholder("https://example.com?q={query}"));
+    }
+
+    #[test]
+    fn test_has_query_placeholder_returns_false_when_template_missing_placeholder() {
+        assert!(!has_query_placeholder("https://example.com"));
+    }
+
+    #[test]
     fn test_load_quicklinks_from_path_returns_empty_when_file_missing() {
         let dir = tempfile::tempdir().expect("create temp dir");
         let path = dir.path().join("quicklinks.json");
@@ -174,4 +203,49 @@
         assert_eq!(loaded.len(), 1);
         assert_eq!(loaded[0].id, "keep");
     }
+
+    #[test]
+    fn test_update_quicklink_from_path_updates_name_and_url_template() {
+        let dir = tempfile::tempdir().expect("create temp dir");
+        let path = dir.path().join("quicklinks.json");
+        let links = vec![Quicklink {
+            id: "target".to_string(),
+            name: "Old".to_string(),
+            url_template: "https://old.example.com".to_string(),
+            icon: None,
+        }];
+
+        save_quicklinks_to_path(&links, &path).expect("seed quicklinks");
+        let updated = update_quicklink_from_path(
+            "target",
+            " New Name ",
+            " https://new.example.com?q={query} ",
+            &path,
+        );
+
+        assert!(updated);
+        let loaded = load_quicklinks_from_path(&path);
+        assert_eq!(loaded.len(), 1);
+        assert_eq!(loaded[0].name, "New Name");
+        assert_eq!(loaded[0].url_template, "https://new.example.com?q={query}");
+    }
+
+    #[test]
+    fn test_update_quicklink_from_path_returns_false_when_id_not_found() {
+        let dir = tempfile::tempdir().expect("create temp dir");
+        let path = dir.path().join("quicklinks.json");
+        let links = vec![Quicklink {
+            id: "target".to_string(),
+            name: "Keep".to_string(),
+            url_template: "https://example.com".to_string(),
+            icon: None,
+        }];
+
+        save_quicklinks_to_path(&links, &path).expect("seed quicklinks");
+        let updated = update_quicklink_from_path("missing", "Name", "https://updated.example.com", &path);
+
+        assert!(!updated);
+        let loaded = load_quicklinks_from_path(&path);
+        assert_eq!(loaded, links);
+    }
 }


thinking
**Examining prompt response submission**
exec
/bin/zsh -lc "sed -n '200,330p' src/app_impl/prompt_ai.rs" in /Users/johnlindquist/dev/script-kit-gpui succeeded in 51ms:
                | AppView::TermPrompt { .. }
                | AppView::EditorPrompt { .. }
                | AppView::ClipboardHistoryView { .. }
                | AppView::AppLauncherView { .. }
                | AppView::WindowSwitcherView { .. }
                | AppView::DesignGalleryView { .. }
                | AppView::ScratchPadView { .. }
                | AppView::QuickTerminalView { .. }
        )
    }

    /// Submit a response to the current prompt
    ///
    /// Uses try_send() to avoid blocking the UI thread if the script's input
    /// channel is full. User-initiated actions should never freeze the UI.
    pub(crate) fn submit_prompt_response(
        &mut self,
        id: String,
        value: Option<String>,
        _cx: &mut Context<Self>,
file update:
diff --git a/src/builtins/part_001_entries/entries_000.rs b/src/builtins/part_001_entries/entries_000.rs
index 926be9edb8db75488c1894f105dba265b103c614..1b3e861bd2e0390edbd6aafc031907ffa15a7cd5
--- a/src/builtins/part_001_entries/entries_000.rs
+++ b/src/builtins/part_001_entries/entries_000.rs
@@ -69,6 +69,24 @@
     ));
     debug!("Added Notes built-in entry");
 
+    entries.push(BuiltInEntry::new_with_icon(
+        "builtin-quicklinks",
+        "Quicklinks",
+        "Manage quick links and open URLs with optional {query} expansion",
+        vec![
+            "quicklinks",
+            "quicklink",
+            "link",
+            "url",
+            "bookmark",
+            "open",
+            "search",
+        ],
+        BuiltInFeature::Quicklinks,
+        "ðŸ”—",
+    ));
+    debug!("Added Quicklinks built-in entry");
+
     // Design Gallery is only available in debug builds (developer tool)
     #[cfg(debug_assertions)]
     {
diff --git a/src/quicklinks/mod.rs b/src/quicklinks/mod.rs
index 08aeea02e216c8026f59f0d8fe5627ededb1dec0..e9e055c95e2b0cd21fbc8b79971df226a788899c
--- a/src/quicklinks/mod.rs
+++ b/src/quicklinks/mod.rs
@@ -43,6 +43,14 @@
     url_template.replace(QUERY_PLACEHOLDER, query)
 }
 
+pub fn has_query_placeholder(url_template: &str) -> bool {
+    url_template.contains(QUERY_PLACEHOLDER)
+}
+
+pub fn update_quicklink(id: &str, name: &str, url_template: &str) -> bool {
+    update_quicklink_from_path(id, name, url_template, &quicklinks_path())
+}
+
 fn quicklinks_path() -> PathBuf {
     dirs::home_dir()
         .map(|home| home.join(".scriptkit").join(QUICKLINKS_FILE))
@@ -75,11 +83,22 @@
     let _ = save_quicklinks_to_path(&links, path);
 }
 
+fn update_quicklink_from_path(id: &str, name: &str, url_template: &str, path: &Path) -> bool {
+    let mut links = load_quicklinks_from_path(path);
+    if let Some(link) = links.iter_mut().find(|link| link.id == id) {
+        link.name = name.trim().to_string();
+        link.url_template = url_template.trim().to_string();
+        return save_quicklinks_to_path(&links, path).is_ok();
+    }
+
+    false
+}
+
 #[cfg(test)]
 mod tests {
     use super::{
-        create_quicklink, delete_quicklink_from_path, expand_url, load_quicklinks_from_path,
-        save_quicklinks_to_path, Quicklink,
+        create_quicklink, delete_quicklink_from_path, expand_url, has_query_placeholder,
+        load_quicklinks_from_path, save_quicklinks_to_path, update_quicklink_from_path, Quicklink,
     };
 
     #[test]
@@ -105,6 +124,16 @@
     }
 
     #[test]
+    fn test_has_query_placeholder_returns_true_when_template_contains_placeholder() {
+        assert!(has_query_placeholder("https://example.com?q={query}"));
+    }
+
+    #[test]
+    fn test_has_query_placeholder_returns_false_when_template_missing_placeholder() {
+        assert!(!has_query_placeholder("https://example.com"));
+    }
+
+    #[test]
     fn test_load_quicklinks_from_path_returns_empty_when_file_missing() {
         let dir = tempfile::tempdir().expect("create temp dir");
         let path = dir.path().join("quicklinks.json");
@@ -174,4 +203,49 @@
         assert_eq!(loaded.len(), 1);
         assert_eq!(loaded[0].id, "keep");
     }
+
+    #[test]
+    fn test_update_quicklink_from_path_updates_name_and_url_template() {
+        let dir = tempfile::tempdir().expect("create temp dir");
+        let path = dir.path().join("quicklinks.json");
+        let links = vec![Quicklink {
+            id: "target".to_string(),
+            name: "Old".to_string(),
+            url_template: "https://old.example.com".to_string(),
+            icon: None,
+        }];
+
+        save_quicklinks_to_path(&links, &path).expect("seed quicklinks");
+        let updated = update_quicklink_from_path(
+            "target",
+            " New Name ",
+            " https://new.example.com?q={query} ",
+            &path,
+        );
+
+        assert!(updated);
+        let loaded = load_quicklinks_from_path(&path);
+        assert_eq!(loaded.len(), 1);
+        assert_eq!(loaded[0].name, "New Name");
+        assert_eq!(loaded[0].url_template, "https://new.example.com?q={query}");
+    }
+
+    #[test]
+    fn test_update_quicklink_from_path_returns_false_when_id_not_found() {
+        let dir = tempfile::tempdir().expect("create temp dir");
+        let path = dir.path().join("quicklinks.json");
+        let links = vec![Quicklink {
+            id: "target".to_string(),
+            name: "Keep".to_string(),
+            url_template: "https://example.com".to_string(),
+            icon: None,
+        }];
+
+        save_quicklinks_to_path(&links, &path).expect("seed quicklinks");
+        let updated = update_quicklink_from_path("missing", "Name", "https://updated.example.com", &path);
+
+        assert!(!updated);
+        let loaded = load_quicklinks_from_path(&path);
+        assert_eq!(loaded, links);
+    }
 }

 succeeded in 4m 44s:
Claimed for codex-wire-quicklinks: src/builtins/part_000.rs
 succeeded in 2m 22s:
Claimed for codex-wire-quicklinks: src/builtins/part_000.rs
 succeeded in 2m 22s:
Claimed for codex-wire-quicklinks: src/app_execute/builtin_execution.rs

thinking
**Scoping quicklinks integration options**
codex
Iâ€™m evaluating a lower-risk integration path: invoking the existing Quick Links extension script, but only if it actually uses `src/quicklinks/mod.rs`; otherwise Iâ€™ll keep implementing native built-in flow. Iâ€™m checking that script now.
exec
/bin/zsh -lc "sed -n '1,260p' kit-init/extensions/quicklinks/main.md" in /Users/johnlindquist/dev/script-kit-gpui succeeded in 51ms:
---
name: Quick Links
description: Quick access to commonly used websites
author: Script Kit
icon: link
---

# Quick Links

Instantly open your most frequently used websites.

---

## Google Search

<!--
description: Open Google Search
-->

```open
file update:
diff --git a/src/builtins/part_001_entries/entries_000.rs b/src/builtins/part_001_entries/entries_000.rs
index 926be9edb8db75488c1894f105dba265b103c614..1b3e861bd2e0390edbd6aafc031907ffa15a7cd5
--- a/src/builtins/part_001_entries/entries_000.rs
+++ b/src/builtins/part_001_entries/entries_000.rs
@@ -69,6 +69,24 @@
     ));
     debug!("Added Notes built-in entry");
 
+    entries.push(BuiltInEntry::new_with_icon(
+        "builtin-quicklinks",
+        "Quicklinks",
+        "Manage quick links and open URLs with optional {query} expansion",
+        vec![
+            "quicklinks",
+            "quicklink",
+            "link",
+            "url",
+            "bookmark",
+            "open",
+            "search",
+        ],
+        BuiltInFeature::Quicklinks,
+        "ðŸ”—",
+    ));
+    debug!("Added Quicklinks built-in entry");
+
     // Design Gallery is only available in debug builds (developer tool)
     #[cfg(debug_assertions)]
     {
diff --git a/src/quicklinks/mod.rs b/src/quicklinks/mod.rs
index 08aeea02e216c8026f59f0d8fe5627ededb1dec0..e9e055c95e2b0cd21fbc8b79971df226a788899c
--- a/src/quicklinks/mod.rs
+++ b/src/quicklinks/mod.rs
@@ -43,6 +43,14 @@
     url_template.replace(QUERY_PLACEHOLDER, query)
 }
 
+pub fn has_query_placeholder(url_template: &str) -> bool {
+    url_template.contains(QUERY_PLACEHOLDER)
+}
+
+pub fn update_quicklink(id: &str, name: &str, url_template: &str) -> bool {
+    update_quicklink_from_path(id, name, url_template, &quicklinks_path())
+}
+
 fn quicklinks_path() -> PathBuf {
     dirs::home_dir()
         .map(|home| home.join(".scriptkit").join(QUICKLINKS_FILE))
@@ -75,11 +83,22 @@
     let _ = save_quicklinks_to_path(&links, path);
 }
 
+fn update_quicklink_from_path(id: &str, name: &str, url_template: &str, path: &Path) -> bool {
+    let mut links = load_quicklinks_from_path(path);
+    if let Some(link) = links.iter_mut().find(|link| link.id == id) {
+        link.name = name.trim().to_string();
+        link.url_template = url_template.trim().to_string();
+        return save_quicklinks_to_path(&links, path).is_ok();
+    }
+
+    false
+}
+
 #[cfg(test)]
 mod tests {
     use super::{
-        create_quicklink, delete_quicklink_from_path, expand_url, load_quicklinks_from_path,
-        save_quicklinks_to_path, Quicklink,
+        create_quicklink, delete_quicklink_from_path, expand_url, has_query_placeholder,
+        load_quicklinks_from_path, save_quicklinks_to_path, update_quicklink_from_path, Quicklink,
     };
 
     #[test]
@@ -105,6 +124,16 @@
     }
 
     #[test]
+    fn test_has_query_placeholder_returns_true_when_template_contains_placeholder() {
+        assert!(has_query_placeholder("https://example.com?q={query}"));
+    }
+
+    #[test]
+    fn test_has_query_placeholder_returns_false_when_template_missing_placeholder() {
+        assert!(!has_query_placeholder("https://example.com"));
+    }
+
+    #[test]
     fn test_load_quicklinks_from_path_returns_empty_when_file_missing() {
         let dir = tempfile::tempdir().expect("create temp dir");
         let path = dir.path().join("quicklinks.json");
@@ -174,4 +203,49 @@
         assert_eq!(loaded.len(), 1);
         assert_eq!(loaded[0].id, "keep");
     }
+
+    #[test]
+    fn test_update_quicklink_from_path_updates_name_and_url_template() {
+        let dir = tempfile::tempdir().expect("create temp dir");
+        let path = dir.path().join("quicklinks.json");
+        let links = vec![Quicklink {
+            id: "target".to_string(),
+            name: "Old".to_string(),
+            url_template: "https://old.example.com".to_string(),
+            icon: None,
+        }];
+
+        save_quicklinks_to_path(&links, &path).expect("seed quicklinks");
+        let updated = update_quicklink_from_path(
+            "target",
+            " New Name ",
+            " https://new.example.com?q={query} ",
+            &path,
+        );
+
+        assert!(updated);
+        let loaded = load_quicklinks_from_path(&path);
+        assert_eq!(loaded.len(), 1);
+        assert_eq!(loaded[0].name, "New Name");
+        assert_eq!(loaded[0].url_template, "https://new.example.com?q={query}");
+    }
+
+    #[test]
+    fn test_update_quicklink_from_path_returns_false_when_id_not_found() {
+        let dir = tempfile::tempdir().expect("create temp dir");
+        let path = dir.path().join("quicklinks.json");
+        let links = vec![Quicklink {
+            id: "target".to_string(),
+            name: "Keep".to_string(),
+            url_template: "https://example.com".to_string(),
+            icon: None,
+        }];
+
+        save_quicklinks_to_path(&links, &path).expect("seed quicklinks");
+        let updated = update_quicklink_from_path("missing", "Name", "https://updated.example.com", &path);
+
+        assert!(!updated);
+        let loaded = load_quicklinks_from_path(&path);
+        assert_eq!(loaded, links);
+    }
 }


thinking
**Inspecting quicklinks module methods**
exec
/bin/zsh -lc "sed -n '1,320p' src/quicklinks/mod.rs" in /Users/johnlindquist/dev/script-kit-gpui succeeded in 52ms:
//! Quicklinks data model and JSON storage.

use std::fs;
use std::path::{Path, PathBuf};

use serde::{Deserialize, Serialize};
use uuid::Uuid;

const QUICKLINKS_FILE: &str = "quicklinks.json";
const QUERY_PLACEHOLDER: &str = "{query}";

#[derive(Clone, Debug, Serialize, Deserialize, PartialEq, Eq)]
pub struct Quicklink {
    pub id: String,
    pub name: String,
    pub url_template: String,
    #[serde(default)]
    pub icon: Option<String>,
}

file update:
diff --git a/src/builtins/part_001_entries/entries_000.rs b/src/builtins/part_001_entries/entries_000.rs
index 926be9edb8db75488c1894f105dba265b103c614..1b3e861bd2e0390edbd6aafc031907ffa15a7cd5
--- a/src/builtins/part_001_entries/entries_000.rs
+++ b/src/builtins/part_001_entries/entries_000.rs
@@ -69,6 +69,24 @@
     ));
     debug!("Added Notes built-in entry");
 
+    entries.push(BuiltInEntry::new_with_icon(
+        "builtin-quicklinks",
+        "Quicklinks",
+        "Manage quick links and open URLs with optional {query} expansion",
+        vec![
+            "quicklinks",
+            "quicklink",
+            "link",
+            "url",
+            "bookmark",
+            "open",
+            "search",
+        ],
+        BuiltInFeature::Quicklinks,
+        "ðŸ”—",
+    ));
+    debug!("Added Quicklinks built-in entry");
+
     // Design Gallery is only available in debug builds (developer tool)
     #[cfg(debug_assertions)]
     {
diff --git a/src/quicklinks/mod.rs b/src/quicklinks/mod.rs
index 08aeea02e216c8026f59f0d8fe5627ededb1dec0..e9e055c95e2b0cd21fbc8b79971df226a788899c
--- a/src/quicklinks/mod.rs
+++ b/src/quicklinks/mod.rs
@@ -43,6 +43,14 @@
     url_template.replace(QUERY_PLACEHOLDER, query)
 }
 
+pub fn has_query_placeholder(url_template: &str) -> bool {
+    url_template.contains(QUERY_PLACEHOLDER)
+}
+
+pub fn update_quicklink(id: &str, name: &str, url_template: &str) -> bool {
+    update_quicklink_from_path(id, name, url_template, &quicklinks_path())
+}
+
 fn quicklinks_path() -> PathBuf {
     dirs::home_dir()
         .map(|home| home.join(".scriptkit").join(QUICKLINKS_FILE))
@@ -75,11 +83,22 @@
     let _ = save_quicklinks_to_path(&links, path);
 }
 
+fn update_quicklink_from_path(id: &str, name: &str, url_template: &str, path: &Path) -> bool {
+    let mut links = load_quicklinks_from_path(path);
+    if let Some(link) = links.iter_mut().find(|link| link.id == id) {
+        link.name = name.trim().to_string();
+        link.url_template = url_template.trim().to_string();
+        return save_quicklinks_to_path(&links, path).is_ok();
+    }
+
+    false
+}
+
 #[cfg(test)]
 mod tests {
     use super::{
-        create_quicklink, delete_quicklink_from_path, expand_url, load_quicklinks_from_path,
-        save_quicklinks_to_path, Quicklink,
+        create_quicklink, delete_quicklink_from_path, expand_url, has_query_placeholder,
+        load_quicklinks_from_path, save_quicklinks_to_path, update_quicklink_from_path, Quicklink,
     };
 
     #[test]
@@ -105,6 +124,16 @@
     }
 
     #[test]
+    fn test_has_query_placeholder_returns_true_when_template_contains_placeholder() {
+        assert!(has_query_placeholder("https://example.com?q={query}"));
+    }
+
+    #[test]
+    fn test_has_query_placeholder_returns_false_when_template_missing_placeholder() {
+        assert!(!has_query_placeholder("https://example.com"));
+    }
+
+    #[test]
     fn test_load_quicklinks_from_path_returns_empty_when_file_missing() {
         let dir = tempfile::tempdir().expect("create temp dir");
         let path = dir.path().join("quicklinks.json");
@@ -174,4 +203,49 @@
         assert_eq!(loaded.len(), 1);
         assert_eq!(loaded[0].id, "keep");
     }
+
+    #[test]
+    fn test_update_quicklink_from_path_updates_name_and_url_template() {
+        let dir = tempfile::tempdir().expect("create temp dir");
+        let path = dir.path().join("quicklinks.json");
+        let links = vec![Quicklink {
+            id: "target".to_string(),
+            name: "Old".to_string(),
+            url_template: "https://old.example.com".to_string(),
+            icon: None,
+        }];
+
+        save_quicklinks_to_path(&links, &path).expect("seed quicklinks");
+        let updated = update_quicklink_from_path(
+            "target",
+            " New Name ",
+            " https://new.example.com?q={query} ",
+            &path,
+        );
+
+        assert!(updated);
+        let loaded = load_quicklinks_from_path(&path);
+        assert_eq!(loaded.len(), 1);
+        assert_eq!(loaded[0].name, "New Name");
+        assert_eq!(loaded[0].url_template, "https://new.example.com?q={query}");
+    }
+
+    #[test]
+    fn test_update_quicklink_from_path_returns_false_when_id_not_found() {
+        let dir = tempfile::tempdir().expect("create temp dir");
+        let path = dir.path().join("quicklinks.json");
+        let links = vec![Quicklink {
+            id: "target".to_string(),
+            name: "Keep".to_string(),
+            url_template: "https://example.com".to_string(),
+            icon: None,
+        }];
+
+        save_quicklinks_to_path(&links, &path).expect("seed quicklinks");
+        let updated = update_quicklink_from_path("missing", "Name", "https://updated.example.com", &path);
+
+        assert!(!updated);
+        let loaded = load_quicklinks_from_path(&path);
+        assert_eq!(loaded, links);
+    }
 }


thinking
**Assessing builtin entry impact on tests**
codex
Iâ€™m still blocked on `part_000` and `builtin_execution`, and those two files are exactly where the remaining feature logic must land. Iâ€™m polling swarm state now so I can resume as soon as they release.
exec
/bin/zsh -lc '~/.claude/bin/swarm.ts status' in /Users/johnlindquist/dev/script-kit-gpui succeeded in 51ms:
Repo: /Users/johnlindquist/dev/script-kit-gpui
Updated: 2026-02-08T03:05:35.377Z

Active agents (2):
codex-wire-emoji [in_progress] codex/gpt-5.3-codex/exec
  task: Wire up the existing src/emoji/mod.rs static emoji database into the app as a working built-in feature. The module has â€¦
  scope: src/emoji/**,src/builtins/part_000.rs,src/builtins/part_001_entries/**,src/app_execute/builtin_execution.rs
  claims: (none)
  notes: Starting emoji built-in wiring; preparing claims and reading existing emoji + clipboard flow

codex-wire-quicklinks [blocked] codex/gpt-5.3-codex/exec
  task: Wire up the existing src/quicklinks/mod.rs storage module into the app as a working built-in feature. The module alreadâ€¦
  scope: src/quicklinks/**,src/builtins/part_000.rs,src/builtins/part_001_entries/**,src/app_execute/builtin_execution.rs
  claims(4): src/builtins/part_001_entries/entries_000.rs, src/quicklinks/mod.rs, src/builtins/part_000.rs, src/app_execute/builtin_execution.rs
  notes: Added quicklinks module helpers/tests + builtin entry in entries_000.rs; waiting for claims on src/builtins/part_000.rs and src/app_execute/builtin_execution.rs

Inactive agents (257):
- codex-accessibility [done] done. exit=0. final=.ai/logs/codex-accessibility.final.md. See final message file.
- codex-action-labels [failed] failed. exit=1. final=.ai/logs/codex-action-labels.final.md.
- codex-actions-audit [failed] failed. exit=1. final=.ai/logs/codex-actions-audit.final.md. See final message file.
file update:
diff --git a/src/builtins/part_001_entries/entries_000.rs b/src/builtins/part_001_entries/entries_000.rs
index 926be9edb8db75488c1894f105dba265b103c614..1b3e861bd2e0390edbd6aafc031907ffa15a7cd5
--- a/src/builtins/part_001_entries/entries_000.rs
+++ b/src/builtins/part_001_entries/entries_000.rs
@@ -69,6 +69,24 @@
     ));
     debug!("Added Notes built-in entry");
 
+    entries.push(BuiltInEntry::new_with_icon(
+        "builtin-quicklinks",
+        "Quicklinks",
+        "Manage quick links and open URLs with optional {query} expansion",
+        vec![
+            "quicklinks",
+            "quicklink",
+            "link",
+            "url",
+            "bookmark",
+            "open",
+            "search",
+        ],
+        BuiltInFeature::Quicklinks,
+        "ðŸ”—",
+    ));
+    debug!("Added Quicklinks built-in entry");
+
     // Design Gallery is only available in debug builds (developer tool)
     #[cfg(debug_assertions)]
     {
diff --git a/src/quicklinks/mod.rs b/src/quicklinks/mod.rs
index 08aeea02e216c8026f59f0d8fe5627ededb1dec0..e9e055c95e2b0cd21fbc8b79971df226a788899c
--- a/src/quicklinks/mod.rs
+++ b/src/quicklinks/mod.rs
@@ -43,6 +43,14 @@
     url_template.replace(QUERY_PLACEHOLDER, query)
 }
 
+pub fn has_query_placeholder(url_template: &str) -> bool {
+    url_template.contains(QUERY_PLACEHOLDER)
+}
+
+pub fn update_quicklink(id: &str, name: &str, url_template: &str) -> bool {
+    update_quicklink_from_path(id, name, url_template, &quicklinks_path())
+}
+
 fn quicklinks_path() -> PathBuf {
     dirs::home_dir()
         .map(|home| home.join(".scriptkit").join(QUICKLINKS_FILE))
@@ -75,11 +83,22 @@
     let _ = save_quicklinks_to_path(&links, path);
 }
 
+fn update_quicklink_from_path(id: &str, name: &str, url_template: &str, path: &Path) -> bool {
+    let mut links = load_quicklinks_from_path(path);
+    if let Some(link) = links.iter_mut().find(|link| link.id == id) {
+        link.name = name.trim().to_string();
+        link.url_template = url_template.trim().to_string();
+        return save_quicklinks_to_path(&links, path).is_ok();
+    }
+
+    false
+}
+
 #[cfg(test)]
 mod tests {
     use super::{
-        create_quicklink, delete_quicklink_from_path, expand_url, load_quicklinks_from_path,
-        save_quicklinks_to_path, Quicklink,
+        create_quicklink, delete_quicklink_from_path, expand_url, has_query_placeholder,
+        load_quicklinks_from_path, save_quicklinks_to_path, update_quicklink_from_path, Quicklink,
     };
 
     #[test]
@@ -105,6 +124,16 @@
     }
 
     #[test]
+    fn test_has_query_placeholder_returns_true_when_template_contains_placeholder() {
+        assert!(has_query_placeholder("https://example.com?q={query}"));
+    }
+
+    #[test]
+    fn test_has_query_placeholder_returns_false_when_template_missing_placeholder() {
+        assert!(!has_query_placeholder("https://example.com"));
+    }
+
+    #[test]
     fn test_load_quicklinks_from_path_returns_empty_when_file_missing() {
         let dir = tempfile::tempdir().expect("create temp dir");
         let path = dir.path().join("quicklinks.json");
@@ -174,4 +203,49 @@
         assert_eq!(loaded.len(), 1);
         assert_eq!(loaded[0].id, "keep");
     }
+
+    #[test]
+    fn test_update_quicklink_from_path_updates_name_and_url_template() {
+        let dir = tempfile::tempdir().expect("create temp dir");
+        let path = dir.path().join("quicklinks.json");
+        let links = vec![Quicklink {
+            id: "target".to_string(),
+            name: "Old".to_string(),
+            url_template: "https://old.example.com".to_string(),
+            icon: None,
+        }];
+
+        save_quicklinks_to_path(&links, &path).expect("seed quicklinks");
+        let updated = update_quicklink_from_path(
+            "target",
+            " New Name ",
+            " https://new.example.com?q={query} ",
+            &path,
+        );
+
+        assert!(updated);
+        let loaded = load_quicklinks_from_path(&path);
+        assert_eq!(loaded.len(), 1);
+        assert_eq!(loaded[0].name, "New Name");
+        assert_eq!(loaded[0].url_template, "https://new.example.com?q={query}");
+    }
+
+    #[test]
+    fn test_update_quicklink_from_path_returns_false_when_id_not_found() {
+        let dir = tempfile::tempdir().expect("create temp dir");
+        let path = dir.path().join("quicklinks.json");
+        let links = vec![Quicklink {
+            id: "target".to_string(),
+            name: "Keep".to_string(),
+            url_template: "https://example.com".to_string(),
+            icon: None,
+        }];
+
+        save_quicklinks_to_path(&links, &path).expect("seed quicklinks");
+        let updated = update_quicklink_from_path("missing", "Name", "https://updated.example.com", &path);
+
+        assert!(!updated);
+        let loaded = load_quicklinks_from_path(&path);
+        assert_eq!(loaded, links);
+    }
 }


thinking
**Confirming claim status and clearing lingering processes**
exec
/bin/zsh -lc "ps -ax -o pid,command | rg 'swarm.ts claim --wait --id codex-wire-quicklinks'" in /Users/johnlindquist/dev/script-kit-gpui succeeded in 51ms:
18350 /bin/zsh -lc ps -ax -o pid,command | rg 'swarm.ts claim --wait --id codex-wire-quicklinks'
18355 rg swarm.ts claim --wait --id codex-wire-quicklinks
96435 node /Users/johnlindquist/.bun/bin/codex exec --cd /Users/johnlindquist/dev/script-kit-gpui --model gpt-5.3-codex -c model_reasoning_effort="xhigh" -c model_auto_compact_token_limit=120000 -c developer_instructions="You are Codex implementer agent \"codex-wire-quicklinks\".\n\n## Coordination\nThis repo runs parallel agents in ONE working tree. Before editing any file, you MUST claim it.\nCommands (run via shell):\n  - View roster: ~/.claude/bin/swarm.ts status\n  - Claim files (blocks until free): ~/.claude/bin/swarm.ts claim --wait --id codex-wire-quicklinks path/to/file\n  - Release: ~/.claude/bin/swarm.ts release --id codex-wire-quicklinks path/to/file\n  - Update status/notes: ~/.claude/bin/swarm.ts update --id codex-wire-quicklinks --status in_progress --notes \"...\"\nRules:\n  - Never edit a file you haven't claimed.\n  - Keep claims tight (claim only what you're actively changing).\n  - If blocked, set status=blocked and say what you're waiting on.\n  - When finished, set status=done and release claims.\n\n## Development practices (this code is maintained by AI agents)\n  - Log state transitions with enough context to diagnose failures from logs alone.\n  - Structured errors: include what was attempted, what failed, and current state.\n  - Name things for grepability â€” unique identifiers agents can find on the first search.\n  - Every behavior change gets a test. Untested code is invisible to the next agent.\n  - Test names describe the scenario: test_X_does_Y_when_Z.\n  - Keep functions small and single-purpose. 500-line functions burn agent context.\n  - Use types to encode constraints (enums > strings for errors).\n\n## CRITICAL: Parallel-safe verification\n  - Other agents are modifying other files RIGHT NOW. Full test suites WILL show their failures.\n  - ONLY run tests that cover YOUR changed files. Scope every test/check command:\n    Rust: cargo test -p your-crate -- module::test_name | JS: npx jest your/file.test.ts\n  - Do NOT run: cargo test (unscoped), cargo check (whole workspace), npm test (unscoped).\n  - If a scoped test fails, it's YOUR bug â€” fix it. If tests outside your scope fail, ignore them.\n\n## Git commit discipline\n  - NEVER commit unverified work. Run tests/lints/type-checks FIRST. If it fails, fix it before committing.\n  - A commit is a declaration: \"this works and here's the proof.\"\n  - Commit FREQUENTLY â€” after each meaningful unit of VERIFIED work, not just at the end.\n  - A \"unit\" = one logical change that passes verification (new function, bug fix, refactor, test added).\n  - NEVER batch an entire task into one giant commit. Small commits are searchable; big ones aren't.\n  - Commit message format:\n      Line 1: <type>(<scope>): <what changed> (imperative, max 72 chars)\n      Line 3+: WHY this change was made, WHAT was verified, and HOW to test it.\n    Types: feat, fix, refactor, test, docs, chore\n    Example:\n      feat(auth): add refresh token rotation\n      \n      Tokens now rotate on each refresh call to prevent replay attacks.\n      The old token is invalidated immediately on rotation.\n      \n      Verified: cargo test --lib -- auth::refresh (4 tests pass)\n      Verified: manual smoke test via curl â€” token rotates, old token returns 401\n  - The \"Verified:\" lines are REQUIRED. Future agents will read git log to understand\n    what was tested and how to re-verify. This is the most valuable part of the message.\n  - In your final message, list all commits you made with their hashes.\n\n## Time budget\nYou have approximately 10 minutes. If your task is too broad to complete in time:\n(1) Commit any verified progress.\n(2) Run: ~/.claude/bin/swarm.ts update --id YOUR_ID --status needs_split --notes 'suggest: 1) sub-task-desc scope:files 2) sub-task-desc scope:files'.\n(3) Exit cleanly. The dispatcher will read your suggestions and spawn narrower workers." --output-last-message /Users/johnlindquist/dev/script-kit-gpui/.ai/logs/codex-wire-quicklinks.final.md --yolo You are agent codex-wire-quicklinks.\012\012Current parallel-agent roster (read this first):\012```\012SWARM SNAPSHOT @ 2026-02-08T02:57:24.003Z\012- codex-wire-favorites [in_progress] scope=src/favorites/**,src/builtins/part_000.rs,src/builtins/part_001_entries/**,src/app_execute/builtin_execution.rs,src/actions/builders/script_context.rs task=Wire up the existing src/favorites/mod.rs storage module into the app as a working feature. The module already has loadâ€¦\012  notes: Inspecting favorites wiring points and planning minimal scoped edits\012- codex-wire-quicklinks [starting] scope=src/quicklinks/**,src/builtins/part_000.rs,src/builtins/part_001_entries/**,src/app_execute/builtin_execution.rs task=Wire up the existing src/quicklinks/mod.rs storage module into the app as a working built-in feature. The module alreadâ€¦\012```\012\012Your assignment:\012- Task: Wire up the existing src/quicklinks/mod.rs storage module into the app as a working built-in feature. The module already has create/load/save/delete/expand_url APIs backed by ~/.scriptkit/quicklinks.json. You need to: (1) Add a BuiltInFeature::Quicklinks variant in src/builtins/part_000.rs with a descriptive entry in get_builtin_entries(), (2) Add execute_builtin handling in src/app_execute/builtin_execution.rs that shows a list of quicklinks, (3) Allow users to add/edit/delete quicklinks and open them (expanding {query} placeholders). The UI should list existing quicklinks and have an option to create new ones. Run cargo check && cargo clippy --all-targets -- -D warnings && cargo test after changes.\012- Scope: src/quicklinks/**,src/builtins/part_000.rs,src/builtins/part_001_entries/**,src/app_execute/builtin_execution.rs\012\012Operating constraints:\012- Single working tree (no worktrees, no patches).\012- You MUST claim files before editing (~/.claude/bin/swarm.ts claim --wait ...).\012\012Deliverables:\012- Make the code changes required by the task.\012- Run the most relevant tests/linters.\012- In your FINAL message, include: changed files, how to test, and any risks/known gaps.
96466 /Users/johnlindquist/.bun/install/global/node_modules/@openai/codex/vendor/aarch64-apple-darwin/codex/codex exec --cd /Users/johnlindquist/dev/script-kit-gpui --model gpt-5.3-codex -c model_reasoning_effort="xhigh" -c model_auto_compact_token_limit=120000 -c developer_instructions="You are Codex implementer agent \"codex-wire-quicklinks\".\n\n## Coordination\nThis repo runs parallel agents in ONE working tree. Before editing any file, you MUST claim it.\nCommands (run via shell):\n  - View roster: ~/.claude/bin/swarm.ts status\n  - Claim files (blocks until free): ~/.claude/bin/swarm.ts claim --wait --id codex-wire-quicklinks path/to/file\n  - Release: ~/.claude/bin/swarm.ts release --id codex-wire-quicklinks path/to/file\n  - Update status/notes: ~/.claude/bin/swarm.ts update --id codex-wire-quicklinks --status in_progress --notes \"...\"\nRules:\n  - Never edit a file you haven't claimed.\n  - Keep claims tight (claim only what you're actively changing).\n  - If blocked, set status=blocked and say what you're waiting on.\n  - When finished, set status=done and release claims.\n\n## Development practices (this code is maintained by AI agents)\n  - Log state transitions with enough context to diagnose failures from logs alone.\n  - Structured errors: include what was attempted, what failed, and current state.\n  - Name things for grepability â€” unique identifiers agents can find on the first search.\n  - Every behavior change gets a test. Untested code is invisible to the next agent.\n  - Test names describe the scenario: test_X_does_Y_when_Z.\n  - Keep functions small and single-purpose. 500-line functions burn agent context.\n  - Use types to encode constraints (enums > strings for errors).\n\n## CRITICAL: Parallel-safe verification\n  - Other agents are modifying other files RIGHT NOW. Full test suites WILL show their failures.\n  - ONLY run tests that cover YOUR changed files. Scope every test/check command:\n    Rust: cargo test -p your-crate -- module::test_name | JS: npx jest your/file.test.ts\n  - Do NOT run: cargo test (unscoped), cargo check (whole workspace), npm test (unscoped).\n  - If a scoped test fails, it's YOUR bug â€” fix it. If tests outside your scope fail, ignore them.\n\n## Git commit discipline\n  - NEVER commit unverified work. Run tests/lints/type-checks FIRST. If it fails, fix it before committing.\n  - A commit is a declaration: \"this works and here's the proof.\"\n  - Commit FREQUENTLY â€” after each meaningful unit of VERIFIED work, not just at the end.\n  - A \"unit\" = one logical change that passes verification (new function, bug fix, refactor, test added).\n  - NEVER batch an entire task into one giant commit. Small commits are searchable; big ones aren't.\n  - Commit message format:\n      Line 1: <type>(<scope>): <what changed> (imperative, max 72 chars)\n      Line 3+: WHY this change was made, WHAT was verified, and HOW to test it.\n    Types: feat, fix, refactor, test, docs, chore\n    Example:\n      feat(auth): add refresh token rotation\n      \n      Tokens now rotate on each refresh call to prevent replay attacks.\n      The old token is invalidated immediately on rotation.\n      \n      Verified: cargo test --lib -- auth::refresh (4 tests pass)\n      Verified: manual smoke test via curl â€” token rotates, old token returns 401\n  - The \"Verified:\" lines are REQUIRED. Future agents will read git log to understand\n    what was tested and how to re-verify. This is the most valuable part of the message.\n  - In your final message, list all commits you made with their hashes.\n\n## Time budget\nYou have approximately 10 minutes. If your task is too broad to complete in time:\n(1) Commit any verified progress.\n(2) Run: ~/.claude/bin/swarm.ts update --id YOUR_ID --status needs_split --notes 'suggest: 1) sub-task-desc scope:files 2) sub-task-desc scope:files'.\n(3) Exit cleanly. The dispatcher will read your suggestions and spawn narrower workers." --output-last-message /Users/johnlindquist/dev/script-kit-gpui/.ai/logs/codex-wire-quicklinks.final.md --yolo You are agent codex-wire-quicklinks.\012\012Current parallel-agent roster (read this first):\012```\012SWARM SNAPSHOT @ 2026-02-08T02:57:24.003Z\012- codex-wire-favorites [in_progress] scope=src/favorites/**,src/builtins/part_000.rs,src/builtins/part_001_entries/**,src/app_execute/builtin_execution.rs,src/actions/builders/script_context.rs task=Wire up the existing src/favorites/mod.rs storage module into the app as a working feature. The module already has loadâ€¦\012  notes: Inspecting favorites wiring points and planning minimal scoped edits\012- codex-wire-quicklinks [starting] scope=src/quicklinks/**,src/builtins/part_000.rs,src/builtins/part_001_entries/**,src/app_execute/builtin_execution.rs task=Wire up the existing src/quicklinks/mod.rs storage module into the app as a working built-in feature. The module alreadâ€¦\012```\012\012Your assignment:\012- Task: Wire up the existing src/quicklinks/mod.rs storage module into the app as a working built-in feature. The module already has create/load/save/delete/expand_url APIs backed by ~/.scriptkit/quicklinks.json. You need to: (1) Add a BuiltInFeature::Quicklinks variant in src/builtins/part_000.rs with a descriptive entry in get_builtin_entries(), (2) Add execute_builtin handling in src/app_execute/builtin_execution.rs that shows a list of quicklinks, (3) Allow users to add/edit/delete quicklinks and open them (expanding {query} placeholders). The UI should list existing quicklinks and have an option to create new ones. Run cargo check && cargo clippy --all-targets -- -D warnings && cargo test after changes.\012- Scope: src/quicklinks/**,src/builtins/part_000.rs,src/builtins/part_001_entries/**,src/app_execute/builtin_execution.rs\012\012Operating constraints:\012- Single working tree (no worktrees, no patches).\012- You MUST claim files before editing (~/.claude/bin/swarm.ts claim --wait ...).\012\012Deliverables:\012- Make the code changes required by the task.\012- Run the most relevant tests/linters.\012- In your FINAL message, include: changed files, how to test, and any risks/known gaps.
file update:
diff --git a/src/builtins/part_001_entries/entries_000.rs b/src/builtins/part_001_entries/entries_000.rs
index 926be9edb8db75488c1894f105dba265b103c614..1b3e861bd2e0390edbd6aafc031907ffa15a7cd5
--- a/src/builtins/part_001_entries/entries_000.rs
+++ b/src/builtins/part_001_entries/entries_000.rs
@@ -69,6 +69,24 @@
     ));
     debug!("Added Notes built-in entry");
 
+    entries.push(BuiltInEntry::new_with_icon(
+        "builtin-quicklinks",
+        "Quicklinks",
+        "Manage quick links and open URLs with optional {query} expansion",
+        vec![
+            "quicklinks",
+            "quicklink",
+            "link",
+            "url",
+            "bookmark",
+            "open",
+            "search",
+        ],
+        BuiltInFeature::Quicklinks,
+        "ðŸ”—",
+    ));
+    debug!("Added Quicklinks built-in entry");
+
     // Design Gallery is only available in debug builds (developer tool)
     #[cfg(debug_assertions)]
     {
diff --git a/src/quicklinks/mod.rs b/src/quicklinks/mod.rs
index 08aeea02e216c8026f59f0d8fe5627ededb1dec0..e9e055c95e2b0cd21fbc8b79971df226a788899c
--- a/src/quicklinks/mod.rs
+++ b/src/quicklinks/mod.rs
@@ -43,6 +43,14 @@
     url_template.replace(QUERY_PLACEHOLDER, query)
 }
 
+pub fn has_query_placeholder(url_template: &str) -> bool {
+    url_template.contains(QUERY_PLACEHOLDER)
+}
+
+pub fn update_quicklink(id: &str, name: &str, url_template: &str) -> bool {
+    update_quicklink_from_path(id, name, url_template, &quicklinks_path())
+}
+
 fn quicklinks_path() -> PathBuf {
     dirs::home_dir()
         .map(|home| home.join(".scriptkit").join(QUICKLINKS_FILE))
@@ -75,11 +83,22 @@
     let _ = save_quicklinks_to_path(&links, path);
 }
 
+fn update_quicklink_from_path(id: &str, name: &str, url_template: &str, path: &Path) -> bool {
+    let mut links = load_quicklinks_from_path(path);
+    if let Some(link) = links.iter_mut().find(|link| link.id == id) {
+        link.name = name.trim().to_string();
+        link.url_template = url_template.trim().to_string();
+        return save_quicklinks_to_path(&links, path).is_ok();
+    }
+
+    false
+}
+
 #[cfg(test)]
 mod tests {
     use super::{
-        create_quicklink, delete_quicklink_from_path, expand_url, load_quicklinks_from_path,
-        save_quicklinks_to_path, Quicklink,
+        create_quicklink, delete_quicklink_from_path, expand_url, has_query_placeholder,
+        load_quicklinks_from_path, save_quicklinks_to_path, update_quicklink_from_path, Quicklink,
     };
 
     #[test]
@@ -105,6 +124,16 @@
     }
 
     #[test]
+    fn test_has_query_placeholder_returns_true_when_template_contains_placeholder() {
+        assert!(has_query_placeholder("https://example.com?q={query}"));
+    }
+
+    #[test]
+    fn test_has_query_placeholder_returns_false_when_template_missing_placeholder() {
+        assert!(!has_query_placeholder("https://example.com"));
+    }
+
+    #[test]
     fn test_load_quicklinks_from_path_returns_empty_when_file_missing() {
         let dir = tempfile::tempdir().expect("create temp dir");
         let path = dir.path().join("quicklinks.json");
@@ -174,4 +203,49 @@
         assert_eq!(loaded.len(), 1);
         assert_eq!(loaded[0].id, "keep");
     }
+
+    #[test]
+    fn test_update_quicklink_from_path_updates_name_and_url_template() {
+        let dir = tempfile::tempdir().expect("create temp dir");
+        let path = dir.path().join("quicklinks.json");
+        let links = vec![Quicklink {
+            id: "target".to_string(),
+            name: "Old".to_string(),
+            url_template: "https://old.example.com".to_string(),
+            icon: None,
+        }];
+
+        save_quicklinks_to_path(&links, &path).expect("seed quicklinks");
+        let updated = update_quicklink_from_path(
+            "target",
+            " New Name ",
+            " https://new.example.com?q={query} ",
+            &path,
+        );
+
+        assert!(updated);
+        let loaded = load_quicklinks_from_path(&path);
+        assert_eq!(loaded.len(), 1);
+        assert_eq!(loaded[0].name, "New Name");
+        assert_eq!(loaded[0].url_template, "https://new.example.com?q={query}");
+    }
+
+    #[test]
+    fn test_update_quicklink_from_path_returns_false_when_id_not_found() {
+        let dir = tempfile::tempdir().expect("create temp dir");
+        let path = dir.path().join("quicklinks.json");
+        let links = vec![Quicklink {
+            id: "target".to_string(),
+            name: "Keep".to_string(),
+            url_template: "https://example.com".to_string(),
+            icon: None,
+        }];
+
+        save_quicklinks_to_path(&links, &path).expect("seed quicklinks");
+        let updated = update_quicklink_from_path("missing", "Name", "https://updated.example.com", &path);
+
+        assert!(!updated);
+        let loaded = load_quicklinks_from_path(&path);
+        assert_eq!(loaded, links);
+    }
 }


thinking
**Updating swarm status**
exec
/bin/zsh -lc '~/.claude/bin/swarm.ts update --id codex-wire-quicklinks --status in_progress --notes "Claims acquired for part_000 + builtin_execution; implementing quicklinks built-in dispatch and list management"' in /Users/johnlindquist/dev/script-kit-gpui succeeded in 51ms:
Updated: codex-wire-quicklinks
file update:
diff --git a/src/builtins/part_001_entries/entries_000.rs b/src/builtins/part_001_entries/entries_000.rs
index 926be9edb8db75488c1894f105dba265b103c614..1b3e861bd2e0390edbd6aafc031907ffa15a7cd5
--- a/src/builtins/part_001_entries/entries_000.rs
+++ b/src/builtins/part_001_entries/entries_000.rs
@@ -69,6 +69,24 @@
     ));
     debug!("Added Notes built-in entry");
 
+    entries.push(BuiltInEntry::new_with_icon(
+        "builtin-quicklinks",
+        "Quicklinks",
+        "Manage quick links and open URLs with optional {query} expansion",
+        vec![
+            "quicklinks",
+            "quicklink",
+            "link",
+            "url",
+            "bookmark",
+            "open",
+            "search",
+        ],
+        BuiltInFeature::Quicklinks,
+        "ðŸ”—",
+    ));
+    debug!("Added Quicklinks built-in entry");
+
     // Design Gallery is only available in debug builds (developer tool)
     #[cfg(debug_assertions)]
     {
diff --git a/src/quicklinks/mod.rs b/src/quicklinks/mod.rs
index 08aeea02e216c8026f59f0d8fe5627ededb1dec0..e9e055c95e2b0cd21fbc8b79971df226a788899c
--- a/src/quicklinks/mod.rs
+++ b/src/quicklinks/mod.rs
@@ -43,6 +43,14 @@
     url_template.replace(QUERY_PLACEHOLDER, query)
 }
 
+pub fn has_query_placeholder(url_template: &str) -> bool {
+    url_template.contains(QUERY_PLACEHOLDER)
+}
+
+pub fn update_quicklink(id: &str, name: &str, url_template: &str) -> bool {
+    update_quicklink_from_path(id, name, url_template, &quicklinks_path())
+}
+
 fn quicklinks_path() -> PathBuf {
     dirs::home_dir()
         .map(|home| home.join(".scriptkit").join(QUICKLINKS_FILE))
@@ -75,11 +83,22 @@
     let _ = save_quicklinks_to_path(&links, path);
 }
 
+fn update_quicklink_from_path(id: &str, name: &str, url_template: &str, path: &Path) -> bool {
+    let mut links = load_quicklinks_from_path(path);
+    if let Some(link) = links.iter_mut().find(|link| link.id == id) {
+        link.name = name.trim().to_string();
+        link.url_template = url_template.trim().to_string();
+        return save_quicklinks_to_path(&links, path).is_ok();
+    }
+
+    false
+}
+
 #[cfg(test)]
 mod tests {
     use super::{
-        create_quicklink, delete_quicklink_from_path, expand_url, load_quicklinks_from_path,
-        save_quicklinks_to_path, Quicklink,
+        create_quicklink, delete_quicklink_from_path, expand_url, has_query_placeholder,
+        load_quicklinks_from_path, save_quicklinks_to_path, update_quicklink_from_path, Quicklink,
     };
 
     #[test]
@@ -105,6 +124,16 @@
     }
 
     #[test]
+    fn test_has_query_placeholder_returns_true_when_template_contains_placeholder() {
+        assert!(has_query_placeholder("https://example.com?q={query}"));
+    }
+
+    #[test]
+    fn test_has_query_placeholder_returns_false_when_template_missing_placeholder() {
+        assert!(!has_query_placeholder("https://example.com"));
+    }
+
+    #[test]
     fn test_load_quicklinks_from_path_returns_empty_when_file_missing() {
         let dir = tempfile::tempdir().expect("create temp dir");
         let path = dir.path().join("quicklinks.json");
@@ -174,4 +203,49 @@
         assert_eq!(loaded.len(), 1);
         assert_eq!(loaded[0].id, "keep");
     }
+
+    #[test]
+    fn test_update_quicklink_from_path_updates_name_and_url_template() {
+        let dir = tempfile::tempdir().expect("create temp dir");
+        let path = dir.path().join("quicklinks.json");
+        let links = vec![Quicklink {
+            id: "target".to_string(),
+            name: "Old".to_string(),
+            url_template: "https://old.example.com".to_string(),
+            icon: None,
+        }];
+
+        save_quicklinks_to_path(&links, &path).expect("seed quicklinks");
+        let updated = update_quicklink_from_path(
+            "target",
+            " New Name ",
+            " https://new.example.com?q={query} ",
+            &path,
+        );
+
+        assert!(updated);
+        let loaded = load_quicklinks_from_path(&path);
+        assert_eq!(loaded.len(), 1);
+        assert_eq!(loaded[0].name, "New Name");
+        assert_eq!(loaded[0].url_template, "https://new.example.com?q={query}");
+    }
+
+    #[test]
+    fn test_update_quicklink_from_path_returns_false_when_id_not_found() {
+        let dir = tempfile::tempdir().expect("create temp dir");
+        let path = dir.path().join("quicklinks.json");
+        let links = vec![Quicklink {
+            id: "target".to_string(),
+            name: "Keep".to_string(),
+            url_template: "https://example.com".to_string(),
+            icon: None,
+        }];
+
+        save_quicklinks_to_path(&links, &path).expect("seed quicklinks");
+        let updated = update_quicklink_from_path("missing", "Name", "https://updated.example.com", &path);
+
+        assert!(!updated);
+        let loaded = load_quicklinks_from_path(&path);
+        assert_eq!(loaded, links);
+    }
 }


thinking
**Inspecting builtins enum variants**
codex
Claims are now free and Iâ€™ve switched to active implementation. Iâ€™m editing `BuiltInFeature` next, then Iâ€™ll add the quicklinks execution flow in `builtin_execution` with create/edit/delete/open behavior.
exec
/bin/zsh -lc "sed -n '180,320p' src/builtins/part_000.rs" in /Users/johnlindquist/dev/script-kit-gpui succeeded in 52ms:
}
/// Groups for categorizing built-in entries in the UI
#[derive(Debug, Clone, Copy, PartialEq, Eq, Default)]
#[allow(dead_code)] // MenuBar variant will be used when menu bar integration is complete
pub enum BuiltInGroup {
    /// Core built-in features (Clipboard History, Window Switcher, etc.)
    #[default]
    Core,
    /// Menu bar items from the frontmost application
    MenuBar,
}
/// Types of built-in features
#[derive(Debug, Clone, PartialEq, Eq)]
#[allow(dead_code)] // Some variants reserved for future use
pub enum BuiltInFeature {
    /// Clipboard history viewer/manager
    ClipboardHistory,
    /// Application launcher for opening installed apps (legacy, apps now in main search)
    AppLauncher,
    /// Individual application entry (for future use when apps appear in search)
file update:
diff --git a/src/builtins/part_001_entries/entries_000.rs b/src/builtins/part_001_entries/entries_000.rs
index 926be9edb8db75488c1894f105dba265b103c614..1b3e861bd2e0390edbd6aafc031907ffa15a7cd5
--- a/src/builtins/part_001_entries/entries_000.rs
+++ b/src/builtins/part_001_entries/entries_000.rs
@@ -69,6 +69,24 @@
     ));
     debug!("Added Notes built-in entry");
 
+    entries.push(BuiltInEntry::new_with_icon(
+        "builtin-quicklinks",
+        "Quicklinks",
+        "Manage quick links and open URLs with optional {query} expansion",
+        vec![
+            "quicklinks",
+            "quicklink",
+            "link",
+            "url",
+            "bookmark",
+            "open",
+            "search",
+        ],
+        BuiltInFeature::Quicklinks,
+        "ðŸ”—",
+    ));
+    debug!("Added Quicklinks built-in entry");
+
     // Design Gallery is only available in debug builds (developer tool)
     #[cfg(debug_assertions)]
     {
diff --git a/src/quicklinks/mod.rs b/src/quicklinks/mod.rs
index 08aeea02e216c8026f59f0d8fe5627ededb1dec0..e9e055c95e2b0cd21fbc8b79971df226a788899c
--- a/src/quicklinks/mod.rs
+++ b/src/quicklinks/mod.rs
@@ -43,6 +43,14 @@
     url_template.replace(QUERY_PLACEHOLDER, query)
 }
 
+pub fn has_query_placeholder(url_template: &str) -> bool {
+    url_template.contains(QUERY_PLACEHOLDER)
+}
+
+pub fn update_quicklink(id: &str, name: &str, url_template: &str) -> bool {
+    update_quicklink_from_path(id, name, url_template, &quicklinks_path())
+}
+
 fn quicklinks_path() -> PathBuf {
     dirs::home_dir()
         .map(|home| home.join(".scriptkit").join(QUICKLINKS_FILE))
@@ -75,11 +83,22 @@
     let _ = save_quicklinks_to_path(&links, path);
 }
 
+fn update_quicklink_from_path(id: &str, name: &str, url_template: &str, path: &Path) -> bool {
+    let mut links = load_quicklinks_from_path(path);
+    if let Some(link) = links.iter_mut().find(|link| link.id == id) {
+        link.name = name.trim().to_string();
+        link.url_template = url_template.trim().to_string();
+        return save_quicklinks_to_path(&links, path).is_ok();
+    }
+
+    false
+}
+
 #[cfg(test)]
 mod tests {
     use super::{
-        create_quicklink, delete_quicklink_from_path, expand_url, load_quicklinks_from_path,
-        save_quicklinks_to_path, Quicklink,
+        create_quicklink, delete_quicklink_from_path, expand_url, has_query_placeholder,
+        load_quicklinks_from_path, save_quicklinks_to_path, update_quicklink_from_path, Quicklink,
     };
 
     #[test]
@@ -105,6 +124,16 @@
     }
 
     #[test]
+    fn test_has_query_placeholder_returns_true_when_template_contains_placeholder() {
+        assert!(has_query_placeholder("https://example.com?q={query}"));
+    }
+
+    #[test]
+    fn test_has_query_placeholder_returns_false_when_template_missing_placeholder() {
+        assert!(!has_query_placeholder("https://example.com"));
+    }
+
+    #[test]
     fn test_load_quicklinks_from_path_returns_empty_when_file_missing() {
         let dir = tempfile::tempdir().expect("create temp dir");
         let path = dir.path().join("quicklinks.json");
@@ -174,4 +203,49 @@
         assert_eq!(loaded.len(), 1);
         assert_eq!(loaded[0].id, "keep");
     }
+
+    #[test]
+    fn test_update_quicklink_from_path_updates_name_and_url_template() {
+        let dir = tempfile::tempdir().expect("create temp dir");
+        let path = dir.path().join("quicklinks.json");
+        let links = vec![Quicklink {
+            id: "target".to_string(),
+            name: "Old".to_string(),
+            url_template: "https://old.example.com".to_string(),
+            icon: None,
+        }];
+
+        save_quicklinks_to_path(&links, &path).expect("seed quicklinks");
+        let updated = update_quicklink_from_path(
+            "target",
+            " New Name ",
+            " https://new.example.com?q={query} ",
+            &path,
+        );
+
+        assert!(updated);
+        let loaded = load_quicklinks_from_path(&path);
+        assert_eq!(loaded.len(), 1);
+        assert_eq!(loaded[0].name, "New Name");
+        assert_eq!(loaded[0].url_template, "https://new.example.com?q={query}");
+    }
+
+    #[test]
+    fn test_update_quicklink_from_path_returns_false_when_id_not_found() {
+        let dir = tempfile::tempdir().expect("create temp dir");
+        let path = dir.path().join("quicklinks.json");
+        let links = vec![Quicklink {
+            id: "target".to_string(),
+            name: "Keep".to_string(),
+            url_template: "https://example.com".to_string(),
+            icon: None,
+        }];
+
+        save_quicklinks_to_path(&links, &path).expect("seed quicklinks");
+        let updated = update_quicklink_from_path("missing", "Name", "https://updated.example.com", &path);
+
+        assert!(!updated);
+        let loaded = load_quicklinks_from_path(&path);
+        assert_eq!(loaded, links);
+    }
 }


thinking
**Planning Quicklinks variant**
exec
/bin/zsh -lc "sed -n '1,160p' src/builtins/part_001_entries/entries_000.rs" in /Users/johnlindquist/dev/script-kit-gpui succeeded in 52ms:
{
    if config.clipboard_history {
        entries.push(BuiltInEntry::new_with_icon(
            "builtin-clipboard-history",
            "Clipboard History",
            "Open clipboard history to view, search, and reuse copied items",
            vec!["clipboard", "history", "paste", "copy"],
            BuiltInFeature::ClipboardHistory,
            "ðŸ“‹",
        ));
        debug!("Added Clipboard History built-in entry");
    }

    // Note: AppLauncher built-in removed - apps now appear directly in main search
    // The app_launcher config flag is kept for future use (e.g., to disable app search entirely)
    if config.app_launcher {
        debug!("app_launcher enabled - apps will appear in main search");
    }

    if config.window_switcher {
file update:
diff --git a/src/builtins/part_001_entries/entries_000.rs b/src/builtins/part_001_entries/entries_000.rs
index 926be9edb8db75488c1894f105dba265b103c614..1b3e861bd2e0390edbd6aafc031907ffa15a7cd5
--- a/src/builtins/part_001_entries/entries_000.rs
+++ b/src/builtins/part_001_entries/entries_000.rs
@@ -69,6 +69,24 @@
     ));
     debug!("Added Notes built-in entry");
 
+    entries.push(BuiltInEntry::new_with_icon(
+        "builtin-quicklinks",
+        "Quicklinks",
+        "Manage quick links and open URLs with optional {query} expansion",
+        vec![
+            "quicklinks",
+            "quicklink",
+            "link",
+            "url",
+            "bookmark",
+            "open",
+            "search",
+        ],
+        BuiltInFeature::Quicklinks,
+        "ðŸ”—",
+    ));
+    debug!("Added Quicklinks built-in entry");
+
     // Design Gallery is only available in debug builds (developer tool)
     #[cfg(debug_assertions)]
     {
diff --git a/src/quicklinks/mod.rs b/src/quicklinks/mod.rs
index 08aeea02e216c8026f59f0d8fe5627ededb1dec0..e9e055c95e2b0cd21fbc8b79971df226a788899c
--- a/src/quicklinks/mod.rs
+++ b/src/quicklinks/mod.rs
@@ -43,6 +43,14 @@
     url_template.replace(QUERY_PLACEHOLDER, query)
 }
 
+pub fn has_query_placeholder(url_template: &str) -> bool {
+    url_template.contains(QUERY_PLACEHOLDER)
+}
+
+pub fn update_quicklink(id: &str, name: &str, url_template: &str) -> bool {
+    update_quicklink_from_path(id, name, url_template, &quicklinks_path())
+}
+
 fn quicklinks_path() -> PathBuf {
     dirs::home_dir()
         .map(|home| home.join(".scriptkit").join(QUICKLINKS_FILE))
@@ -75,11 +83,22 @@
     let _ = save_quicklinks_to_path(&links, path);
 }
 
+fn update_quicklink_from_path(id: &str, name: &str, url_template: &str, path: &Path) -> bool {
+    let mut links = load_quicklinks_from_path(path);
+    if let Some(link) = links.iter_mut().find(|link| link.id == id) {
+        link.name = name.trim().to_string();
+        link.url_template = url_template.trim().to_string();
+        return save_quicklinks_to_path(&links, path).is_ok();
+    }
+
+    false
+}
+
 #[cfg(test)]
 mod tests {
     use super::{
-        create_quicklink, delete_quicklink_from_path, expand_url, load_quicklinks_from_path,
-        save_quicklinks_to_path, Quicklink,
+        create_quicklink, delete_quicklink_from_path, expand_url, has_query_placeholder,
+        load_quicklinks_from_path, save_quicklinks_to_path, update_quicklink_from_path, Quicklink,
     };
 
     #[test]
@@ -105,6 +124,16 @@
     }
 
     #[test]
+    fn test_has_query_placeholder_returns_true_when_template_contains_placeholder() {
+        assert!(has_query_placeholder("https://example.com?q={query}"));
+    }
+
+    #[test]
+    fn test_has_query_placeholder_returns_false_when_template_missing_placeholder() {
+        assert!(!has_query_placeholder("https://example.com"));
+    }
+
+    #[test]
     fn test_load_quicklinks_from_path_returns_empty_when_file_missing() {
         let dir = tempfile::tempdir().expect("create temp dir");
         let path = dir.path().join("quicklinks.json");
@@ -174,4 +203,49 @@
         assert_eq!(loaded.len(), 1);
         assert_eq!(loaded[0].id, "keep");
     }
+
+    #[test]
+    fn test_update_quicklink_from_path_updates_name_and_url_template() {
+        let dir = tempfile::tempdir().expect("create temp dir");
+        let path = dir.path().join("quicklinks.json");
+        let links = vec![Quicklink {
+            id: "target".to_string(),
+            name: "Old".to_string(),
+            url_template: "https://old.example.com".to_string(),
+            icon: None,
+        }];
+
+        save_quicklinks_to_path(&links, &path).expect("seed quicklinks");
+        let updated = update_quicklink_from_path(
+            "target",
+            " New Name ",
+            " https://new.example.com?q={query} ",
+            &path,
+        );
+
+        assert!(updated);
+        let loaded = load_quicklinks_from_path(&path);
+        assert_eq!(loaded.len(), 1);
+        assert_eq!(loaded[0].name, "New Name");
+        assert_eq!(loaded[0].url_template, "https://new.example.com?q={query}");
+    }
+
+    #[test]
+    fn test_update_quicklink_from_path_returns_false_when_id_not_found() {
+        let dir = tempfile::tempdir().expect("create temp dir");
+        let path = dir.path().join("quicklinks.json");
+        let links = vec![Quicklink {
+            id: "target".to_string(),
+            name: "Keep".to_string(),
+            url_template: "https://example.com".to_string(),
+            icon: None,
+        }];
+
+        save_quicklinks_to_path(&links, &path).expect("seed quicklinks");
+        let updated = update_quicklink_from_path("missing", "Name", "https://updated.example.com", &path);
+
+        assert!(!updated);
+        let loaded = load_quicklinks_from_path(&path);
+        assert_eq!(loaded, links);
+    }
 }


thinking
**Planning quicklinks integration approach**
exec
/bin/zsh -lc "sed -n '1,260p' src/main_sections/app_state.rs" in /Users/johnlindquist/dev/script-kit-gpui succeeded in 51ms:
struct ScriptListApp {
    /// H1 Optimization: Arc-wrapped scripts for cheap cloning during filter operations
    scripts: Vec<std::sync::Arc<scripts::Script>>,
    /// H1 Optimization: Arc-wrapped scriptlets for cheap cloning during filter operations
    scriptlets: Vec<std::sync::Arc<scripts::Scriptlet>>,
    builtin_entries: Vec<builtins::BuiltInEntry>,
    /// Cached list of installed applications for main search and AppLauncherView
    apps: Vec<app_launcher::AppInfo>,
    /// P0 FIX: Cached clipboard entries for ClipboardHistoryView (avoids cloning per frame)
    cached_clipboard_entries: Vec<clipboard_history::ClipboardEntryMeta>,
    /// Focused clipboard entry ID for action handling in ClipboardHistoryView
    #[allow(dead_code)]
    focused_clipboard_entry_id: Option<String>,
    /// P0 FIX: Cached windows for WindowSwitcherView (avoids cloning per frame)
    cached_windows: Vec<window_control::WindowInfo>,
    /// Cached file results for FileSearchView (avoids cloning per frame)
    cached_file_results: Vec<file_search::FileResult>,
    selected_index: usize,
    /// Main menu filter text (mirrors gpui-component input state)
    filter_text: String,
file update:
diff --git a/src/builtins/part_001_entries/entries_000.rs b/src/builtins/part_001_entries/entries_000.rs
index 926be9edb8db75488c1894f105dba265b103c614..1b3e861bd2e0390edbd6aafc031907ffa15a7cd5
--- a/src/builtins/part_001_entries/entries_000.rs
+++ b/src/builtins/part_001_entries/entries_000.rs
@@ -69,6 +69,24 @@
     ));
     debug!("Added Notes built-in entry");
 
+    entries.push(BuiltInEntry::new_with_icon(
+        "builtin-quicklinks",
+        "Quicklinks",
+        "Manage quick links and open URLs with optional {query} expansion",
+        vec![
+            "quicklinks",
+            "quicklink",
+            "link",
+            "url",
+            "bookmark",
+            "open",
+            "search",
+        ],
+        BuiltInFeature::Quicklinks,
+        "ðŸ”—",
+    ));
+    debug!("Added Quicklinks built-in entry");
+
     // Design Gallery is only available in debug builds (developer tool)
     #[cfg(debug_assertions)]
     {
diff --git a/src/quicklinks/mod.rs b/src/quicklinks/mod.rs
index 08aeea02e216c8026f59f0d8fe5627ededb1dec0..e9e055c95e2b0cd21fbc8b79971df226a788899c
--- a/src/quicklinks/mod.rs
+++ b/src/quicklinks/mod.rs
@@ -43,6 +43,14 @@
     url_template.replace(QUERY_PLACEHOLDER, query)
 }
 
+pub fn has_query_placeholder(url_template: &str) -> bool {
+    url_template.contains(QUERY_PLACEHOLDER)
+}
+
+pub fn update_quicklink(id: &str, name: &str, url_template: &str) -> bool {
+    update_quicklink_from_path(id, name, url_template, &quicklinks_path())
+}
+
 fn quicklinks_path() -> PathBuf {
     dirs::home_dir()
         .map(|home| home.join(".scriptkit").join(QUICKLINKS_FILE))
@@ -75,11 +83,22 @@
     let _ = save_quicklinks_to_path(&links, path);
 }
 
+fn update_quicklink_from_path(id: &str, name: &str, url_template: &str, path: &Path) -> bool {
+    let mut links = load_quicklinks_from_path(path);
+    if let Some(link) = links.iter_mut().find(|link| link.id == id) {
+        link.name = name.trim().to_string();
+        link.url_template = url_template.trim().to_string();
+        return save_quicklinks_to_path(&links, path).is_ok();
+    }
+
+    false
+}
+
 #[cfg(test)]
 mod tests {
     use super::{
-        create_quicklink, delete_quicklink_from_path, expand_url, load_quicklinks_from_path,
-        save_quicklinks_to_path, Quicklink,
+        create_quicklink, delete_quicklink_from_path, expand_url, has_query_placeholder,
+        load_quicklinks_from_path, save_quicklinks_to_path, update_quicklink_from_path, Quicklink,
     };
 
     #[test]
@@ -105,6 +124,16 @@
     }
 
     #[test]
+    fn test_has_query_placeholder_returns_true_when_template_contains_placeholder() {
+        assert!(has_query_placeholder("https://example.com?q={query}"));
+    }
+
+    #[test]
+    fn test_has_query_placeholder_returns_false_when_template_missing_placeholder() {
+        assert!(!has_query_placeholder("https://example.com"));
+    }
+
+    #[test]
     fn test_load_quicklinks_from_path_returns_empty_when_file_missing() {
         let dir = tempfile::tempdir().expect("create temp dir");
         let path = dir.path().join("quicklinks.json");
@@ -174,4 +203,49 @@
         assert_eq!(loaded.len(), 1);
         assert_eq!(loaded[0].id, "keep");
     }
+
+    #[test]
+    fn test_update_quicklink_from_path_updates_name_and_url_template() {
+        let dir = tempfile::tempdir().expect("create temp dir");
+        let path = dir.path().join("quicklinks.json");
+        let links = vec![Quicklink {
+            id: "target".to_string(),
+            name: "Old".to_string(),
+            url_template: "https://old.example.com".to_string(),
+            icon: None,
+        }];
+
+        save_quicklinks_to_path(&links, &path).expect("seed quicklinks");
+        let updated = update_quicklink_from_path(
+            "target",
+            " New Name ",
+            " https://new.example.com?q={query} ",
+            &path,
+        );
+
+        assert!(updated);
+        let loaded = load_quicklinks_from_path(&path);
+        assert_eq!(loaded.len(), 1);
+        assert_eq!(loaded[0].name, "New Name");
+        assert_eq!(loaded[0].url_template, "https://new.example.com?q={query}");
+    }
+
+    #[test]
+    fn test_update_quicklink_from_path_returns_false_when_id_not_found() {
+        let dir = tempfile::tempdir().expect("create temp dir");
+        let path = dir.path().join("quicklinks.json");
+        let links = vec![Quicklink {
+            id: "target".to_string(),
+            name: "Keep".to_string(),
+            url_template: "https://example.com".to_string(),
+            icon: None,
+        }];
+
+        save_quicklinks_to_path(&links, &path).expect("seed quicklinks");
+        let updated = update_quicklink_from_path("missing", "Name", "https://updated.example.com", &path);
+
+        assert!(!updated);
+        let loaded = load_quicklinks_from_path(&path);
+        assert_eq!(loaded, links);
+    }
 }


thinking
**Evaluating fallback mode for quicklinks**
exec
/bin/zsh -lc "sed -n '1,260p' src/fallbacks/builtins.rs" in /Users/johnlindquist/dev/script-kit-gpui succeeded in 51ms:
//! Built-in fallback command definitions
//!
//! This module defines the default fallback commands that appear when no scripts
//! match the user's input. Fallbacks are Raycast-style actions like "Search Google",
//! "Open URL", "Calculate", etc.
//!
//! NOTE: Some items are currently unused as this is a new module being integrated.
#![allow(dead_code)]

use crate::scripts::input_detection::{is_file_path, is_math_expression, is_url, InputType};

/// Simple percent-encoding for URL query strings
/// Encodes characters that are not unreserved per RFC 3986
fn percent_encode(input: &str) -> String {
    let mut encoded = String::with_capacity(input.len() * 3);
    for byte in input.bytes() {
        match byte {
            // Unreserved characters: A-Z a-z 0-9 - . _ ~
            b'A'..=b'Z' | b'a'..=b'z' | b'0'..=b'9' | b'-' | b'.' | b'_' | b'~' => {
                encoded.push(byte as char);
file update:
diff --git a/src/builtins/part_001_entries/entries_000.rs b/src/builtins/part_001_entries/entries_000.rs
index 926be9edb8db75488c1894f105dba265b103c614..1b3e861bd2e0390edbd6aafc031907ffa15a7cd5
--- a/src/builtins/part_001_entries/entries_000.rs
+++ b/src/builtins/part_001_entries/entries_000.rs
@@ -69,6 +69,24 @@
     ));
     debug!("Added Notes built-in entry");
 
+    entries.push(BuiltInEntry::new_with_icon(
+        "builtin-quicklinks",
+        "Quicklinks",
+        "Manage quick links and open URLs with optional {query} expansion",
+        vec![
+            "quicklinks",
+            "quicklink",
+            "link",
+            "url",
+            "bookmark",
+            "open",
+            "search",
+        ],
+        BuiltInFeature::Quicklinks,
+        "ðŸ”—",
+    ));
+    debug!("Added Quicklinks built-in entry");
+
     // Design Gallery is only available in debug builds (developer tool)
     #[cfg(debug_assertions)]
     {
diff --git a/src/quicklinks/mod.rs b/src/quicklinks/mod.rs
index 08aeea02e216c8026f59f0d8fe5627ededb1dec0..e9e055c95e2b0cd21fbc8b79971df226a788899c
--- a/src/quicklinks/mod.rs
+++ b/src/quicklinks/mod.rs
@@ -43,6 +43,14 @@
     url_template.replace(QUERY_PLACEHOLDER, query)
 }
 
+pub fn has_query_placeholder(url_template: &str) -> bool {
+    url_template.contains(QUERY_PLACEHOLDER)
+}
+
+pub fn update_quicklink(id: &str, name: &str, url_template: &str) -> bool {
+    update_quicklink_from_path(id, name, url_template, &quicklinks_path())
+}
+
 fn quicklinks_path() -> PathBuf {
     dirs::home_dir()
         .map(|home| home.join(".scriptkit").join(QUICKLINKS_FILE))
@@ -75,11 +83,22 @@
     let _ = save_quicklinks_to_path(&links, path);
 }
 
+fn update_quicklink_from_path(id: &str, name: &str, url_template: &str, path: &Path) -> bool {
+    let mut links = load_quicklinks_from_path(path);
+    if let Some(link) = links.iter_mut().find(|link| link.id == id) {
+        link.name = name.trim().to_string();
+        link.url_template = url_template.trim().to_string();
+        return save_quicklinks_to_path(&links, path).is_ok();
+    }
+
+    false
+}
+
 #[cfg(test)]
 mod tests {
     use super::{
-        create_quicklink, delete_quicklink_from_path, expand_url, load_quicklinks_from_path,
-        save_quicklinks_to_path, Quicklink,
+        create_quicklink, delete_quicklink_from_path, expand_url, has_query_placeholder,
+        load_quicklinks_from_path, save_quicklinks_to_path, update_quicklink_from_path, Quicklink,
     };
 
     #[test]
@@ -105,6 +124,16 @@
     }
 
     #[test]
+    fn test_has_query_placeholder_returns_true_when_template_contains_placeholder() {
+        assert!(has_query_placeholder("https://example.com?q={query}"));
+    }
+
+    #[test]
+    fn test_has_query_placeholder_returns_false_when_template_missing_placeholder() {
+        assert!(!has_query_placeholder("https://example.com"));
+    }
+
+    #[test]
     fn test_load_quicklinks_from_path_returns_empty_when_file_missing() {
         let dir = tempfile::tempdir().expect("create temp dir");
         let path = dir.path().join("quicklinks.json");
@@ -174,4 +203,49 @@
         assert_eq!(loaded.len(), 1);
         assert_eq!(loaded[0].id, "keep");
     }
+
+    #[test]
+    fn test_update_quicklink_from_path_updates_name_and_url_template() {
+        let dir = tempfile::tempdir().expect("create temp dir");
+        let path = dir.path().join("quicklinks.json");
+        let links = vec![Quicklink {
+            id: "target".to_string(),
+            name: "Old".to_string(),
+            url_template: "https://old.example.com".to_string(),
+            icon: None,
+        }];
+
+        save_quicklinks_to_path(&links, &path).expect("seed quicklinks");
+        let updated = update_quicklink_from_path(
+            "target",
+            " New Name ",
+            " https://new.example.com?q={query} ",
+            &path,
+        );
+
+        assert!(updated);
+        let loaded = load_quicklinks_from_path(&path);
+        assert_eq!(loaded.len(), 1);
+        assert_eq!(loaded[0].name, "New Name");
+        assert_eq!(loaded[0].url_template, "https://new.example.com?q={query}");
+    }
+
+    #[test]
+    fn test_update_quicklink_from_path_returns_false_when_id_not_found() {
+        let dir = tempfile::tempdir().expect("create temp dir");
+        let path = dir.path().join("quicklinks.json");
+        let links = vec![Quicklink {
+            id: "target".to_string(),
+            name: "Keep".to_string(),
+            url_template: "https://example.com".to_string(),
+            icon: None,
+        }];
+
+        save_quicklinks_to_path(&links, &path).expect("seed quicklinks");
+        let updated = update_quicklink_from_path("missing", "Name", "https://updated.example.com", &path);
+
+        assert!(!updated);
+        let loaded = load_quicklinks_from_path(&path);
+        assert_eq!(loaded, links);
+    }
 }


thinking
**Planning dynamic quicklinks injection**
exec
/bin/zsh -lc 'rg -n "builtin_entries" src/scripts src/app_impl src/main_sections | head -n 200' in /Users/johnlindquist/dev/script-kit-gpui succeeded in 52ms:
src/main_sections/app_state.rs:6:    builtin_entries: Vec<builtins::BuiltInEntry>,
src/app_impl/filtering_cache.rs:58:                    self.builtin_entries.len(),
src/app_impl/filtering_cache.rs:66:                &self.builtin_entries,
src/app_impl/filtering_cache.rs:152:            &self.builtin_entries,
src/app_impl/selection_fallback.rs:40:                if let Some(entry) = builtins::get_builtin_entries(&config)
src/app_impl/execution_scripts.rs:373:                    if let Some(entry) = builtins::get_builtin_entries(&config)
src/app_impl/startup.rs:72:        let builtin_entries = builtins::get_builtin_entries(&config.get_builtins());
src/app_impl/startup.rs:103:            &format!("Loaded {} built-in features", builtin_entries.len()),
src/app_impl/startup.rs:305:            builtin_entries,
src/app_impl/startup_new_prelude.rs:56:        let builtin_entries = builtins::get_builtin_entries(&config.get_builtins());
src/app_impl/startup_new_prelude.rs:87:            &format!("Loaded {} built-in features", builtin_entries.len()),
src/app_impl/startup_new_state.rs:19:            builtin_entries,
file update:
diff --git a/src/builtins/part_001_entries/entries_000.rs b/src/builtins/part_001_entries/entries_000.rs
index 926be9edb8db75488c1894f105dba265b103c614..1b3e861bd2e0390edbd6aafc031907ffa15a7cd5
--- a/src/builtins/part_001_entries/entries_000.rs
+++ b/src/builtins/part_001_entries/entries_000.rs
@@ -69,6 +69,24 @@
     ));
     debug!("Added Notes built-in entry");
 
+    entries.push(BuiltInEntry::new_with_icon(
+        "builtin-quicklinks",
+        "Quicklinks",
+        "Manage quick links and open URLs with optional {query} expansion",
+        vec![
+            "quicklinks",
+            "quicklink",
+            "link",
+            "url",
+            "bookmark",
+            "open",
+            "search",
+        ],
+        BuiltInFeature::Quicklinks,
+        "ðŸ”—",
+    ));
+    debug!("Added Quicklinks built-in entry");
+
     // Design Gallery is only available in debug builds (developer tool)
     #[cfg(debug_assertions)]
     {
diff --git a/src/quicklinks/mod.rs b/src/quicklinks/mod.rs
index 08aeea02e216c8026f59f0d8fe5627ededb1dec0..e9e055c95e2b0cd21fbc8b79971df226a788899c
--- a/src/quicklinks/mod.rs
+++ b/src/quicklinks/mod.rs
@@ -43,6 +43,14 @@
     url_template.replace(QUERY_PLACEHOLDER, query)
 }
 
+pub fn has_query_placeholder(url_template: &str) -> bool {
+    url_template.contains(QUERY_PLACEHOLDER)
+}
+
+pub fn update_quicklink(id: &str, name: &str, url_template: &str) -> bool {
+    update_quicklink_from_path(id, name, url_template, &quicklinks_path())
+}
+
 fn quicklinks_path() -> PathBuf {
     dirs::home_dir()
         .map(|home| home.join(".scriptkit").join(QUICKLINKS_FILE))
@@ -75,11 +83,22 @@
     let _ = save_quicklinks_to_path(&links, path);
 }
 
+fn update_quicklink_from_path(id: &str, name: &str, url_template: &str, path: &Path) -> bool {
+    let mut links = load_quicklinks_from_path(path);
+    if let Some(link) = links.iter_mut().find(|link| link.id == id) {
+        link.name = name.trim().to_string();
+        link.url_template = url_template.trim().to_string();
+        return save_quicklinks_to_path(&links, path).is_ok();
+    }
+
+    false
+}
+
 #[cfg(test)]
 mod tests {
     use super::{
-        create_quicklink, delete_quicklink_from_path, expand_url, load_quicklinks_from_path,
-        save_quicklinks_to_path, Quicklink,
+        create_quicklink, delete_quicklink_from_path, expand_url, has_query_placeholder,
+        load_quicklinks_from_path, save_quicklinks_to_path, update_quicklink_from_path, Quicklink,
     };
 
     #[test]
@@ -105,6 +124,16 @@
     }
 
     #[test]
+    fn test_has_query_placeholder_returns_true_when_template_contains_placeholder() {
+        assert!(has_query_placeholder("https://example.com?q={query}"));
+    }
+
+    #[test]
+    fn test_has_query_placeholder_returns_false_when_template_missing_placeholder() {
+        assert!(!has_query_placeholder("https://example.com"));
+    }
+
+    #[test]
     fn test_load_quicklinks_from_path_returns_empty_when_file_missing() {
         let dir = tempfile::tempdir().expect("create temp dir");
         let path = dir.path().join("quicklinks.json");
@@ -174,4 +203,49 @@
         assert_eq!(loaded.len(), 1);
         assert_eq!(loaded[0].id, "keep");
     }
+
+    #[test]
+    fn test_update_quicklink_from_path_updates_name_and_url_template() {
+        let dir = tempfile::tempdir().expect("create temp dir");
+        let path = dir.path().join("quicklinks.json");
+        let links = vec![Quicklink {
+            id: "target".to_string(),
+            name: "Old".to_string(),
+            url_template: "https://old.example.com".to_string(),
+            icon: None,
+        }];
+
+        save_quicklinks_to_path(&links, &path).expect("seed quicklinks");
+        let updated = update_quicklink_from_path(
+            "target",
+            " New Name ",
+            " https://new.example.com?q={query} ",
+            &path,
+        );
+
+        assert!(updated);
+        let loaded = load_quicklinks_from_path(&path);
+        assert_eq!(loaded.len(), 1);
+        assert_eq!(loaded[0].name, "New Name");
+        assert_eq!(loaded[0].url_template, "https://new.example.com?q={query}");
+    }
+
+    #[test]
+    fn test_update_quicklink_from_path_returns_false_when_id_not_found() {
+        let dir = tempfile::tempdir().expect("create temp dir");
+        let path = dir.path().join("quicklinks.json");
+        let links = vec![Quicklink {
+            id: "target".to_string(),
+            name: "Keep".to_string(),
+            url_template: "https://example.com".to_string(),
+            icon: None,
+        }];
+
+        save_quicklinks_to_path(&links, &path).expect("seed quicklinks");
+        let updated = update_quicklink_from_path("missing", "Name", "https://updated.example.com", &path);
+
+        assert!(!updated);
+        let loaded = load_quicklinks_from_path(&path);
+        assert_eq!(loaded, links);
+    }
 }


thinking
**Inspecting cache structure**
exec
/bin/zsh -lc "sed -n '1,260p' src/app_impl/filtering_cache.rs" in /Users/johnlindquist/dev/script-kit-gpui succeeded in 51ms:
use super::*;

impl ScriptListApp {
    pub(crate) fn filter_text(&self) -> &str {
        self.filter_text.as_str()
    }

    /// P1: Now uses caching - invalidates only when filter_text changes
    pub(crate) fn filtered_results(&self) -> Vec<scripts::SearchResult> {
        let filter_text = self.filter_text();
        // P1: Return cached results if filter hasn't changed
        if filter_text == self.filter_cache_key {
            logging::log_debug("CACHE", &format!("Filter cache HIT for '{}'", filter_text));
            return self.cached_filtered_results.clone();
        }

        // P1: Cache miss - need to recompute (will be done by get_filtered_results_mut)
        logging::log_debug(
            "CACHE",
            &format!(
file update:
diff --git a/src/builtins/part_001_entries/entries_000.rs b/src/builtins/part_001_entries/entries_000.rs
index 926be9edb8db75488c1894f105dba265b103c614..1b3e861bd2e0390edbd6aafc031907ffa15a7cd5
--- a/src/builtins/part_001_entries/entries_000.rs
+++ b/src/builtins/part_001_entries/entries_000.rs
@@ -69,6 +69,24 @@
     ));
     debug!("Added Notes built-in entry");
 
+    entries.push(BuiltInEntry::new_with_icon(
+        "builtin-quicklinks",
+        "Quicklinks",
+        "Manage quick links and open URLs with optional {query} expansion",
+        vec![
+            "quicklinks",
+            "quicklink",
+            "link",
+            "url",
+            "bookmark",
+            "open",
+            "search",
+        ],
+        BuiltInFeature::Quicklinks,
+        "ðŸ”—",
+    ));
+    debug!("Added Quicklinks built-in entry");
+
     // Design Gallery is only available in debug builds (developer tool)
     #[cfg(debug_assertions)]
     {
diff --git a/src/quicklinks/mod.rs b/src/quicklinks/mod.rs
index 08aeea02e216c8026f59f0d8fe5627ededb1dec0..e9e055c95e2b0cd21fbc8b79971df226a788899c
--- a/src/quicklinks/mod.rs
+++ b/src/quicklinks/mod.rs
@@ -43,6 +43,14 @@
     url_template.replace(QUERY_PLACEHOLDER, query)
 }
 
+pub fn has_query_placeholder(url_template: &str) -> bool {
+    url_template.contains(QUERY_PLACEHOLDER)
+}
+
+pub fn update_quicklink(id: &str, name: &str, url_template: &str) -> bool {
+    update_quicklink_from_path(id, name, url_template, &quicklinks_path())
+}
+
 fn quicklinks_path() -> PathBuf {
     dirs::home_dir()
         .map(|home| home.join(".scriptkit").join(QUICKLINKS_FILE))
@@ -75,11 +83,22 @@
     let _ = save_quicklinks_to_path(&links, path);
 }
 
+fn update_quicklink_from_path(id: &str, name: &str, url_template: &str, path: &Path) -> bool {
+    let mut links = load_quicklinks_from_path(path);
+    if let Some(link) = links.iter_mut().find(|link| link.id == id) {
+        link.name = name.trim().to_string();
+        link.url_template = url_template.trim().to_string();
+        return save_quicklinks_to_path(&links, path).is_ok();
+    }
+
+    false
+}
+
 #[cfg(test)]
 mod tests {
     use super::{
-        create_quicklink, delete_quicklink_from_path, expand_url, load_quicklinks_from_path,
-        save_quicklinks_to_path, Quicklink,
+        create_quicklink, delete_quicklink_from_path, expand_url, has_query_placeholder,
+        load_quicklinks_from_path, save_quicklinks_to_path, update_quicklink_from_path, Quicklink,
     };
 
     #[test]
@@ -105,6 +124,16 @@
     }
 
     #[test]
+    fn test_has_query_placeholder_returns_true_when_template_contains_placeholder() {
+        assert!(has_query_placeholder("https://example.com?q={query}"));
+    }
+
+    #[test]
+    fn test_has_query_placeholder_returns_false_when_template_missing_placeholder() {
+        assert!(!has_query_placeholder("https://example.com"));
+    }
+
+    #[test]
     fn test_load_quicklinks_from_path_returns_empty_when_file_missing() {
         let dir = tempfile::tempdir().expect("create temp dir");
         let path = dir.path().join("quicklinks.json");
@@ -174,4 +203,49 @@
         assert_eq!(loaded.len(), 1);
         assert_eq!(loaded[0].id, "keep");
     }
+
+    #[test]
+    fn test_update_quicklink_from_path_updates_name_and_url_template() {
+        let dir = tempfile::tempdir().expect("create temp dir");
+        let path = dir.path().join("quicklinks.json");
+        let links = vec![Quicklink {
+            id: "target".to_string(),
+            name: "Old".to_string(),
+            url_template: "https://old.example.com".to_string(),
+            icon: None,
+        }];
+
+        save_quicklinks_to_path(&links, &path).expect("seed quicklinks");
+        let updated = update_quicklink_from_path(
+            "target",
+            " New Name ",
+            " https://new.example.com?q={query} ",
+            &path,
+        );
+
+        assert!(updated);
+        let loaded = load_quicklinks_from_path(&path);
+        assert_eq!(loaded.len(), 1);
+        assert_eq!(loaded[0].name, "New Name");
+        assert_eq!(loaded[0].url_template, "https://new.example.com?q={query}");
+    }
+
+    #[test]
+    fn test_update_quicklink_from_path_returns_false_when_id_not_found() {
+        let dir = tempfile::tempdir().expect("create temp dir");
+        let path = dir.path().join("quicklinks.json");
+        let links = vec![Quicklink {
+            id: "target".to_string(),
+            name: "Keep".to_string(),
+            url_template: "https://example.com".to_string(),
+            icon: None,
+        }];
+
+        save_quicklinks_to_path(&links, &path).expect("seed quicklinks");
+        let updated = update_quicklink_from_path("missing", "Name", "https://updated.example.com", &path);
+
+        assert!(!updated);
+        let loaded = load_quicklinks_from_path(&path);
+        assert_eq!(loaded, links);
+    }
 }


thinking
**Planning quicklinks via app launcher**
exec
/bin/zsh -lc "sed -n '840,980p' src/app_impl/startup.rs" in /Users/johnlindquist/dev/script-kit-gpui succeeded in 51ms:
                                        );
                                        cx.notify();
                                    } else if (key == "down" || key == "arrowdown")
                                        && *selected_index + 1 < filtered_len
                                    {
                                        *selected_index += 1;
                                        this.file_search_scroll_handle.scroll_to_item(
                                            *selected_index,
                                            gpui::ScrollStrategy::Nearest,
                                        );
                                        cx.notify();
                                    }
                                    // Stop propagation so Input doesn't handle it
                                    cx.stop_propagation();
                                }
                                AppView::ClipboardHistoryView {
                                    selected_index,
                                    filter,
                                } => {
                                    // CRITICAL: If actions popup is open, route to actions dialog instead
file update:
diff --git a/src/builtins/part_001_entries/entries_000.rs b/src/builtins/part_001_entries/entries_000.rs
index 926be9edb8db75488c1894f105dba265b103c614..1b3e861bd2e0390edbd6aafc031907ffa15a7cd5
--- a/src/builtins/part_001_entries/entries_000.rs
+++ b/src/builtins/part_001_entries/entries_000.rs
@@ -69,6 +69,24 @@
     ));
     debug!("Added Notes built-in entry");
 
+    entries.push(BuiltInEntry::new_with_icon(
+        "builtin-quicklinks",
+        "Quicklinks",
+        "Manage quick links and open URLs with optional {query} expansion",
+        vec![
+            "quicklinks",
+            "quicklink",
+            "link",
+            "url",
+            "bookmark",
+            "open",
+            "search",
+        ],
+        BuiltInFeature::Quicklinks,
+        "ðŸ”—",
+    ));
+    debug!("Added Quicklinks built-in entry");
+
     // Design Gallery is only available in debug builds (developer tool)
     #[cfg(debug_assertions)]
     {
diff --git a/src/quicklinks/mod.rs b/src/quicklinks/mod.rs
index 08aeea02e216c8026f59f0d8fe5627ededb1dec0..e9e055c95e2b0cd21fbc8b79971df226a788899c
--- a/src/quicklinks/mod.rs
+++ b/src/quicklinks/mod.rs
@@ -43,6 +43,14 @@
     url_template.replace(QUERY_PLACEHOLDER, query)
 }
 
+pub fn has_query_placeholder(url_template: &str) -> bool {
+    url_template.contains(QUERY_PLACEHOLDER)
+}
+
+pub fn update_quicklink(id: &str, name: &str, url_template: &str) -> bool {
+    update_quicklink_from_path(id, name, url_template, &quicklinks_path())
+}
+
 fn quicklinks_path() -> PathBuf {
     dirs::home_dir()
         .map(|home| home.join(".scriptkit").join(QUICKLINKS_FILE))
@@ -75,11 +83,22 @@
     let _ = save_quicklinks_to_path(&links, path);
 }
 
+fn update_quicklink_from_path(id: &str, name: &str, url_template: &str, path: &Path) -> bool {
+    let mut links = load_quicklinks_from_path(path);
+    if let Some(link) = links.iter_mut().find(|link| link.id == id) {
+        link.name = name.trim().to_string();
+        link.url_template = url_template.trim().to_string();
+        return save_quicklinks_to_path(&links, path).is_ok();
+    }
+
+    false
+}
+
 #[cfg(test)]
 mod tests {
     use super::{
-        create_quicklink, delete_quicklink_from_path, expand_url, load_quicklinks_from_path,
-        save_quicklinks_to_path, Quicklink,
+        create_quicklink, delete_quicklink_from_path, expand_url, has_query_placeholder,
+        load_quicklinks_from_path, save_quicklinks_to_path, update_quicklink_from_path, Quicklink,
     };
 
     #[test]
@@ -105,6 +124,16 @@
     }
 
     #[test]
+    fn test_has_query_placeholder_returns_true_when_template_contains_placeholder() {
+        assert!(has_query_placeholder("https://example.com?q={query}"));
+    }
+
+    #[test]
+    fn test_has_query_placeholder_returns_false_when_template_missing_placeholder() {
+        assert!(!has_query_placeholder("https://example.com"));
+    }
+
+    #[test]
     fn test_load_quicklinks_from_path_returns_empty_when_file_missing() {
         let dir = tempfile::tempdir().expect("create temp dir");
         let path = dir.path().join("quicklinks.json");
@@ -174,4 +203,49 @@
         assert_eq!(loaded.len(), 1);
         assert_eq!(loaded[0].id, "keep");
     }
+
+    #[test]
+    fn test_update_quicklink_from_path_updates_name_and_url_template() {
+        let dir = tempfile::tempdir().expect("create temp dir");
+        let path = dir.path().join("quicklinks.json");
+        let links = vec![Quicklink {
+            id: "target".to_string(),
+            name: "Old".to_string(),
+            url_template: "https://old.example.com".to_string(),
+            icon: None,
+        }];
+
+        save_quicklinks_to_path(&links, &path).expect("seed quicklinks");
+        let updated = update_quicklink_from_path(
+            "target",
+            " New Name ",
+            " https://new.example.com?q={query} ",
+            &path,
+        );
+
+        assert!(updated);
+        let loaded = load_quicklinks_from_path(&path);
+        assert_eq!(loaded.len(), 1);
+        assert_eq!(loaded[0].name, "New Name");
+        assert_eq!(loaded[0].url_template, "https://new.example.com?q={query}");
+    }
+
+    #[test]
+    fn test_update_quicklink_from_path_returns_false_when_id_not_found() {
+        let dir = tempfile::tempdir().expect("create temp dir");
+        let path = dir.path().join("quicklinks.json");
+        let links = vec![Quicklink {
+            id: "target".to_string(),
+            name: "Keep".to_string(),
+            url_template: "https://example.com".to_string(),
+            icon: None,
+        }];
+
+        save_quicklinks_to_path(&links, &path).expect("seed quicklinks");
+        let updated = update_quicklink_from_path("missing", "Name", "https://updated.example.com", &path);
+
+        assert!(!updated);
+        let loaded = load_quicklinks_from_path(&path);
+        assert_eq!(loaded, links);
+    }
 }


thinking
**Noticing potential filter omission**
exec
/bin/zsh -lc 'rg -n "AppView::AppLauncherView|launch_application|AppLauncher" src/app_impl/startup.rs src/app_impl/startup_new_*.rs src/main_entry/app_run_setup.rs | head -n 200' in /Users/johnlindquist/dev/script-kit-gpui succeeded in 51ms:
src/app_impl/startup_new_arrow.rs:158:                                AppView::AppLauncherView {
src/app_impl/startup.rs:910:                                AppView::AppLauncherView {
src/main_entry/app_run_setup.rs:1467:                                        view.current_view = AppView::AppLauncherView {
file update:
diff --git a/src/builtins/part_001_entries/entries_000.rs b/src/builtins/part_001_entries/entries_000.rs
index 926be9edb8db75488c1894f105dba265b103c614..1b3e861bd2e0390edbd6aafc031907ffa15a7cd5
--- a/src/builtins/part_001_entries/entries_000.rs
+++ b/src/builtins/part_001_entries/entries_000.rs
@@ -69,6 +69,24 @@
     ));
     debug!("Added Notes built-in entry");
 
+    entries.push(BuiltInEntry::new_with_icon(
+        "builtin-quicklinks",
+        "Quicklinks",
+        "Manage quick links and open URLs with optional {query} expansion",
+        vec![
+            "quicklinks",
+            "quicklink",
+            "link",
+            "url",
+            "bookmark",
+            "open",
+            "search",
+        ],
+        BuiltInFeature::Quicklinks,
+        "ðŸ”—",
+    ));
+    debug!("Added Quicklinks built-in entry");
+
     // Design Gallery is only available in debug builds (developer tool)
     #[cfg(debug_assertions)]
     {
diff --git a/src/quicklinks/mod.rs b/src/quicklinks/mod.rs
index 08aeea02e216c8026f59f0d8fe5627ededb1dec0..e9e055c95e2b0cd21fbc8b79971df226a788899c
--- a/src/quicklinks/mod.rs
+++ b/src/quicklinks/mod.rs
@@ -43,6 +43,14 @@
     url_template.replace(QUERY_PLACEHOLDER, query)
 }
 
+pub fn has_query_placeholder(url_template: &str) -> bool {
+    url_template.contains(QUERY_PLACEHOLDER)
+}
+
+pub fn update_quicklink(id: &str, name: &str, url_template: &str) -> bool {
+    update_quicklink_from_path(id, name, url_template, &quicklinks_path())
+}
+
 fn quicklinks_path() -> PathBuf {
     dirs::home_dir()
         .map(|home| home.join(".scriptkit").join(QUICKLINKS_FILE))
@@ -75,11 +83,22 @@
     let _ = save_quicklinks_to_path(&links, path);
 }
 
+fn update_quicklink_from_path(id: &str, name: &str, url_template: &str, path: &Path) -> bool {
+    let mut links = load_quicklinks_from_path(path);
+    if let Some(link) = links.iter_mut().find(|link| link.id == id) {
+        link.name = name.trim().to_string();
+        link.url_template = url_template.trim().to_string();
+        return save_quicklinks_to_path(&links, path).is_ok();
+    }
+
+    false
+}
+
 #[cfg(test)]
 mod tests {
     use super::{
-        create_quicklink, delete_quicklink_from_path, expand_url, load_quicklinks_from_path,
-        save_quicklinks_to_path, Quicklink,
+        create_quicklink, delete_quicklink_from_path, expand_url, has_query_placeholder,
+        load_quicklinks_from_path, save_quicklinks_to_path, update_quicklink_from_path, Quicklink,
     };
 
     #[test]
@@ -105,6 +124,16 @@
     }
 
     #[test]
+    fn test_has_query_placeholder_returns_true_when_template_contains_placeholder() {
+        assert!(has_query_placeholder("https://example.com?q={query}"));
+    }
+
+    #[test]
+    fn test_has_query_placeholder_returns_false_when_template_missing_placeholder() {
+        assert!(!has_query_placeholder("https://example.com"));
+    }
+
+    #[test]
     fn test_load_quicklinks_from_path_returns_empty_when_file_missing() {
         let dir = tempfile::tempdir().expect("create temp dir");
         let path = dir.path().join("quicklinks.json");
@@ -174,4 +203,49 @@
         assert_eq!(loaded.len(), 1);
         assert_eq!(loaded[0].id, "keep");
     }
+
+    #[test]
+    fn test_update_quicklink_from_path_updates_name_and_url_template() {
+        let dir = tempfile::tempdir().expect("create temp dir");
+        let path = dir.path().join("quicklinks.json");
+        let links = vec![Quicklink {
+            id: "target".to_string(),
+            name: "Old".to_string(),
+            url_template: "https://old.example.com".to_string(),
+            icon: None,
+        }];
+
+        save_quicklinks_to_path(&links, &path).expect("seed quicklinks");
+        let updated = update_quicklink_from_path(
+            "target",
+            " New Name ",
+            " https://new.example.com?q={query} ",
+            &path,
+        );
+
+        assert!(updated);
+        let loaded = load_quicklinks_from_path(&path);
+        assert_eq!(loaded.len(), 1);
+        assert_eq!(loaded[0].name, "New Name");
+        assert_eq!(loaded[0].url_template, "https://new.example.com?q={query}");
+    }
+
+    #[test]
+    fn test_update_quicklink_from_path_returns_false_when_id_not_found() {
+        let dir = tempfile::tempdir().expect("create temp dir");
+        let path = dir.path().join("quicklinks.json");
+        let links = vec![Quicklink {
+            id: "target".to_string(),
+            name: "Keep".to_string(),
+            url_template: "https://example.com".to_string(),
+            icon: None,
+        }];
+
+        save_quicklinks_to_path(&links, &path).expect("seed quicklinks");
+        let updated = update_quicklink_from_path("missing", "Name", "https://updated.example.com", &path);
+
+        assert!(!updated);
+        let loaded = load_quicklinks_from_path(&path);
+        assert_eq!(loaded, links);
+    }
 }


thinking
**Inspecting key handling in startup**
exec
/bin/zsh -lc "sed -n '1360,1540p' src/main_entry/app_run_setup.rs" in /Users/johnlindquist/dev/script-kit-gpui succeeded in 50ms:
                                            }
                                        } else {
                                            logging::log("STDIN", "Saved position no longer visible, using eye-line");
                                            platform::calculate_eye_line_bounds_on_mouse_display(window_size)
                                        }
                                    } else {
                                        logging::log("STDIN", "No saved position for this display, using eye-line");
                                        platform::calculate_eye_line_bounds_on_mouse_display(window_size)
                                    }
                                } else {
                                    logging::log("STDIN", "Could not get mouse position, using eye-line");
                                    platform::calculate_eye_line_bounds_on_mouse_display(window_size)
                                };
                                window_ops::queue_move(bounds, window, ctx);

                                if !PANEL_CONFIGURED.load(std::sync::atomic::Ordering::SeqCst) {
                                    platform::configure_as_floating_panel();
                                    platform::swizzle_gpui_blurred_view();
                                    // Configure vibrancy based on actual theme colors
                                    let theme = theme::load_theme();
file update:
diff --git a/src/builtins/part_001_entries/entries_000.rs b/src/builtins/part_001_entries/entries_000.rs
index 926be9edb8db75488c1894f105dba265b103c614..1b3e861bd2e0390edbd6aafc031907ffa15a7cd5
--- a/src/builtins/part_001_entries/entries_000.rs
+++ b/src/builtins/part_001_entries/entries_000.rs
@@ -69,6 +69,24 @@
     ));
     debug!("Added Notes built-in entry");
 
+    entries.push(BuiltInEntry::new_with_icon(
+        "builtin-quicklinks",
+        "Quicklinks",
+        "Manage quick links and open URLs with optional {query} expansion",
+        vec![
+            "quicklinks",
+            "quicklink",
+            "link",
+            "url",
+            "bookmark",
+            "open",
+            "search",
+        ],
+        BuiltInFeature::Quicklinks,
+        "ðŸ”—",
+    ));
+    debug!("Added Quicklinks built-in entry");
+
     // Design Gallery is only available in debug builds (developer tool)
     #[cfg(debug_assertions)]
     {
diff --git a/src/quicklinks/mod.rs b/src/quicklinks/mod.rs
index 08aeea02e216c8026f59f0d8fe5627ededb1dec0..e9e055c95e2b0cd21fbc8b79971df226a788899c
--- a/src/quicklinks/mod.rs
+++ b/src/quicklinks/mod.rs
@@ -43,6 +43,14 @@
     url_template.replace(QUERY_PLACEHOLDER, query)
 }
 
+pub fn has_query_placeholder(url_template: &str) -> bool {
+    url_template.contains(QUERY_PLACEHOLDER)
+}
+
+pub fn update_quicklink(id: &str, name: &str, url_template: &str) -> bool {
+    update_quicklink_from_path(id, name, url_template, &quicklinks_path())
+}
+
 fn quicklinks_path() -> PathBuf {
     dirs::home_dir()
         .map(|home| home.join(".scriptkit").join(QUICKLINKS_FILE))
@@ -75,11 +83,22 @@
     let _ = save_quicklinks_to_path(&links, path);
 }
 
+fn update_quicklink_from_path(id: &str, name: &str, url_template: &str, path: &Path) -> bool {
+    let mut links = load_quicklinks_from_path(path);
+    if let Some(link) = links.iter_mut().find(|link| link.id == id) {
+        link.name = name.trim().to_string();
+        link.url_template = url_template.trim().to_string();
+        return save_quicklinks_to_path(&links, path).is_ok();
+    }
+
+    false
+}
+
 #[cfg(test)]
 mod tests {
     use super::{
-        create_quicklink, delete_quicklink_from_path, expand_url, load_quicklinks_from_path,
-        save_quicklinks_to_path, Quicklink,
+        create_quicklink, delete_quicklink_from_path, expand_url, has_query_placeholder,
+        load_quicklinks_from_path, save_quicklinks_to_path, update_quicklink_from_path, Quicklink,
     };
 
     #[test]
@@ -105,6 +124,16 @@
     }
 
     #[test]
+    fn test_has_query_placeholder_returns_true_when_template_contains_placeholder() {
+        assert!(has_query_placeholder("https://example.com?q={query}"));
+    }
+
+    #[test]
+    fn test_has_query_placeholder_returns_false_when_template_missing_placeholder() {
+        assert!(!has_query_placeholder("https://example.com"));
+    }
+
+    #[test]
     fn test_load_quicklinks_from_path_returns_empty_when_file_missing() {
         let dir = tempfile::tempdir().expect("create temp dir");
         let path = dir.path().join("quicklinks.json");
@@ -174,4 +203,49 @@
         assert_eq!(loaded.len(), 1);
         assert_eq!(loaded[0].id, "keep");
     }
+
+    #[test]
+    fn test_update_quicklink_from_path_updates_name_and_url_template() {
+        let dir = tempfile::tempdir().expect("create temp dir");
+        let path = dir.path().join("quicklinks.json");
+        let links = vec![Quicklink {
+            id: "target".to_string(),
+            name: "Old".to_string(),
+            url_template: "https://old.example.com".to_string(),
+            icon: None,
+        }];
+
+        save_quicklinks_to_path(&links, &path).expect("seed quicklinks");
+        let updated = update_quicklink_from_path(
+            "target",
+            " New Name ",
+            " https://new.example.com?q={query} ",
+            &path,
+        );
+
+        assert!(updated);
+        let loaded = load_quicklinks_from_path(&path);
+        assert_eq!(loaded.len(), 1);
+        assert_eq!(loaded[0].name, "New Name");
+        assert_eq!(loaded[0].url_template, "https://new.example.com?q={query}");
+    }
+
+    #[test]
+    fn test_update_quicklink_from_path_returns_false_when_id_not_found() {
+        let dir = tempfile::tempdir().expect("create temp dir");
+        let path = dir.path().join("quicklinks.json");
+        let links = vec![Quicklink {
+            id: "target".to_string(),
+            name: "Keep".to_string(),
+            url_template: "https://example.com".to_string(),
+            icon: None,
+        }];
+
+        save_quicklinks_to_path(&links, &path).expect("seed quicklinks");
+        let updated = update_quicklink_from_path("missing", "Name", "https://updated.example.com", &path);
+
+        assert!(!updated);
+        let loaded = load_quicklinks_from_path(&path);
+        assert_eq!(loaded, links);
+    }
 }


thinking
**Inspecting global Enter handling**
exec
/bin/zsh -lc 'rg -n "enter|Enter|submit|execute_selected|execute_builtin|AppView::AppLauncherView|open_application|launch" src/app_impl/startup.rs | head -n 200' in /Users/johnlindquist/dev/script-kit-gpui succeeded in 51ms:
116:        let app_launcher_enabled = config.get_builtins().app_launcher;
117:        if app_launcher_enabled {
120:                async_channel::bounded::<(Vec<app_launcher::AppInfo>, std::time::Duration)>(1);
125:                let apps = app_launcher::scan_applications().clone();
273:                InputEvent::PressEnter { .. } => {
278:                            this.execute_selected_fallback(cx);
280:                            this.execute_selected(cx);
631:                                    // Tab: Enter directory OR autocomplete file name
662:                                            // Directory: Enter it (append /)
668:                                                &format!("Tab: Entering directory: {}", new_path),
910:                                AppView::AppLauncherView {
1121:        // This handles Cmd+K (toggle), Escape (close), Enter (submit), and typing
1140:                        // FIRST: If confirm dialog is open, route Enter/Escape to it
1316:                            // This ensures enter, escape, backspace, and character keys are
1380:                        // Handle Enter to submit selected action
1381:                        if key == "enter" {
file update:
diff --git a/src/builtins/part_001_entries/entries_000.rs b/src/builtins/part_001_entries/entries_000.rs
index 926be9edb8db75488c1894f105dba265b103c614..1b3e861bd2e0390edbd6aafc031907ffa15a7cd5
--- a/src/builtins/part_001_entries/entries_000.rs
+++ b/src/builtins/part_001_entries/entries_000.rs
@@ -69,6 +69,24 @@
     ));
     debug!("Added Notes built-in entry");
 
+    entries.push(BuiltInEntry::new_with_icon(
+        "builtin-quicklinks",
+        "Quicklinks",
+        "Manage quick links and open URLs with optional {query} expansion",
+        vec![
+            "quicklinks",
+            "quicklink",
+            "link",
+            "url",
+            "bookmark",
+            "open",
+            "search",
+        ],
+        BuiltInFeature::Quicklinks,
+        "ðŸ”—",
+    ));
+    debug!("Added Quicklinks built-in entry");
+
     // Design Gallery is only available in debug builds (developer tool)
     #[cfg(debug_assertions)]
     {
diff --git a/src/quicklinks/mod.rs b/src/quicklinks/mod.rs
index 08aeea02e216c8026f59f0d8fe5627ededb1dec0..e9e055c95e2b0cd21fbc8b79971df226a788899c
--- a/src/quicklinks/mod.rs
+++ b/src/quicklinks/mod.rs
@@ -43,6 +43,14 @@
     url_template.replace(QUERY_PLACEHOLDER, query)
 }
 
+pub fn has_query_placeholder(url_template: &str) -> bool {
+    url_template.contains(QUERY_PLACEHOLDER)
+}
+
+pub fn update_quicklink(id: &str, name: &str, url_template: &str) -> bool {
+    update_quicklink_from_path(id, name, url_template, &quicklinks_path())
+}
+
 fn quicklinks_path() -> PathBuf {
     dirs::home_dir()
         .map(|home| home.join(".scriptkit").join(QUICKLINKS_FILE))
@@ -75,11 +83,22 @@
     let _ = save_quicklinks_to_path(&links, path);
 }
 
+fn update_quicklink_from_path(id: &str, name: &str, url_template: &str, path: &Path) -> bool {
+    let mut links = load_quicklinks_from_path(path);
+    if let Some(link) = links.iter_mut().find(|link| link.id == id) {
+        link.name = name.trim().to_string();
+        link.url_template = url_template.trim().to_string();
+        return save_quicklinks_to_path(&links, path).is_ok();
+    }
+
+    false
+}
+
 #[cfg(test)]
 mod tests {
     use super::{
-        create_quicklink, delete_quicklink_from_path, expand_url, load_quicklinks_from_path,
-        save_quicklinks_to_path, Quicklink,
+        create_quicklink, delete_quicklink_from_path, expand_url, has_query_placeholder,
+        load_quicklinks_from_path, save_quicklinks_to_path, update_quicklink_from_path, Quicklink,
     };
 
     #[test]
@@ -105,6 +124,16 @@
     }
 
     #[test]
+    fn test_has_query_placeholder_returns_true_when_template_contains_placeholder() {
+        assert!(has_query_placeholder("https://example.com?q={query}"));
+    }
+
+    #[test]
+    fn test_has_query_placeholder_returns_false_when_template_missing_placeholder() {
+        assert!(!has_query_placeholder("https://example.com"));
+    }
+
+    #[test]
     fn test_load_quicklinks_from_path_returns_empty_when_file_missing() {
         let dir = tempfile::tempdir().expect("create temp dir");
         let path = dir.path().join("quicklinks.json");
@@ -174,4 +203,49 @@
         assert_eq!(loaded.len(), 1);
         assert_eq!(loaded[0].id, "keep");
     }
+
+    #[test]
+    fn test_update_quicklink_from_path_updates_name_and_url_template() {
+        let dir = tempfile::tempdir().expect("create temp dir");
+        let path = dir.path().join("quicklinks.json");
+        let links = vec![Quicklink {
+            id: "target".to_string(),
+            name: "Old".to_string(),
+            url_template: "https://old.example.com".to_string(),
+            icon: None,
+        }];
+
+        save_quicklinks_to_path(&links, &path).expect("seed quicklinks");
+        let updated = update_quicklink_from_path(
+            "target",
+            " New Name ",
+            " https://new.example.com?q={query} ",
+            &path,
+        );
+
+        assert!(updated);
+        let loaded = load_quicklinks_from_path(&path);
+        assert_eq!(loaded.len(), 1);
+        assert_eq!(loaded[0].name, "New Name");
+        assert_eq!(loaded[0].url_template, "https://new.example.com?q={query}");
+    }
+
+    #[test]
+    fn test_update_quicklink_from_path_returns_false_when_id_not_found() {
+        let dir = tempfile::tempdir().expect("create temp dir");
+        let path = dir.path().join("quicklinks.json");
+        let links = vec![Quicklink {
+            id: "target".to_string(),
+            name: "Keep".to_string(),
+            url_template: "https://example.com".to_string(),
+            icon: None,
+        }];
+
+        save_quicklinks_to_path(&links, &path).expect("seed quicklinks");
+        let updated = update_quicklink_from_path("missing", "Name", "https://updated.example.com", &path);
+
+        assert!(!updated);
+        let loaded = load_quicklinks_from_path(&path);
+        assert_eq!(loaded, links);
+    }
 }


thinking
**Inspecting key input handling**
exec
/bin/zsh -lc "sed -n '240,340p' src/app_impl/startup.rs" in /Users/johnlindquist/dev/script-kit-gpui succeeded in 50ms:
                    if this.show_actions_popup || is_actions_window_open() {
                        logging::log(
                            "FOCUS",
                            "Main input focused while actions open - closing actions via shared close path",
                        );
                        this.close_actions_popup(ActionsDialogHost::MainList, window, cx);
                    }

                    cx.notify();
                }
                InputEvent::Blur => {
                    this.gpui_input_focused = false;
                    if this.focused_input == FocusedInput::MainFilter {
                        this.focused_input = FocusedInput::None;
                    }
                    cx.notify();
                }
                InputEvent::Change => {
                    let input_received_at = std::time::Instant::now();
                    // Read the current input value to see what we're processing
file update:
diff --git a/src/builtins/part_001_entries/entries_000.rs b/src/builtins/part_001_entries/entries_000.rs
index 926be9edb8db75488c1894f105dba265b103c614..1b3e861bd2e0390edbd6aafc031907ffa15a7cd5
--- a/src/builtins/part_001_entries/entries_000.rs
+++ b/src/builtins/part_001_entries/entries_000.rs
@@ -69,6 +69,24 @@
     ));
     debug!("Added Notes built-in entry");
 
+    entries.push(BuiltInEntry::new_with_icon(
+        "builtin-quicklinks",
+        "Quicklinks",
+        "Manage quick links and open URLs with optional {query} expansion",
+        vec![
+            "quicklinks",
+            "quicklink",
+            "link",
+            "url",
+            "bookmark",
+            "open",
+            "search",
+        ],
+        BuiltInFeature::Quicklinks,
+        "ðŸ”—",
+    ));
+    debug!("Added Quicklinks built-in entry");
+
     // Design Gallery is only available in debug builds (developer tool)
     #[cfg(debug_assertions)]
     {
diff --git a/src/quicklinks/mod.rs b/src/quicklinks/mod.rs
index 08aeea02e216c8026f59f0d8fe5627ededb1dec0..e9e055c95e2b0cd21fbc8b79971df226a788899c
--- a/src/quicklinks/mod.rs
+++ b/src/quicklinks/mod.rs
@@ -43,6 +43,14 @@
     url_template.replace(QUERY_PLACEHOLDER, query)
 }
 
+pub fn has_query_placeholder(url_template: &str) -> bool {
+    url_template.contains(QUERY_PLACEHOLDER)
+}
+
+pub fn update_quicklink(id: &str, name: &str, url_template: &str) -> bool {
+    update_quicklink_from_path(id, name, url_template, &quicklinks_path())
+}
+
 fn quicklinks_path() -> PathBuf {
     dirs::home_dir()
         .map(|home| home.join(".scriptkit").join(QUICKLINKS_FILE))
@@ -75,11 +83,22 @@
     let _ = save_quicklinks_to_path(&links, path);
 }
 
+fn update_quicklink_from_path(id: &str, name: &str, url_template: &str, path: &Path) -> bool {
+    let mut links = load_quicklinks_from_path(path);
+    if let Some(link) = links.iter_mut().find(|link| link.id == id) {
+        link.name = name.trim().to_string();
+        link.url_template = url_template.trim().to_string();
+        return save_quicklinks_to_path(&links, path).is_ok();
+    }
+
+    false
+}
+
 #[cfg(test)]
 mod tests {
     use super::{
-        create_quicklink, delete_quicklink_from_path, expand_url, load_quicklinks_from_path,
-        save_quicklinks_to_path, Quicklink,
+        create_quicklink, delete_quicklink_from_path, expand_url, has_query_placeholder,
+        load_quicklinks_from_path, save_quicklinks_to_path, update_quicklink_from_path, Quicklink,
     };
 
     #[test]
@@ -105,6 +124,16 @@
     }
 
     #[test]
+    fn test_has_query_placeholder_returns_true_when_template_contains_placeholder() {
+        assert!(has_query_placeholder("https://example.com?q={query}"));
+    }
+
+    #[test]
+    fn test_has_query_placeholder_returns_false_when_template_missing_placeholder() {
+        assert!(!has_query_placeholder("https://example.com"));
+    }
+
+    #[test]
     fn test_load_quicklinks_from_path_returns_empty_when_file_missing() {
         let dir = tempfile::tempdir().expect("create temp dir");
         let path = dir.path().join("quicklinks.json");
@@ -174,4 +203,49 @@
         assert_eq!(loaded.len(), 1);
         assert_eq!(loaded[0].id, "keep");
     }
+
+    #[test]
+    fn test_update_quicklink_from_path_updates_name_and_url_template() {
+        let dir = tempfile::tempdir().expect("create temp dir");
+        let path = dir.path().join("quicklinks.json");
+        let links = vec![Quicklink {
+            id: "target".to_string(),
+            name: "Old".to_string(),
+            url_template: "https://old.example.com".to_string(),
+            icon: None,
+        }];
+
+        save_quicklinks_to_path(&links, &path).expect("seed quicklinks");
+        let updated = update_quicklink_from_path(
+            "target",
+            " New Name ",
+            " https://new.example.com?q={query} ",
+            &path,
+        );
+
+        assert!(updated);
+        let loaded = load_quicklinks_from_path(&path);
+        assert_eq!(loaded.len(), 1);
+        assert_eq!(loaded[0].name, "New Name");
+        assert_eq!(loaded[0].url_template, "https://new.example.com?q={query}");
+    }
+
+    #[test]
+    fn test_update_quicklink_from_path_returns_false_when_id_not_found() {
+        let dir = tempfile::tempdir().expect("create temp dir");
+        let path = dir.path().join("quicklinks.json");
+        let links = vec![Quicklink {
+            id: "target".to_string(),
+            name: "Keep".to_string(),
+            url_template: "https://example.com".to_string(),
+            icon: None,
+        }];
+
+        save_quicklinks_to_path(&links, &path).expect("seed quicklinks");
+        let updated = update_quicklink_from_path("missing", "Name", "https://updated.example.com", &path);
+
+        assert!(!updated);
+        let loaded = load_quicklinks_from_path(&path);
+        assert_eq!(loaded, links);
+    }
 }


thinking
**Inspecting execution script function**
exec
/bin/zsh -lc "sed -n '1,260p' src/app_impl/execution_scripts.rs" in /Users/johnlindquist/dev/script-kit-gpui succeeded in 51ms:
use super::*;

const NO_MAIN_WINDOW_BUILTINS: &[&str] = &[
    "builtin-ai-chat",
    "builtin-open-ai",
    "builtin-notes",
    "builtin-open-notes",
    "builtin-new-note",
    "builtin-search-notes",
    "builtin-quick-capture",
    "builtin-new-conversation",
];

fn builtin_needs_main_window_for_command_id(identifier: &str) -> bool {
    !NO_MAIN_WINDOW_BUILTINS.contains(&identifier)
}

#[cfg(test)]
mod builtin_command_window_visibility_tests {
    use super::builtin_needs_main_window_for_command_id;
file update:
diff --git a/src/builtins/part_001_entries/entries_000.rs b/src/builtins/part_001_entries/entries_000.rs
index 926be9edb8db75488c1894f105dba265b103c614..1b3e861bd2e0390edbd6aafc031907ffa15a7cd5
--- a/src/builtins/part_001_entries/entries_000.rs
+++ b/src/builtins/part_001_entries/entries_000.rs
@@ -69,6 +69,24 @@
     ));
     debug!("Added Notes built-in entry");
 
+    entries.push(BuiltInEntry::new_with_icon(
+        "builtin-quicklinks",
+        "Quicklinks",
+        "Manage quick links and open URLs with optional {query} expansion",
+        vec![
+            "quicklinks",
+            "quicklink",
+            "link",
+            "url",
+            "bookmark",
+            "open",
+            "search",
+        ],
+        BuiltInFeature::Quicklinks,
+        "ðŸ”—",
+    ));
+    debug!("Added Quicklinks built-in entry");
+
     // Design Gallery is only available in debug builds (developer tool)
     #[cfg(debug_assertions)]
     {
diff --git a/src/quicklinks/mod.rs b/src/quicklinks/mod.rs
index 08aeea02e216c8026f59f0d8fe5627ededb1dec0..e9e055c95e2b0cd21fbc8b79971df226a788899c
--- a/src/quicklinks/mod.rs
+++ b/src/quicklinks/mod.rs
@@ -43,6 +43,14 @@
     url_template.replace(QUERY_PLACEHOLDER, query)
 }
 
+pub fn has_query_placeholder(url_template: &str) -> bool {
+    url_template.contains(QUERY_PLACEHOLDER)
+}
+
+pub fn update_quicklink(id: &str, name: &str, url_template: &str) -> bool {
+    update_quicklink_from_path(id, name, url_template, &quicklinks_path())
+}
+
 fn quicklinks_path() -> PathBuf {
     dirs::home_dir()
         .map(|home| home.join(".scriptkit").join(QUICKLINKS_FILE))
@@ -75,11 +83,22 @@
     let _ = save_quicklinks_to_path(&links, path);
 }
 
+fn update_quicklink_from_path(id: &str, name: &str, url_template: &str, path: &Path) -> bool {
+    let mut links = load_quicklinks_from_path(path);
+    if let Some(link) = links.iter_mut().find(|link| link.id == id) {
+        link.name = name.trim().to_string();
+        link.url_template = url_template.trim().to_string();
+        return save_quicklinks_to_path(&links, path).is_ok();
+    }
+
+    false
+}
+
 #[cfg(test)]
 mod tests {
     use super::{
-        create_quicklink, delete_quicklink_from_path, expand_url, load_quicklinks_from_path,
-        save_quicklinks_to_path, Quicklink,
+        create_quicklink, delete_quicklink_from_path, expand_url, has_query_placeholder,
+        load_quicklinks_from_path, save_quicklinks_to_path, update_quicklink_from_path, Quicklink,
     };
 
     #[test]
@@ -105,6 +124,16 @@
     }
 
     #[test]
+    fn test_has_query_placeholder_returns_true_when_template_contains_placeholder() {
+        assert!(has_query_placeholder("https://example.com?q={query}"));
+    }
+
+    #[test]
+    fn test_has_query_placeholder_returns_false_when_template_missing_placeholder() {
+        assert!(!has_query_placeholder("https://example.com"));
+    }
+
+    #[test]
     fn test_load_quicklinks_from_path_returns_empty_when_file_missing() {
         let dir = tempfile::tempdir().expect("create temp dir");
         let path = dir.path().join("quicklinks.json");
@@ -174,4 +203,49 @@
         assert_eq!(loaded.len(), 1);
         assert_eq!(loaded[0].id, "keep");
     }
+
+    #[test]
+    fn test_update_quicklink_from_path_updates_name_and_url_template() {
+        let dir = tempfile::tempdir().expect("create temp dir");
+        let path = dir.path().join("quicklinks.json");
+        let links = vec![Quicklink {
+            id: "target".to_string(),
+            name: "Old".to_string(),
+            url_template: "https://old.example.com".to_string(),
+            icon: None,
+        }];
+
+        save_quicklinks_to_path(&links, &path).expect("seed quicklinks");
+        let updated = update_quicklink_from_path(
+            "target",
+            " New Name ",
+            " https://new.example.com?q={query} ",
+            &path,
+        );
+
+        assert!(updated);
+        let loaded = load_quicklinks_from_path(&path);
+        assert_eq!(loaded.len(), 1);
+        assert_eq!(loaded[0].name, "New Name");
+        assert_eq!(loaded[0].url_template, "https://new.example.com?q={query}");
+    }
+
+    #[test]
+    fn test_update_quicklink_from_path_returns_false_when_id_not_found() {
+        let dir = tempfile::tempdir().expect("create temp dir");
+        let path = dir.path().join("quicklinks.json");
+        let links = vec![Quicklink {
+            id: "target".to_string(),
+            name: "Keep".to_string(),
+            url_template: "https://example.com".to_string(),
+            icon: None,
+        }];
+
+        save_quicklinks_to_path(&links, &path).expect("seed quicklinks");
+        let updated = update_quicklink_from_path("missing", "Name", "https://updated.example.com", &path);
+
+        assert!(!updated);
+        let loaded = load_quicklinks_from_path(&path);
+        assert_eq!(loaded, links);
+    }
 }

exec
/bin/zsh -lc "sed -n '260,520p' src/app_impl/execution_scripts.rs" in /Users/johnlindquist/dev/script-kit-gpui succeeded in 51ms:
                cx.notify();
            }
        }
    }

    /// Execute a script or scriptlet by its file path
    /// Used by global shortcuts to directly invoke scripts
    #[allow(dead_code)]
    pub(crate) fn execute_script_by_path(&mut self, path: &str, cx: &mut Context<Self>) {
        logging::log("EXEC", &format!("Executing script by path: {}", path));

        // Check if it's a scriptlet (contains #)
        if path.contains('#') {
            // It's a scriptlet path like "/path/to/file.md#command"
            if let Some(scriptlet) = self
                .scriptlets
                .iter()
                .find(|s| s.file_path.as_ref().map(|p| p == path).unwrap_or(false))
            {
                let scriptlet_clone = scriptlet.clone();
file update:
diff --git a/src/builtins/part_001_entries/entries_000.rs b/src/builtins/part_001_entries/entries_000.rs
index 926be9edb8db75488c1894f105dba265b103c614..1b3e861bd2e0390edbd6aafc031907ffa15a7cd5
--- a/src/builtins/part_001_entries/entries_000.rs
+++ b/src/builtins/part_001_entries/entries_000.rs
@@ -69,6 +69,24 @@
     ));
     debug!("Added Notes built-in entry");
 
+    entries.push(BuiltInEntry::new_with_icon(
+        "builtin-quicklinks",
+        "Quicklinks",
+        "Manage quick links and open URLs with optional {query} expansion",
+        vec![
+            "quicklinks",
+            "quicklink",
+            "link",
+            "url",
+            "bookmark",
+            "open",
+            "search",
+        ],
+        BuiltInFeature::Quicklinks,
+        "ðŸ”—",
+    ));
+    debug!("Added Quicklinks built-in entry");
+
     // Design Gallery is only available in debug builds (developer tool)
     #[cfg(debug_assertions)]
     {
diff --git a/src/quicklinks/mod.rs b/src/quicklinks/mod.rs
index 08aeea02e216c8026f59f0d8fe5627ededb1dec0..e9e055c95e2b0cd21fbc8b79971df226a788899c
--- a/src/quicklinks/mod.rs
+++ b/src/quicklinks/mod.rs
@@ -43,6 +43,14 @@
     url_template.replace(QUERY_PLACEHOLDER, query)
 }
 
+pub fn has_query_placeholder(url_template: &str) -> bool {
+    url_template.contains(QUERY_PLACEHOLDER)
+}
+
+pub fn update_quicklink(id: &str, name: &str, url_template: &str) -> bool {
+    update_quicklink_from_path(id, name, url_template, &quicklinks_path())
+}
+
 fn quicklinks_path() -> PathBuf {
     dirs::home_dir()
         .map(|home| home.join(".scriptkit").join(QUICKLINKS_FILE))
@@ -75,11 +83,22 @@
     let _ = save_quicklinks_to_path(&links, path);
 }
 
+fn update_quicklink_from_path(id: &str, name: &str, url_template: &str, path: &Path) -> bool {
+    let mut links = load_quicklinks_from_path(path);
+    if let Some(link) = links.iter_mut().find(|link| link.id == id) {
+        link.name = name.trim().to_string();
+        link.url_template = url_template.trim().to_string();
+        return save_quicklinks_to_path(&links, path).is_ok();
+    }
+
+    false
+}
+
 #[cfg(test)]
 mod tests {
     use super::{
-        create_quicklink, delete_quicklink_from_path, expand_url, load_quicklinks_from_path,
-        save_quicklinks_to_path, Quicklink,
+        create_quicklink, delete_quicklink_from_path, expand_url, has_query_placeholder,
+        load_quicklinks_from_path, save_quicklinks_to_path, update_quicklink_from_path, Quicklink,
     };
 
     #[test]
@@ -105,6 +124,16 @@
     }
 
     #[test]
+    fn test_has_query_placeholder_returns_true_when_template_contains_placeholder() {
+        assert!(has_query_placeholder("https://example.com?q={query}"));
+    }
+
+    #[test]
+    fn test_has_query_placeholder_returns_false_when_template_missing_placeholder() {
+        assert!(!has_query_placeholder("https://example.com"));
+    }
+
+    #[test]
     fn test_load_quicklinks_from_path_returns_empty_when_file_missing() {
         let dir = tempfile::tempdir().expect("create temp dir");
         let path = dir.path().join("quicklinks.json");
@@ -174,4 +203,49 @@
         assert_eq!(loaded.len(), 1);
         assert_eq!(loaded[0].id, "keep");
     }
+
+    #[test]
+    fn test_update_quicklink_from_path_updates_name_and_url_template() {
+        let dir = tempfile::tempdir().expect("create temp dir");
+        let path = dir.path().join("quicklinks.json");
+        let links = vec![Quicklink {
+            id: "target".to_string(),
+            name: "Old".to_string(),
+            url_template: "https://old.example.com".to_string(),
+            icon: None,
+        }];
+
+        save_quicklinks_to_path(&links, &path).expect("seed quicklinks");
+        let updated = update_quicklink_from_path(
+            "target",
+            " New Name ",
+            " https://new.example.com?q={query} ",
+            &path,
+        );
+
+        assert!(updated);
+        let loaded = load_quicklinks_from_path(&path);
+        assert_eq!(loaded.len(), 1);
+        assert_eq!(loaded[0].name, "New Name");
+        assert_eq!(loaded[0].url_template, "https://new.example.com?q={query}");
+    }
+
+    #[test]
+    fn test_update_quicklink_from_path_returns_false_when_id_not_found() {
+        let dir = tempfile::tempdir().expect("create temp dir");
+        let path = dir.path().join("quicklinks.json");
+        let links = vec![Quicklink {
+            id: "target".to_string(),
+            name: "Keep".to_string(),
+            url_template: "https://example.com".to_string(),
+            icon: None,
+        }];
+
+        save_quicklinks_to_path(&links, &path).expect("seed quicklinks");
+        let updated = update_quicklink_from_path("missing", "Name", "https://updated.example.com", &path);
+
+        assert!(!updated);
+        let loaded = load_quicklinks_from_path(&path);
+        assert_eq!(loaded, links);
+    }
 }


thinking
**Identifying execution handler location**
codex
Iâ€™m tracing the exact `Enter` execution path now (`execute_selected`) so I can hook quicklinks into an existing list flow with minimal structural churn.
exec
/bin/zsh -lc "rg -n \"fn execute_selected|execute_selected\\(\" src/app_impl src | head -n 80" in /Users/johnlindquist/dev/script-kit-gpui succeeded in 51ms:
src/app_impl/selection_fallback.rs:103:    pub(crate) fn execute_selected(&mut self, cx: &mut Context<Self>) {
src/app_impl/selection_fallback.rs:250:    pub fn execute_selected_fallback(&mut self, cx: &mut Context<Self>) {
src/app_impl/startup.rs:280:                            this.execute_selected(cx);
src/app_impl/startup_new_prelude.rs:264:                            this.execute_selected(cx);
src/app_actions/handle_action.rs:564:                self.execute_selected(cx);
src/app_actions/handle_action/main_actions_01.rs:20:                self.execute_selected(cx);
src/render_script_list/part_000.rs:339:                                                        this.execute_selected(cx);
src/render_script_list/part_000.rs:817:                            this.execute_selected(cx);
src/render_script_list/part_000.rs:1242:                            this.execute_selected(cx);
src/render_script_list/part_000_body/body_001.rs:348:                            this.execute_selected(cx);
src/render_script_list/part_000_body/body_000.rs:333:                                                        this.execute_selected(cx);
src/render_script_list/part_000_body/body_002.rs:382:                            this.execute_selected(cx);
src/main_entry/runtime_stdin.rs:353:                                                    view.execute_selected(ctx);
src/main_entry/app_run_setup.rs:1555:                                                    view.execute_selected(ctx);
src/main_entry/runtime_stdin_match_simulate_key.rs:74:                                                    view.execute_selected(ctx);
src/app_impl/startup_new_prelude.rs:264:                            this.execute_selected(cx);
src/app_impl/startup.rs:280:                            this.execute_selected(cx);
src/app_impl/selection_fallback.rs:103:    pub(crate) fn execute_selected(&mut self, cx: &mut Context<Self>) {
src/app_impl/selection_fallback.rs:250:    pub fn execute_selected_fallback(&mut self, cx: &mut Context<Self>) {
src/scripts/types.rs:263:    /// This method is used by both the footer button text and execute_selected().
file update:
diff --git a/src/builtins/part_001_entries/entries_000.rs b/src/builtins/part_001_entries/entries_000.rs
index 926be9edb8db75488c1894f105dba265b103c614..1b3e861bd2e0390edbd6aafc031907ffa15a7cd5
--- a/src/builtins/part_001_entries/entries_000.rs
+++ b/src/builtins/part_001_entries/entries_000.rs
@@ -69,6 +69,24 @@
     ));
     debug!("Added Notes built-in entry");
 
+    entries.push(BuiltInEntry::new_with_icon(
+        "builtin-quicklinks",
+        "Quicklinks",
+        "Manage quick links and open URLs with optional {query} expansion",
+        vec![
+            "quicklinks",
+            "quicklink",
+            "link",
+            "url",
+            "bookmark",
+            "open",
+            "search",
+        ],
+        BuiltInFeature::Quicklinks,
+        "ðŸ”—",
+    ));
+    debug!("Added Quicklinks built-in entry");
+
     // Design Gallery is only available in debug builds (developer tool)
     #[cfg(debug_assertions)]
     {
diff --git a/src/quicklinks/mod.rs b/src/quicklinks/mod.rs
index 08aeea02e216c8026f59f0d8fe5627ededb1dec0..e9e055c95e2b0cd21fbc8b79971df226a788899c
--- a/src/quicklinks/mod.rs
+++ b/src/quicklinks/mod.rs
@@ -43,6 +43,14 @@
     url_template.replace(QUERY_PLACEHOLDER, query)
 }
 
+pub fn has_query_placeholder(url_template: &str) -> bool {
+    url_template.contains(QUERY_PLACEHOLDER)
+}
+
+pub fn update_quicklink(id: &str, name: &str, url_template: &str) -> bool {
+    update_quicklink_from_path(id, name, url_template, &quicklinks_path())
+}
+
 fn quicklinks_path() -> PathBuf {
     dirs::home_dir()
         .map(|home| home.join(".scriptkit").join(QUICKLINKS_FILE))
@@ -75,11 +83,22 @@
     let _ = save_quicklinks_to_path(&links, path);
 }
 
+fn update_quicklink_from_path(id: &str, name: &str, url_template: &str, path: &Path) -> bool {
+    let mut links = load_quicklinks_from_path(path);
+    if let Some(link) = links.iter_mut().find(|link| link.id == id) {
+        link.name = name.trim().to_string();
+        link.url_template = url_template.trim().to_string();
+        return save_quicklinks_to_path(&links, path).is_ok();
+    }
+
+    false
+}
+
 #[cfg(test)]
 mod tests {
     use super::{
-        create_quicklink, delete_quicklink_from_path, expand_url, load_quicklinks_from_path,
-        save_quicklinks_to_path, Quicklink,
+        create_quicklink, delete_quicklink_from_path, expand_url, has_query_placeholder,
+        load_quicklinks_from_path, save_quicklinks_to_path, update_quicklink_from_path, Quicklink,
     };
 
     #[test]
@@ -105,6 +124,16 @@
     }
 
     #[test]
+    fn test_has_query_placeholder_returns_true_when_template_contains_placeholder() {
+        assert!(has_query_placeholder("https://example.com?q={query}"));
+    }
+
+    #[test]
+    fn test_has_query_placeholder_returns_false_when_template_missing_placeholder() {
+        assert!(!has_query_placeholder("https://example.com"));
+    }
+
+    #[test]
     fn test_load_quicklinks_from_path_returns_empty_when_file_missing() {
         let dir = tempfile::tempdir().expect("create temp dir");
         let path = dir.path().join("quicklinks.json");
@@ -174,4 +203,49 @@
         assert_eq!(loaded.len(), 1);
         assert_eq!(loaded[0].id, "keep");
     }
+
+    #[test]
+    fn test_update_quicklink_from_path_updates_name_and_url_template() {
+        let dir = tempfile::tempdir().expect("create temp dir");
+        let path = dir.path().join("quicklinks.json");
+        let links = vec![Quicklink {
+            id: "target".to_string(),
+            name: "Old".to_string(),
+            url_template: "https://old.example.com".to_string(),
+            icon: None,
+        }];
+
+        save_quicklinks_to_path(&links, &path).expect("seed quicklinks");
+        let updated = update_quicklink_from_path(
+            "target",
+            " New Name ",
+            " https://new.example.com?q={query} ",
+            &path,
+        );
+
+        assert!(updated);
+        let loaded = load_quicklinks_from_path(&path);
+        assert_eq!(loaded.len(), 1);
+        assert_eq!(loaded[0].name, "New Name");
+        assert_eq!(loaded[0].url_template, "https://new.example.com?q={query}");
+    }
+
+    #[test]
+    fn test_update_quicklink_from_path_returns_false_when_id_not_found() {
+        let dir = tempfile::tempdir().expect("create temp dir");
+        let path = dir.path().join("quicklinks.json");
+        let links = vec![Quicklink {
+            id: "target".to_string(),
+            name: "Keep".to_string(),
+            url_template: "https://example.com".to_string(),
+            icon: None,
+        }];
+
+        save_quicklinks_to_path(&links, &path).expect("seed quicklinks");
+        let updated = update_quicklink_from_path("missing", "Name", "https://updated.example.com", &path);
+
+        assert!(!updated);
+        let loaded = load_quicklinks_from_path(&path);
+        assert_eq!(loaded, links);
+    }
 }

exec
/bin/zsh -lc "sed -n '1,260p' src/app_impl/selection_fallback.rs" in /Users/johnlindquist/dev/script-kit-gpui succeeded in 52ms:
use super::*;

fn resolve_grouped_result_index(
    grouped_items: &[GroupedListItem],
    selected_index: usize,
) -> Option<(usize, usize)> {
    let coerced_index = crate::list_item::coerce_selection(grouped_items, selected_index)?;
    match grouped_items.get(coerced_index) {
        Some(GroupedListItem::Item(result_idx)) => Some((coerced_index, *result_idx)),
        _ => None,
    }
}

impl ScriptListApp {
    #[allow(dead_code)]
    pub(crate) fn filtered_scripts(&self) -> Vec<Arc<scripts::Script>> {
        let filter_text = self.filter_text();
        if filter_text.is_empty() {
            self.scripts.clone()
        } else {
file update:
diff --git a/src/builtins/part_001_entries/entries_000.rs b/src/builtins/part_001_entries/entries_000.rs
index 926be9edb8db75488c1894f105dba265b103c614..1b3e861bd2e0390edbd6aafc031907ffa15a7cd5
--- a/src/builtins/part_001_entries/entries_000.rs
+++ b/src/builtins/part_001_entries/entries_000.rs
@@ -69,6 +69,24 @@
     ));
     debug!("Added Notes built-in entry");
 
+    entries.push(BuiltInEntry::new_with_icon(
+        "builtin-quicklinks",
+        "Quicklinks",
+        "Manage quick links and open URLs with optional {query} expansion",
+        vec![
+            "quicklinks",
+            "quicklink",
+            "link",
+            "url",
+            "bookmark",
+            "open",
+            "search",
+        ],
+        BuiltInFeature::Quicklinks,
+        "ðŸ”—",
+    ));
+    debug!("Added Quicklinks built-in entry");
+
     // Design Gallery is only available in debug builds (developer tool)
     #[cfg(debug_assertions)]
     {
diff --git a/src/quicklinks/mod.rs b/src/quicklinks/mod.rs
index 08aeea02e216c8026f59f0d8fe5627ededb1dec0..e9e055c95e2b0cd21fbc8b79971df226a788899c
--- a/src/quicklinks/mod.rs
+++ b/src/quicklinks/mod.rs
@@ -43,6 +43,14 @@
     url_template.replace(QUERY_PLACEHOLDER, query)
 }
 
+pub fn has_query_placeholder(url_template: &str) -> bool {
+    url_template.contains(QUERY_PLACEHOLDER)
+}
+
+pub fn update_quicklink(id: &str, name: &str, url_template: &str) -> bool {
+    update_quicklink_from_path(id, name, url_template, &quicklinks_path())
+}
+
 fn quicklinks_path() -> PathBuf {
     dirs::home_dir()
         .map(|home| home.join(".scriptkit").join(QUICKLINKS_FILE))
@@ -75,11 +83,22 @@
     let _ = save_quicklinks_to_path(&links, path);
 }
 
+fn update_quicklink_from_path(id: &str, name: &str, url_template: &str, path: &Path) -> bool {
+    let mut links = load_quicklinks_from_path(path);
+    if let Some(link) = links.iter_mut().find(|link| link.id == id) {
+        link.name = name.trim().to_string();
+        link.url_template = url_template.trim().to_string();
+        return save_quicklinks_to_path(&links, path).is_ok();
+    }
+
+    false
+}
+
 #[cfg(test)]
 mod tests {
     use super::{
-        create_quicklink, delete_quicklink_from_path, expand_url, load_quicklinks_from_path,
-        save_quicklinks_to_path, Quicklink,
+        create_quicklink, delete_quicklink_from_path, expand_url, has_query_placeholder,
+        load_quicklinks_from_path, save_quicklinks_to_path, update_quicklink_from_path, Quicklink,
     };
 
     #[test]
@@ -105,6 +124,16 @@
     }
 
     #[test]
+    fn test_has_query_placeholder_returns_true_when_template_contains_placeholder() {
+        assert!(has_query_placeholder("https://example.com?q={query}"));
+    }
+
+    #[test]
+    fn test_has_query_placeholder_returns_false_when_template_missing_placeholder() {
+        assert!(!has_query_placeholder("https://example.com"));
+    }
+
+    #[test]
     fn test_load_quicklinks_from_path_returns_empty_when_file_missing() {
         let dir = tempfile::tempdir().expect("create temp dir");
         let path = dir.path().join("quicklinks.json");
@@ -174,4 +203,49 @@
         assert_eq!(loaded.len(), 1);
         assert_eq!(loaded[0].id, "keep");
     }
+
+    #[test]
+    fn test_update_quicklink_from_path_updates_name_and_url_template() {
+        let dir = tempfile::tempdir().expect("create temp dir");
+        let path = dir.path().join("quicklinks.json");
+        let links = vec![Quicklink {
+            id: "target".to_string(),
+            name: "Old".to_string(),
+            url_template: "https://old.example.com".to_string(),
+            icon: None,
+        }];
+
+        save_quicklinks_to_path(&links, &path).expect("seed quicklinks");
+        let updated = update_quicklink_from_path(
+            "target",
+            " New Name ",
+            " https://new.example.com?q={query} ",
+            &path,
+        );
+
+        assert!(updated);
+        let loaded = load_quicklinks_from_path(&path);
+        assert_eq!(loaded.len(), 1);
+        assert_eq!(loaded[0].name, "New Name");
+        assert_eq!(loaded[0].url_template, "https://new.example.com?q={query}");
+    }
+
+    #[test]
+    fn test_update_quicklink_from_path_returns_false_when_id_not_found() {
+        let dir = tempfile::tempdir().expect("create temp dir");
+        let path = dir.path().join("quicklinks.json");
+        let links = vec![Quicklink {
+            id: "target".to_string(),
+            name: "Keep".to_string(),
+            url_template: "https://example.com".to_string(),
+            icon: None,
+        }];
+
+        save_quicklinks_to_path(&links, &path).expect("seed quicklinks");
+        let updated = update_quicklink_from_path("missing", "Name", "https://updated.example.com", &path);
+
+        assert!(!updated);
+        let loaded = load_quicklinks_from_path(&path);
+        assert_eq!(loaded, links);
+    }
 }


thinking
**Inspecting favorites integration approach**
exec
/bin/zsh -lc "git diff -- src/builtins/part_000.rs src/app_execute/builtin_execution.rs | sed -n '1,260p'" in /Users/johnlindquist/dev/script-kit-gpui succeeded in 52ms:
diff --git a/src/app_execute/builtin_execution.rs b/src/app_execute/builtin_execution.rs
index ea07c5b..beb3a48 100644
--- a/src/app_execute/builtin_execution.rs
+++ b/src/app_execute/builtin_execution.rs
@@ -1,3 +1,7 @@
+fn ai_open_failure_message(error: impl std::fmt::Display) -> String {
+    format!("Failed to open AI: {}", error)
+}
+
 impl ScriptListApp {
     fn system_action_feedback_message(
         &self,
@@ -286,7 +290,7 @@ impl ScriptListApp {
                             let _ = this.update(cx, |this, cx| {
                                 this.toast_manager.push(
                                     components::toast::Toast::error(
-                                        format!("Failed to open AI: {}", e),
+                                        ai_open_failure_message(&e),
                                         &this.theme,
                                     )
file update:
diff --git a/src/builtins/part_001_entries/entries_000.rs b/src/builtins/part_001_entries/entries_000.rs
index 926be9edb8db75488c1894f105dba265b103c614..1b3e861bd2e0390edbd6aafc031907ffa15a7cd5
--- a/src/builtins/part_001_entries/entries_000.rs
+++ b/src/builtins/part_001_entries/entries_000.rs
@@ -69,6 +69,24 @@
     ));
     debug!("Added Notes built-in entry");
 
+    entries.push(BuiltInEntry::new_with_icon(
+        "builtin-quicklinks",
+        "Quicklinks",
+        "Manage quick links and open URLs with optional {query} expansion",
+        vec![
+            "quicklinks",
+            "quicklink",
+            "link",
+            "url",
+            "bookmark",
+            "open",
+            "search",
+        ],
+        BuiltInFeature::Quicklinks,
+        "ðŸ”—",
+    ));
+    debug!("Added Quicklinks built-in entry");
+
     // Design Gallery is only available in debug builds (developer tool)
     #[cfg(debug_assertions)]
     {
diff --git a/src/quicklinks/mod.rs b/src/quicklinks/mod.rs
index 08aeea02e216c8026f59f0d8fe5627ededb1dec0..e9e055c95e2b0cd21fbc8b79971df226a788899c
--- a/src/quicklinks/mod.rs
+++ b/src/quicklinks/mod.rs
@@ -43,6 +43,14 @@
     url_template.replace(QUERY_PLACEHOLDER, query)
 }
 
+pub fn has_query_placeholder(url_template: &str) -> bool {
+    url_template.contains(QUERY_PLACEHOLDER)
+}
+
+pub fn update_quicklink(id: &str, name: &str, url_template: &str) -> bool {
+    update_quicklink_from_path(id, name, url_template, &quicklinks_path())
+}
+
 fn quicklinks_path() -> PathBuf {
     dirs::home_dir()
         .map(|home| home.join(".scriptkit").join(QUICKLINKS_FILE))
@@ -75,11 +83,22 @@
     let _ = save_quicklinks_to_path(&links, path);
 }
 
+fn update_quicklink_from_path(id: &str, name: &str, url_template: &str, path: &Path) -> bool {
+    let mut links = load_quicklinks_from_path(path);
+    if let Some(link) = links.iter_mut().find(|link| link.id == id) {
+        link.name = name.trim().to_string();
+        link.url_template = url_template.trim().to_string();
+        return save_quicklinks_to_path(&links, path).is_ok();
+    }
+
+    false
+}
+
 #[cfg(test)]
 mod tests {
     use super::{
-        create_quicklink, delete_quicklink_from_path, expand_url, load_quicklinks_from_path,
-        save_quicklinks_to_path, Quicklink,
+        create_quicklink, delete_quicklink_from_path, expand_url, has_query_placeholder,
+        load_quicklinks_from_path, save_quicklinks_to_path, update_quicklink_from_path, Quicklink,
     };
 
     #[test]
@@ -105,6 +124,16 @@
     }
 
     #[test]
+    fn test_has_query_placeholder_returns_true_when_template_contains_placeholder() {
+        assert!(has_query_placeholder("https://example.com?q={query}"));
+    }
+
+    #[test]
+    fn test_has_query_placeholder_returns_false_when_template_missing_placeholder() {
+        assert!(!has_query_placeholder("https://example.com"));
+    }
+
+    #[test]
     fn test_load_quicklinks_from_path_returns_empty_when_file_missing() {
         let dir = tempfile::tempdir().expect("create temp dir");
         let path = dir.path().join("quicklinks.json");
@@ -174,4 +203,49 @@
         assert_eq!(loaded.len(), 1);
         assert_eq!(loaded[0].id, "keep");
     }
+
+    #[test]
+    fn test_update_quicklink_from_path_updates_name_and_url_template() {
+        let dir = tempfile::tempdir().expect("create temp dir");
+        let path = dir.path().join("quicklinks.json");
+        let links = vec![Quicklink {
+            id: "target".to_string(),
+            name: "Old".to_string(),
+            url_template: "https://old.example.com".to_string(),
+            icon: None,
+        }];
+
+        save_quicklinks_to_path(&links, &path).expect("seed quicklinks");
+        let updated = update_quicklink_from_path(
+            "target",
+            " New Name ",
+            " https://new.example.com?q={query} ",
+            &path,
+        );
+
+        assert!(updated);
+        let loaded = load_quicklinks_from_path(&path);
+        assert_eq!(loaded.len(), 1);
+        assert_eq!(loaded[0].name, "New Name");
+        assert_eq!(loaded[0].url_template, "https://new.example.com?q={query}");
+    }
+
+    #[test]
+    fn test_update_quicklink_from_path_returns_false_when_id_not_found() {
+        let dir = tempfile::tempdir().expect("create temp dir");
+        let path = dir.path().join("quicklinks.json");
+        let links = vec![Quicklink {
+            id: "target".to_string(),
+            name: "Keep".to_string(),
+            url_template: "https://example.com".to_string(),
+            icon: None,
+        }];
+
+        save_quicklinks_to_path(&links, &path).expect("seed quicklinks");
+        let updated = update_quicklink_from_path("missing", "Name", "https://updated.example.com", &path);
+
+        assert!(!updated);
+        let loaded = load_quicklinks_from_path(&path);
+        assert_eq!(loaded, links);
+    }
 }


thinking
**Checking unchanged file diff**
exec
/bin/zsh -lc "git diff -- src/builtins/part_000.rs | sed -n '1,200p'" in /Users/johnlindquist/dev/script-kit-gpui succeeded in 50ms:
diff --git a/src/builtins/part_000.rs b/src/builtins/part_000.rs
index c3e90b1..5f6d27d 100644
--- a/src/builtins/part_000.rs
+++ b/src/builtins/part_000.rs
@@ -96,6 +96,8 @@ pub enum AiCommandType {
     OpenAi,
     NewConversation,
     ClearConversation,
+    /// Generate a new Script Kit script from the main prompt text
+    GenerateScript,
     /// Send a screenshot of the entire screen to AI Chat
     SendScreenToAi,
     /// Send a screenshot of the focused window to AI Chat
@@ -157,6 +159,13 @@ pub enum UtilityCommandType {
     /// Terminate all actively running Script Kit child processes
     StopAllProcesses,
 }
+/// Kit Store command types for browsing and managing kits
+#[derive(Debug, Clone, Copy, PartialEq, Eq)]
+pub enum KitStoreCommandType {
file update:
diff --git a/src/builtins/part_001_entries/entries_000.rs b/src/builtins/part_001_entries/entries_000.rs
index 926be9edb8db75488c1894f105dba265b103c614..1b3e861bd2e0390edbd6aafc031907ffa15a7cd5
--- a/src/builtins/part_001_entries/entries_000.rs
+++ b/src/builtins/part_001_entries/entries_000.rs
@@ -69,6 +69,24 @@
     ));
     debug!("Added Notes built-in entry");
 
+    entries.push(BuiltInEntry::new_with_icon(
+        "builtin-quicklinks",
+        "Quicklinks",
+        "Manage quick links and open URLs with optional {query} expansion",
+        vec![
+            "quicklinks",
+            "quicklink",
+            "link",
+            "url",
+            "bookmark",
+            "open",
+            "search",
+        ],
+        BuiltInFeature::Quicklinks,
+        "ðŸ”—",
+    ));
+    debug!("Added Quicklinks built-in entry");
+
     // Design Gallery is only available in debug builds (developer tool)
     #[cfg(debug_assertions)]
     {
diff --git a/src/quicklinks/mod.rs b/src/quicklinks/mod.rs
index 08aeea02e216c8026f59f0d8fe5627ededb1dec0..e9e055c95e2b0cd21fbc8b79971df226a788899c
--- a/src/quicklinks/mod.rs
+++ b/src/quicklinks/mod.rs
@@ -43,6 +43,14 @@
     url_template.replace(QUERY_PLACEHOLDER, query)
 }
 
+pub fn has_query_placeholder(url_template: &str) -> bool {
+    url_template.contains(QUERY_PLACEHOLDER)
+}
+
+pub fn update_quicklink(id: &str, name: &str, url_template: &str) -> bool {
+    update_quicklink_from_path(id, name, url_template, &quicklinks_path())
+}
+
 fn quicklinks_path() -> PathBuf {
     dirs::home_dir()
         .map(|home| home.join(".scriptkit").join(QUICKLINKS_FILE))
@@ -75,11 +83,22 @@
     let _ = save_quicklinks_to_path(&links, path);
 }
 
+fn update_quicklink_from_path(id: &str, name: &str, url_template: &str, path: &Path) -> bool {
+    let mut links = load_quicklinks_from_path(path);
+    if let Some(link) = links.iter_mut().find(|link| link.id == id) {
+        link.name = name.trim().to_string();
+        link.url_template = url_template.trim().to_string();
+        return save_quicklinks_to_path(&links, path).is_ok();
+    }
+
+    false
+}
+
 #[cfg(test)]
 mod tests {
     use super::{
-        create_quicklink, delete_quicklink_from_path, expand_url, load_quicklinks_from_path,
-        save_quicklinks_to_path, Quicklink,
+        create_quicklink, delete_quicklink_from_path, expand_url, has_query_placeholder,
+        load_quicklinks_from_path, save_quicklinks_to_path, update_quicklink_from_path, Quicklink,
     };
 
     #[test]
@@ -105,6 +124,16 @@
     }
 
     #[test]
+    fn test_has_query_placeholder_returns_true_when_template_contains_placeholder() {
+        assert!(has_query_placeholder("https://example.com?q={query}"));
+    }
+
+    #[test]
+    fn test_has_query_placeholder_returns_false_when_template_missing_placeholder() {
+        assert!(!has_query_placeholder("https://example.com"));
+    }
+
+    #[test]
     fn test_load_quicklinks_from_path_returns_empty_when_file_missing() {
         let dir = tempfile::tempdir().expect("create temp dir");
         let path = dir.path().join("quicklinks.json");
@@ -174,4 +203,49 @@
         assert_eq!(loaded.len(), 1);
         assert_eq!(loaded[0].id, "keep");
     }
+
+    #[test]
+    fn test_update_quicklink_from_path_updates_name_and_url_template() {
+        let dir = tempfile::tempdir().expect("create temp dir");
+        let path = dir.path().join("quicklinks.json");
+        let links = vec![Quicklink {
+            id: "target".to_string(),
+            name: "Old".to_string(),
+            url_template: "https://old.example.com".to_string(),
+            icon: None,
+        }];
+
+        save_quicklinks_to_path(&links, &path).expect("seed quicklinks");
+        let updated = update_quicklink_from_path(
+            "target",
+            " New Name ",
+            " https://new.example.com?q={query} ",
+            &path,
+        );
+
+        assert!(updated);
+        let loaded = load_quicklinks_from_path(&path);
+        assert_eq!(loaded.len(), 1);
+        assert_eq!(loaded[0].name, "New Name");
+        assert_eq!(loaded[0].url_template, "https://new.example.com?q={query}");
+    }
+
+    #[test]
+    fn test_update_quicklink_from_path_returns_false_when_id_not_found() {
+        let dir = tempfile::tempdir().expect("create temp dir");
+        let path = dir.path().join("quicklinks.json");
+        let links = vec![Quicklink {
+            id: "target".to_string(),
+            name: "Keep".to_string(),
+            url_template: "https://example.com".to_string(),
+            icon: None,
+        }];
+
+        save_quicklinks_to_path(&links, &path).expect("seed quicklinks");
+        let updated = update_quicklink_from_path("missing", "Name", "https://updated.example.com", &path);
+
+        assert!(!updated);
+        let loaded = load_quicklinks_from_path(&path);
+        assert_eq!(loaded, links);
+    }
 }


thinking
**Inspecting prompt form handling**
codex
Before editing dispatch logic, Iâ€™m checking whether thereâ€™s an existing prompt/form helper we can reuse for add/edit without introducing a new view type. This keeps changes contained to the claimed files.
exec
/bin/zsh -lc 'rg -n "ShowForm|FormPrompt|Message::Form|PromptMessage::ShowForm|show_form" src/prompt_handler src/app_execute src | head -n 200' in /Users/johnlindquist/dev/script-kit-gpui succeeded in 51ms:
src/prompt_handler/part_001.rs:176:            PromptMessage::ShowForm { id, html, actions } => {
src/prompt_handler/part_001.rs:185:                // Create FormPromptState entity with parsed fields
src/prompt_handler/part_001.rs:186:                let form_state = FormPromptState::new(id.clone(), html, colors, cx);
src/prompt_handler/part_001.rs:190:                self.current_view = AppView::FormPrompt { id, entity };
src/prompt_handler/part_001.rs:191:                self.focused_input = FocusedInput::None; // FormPrompt has its own focus handling
src/prompt_handler/part_001.rs:192:                self.pending_focus = Some(FocusTarget::FormPrompt);
src/prompt_handler/part_001.rs:745:                    AppView::FormPrompt { id, .. } => (
src/prompt_handler/part_001.rs:1087:                    AppView::FormPrompt { id, .. } => Some(id.clone()),
src/prompt_handler/part_001_arms/arms_000.rs:168:            PromptMessage::ShowForm { id, html, actions } => {
src/prompt_handler/part_001_arms/arms_000.rs:177:                // Create FormPromptState entity with parsed fields
src/prompt_handler/part_001_arms/arms_000.rs:178:                let form_state = FormPromptState::new(id.clone(), html, colors, cx);
src/prompt_handler/part_001_arms/arms_000.rs:182:                self.current_view = AppView::FormPrompt { id, entity };
src/prompt_handler/part_001_arms/arms_000.rs:183:                self.focused_input = FocusedInput::None; // FormPrompt has its own focus handling
src/prompt_handler/part_001_arms/arms_000.rs:184:                self.pending_focus = Some(FocusTarget::FormPrompt);
src/prompt_handler/part_001_arms/arms_003.rs:46:                    AppView::FormPrompt { id, .. } => Some(id.clone()),
src/prompt_handler/part_001_arms/arms_002.rs:86:                    AppView::FormPrompt { id, .. } => (
src/app_layout/build_layout_info.rs:15:            AppView::FormPrompt { .. } => "form",
src/app_layout/build_component_bounds.rs:36:            AppView::FormPrompt { .. } => "FormPrompt",
src/app_layout/build_component_bounds.rs:217:            AppView::FormPrompt { .. } => {
src/render_prompts/form/helpers.rs:28:fn focused_form_field_is_textarea(form: &FormPromptState) -> bool {
file update:
diff --git a/src/builtins/part_001_entries/entries_000.rs b/src/builtins/part_001_entries/entries_000.rs
index 926be9edb8db75488c1894f105dba265b103c614..1b3e861bd2e0390edbd6aafc031907ffa15a7cd5
--- a/src/builtins/part_001_entries/entries_000.rs
+++ b/src/builtins/part_001_entries/entries_000.rs
@@ -69,6 +69,24 @@
     ));
     debug!("Added Notes built-in entry");
 
+    entries.push(BuiltInEntry::new_with_icon(
+        "builtin-quicklinks",
+        "Quicklinks",
+        "Manage quick links and open URLs with optional {query} expansion",
+        vec![
+            "quicklinks",
+            "quicklink",
+            "link",
+            "url",
+            "bookmark",
+            "open",
+            "search",
+        ],
+        BuiltInFeature::Quicklinks,
+        "ðŸ”—",
+    ));
+    debug!("Added Quicklinks built-in entry");
+
     // Design Gallery is only available in debug builds (developer tool)
     #[cfg(debug_assertions)]
     {
diff --git a/src/quicklinks/mod.rs b/src/quicklinks/mod.rs
index 08aeea02e216c8026f59f0d8fe5627ededb1dec0..e9e055c95e2b0cd21fbc8b79971df226a788899c
--- a/src/quicklinks/mod.rs
+++ b/src/quicklinks/mod.rs
@@ -43,6 +43,14 @@
     url_template.replace(QUERY_PLACEHOLDER, query)
 }
 
+pub fn has_query_placeholder(url_template: &str) -> bool {
+    url_template.contains(QUERY_PLACEHOLDER)
+}
+
+pub fn update_quicklink(id: &str, name: &str, url_template: &str) -> bool {
+    update_quicklink_from_path(id, name, url_template, &quicklinks_path())
+}
+
 fn quicklinks_path() -> PathBuf {
     dirs::home_dir()
         .map(|home| home.join(".scriptkit").join(QUICKLINKS_FILE))
@@ -75,11 +83,22 @@
     let _ = save_quicklinks_to_path(&links, path);
 }
 
+fn update_quicklink_from_path(id: &str, name: &str, url_template: &str, path: &Path) -> bool {
+    let mut links = load_quicklinks_from_path(path);
+    if let Some(link) = links.iter_mut().find(|link| link.id == id) {
+        link.name = name.trim().to_string();
+        link.url_template = url_template.trim().to_string();
+        return save_quicklinks_to_path(&links, path).is_ok();
+    }
+
+    false
+}
+
 #[cfg(test)]
 mod tests {
     use super::{
-        create_quicklink, delete_quicklink_from_path, expand_url, load_quicklinks_from_path,
-        save_quicklinks_to_path, Quicklink,
+        create_quicklink, delete_quicklink_from_path, expand_url, has_query_placeholder,
+        load_quicklinks_from_path, save_quicklinks_to_path, update_quicklink_from_path, Quicklink,
     };
 
     #[test]
@@ -105,6 +124,16 @@
     }
 
     #[test]
+    fn test_has_query_placeholder_returns_true_when_template_contains_placeholder() {
+        assert!(has_query_placeholder("https://example.com?q={query}"));
+    }
+
+    #[test]
+    fn test_has_query_placeholder_returns_false_when_template_missing_placeholder() {
+        assert!(!has_query_placeholder("https://example.com"));
+    }
+
+    #[test]
     fn test_load_quicklinks_from_path_returns_empty_when_file_missing() {
         let dir = tempfile::tempdir().expect("create temp dir");
         let path = dir.path().join("quicklinks.json");
@@ -174,4 +203,49 @@
         assert_eq!(loaded.len(), 1);
         assert_eq!(loaded[0].id, "keep");
     }
+
+    #[test]
+    fn test_update_quicklink_from_path_updates_name_and_url_template() {
+        let dir = tempfile::tempdir().expect("create temp dir");
+        let path = dir.path().join("quicklinks.json");
+        let links = vec![Quicklink {
+            id: "target".to_string(),
+            name: "Old".to_string(),
+            url_template: "https://old.example.com".to_string(),
+            icon: None,
+        }];
+
+        save_quicklinks_to_path(&links, &path).expect("seed quicklinks");
+        let updated = update_quicklink_from_path(
+            "target",
+            " New Name ",
+            " https://new.example.com?q={query} ",
+            &path,
+        );
+
+        assert!(updated);
+        let loaded = load_quicklinks_from_path(&path);
+        assert_eq!(loaded.len(), 1);
+        assert_eq!(loaded[0].name, "New Name");
+        assert_eq!(loaded[0].url_template, "https://new.example.com?q={query}");
+    }
+
+    #[test]
+    fn test_update_quicklink_from_path_returns_false_when_id_not_found() {
+        let dir = tempfile::tempdir().expect("create temp dir");
+        let path = dir.path().join("quicklinks.json");
+        let links = vec![Quicklink {
+            id: "target".to_string(),
+            name: "Keep".to_string(),
+            url_template: "https://example.com".to_string(),
+            icon: None,
+        }];
+
+        save_quicklinks_to_path(&links, &path).expect("seed quicklinks");
+        let updated = update_quicklink_from_path("missing", "Name", "https://updated.example.com", &path);
+
+        assert!(!updated);
+        let loaded = load_quicklinks_from_path(&path);
+        assert_eq!(loaded, links);
+    }
 }


thinking
**Exploring quicklinks UI integration**
exec
/bin/zsh -lc "sed -n '1120,1445p' src/app_impl/startup.rs" in /Users/johnlindquist/dev/script-kit-gpui succeeded in 50ms:
        // Add interceptor for actions popup in FileSearchView and ScriptList
        // This handles Cmd+K (toggle), Escape (close), Enter (submit), and typing
        let app_entity_for_actions = cx.entity().downgrade();
        let actions_interceptor = cx.intercept_keystrokes({
            let app_entity = app_entity_for_actions;
            move |event, window, cx| {
                // CRITICAL: Skip processing if this keystroke is from Notes or AI window
                // intercept_keystrokes is GLOBAL and fires for ALL windows in the app
                // We only want to handle keystrokes for the main window
                if crate::notes::is_notes_window(window) || crate::ai::is_ai_window(window) {
                    return; // Let the secondary window handle its own keystrokes
                }

                let key = event.keystroke.key.to_lowercase();
                let has_cmd = event.keystroke.modifiers.platform;
                let has_shift = event.keystroke.modifiers.shift;
                let key_char = event.keystroke.key_char.as_deref();

                if let Some(app) = app_entity.upgrade() {
                    app.update(cx, |this, cx| {
file update:
diff --git a/src/builtins/part_001_entries/entries_000.rs b/src/builtins/part_001_entries/entries_000.rs
index 926be9edb8db75488c1894f105dba265b103c614..1b3e861bd2e0390edbd6aafc031907ffa15a7cd5
--- a/src/builtins/part_001_entries/entries_000.rs
+++ b/src/builtins/part_001_entries/entries_000.rs
@@ -69,6 +69,24 @@
     ));
     debug!("Added Notes built-in entry");
 
+    entries.push(BuiltInEntry::new_with_icon(
+        "builtin-quicklinks",
+        "Quicklinks",
+        "Manage quick links and open URLs with optional {query} expansion",
+        vec![
+            "quicklinks",
+            "quicklink",
+            "link",
+            "url",
+            "bookmark",
+            "open",
+            "search",
+        ],
+        BuiltInFeature::Quicklinks,
+        "ðŸ”—",
+    ));
+    debug!("Added Quicklinks built-in entry");
+
     // Design Gallery is only available in debug builds (developer tool)
     #[cfg(debug_assertions)]
     {
diff --git a/src/quicklinks/mod.rs b/src/quicklinks/mod.rs
index 08aeea02e216c8026f59f0d8fe5627ededb1dec0..e9e055c95e2b0cd21fbc8b79971df226a788899c
--- a/src/quicklinks/mod.rs
+++ b/src/quicklinks/mod.rs
@@ -43,6 +43,14 @@
     url_template.replace(QUERY_PLACEHOLDER, query)
 }
 
+pub fn has_query_placeholder(url_template: &str) -> bool {
+    url_template.contains(QUERY_PLACEHOLDER)
+}
+
+pub fn update_quicklink(id: &str, name: &str, url_template: &str) -> bool {
+    update_quicklink_from_path(id, name, url_template, &quicklinks_path())
+}
+
 fn quicklinks_path() -> PathBuf {
     dirs::home_dir()
         .map(|home| home.join(".scriptkit").join(QUICKLINKS_FILE))
@@ -75,11 +83,22 @@
     let _ = save_quicklinks_to_path(&links, path);
 }
 
+fn update_quicklink_from_path(id: &str, name: &str, url_template: &str, path: &Path) -> bool {
+    let mut links = load_quicklinks_from_path(path);
+    if let Some(link) = links.iter_mut().find(|link| link.id == id) {
+        link.name = name.trim().to_string();
+        link.url_template = url_template.trim().to_string();
+        return save_quicklinks_to_path(&links, path).is_ok();
+    }
+
+    false
+}
+
 #[cfg(test)]
 mod tests {
     use super::{
-        create_quicklink, delete_quicklink_from_path, expand_url, load_quicklinks_from_path,
-        save_quicklinks_to_path, Quicklink,
+        create_quicklink, delete_quicklink_from_path, expand_url, has_query_placeholder,
+        load_quicklinks_from_path, save_quicklinks_to_path, update_quicklink_from_path, Quicklink,
     };
 
     #[test]
@@ -105,6 +124,16 @@
     }
 
     #[test]
+    fn test_has_query_placeholder_returns_true_when_template_contains_placeholder() {
+        assert!(has_query_placeholder("https://example.com?q={query}"));
+    }
+
+    #[test]
+    fn test_has_query_placeholder_returns_false_when_template_missing_placeholder() {
+        assert!(!has_query_placeholder("https://example.com"));
+    }
+
+    #[test]
     fn test_load_quicklinks_from_path_returns_empty_when_file_missing() {
         let dir = tempfile::tempdir().expect("create temp dir");
         let path = dir.path().join("quicklinks.json");
@@ -174,4 +203,49 @@
         assert_eq!(loaded.len(), 1);
         assert_eq!(loaded[0].id, "keep");
     }
+
+    #[test]
+    fn test_update_quicklink_from_path_updates_name_and_url_template() {
+        let dir = tempfile::tempdir().expect("create temp dir");
+        let path = dir.path().join("quicklinks.json");
+        let links = vec![Quicklink {
+            id: "target".to_string(),
+            name: "Old".to_string(),
+            url_template: "https://old.example.com".to_string(),
+            icon: None,
+        }];
+
+        save_quicklinks_to_path(&links, &path).expect("seed quicklinks");
+        let updated = update_quicklink_from_path(
+            "target",
+            " New Name ",
+            " https://new.example.com?q={query} ",
+            &path,
+        );
+
+        assert!(updated);
+        let loaded = load_quicklinks_from_path(&path);
+        assert_eq!(loaded.len(), 1);
+        assert_eq!(loaded[0].name, "New Name");
+        assert_eq!(loaded[0].url_template, "https://new.example.com?q={query}");
+    }
+
+    #[test]
+    fn test_update_quicklink_from_path_returns_false_when_id_not_found() {
+        let dir = tempfile::tempdir().expect("create temp dir");
+        let path = dir.path().join("quicklinks.json");
+        let links = vec![Quicklink {
+            id: "target".to_string(),
+            name: "Keep".to_string(),
+            url_template: "https://example.com".to_string(),
+            icon: None,
+        }];
+
+        save_quicklinks_to_path(&links, &path).expect("seed quicklinks");
+        let updated = update_quicklink_from_path("missing", "Name", "https://updated.example.com", &path);
+
+        assert!(!updated);
+        let loaded = load_quicklinks_from_path(&path);
+        assert_eq!(loaded, links);
+    }
 }


thinking
**Inspecting enter key handling**
exec
/bin/zsh -lc "rg -n \"on_key|KeyDown|keystroke|key == \\\"enter\\\"|PressEnter\" src/app_impl/startup.rs | head -n 120" in /Users/johnlindquist/dev/script-kit-gpui succeeded in 51ms:
273:                InputEvent::PressEnter { .. } => {
554:        let tab_interceptor = cx.intercept_keystrokes({
557:                let key = event.keystroke.key.to_lowercase();
558:                let is_tab_key = matches!(event.keystroke.key.as_str(), "tab" | "Tab")
560:                let has_shift = event.keystroke.modifiers.shift;
563:                    && !event.keystroke.modifiers.platform
564:                    && !event.keystroke.modifiers.alt
565:                    && !event.keystroke.modifiers.control
756:        let arrow_interceptor = cx.intercept_keystrokes({
759:                let key = event.keystroke.key.to_lowercase();
762:                    && !event.keystroke.modifiers.platform
763:                    && !event.keystroke.modifiers.alt
764:                    && !event.keystroke.modifiers.control
1066:        let home_end_interceptor = cx.intercept_keystrokes({
1069:                // Skip processing if this keystroke is from Notes or AI window
1074:                let key = event.keystroke.key.to_lowercase();
1075:                let has_platform_mod = event.keystroke.modifiers.platform; // Cmd on macOS
1123:        let actions_interceptor = cx.intercept_keystrokes({
1126:                // CRITICAL: Skip processing if this keystroke is from Notes or AI window
1127:                // intercept_keystrokes is GLOBAL and fires for ALL windows in the app
file update:
diff --git a/src/builtins/part_001_entries/entries_000.rs b/src/builtins/part_001_entries/entries_000.rs
index 926be9edb8db75488c1894f105dba265b103c614..1b3e861bd2e0390edbd6aafc031907ffa15a7cd5
--- a/src/builtins/part_001_entries/entries_000.rs
+++ b/src/builtins/part_001_entries/entries_000.rs
@@ -69,6 +69,24 @@
     ));
     debug!("Added Notes built-in entry");
 
+    entries.push(BuiltInEntry::new_with_icon(
+        "builtin-quicklinks",
+        "Quicklinks",
+        "Manage quick links and open URLs with optional {query} expansion",
+        vec![
+            "quicklinks",
+            "quicklink",
+            "link",
+            "url",
+            "bookmark",
+            "open",
+            "search",
+        ],
+        BuiltInFeature::Quicklinks,
+        "ðŸ”—",
+    ));
+    debug!("Added Quicklinks built-in entry");
+
     // Design Gallery is only available in debug builds (developer tool)
     #[cfg(debug_assertions)]
     {
diff --git a/src/quicklinks/mod.rs b/src/quicklinks/mod.rs
index 08aeea02e216c8026f59f0d8fe5627ededb1dec0..e9e055c95e2b0cd21fbc8b79971df226a788899c
--- a/src/quicklinks/mod.rs
+++ b/src/quicklinks/mod.rs
@@ -43,6 +43,14 @@
     url_template.replace(QUERY_PLACEHOLDER, query)
 }
 
+pub fn has_query_placeholder(url_template: &str) -> bool {
+    url_template.contains(QUERY_PLACEHOLDER)
+}
+
+pub fn update_quicklink(id: &str, name: &str, url_template: &str) -> bool {
+    update_quicklink_from_path(id, name, url_template, &quicklinks_path())
+}
+
 fn quicklinks_path() -> PathBuf {
     dirs::home_dir()
         .map(|home| home.join(".scriptkit").join(QUICKLINKS_FILE))
@@ -75,11 +83,22 @@
     let _ = save_quicklinks_to_path(&links, path);
 }
 
+fn update_quicklink_from_path(id: &str, name: &str, url_template: &str, path: &Path) -> bool {
+    let mut links = load_quicklinks_from_path(path);
+    if let Some(link) = links.iter_mut().find(|link| link.id == id) {
+        link.name = name.trim().to_string();
+        link.url_template = url_template.trim().to_string();
+        return save_quicklinks_to_path(&links, path).is_ok();
+    }
+
+    false
+}
+
 #[cfg(test)]
 mod tests {
     use super::{
-        create_quicklink, delete_quicklink_from_path, expand_url, load_quicklinks_from_path,
-        save_quicklinks_to_path, Quicklink,
+        create_quicklink, delete_quicklink_from_path, expand_url, has_query_placeholder,
+        load_quicklinks_from_path, save_quicklinks_to_path, update_quicklink_from_path, Quicklink,
     };
 
     #[test]
@@ -105,6 +124,16 @@
     }
 
     #[test]
+    fn test_has_query_placeholder_returns_true_when_template_contains_placeholder() {
+        assert!(has_query_placeholder("https://example.com?q={query}"));
+    }
+
+    #[test]
+    fn test_has_query_placeholder_returns_false_when_template_missing_placeholder() {
+        assert!(!has_query_placeholder("https://example.com"));
+    }
+
+    #[test]
     fn test_load_quicklinks_from_path_returns_empty_when_file_missing() {
         let dir = tempfile::tempdir().expect("create temp dir");
         let path = dir.path().join("quicklinks.json");
@@ -174,4 +203,49 @@
         assert_eq!(loaded.len(), 1);
         assert_eq!(loaded[0].id, "keep");
     }
+
+    #[test]
+    fn test_update_quicklink_from_path_updates_name_and_url_template() {
+        let dir = tempfile::tempdir().expect("create temp dir");
+        let path = dir.path().join("quicklinks.json");
+        let links = vec![Quicklink {
+            id: "target".to_string(),
+            name: "Old".to_string(),
+            url_template: "https://old.example.com".to_string(),
+            icon: None,
+        }];
+
+        save_quicklinks_to_path(&links, &path).expect("seed quicklinks");
+        let updated = update_quicklink_from_path(
+            "target",
+            " New Name ",
+            " https://new.example.com?q={query} ",
+            &path,
+        );
+
+        assert!(updated);
+        let loaded = load_quicklinks_from_path(&path);
+        assert_eq!(loaded.len(), 1);
+        assert_eq!(loaded[0].name, "New Name");
+        assert_eq!(loaded[0].url_template, "https://new.example.com?q={query}");
+    }
+
+    #[test]
+    fn test_update_quicklink_from_path_returns_false_when_id_not_found() {
+        let dir = tempfile::tempdir().expect("create temp dir");
+        let path = dir.path().join("quicklinks.json");
+        let links = vec![Quicklink {
+            id: "target".to_string(),
+            name: "Keep".to_string(),
+            url_template: "https://example.com".to_string(),
+            icon: None,
+        }];
+
+        save_quicklinks_to_path(&links, &path).expect("seed quicklinks");
+        let updated = update_quicklink_from_path("missing", "Name", "https://updated.example.com", &path);
+
+        assert!(!updated);
+        let loaded = load_quicklinks_from_path(&path);
+        assert_eq!(loaded, links);
+    }
 }


[swarm-timeout] max runtime 600s reached; sending SIGTERM


==== exit @ 2026-02-08T03:07:24.018Z code=0 status=needs_split ====
