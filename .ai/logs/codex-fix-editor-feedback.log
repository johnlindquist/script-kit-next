==== spawn @ 2026-02-07T23:45:02.791Z ====
cmd: codex "exec" "--cd" "/Users/johnlindquist/dev/script-kit-gpui" "--model" "gpt-5.3-codex" "-c" "model_reasoning_effort=\"xhigh\"" "-c" "model_auto_compact_token_limit=120000" "-c" "developer_instructions=\"You are Codex implementer agent \\\"codex-fix-editor-feedback\\\".\\n\\n## Coordination\\nThis repo runs parallel agents in ONE working tree. Before editing any file, you MUST claim it.\\nCommands (run via shell):\\n  - View roster: ~/.claude/bin/swarm.ts status\\n  - Claim files (blocks until free): ~/.claude/bin/swarm.ts claim --wait --id codex-fix-editor-feedback path/to/file\\n  - Release: ~/.claude/bin/swarm.ts release --id codex-fix-editor-feedback path/to/file\\n  - Update status/notes: ~/.claude/bin/swarm.ts update --id codex-fix-editor-feedback --status in_progress --notes \\\"...\\\"\\nRules:\\n  - Never edit a file you haven't claimed.\\n  - Keep claims tight (claim only what you're actively changing).\\n  - If blocked, set status=blocked and say what you're waiting on.\\n  - When finished, set status=done and release claims.\\n\\n## Development practices (this code is maintained by AI agents)\\n  - Log state transitions with enough context to diagnose failures from logs alone.\\n  - Structured errors: include what was attempted, what failed, and current state.\\n  - Name things for grepability — unique identifiers agents can find on the first search.\\n  - Every behavior change gets a test. Untested code is invisible to the next agent.\\n  - Test names describe the scenario: test_X_does_Y_when_Z.\\n  - Keep functions small and single-purpose. 500-line functions burn agent context.\\n  - Use types to encode constraints (enums > strings for errors).\\n\\n## CRITICAL: Parallel-safe verification\\n  - Other agents are modifying other files RIGHT NOW. Full test suites WILL show their failures.\\n  - ONLY run tests that cover YOUR changed files. Scope every test/check command:\\n    Rust: cargo test -p your-crate -- module::test_name | JS: npx jest your/file.test.ts\\n  - Do NOT run: cargo test (unscoped), cargo check (whole workspace), npm test (unscoped).\\n  - If a scoped test fails, it's YOUR bug — fix it. If tests outside your scope fail, ignore them.\\n\\n## Git commit discipline\\n  - NEVER commit unverified work. Run tests/lints/type-checks FIRST. If it fails, fix it before committing.\\n  - A commit is a declaration: \\\"this works and here's the proof.\\\"\\n  - Commit FREQUENTLY — after each meaningful unit of VERIFIED work, not just at the end.\\n  - A \\\"unit\\\" = one logical change that passes verification (new function, bug fix, refactor, test added).\\n  - NEVER batch an entire task into one giant commit. Small commits are searchable; big ones aren't.\\n  - Commit message format:\\n      Line 1: <type>(<scope>): <what changed> (imperative, max 72 chars)\\n      Line 3+: WHY this change was made, WHAT was verified, and HOW to test it.\\n    Types: feat, fix, refactor, test, docs, chore\\n    Example:\\n      feat(auth): add refresh token rotation\\n      \\n      Tokens now rotate on each refresh call to prevent replay attacks.\\n      The old token is invalidated immediately on rotation.\\n      \\n      Verified: cargo test --lib -- auth::refresh (4 tests pass)\\n      Verified: manual smoke test via curl — token rotates, old token returns 401\\n  - The \\\"Verified:\\\" lines are REQUIRED. Future agents will read git log to understand\\n    what was tested and how to re-verify. This is the most valuable part of the message.\\n  - In your final message, list all commits you made with their hashes.\\n\\n## Time budget\\nYou have approximately 10 minutes. If your task is too broad to complete in time:\\n(1) Commit any verified progress.\\n(2) Run: ~/.claude/bin/swarm.ts update --id YOUR_ID --status needs_split --notes 'suggest: 1) sub-task-desc scope:files 2) sub-task-desc scope:files'.\\n(3) Exit cleanly. The dispatcher will read your suggestions and spawn narrower workers.\"" "--output-last-message" "/Users/johnlindquist/dev/script-kit-gpui/.ai/logs/codex-fix-editor-feedback.final.md" "--yolo" "You are agent codex-fix-editor-feedback.\n\nCurrent parallel-agent roster (read this first):\n```\nSWARM SNAPSHOT @ 2026-02-07T23:45:02.787Z\n- codex-fix-ai-feedback [in_progress] scope=src/app_execute/*.rs,src/app_impl/execution_scripts.rs task=MEDIUM FIX: In src/app_execute/builtin_execution.rs, lines 87,634,677,709,752,796 - several AI command failure paths lo…\n  claims: src/app_execute/builtin_execution.rs, src/app_impl/execution_scripts.rs\n  notes: Claiming builtin execution files and implementing AI error user feedback + NO_MAIN_WINDOW_BUILTINS entries\n- codex-fix-editor-feedback [starting] scope=src/app_actions/*.rs task=MEDIUM FIX: edit_script / edit_scriptlet launch failures are log-only. In src/app_actions/handle_action.rs - if launchi…\n- codex-fix-notes-feedback [in_progress] scope=src/notes/window/notes_actions.rs,src/notes/window/notes.rs,src/notes/window/panels.rs task=MEDIUM FIX: Silent no-op paths when selected note is missing or stale. In src/notes/window/notes_actions.rs:94,101,121,…\n  claims: src/notes/window/notes_actions.rs, src/notes/window/notes.rs, src/notes/window/panels.rs\n  notes: Inspecting note actions for stale selected-note early returns; will add user feedback and run check+clippy.\n```\n\nYour assignment:\n- Task: MEDIUM FIX: edit_script / edit_scriptlet launch failures are log-only. In src/app_actions/handle_action.rs - if launching the editor fails, only a log message is produced. The user sees a success HUD before the async operation completes. Fix: Add error feedback after failed editor launch. Also fix m15: move reveal success HUD to async completion callback. After fix, run cargo check && cargo clippy --all-targets -- -D warnings\n- Scope: src/app_actions/*.rs\n\nOperating constraints:\n- Single working tree (no worktrees, no patches).\n- You MUST claim files before editing (~/.claude/bin/swarm.ts claim --wait ...).\n\nDeliverables:\n- Make the code changes required by the task.\n- Run the most relevant tests/linters.\n- In your FINAL message, include: changed files, how to test, and any risks/known gaps."

OpenAI Codex v0.98.0 (research preview)
--------
workdir: /Users/johnlindquist/dev/script-kit-gpui
model: gpt-5.3-codex
provider: openai
approval: never
sandbox: danger-full-access
reasoning effort: xhigh
reasoning summaries: auto
session id: 019c3a7e-9f7c-76b0-a795-2407a23a3770
--------
user
You are agent codex-fix-editor-feedback.

Current parallel-agent roster (read this first):
```
SWARM SNAPSHOT @ 2026-02-07T23:45:02.787Z
- codex-fix-ai-feedback [in_progress] scope=src/app_execute/*.rs,src/app_impl/execution_scripts.rs task=MEDIUM FIX: In src/app_execute/builtin_execution.rs, lines 87,634,677,709,752,796 - several AI command failure paths lo…
  claims: src/app_execute/builtin_execution.rs, src/app_impl/execution_scripts.rs
  notes: Claiming builtin execution files and implementing AI error user feedback + NO_MAIN_WINDOW_BUILTINS entries
- codex-fix-editor-feedback [starting] scope=src/app_actions/*.rs task=MEDIUM FIX: edit_script / edit_scriptlet launch failures are log-only. In src/app_actions/handle_action.rs - if launchi…
- codex-fix-notes-feedback [in_progress] scope=src/notes/window/notes_actions.rs,src/notes/window/notes.rs,src/notes/window/panels.rs task=MEDIUM FIX: Silent no-op paths when selected note is missing or stale. In src/notes/window/notes_actions.rs:94,101,121,…
  claims: src/notes/window/notes_actions.rs, src/notes/window/notes.rs, src/notes/window/panels.rs
  notes: Inspecting note actions for stale selected-note early returns; will add user feedback and run check+clippy.
```

Your assignment:
- Task: MEDIUM FIX: edit_script / edit_scriptlet launch failures are log-only. In src/app_actions/handle_action.rs - if launching the editor fails, only a log message is produced. The user sees a success HUD before the async operation completes. Fix: Add error feedback after failed editor launch. Also fix m15: move reveal success HUD to async completion callback. After fix, run cargo check && cargo clippy --all-targets -- -D warnings
- Scope: src/app_actions/*.rs

Operating constraints:
- Single working tree (no worktrees, no patches).
- You MUST claim files before editing (~/.claude/bin/swarm.ts claim --wait ...).

Deliverables:
- Make the code changes required by the task.
- Run the most relevant tests/linters.
- In your FINAL message, include: changed files, how to test, and any risks/known gaps.
warning: Under-development features enabled: responses_websockets. Under-development features are incomplete and may behave unpredictably. To suppress this warning, set `suppress_unstable_features_warning = true` in /Users/johnlindquist/.codex/config.toml.
mcp: deepwiki starting
mcp: deepwiki ready
mcp startup: ready: deepwiki

thinking
**Reconciling verification and commit strategies**
codex
I’m handling the `edit_script` / `edit_scriptlet` feedback fix in `src/app_actions/*.rs`. First I’ll refresh swarm status, claim the target file, then inspect the current action handlers before making a minimal patch.
exec
/bin/zsh -lc '~/.claude/bin/swarm.ts status && git status --short' in /Users/johnlindquist/dev/script-kit-gpui succeeded in 51ms:
Repo: /Users/johnlindquist/dev/script-kit-gpui
Updated: 2026-02-07T23:45:24.652Z

Active agents (3):
codex-fix-ai-feedback [in_progress] codex/gpt-5.3-codex/exec
  task: MEDIUM FIX: In src/app_execute/builtin_execution.rs, lines 87,634,677,709,752,796 - several AI command failure paths lo…
  scope: src/app_execute/*.rs,src/app_impl/execution_scripts.rs
  claims(2): src/app_execute/builtin_execution.rs, src/app_impl/execution_scripts.rs
  notes: Claiming builtin execution files and implementing AI error user feedback + NO_MAIN_WINDOW_BUILTINS entries

codex-fix-editor-feedback [in_progress] codex/gpt-5.3-codex/exec
  task: MEDIUM FIX: edit_script / edit_scriptlet launch failures are log-only. In src/app_actions/handle_action.rs - if launchi…
  scope: src/app_actions/*.rs
  claims: (none)
  notes: spawned codex (exec)

codex-fix-notes-feedback [in_progress] codex/gpt-5.3-codex/exec
  task: MEDIUM FIX: Silent no-op paths when selected note is missing or stale. In src/notes/window/notes_actions.rs:94,101,121,…
  scope: src/notes/window/notes_actions.rs,src/notes/window/notes.rs,src/notes/window/panels.rs
  claims(3): src/notes/window/notes_actions.rs, src/notes/window/notes.rs, src/notes/window/panels.rs

thinking
**Adjusting handling for parallel changes**
codex
I confirmed the tree is heavily dirty from parallel agents, so I’ll isolate to the assigned file only. Next step is claiming `src/app_actions/handle_action.rs` and updating swarm notes before editing.
exec
/bin/zsh -lc '~/.claude/bin/swarm.ts update --id codex-fix-editor-feedback --status in_progress --notes "Claiming handle_action editor launch feedback flow; moving success HUD to async completion"' in /Users/johnlindquist/dev/script-kit-gpui succeeded in 51ms:
Updated: codex-fix-editor-feedback
exec
/bin/zsh -lc '~/.claude/bin/swarm.ts claim --wait --id codex-fix-editor-feedback src/app_actions/handle_action.rs' in /Users/johnlindquist/dev/script-kit-gpui succeeded in 69ms:
Claimed for codex-fix-editor-feedback: src/app_actions/handle_action.rs

thinking
**Scanning for key logic lines**
codex
I’ve claimed the file and am now mapping the `edit_script` / `edit_scriptlet` code paths to move HUD timing and add failure feedback on async launch errors.
exec
/bin/zsh -lc "rg -n \"edit_scriptlet|edit_script|show_hud|launch|open::that|editor\" src/app_actions/handle_action.rs && sed -n '1,260p' src/app_actions/handle_action.rs" in /Users/johnlindquist/dev/script-kit-gpui succeeded in 51ms:
146:                    self.show_hud("No clipboard entry selected".to_string(), Some(2000), cx);
201:                            self.show_hud(message.to_string(), Some(1500), cx);
207:                        self.show_hud(format!("Failed to update pin: {}", e), Some(3000), cx);
214:                    self.show_hud("No clipboard entry selected".to_string(), Some(2000), cx);
219:                    self.show_hud(
255:                    Ok(()) => self.show_hud("Share sheet opened".to_string(), Some(1500), cx),
256:                    Err(message) => self.show_hud(message, Some(2000), cx),
263:                    self.show_hud("No clipboard entry selected".to_string(), Some(2000), cx);
280:                        self.show_hud("Pasted".to_string(), Some(1000), cx);
285:                        self.show_hud(format!("Failed to paste: {}", e), Some(2500), cx);
292:                    self.show_hud("No clipboard entry selected".to_string(), Some(2000), cx);
297:                    self.show_hud(
317:                            self.show_hud("Failed to open AI window".to_string(), Some(2000), cx);
325:                            self.show_hud(
339:                            self.show_hud("Failed to open AI window".to_string(), Some(2000), cx);
346:                self.show_hud("Attached to AI".to_string(), Some(1500), cx);
353:                    self.show_hud("No clipboard entry selected".to_string(), Some(2000), cx);
364:                        self.show_hud("Copied to clipboard".to_string(), Some(1500), cx);
369:                        self.show_hud(format!("Failed to copy: {}", e), Some(2500), cx);
377:                    self.show_hud("No clipboard entry selected".to_string(), Some(2000), cx);

thinking
**Planning targeted code inspection**
exec
/bin/zsh -lc "sed -n '820,1125p' src/app_actions/handle_action.rs" in /Users/johnlindquist/dev/script-kit-gpuiexec
/bin/zsh -lc "sed -n '1880,2005p' src/app_actions/handle_action.rs" in /Users/johnlindquist/dev/script-kit-gpui succeeded in 52ms:
                            if let Some(ref bundle_id) = m.app.bundle_id {
                                Some(format!("app/{}", bundle_id))
                            } else {
                                Some(format!(
                                    "app/{}",
                                    m.app.name.to_lowercase().replace(' ', "-")
                                ))
                            }
                        }
                        scripts::SearchResult::Agent(m) => Some(format!("agent/{}", m.agent.name)),
                        scripts::SearchResult::Window(_) => None,
                        scripts::SearchResult::Fallback(m) => {
                            Some(format!("fallback/{}", m.fallback.name()))
                        }
                    };

                    if let Some(command_id) = command_id_opt {
                        // Remove the alias override from persistence
                        match crate::aliases::remove_alias_override(&command_id) {
                            Ok(()) => {
 succeeded in 50ms:

                // Create snippet entry with proper fence handling
                let fence = if content.contains("```") {
                    "~~~~"
                } else {
                    "```"
                };
                let snippet_entry = format!(
                    "\n## {}\n\n{}\nname: {}\ntool: paste\nkeyword: {}\n{}\n\n{}paste\n{}\n{}\n",
                    keyword, fence, keyword, keyword, fence, fence, content, fence
                );

                // Append to snippets file
                let result = if snippets_file.exists() {
                    std::fs::OpenOptions::new()
                        .append(true)
                        .open(&snippets_file)
                        .and_then(|mut f| {
                            use std::io::Write;
                            f.write_all(snippet_entry.as_bytes())

thinking
**Searching for function definition**
codex
I found both action branches: they call `self.edit_script(...)`, immediately show success-equivalent UX by hiding the window, and never surface async spawn failures. I’m locating the `edit_script` implementation next so I can wire explicit success/failure callbacks.
exec
/bin/zsh -lc "rg -n \"fn edit_script\\(|edit_script\\(\" src/app_actions -g'*.rs'" in /Users/johnlindquist/dev/script-kit-gpui succeeded in 52ms:
src/app_actions/handle_action.rs:629:                            self.edit_script(&m.script.path);
src/app_actions/handle_action.rs:633:                            self.edit_script(&m.agent.path);
src/app_actions/handle_action.rs:674:                                    self.edit_script(&s.script.path);
src/app_actions/handle_action.rs:887:                        self.edit_script(&path);
src/app_actions/handle_action.rs:1935:                            self.edit_script(&path);
src/app_actions/handle_action/main_actions_02.rs:130:                        self.edit_script(&path);
src/app_actions/handle_action/main_actions_05.rs:162:                            self.edit_script(&path);
src/app_actions/handle_action/main_actions_01.rs:203:                            self.edit_script(&m.script.path);
src/app_actions/handle_action/main_actions_01.rs:207:                            self.edit_script(&m.agent.path);
src/app_actions/handle_action/main_actions_01.rs:248:                                    self.edit_script(&s.script.path);

thinking
**Searching function definitions**
exec
/bin/zsh -lc "rg -n \"fn edit_script\\(\" src -g'*.rs'" in /Users/johnlindquist/dev/script-kit-gpui succeeded in 52ms:
src/app_impl/shortcut_recorder.rs:4:    pub(crate) fn edit_script(&mut self, path: &std::path::Path) {

thinking
**Confirming edit scope limits**
exec
/bin/zsh -lc "sed -n '1,240p' src/app_impl/shortcut_recorder.rs" in /Users/johnlindquist/dev/script-kit-gpui succeeded in 51ms:
use super::*;

impl ScriptListApp {
    pub(crate) fn edit_script(&mut self, path: &std::path::Path) {
        let editor = self.config.get_editor();
        logging::log(
            "UI",
            &format!("Opening script in editor '{}': {}", editor, path.display()),
        );
        let path_str = path.to_string_lossy().to_string();

        std::thread::spawn(move || {
            use std::process::Command;
            match Command::new(&editor).arg(&path_str).spawn() {
                Ok(_) => logging::log("UI", &format!("Successfully spawned editor: {}", editor)),
                Err(e) => logging::log(
                    "ERROR",
                    &format!("Failed to spawn editor '{}': {}", editor, e),
                ),
            }

thinking
**Analyzing editor launch error handling and HUD timing**
exec
/bin/zsh -lc "sed -n '420,730p' src/app_actions/handle_action.rs" in /Users/johnlindquist/dev/script-kit-gpui succeeded in 51ms:

        // Only script-list-hosted actions should force a ScriptList transition.
        if should_transition_to_script_list {
            self.transition_to_script_list_after_action(cx);
        }

        match action_id.as_str() {
            "create_script" => {
                logging::log("UI", "Create script action - opening scripts folder");
                let scripts_dir = shellexpand::tilde("~/.scriptkit/scripts").to_string();
                std::thread::spawn(move || {
                    use std::process::Command;
                    match Command::new("open").arg(&scripts_dir).spawn() {
                        Ok(_) => {
                            logging::log("UI", &format!("Opened scripts folder: {}", scripts_dir))
                        }
                        Err(e) => {
                            logging::log("ERROR", &format!("Failed to open scripts folder: {}", e))
                        }
                    }

thinking
**Analyzing concurrency imports**
codex
I’ve confirmed the problematic pattern appears in multiple edit entry points and `reveal_in_finder`: they optimistically hide/show before background result is known. I’m now checking existing async patterns in this file so the fix matches the project style.
exec
/bin/zsh -lc "sed -n '1,160p' src/app_actions/handle_action.rs" in /Users/johnlindquist/dev/script-kit-gpui succeeded in 51ms:
impl ScriptListApp {
    fn hide_main_and_reset(&self, _cx: &mut Context<Self>) {
        if let Some((x, y, w, h)) = platform::get_main_window_bounds() {
            let bounds = crate::window_state::PersistedWindowBounds::new(x, y, w, h);
            let displays = platform::get_macos_displays();
            let _ =
                crate::window_state::save_main_position_with_display_detection(bounds, &displays);
        }
        set_main_window_visible(false);
        NEEDS_RESET.store(true, Ordering::SeqCst);
        // Use platform-specific hide that only hides the main window,
        // not the entire app (cx.hide() would hide HUD too)
        platform::hide_main_window();
    }

    /// Helper to reveal a path in Finder (macOS)
    fn reveal_in_finder(&self, path: &std::path::Path) {
        let path_str = path.to_string_lossy().to_string();
        std::thread::spawn(move || {
            let file_manager = if cfg!(target_os = "macos") {

thinking
**Planning async editor launch feedback**
exec
/bin/zsh -lc "rg -n \"async_channel::bounded|send_blocking|recv\\(\\)\\.await|cx\\.spawn\\(async move \\|this, cx\\|\" src/app_actions/handle_action.rs" in /Users/johnlindquist/dev/script-kit-gpui succeeded in 51ms:
920:                cx.spawn(async move |this, cx| {
921:                    let (confirm_tx, confirm_rx) = async_channel::bounded::<bool>(1);
984:                    let Ok(confirmed) = confirm_rx.recv().await else {
1462:                cx.spawn(async move |this, cx| {
1463:                    let (confirm_tx, confirm_rx) = async_channel::bounded::<bool>(1);
1526:                    let Ok(confirmed) = confirm_rx.recv().await else {
1653:                cx.spawn(async move |this, cx| {
1654:                    let (confirm_tx, confirm_rx) = async_channel::bounded::<bool>(1);
1717:                    let Ok(confirmed) = confirm_rx.recv().await else {

thinking
**Inspecting module imports for channel usage**
exec
/bin/zsh -lc "sed -n '1,220p' src/app_actions/mod.rs" in /Users/johnlindquist/dev/script-kit-gpui exited 1 in 52ms:
sed: src/app_actions/mod.rs: No such file or directory

thinking
**Listing specific directory contents**
exec
/bin/zsh -lc "ls -la src/app_actions && find src/app_actions -maxdepth 2 -type f | sed 's#"'^#- #'"'" in /Users/johnlindquist/dev/script-kit-gpui succeeded in 51ms:
total 280
drwxr-xr-x    8 johnlindquist  staff     256 Feb  7 14:27 .
drwxr-xr-x  145 johnlindquist  staff    4640 Feb  7 16:08 ..
drwxr-xr-x    9 johnlindquist  staff     288 Feb  7 09:35 handle_action
-rw-------    1 johnlindquist  staff  115420 Feb  7 12:00 handle_action.rs
-rw-r--r--    1 johnlindquist  staff   12759 Feb  7 12:01 helpers.rs
-rw-r--r--    1 johnlindquist  staff    3851 Feb  7 09:29 sdk_actions.rs
drwxr-xr-x    5 johnlindquist  staff     160 Feb  7 14:26 tests
-rw-r--r--    1 johnlindquist  staff     232 Feb  7 14:42 tests.rs
- src/app_actions/tests/clipboard_actions.rs
- src/app_actions/tests/clipboard_actions_menu_coverage.rs
- src/app_actions/tests/actions_button_visibility.rs
- src/app_actions/helpers.rs
- src/app_actions/tests.rs
- src/app_actions/handle_action/main_actions_04.rs
- src/app_actions/handle_action/main_actions_01.rs
- src/app_actions/handle_action/main_actions_05.rs
- src/app_actions/handle_action/clipboard_actions.rs
- src/app_actions/handle_action/main_actions_02.rs
- src/app_actions/handle_action/main_actions_06.rs

thinking
**Investigating module usage**
exec
/bin/zsh -lc "rg -n \"mod app_actions|pub mod app_actions|handle_action\" src/main.rs src -g'*.rs' | head -n 80" in /Users/johnlindquist/dev/script-kit-gpui succeeded in 50ms:
src/main.rs:282:// App actions handling (handle_action, trigger_action_by_name)
src/app_actions/handle_action.rs:131:    fn handle_action(&mut self, action_id: String, cx: &mut Context<Self>) {
src/app_actions/handle_action.rs:2243:                // at the start of handle_action()
src/app_actions/handle_action/main_actions_06.rs:161:                // at the start of handle_action()
src/app_actions/helpers.rs:3:// Contains: handle_action, trigger_action_by_name
src/app_actions/helpers.rs:165:mod app_actions_tests {
src/app_actions/tests/actions_button_visibility.rs:9:        let content = fs::read_to_string("src/app_actions/handle_action.rs")
src/app_actions/tests/actions_button_visibility.rs:10:            .expect("Failed to read src/app_actions/handle_action.rs");
src/app_actions/tests/clipboard_actions_menu_coverage.rs:4:// in `ScriptListApp::handle_action`.
src/app_actions/tests/clipboard_actions_menu_coverage.rs:26:        let mut files: Vec<PathBuf> = fs::read_dir("src/app_actions/handle_action")
src/app_actions/tests/clipboard_actions_menu_coverage.rs:27:            .expect("Failed to read src/app_actions/handle_action")
src/app_actions/tests/clipboard_actions_menu_coverage.rs:33:        let mut content = fs::read_to_string("src/app_actions/handle_action.rs")
src/app_actions/tests/clipboard_actions_menu_coverage.rs:34:            .expect("Failed to read src/app_actions/handle_action.rs");
src/tray/part_000.rs:422:    /// This is a pure function with no side effects - use `handle_action()`
src/tray/part_000.rs:435:    pub fn handle_action(&self, action: TrayMenuAction) -> Result<()> {
src/actions_button_visibility_tests.rs:9:        let content = fs::read_to_string("src/app_actions/handle_action.rs")
src/actions_button_visibility_tests.rs:10:            .expect("Failed to read src/app_actions/handle_action.rs");
src/render_script_list/part_000.rs:558:                            this.handle_action("add_shortcut".to_string(), cx);
src/render_script_list/part_000.rs:572:                            this.handle_action("edit_script".to_string(), cx);
src/render_script_list/part_000.rs:578:                            this.handle_action("reveal_in_finder".to_string(), cx);

thinking
**Inspecting main imports**
exec
/bin/zsh -lc "sed -n '1,220p' src/app_actions.rs" in /Users/johnlindquist/dev/script-kit-gpui succeeded in 51ms:
// App actions methods split into sub-files for maintainability
include!("app_actions/helpers.rs");
include!("app_actions/handle_action.rs");
include!("app_actions/sdk_actions.rs");

thinking
**Inspecting module inclusion points**
exec
/bin/zsh -lc "sed -n '240,340p' src/main.rs" in /Users/johnlindquist/dev/script-kit-gpui succeeded in 51ms:
use syntax::highlight_code_lines;

/// Channel for sending prompt messages from script thread to UI
#[allow(dead_code)]
type PromptChannel = (mpsc::Sender<PromptMessage>, mpsc::Receiver<PromptMessage>);

// Import utilities from modules
use stdin_commands::{
    start_stdin_listener, validate_capture_window_output_path, ExternalCommand,
    ExternalCommandEnvelope, KeyModifier,
};
use utils::render_path_with_highlights;

// Global state for hotkey signaling between threads
static NEEDS_RESET: AtomicBool = AtomicBool::new(false); // Track if window needs reset to script list on next show

pub use script_kit_gpui::{is_main_window_visible, set_main_window_visible};
static PANEL_CONFIGURED: AtomicBool = AtomicBool::new(false); // Track if floating panel has been configured (one-time setup on first show)
static SHUTDOWN_REQUESTED: AtomicBool = AtomicBool::new(false); // Track if shutdown signal received (prevents new script spawns)


thinking
**Searching channel usage**
exec
/bin/zsh -lc "rg -n \"use async_channel|async_channel::\" src/main.rs src/main_sections -g'*.rs' | head -n 40" in /Users/johnlindquist/dev/script-kit-gpui succeeded in 51ms:
src/main_sections/app_state.rs:58:    prompt_receiver: Option<async_channel::Receiver<PromptMessage>>,
src/main_sections/app_state.rs:220:    builtin_confirm_sender: async_channel::Sender<(String, bool)>,
src/main_sections/app_state.rs:221:    builtin_confirm_receiver: async_channel::Receiver<(String, bool)>,
src/main_sections/deeplink.rs:4:    async_channel::Sender<String>,
src/main_sections/deeplink.rs:5:    async_channel::Receiver<String>,
src/main_sections/deeplink.rs:10:    async_channel::Sender<String>,
src/main_sections/deeplink.rs:11:    async_channel::Receiver<String>,
src/main_sections/deeplink.rs:13:    DEEPLINK_CHANNEL.get_or_init(|| async_channel::bounded(10))

thinking
**Reviewing helper usage and action handling**
exec
/bin/zsh -lc "sed -n '2200,2285p' src/app_actions/handle_action.rs" in /Users/johnlindquist/dev/script-kit-gpui succeeded in 51ms:
                    if let Some(ref frecency_path) = script_info.frecency_path {
                        // Remove the frecency entry for this item
                        if self.frecency_store.remove(frecency_path).is_some() {
                            // Save the updated frecency store
                            if let Err(e) = self.frecency_store.save() {
                                logging::log(
                                    "ERROR",
                                    &format!("Failed to save frecency after reset: {}", e),
                                );
                            }
                            // Invalidate the grouped cache AND refresh scripts to rebuild the list
                            // This ensures the item is immediately removed from the Suggested section
                            self.invalidate_grouped_cache();
                            self.refresh_scripts(cx);
                            logging::log("UI", &format!("Reset ranking for: {}", script_info.name));
                            self.show_hud(
                                format!("Ranking reset for \"{}\"", script_info.name),
                                Some(2000),
                                cx,
                            );

thinking
**Reviewing action handler end behavior**
exec
/bin/zsh -lc "sed -n '2285,2435p' src/app_actions/handle_action.rs" in /Users/johnlindquist/dev/script-kit-gpui succeeded in 51ms:
                                        .actions
                                        .iter()
                                        .find(|a| a.command == action_command)
                                    {
                                        // Create a scriptlet for executing the action
                                        let action_scriptlet = scriptlets::Scriptlet {
                                            name: action.name.clone(),
                                            command: action.command.clone(),
                                            tool: action.tool.clone(),
                                            scriptlet_content: action.code.clone(),
                                            inputs: action.inputs.clone(),
                                            group: full_scriptlet.group.clone(),
                                            preview: None,
                                            metadata: scriptlets::ScriptletMetadata {
                                                shortcut: action.shortcut.clone(),
                                                description: action.description.clone(),
                                                ..Default::default()
                                            },
                                            typed_metadata: None,
                                            schema: None,

thinking
**Designing async editor launch with feedback**
exec
/bin/zsh -lc "rg -n \"reveal_in_finder\\(\" src -g'*.rs'" in /Users/johnlindquist/dev/script-kit-gpui succeeded in 52ms:
src/app_actions/handle_action.rs:17:    fn reveal_in_finder(&self, path: &std::path::Path) {
src/app_actions/handle_action.rs:28:            match crate::file_search::reveal_in_finder(&path_str) {
src/app_actions/handle_action.rs:474:                    self.reveal_in_finder(&path);
src/app_actions/handle_action.rs:1815:                        self.reveal_in_finder(&save_path);
src/app_actions/handle_action.rs:1967:                            self.reveal_in_finder(path);
src/app_actions/handle_action/main_actions_05.rs:42:                        self.reveal_in_finder(&save_path);
src/app_actions/handle_action/main_actions_05.rs:194:                            self.reveal_in_finder(path);
src/app_actions/handle_action/main_actions_01.rs:48:                    self.reveal_in_finder(&path);
src/file_search/part_001.rs:441:pub fn reveal_in_finder(path: &str) -> Result<(), String> {
src/render_builtins/file_search_setup_key.rs:155:                                    let _ = file_search::reveal_in_finder(&file.path);
src/render_builtins/file_search.rs:163:                                    let _ = file_search::reveal_in_finder(&file.path);
src/actions/dialog_builtin_action_validation_tests_32/part_01.rs:277:fn batch32_file_reveal_desc_says_reveal_in_finder() {
src/actions/dialog_builtin_action_validation_tests_34/part_01.rs:220:fn file_reveal_desc_says_reveal_in_finder() {
src/actions/dialog_builtin_action_validation_tests_34/part_03.rs:187:fn agent_has_reveal_in_finder() {
src/actions/dialog_builtin_action_validation_tests_30/part_04.rs:3:fn batch30_agent_has_reveal_in_finder() {
src/app_impl/execution_paths.rs:201:                match crate::file_search::reveal_in_finder(&path_info.path) {
src/app_impl/webcam_actions.rs:171:                self.reveal_in_finder(&save_path);
src/actions/dialog_builtin_action_validation_tests_39/tests_part_02.rs:34:    fn file_context_both_have_reveal_in_finder() {
src/actions/dialog_builtin_action_validation_tests_39/tests_part_02.rs:297:    fn agent_context_has_reveal_in_finder() {
src/actions/dialog_builtin_action_validation_tests_22/part_03.rs:148:fn batch22_file_context_always_has_reveal_in_finder() {

thinking
**Assessing method signature change impact**
exec
/bin/zsh -lc "sed -n '1768,1838p' src/app_actions/handle_action.rs" in /Users/johnlindquist/dev/script-kit-gpui succeeded in 51ms:
                    .ok();
                })
                .detach();
                return;
            }

            "clipboard_save_file" => {
                let Some(entry) = selected_clipboard_entry.clone() else {
                    self.show_hud("No clipboard entry selected".to_string(), Some(2000), cx);
                    return;
                };

                let Some(content) = clipboard_history::get_entry_content(&entry.id) else {
                    self.show_hud("Clipboard content unavailable".to_string(), Some(2000), cx);
                    return;
                };

                // Determine filename and content based on type
                let (file_content, extension) = match entry.content_type {
                    clipboard_history::ContentType::Text => (content.into_bytes(), "txt"),

thinking
**Inspecting existing test patterns**
codex
I’m implementing this as local helpers inside `handle_action.rs` so we don’t need cross-module signature changes. After patching, I’ll add a focused regression test under `src/app_actions/tests` that checks the new async feedback wiring.
exec
/bin/zsh -lc "sed -n '1,200p' src/app_actions/tests.rs" in /Users/johnlindquist/dev/script-kit-gpuiexec
/bin/zsh -lc "sed -n '1,260p' src/app_actions/tests/actions_button_visibility.rs" in /Users/johnlindquist/dev/script-kit-gpuiexec
/bin/zsh -lc "sed -n '1,260p' src/app_actions/tests/clipboard_actions_menu_coverage.rs" in /Users/johnlindquist/dev/script-kit-gpuiexec
/bin/zsh -lc "sed -n '1,260p' src/app_actions/tests/clipboard_actions.rs" in /Users/johnlindquist/dev/script-kit-gpui succeeded in 51ms:
// Regression tests for actions button visibility in the main script list.

#[cfg(test)]
mod tests {
    use std::fs;

    #[test]
    fn test_has_actions_helper_exists_and_handles_clipboard() {
        let content = fs::read_to_string("src/app_actions/handle_action.rs")
            .expect("Failed to read src/app_actions/handle_action.rs");

        assert!(
            content.contains("fn has_actions"),
            "Expected ScriptListApp::has_actions() helper to exist"
        );

        assert!(
            content.contains("ClipboardHistoryView"),
            "has_actions() should account for ClipboardHistoryView selection"
        );
 succeeded in 51ms:
#[path = "tests/actions_button_visibility.rs"]
mod actions_button_visibility;

#[path = "tests/clipboard_actions.rs"]
mod clipboard_actions;

#[path = "tests/clipboard_actions_menu_coverage.rs"]
mod clipboard_actions_menu_coverage;
 succeeded in 52ms:
// Targeted regression tests for destructive clipboard action safeguards.

use std::fs;

fn read(path: &str) -> String {
    fs::read_to_string(path).unwrap_or_else(|_| panic!("Failed to read {path}"))
}

#[test]
fn clipboard_delete_multiple_requires_confirmation_before_delete() {
    let content = read("src/app_actions.rs");

    assert!(
        content.contains("\"clipboard_delete_multiple\""),
        "Expected app_actions.rs to handle clipboard_delete_multiple"
    );
    assert!(
        content.contains("Are you sure you want to delete these")
            && content.contains("matching clipboard entries"),
        "Expected clipboard_delete_multiple to show a count-aware confirmation message"
 succeeded in 52ms:
// Regression tests for clipboard actions menu handler coverage.
//
// Ensures every clipboard action ID exposed in the actions menu has a handler
// in `ScriptListApp::handle_action`.

#[cfg(test)]
mod tests {
    use std::collections::BTreeSet;
    use std::fs;
    use std::path::PathBuf;

    fn clipboard_builder_ids() -> BTreeSet<String> {
        let region = fs::read_to_string("src/actions/builders/clipboard.rs")
            .expect("Failed to read src/actions/builders/clipboard.rs");

        let mut ids = BTreeSet::new();
        let re = regex::Regex::new(r#"Action::new\(\s*"(clipboard_[a-z0-9_]+)""#)
            .expect("regex compile failed");
        for cap in re.captures_iter(&region) {
            ids.insert(cap[1].to_string());

thinking
**Planning multi-file claims**
codex
I’m ready to patch `handle_action.rs` and add a small regression test file. I’ll claim `src/app_actions/tests.rs` and the new test path before editing.
exec
/bin/zsh -lc '~/.claude/bin/swarm.ts update --id codex-fix-editor-feedback --status in_progress --notes "Implementing async editor/reveal feedback in handle_action + regression test"' in /Users/johnlindquist/dev/script-kit-gpui succeeded in 51ms:
Updated: codex-fix-editor-feedback
exec
/bin/zsh -lc '~/.claude/bin/swarm.ts claim --wait --id codex-fix-editor-feedback src/app_actions/tests.rs src/app_actions/tests/editor_launch_feedback.rs' in /Users/johnlindquist/dev/script-kit-gpui succeeded in 103ms:
Claimed for codex-fix-editor-feedback: src/app_actions/tests.rs, src/app_actions/tests/editor_launch_feedback.rs

thinking
**Designing async editor/reveal helpers**
exec
/bin/zsh -lc 'rg -n "''^name'"\\s*=\\s*\\\"\" Cargo.toml | head -n 5" in /Users/johnlindquist/dev/script-kit-gpui succeeded in 51ms:
2:name = "script-kit-gpui"
8:name = "script_kit_gpui"
12:name = "script-kit-gpui"
17:name = "smoke-test"
22:name = "storybook"

thinking
**Inspecting workspace root**
exec
/bin/zsh -lc "sed -n '1,120p' Cargo.toml" in /Users/johnlindquist/dev/script-kit-gpui succeeded in 52ms:
[package]
name = "script-kit-gpui"
version = "0.1.0"
edition = "2021"
default-run = "script-kit-gpui"

[lib]
name = "script_kit_gpui"
path = "src/lib.rs"

[[bin]]
name = "script-kit-gpui"
path = "src/main.rs"
test = false  # Tests run via lib.rs only - avoids duplicate test runs

[[bin]]
name = "smoke-test"
path = "src/bin/smoke-test.rs"
test = false


thinking
**Planning async editor launch patch**
codex
I’m patching `handle_action.rs` now with two async helpers and wiring `edit_script`, `edit_scriptlet`, and reveal actions to display HUDs only after background completion (with error HUD on failure).
file update
M /Users/johnlindquist/dev/script-kit-gpui/src/app_actions/handle_action.rs
@@ -34,2 +34,105 @@
 
+    /// Reveal a path and return completion back to the UI thread for HUD feedback.
+    fn reveal_in_finder_with_feedback_async(
+        &self,
+        path: &std::path::Path,
+    ) -> async_channel::Receiver<Result<(), String>> {
+        let path_str = path.to_string_lossy().to_string();
+        let (result_tx, result_rx) = async_channel::bounded::<Result<(), String>>(1);
+
+        std::thread::spawn(move || {
+            let file_manager = if cfg!(target_os = "macos") {
+                "Finder"
+            } else if cfg!(target_os = "windows") {
+                "Explorer"
+            } else {
+                "File Manager"
+            };
+
+            logging::log(
+                "UI",
+                &format!(
+                    "ACTION_REVEAL_IN_FINDER_START file_manager='{}' path='{}'",
+                    file_manager, path_str
+                ),
+            );
+
+            let reveal_result = match crate::file_search::reveal_in_finder(&path_str) {
+                Ok(()) => {
+                    logging::log(
+                        "UI",
+                        &format!(
+                            "ACTION_REVEAL_IN_FINDER_SUCCESS file_manager='{}' path='{}'",
+                            file_manager, path_str
+                        ),
+                    );
+                    Ok(())
+                }
+                Err(error) => {
+                    logging::log(
+                        "ERROR",
+                        &format!(
+                            "ACTION_REVEAL_IN_FINDER_FAILED attempted='reveal_in_finder' path='{}' file_manager='{}' error='{}'",
+                            path_str, file_manager, error
+                        ),
+                    );
+                    Err(format!("Failed to reveal in {}: {}", file_manager, error))
+                }
+            };
+
+            let _ = result_tx.send_blocking(reveal_result);
+        });
+
+        result_rx
+    }
+
+    /// Launch the configured editor and return completion back to the UI thread for HUD feedback.
+    fn launch_editor_with_feedback_async(
+        &self,
+        path: &std::path::Path,
+    ) -> async_channel::Receiver<Result<(), String>> {
+        let editor = self.config.get_editor();
+        let path_str = path.to_string_lossy().to_string();
+        let (result_tx, result_rx) = async_channel::bounded::<Result<(), String>>(1);
+
+        std::thread::spawn(move || {
+            use std::process::Command;
+
+            logging::log(
+                "UI",
+                &format!(
+                    "ACTION_EDITOR_LAUNCH_START editor='{}' path='{}'",
+                    editor, path_str
+                ),
+            );
+
+            let launch_result = match Command::new(&editor).arg(&path_str).spawn() {
+                Ok(_) => {
+                    logging::log(
+                        "UI",
+                        &format!(
+                            "ACTION_EDITOR_LAUNCH_SUCCESS editor='{}' path='{}'",
+                            editor, path_str
+                        ),
+                    );
+                    Ok(())
+                }
+                Err(error) => {
+                    logging::log(
+                        "ERROR",
+                        &format!(
+                            "ACTION_EDITOR_LAUNCH_FAILED attempted='{} {}' path='{}' error='{}'",
+                            editor, path_str, path_str, error
+                        ),
+                    );
+                    Err(format!("Failed to open in {}: {}", editor, error))
+                }
+            };
+
+            let _ = result_tx.send_blocking(launch_result);
+        });
+
+        result_rx
+    }
+
     /// Copy text to clipboard using pbcopy on macOS.
@@ -473,5 +576,20 @@
                 if let Some(path) = path_opt {
-                    self.reveal_in_finder(&path);
-                    self.show_hud("Opened in Finder".to_string(), Some(1500), cx);
-                    self.hide_main_and_reset(cx);
+                    let reveal_result_rx = self.reveal_in_finder_with_feedback_async(&path);
+                    cx.spawn(async move |this, cx| {
+                        let Ok(reveal_result) = reveal_result_rx.recv().await else {
+                            return;
+                        };
+
+                        this.update(cx, |this, cx| match reveal_result {
+                            Ok(()) => {
+                                this.show_hud("Opened in Finder".to_string(), Some(1500), cx);
+                                this.hide_main_and_reset(cx);
+                            }
+                            Err(message) => {
+                                this.show_hud(message, Some(2500), cx);
+                            }
+                        })
+                        .ok();
+                    })
+                    .detach();
                 } else {
@@ -886,4 +1004,19 @@
                     if let Some(path) = path_opt {
-                        self.edit_script(&path);
-                        self.hide_main_and_reset(cx);
+                        let editor_launch_rx = self.launch_editor_with_feedback_async(&path);
+                        cx.spawn(async move |this, cx| {
+                            let Ok(launch_result) = editor_launch_rx.recv().await else {
+                                return;
+                            };
+
+                            this.update(cx, |this, cx| match launch_result {
+                                Ok(()) => {
+                                    this.hide_main_and_reset(cx);
+                                }
+                                Err(message) => {
+                                    this.show_hud(message, Some(3000), cx);
+                                }
+                            })
+                            .ok();
+                        })
+                        .detach();
                     } else {
@@ -1934,4 +2067,19 @@
                             let path = std::path::PathBuf::from(path_str);
-                            self.edit_script(&path);
-                            self.hide_main_and_reset(cx);
+                            let editor_launch_rx = self.launch_editor_with_feedback_async(&path);
+                            cx.spawn(async move |this, cx| {
+                                let Ok(launch_result) = editor_launch_rx.recv().await else {
+                                    return;
+                                };
+
+                                this.update(cx, |this, cx| match launch_result {
+                                    Ok(()) => {
+                                        this.hide_main_and_reset(cx);
+                                    }
+                                    Err(message) => {
+                                        this.show_hud(message, Some(3000), cx);
+                                    }
+                                })
+                                .ok();
+                            })
+                            .detach();
                         } else {
@@ -1966,5 +2114,20 @@
                             let path = std::path::Path::new(path_str);
-                            self.reveal_in_finder(path);
-                            self.show_hud("Opened in Finder".to_string(), Some(1500), cx);
-                            self.hide_main_and_reset(cx);
+                            let reveal_result_rx = self.reveal_in_finder_with_feedback_async(path);
+                            cx.spawn(async move |this, cx| {
+                                let Ok(reveal_result) = reveal_result_rx.recv().await else {
+                                    return;
+                                };
+
+                                this.update(cx, |this, cx| match reveal_result {
+                                    Ok(()) => {
+                                        this.show_hud("Opened in Finder".to_string(), Some(1500), cx);
+                                        this.hide_main_and_reset(cx);
+                                    }
+                                    Err(message) => {
+                                        this.show_hud(message, Some(2500), cx);
+                                    }
+                                })
+                                .ok();
+                            })
+                            .detach();
                         } else {
apply_patch(auto_approved=true) exited 0 in 14ms:
Success. Updated the following files:
M /Users/johnlindquist/dev/script-kit-gpui/src/app_actions/handle_action.rs
file update:
diff --git a/src/app_actions/handle_action.rs b/src/app_actions/handle_action.rs
index 6512e920f98eb38811debb5dca005d821b3adb44..dda46dd268dc9fe3130c27b221485ba871f1c703
--- a/src/app_actions/handle_action.rs
+++ b/src/app_actions/handle_action.rs
@@ -32,6 +32,109 @@
         });
     }
 
+    /// Reveal a path and return completion back to the UI thread for HUD feedback.
+    fn reveal_in_finder_with_feedback_async(
+        &self,
+        path: &std::path::Path,
+    ) -> async_channel::Receiver<Result<(), String>> {
+        let path_str = path.to_string_lossy().to_string();
+        let (result_tx, result_rx) = async_channel::bounded::<Result<(), String>>(1);
+
+        std::thread::spawn(move || {
+            let file_manager = if cfg!(target_os = "macos") {
+                "Finder"
+            } else if cfg!(target_os = "windows") {
+                "Explorer"
+            } else {
+                "File Manager"
+            };
+
+            logging::log(
+                "UI",
+                &format!(
+                    "ACTION_REVEAL_IN_FINDER_START file_manager='{}' path='{}'",
+                    file_manager, path_str
+                ),
+            );
+
+            let reveal_result = match crate::file_search::reveal_in_finder(&path_str) {
+                Ok(()) => {
+                    logging::log(
+                        "UI",
+                        &format!(
+                            "ACTION_REVEAL_IN_FINDER_SUCCESS file_manager='{}' path='{}'",
+                            file_manager, path_str
+                        ),
+                    );
+                    Ok(())
+                }
+                Err(error) => {
+                    logging::log(
+                        "ERROR",
+                        &format!(
+                            "ACTION_REVEAL_IN_FINDER_FAILED attempted='reveal_in_finder' path='{}' file_manager='{}' error='{}'",
+                            path_str, file_manager, error
+                        ),
+                    );
+                    Err(format!("Failed to reveal in {}: {}", file_manager, error))
+                }
+            };
+
+            let _ = result_tx.send_blocking(reveal_result);
+        });
+
+        result_rx
+    }
+
+    /// Launch the configured editor and return completion back to the UI thread for HUD feedback.
+    fn launch_editor_with_feedback_async(
+        &self,
+        path: &std::path::Path,
+    ) -> async_channel::Receiver<Result<(), String>> {
+        let editor = self.config.get_editor();
+        let path_str = path.to_string_lossy().to_string();
+        let (result_tx, result_rx) = async_channel::bounded::<Result<(), String>>(1);
+
+        std::thread::spawn(move || {
+            use std::process::Command;
+
+            logging::log(
+                "UI",
+                &format!(
+                    "ACTION_EDITOR_LAUNCH_START editor='{}' path='{}'",
+                    editor, path_str
+                ),
+            );
+
+            let launch_result = match Command::new(&editor).arg(&path_str).spawn() {
+                Ok(_) => {
+                    logging::log(
+                        "UI",
+                        &format!(
+                            "ACTION_EDITOR_LAUNCH_SUCCESS editor='{}' path='{}'",
+                            editor, path_str
+                        ),
+                    );
+                    Ok(())
+                }
+                Err(error) => {
+                    logging::log(
+                        "ERROR",
+                        &format!(
+                            "ACTION_EDITOR_LAUNCH_FAILED attempted='{} {}' path='{}' error='{}'",
+                            editor, path_str, path_str, error
+                        ),
+                    );
+                    Err(format!("Failed to open in {}: {}", editor, error))
+                }
+            };
+
+            let _ = result_tx.send_blocking(launch_result);
+        });
+
+        result_rx
+    }
+
     /// Copy text to clipboard using pbcopy on macOS.
     /// Critical: This properly closes stdin before waiting to prevent hangs.
     #[cfg(target_os = "macos")]
@@ -471,9 +574,24 @@
                 };
 
                 if let Some(path) = path_opt {
-                    self.reveal_in_finder(&path);
-                    self.show_hud("Opened in Finder".to_string(), Some(1500), cx);
-                    self.hide_main_and_reset(cx);
+                    let reveal_result_rx = self.reveal_in_finder_with_feedback_async(&path);
+                    cx.spawn(async move |this, cx| {
+                        let Ok(reveal_result) = reveal_result_rx.recv().await else {
+                            return;
+                        };
+
+                        this.update(cx, |this, cx| match reveal_result {
+                            Ok(()) => {
+                                this.show_hud("Opened in Finder".to_string(), Some(1500), cx);
+                                this.hide_main_and_reset(cx);
+                            }
+                            Err(message) => {
+                                this.show_hud(message, Some(2500), cx);
+                            }
+                        })
+                        .ok();
+                    })
+                    .detach();
                 } else {
                     self.show_hud(
                         "Cannot reveal this item type in Finder".to_string(),
@@ -884,8 +1002,23 @@
                     };
 
                     if let Some(path) = path_opt {
-                        self.edit_script(&path);
-                        self.hide_main_and_reset(cx);
+                        let editor_launch_rx = self.launch_editor_with_feedback_async(&path);
+                        cx.spawn(async move |this, cx| {
+                            let Ok(launch_result) = editor_launch_rx.recv().await else {
+                                return;
+                            };
+
+                            this.update(cx, |this, cx| match launch_result {
+                                Ok(()) => {
+                                    this.hide_main_and_reset(cx);
+                                }
+                                Err(message) => {
+                                    this.show_hud(message, Some(3000), cx);
+                                }
+                            })
+                            .ok();
+                        })
+                        .detach();
                     } else {
                         self.show_hud("Cannot edit this item type".to_string(), Some(2000), cx);
                     }
@@ -1932,8 +2065,23 @@
                             // Extract just the path without the anchor (e.g., "/path/to/file.md#slug" -> "/path/to/file.md")
                             let path_str = file_path.split('#').next().unwrap_or(file_path);
                             let path = std::path::PathBuf::from(path_str);
-                            self.edit_script(&path);
-                            self.hide_main_and_reset(cx);
+                            let editor_launch_rx = self.launch_editor_with_feedback_async(&path);
+                            cx.spawn(async move |this, cx| {
+                                let Ok(launch_result) = editor_launch_rx.recv().await else {
+                                    return;
+                                };
+
+                                this.update(cx, |this, cx| match launch_result {
+                                    Ok(()) => {
+                                        this.hide_main_and_reset(cx);
+                                    }
+                                    Err(message) => {
+                                        this.show_hud(message, Some(3000), cx);
+                                    }
+                                })
+                                .ok();
+                            })
+                            .detach();
                         } else {
                             self.show_hud(
                                 "Scriptlet has no source file path".to_string(),
@@ -1964,9 +2112,24 @@
                             // Extract just the path without the anchor
                             let path_str = file_path.split('#').next().unwrap_or(file_path);
                             let path = std::path::Path::new(path_str);
-                            self.reveal_in_finder(path);
-                            self.show_hud("Opened in Finder".to_string(), Some(1500), cx);
-                            self.hide_main_and_reset(cx);
+                            let reveal_result_rx = self.reveal_in_finder_with_feedback_async(path);
+                            cx.spawn(async move |this, cx| {
+                                let Ok(reveal_result) = reveal_result_rx.recv().await else {
+                                    return;
+                                };
+
+                                this.update(cx, |this, cx| match reveal_result {
+                                    Ok(()) => {
+                                        this.show_hud("Opened in Finder".to_string(), Some(1500), cx);
+                                        this.hide_main_and_reset(cx);
+                                    }
+                                    Err(message) => {
+                                        this.show_hud(message, Some(2500), cx);
+                                    }
+                                })
+                                .ok();
+                            })
+                            .detach();
                         } else {
                             self.show_hud(
                                 "Scriptlet has no source file path".to_string(),

file update:
diff --git a/src/app_actions/handle_action.rs b/src/app_actions/handle_action.rs
index 6512e920f98eb38811debb5dca005d821b3adb44..dda46dd268dc9fe3130c27b221485ba871f1c703
--- a/src/app_actions/handle_action.rs
+++ b/src/app_actions/handle_action.rs
@@ -32,6 +32,109 @@
         });
     }
 
+    /// Reveal a path and return completion back to the UI thread for HUD feedback.
+    fn reveal_in_finder_with_feedback_async(
+        &self,
+        path: &std::path::Path,
+    ) -> async_channel::Receiver<Result<(), String>> {
+        let path_str = path.to_string_lossy().to_string();
+        let (result_tx, result_rx) = async_channel::bounded::<Result<(), String>>(1);
+
+        std::thread::spawn(move || {
+            let file_manager = if cfg!(target_os = "macos") {
+                "Finder"
+            } else if cfg!(target_os = "windows") {
+                "Explorer"
+            } else {
+                "File Manager"
+            };
+
+            logging::log(
+                "UI",
+                &format!(
+                    "ACTION_REVEAL_IN_FINDER_START file_manager='{}' path='{}'",
+                    file_manager, path_str
+                ),
+            );
+
+            let reveal_result = match crate::file_search::reveal_in_finder(&path_str) {
+                Ok(()) => {
+                    logging::log(
+                        "UI",
+                        &format!(
+                            "ACTION_REVEAL_IN_FINDER_SUCCESS file_manager='{}' path='{}'",
+                            file_manager, path_str
+                        ),
+                    );
+                    Ok(())
+                }
+                Err(error) => {
+                    logging::log(
+                        "ERROR",
+                        &format!(
+                            "ACTION_REVEAL_IN_FINDER_FAILED attempted='reveal_in_finder' path='{}' file_manager='{}' error='{}'",
+                            path_str, file_manager, error
+                        ),
+                    );
+                    Err(format!("Failed to reveal in {}: {}", file_manager, error))
+                }
+            };
+
+            let _ = result_tx.send_blocking(reveal_result);
+        });
+
+        result_rx
+    }
+
+    /// Launch the configured editor and return completion back to the UI thread for HUD feedback.
+    fn launch_editor_with_feedback_async(
+        &self,
+        path: &std::path::Path,
+    ) -> async_channel::Receiver<Result<(), String>> {
+        let editor = self.config.get_editor();
+        let path_str = path.to_string_lossy().to_string();
+        let (result_tx, result_rx) = async_channel::bounded::<Result<(), String>>(1);
+
+        std::thread::spawn(move || {
+            use std::process::Command;
+
+            logging::log(
+                "UI",
+                &format!(
+                    "ACTION_EDITOR_LAUNCH_START editor='{}' path='{}'",
+                    editor, path_str
+                ),
+            );
+
+            let launch_result = match Command::new(&editor).arg(&path_str).spawn() {
+                Ok(_) => {
+                    logging::log(
+                        "UI",
+                        &format!(
+                            "ACTION_EDITOR_LAUNCH_SUCCESS editor='{}' path='{}'",
+                            editor, path_str
+                        ),
+                    );
+                    Ok(())
+                }
+                Err(error) => {
+                    logging::log(
+                        "ERROR",
+                        &format!(
+                            "ACTION_EDITOR_LAUNCH_FAILED attempted='{} {}' path='{}' error='{}'",
+                            editor, path_str, path_str, error
+                        ),
+                    );
+                    Err(format!("Failed to open in {}: {}", editor, error))
+                }
+            };
+
+            let _ = result_tx.send_blocking(launch_result);
+        });
+
+        result_rx
+    }
+
     /// Copy text to clipboard using pbcopy on macOS.
     /// Critical: This properly closes stdin before waiting to prevent hangs.
     #[cfg(target_os = "macos")]
@@ -471,9 +574,24 @@
                 };
 
                 if let Some(path) = path_opt {
-                    self.reveal_in_finder(&path);
-                    self.show_hud("Opened in Finder".to_string(), Some(1500), cx);
-                    self.hide_main_and_reset(cx);
+                    let reveal_result_rx = self.reveal_in_finder_with_feedback_async(&path);
+                    cx.spawn(async move |this, cx| {
+                        let Ok(reveal_result) = reveal_result_rx.recv().await else {
+                            return;
+                        };
+
+                        this.update(cx, |this, cx| match reveal_result {
+                            Ok(()) => {
+                                this.show_hud("Opened in Finder".to_string(), Some(1500), cx);
+                                this.hide_main_and_reset(cx);
+                            }
+                            Err(message) => {
+                                this.show_hud(message, Some(2500), cx);
+                            }
+                        })
+                        .ok();
+                    })
+                    .detach();
                 } else {
                     self.show_hud(
                         "Cannot reveal this item type in Finder".to_string(),
@@ -884,8 +1002,23 @@
                     };
 
                     if let Some(path) = path_opt {
-                        self.edit_script(&path);
-                        self.hide_main_and_reset(cx);
+                        let editor_launch_rx = self.launch_editor_with_feedback_async(&path);
+                        cx.spawn(async move |this, cx| {
+                            let Ok(launch_result) = editor_launch_rx.recv().await else {
+                                return;
+                            };
+
+                            this.update(cx, |this, cx| match launch_result {
+                                Ok(()) => {
+                                    this.hide_main_and_reset(cx);
+                                }
+                                Err(message) => {
+                                    this.show_hud(message, Some(3000), cx);
+                                }
+                            })
+                            .ok();
+                        })
+                        .detach();
                     } else {
                         self.show_hud("Cannot edit this item type".to_string(), Some(2000), cx);
                     }
@@ -1932,8 +2065,23 @@
                             // Extract just the path without the anchor (e.g., "/path/to/file.md#slug" -> "/path/to/file.md")
                             let path_str = file_path.split('#').next().unwrap_or(file_path);
                             let path = std::path::PathBuf::from(path_str);
-                            self.edit_script(&path);
-                            self.hide_main_and_reset(cx);
+                            let editor_launch_rx = self.launch_editor_with_feedback_async(&path);
+                            cx.spawn(async move |this, cx| {
+                                let Ok(launch_result) = editor_launch_rx.recv().await else {
+                                    return;
+                                };
+
+                                this.update(cx, |this, cx| match launch_result {
+                                    Ok(()) => {
+                                        this.hide_main_and_reset(cx);
+                                    }
+                                    Err(message) => {
+                                        this.show_hud(message, Some(3000), cx);
+                                    }
+                                })
+                                .ok();
+                            })
+                            .detach();
                         } else {
                             self.show_hud(
                                 "Scriptlet has no source file path".to_string(),
@@ -1964,9 +2112,24 @@
                             // Extract just the path without the anchor
                             let path_str = file_path.split('#').next().unwrap_or(file_path);
                             let path = std::path::Path::new(path_str);
-                            self.reveal_in_finder(path);
-                            self.show_hud("Opened in Finder".to_string(), Some(1500), cx);
-                            self.hide_main_and_reset(cx);
+                            let reveal_result_rx = self.reveal_in_finder_with_feedback_async(path);
+                            cx.spawn(async move |this, cx| {
+                                let Ok(reveal_result) = reveal_result_rx.recv().await else {
+                                    return;
+                                };
+
+                                this.update(cx, |this, cx| match reveal_result {
+                                    Ok(()) => {
+                                        this.show_hud("Opened in Finder".to_string(), Some(1500), cx);
+                                        this.hide_main_and_reset(cx);
+                                    }
+                                    Err(message) => {
+                                        this.show_hud(message, Some(2500), cx);
+                                    }
+                                })
+                                .ok();
+                            })
+                            .detach();
                         } else {
                             self.show_hud(
                                 "Scriptlet has no source file path".to_string(),


thinking
**Considering selective rustfmt usage**
exec
/bin/zsh -lc "rg -n \"launch_editor_with_feedback_async|reveal_in_finder_with_feedback_async|ACTION_EDITOR_LAUNCH|ACTION_REVEAL_IN_FINDER|\\\"edit_script\\\" =>|\\\"edit_scriptlet\\\" =>|\\\"reveal_in_finder\\\" =>|\\\"reveal_scriptlet_in_finder\\\" =>\" src/app_actions/handle_action.rs && sed -n '1,150p' src/app_actions/handle_action.rs && sed -n '450,530p' src/app_actions/handle_action.rs && sed -n '940,1035p' src/app_actions/handle_action.rs && sed -n '1985,2075p' src/app_actions/handle_action.rs" in /Users/johnlindquist/dev/script-kit-gpui succeeded in 51ms:
36:    fn reveal_in_finder_with_feedback_async(
55:                    "ACTION_REVEAL_IN_FINDER_START file_manager='{}' path='{}'",
65:                            "ACTION_REVEAL_IN_FINDER_SUCCESS file_manager='{}' path='{}'",
75:                            "ACTION_REVEAL_IN_FINDER_FAILED attempted='reveal_in_finder' path='{}' file_manager='{}' error='{}'",
90:    fn launch_editor_with_feedback_async(
104:                    "ACTION_EDITOR_LAUNCH_START editor='{}' path='{}'",
114:                            "ACTION_EDITOR_LAUNCH_SUCCESS editor='{}' path='{}'",
124:                            "ACTION_EDITOR_LAUNCH_FAILED attempted='{} {}' path='{}' error='{}'",
555:            "reveal_in_finder" => {
577:                    let reveal_result_rx = self.reveal_in_finder_with_feedback_async(&path);
991:            "edit_script" => {
1005:                        let editor_launch_rx = self.launch_editor_with_feedback_async(&path);
2060:            "edit_scriptlet" => {
2068:                            let editor_launch_rx = self.launch_editor_with_feedback_async(&path);
2107:            "reveal_scriptlet_in_finder" => {
2115:                            let reveal_result_rx = self.reveal_in_finder_with_feedback_async(path);
impl ScriptListApp {
    fn hide_main_and_reset(&self, _cx: &mut Context<Self>) {
        if let Some((x, y, w, h)) = platform::get_main_window_bounds() {
            let bounds = crate::window_state::PersistedWindowBounds::new(x, y, w, h);
file update:
diff --git a/src/app_actions/handle_action.rs b/src/app_actions/handle_action.rs
index 6512e920f98eb38811debb5dca005d821b3adb44..dda46dd268dc9fe3130c27b221485ba871f1c703
--- a/src/app_actions/handle_action.rs
+++ b/src/app_actions/handle_action.rs
@@ -32,6 +32,109 @@
         });
     }
 
+    /// Reveal a path and return completion back to the UI thread for HUD feedback.
+    fn reveal_in_finder_with_feedback_async(
+        &self,
+        path: &std::path::Path,
+    ) -> async_channel::Receiver<Result<(), String>> {
+        let path_str = path.to_string_lossy().to_string();
+        let (result_tx, result_rx) = async_channel::bounded::<Result<(), String>>(1);
+
+        std::thread::spawn(move || {
+            let file_manager = if cfg!(target_os = "macos") {
+                "Finder"
+            } else if cfg!(target_os = "windows") {
+                "Explorer"
+            } else {
+                "File Manager"
+            };
+
+            logging::log(
+                "UI",
+                &format!(
+                    "ACTION_REVEAL_IN_FINDER_START file_manager='{}' path='{}'",
+                    file_manager, path_str
+                ),
+            );
+
+            let reveal_result = match crate::file_search::reveal_in_finder(&path_str) {
+                Ok(()) => {
+                    logging::log(
+                        "UI",
+                        &format!(
+                            "ACTION_REVEAL_IN_FINDER_SUCCESS file_manager='{}' path='{}'",
+                            file_manager, path_str
+                        ),
+                    );
+                    Ok(())
+                }
+                Err(error) => {
+                    logging::log(
+                        "ERROR",
+                        &format!(
+                            "ACTION_REVEAL_IN_FINDER_FAILED attempted='reveal_in_finder' path='{}' file_manager='{}' error='{}'",
+                            path_str, file_manager, error
+                        ),
+                    );
+                    Err(format!("Failed to reveal in {}: {}", file_manager, error))
+                }
+            };
+
+            let _ = result_tx.send_blocking(reveal_result);
+        });
+
+        result_rx
+    }
+
+    /// Launch the configured editor and return completion back to the UI thread for HUD feedback.
+    fn launch_editor_with_feedback_async(
+        &self,
+        path: &std::path::Path,
+    ) -> async_channel::Receiver<Result<(), String>> {
+        let editor = self.config.get_editor();
+        let path_str = path.to_string_lossy().to_string();
+        let (result_tx, result_rx) = async_channel::bounded::<Result<(), String>>(1);
+
+        std::thread::spawn(move || {
+            use std::process::Command;
+
+            logging::log(
+                "UI",
+                &format!(
+                    "ACTION_EDITOR_LAUNCH_START editor='{}' path='{}'",
+                    editor, path_str
+                ),
+            );
+
+            let launch_result = match Command::new(&editor).arg(&path_str).spawn() {
+                Ok(_) => {
+                    logging::log(
+                        "UI",
+                        &format!(
+                            "ACTION_EDITOR_LAUNCH_SUCCESS editor='{}' path='{}'",
+                            editor, path_str
+                        ),
+                    );
+                    Ok(())
+                }
+                Err(error) => {
+                    logging::log(
+                        "ERROR",
+                        &format!(
+                            "ACTION_EDITOR_LAUNCH_FAILED attempted='{} {}' path='{}' error='{}'",
+                            editor, path_str, path_str, error
+                        ),
+                    );
+                    Err(format!("Failed to open in {}: {}", editor, error))
+                }
+            };
+
+            let _ = result_tx.send_blocking(launch_result);
+        });
+
+        result_rx
+    }
+
     /// Copy text to clipboard using pbcopy on macOS.
     /// Critical: This properly closes stdin before waiting to prevent hangs.
     #[cfg(target_os = "macos")]
@@ -471,9 +574,24 @@
                 };
 
                 if let Some(path) = path_opt {
-                    self.reveal_in_finder(&path);
-                    self.show_hud("Opened in Finder".to_string(), Some(1500), cx);
-                    self.hide_main_and_reset(cx);
+                    let reveal_result_rx = self.reveal_in_finder_with_feedback_async(&path);
+                    cx.spawn(async move |this, cx| {
+                        let Ok(reveal_result) = reveal_result_rx.recv().await else {
+                            return;
+                        };
+
+                        this.update(cx, |this, cx| match reveal_result {
+                            Ok(()) => {
+                                this.show_hud("Opened in Finder".to_string(), Some(1500), cx);
+                                this.hide_main_and_reset(cx);
+                            }
+                            Err(message) => {
+                                this.show_hud(message, Some(2500), cx);
+                            }
+                        })
+                        .ok();
+                    })
+                    .detach();
                 } else {
                     self.show_hud(
                         "Cannot reveal this item type in Finder".to_string(),
@@ -884,8 +1002,23 @@
                     };
 
                     if let Some(path) = path_opt {
-                        self.edit_script(&path);
-                        self.hide_main_and_reset(cx);
+                        let editor_launch_rx = self.launch_editor_with_feedback_async(&path);
+                        cx.spawn(async move |this, cx| {
+                            let Ok(launch_result) = editor_launch_rx.recv().await else {
+                                return;
+                            };
+
+                            this.update(cx, |this, cx| match launch_result {
+                                Ok(()) => {
+                                    this.hide_main_and_reset(cx);
+                                }
+                                Err(message) => {
+                                    this.show_hud(message, Some(3000), cx);
+                                }
+                            })
+                            .ok();
+                        })
+                        .detach();
                     } else {
                         self.show_hud("Cannot edit this item type".to_string(), Some(2000), cx);
                     }
@@ -1932,8 +2065,23 @@
                             // Extract just the path without the anchor (e.g., "/path/to/file.md#slug" -> "/path/to/file.md")
                             let path_str = file_path.split('#').next().unwrap_or(file_path);
                             let path = std::path::PathBuf::from(path_str);
-                            self.edit_script(&path);
-                            self.hide_main_and_reset(cx);
+                            let editor_launch_rx = self.launch_editor_with_feedback_async(&path);
+                            cx.spawn(async move |this, cx| {
+                                let Ok(launch_result) = editor_launch_rx.recv().await else {
+                                    return;
+                                };
+
+                                this.update(cx, |this, cx| match launch_result {
+                                    Ok(()) => {
+                                        this.hide_main_and_reset(cx);
+                                    }
+                                    Err(message) => {
+                                        this.show_hud(message, Some(3000), cx);
+                                    }
+                                })
+                                .ok();
+                            })
+                            .detach();
                         } else {
                             self.show_hud(
                                 "Scriptlet has no source file path".to_string(),
@@ -1964,9 +2112,24 @@
                             // Extract just the path without the anchor
                             let path_str = file_path.split('#').next().unwrap_or(file_path);
                             let path = std::path::Path::new(path_str);
-                            self.reveal_in_finder(path);
-                            self.show_hud("Opened in Finder".to_string(), Some(1500), cx);
-                            self.hide_main_and_reset(cx);
+                            let reveal_result_rx = self.reveal_in_finder_with_feedback_async(path);
+                            cx.spawn(async move |this, cx| {
+                                let Ok(reveal_result) = reveal_result_rx.recv().await else {
+                                    return;
+                                };
+
+                                this.update(cx, |this, cx| match reveal_result {
+                                    Ok(()) => {
+                                        this.show_hud("Opened in Finder".to_string(), Some(1500), cx);
+                                        this.hide_main_and_reset(cx);
+                                    }
+                                    Err(message) => {
+                                        this.show_hud(message, Some(2500), cx);
+                                    }
+                                })
+                                .ok();
+                            })
+                            .detach();
                         } else {
                             self.show_hud(
                                 "Scriptlet has no source file path".to_string(),


thinking
**Inspecting output around reveal action**
exec
/bin/zsh -lc "nl -ba src/app_actions/handle_action.rs | sed -n '545,625p' && nl -ba src/app_actions/handle_action.rs | sed -n '990,1045p' && nl -ba src/app_actions/handle_action.rs | sed -n '2050,2145p'" in /Users/johnlindquist/dev/script-kit-gpui succeeded in 51ms:
   545	                self.hide_main_and_reset(cx);
   546	            }
   547	            "run_script" => {
   548	                logging::log("UI", "Run script action");
   549	                self.execute_selected(cx);
   550	            }
   551	            "view_logs" => {
   552	                logging::log("UI", "View logs action");
   553	                self.toggle_logs(cx);
   554	            }
   555	            "reveal_in_finder" => {
   556	                logging::log("UI", "Reveal in Finder action");
   557	                // First check if we have a file search path (takes priority)
   558	                let path_opt = if let Some(path) = self.file_search_actions_path.take() {
   559	                    logging::log("UI", &format!("Reveal in Finder (file search): {}", path));
   560	                    Some(std::path::PathBuf::from(path))
   561	                } else if let Some(result) = self.get_selected_result() {
   562	                    // Fall back to main menu selected result
   563	                    match result {
   564	                        scripts::SearchResult::Script(m) => Some(m.script.path.clone()),
file update:
diff --git a/src/app_actions/handle_action.rs b/src/app_actions/handle_action.rs
index 6512e920f98eb38811debb5dca005d821b3adb44..dda46dd268dc9fe3130c27b221485ba871f1c703
--- a/src/app_actions/handle_action.rs
+++ b/src/app_actions/handle_action.rs
@@ -32,6 +32,109 @@
         });
     }
 
+    /// Reveal a path and return completion back to the UI thread for HUD feedback.
+    fn reveal_in_finder_with_feedback_async(
+        &self,
+        path: &std::path::Path,
+    ) -> async_channel::Receiver<Result<(), String>> {
+        let path_str = path.to_string_lossy().to_string();
+        let (result_tx, result_rx) = async_channel::bounded::<Result<(), String>>(1);
+
+        std::thread::spawn(move || {
+            let file_manager = if cfg!(target_os = "macos") {
+                "Finder"
+            } else if cfg!(target_os = "windows") {
+                "Explorer"
+            } else {
+                "File Manager"
+            };
+
+            logging::log(
+                "UI",
+                &format!(
+                    "ACTION_REVEAL_IN_FINDER_START file_manager='{}' path='{}'",
+                    file_manager, path_str
+                ),
+            );
+
+            let reveal_result = match crate::file_search::reveal_in_finder(&path_str) {
+                Ok(()) => {
+                    logging::log(
+                        "UI",
+                        &format!(
+                            "ACTION_REVEAL_IN_FINDER_SUCCESS file_manager='{}' path='{}'",
+                            file_manager, path_str
+                        ),
+                    );
+                    Ok(())
+                }
+                Err(error) => {
+                    logging::log(
+                        "ERROR",
+                        &format!(
+                            "ACTION_REVEAL_IN_FINDER_FAILED attempted='reveal_in_finder' path='{}' file_manager='{}' error='{}'",
+                            path_str, file_manager, error
+                        ),
+                    );
+                    Err(format!("Failed to reveal in {}: {}", file_manager, error))
+                }
+            };
+
+            let _ = result_tx.send_blocking(reveal_result);
+        });
+
+        result_rx
+    }
+
+    /// Launch the configured editor and return completion back to the UI thread for HUD feedback.
+    fn launch_editor_with_feedback_async(
+        &self,
+        path: &std::path::Path,
+    ) -> async_channel::Receiver<Result<(), String>> {
+        let editor = self.config.get_editor();
+        let path_str = path.to_string_lossy().to_string();
+        let (result_tx, result_rx) = async_channel::bounded::<Result<(), String>>(1);
+
+        std::thread::spawn(move || {
+            use std::process::Command;
+
+            logging::log(
+                "UI",
+                &format!(
+                    "ACTION_EDITOR_LAUNCH_START editor='{}' path='{}'",
+                    editor, path_str
+                ),
+            );
+
+            let launch_result = match Command::new(&editor).arg(&path_str).spawn() {
+                Ok(_) => {
+                    logging::log(
+                        "UI",
+                        &format!(
+                            "ACTION_EDITOR_LAUNCH_SUCCESS editor='{}' path='{}'",
+                            editor, path_str
+                        ),
+                    );
+                    Ok(())
+                }
+                Err(error) => {
+                    logging::log(
+                        "ERROR",
+                        &format!(
+                            "ACTION_EDITOR_LAUNCH_FAILED attempted='{} {}' path='{}' error='{}'",
+                            editor, path_str, path_str, error
+                        ),
+                    );
+                    Err(format!("Failed to open in {}: {}", editor, error))
+                }
+            };
+
+            let _ = result_tx.send_blocking(launch_result);
+        });
+
+        result_rx
+    }
+
     /// Copy text to clipboard using pbcopy on macOS.
     /// Critical: This properly closes stdin before waiting to prevent hangs.
     #[cfg(target_os = "macos")]
@@ -471,9 +574,24 @@
                 };
 
                 if let Some(path) = path_opt {
-                    self.reveal_in_finder(&path);
-                    self.show_hud("Opened in Finder".to_string(), Some(1500), cx);
-                    self.hide_main_and_reset(cx);
+                    let reveal_result_rx = self.reveal_in_finder_with_feedback_async(&path);
+                    cx.spawn(async move |this, cx| {
+                        let Ok(reveal_result) = reveal_result_rx.recv().await else {
+                            return;
+                        };
+
+                        this.update(cx, |this, cx| match reveal_result {
+                            Ok(()) => {
+                                this.show_hud("Opened in Finder".to_string(), Some(1500), cx);
+                                this.hide_main_and_reset(cx);
+                            }
+                            Err(message) => {
+                                this.show_hud(message, Some(2500), cx);
+                            }
+                        })
+                        .ok();
+                    })
+                    .detach();
                 } else {
                     self.show_hud(
                         "Cannot reveal this item type in Finder".to_string(),
@@ -884,8 +1002,23 @@
                     };
 
                     if let Some(path) = path_opt {
-                        self.edit_script(&path);
-                        self.hide_main_and_reset(cx);
+                        let editor_launch_rx = self.launch_editor_with_feedback_async(&path);
+                        cx.spawn(async move |this, cx| {
+                            let Ok(launch_result) = editor_launch_rx.recv().await else {
+                                return;
+                            };
+
+                            this.update(cx, |this, cx| match launch_result {
+                                Ok(()) => {
+                                    this.hide_main_and_reset(cx);
+                                }
+                                Err(message) => {
+                                    this.show_hud(message, Some(3000), cx);
+                                }
+                            })
+                            .ok();
+                        })
+                        .detach();
                     } else {
                         self.show_hud("Cannot edit this item type".to_string(), Some(2000), cx);
                     }
@@ -1932,8 +2065,23 @@
                             // Extract just the path without the anchor (e.g., "/path/to/file.md#slug" -> "/path/to/file.md")
                             let path_str = file_path.split('#').next().unwrap_or(file_path);
                             let path = std::path::PathBuf::from(path_str);
-                            self.edit_script(&path);
-                            self.hide_main_and_reset(cx);
+                            let editor_launch_rx = self.launch_editor_with_feedback_async(&path);
+                            cx.spawn(async move |this, cx| {
+                                let Ok(launch_result) = editor_launch_rx.recv().await else {
+                                    return;
+                                };
+
+                                this.update(cx, |this, cx| match launch_result {
+                                    Ok(()) => {
+                                        this.hide_main_and_reset(cx);
+                                    }
+                                    Err(message) => {
+                                        this.show_hud(message, Some(3000), cx);
+                                    }
+                                })
+                                .ok();
+                            })
+                            .detach();
                         } else {
                             self.show_hud(
                                 "Scriptlet has no source file path".to_string(),
@@ -1964,9 +2112,24 @@
                             // Extract just the path without the anchor
                             let path_str = file_path.split('#').next().unwrap_or(file_path);
                             let path = std::path::Path::new(path_str);
-                            self.reveal_in_finder(path);
-                            self.show_hud("Opened in Finder".to_string(), Some(1500), cx);
-                            self.hide_main_and_reset(cx);
+                            let reveal_result_rx = self.reveal_in_finder_with_feedback_async(path);
+                            cx.spawn(async move |this, cx| {
+                                let Ok(reveal_result) = reveal_result_rx.recv().await else {
+                                    return;
+                                };
+
+                                this.update(cx, |this, cx| match reveal_result {
+                                    Ok(()) => {
+                                        this.show_hud("Opened in Finder".to_string(), Some(1500), cx);
+                                        this.hide_main_and_reset(cx);
+                                    }
+                                    Err(message) => {
+                                        this.show_hud(message, Some(2500), cx);
+                                    }
+                                })
+                                .ok();
+                            })
+                            .detach();
                         } else {
                             self.show_hud(
                                 "Scriptlet has no source file path".to_string(),


thinking
**Updating test module path**
file update
M /Users/johnlindquist/dev/script-kit-gpui/src/app_actions/tests.rs
@@ -8 +8,4 @@
 mod clipboard_actions_menu_coverage;
+
+#[path = "tests/editor_launch_feedback.rs"]
+mod editor_launch_feedback;
apply_patch(auto_approved=true) exited 0 in 19ms:
Success. Updated the following files:
M /Users/johnlindquist/dev/script-kit-gpui/src/app_actions/tests.rs
file update:
diff --git a/src/app_actions/handle_action.rs b/src/app_actions/handle_action.rs
index 6512e920f98eb38811debb5dca005d821b3adb44..dda46dd268dc9fe3130c27b221485ba871f1c703
--- a/src/app_actions/handle_action.rs
+++ b/src/app_actions/handle_action.rs
@@ -32,6 +32,109 @@
         });
     }
 
+    /// Reveal a path and return completion back to the UI thread for HUD feedback.
+    fn reveal_in_finder_with_feedback_async(
+        &self,
+        path: &std::path::Path,
+    ) -> async_channel::Receiver<Result<(), String>> {
+        let path_str = path.to_string_lossy().to_string();
+        let (result_tx, result_rx) = async_channel::bounded::<Result<(), String>>(1);
+
+        std::thread::spawn(move || {
+            let file_manager = if cfg!(target_os = "macos") {
+                "Finder"
+            } else if cfg!(target_os = "windows") {
+                "Explorer"
+            } else {
+                "File Manager"
+            };
+
+            logging::log(
+                "UI",
+                &format!(
+                    "ACTION_REVEAL_IN_FINDER_START file_manager='{}' path='{}'",
+                    file_manager, path_str
+                ),
+            );
+
+            let reveal_result = match crate::file_search::reveal_in_finder(&path_str) {
+                Ok(()) => {
+                    logging::log(
+                        "UI",
+                        &format!(
+                            "ACTION_REVEAL_IN_FINDER_SUCCESS file_manager='{}' path='{}'",
+                            file_manager, path_str
+                        ),
+                    );
+                    Ok(())
+                }
+                Err(error) => {
+                    logging::log(
+                        "ERROR",
+                        &format!(
+                            "ACTION_REVEAL_IN_FINDER_FAILED attempted='reveal_in_finder' path='{}' file_manager='{}' error='{}'",
+                            path_str, file_manager, error
+                        ),
+                    );
+                    Err(format!("Failed to reveal in {}: {}", file_manager, error))
+                }
+            };
+
+            let _ = result_tx.send_blocking(reveal_result);
+        });
+
+        result_rx
+    }
+
+    /// Launch the configured editor and return completion back to the UI thread for HUD feedback.
+    fn launch_editor_with_feedback_async(
+        &self,
+        path: &std::path::Path,
+    ) -> async_channel::Receiver<Result<(), String>> {
+        let editor = self.config.get_editor();
+        let path_str = path.to_string_lossy().to_string();
+        let (result_tx, result_rx) = async_channel::bounded::<Result<(), String>>(1);
+
+        std::thread::spawn(move || {
+            use std::process::Command;
+
+            logging::log(
+                "UI",
+                &format!(
+                    "ACTION_EDITOR_LAUNCH_START editor='{}' path='{}'",
+                    editor, path_str
+                ),
+            );
+
+            let launch_result = match Command::new(&editor).arg(&path_str).spawn() {
+                Ok(_) => {
+                    logging::log(
+                        "UI",
+                        &format!(
+                            "ACTION_EDITOR_LAUNCH_SUCCESS editor='{}' path='{}'",
+                            editor, path_str
+                        ),
+                    );
+                    Ok(())
+                }
+                Err(error) => {
+                    logging::log(
+                        "ERROR",
+                        &format!(
+                            "ACTION_EDITOR_LAUNCH_FAILED attempted='{} {}' path='{}' error='{}'",
+                            editor, path_str, path_str, error
+                        ),
+                    );
+                    Err(format!("Failed to open in {}: {}", editor, error))
+                }
+            };
+
+            let _ = result_tx.send_blocking(launch_result);
+        });
+
+        result_rx
+    }
+
     /// Copy text to clipboard using pbcopy on macOS.
     /// Critical: This properly closes stdin before waiting to prevent hangs.
     #[cfg(target_os = "macos")]
@@ -471,9 +574,24 @@
                 };
 
                 if let Some(path) = path_opt {
-                    self.reveal_in_finder(&path);
-                    self.show_hud("Opened in Finder".to_string(), Some(1500), cx);
-                    self.hide_main_and_reset(cx);
+                    let reveal_result_rx = self.reveal_in_finder_with_feedback_async(&path);
+                    cx.spawn(async move |this, cx| {
+                        let Ok(reveal_result) = reveal_result_rx.recv().await else {
+                            return;
+                        };
+
+                        this.update(cx, |this, cx| match reveal_result {
+                            Ok(()) => {
+                                this.show_hud("Opened in Finder".to_string(), Some(1500), cx);
+                                this.hide_main_and_reset(cx);
+                            }
+                            Err(message) => {
+                                this.show_hud(message, Some(2500), cx);
+                            }
+                        })
+                        .ok();
+                    })
+                    .detach();
                 } else {
                     self.show_hud(
                         "Cannot reveal this item type in Finder".to_string(),
@@ -884,8 +1002,23 @@
                     };
 
                     if let Some(path) = path_opt {
-                        self.edit_script(&path);
-                        self.hide_main_and_reset(cx);
+                        let editor_launch_rx = self.launch_editor_with_feedback_async(&path);
+                        cx.spawn(async move |this, cx| {
+                            let Ok(launch_result) = editor_launch_rx.recv().await else {
+                                return;
+                            };
+
+                            this.update(cx, |this, cx| match launch_result {
+                                Ok(()) => {
+                                    this.hide_main_and_reset(cx);
+                                }
+                                Err(message) => {
+                                    this.show_hud(message, Some(3000), cx);
+                                }
+                            })
+                            .ok();
+                        })
+                        .detach();
                     } else {
                         self.show_hud("Cannot edit this item type".to_string(), Some(2000), cx);
                     }
@@ -1932,8 +2065,23 @@
                             // Extract just the path without the anchor (e.g., "/path/to/file.md#slug" -> "/path/to/file.md")
                             let path_str = file_path.split('#').next().unwrap_or(file_path);
                             let path = std::path::PathBuf::from(path_str);
-                            self.edit_script(&path);
-                            self.hide_main_and_reset(cx);
+                            let editor_launch_rx = self.launch_editor_with_feedback_async(&path);
+                            cx.spawn(async move |this, cx| {
+                                let Ok(launch_result) = editor_launch_rx.recv().await else {
+                                    return;
+                                };
+
+                                this.update(cx, |this, cx| match launch_result {
+                                    Ok(()) => {
+                                        this.hide_main_and_reset(cx);
+                                    }
+                                    Err(message) => {
+                                        this.show_hud(message, Some(3000), cx);
+                                    }
+                                })
+                                .ok();
+                            })
+                            .detach();
                         } else {
                             self.show_hud(
                                 "Scriptlet has no source file path".to_string(),
@@ -1964,9 +2112,24 @@
                             // Extract just the path without the anchor
                             let path_str = file_path.split('#').next().unwrap_or(file_path);
                             let path = std::path::Path::new(path_str);
-                            self.reveal_in_finder(path);
-                            self.show_hud("Opened in Finder".to_string(), Some(1500), cx);
-                            self.hide_main_and_reset(cx);
+                            let reveal_result_rx = self.reveal_in_finder_with_feedback_async(path);
+                            cx.spawn(async move |this, cx| {
+                                let Ok(reveal_result) = reveal_result_rx.recv().await else {
+                                    return;
+                                };
+
+                                this.update(cx, |this, cx| match reveal_result {
+                                    Ok(()) => {
+                                        this.show_hud("Opened in Finder".to_string(), Some(1500), cx);
+                                        this.hide_main_and_reset(cx);
+                                    }
+                                    Err(message) => {
+                                        this.show_hud(message, Some(2500), cx);
+                                    }
+                                })
+                                .ok();
+                            })
+                            .detach();
                         } else {
                             self.show_hud(
                                 "Scriptlet has no source file path".to_string(),
diff --git a/src/app_actions/tests.rs b/src/app_actions/tests.rs
index 6e1bf7a5d42c8a5885695d94e51511178ec11315..7d9221c13778e3f29cf8798b8da18261b85f5221
--- a/src/app_actions/tests.rs
+++ b/src/app_actions/tests.rs
@@ -6,3 +6,6 @@
 
 #[path = "tests/clipboard_actions_menu_coverage.rs"]
 mod clipboard_actions_menu_coverage;
+
+#[path = "tests/editor_launch_feedback.rs"]
+mod editor_launch_feedback;

file update:
diff --git a/src/app_actions/handle_action.rs b/src/app_actions/handle_action.rs
index 6512e920f98eb38811debb5dca005d821b3adb44..dda46dd268dc9fe3130c27b221485ba871f1c703
--- a/src/app_actions/handle_action.rs
+++ b/src/app_actions/handle_action.rs
@@ -32,6 +32,109 @@
         });
     }
 
+    /// Reveal a path and return completion back to the UI thread for HUD feedback.
+    fn reveal_in_finder_with_feedback_async(
+        &self,
+        path: &std::path::Path,
+    ) -> async_channel::Receiver<Result<(), String>> {
+        let path_str = path.to_string_lossy().to_string();
+        let (result_tx, result_rx) = async_channel::bounded::<Result<(), String>>(1);
+
+        std::thread::spawn(move || {
+            let file_manager = if cfg!(target_os = "macos") {
+                "Finder"
+            } else if cfg!(target_os = "windows") {
+                "Explorer"
+            } else {
+                "File Manager"
+            };
+
+            logging::log(
+                "UI",
+                &format!(
+                    "ACTION_REVEAL_IN_FINDER_START file_manager='{}' path='{}'",
+                    file_manager, path_str
+                ),
+            );
+
+            let reveal_result = match crate::file_search::reveal_in_finder(&path_str) {
+                Ok(()) => {
+                    logging::log(
+                        "UI",
+                        &format!(
+                            "ACTION_REVEAL_IN_FINDER_SUCCESS file_manager='{}' path='{}'",
+                            file_manager, path_str
+                        ),
+                    );
+                    Ok(())
+                }
+                Err(error) => {
+                    logging::log(
+                        "ERROR",
+                        &format!(
+                            "ACTION_REVEAL_IN_FINDER_FAILED attempted='reveal_in_finder' path='{}' file_manager='{}' error='{}'",
+                            path_str, file_manager, error
+                        ),
+                    );
+                    Err(format!("Failed to reveal in {}: {}", file_manager, error))
+                }
+            };
+
+            let _ = result_tx.send_blocking(reveal_result);
+        });
+
+        result_rx
+    }
+
+    /// Launch the configured editor and return completion back to the UI thread for HUD feedback.
+    fn launch_editor_with_feedback_async(
+        &self,
+        path: &std::path::Path,
+    ) -> async_channel::Receiver<Result<(), String>> {
+        let editor = self.config.get_editor();
+        let path_str = path.to_string_lossy().to_string();
+        let (result_tx, result_rx) = async_channel::bounded::<Result<(), String>>(1);
+
+        std::thread::spawn(move || {
+            use std::process::Command;
+
+            logging::log(
+                "UI",
+                &format!(
+                    "ACTION_EDITOR_LAUNCH_START editor='{}' path='{}'",
+                    editor, path_str
+                ),
+            );
+
+            let launch_result = match Command::new(&editor).arg(&path_str).spawn() {
+                Ok(_) => {
+                    logging::log(
+                        "UI",
+                        &format!(
+                            "ACTION_EDITOR_LAUNCH_SUCCESS editor='{}' path='{}'",
+                            editor, path_str
+                        ),
+                    );
+                    Ok(())
+                }
+                Err(error) => {
+                    logging::log(
+                        "ERROR",
+                        &format!(
+                            "ACTION_EDITOR_LAUNCH_FAILED attempted='{} {}' path='{}' error='{}'",
+                            editor, path_str, path_str, error
+                        ),
+                    );
+                    Err(format!("Failed to open in {}: {}", editor, error))
+                }
+            };
+
+            let _ = result_tx.send_blocking(launch_result);
+        });
+
+        result_rx
+    }
+
     /// Copy text to clipboard using pbcopy on macOS.
     /// Critical: This properly closes stdin before waiting to prevent hangs.
     #[cfg(target_os = "macos")]
@@ -471,9 +574,24 @@
                 };
 
                 if let Some(path) = path_opt {
-                    self.reveal_in_finder(&path);
-                    self.show_hud("Opened in Finder".to_string(), Some(1500), cx);
-                    self.hide_main_and_reset(cx);
+                    let reveal_result_rx = self.reveal_in_finder_with_feedback_async(&path);
+                    cx.spawn(async move |this, cx| {
+                        let Ok(reveal_result) = reveal_result_rx.recv().await else {
+                            return;
+                        };
+
+                        this.update(cx, |this, cx| match reveal_result {
+                            Ok(()) => {
+                                this.show_hud("Opened in Finder".to_string(), Some(1500), cx);
+                                this.hide_main_and_reset(cx);
+                            }
+                            Err(message) => {
+                                this.show_hud(message, Some(2500), cx);
+                            }
+                        })
+                        .ok();
+                    })
+                    .detach();
                 } else {
                     self.show_hud(
                         "Cannot reveal this item type in Finder".to_string(),
@@ -884,8 +1002,23 @@
                     };
 
                     if let Some(path) = path_opt {
-                        self.edit_script(&path);
-                        self.hide_main_and_reset(cx);
+                        let editor_launch_rx = self.launch_editor_with_feedback_async(&path);
+                        cx.spawn(async move |this, cx| {
+                            let Ok(launch_result) = editor_launch_rx.recv().await else {
+                                return;
+                            };
+
+                            this.update(cx, |this, cx| match launch_result {
+                                Ok(()) => {
+                                    this.hide_main_and_reset(cx);
+                                }
+                                Err(message) => {
+                                    this.show_hud(message, Some(3000), cx);
+                                }
+                            })
+                            .ok();
+                        })
+                        .detach();
                     } else {
                         self.show_hud("Cannot edit this item type".to_string(), Some(2000), cx);
                     }
@@ -1932,8 +2065,23 @@
                             // Extract just the path without the anchor (e.g., "/path/to/file.md#slug" -> "/path/to/file.md")
                             let path_str = file_path.split('#').next().unwrap_or(file_path);
                             let path = std::path::PathBuf::from(path_str);
-                            self.edit_script(&path);
-                            self.hide_main_and_reset(cx);
+                            let editor_launch_rx = self.launch_editor_with_feedback_async(&path);
+                            cx.spawn(async move |this, cx| {
+                                let Ok(launch_result) = editor_launch_rx.recv().await else {
+                                    return;
+                                };
+
+                                this.update(cx, |this, cx| match launch_result {
+                                    Ok(()) => {
+                                        this.hide_main_and_reset(cx);
+                                    }
+                                    Err(message) => {
+                                        this.show_hud(message, Some(3000), cx);
+                                    }
+                                })
+                                .ok();
+                            })
+                            .detach();
                         } else {
                             self.show_hud(
                                 "Scriptlet has no source file path".to_string(),
@@ -1964,9 +2112,24 @@
                             // Extract just the path without the anchor
                             let path_str = file_path.split('#').next().unwrap_or(file_path);
                             let path = std::path::Path::new(path_str);
-                            self.reveal_in_finder(path);
-                            self.show_hud("Opened in Finder".to_string(), Some(1500), cx);
-                            self.hide_main_and_reset(cx);
+                            let reveal_result_rx = self.reveal_in_finder_with_feedback_async(path);
+                            cx.spawn(async move |this, cx| {
+                                let Ok(reveal_result) = reveal_result_rx.recv().await else {
+                                    return;
+                                };
+
+                                this.update(cx, |this, cx| match reveal_result {
+                                    Ok(()) => {
+                                        this.show_hud("Opened in Finder".to_string(), Some(1500), cx);
+                                        this.hide_main_and_reset(cx);
+                                    }
+                                    Err(message) => {
+                                        this.show_hud(message, Some(2500), cx);
+                                    }
+                                })
+                                .ok();
+                            })
+                            .detach();
                         } else {
                             self.show_hud(
                                 "Scriptlet has no source file path".to_string(),
diff --git a/src/app_actions/tests.rs b/src/app_actions/tests.rs
index 6e1bf7a5d42c8a5885695d94e51511178ec11315..7d9221c13778e3f29cf8798b8da18261b85f5221
--- a/src/app_actions/tests.rs
+++ b/src/app_actions/tests.rs
@@ -6,3 +6,6 @@
 
 #[path = "tests/clipboard_actions_menu_coverage.rs"]
 mod clipboard_actions_menu_coverage;
+
+#[path = "tests/editor_launch_feedback.rs"]
+mod editor_launch_feedback;


thinking
**Creating new test file**
codex
I’ve finished the code patch and now I’m adding a focused regression test that asserts the new async editor/reveal feedback wiring remains in place.
exec
/bin/zsh -lc "cat > src/app_actions/tests/editor_launch_feedback.rs <<'EOF'
use std::fs;

fn read(path: &str) -> String {
    fs::read_to_string(path).unwrap_or_else(|_| panic"'!("Failed to read {path}"))
}

fn count_occurrences(haystack: &str, needle: &str) -> usize {
    haystack.match_indices(needle).count()
}

#[test]
fn test_edit_actions_show_error_feedback_when_editor_launch_fails() {
    let content = read("src/app_actions/handle_action.rs");

    assert!(
        content.contains("fn launch_editor_with_feedback_async"),
        "Expected async editor launch helper to exist"
    );

    let usage_count = count_occurrences(&content, "self.launch_editor_with_feedback_async(&path)");
    assert!(
        usage_count >= 2,
        "Expected edit_script and edit_scriptlet to use async editor launch feedback (found {usage_count} usages)"
    );

    assert!(
        content.contains("this.show_hud(message, Some(3000), cx);"),
        "Expected async editor launch failure to surface a HUD error message"
    );
}

#[test]
fn test_reveal_actions_show_success_hud_after_async_reveal_completion() {
    let content = read("src/app_actions/handle_action.rs");

    assert!(
        content.contains("fn reveal_in_finder_with_feedback_async"),
        "Expected async reveal helper to exist"
    );

    let usage_count = count_occurrences(
        &content,
        "self.reveal_in_finder_with_feedback_async(&path)",
    ) + count_occurrences(
        &content,
        "self.reveal_in_finder_with_feedback_async(path)",
    );
    assert!(
        usage_count >= 2,
        "Expected reveal actions to use async reveal feedback helper (found {usage_count} usages)"
    );

    assert!(
        content.contains("let Ok(reveal_result) = reveal_result_rx.recv().await else {"),
        "Expected reveal actions to await async reveal completion before showing HUD"
    );

    assert!(
        content.contains("this.show_hud('"\\\"Opened in Finder\\\".to_string(), Some(1500), cx);\"),
        \"Expected reveal success HUD to be emitted from async completion callback\"
    );
}
EOF" in /Users/johnlindquist/dev/script-kit-gpui succeeded in 52ms:

file update:
diff --git a/src/app_actions/handle_action.rs b/src/app_actions/handle_action.rs
index 6512e920f98eb38811debb5dca005d821b3adb44..dda46dd268dc9fe3130c27b221485ba871f1c703
--- a/src/app_actions/handle_action.rs
+++ b/src/app_actions/handle_action.rs
@@ -32,6 +32,109 @@
         });
     }
 
+    /// Reveal a path and return completion back to the UI thread for HUD feedback.
+    fn reveal_in_finder_with_feedback_async(
+        &self,
+        path: &std::path::Path,
+    ) -> async_channel::Receiver<Result<(), String>> {
+        let path_str = path.to_string_lossy().to_string();
+        let (result_tx, result_rx) = async_channel::bounded::<Result<(), String>>(1);
+
+        std::thread::spawn(move || {
+            let file_manager = if cfg!(target_os = "macos") {
+                "Finder"
+            } else if cfg!(target_os = "windows") {
+                "Explorer"
+            } else {
+                "File Manager"
+            };
+
+            logging::log(
+                "UI",
+                &format!(
+                    "ACTION_REVEAL_IN_FINDER_START file_manager='{}' path='{}'",
+                    file_manager, path_str
+                ),
+            );
+
+            let reveal_result = match crate::file_search::reveal_in_finder(&path_str) {
+                Ok(()) => {
+                    logging::log(
+                        "UI",
+                        &format!(
+                            "ACTION_REVEAL_IN_FINDER_SUCCESS file_manager='{}' path='{}'",
+                            file_manager, path_str
+                        ),
+                    );
+                    Ok(())
+                }
+                Err(error) => {
+                    logging::log(
+                        "ERROR",
+                        &format!(
+                            "ACTION_REVEAL_IN_FINDER_FAILED attempted='reveal_in_finder' path='{}' file_manager='{}' error='{}'",
+                            path_str, file_manager, error
+                        ),
+                    );
+                    Err(format!("Failed to reveal in {}: {}", file_manager, error))
+                }
+            };
+
+            let _ = result_tx.send_blocking(reveal_result);
+        });
+
+        result_rx
+    }
+
+    /// Launch the configured editor and return completion back to the UI thread for HUD feedback.
+    fn launch_editor_with_feedback_async(
+        &self,
+        path: &std::path::Path,
+    ) -> async_channel::Receiver<Result<(), String>> {
+        let editor = self.config.get_editor();
+        let path_str = path.to_string_lossy().to_string();
+        let (result_tx, result_rx) = async_channel::bounded::<Result<(), String>>(1);
+
+        std::thread::spawn(move || {
+            use std::process::Command;
+
+            logging::log(
+                "UI",
+                &format!(
+                    "ACTION_EDITOR_LAUNCH_START editor='{}' path='{}'",
+                    editor, path_str
+                ),
+            );
+
+            let launch_result = match Command::new(&editor).arg(&path_str).spawn() {
+                Ok(_) => {
+                    logging::log(
+                        "UI",
+                        &format!(
+                            "ACTION_EDITOR_LAUNCH_SUCCESS editor='{}' path='{}'",
+                            editor, path_str
+                        ),
+                    );
+                    Ok(())
+                }
+                Err(error) => {
+                    logging::log(
+                        "ERROR",
+                        &format!(
+                            "ACTION_EDITOR_LAUNCH_FAILED attempted='{} {}' path='{}' error='{}'",
+                            editor, path_str, path_str, error
+                        ),
+                    );
+                    Err(format!("Failed to open in {}: {}", editor, error))
+                }
+            };
+
+            let _ = result_tx.send_blocking(launch_result);
+        });
+
+        result_rx
+    }
+
     /// Copy text to clipboard using pbcopy on macOS.
     /// Critical: This properly closes stdin before waiting to prevent hangs.
     #[cfg(target_os = "macos")]
@@ -471,9 +574,24 @@
                 };
 
                 if let Some(path) = path_opt {
-                    self.reveal_in_finder(&path);
-                    self.show_hud("Opened in Finder".to_string(), Some(1500), cx);
-                    self.hide_main_and_reset(cx);
+                    let reveal_result_rx = self.reveal_in_finder_with_feedback_async(&path);
+                    cx.spawn(async move |this, cx| {
+                        let Ok(reveal_result) = reveal_result_rx.recv().await else {
+                            return;
+                        };
+
+                        this.update(cx, |this, cx| match reveal_result {
+                            Ok(()) => {
+                                this.show_hud("Opened in Finder".to_string(), Some(1500), cx);
+                                this.hide_main_and_reset(cx);
+                            }
+                            Err(message) => {
+                                this.show_hud(message, Some(2500), cx);
+                            }
+                        })
+                        .ok();
+                    })
+                    .detach();
                 } else {
                     self.show_hud(
                         "Cannot reveal this item type in Finder".to_string(),
@@ -884,8 +1002,23 @@
                     };
 
                     if let Some(path) = path_opt {
-                        self.edit_script(&path);
-                        self.hide_main_and_reset(cx);
+                        let editor_launch_rx = self.launch_editor_with_feedback_async(&path);
+                        cx.spawn(async move |this, cx| {
+                            let Ok(launch_result) = editor_launch_rx.recv().await else {
+                                return;
+                            };
+
+                            this.update(cx, |this, cx| match launch_result {
+                                Ok(()) => {
+                                    this.hide_main_and_reset(cx);
+                                }
+                                Err(message) => {
+                                    this.show_hud(message, Some(3000), cx);
+                                }
+                            })
+                            .ok();
+                        })
+                        .detach();
                     } else {
                         self.show_hud("Cannot edit this item type".to_string(), Some(2000), cx);
                     }
@@ -1932,8 +2065,23 @@
                             // Extract just the path without the anchor (e.g., "/path/to/file.md#slug" -> "/path/to/file.md")
                             let path_str = file_path.split('#').next().unwrap_or(file_path);
                             let path = std::path::PathBuf::from(path_str);
-                            self.edit_script(&path);
-                            self.hide_main_and_reset(cx);
+                            let editor_launch_rx = self.launch_editor_with_feedback_async(&path);
+                            cx.spawn(async move |this, cx| {
+                                let Ok(launch_result) = editor_launch_rx.recv().await else {
+                                    return;
+                                };
+
+                                this.update(cx, |this, cx| match launch_result {
+                                    Ok(()) => {
+                                        this.hide_main_and_reset(cx);
+                                    }
+                                    Err(message) => {
+                                        this.show_hud(message, Some(3000), cx);
+                                    }
+                                })
+                                .ok();
+                            })
+                            .detach();
                         } else {
                             self.show_hud(
                                 "Scriptlet has no source file path".to_string(),
@@ -1964,9 +2112,24 @@
                             // Extract just the path without the anchor
                             let path_str = file_path.split('#').next().unwrap_or(file_path);
                             let path = std::path::Path::new(path_str);
-                            self.reveal_in_finder(path);
-                            self.show_hud("Opened in Finder".to_string(), Some(1500), cx);
-                            self.hide_main_and_reset(cx);
+                            let reveal_result_rx = self.reveal_in_finder_with_feedback_async(path);
+                            cx.spawn(async move |this, cx| {
+                                let Ok(reveal_result) = reveal_result_rx.recv().await else {
+                                    return;
+                                };
+
+                                this.update(cx, |this, cx| match reveal_result {
+                                    Ok(()) => {
+                                        this.show_hud("Opened in Finder".to_string(), Some(1500), cx);
+                                        this.hide_main_and_reset(cx);
+                                    }
+                                    Err(message) => {
+                                        this.show_hud(message, Some(2500), cx);
+                                    }
+                                })
+                                .ok();
+                            })
+                            .detach();
                         } else {
                             self.show_hud(
                                 "Scriptlet has no source file path".to_string(),
diff --git a/src/app_actions/tests.rs b/src/app_actions/tests.rs
index 6e1bf7a5d42c8a5885695d94e51511178ec11315..7d9221c13778e3f29cf8798b8da18261b85f5221
--- a/src/app_actions/tests.rs
+++ b/src/app_actions/tests.rs
@@ -6,3 +6,6 @@
 
 #[path = "tests/clipboard_actions_menu_coverage.rs"]
 mod clipboard_actions_menu_coverage;
+
+#[path = "tests/editor_launch_feedback.rs"]
+mod editor_launch_feedback;


thinking
**Inspecting test modules**
exec
/bin/zsh -lc "sed -n '1,220p' src/lib.rs" in /Users/johnlindquist/dev/script-kit-gpui succeeded in 52ms:
#![allow(unexpected_cfgs)]
#![recursion_limit = "2048"]

//! Script Kit GPUI - A GPUI-based launcher for Script Kit
//!
//! This library provides the core functionality for executing scripts
//! with bidirectional JSONL communication.

// Actions - Reusable action dialog component
// Provides ActionsDialog with configurable layout for script actions, AI command bar, etc.
pub mod actions;

// App Shell - Unified frame and chrome for all prompts
// Provides ShellSpec, HeaderSpec, FooterSpec, ChromeSpec for consistent prompt layout
pub mod app_shell;

#[cfg(target_os = "macos")]
pub mod camera;
pub mod components;
pub mod config;
file update:
diff --git a/src/app_actions/handle_action.rs b/src/app_actions/handle_action.rs
index 6512e920f98eb38811debb5dca005d821b3adb44..dda46dd268dc9fe3130c27b221485ba871f1c703
--- a/src/app_actions/handle_action.rs
+++ b/src/app_actions/handle_action.rs
@@ -32,6 +32,109 @@
         });
     }
 
+    /// Reveal a path and return completion back to the UI thread for HUD feedback.
+    fn reveal_in_finder_with_feedback_async(
+        &self,
+        path: &std::path::Path,
+    ) -> async_channel::Receiver<Result<(), String>> {
+        let path_str = path.to_string_lossy().to_string();
+        let (result_tx, result_rx) = async_channel::bounded::<Result<(), String>>(1);
+
+        std::thread::spawn(move || {
+            let file_manager = if cfg!(target_os = "macos") {
+                "Finder"
+            } else if cfg!(target_os = "windows") {
+                "Explorer"
+            } else {
+                "File Manager"
+            };
+
+            logging::log(
+                "UI",
+                &format!(
+                    "ACTION_REVEAL_IN_FINDER_START file_manager='{}' path='{}'",
+                    file_manager, path_str
+                ),
+            );
+
+            let reveal_result = match crate::file_search::reveal_in_finder(&path_str) {
+                Ok(()) => {
+                    logging::log(
+                        "UI",
+                        &format!(
+                            "ACTION_REVEAL_IN_FINDER_SUCCESS file_manager='{}' path='{}'",
+                            file_manager, path_str
+                        ),
+                    );
+                    Ok(())
+                }
+                Err(error) => {
+                    logging::log(
+                        "ERROR",
+                        &format!(
+                            "ACTION_REVEAL_IN_FINDER_FAILED attempted='reveal_in_finder' path='{}' file_manager='{}' error='{}'",
+                            path_str, file_manager, error
+                        ),
+                    );
+                    Err(format!("Failed to reveal in {}: {}", file_manager, error))
+                }
+            };
+
+            let _ = result_tx.send_blocking(reveal_result);
+        });
+
+        result_rx
+    }
+
+    /// Launch the configured editor and return completion back to the UI thread for HUD feedback.
+    fn launch_editor_with_feedback_async(
+        &self,
+        path: &std::path::Path,
+    ) -> async_channel::Receiver<Result<(), String>> {
+        let editor = self.config.get_editor();
+        let path_str = path.to_string_lossy().to_string();
+        let (result_tx, result_rx) = async_channel::bounded::<Result<(), String>>(1);
+
+        std::thread::spawn(move || {
+            use std::process::Command;
+
+            logging::log(
+                "UI",
+                &format!(
+                    "ACTION_EDITOR_LAUNCH_START editor='{}' path='{}'",
+                    editor, path_str
+                ),
+            );
+
+            let launch_result = match Command::new(&editor).arg(&path_str).spawn() {
+                Ok(_) => {
+                    logging::log(
+                        "UI",
+                        &format!(
+                            "ACTION_EDITOR_LAUNCH_SUCCESS editor='{}' path='{}'",
+                            editor, path_str
+                        ),
+                    );
+                    Ok(())
+                }
+                Err(error) => {
+                    logging::log(
+                        "ERROR",
+                        &format!(
+                            "ACTION_EDITOR_LAUNCH_FAILED attempted='{} {}' path='{}' error='{}'",
+                            editor, path_str, path_str, error
+                        ),
+                    );
+                    Err(format!("Failed to open in {}: {}", editor, error))
+                }
+            };
+
+            let _ = result_tx.send_blocking(launch_result);
+        });
+
+        result_rx
+    }
+
     /// Copy text to clipboard using pbcopy on macOS.
     /// Critical: This properly closes stdin before waiting to prevent hangs.
     #[cfg(target_os = "macos")]
@@ -471,9 +574,24 @@
                 };
 
                 if let Some(path) = path_opt {
-                    self.reveal_in_finder(&path);
-                    self.show_hud("Opened in Finder".to_string(), Some(1500), cx);
-                    self.hide_main_and_reset(cx);
+                    let reveal_result_rx = self.reveal_in_finder_with_feedback_async(&path);
+                    cx.spawn(async move |this, cx| {
+                        let Ok(reveal_result) = reveal_result_rx.recv().await else {
+                            return;
+                        };
+
+                        this.update(cx, |this, cx| match reveal_result {
+                            Ok(()) => {
+                                this.show_hud("Opened in Finder".to_string(), Some(1500), cx);
+                                this.hide_main_and_reset(cx);
+                            }
+                            Err(message) => {
+                                this.show_hud(message, Some(2500), cx);
+                            }
+                        })
+                        .ok();
+                    })
+                    .detach();
                 } else {
                     self.show_hud(
                         "Cannot reveal this item type in Finder".to_string(),
@@ -884,8 +1002,23 @@
                     };
 
                     if let Some(path) = path_opt {
-                        self.edit_script(&path);
-                        self.hide_main_and_reset(cx);
+                        let editor_launch_rx = self.launch_editor_with_feedback_async(&path);
+                        cx.spawn(async move |this, cx| {
+                            let Ok(launch_result) = editor_launch_rx.recv().await else {
+                                return;
+                            };
+
+                            this.update(cx, |this, cx| match launch_result {
+                                Ok(()) => {
+                                    this.hide_main_and_reset(cx);
+                                }
+                                Err(message) => {
+                                    this.show_hud(message, Some(3000), cx);
+                                }
+                            })
+                            .ok();
+                        })
+                        .detach();
                     } else {
                         self.show_hud("Cannot edit this item type".to_string(), Some(2000), cx);
                     }
@@ -1932,8 +2065,23 @@
                             // Extract just the path without the anchor (e.g., "/path/to/file.md#slug" -> "/path/to/file.md")
                             let path_str = file_path.split('#').next().unwrap_or(file_path);
                             let path = std::path::PathBuf::from(path_str);
-                            self.edit_script(&path);
-                            self.hide_main_and_reset(cx);
+                            let editor_launch_rx = self.launch_editor_with_feedback_async(&path);
+                            cx.spawn(async move |this, cx| {
+                                let Ok(launch_result) = editor_launch_rx.recv().await else {
+                                    return;
+                                };
+
+                                this.update(cx, |this, cx| match launch_result {
+                                    Ok(()) => {
+                                        this.hide_main_and_reset(cx);
+                                    }
+                                    Err(message) => {
+                                        this.show_hud(message, Some(3000), cx);
+                                    }
+                                })
+                                .ok();
+                            })
+                            .detach();
                         } else {
                             self.show_hud(
                                 "Scriptlet has no source file path".to_string(),
@@ -1964,9 +2112,24 @@
                             // Extract just the path without the anchor
                             let path_str = file_path.split('#').next().unwrap_or(file_path);
                             let path = std::path::Path::new(path_str);
-                            self.reveal_in_finder(path);
-                            self.show_hud("Opened in Finder".to_string(), Some(1500), cx);
-                            self.hide_main_and_reset(cx);
+                            let reveal_result_rx = self.reveal_in_finder_with_feedback_async(path);
+                            cx.spawn(async move |this, cx| {
+                                let Ok(reveal_result) = reveal_result_rx.recv().await else {
+                                    return;
+                                };
+
+                                this.update(cx, |this, cx| match reveal_result {
+                                    Ok(()) => {
+                                        this.show_hud("Opened in Finder".to_string(), Some(1500), cx);
+                                        this.hide_main_and_reset(cx);
+                                    }
+                                    Err(message) => {
+                                        this.show_hud(message, Some(2500), cx);
+                                    }
+                                })
+                                .ok();
+                            })
+                            .detach();
                         } else {
                             self.show_hud(
                                 "Scriptlet has no source file path".to_string(),
diff --git a/src/app_actions/tests.rs b/src/app_actions/tests.rs
index 6e1bf7a5d42c8a5885695d94e51511178ec11315..7d9221c13778e3f29cf8798b8da18261b85f5221
--- a/src/app_actions/tests.rs
+++ b/src/app_actions/tests.rs
@@ -6,3 +6,6 @@
 
 #[path = "tests/clipboard_actions_menu_coverage.rs"]
 mod clipboard_actions_menu_coverage;
+
+#[path = "tests/editor_launch_feedback.rs"]
+mod editor_launch_feedback;


thinking
**Searching test modules structure**
exec
/bin/zsh -lc "rg -n \"app_actions/tests.rs|mod app_actions_tests|\\[path = \\\"app_actions/tests.rs\\\"\\]|include"'!'"\\(\\\"app_actions/tests.rs\\\"\\)\" src -g'*.rs'" in /Users/johnlindquist/dev/script-kit-gpui succeeded in 50ms:
src/app_actions/helpers.rs:165:mod app_actions_tests {
file update:
diff --git a/src/app_actions/handle_action.rs b/src/app_actions/handle_action.rs
index 6512e920f98eb38811debb5dca005d821b3adb44..dda46dd268dc9fe3130c27b221485ba871f1c703
--- a/src/app_actions/handle_action.rs
+++ b/src/app_actions/handle_action.rs
@@ -32,6 +32,109 @@
         });
     }
 
+    /// Reveal a path and return completion back to the UI thread for HUD feedback.
+    fn reveal_in_finder_with_feedback_async(
+        &self,
+        path: &std::path::Path,
+    ) -> async_channel::Receiver<Result<(), String>> {
+        let path_str = path.to_string_lossy().to_string();
+        let (result_tx, result_rx) = async_channel::bounded::<Result<(), String>>(1);
+
+        std::thread::spawn(move || {
+            let file_manager = if cfg!(target_os = "macos") {
+                "Finder"
+            } else if cfg!(target_os = "windows") {
+                "Explorer"
+            } else {
+                "File Manager"
+            };
+
+            logging::log(
+                "UI",
+                &format!(
+                    "ACTION_REVEAL_IN_FINDER_START file_manager='{}' path='{}'",
+                    file_manager, path_str
+                ),
+            );
+
+            let reveal_result = match crate::file_search::reveal_in_finder(&path_str) {
+                Ok(()) => {
+                    logging::log(
+                        "UI",
+                        &format!(
+                            "ACTION_REVEAL_IN_FINDER_SUCCESS file_manager='{}' path='{}'",
+                            file_manager, path_str
+                        ),
+                    );
+                    Ok(())
+                }
+                Err(error) => {
+                    logging::log(
+                        "ERROR",
+                        &format!(
+                            "ACTION_REVEAL_IN_FINDER_FAILED attempted='reveal_in_finder' path='{}' file_manager='{}' error='{}'",
+                            path_str, file_manager, error
+                        ),
+                    );
+                    Err(format!("Failed to reveal in {}: {}", file_manager, error))
+                }
+            };
+
+            let _ = result_tx.send_blocking(reveal_result);
+        });
+
+        result_rx
+    }
+
+    /// Launch the configured editor and return completion back to the UI thread for HUD feedback.
+    fn launch_editor_with_feedback_async(
+        &self,
+        path: &std::path::Path,
+    ) -> async_channel::Receiver<Result<(), String>> {
+        let editor = self.config.get_editor();
+        let path_str = path.to_string_lossy().to_string();
+        let (result_tx, result_rx) = async_channel::bounded::<Result<(), String>>(1);
+
+        std::thread::spawn(move || {
+            use std::process::Command;
+
+            logging::log(
+                "UI",
+                &format!(
+                    "ACTION_EDITOR_LAUNCH_START editor='{}' path='{}'",
+                    editor, path_str
+                ),
+            );
+
+            let launch_result = match Command::new(&editor).arg(&path_str).spawn() {
+                Ok(_) => {
+                    logging::log(
+                        "UI",
+                        &format!(
+                            "ACTION_EDITOR_LAUNCH_SUCCESS editor='{}' path='{}'",
+                            editor, path_str
+                        ),
+                    );
+                    Ok(())
+                }
+                Err(error) => {
+                    logging::log(
+                        "ERROR",
+                        &format!(
+                            "ACTION_EDITOR_LAUNCH_FAILED attempted='{} {}' path='{}' error='{}'",
+                            editor, path_str, path_str, error
+                        ),
+                    );
+                    Err(format!("Failed to open in {}: {}", editor, error))
+                }
+            };
+
+            let _ = result_tx.send_blocking(launch_result);
+        });
+
+        result_rx
+    }
+
     /// Copy text to clipboard using pbcopy on macOS.
     /// Critical: This properly closes stdin before waiting to prevent hangs.
     #[cfg(target_os = "macos")]
@@ -471,9 +574,24 @@
                 };
 
                 if let Some(path) = path_opt {
-                    self.reveal_in_finder(&path);
-                    self.show_hud("Opened in Finder".to_string(), Some(1500), cx);
-                    self.hide_main_and_reset(cx);
+                    let reveal_result_rx = self.reveal_in_finder_with_feedback_async(&path);
+                    cx.spawn(async move |this, cx| {
+                        let Ok(reveal_result) = reveal_result_rx.recv().await else {
+                            return;
+                        };
+
+                        this.update(cx, |this, cx| match reveal_result {
+                            Ok(()) => {
+                                this.show_hud("Opened in Finder".to_string(), Some(1500), cx);
+                                this.hide_main_and_reset(cx);
+                            }
+                            Err(message) => {
+                                this.show_hud(message, Some(2500), cx);
+                            }
+                        })
+                        .ok();
+                    })
+                    .detach();
                 } else {
                     self.show_hud(
                         "Cannot reveal this item type in Finder".to_string(),
@@ -884,8 +1002,23 @@
                     };
 
                     if let Some(path) = path_opt {
-                        self.edit_script(&path);
-                        self.hide_main_and_reset(cx);
+                        let editor_launch_rx = self.launch_editor_with_feedback_async(&path);
+                        cx.spawn(async move |this, cx| {
+                            let Ok(launch_result) = editor_launch_rx.recv().await else {
+                                return;
+                            };
+
+                            this.update(cx, |this, cx| match launch_result {
+                                Ok(()) => {
+                                    this.hide_main_and_reset(cx);
+                                }
+                                Err(message) => {
+                                    this.show_hud(message, Some(3000), cx);
+                                }
+                            })
+                            .ok();
+                        })
+                        .detach();
                     } else {
                         self.show_hud("Cannot edit this item type".to_string(), Some(2000), cx);
                     }
@@ -1932,8 +2065,23 @@
                             // Extract just the path without the anchor (e.g., "/path/to/file.md#slug" -> "/path/to/file.md")
                             let path_str = file_path.split('#').next().unwrap_or(file_path);
                             let path = std::path::PathBuf::from(path_str);
-                            self.edit_script(&path);
-                            self.hide_main_and_reset(cx);
+                            let editor_launch_rx = self.launch_editor_with_feedback_async(&path);
+                            cx.spawn(async move |this, cx| {
+                                let Ok(launch_result) = editor_launch_rx.recv().await else {
+                                    return;
+                                };
+
+                                this.update(cx, |this, cx| match launch_result {
+                                    Ok(()) => {
+                                        this.hide_main_and_reset(cx);
+                                    }
+                                    Err(message) => {
+                                        this.show_hud(message, Some(3000), cx);
+                                    }
+                                })
+                                .ok();
+                            })
+                            .detach();
                         } else {
                             self.show_hud(
                                 "Scriptlet has no source file path".to_string(),
@@ -1964,9 +2112,24 @@
                             // Extract just the path without the anchor
                             let path_str = file_path.split('#').next().unwrap_or(file_path);
                             let path = std::path::Path::new(path_str);
-                            self.reveal_in_finder(path);
-                            self.show_hud("Opened in Finder".to_string(), Some(1500), cx);
-                            self.hide_main_and_reset(cx);
+                            let reveal_result_rx = self.reveal_in_finder_with_feedback_async(path);
+                            cx.spawn(async move |this, cx| {
+                                let Ok(reveal_result) = reveal_result_rx.recv().await else {
+                                    return;
+                                };
+
+                                this.update(cx, |this, cx| match reveal_result {
+                                    Ok(()) => {
+                                        this.show_hud("Opened in Finder".to_string(), Some(1500), cx);
+                                        this.hide_main_and_reset(cx);
+                                    }
+                                    Err(message) => {
+                                        this.show_hud(message, Some(2500), cx);
+                                    }
+                                })
+                                .ok();
+                            })
+                            .detach();
                         } else {
                             self.show_hud(
                                 "Scriptlet has no source file path".to_string(),
diff --git a/src/app_actions/tests.rs b/src/app_actions/tests.rs
index 6e1bf7a5d42c8a5885695d94e51511178ec11315..7d9221c13778e3f29cf8798b8da18261b85f5221
--- a/src/app_actions/tests.rs
+++ b/src/app_actions/tests.rs
@@ -6,3 +6,6 @@
 
 #[path = "tests/clipboard_actions_menu_coverage.rs"]
 mod clipboard_actions_menu_coverage;
+
+#[path = "tests/editor_launch_feedback.rs"]
+mod editor_launch_feedback;


thinking
**Exploring related test files**
exec
/bin/zsh -lc "sed -n '140,240p' src/app_actions/helpers.rs" in /Users/johnlindquist/dev/script-kit-gpui succeeded in 52ms:
        let status = std::process::Command::new("osascript")
            .args(["-e", &script])
            .status()
            .map_err(|err| format!("failed to launch osascript: {err}"))?;

        if status.success() {
            Ok(())
        } else {
            Err(format!("osascript exited with status {}", status))
        }
    }

    #[cfg(not(target_os = "macos"))]
    {
        if path.is_dir() {
            std::fs::remove_dir_all(path)
                .map_err(|err| format!("failed to remove directory '{}': {err}", path.display()))
        } else {
            std::fs::remove_file(path)
                .map_err(|err| format!("failed to remove file '{}': {err}", path.display()))
file update:
diff --git a/src/app_actions/handle_action.rs b/src/app_actions/handle_action.rs
index 6512e920f98eb38811debb5dca005d821b3adb44..dda46dd268dc9fe3130c27b221485ba871f1c703
--- a/src/app_actions/handle_action.rs
+++ b/src/app_actions/handle_action.rs
@@ -32,6 +32,109 @@
         });
     }
 
+    /// Reveal a path and return completion back to the UI thread for HUD feedback.
+    fn reveal_in_finder_with_feedback_async(
+        &self,
+        path: &std::path::Path,
+    ) -> async_channel::Receiver<Result<(), String>> {
+        let path_str = path.to_string_lossy().to_string();
+        let (result_tx, result_rx) = async_channel::bounded::<Result<(), String>>(1);
+
+        std::thread::spawn(move || {
+            let file_manager = if cfg!(target_os = "macos") {
+                "Finder"
+            } else if cfg!(target_os = "windows") {
+                "Explorer"
+            } else {
+                "File Manager"
+            };
+
+            logging::log(
+                "UI",
+                &format!(
+                    "ACTION_REVEAL_IN_FINDER_START file_manager='{}' path='{}'",
+                    file_manager, path_str
+                ),
+            );
+
+            let reveal_result = match crate::file_search::reveal_in_finder(&path_str) {
+                Ok(()) => {
+                    logging::log(
+                        "UI",
+                        &format!(
+                            "ACTION_REVEAL_IN_FINDER_SUCCESS file_manager='{}' path='{}'",
+                            file_manager, path_str
+                        ),
+                    );
+                    Ok(())
+                }
+                Err(error) => {
+                    logging::log(
+                        "ERROR",
+                        &format!(
+                            "ACTION_REVEAL_IN_FINDER_FAILED attempted='reveal_in_finder' path='{}' file_manager='{}' error='{}'",
+                            path_str, file_manager, error
+                        ),
+                    );
+                    Err(format!("Failed to reveal in {}: {}", file_manager, error))
+                }
+            };
+
+            let _ = result_tx.send_blocking(reveal_result);
+        });
+
+        result_rx
+    }
+
+    /// Launch the configured editor and return completion back to the UI thread for HUD feedback.
+    fn launch_editor_with_feedback_async(
+        &self,
+        path: &std::path::Path,
+    ) -> async_channel::Receiver<Result<(), String>> {
+        let editor = self.config.get_editor();
+        let path_str = path.to_string_lossy().to_string();
+        let (result_tx, result_rx) = async_channel::bounded::<Result<(), String>>(1);
+
+        std::thread::spawn(move || {
+            use std::process::Command;
+
+            logging::log(
+                "UI",
+                &format!(
+                    "ACTION_EDITOR_LAUNCH_START editor='{}' path='{}'",
+                    editor, path_str
+                ),
+            );
+
+            let launch_result = match Command::new(&editor).arg(&path_str).spawn() {
+                Ok(_) => {
+                    logging::log(
+                        "UI",
+                        &format!(
+                            "ACTION_EDITOR_LAUNCH_SUCCESS editor='{}' path='{}'",
+                            editor, path_str
+                        ),
+                    );
+                    Ok(())
+                }
+                Err(error) => {
+                    logging::log(
+                        "ERROR",
+                        &format!(
+                            "ACTION_EDITOR_LAUNCH_FAILED attempted='{} {}' path='{}' error='{}'",
+                            editor, path_str, path_str, error
+                        ),
+                    );
+                    Err(format!("Failed to open in {}: {}", editor, error))
+                }
+            };
+
+            let _ = result_tx.send_blocking(launch_result);
+        });
+
+        result_rx
+    }
+
     /// Copy text to clipboard using pbcopy on macOS.
     /// Critical: This properly closes stdin before waiting to prevent hangs.
     #[cfg(target_os = "macos")]
@@ -471,9 +574,24 @@
                 };
 
                 if let Some(path) = path_opt {
-                    self.reveal_in_finder(&path);
-                    self.show_hud("Opened in Finder".to_string(), Some(1500), cx);
-                    self.hide_main_and_reset(cx);
+                    let reveal_result_rx = self.reveal_in_finder_with_feedback_async(&path);
+                    cx.spawn(async move |this, cx| {
+                        let Ok(reveal_result) = reveal_result_rx.recv().await else {
+                            return;
+                        };
+
+                        this.update(cx, |this, cx| match reveal_result {
+                            Ok(()) => {
+                                this.show_hud("Opened in Finder".to_string(), Some(1500), cx);
+                                this.hide_main_and_reset(cx);
+                            }
+                            Err(message) => {
+                                this.show_hud(message, Some(2500), cx);
+                            }
+                        })
+                        .ok();
+                    })
+                    .detach();
                 } else {
                     self.show_hud(
                         "Cannot reveal this item type in Finder".to_string(),
@@ -884,8 +1002,23 @@
                     };
 
                     if let Some(path) = path_opt {
-                        self.edit_script(&path);
-                        self.hide_main_and_reset(cx);
+                        let editor_launch_rx = self.launch_editor_with_feedback_async(&path);
+                        cx.spawn(async move |this, cx| {
+                            let Ok(launch_result) = editor_launch_rx.recv().await else {
+                                return;
+                            };
+
+                            this.update(cx, |this, cx| match launch_result {
+                                Ok(()) => {
+                                    this.hide_main_and_reset(cx);
+                                }
+                                Err(message) => {
+                                    this.show_hud(message, Some(3000), cx);
+                                }
+                            })
+                            .ok();
+                        })
+                        .detach();
                     } else {
                         self.show_hud("Cannot edit this item type".to_string(), Some(2000), cx);
                     }
@@ -1932,8 +2065,23 @@
                             // Extract just the path without the anchor (e.g., "/path/to/file.md#slug" -> "/path/to/file.md")
                             let path_str = file_path.split('#').next().unwrap_or(file_path);
                             let path = std::path::PathBuf::from(path_str);
-                            self.edit_script(&path);
-                            self.hide_main_and_reset(cx);
+                            let editor_launch_rx = self.launch_editor_with_feedback_async(&path);
+                            cx.spawn(async move |this, cx| {
+                                let Ok(launch_result) = editor_launch_rx.recv().await else {
+                                    return;
+                                };
+
+                                this.update(cx, |this, cx| match launch_result {
+                                    Ok(()) => {
+                                        this.hide_main_and_reset(cx);
+                                    }
+                                    Err(message) => {
+                                        this.show_hud(message, Some(3000), cx);
+                                    }
+                                })
+                                .ok();
+                            })
+                            .detach();
                         } else {
                             self.show_hud(
                                 "Scriptlet has no source file path".to_string(),
@@ -1964,9 +2112,24 @@
                             // Extract just the path without the anchor
                             let path_str = file_path.split('#').next().unwrap_or(file_path);
                             let path = std::path::Path::new(path_str);
-                            self.reveal_in_finder(path);
-                            self.show_hud("Opened in Finder".to_string(), Some(1500), cx);
-                            self.hide_main_and_reset(cx);
+                            let reveal_result_rx = self.reveal_in_finder_with_feedback_async(path);
+                            cx.spawn(async move |this, cx| {
+                                let Ok(reveal_result) = reveal_result_rx.recv().await else {
+                                    return;
+                                };
+
+                                this.update(cx, |this, cx| match reveal_result {
+                                    Ok(()) => {
+                                        this.show_hud("Opened in Finder".to_string(), Some(1500), cx);
+                                        this.hide_main_and_reset(cx);
+                                    }
+                                    Err(message) => {
+                                        this.show_hud(message, Some(2500), cx);
+                                    }
+                                })
+                                .ok();
+                            })
+                            .detach();
                         } else {
                             self.show_hud(
                                 "Scriptlet has no source file path".to_string(),
diff --git a/src/app_actions/tests.rs b/src/app_actions/tests.rs
index 6e1bf7a5d42c8a5885695d94e51511178ec11315..7d9221c13778e3f29cf8798b8da18261b85f5221
--- a/src/app_actions/tests.rs
+++ b/src/app_actions/tests.rs
@@ -6,3 +6,6 @@
 
 #[path = "tests/clipboard_actions_menu_coverage.rs"]
 mod clipboard_actions_menu_coverage;
+
+#[path = "tests/editor_launch_feedback.rs"]
+mod editor_launch_feedback;


thinking
**Checking test inclusion in app_actions**
exec
/bin/zsh -lc 'cat src/app_actions.rs' in /Users/johnlindquist/dev/script-kit-gpui succeeded in 51ms:
// App actions methods split into sub-files for maintainability
include!("app_actions/helpers.rs");
include!("app_actions/handle_action.rs");
include!("app_actions/sdk_actions.rs");
file update:
diff --git a/src/app_actions/handle_action.rs b/src/app_actions/handle_action.rs
index 6512e920f98eb38811debb5dca005d821b3adb44..dda46dd268dc9fe3130c27b221485ba871f1c703
--- a/src/app_actions/handle_action.rs
+++ b/src/app_actions/handle_action.rs
@@ -32,6 +32,109 @@
         });
     }
 
+    /// Reveal a path and return completion back to the UI thread for HUD feedback.
+    fn reveal_in_finder_with_feedback_async(
+        &self,
+        path: &std::path::Path,
+    ) -> async_channel::Receiver<Result<(), String>> {
+        let path_str = path.to_string_lossy().to_string();
+        let (result_tx, result_rx) = async_channel::bounded::<Result<(), String>>(1);
+
+        std::thread::spawn(move || {
+            let file_manager = if cfg!(target_os = "macos") {
+                "Finder"
+            } else if cfg!(target_os = "windows") {
+                "Explorer"
+            } else {
+                "File Manager"
+            };
+
+            logging::log(
+                "UI",
+                &format!(
+                    "ACTION_REVEAL_IN_FINDER_START file_manager='{}' path='{}'",
+                    file_manager, path_str
+                ),
+            );
+
+            let reveal_result = match crate::file_search::reveal_in_finder(&path_str) {
+                Ok(()) => {
+                    logging::log(
+                        "UI",
+                        &format!(
+                            "ACTION_REVEAL_IN_FINDER_SUCCESS file_manager='{}' path='{}'",
+                            file_manager, path_str
+                        ),
+                    );
+                    Ok(())
+                }
+                Err(error) => {
+                    logging::log(
+                        "ERROR",
+                        &format!(
+                            "ACTION_REVEAL_IN_FINDER_FAILED attempted='reveal_in_finder' path='{}' file_manager='{}' error='{}'",
+                            path_str, file_manager, error
+                        ),
+                    );
+                    Err(format!("Failed to reveal in {}: {}", file_manager, error))
+                }
+            };
+
+            let _ = result_tx.send_blocking(reveal_result);
+        });
+
+        result_rx
+    }
+
+    /// Launch the configured editor and return completion back to the UI thread for HUD feedback.
+    fn launch_editor_with_feedback_async(
+        &self,
+        path: &std::path::Path,
+    ) -> async_channel::Receiver<Result<(), String>> {
+        let editor = self.config.get_editor();
+        let path_str = path.to_string_lossy().to_string();
+        let (result_tx, result_rx) = async_channel::bounded::<Result<(), String>>(1);
+
+        std::thread::spawn(move || {
+            use std::process::Command;
+
+            logging::log(
+                "UI",
+                &format!(
+                    "ACTION_EDITOR_LAUNCH_START editor='{}' path='{}'",
+                    editor, path_str
+                ),
+            );
+
+            let launch_result = match Command::new(&editor).arg(&path_str).spawn() {
+                Ok(_) => {
+                    logging::log(
+                        "UI",
+                        &format!(
+                            "ACTION_EDITOR_LAUNCH_SUCCESS editor='{}' path='{}'",
+                            editor, path_str
+                        ),
+                    );
+                    Ok(())
+                }
+                Err(error) => {
+                    logging::log(
+                        "ERROR",
+                        &format!(
+                            "ACTION_EDITOR_LAUNCH_FAILED attempted='{} {}' path='{}' error='{}'",
+                            editor, path_str, path_str, error
+                        ),
+                    );
+                    Err(format!("Failed to open in {}: {}", editor, error))
+                }
+            };
+
+            let _ = result_tx.send_blocking(launch_result);
+        });
+
+        result_rx
+    }
+
     /// Copy text to clipboard using pbcopy on macOS.
     /// Critical: This properly closes stdin before waiting to prevent hangs.
     #[cfg(target_os = "macos")]
@@ -471,9 +574,24 @@
                 };
 
                 if let Some(path) = path_opt {
-                    self.reveal_in_finder(&path);
-                    self.show_hud("Opened in Finder".to_string(), Some(1500), cx);
-                    self.hide_main_and_reset(cx);
+                    let reveal_result_rx = self.reveal_in_finder_with_feedback_async(&path);
+                    cx.spawn(async move |this, cx| {
+                        let Ok(reveal_result) = reveal_result_rx.recv().await else {
+                            return;
+                        };
+
+                        this.update(cx, |this, cx| match reveal_result {
+                            Ok(()) => {
+                                this.show_hud("Opened in Finder".to_string(), Some(1500), cx);
+                                this.hide_main_and_reset(cx);
+                            }
+                            Err(message) => {
+                                this.show_hud(message, Some(2500), cx);
+                            }
+                        })
+                        .ok();
+                    })
+                    .detach();
                 } else {
                     self.show_hud(
                         "Cannot reveal this item type in Finder".to_string(),
@@ -884,8 +1002,23 @@
                     };
 
                     if let Some(path) = path_opt {
-                        self.edit_script(&path);
-                        self.hide_main_and_reset(cx);
+                        let editor_launch_rx = self.launch_editor_with_feedback_async(&path);
+                        cx.spawn(async move |this, cx| {
+                            let Ok(launch_result) = editor_launch_rx.recv().await else {
+                                return;
+                            };
+
+                            this.update(cx, |this, cx| match launch_result {
+                                Ok(()) => {
+                                    this.hide_main_and_reset(cx);
+                                }
+                                Err(message) => {
+                                    this.show_hud(message, Some(3000), cx);
+                                }
+                            })
+                            .ok();
+                        })
+                        .detach();
                     } else {
                         self.show_hud("Cannot edit this item type".to_string(), Some(2000), cx);
                     }
@@ -1932,8 +2065,23 @@
                             // Extract just the path without the anchor (e.g., "/path/to/file.md#slug" -> "/path/to/file.md")
                             let path_str = file_path.split('#').next().unwrap_or(file_path);
                             let path = std::path::PathBuf::from(path_str);
-                            self.edit_script(&path);
-                            self.hide_main_and_reset(cx);
+                            let editor_launch_rx = self.launch_editor_with_feedback_async(&path);
+                            cx.spawn(async move |this, cx| {
+                                let Ok(launch_result) = editor_launch_rx.recv().await else {
+                                    return;
+                                };
+
+                                this.update(cx, |this, cx| match launch_result {
+                                    Ok(()) => {
+                                        this.hide_main_and_reset(cx);
+                                    }
+                                    Err(message) => {
+                                        this.show_hud(message, Some(3000), cx);
+                                    }
+                                })
+                                .ok();
+                            })
+                            .detach();
                         } else {
                             self.show_hud(
                                 "Scriptlet has no source file path".to_string(),
@@ -1964,9 +2112,24 @@
                             // Extract just the path without the anchor
                             let path_str = file_path.split('#').next().unwrap_or(file_path);
                             let path = std::path::Path::new(path_str);
-                            self.reveal_in_finder(path);
-                            self.show_hud("Opened in Finder".to_string(), Some(1500), cx);
-                            self.hide_main_and_reset(cx);
+                            let reveal_result_rx = self.reveal_in_finder_with_feedback_async(path);
+                            cx.spawn(async move |this, cx| {
+                                let Ok(reveal_result) = reveal_result_rx.recv().await else {
+                                    return;
+                                };
+
+                                this.update(cx, |this, cx| match reveal_result {
+                                    Ok(()) => {
+                                        this.show_hud("Opened in Finder".to_string(), Some(1500), cx);
+                                        this.hide_main_and_reset(cx);
+                                    }
+                                    Err(message) => {
+                                        this.show_hud(message, Some(2500), cx);
+                                    }
+                                })
+                                .ok();
+                            })
+                            .detach();
                         } else {
                             self.show_hud(
                                 "Scriptlet has no source file path".to_string(),
diff --git a/src/app_actions/tests.rs b/src/app_actions/tests.rs
index 6e1bf7a5d42c8a5885695d94e51511178ec11315..7d9221c13778e3f29cf8798b8da18261b85f5221
--- a/src/app_actions/tests.rs
+++ b/src/app_actions/tests.rs
@@ -6,3 +6,6 @@
 
 #[path = "tests/clipboard_actions_menu_coverage.rs"]
 mod clipboard_actions_menu_coverage;
+
+#[path = "tests/editor_launch_feedback.rs"]
+mod editor_launch_feedback;


thinking
**Searching for separate test modules**
exec
/bin/zsh -lc "rg -n \"app_actions/tests\\.rs|app_actions::tests|mod tests;\" src/app_actions.rs src/main.rs src -g'*.rs'" in /Users/johnlindquist/dev/script-kit-gpui succeeded in 51ms:
src/menu_executor/part_001.rs:76:mod tests;
src/notification/mod.rs:24:mod tests;
src/config/editor.rs:16:mod tests;
src/config/mod.rs:52:mod tests;
src/protocol/message/mod.rs:87:mod tests;
src/protocol/io/mod.rs:5:mod tests;
src/icons/mod.rs:57:mod tests;
src/terminal/pty.rs:20:mod tests;
src/protocol/types/mod.rs:43:mod tests;
src/executor/mod.rs:63:mod tests;
src/terminal/alacritty.rs:51:mod tests;
src/terminal/command_bar_ui.rs:19:mod tests;
src/terminal/command_bar.rs:27:mod tests;
src/designs/core/part_04.rs:2:mod tests;
src/terminal/theme_adapter.rs:32:mod tests;
src/ai/window.rs:82:mod tests;
src/prompts/select/mod.rs:36:mod tests;
src/prompts/env/mod.rs:35:mod tests;
src/prompts/template/mod.rs:28:mod tests;
src/components/alias_input.rs:27:mod tests;
file update:
diff --git a/src/app_actions/handle_action.rs b/src/app_actions/handle_action.rs
index 6512e920f98eb38811debb5dca005d821b3adb44..dda46dd268dc9fe3130c27b221485ba871f1c703
--- a/src/app_actions/handle_action.rs
+++ b/src/app_actions/handle_action.rs
@@ -32,6 +32,109 @@
         });
     }
 
+    /// Reveal a path and return completion back to the UI thread for HUD feedback.
+    fn reveal_in_finder_with_feedback_async(
+        &self,
+        path: &std::path::Path,
+    ) -> async_channel::Receiver<Result<(), String>> {
+        let path_str = path.to_string_lossy().to_string();
+        let (result_tx, result_rx) = async_channel::bounded::<Result<(), String>>(1);
+
+        std::thread::spawn(move || {
+            let file_manager = if cfg!(target_os = "macos") {
+                "Finder"
+            } else if cfg!(target_os = "windows") {
+                "Explorer"
+            } else {
+                "File Manager"
+            };
+
+            logging::log(
+                "UI",
+                &format!(
+                    "ACTION_REVEAL_IN_FINDER_START file_manager='{}' path='{}'",
+                    file_manager, path_str
+                ),
+            );
+
+            let reveal_result = match crate::file_search::reveal_in_finder(&path_str) {
+                Ok(()) => {
+                    logging::log(
+                        "UI",
+                        &format!(
+                            "ACTION_REVEAL_IN_FINDER_SUCCESS file_manager='{}' path='{}'",
+                            file_manager, path_str
+                        ),
+                    );
+                    Ok(())
+                }
+                Err(error) => {
+                    logging::log(
+                        "ERROR",
+                        &format!(
+                            "ACTION_REVEAL_IN_FINDER_FAILED attempted='reveal_in_finder' path='{}' file_manager='{}' error='{}'",
+                            path_str, file_manager, error
+                        ),
+                    );
+                    Err(format!("Failed to reveal in {}: {}", file_manager, error))
+                }
+            };
+
+            let _ = result_tx.send_blocking(reveal_result);
+        });
+
+        result_rx
+    }
+
+    /// Launch the configured editor and return completion back to the UI thread for HUD feedback.
+    fn launch_editor_with_feedback_async(
+        &self,
+        path: &std::path::Path,
+    ) -> async_channel::Receiver<Result<(), String>> {
+        let editor = self.config.get_editor();
+        let path_str = path.to_string_lossy().to_string();
+        let (result_tx, result_rx) = async_channel::bounded::<Result<(), String>>(1);
+
+        std::thread::spawn(move || {
+            use std::process::Command;
+
+            logging::log(
+                "UI",
+                &format!(
+                    "ACTION_EDITOR_LAUNCH_START editor='{}' path='{}'",
+                    editor, path_str
+                ),
+            );
+
+            let launch_result = match Command::new(&editor).arg(&path_str).spawn() {
+                Ok(_) => {
+                    logging::log(
+                        "UI",
+                        &format!(
+                            "ACTION_EDITOR_LAUNCH_SUCCESS editor='{}' path='{}'",
+                            editor, path_str
+                        ),
+                    );
+                    Ok(())
+                }
+                Err(error) => {
+                    logging::log(
+                        "ERROR",
+                        &format!(
+                            "ACTION_EDITOR_LAUNCH_FAILED attempted='{} {}' path='{}' error='{}'",
+                            editor, path_str, path_str, error
+                        ),
+                    );
+                    Err(format!("Failed to open in {}: {}", editor, error))
+                }
+            };
+
+            let _ = result_tx.send_blocking(launch_result);
+        });
+
+        result_rx
+    }
+
     /// Copy text to clipboard using pbcopy on macOS.
     /// Critical: This properly closes stdin before waiting to prevent hangs.
     #[cfg(target_os = "macos")]
@@ -471,9 +574,24 @@
                 };
 
                 if let Some(path) = path_opt {
-                    self.reveal_in_finder(&path);
-                    self.show_hud("Opened in Finder".to_string(), Some(1500), cx);
-                    self.hide_main_and_reset(cx);
+                    let reveal_result_rx = self.reveal_in_finder_with_feedback_async(&path);
+                    cx.spawn(async move |this, cx| {
+                        let Ok(reveal_result) = reveal_result_rx.recv().await else {
+                            return;
+                        };
+
+                        this.update(cx, |this, cx| match reveal_result {
+                            Ok(()) => {
+                                this.show_hud("Opened in Finder".to_string(), Some(1500), cx);
+                                this.hide_main_and_reset(cx);
+                            }
+                            Err(message) => {
+                                this.show_hud(message, Some(2500), cx);
+                            }
+                        })
+                        .ok();
+                    })
+                    .detach();
                 } else {
                     self.show_hud(
                         "Cannot reveal this item type in Finder".to_string(),
@@ -884,8 +1002,23 @@
                     };
 
                     if let Some(path) = path_opt {
-                        self.edit_script(&path);
-                        self.hide_main_and_reset(cx);
+                        let editor_launch_rx = self.launch_editor_with_feedback_async(&path);
+                        cx.spawn(async move |this, cx| {
+                            let Ok(launch_result) = editor_launch_rx.recv().await else {
+                                return;
+                            };
+
+                            this.update(cx, |this, cx| match launch_result {
+                                Ok(()) => {
+                                    this.hide_main_and_reset(cx);
+                                }
+                                Err(message) => {
+                                    this.show_hud(message, Some(3000), cx);
+                                }
+                            })
+                            .ok();
+                        })
+                        .detach();
                     } else {
                         self.show_hud("Cannot edit this item type".to_string(), Some(2000), cx);
                     }
@@ -1932,8 +2065,23 @@
                             // Extract just the path without the anchor (e.g., "/path/to/file.md#slug" -> "/path/to/file.md")
                             let path_str = file_path.split('#').next().unwrap_or(file_path);
                             let path = std::path::PathBuf::from(path_str);
-                            self.edit_script(&path);
-                            self.hide_main_and_reset(cx);
+                            let editor_launch_rx = self.launch_editor_with_feedback_async(&path);
+                            cx.spawn(async move |this, cx| {
+                                let Ok(launch_result) = editor_launch_rx.recv().await else {
+                                    return;
+                                };
+
+                                this.update(cx, |this, cx| match launch_result {
+                                    Ok(()) => {
+                                        this.hide_main_and_reset(cx);
+                                    }
+                                    Err(message) => {
+                                        this.show_hud(message, Some(3000), cx);
+                                    }
+                                })
+                                .ok();
+                            })
+                            .detach();
                         } else {
                             self.show_hud(
                                 "Scriptlet has no source file path".to_string(),
@@ -1964,9 +2112,24 @@
                             // Extract just the path without the anchor
                             let path_str = file_path.split('#').next().unwrap_or(file_path);
                             let path = std::path::Path::new(path_str);
-                            self.reveal_in_finder(path);
-                            self.show_hud("Opened in Finder".to_string(), Some(1500), cx);
-                            self.hide_main_and_reset(cx);
+                            let reveal_result_rx = self.reveal_in_finder_with_feedback_async(path);
+                            cx.spawn(async move |this, cx| {
+                                let Ok(reveal_result) = reveal_result_rx.recv().await else {
+                                    return;
+                                };
+
+                                this.update(cx, |this, cx| match reveal_result {
+                                    Ok(()) => {
+                                        this.show_hud("Opened in Finder".to_string(), Some(1500), cx);
+                                        this.hide_main_and_reset(cx);
+                                    }
+                                    Err(message) => {
+                                        this.show_hud(message, Some(2500), cx);
+                                    }
+                                })
+                                .ok();
+                            })
+                            .detach();
                         } else {
                             self.show_hud(
                                 "Scriptlet has no source file path".to_string(),
diff --git a/src/app_actions/tests.rs b/src/app_actions/tests.rs
index 6e1bf7a5d42c8a5885695d94e51511178ec11315..7d9221c13778e3f29cf8798b8da18261b85f5221
--- a/src/app_actions/tests.rs
+++ b/src/app_actions/tests.rs
@@ -6,3 +6,6 @@
 
 #[path = "tests/clipboard_actions_menu_coverage.rs"]
 mod clipboard_actions_menu_coverage;
+
+#[path = "tests/editor_launch_feedback.rs"]
+mod editor_launch_feedback;


thinking
**Assessing test module inclusion**
exec
/bin/zsh -lc "rg -n \"app_actions_tests|actions_button_visibility_tests|clipboard_actions_menu_coverage_tests|app_actions/tests\" src -g'*.rs'" in /Users/johnlindquist/dev/script-kit-gpui succeeded in 51ms:
src/app_actions/helpers.rs:165:mod app_actions_tests {
src/main.rs:38:mod actions_button_visibility_tests;
src/lib.rs:262:mod actions_button_visibility_tests;
src/lib.rs:268:mod clipboard_actions_menu_coverage_tests;
file update:
diff --git a/src/app_actions/handle_action.rs b/src/app_actions/handle_action.rs
index 6512e920f98eb38811debb5dca005d821b3adb44..dda46dd268dc9fe3130c27b221485ba871f1c703
--- a/src/app_actions/handle_action.rs
+++ b/src/app_actions/handle_action.rs
@@ -32,6 +32,109 @@
         });
     }
 
+    /// Reveal a path and return completion back to the UI thread for HUD feedback.
+    fn reveal_in_finder_with_feedback_async(
+        &self,
+        path: &std::path::Path,
+    ) -> async_channel::Receiver<Result<(), String>> {
+        let path_str = path.to_string_lossy().to_string();
+        let (result_tx, result_rx) = async_channel::bounded::<Result<(), String>>(1);
+
+        std::thread::spawn(move || {
+            let file_manager = if cfg!(target_os = "macos") {
+                "Finder"
+            } else if cfg!(target_os = "windows") {
+                "Explorer"
+            } else {
+                "File Manager"
+            };
+
+            logging::log(
+                "UI",
+                &format!(
+                    "ACTION_REVEAL_IN_FINDER_START file_manager='{}' path='{}'",
+                    file_manager, path_str
+                ),
+            );
+
+            let reveal_result = match crate::file_search::reveal_in_finder(&path_str) {
+                Ok(()) => {
+                    logging::log(
+                        "UI",
+                        &format!(
+                            "ACTION_REVEAL_IN_FINDER_SUCCESS file_manager='{}' path='{}'",
+                            file_manager, path_str
+                        ),
+                    );
+                    Ok(())
+                }
+                Err(error) => {
+                    logging::log(
+                        "ERROR",
+                        &format!(
+                            "ACTION_REVEAL_IN_FINDER_FAILED attempted='reveal_in_finder' path='{}' file_manager='{}' error='{}'",
+                            path_str, file_manager, error
+                        ),
+                    );
+                    Err(format!("Failed to reveal in {}: {}", file_manager, error))
+                }
+            };
+
+            let _ = result_tx.send_blocking(reveal_result);
+        });
+
+        result_rx
+    }
+
+    /// Launch the configured editor and return completion back to the UI thread for HUD feedback.
+    fn launch_editor_with_feedback_async(
+        &self,
+        path: &std::path::Path,
+    ) -> async_channel::Receiver<Result<(), String>> {
+        let editor = self.config.get_editor();
+        let path_str = path.to_string_lossy().to_string();
+        let (result_tx, result_rx) = async_channel::bounded::<Result<(), String>>(1);
+
+        std::thread::spawn(move || {
+            use std::process::Command;
+
+            logging::log(
+                "UI",
+                &format!(
+                    "ACTION_EDITOR_LAUNCH_START editor='{}' path='{}'",
+                    editor, path_str
+                ),
+            );
+
+            let launch_result = match Command::new(&editor).arg(&path_str).spawn() {
+                Ok(_) => {
+                    logging::log(
+                        "UI",
+                        &format!(
+                            "ACTION_EDITOR_LAUNCH_SUCCESS editor='{}' path='{}'",
+                            editor, path_str
+                        ),
+                    );
+                    Ok(())
+                }
+                Err(error) => {
+                    logging::log(
+                        "ERROR",
+                        &format!(
+                            "ACTION_EDITOR_LAUNCH_FAILED attempted='{} {}' path='{}' error='{}'",
+                            editor, path_str, path_str, error
+                        ),
+                    );
+                    Err(format!("Failed to open in {}: {}", editor, error))
+                }
+            };
+
+            let _ = result_tx.send_blocking(launch_result);
+        });
+
+        result_rx
+    }
+
     /// Copy text to clipboard using pbcopy on macOS.
     /// Critical: This properly closes stdin before waiting to prevent hangs.
     #[cfg(target_os = "macos")]
@@ -471,9 +574,24 @@
                 };
 
                 if let Some(path) = path_opt {
-                    self.reveal_in_finder(&path);
-                    self.show_hud("Opened in Finder".to_string(), Some(1500), cx);
-                    self.hide_main_and_reset(cx);
+                    let reveal_result_rx = self.reveal_in_finder_with_feedback_async(&path);
+                    cx.spawn(async move |this, cx| {
+                        let Ok(reveal_result) = reveal_result_rx.recv().await else {
+                            return;
+                        };
+
+                        this.update(cx, |this, cx| match reveal_result {
+                            Ok(()) => {
+                                this.show_hud("Opened in Finder".to_string(), Some(1500), cx);
+                                this.hide_main_and_reset(cx);
+                            }
+                            Err(message) => {
+                                this.show_hud(message, Some(2500), cx);
+                            }
+                        })
+                        .ok();
+                    })
+                    .detach();
                 } else {
                     self.show_hud(
                         "Cannot reveal this item type in Finder".to_string(),
@@ -884,8 +1002,23 @@
                     };
 
                     if let Some(path) = path_opt {
-                        self.edit_script(&path);
-                        self.hide_main_and_reset(cx);
+                        let editor_launch_rx = self.launch_editor_with_feedback_async(&path);
+                        cx.spawn(async move |this, cx| {
+                            let Ok(launch_result) = editor_launch_rx.recv().await else {
+                                return;
+                            };
+
+                            this.update(cx, |this, cx| match launch_result {
+                                Ok(()) => {
+                                    this.hide_main_and_reset(cx);
+                                }
+                                Err(message) => {
+                                    this.show_hud(message, Some(3000), cx);
+                                }
+                            })
+                            .ok();
+                        })
+                        .detach();
                     } else {
                         self.show_hud("Cannot edit this item type".to_string(), Some(2000), cx);
                     }
@@ -1932,8 +2065,23 @@
                             // Extract just the path without the anchor (e.g., "/path/to/file.md#slug" -> "/path/to/file.md")
                             let path_str = file_path.split('#').next().unwrap_or(file_path);
                             let path = std::path::PathBuf::from(path_str);
-                            self.edit_script(&path);
-                            self.hide_main_and_reset(cx);
+                            let editor_launch_rx = self.launch_editor_with_feedback_async(&path);
+                            cx.spawn(async move |this, cx| {
+                                let Ok(launch_result) = editor_launch_rx.recv().await else {
+                                    return;
+                                };
+
+                                this.update(cx, |this, cx| match launch_result {
+                                    Ok(()) => {
+                                        this.hide_main_and_reset(cx);
+                                    }
+                                    Err(message) => {
+                                        this.show_hud(message, Some(3000), cx);
+                                    }
+                                })
+                                .ok();
+                            })
+                            .detach();
                         } else {
                             self.show_hud(
                                 "Scriptlet has no source file path".to_string(),
@@ -1964,9 +2112,24 @@
                             // Extract just the path without the anchor
                             let path_str = file_path.split('#').next().unwrap_or(file_path);
                             let path = std::path::Path::new(path_str);
-                            self.reveal_in_finder(path);
-                            self.show_hud("Opened in Finder".to_string(), Some(1500), cx);
-                            self.hide_main_and_reset(cx);
+                            let reveal_result_rx = self.reveal_in_finder_with_feedback_async(path);
+                            cx.spawn(async move |this, cx| {
+                                let Ok(reveal_result) = reveal_result_rx.recv().await else {
+                                    return;
+                                };
+
+                                this.update(cx, |this, cx| match reveal_result {
+                                    Ok(()) => {
+                                        this.show_hud("Opened in Finder".to_string(), Some(1500), cx);
+                                        this.hide_main_and_reset(cx);
+                                    }
+                                    Err(message) => {
+                                        this.show_hud(message, Some(2500), cx);
+                                    }
+                                })
+                                .ok();
+                            })
+                            .detach();
                         } else {
                             self.show_hud(
                                 "Scriptlet has no source file path".to_string(),
diff --git a/src/app_actions/tests.rs b/src/app_actions/tests.rs
index 6e1bf7a5d42c8a5885695d94e51511178ec11315..7d9221c13778e3f29cf8798b8da18261b85f5221
--- a/src/app_actions/tests.rs
+++ b/src/app_actions/tests.rs
@@ -6,3 +6,6 @@
 
 #[path = "tests/clipboard_actions_menu_coverage.rs"]
 mod clipboard_actions_menu_coverage;
+
+#[path = "tests/editor_launch_feedback.rs"]
+mod editor_launch_feedback;


thinking
**Inspecting test file duplication**
exec
/bin/zsh -lc "sed -n '1,220p' src/actions_button_visibility_tests.rs && sed -n '1,220p' src/clipboard_actions_menu_coverage_tests.rs" in /Users/johnlindquist/dev/script-kit-gpui succeeded in 51ms:
//! Regression tests for actions button visibility in the main script list.

#[cfg(test)]
mod tests {
    use std::fs;

    #[test]
    fn test_has_actions_helper_exists_and_handles_clipboard() {
        let content = fs::read_to_string("src/app_actions/handle_action.rs")
            .expect("Failed to read src/app_actions/handle_action.rs");

        assert!(
            content.contains("fn has_actions"),
            "Expected ScriptListApp::has_actions() helper to exist"
        );

        assert!(
            content.contains("ClipboardHistoryView"),
            "has_actions() should account for ClipboardHistoryView selection"
        );
file update:
diff --git a/src/app_actions/handle_action.rs b/src/app_actions/handle_action.rs
index 6512e920f98eb38811debb5dca005d821b3adb44..dda46dd268dc9fe3130c27b221485ba871f1c703
--- a/src/app_actions/handle_action.rs
+++ b/src/app_actions/handle_action.rs
@@ -32,6 +32,109 @@
         });
     }
 
+    /// Reveal a path and return completion back to the UI thread for HUD feedback.
+    fn reveal_in_finder_with_feedback_async(
+        &self,
+        path: &std::path::Path,
+    ) -> async_channel::Receiver<Result<(), String>> {
+        let path_str = path.to_string_lossy().to_string();
+        let (result_tx, result_rx) = async_channel::bounded::<Result<(), String>>(1);
+
+        std::thread::spawn(move || {
+            let file_manager = if cfg!(target_os = "macos") {
+                "Finder"
+            } else if cfg!(target_os = "windows") {
+                "Explorer"
+            } else {
+                "File Manager"
+            };
+
+            logging::log(
+                "UI",
+                &format!(
+                    "ACTION_REVEAL_IN_FINDER_START file_manager='{}' path='{}'",
+                    file_manager, path_str
+                ),
+            );
+
+            let reveal_result = match crate::file_search::reveal_in_finder(&path_str) {
+                Ok(()) => {
+                    logging::log(
+                        "UI",
+                        &format!(
+                            "ACTION_REVEAL_IN_FINDER_SUCCESS file_manager='{}' path='{}'",
+                            file_manager, path_str
+                        ),
+                    );
+                    Ok(())
+                }
+                Err(error) => {
+                    logging::log(
+                        "ERROR",
+                        &format!(
+                            "ACTION_REVEAL_IN_FINDER_FAILED attempted='reveal_in_finder' path='{}' file_manager='{}' error='{}'",
+                            path_str, file_manager, error
+                        ),
+                    );
+                    Err(format!("Failed to reveal in {}: {}", file_manager, error))
+                }
+            };
+
+            let _ = result_tx.send_blocking(reveal_result);
+        });
+
+        result_rx
+    }
+
+    /// Launch the configured editor and return completion back to the UI thread for HUD feedback.
+    fn launch_editor_with_feedback_async(
+        &self,
+        path: &std::path::Path,
+    ) -> async_channel::Receiver<Result<(), String>> {
+        let editor = self.config.get_editor();
+        let path_str = path.to_string_lossy().to_string();
+        let (result_tx, result_rx) = async_channel::bounded::<Result<(), String>>(1);
+
+        std::thread::spawn(move || {
+            use std::process::Command;
+
+            logging::log(
+                "UI",
+                &format!(
+                    "ACTION_EDITOR_LAUNCH_START editor='{}' path='{}'",
+                    editor, path_str
+                ),
+            );
+
+            let launch_result = match Command::new(&editor).arg(&path_str).spawn() {
+                Ok(_) => {
+                    logging::log(
+                        "UI",
+                        &format!(
+                            "ACTION_EDITOR_LAUNCH_SUCCESS editor='{}' path='{}'",
+                            editor, path_str
+                        ),
+                    );
+                    Ok(())
+                }
+                Err(error) => {
+                    logging::log(
+                        "ERROR",
+                        &format!(
+                            "ACTION_EDITOR_LAUNCH_FAILED attempted='{} {}' path='{}' error='{}'",
+                            editor, path_str, path_str, error
+                        ),
+                    );
+                    Err(format!("Failed to open in {}: {}", editor, error))
+                }
+            };
+
+            let _ = result_tx.send_blocking(launch_result);
+        });
+
+        result_rx
+    }
+
     /// Copy text to clipboard using pbcopy on macOS.
     /// Critical: This properly closes stdin before waiting to prevent hangs.
     #[cfg(target_os = "macos")]
@@ -471,9 +574,24 @@
                 };
 
                 if let Some(path) = path_opt {
-                    self.reveal_in_finder(&path);
-                    self.show_hud("Opened in Finder".to_string(), Some(1500), cx);
-                    self.hide_main_and_reset(cx);
+                    let reveal_result_rx = self.reveal_in_finder_with_feedback_async(&path);
+                    cx.spawn(async move |this, cx| {
+                        let Ok(reveal_result) = reveal_result_rx.recv().await else {
+                            return;
+                        };
+
+                        this.update(cx, |this, cx| match reveal_result {
+                            Ok(()) => {
+                                this.show_hud("Opened in Finder".to_string(), Some(1500), cx);
+                                this.hide_main_and_reset(cx);
+                            }
+                            Err(message) => {
+                                this.show_hud(message, Some(2500), cx);
+                            }
+                        })
+                        .ok();
+                    })
+                    .detach();
                 } else {
                     self.show_hud(
                         "Cannot reveal this item type in Finder".to_string(),
@@ -884,8 +1002,23 @@
                     };
 
                     if let Some(path) = path_opt {
-                        self.edit_script(&path);
-                        self.hide_main_and_reset(cx);
+                        let editor_launch_rx = self.launch_editor_with_feedback_async(&path);
+                        cx.spawn(async move |this, cx| {
+                            let Ok(launch_result) = editor_launch_rx.recv().await else {
+                                return;
+                            };
+
+                            this.update(cx, |this, cx| match launch_result {
+                                Ok(()) => {
+                                    this.hide_main_and_reset(cx);
+                                }
+                                Err(message) => {
+                                    this.show_hud(message, Some(3000), cx);
+                                }
+                            })
+                            .ok();
+                        })
+                        .detach();
                     } else {
                         self.show_hud("Cannot edit this item type".to_string(), Some(2000), cx);
                     }
@@ -1932,8 +2065,23 @@
                             // Extract just the path without the anchor (e.g., "/path/to/file.md#slug" -> "/path/to/file.md")
                             let path_str = file_path.split('#').next().unwrap_or(file_path);
                             let path = std::path::PathBuf::from(path_str);
-                            self.edit_script(&path);
-                            self.hide_main_and_reset(cx);
+                            let editor_launch_rx = self.launch_editor_with_feedback_async(&path);
+                            cx.spawn(async move |this, cx| {
+                                let Ok(launch_result) = editor_launch_rx.recv().await else {
+                                    return;
+                                };
+
+                                this.update(cx, |this, cx| match launch_result {
+                                    Ok(()) => {
+                                        this.hide_main_and_reset(cx);
+                                    }
+                                    Err(message) => {
+                                        this.show_hud(message, Some(3000), cx);
+                                    }
+                                })
+                                .ok();
+                            })
+                            .detach();
                         } else {
                             self.show_hud(
                                 "Scriptlet has no source file path".to_string(),
@@ -1964,9 +2112,24 @@
                             // Extract just the path without the anchor
                             let path_str = file_path.split('#').next().unwrap_or(file_path);
                             let path = std::path::Path::new(path_str);
-                            self.reveal_in_finder(path);
-                            self.show_hud("Opened in Finder".to_string(), Some(1500), cx);
-                            self.hide_main_and_reset(cx);
+                            let reveal_result_rx = self.reveal_in_finder_with_feedback_async(path);
+                            cx.spawn(async move |this, cx| {
+                                let Ok(reveal_result) = reveal_result_rx.recv().await else {
+                                    return;
+                                };
+
+                                this.update(cx, |this, cx| match reveal_result {
+                                    Ok(()) => {
+                                        this.show_hud("Opened in Finder".to_string(), Some(1500), cx);
+                                        this.hide_main_and_reset(cx);
+                                    }
+                                    Err(message) => {
+                                        this.show_hud(message, Some(2500), cx);
+                                    }
+                                })
+                                .ok();
+                            })
+                            .detach();
                         } else {
                             self.show_hud(
                                 "Scriptlet has no source file path".to_string(),
diff --git a/src/app_actions/tests.rs b/src/app_actions/tests.rs
index 6e1bf7a5d42c8a5885695d94e51511178ec11315..7d9221c13778e3f29cf8798b8da18261b85f5221
--- a/src/app_actions/tests.rs
+++ b/src/app_actions/tests.rs
@@ -6,3 +6,6 @@
 
 #[path = "tests/clipboard_actions_menu_coverage.rs"]
 mod clipboard_actions_menu_coverage;
+
+#[path = "tests/editor_launch_feedback.rs"]
+mod editor_launch_feedback;


thinking
**Planning test location cleanup**
codex
I noticed `src/app_actions/tests.rs` isn’t wired into the active test graph, so those new tests would be effectively invisible. I’m moving the regression checks into the already-compiled `app_actions` test module in `helpers.rs` and removing the unused test file/module changes.
exec
/bin/zsh -lc '~/.claude/bin/swarm.ts claim --wait --id codex-fix-editor-feedback src/app_actions/helpers.rs' in /Users/johnlindquist/dev/script-kit-gpui succeeded in 50ms:
Claimed for codex-fix-editor-feedback: src/app_actions/helpers.rs
exec
/bin/zsh -lc '~/.claude/bin/swarm.ts update --id codex-fix-editor-feedback --status in_progress --notes "Moving regression tests into compiled app_actions/helpers.rs test module"' in /Users/johnlindquist/dev/script-kit-gpui succeeded in 52ms:
Updated: codex-fix-editor-feedback
file update:
diff --git a/src/app_actions/handle_action.rs b/src/app_actions/handle_action.rs
index 6512e920f98eb38811debb5dca005d821b3adb44..dda46dd268dc9fe3130c27b221485ba871f1c703
--- a/src/app_actions/handle_action.rs
+++ b/src/app_actions/handle_action.rs
@@ -32,6 +32,109 @@
         });
     }
 
+    /// Reveal a path and return completion back to the UI thread for HUD feedback.
+    fn reveal_in_finder_with_feedback_async(
+        &self,
+        path: &std::path::Path,
+    ) -> async_channel::Receiver<Result<(), String>> {
+        let path_str = path.to_string_lossy().to_string();
+        let (result_tx, result_rx) = async_channel::bounded::<Result<(), String>>(1);
+
+        std::thread::spawn(move || {
+            let file_manager = if cfg!(target_os = "macos") {
+                "Finder"
+            } else if cfg!(target_os = "windows") {
+                "Explorer"
+            } else {
+                "File Manager"
+            };
+
+            logging::log(
+                "UI",
+                &format!(
+                    "ACTION_REVEAL_IN_FINDER_START file_manager='{}' path='{}'",
+                    file_manager, path_str
+                ),
+            );
+
+            let reveal_result = match crate::file_search::reveal_in_finder(&path_str) {
+                Ok(()) => {
+                    logging::log(
+                        "UI",
+                        &format!(
+                            "ACTION_REVEAL_IN_FINDER_SUCCESS file_manager='{}' path='{}'",
+                            file_manager, path_str
+                        ),
+                    );
+                    Ok(())
+                }
+                Err(error) => {
+                    logging::log(
+                        "ERROR",
+                        &format!(
+                            "ACTION_REVEAL_IN_FINDER_FAILED attempted='reveal_in_finder' path='{}' file_manager='{}' error='{}'",
+                            path_str, file_manager, error
+                        ),
+                    );
+                    Err(format!("Failed to reveal in {}: {}", file_manager, error))
+                }
+            };
+
+            let _ = result_tx.send_blocking(reveal_result);
+        });
+
+        result_rx
+    }
+
+    /// Launch the configured editor and return completion back to the UI thread for HUD feedback.
+    fn launch_editor_with_feedback_async(
+        &self,
+        path: &std::path::Path,
+    ) -> async_channel::Receiver<Result<(), String>> {
+        let editor = self.config.get_editor();
+        let path_str = path.to_string_lossy().to_string();
+        let (result_tx, result_rx) = async_channel::bounded::<Result<(), String>>(1);
+
+        std::thread::spawn(move || {
+            use std::process::Command;
+
+            logging::log(
+                "UI",
+                &format!(
+                    "ACTION_EDITOR_LAUNCH_START editor='{}' path='{}'",
+                    editor, path_str
+                ),
+            );
+
+            let launch_result = match Command::new(&editor).arg(&path_str).spawn() {
+                Ok(_) => {
+                    logging::log(
+                        "UI",
+                        &format!(
+                            "ACTION_EDITOR_LAUNCH_SUCCESS editor='{}' path='{}'",
+                            editor, path_str
+                        ),
+                    );
+                    Ok(())
+                }
+                Err(error) => {
+                    logging::log(
+                        "ERROR",
+                        &format!(
+                            "ACTION_EDITOR_LAUNCH_FAILED attempted='{} {}' path='{}' error='{}'",
+                            editor, path_str, path_str, error
+                        ),
+                    );
+                    Err(format!("Failed to open in {}: {}", editor, error))
+                }
+            };
+
+            let _ = result_tx.send_blocking(launch_result);
+        });
+
+        result_rx
+    }
+
     /// Copy text to clipboard using pbcopy on macOS.
     /// Critical: This properly closes stdin before waiting to prevent hangs.
     #[cfg(target_os = "macos")]
@@ -471,9 +574,24 @@
                 };
 
                 if let Some(path) = path_opt {
-                    self.reveal_in_finder(&path);
-                    self.show_hud("Opened in Finder".to_string(), Some(1500), cx);
-                    self.hide_main_and_reset(cx);
+                    let reveal_result_rx = self.reveal_in_finder_with_feedback_async(&path);
+                    cx.spawn(async move |this, cx| {
+                        let Ok(reveal_result) = reveal_result_rx.recv().await else {
+                            return;
+                        };
+
+                        this.update(cx, |this, cx| match reveal_result {
+                            Ok(()) => {
+                                this.show_hud("Opened in Finder".to_string(), Some(1500), cx);
+                                this.hide_main_and_reset(cx);
+                            }
+                            Err(message) => {
+                                this.show_hud(message, Some(2500), cx);
+                            }
+                        })
+                        .ok();
+                    })
+                    .detach();
                 } else {
                     self.show_hud(
                         "Cannot reveal this item type in Finder".to_string(),
@@ -884,8 +1002,23 @@
                     };
 
                     if let Some(path) = path_opt {
-                        self.edit_script(&path);
-                        self.hide_main_and_reset(cx);
+                        let editor_launch_rx = self.launch_editor_with_feedback_async(&path);
+                        cx.spawn(async move |this, cx| {
+                            let Ok(launch_result) = editor_launch_rx.recv().await else {
+                                return;
+                            };
+
+                            this.update(cx, |this, cx| match launch_result {
+                                Ok(()) => {
+                                    this.hide_main_and_reset(cx);
+                                }
+                                Err(message) => {
+                                    this.show_hud(message, Some(3000), cx);
+                                }
+                            })
+                            .ok();
+                        })
+                        .detach();
                     } else {
                         self.show_hud("Cannot edit this item type".to_string(), Some(2000), cx);
                     }
@@ -1932,8 +2065,23 @@
                             // Extract just the path without the anchor (e.g., "/path/to/file.md#slug" -> "/path/to/file.md")
                             let path_str = file_path.split('#').next().unwrap_or(file_path);
                             let path = std::path::PathBuf::from(path_str);
-                            self.edit_script(&path);
-                            self.hide_main_and_reset(cx);
+                            let editor_launch_rx = self.launch_editor_with_feedback_async(&path);
+                            cx.spawn(async move |this, cx| {
+                                let Ok(launch_result) = editor_launch_rx.recv().await else {
+                                    return;
+                                };
+
+                                this.update(cx, |this, cx| match launch_result {
+                                    Ok(()) => {
+                                        this.hide_main_and_reset(cx);
+                                    }
+                                    Err(message) => {
+                                        this.show_hud(message, Some(3000), cx);
+                                    }
+                                })
+                                .ok();
+                            })
+                            .detach();
                         } else {
                             self.show_hud(
                                 "Scriptlet has no source file path".to_string(),
@@ -1964,9 +2112,24 @@
                             // Extract just the path without the anchor
                             let path_str = file_path.split('#').next().unwrap_or(file_path);
                             let path = std::path::Path::new(path_str);
-                            self.reveal_in_finder(path);
-                            self.show_hud("Opened in Finder".to_string(), Some(1500), cx);
-                            self.hide_main_and_reset(cx);
+                            let reveal_result_rx = self.reveal_in_finder_with_feedback_async(path);
+                            cx.spawn(async move |this, cx| {
+                                let Ok(reveal_result) = reveal_result_rx.recv().await else {
+                                    return;
+                                };
+
+                                this.update(cx, |this, cx| match reveal_result {
+                                    Ok(()) => {
+                                        this.show_hud("Opened in Finder".to_string(), Some(1500), cx);
+                                        this.hide_main_and_reset(cx);
+                                    }
+                                    Err(message) => {
+                                        this.show_hud(message, Some(2500), cx);
+                                    }
+                                })
+                                .ok();
+                            })
+                            .detach();
                         } else {
                             self.show_hud(
                                 "Scriptlet has no source file path".to_string(),
diff --git a/src/app_actions/tests.rs b/src/app_actions/tests.rs
index 6e1bf7a5d42c8a5885695d94e51511178ec11315..7d9221c13778e3f29cf8798b8da18261b85f5221
--- a/src/app_actions/tests.rs
+++ b/src/app_actions/tests.rs
@@ -6,3 +6,6 @@
 
 #[path = "tests/clipboard_actions_menu_coverage.rs"]
 mod clipboard_actions_menu_coverage;
+
+#[path = "tests/editor_launch_feedback.rs"]
+mod editor_launch_feedback;


thinking
**Reverting and deleting test file**
file update
M /Users/johnlindquist/dev/script-kit-gpui/src/app_actions/tests.rs
@@ -8,4 +8 @@
 mod clipboard_actions_menu_coverage;
-
-#[path = "tests/editor_launch_feedback.rs"]
-mod editor_launch_feedback;
apply_patch(auto_approved=true) exited 0 in 18ms:
Success. Updated the following files:
M /Users/johnlindquist/dev/script-kit-gpui/src/app_actions/tests.rs
file update:
diff --git a/src/app_actions/handle_action.rs b/src/app_actions/handle_action.rs
index 6512e920f98eb38811debb5dca005d821b3adb44..dda46dd268dc9fe3130c27b221485ba871f1c703
--- a/src/app_actions/handle_action.rs
+++ b/src/app_actions/handle_action.rs
@@ -32,6 +32,109 @@
         });
     }
 
+    /// Reveal a path and return completion back to the UI thread for HUD feedback.
+    fn reveal_in_finder_with_feedback_async(
+        &self,
+        path: &std::path::Path,
+    ) -> async_channel::Receiver<Result<(), String>> {
+        let path_str = path.to_string_lossy().to_string();
+        let (result_tx, result_rx) = async_channel::bounded::<Result<(), String>>(1);
+
+        std::thread::spawn(move || {
+            let file_manager = if cfg!(target_os = "macos") {
+                "Finder"
+            } else if cfg!(target_os = "windows") {
+                "Explorer"
+            } else {
+                "File Manager"
+            };
+
+            logging::log(
+                "UI",
+                &format!(
+                    "ACTION_REVEAL_IN_FINDER_START file_manager='{}' path='{}'",
+                    file_manager, path_str
+                ),
+            );
+
+            let reveal_result = match crate::file_search::reveal_in_finder(&path_str) {
+                Ok(()) => {
+                    logging::log(
+                        "UI",
+                        &format!(
+                            "ACTION_REVEAL_IN_FINDER_SUCCESS file_manager='{}' path='{}'",
+                            file_manager, path_str
+                        ),
+                    );
+                    Ok(())
+                }
+                Err(error) => {
+                    logging::log(
+                        "ERROR",
+                        &format!(
+                            "ACTION_REVEAL_IN_FINDER_FAILED attempted='reveal_in_finder' path='{}' file_manager='{}' error='{}'",
+                            path_str, file_manager, error
+                        ),
+                    );
+                    Err(format!("Failed to reveal in {}: {}", file_manager, error))
+                }
+            };
+
+            let _ = result_tx.send_blocking(reveal_result);
+        });
+
+        result_rx
+    }
+
+    /// Launch the configured editor and return completion back to the UI thread for HUD feedback.
+    fn launch_editor_with_feedback_async(
+        &self,
+        path: &std::path::Path,
+    ) -> async_channel::Receiver<Result<(), String>> {
+        let editor = self.config.get_editor();
+        let path_str = path.to_string_lossy().to_string();
+        let (result_tx, result_rx) = async_channel::bounded::<Result<(), String>>(1);
+
+        std::thread::spawn(move || {
+            use std::process::Command;
+
+            logging::log(
+                "UI",
+                &format!(
+                    "ACTION_EDITOR_LAUNCH_START editor='{}' path='{}'",
+                    editor, path_str
+                ),
+            );
+
+            let launch_result = match Command::new(&editor).arg(&path_str).spawn() {
+                Ok(_) => {
+                    logging::log(
+                        "UI",
+                        &format!(
+                            "ACTION_EDITOR_LAUNCH_SUCCESS editor='{}' path='{}'",
+                            editor, path_str
+                        ),
+                    );
+                    Ok(())
+                }
+                Err(error) => {
+                    logging::log(
+                        "ERROR",
+                        &format!(
+                            "ACTION_EDITOR_LAUNCH_FAILED attempted='{} {}' path='{}' error='{}'",
+                            editor, path_str, path_str, error
+                        ),
+                    );
+                    Err(format!("Failed to open in {}: {}", editor, error))
+                }
+            };
+
+            let _ = result_tx.send_blocking(launch_result);
+        });
+
+        result_rx
+    }
+
     /// Copy text to clipboard using pbcopy on macOS.
     /// Critical: This properly closes stdin before waiting to prevent hangs.
     #[cfg(target_os = "macos")]
@@ -471,9 +574,24 @@
                 };
 
                 if let Some(path) = path_opt {
-                    self.reveal_in_finder(&path);
-                    self.show_hud("Opened in Finder".to_string(), Some(1500), cx);
-                    self.hide_main_and_reset(cx);
+                    let reveal_result_rx = self.reveal_in_finder_with_feedback_async(&path);
+                    cx.spawn(async move |this, cx| {
+                        let Ok(reveal_result) = reveal_result_rx.recv().await else {
+                            return;
+                        };
+
+                        this.update(cx, |this, cx| match reveal_result {
+                            Ok(()) => {
+                                this.show_hud("Opened in Finder".to_string(), Some(1500), cx);
+                                this.hide_main_and_reset(cx);
+                            }
+                            Err(message) => {
+                                this.show_hud(message, Some(2500), cx);
+                            }
+                        })
+                        .ok();
+                    })
+                    .detach();
                 } else {
                     self.show_hud(
                         "Cannot reveal this item type in Finder".to_string(),
@@ -884,8 +1002,23 @@
                     };
 
                     if let Some(path) = path_opt {
-                        self.edit_script(&path);
-                        self.hide_main_and_reset(cx);
+                        let editor_launch_rx = self.launch_editor_with_feedback_async(&path);
+                        cx.spawn(async move |this, cx| {
+                            let Ok(launch_result) = editor_launch_rx.recv().await else {
+                                return;
+                            };
+
+                            this.update(cx, |this, cx| match launch_result {
+                                Ok(()) => {
+                                    this.hide_main_and_reset(cx);
+                                }
+                                Err(message) => {
+                                    this.show_hud(message, Some(3000), cx);
+                                }
+                            })
+                            .ok();
+                        })
+                        .detach();
                     } else {
                         self.show_hud("Cannot edit this item type".to_string(), Some(2000), cx);
                     }
@@ -1932,8 +2065,23 @@
                             // Extract just the path without the anchor (e.g., "/path/to/file.md#slug" -> "/path/to/file.md")
                             let path_str = file_path.split('#').next().unwrap_or(file_path);
                             let path = std::path::PathBuf::from(path_str);
-                            self.edit_script(&path);
-                            self.hide_main_and_reset(cx);
+                            let editor_launch_rx = self.launch_editor_with_feedback_async(&path);
+                            cx.spawn(async move |this, cx| {
+                                let Ok(launch_result) = editor_launch_rx.recv().await else {
+                                    return;
+                                };
+
+                                this.update(cx, |this, cx| match launch_result {
+                                    Ok(()) => {
+                                        this.hide_main_and_reset(cx);
+                                    }
+                                    Err(message) => {
+                                        this.show_hud(message, Some(3000), cx);
+                                    }
+                                })
+                                .ok();
+                            })
+                            .detach();
                         } else {
                             self.show_hud(
                                 "Scriptlet has no source file path".to_string(),
@@ -1964,9 +2112,24 @@
                             // Extract just the path without the anchor
                             let path_str = file_path.split('#').next().unwrap_or(file_path);
                             let path = std::path::Path::new(path_str);
-                            self.reveal_in_finder(path);
-                            self.show_hud("Opened in Finder".to_string(), Some(1500), cx);
-                            self.hide_main_and_reset(cx);
+                            let reveal_result_rx = self.reveal_in_finder_with_feedback_async(path);
+                            cx.spawn(async move |this, cx| {
+                                let Ok(reveal_result) = reveal_result_rx.recv().await else {
+                                    return;
+                                };
+
+                                this.update(cx, |this, cx| match reveal_result {
+                                    Ok(()) => {
+                                        this.show_hud("Opened in Finder".to_string(), Some(1500), cx);
+                                        this.hide_main_and_reset(cx);
+                                    }
+                                    Err(message) => {
+                                        this.show_hud(message, Some(2500), cx);
+                                    }
+                                })
+                                .ok();
+                            })
+                            .detach();
                         } else {
                             self.show_hud(
                                 "Scriptlet has no source file path".to_string(),

file update:
diff --git a/src/app_actions/handle_action.rs b/src/app_actions/handle_action.rs
index 6512e920f98eb38811debb5dca005d821b3adb44..dda46dd268dc9fe3130c27b221485ba871f1c703
--- a/src/app_actions/handle_action.rs
+++ b/src/app_actions/handle_action.rs
@@ -32,6 +32,109 @@
         });
     }
 
+    /// Reveal a path and return completion back to the UI thread for HUD feedback.
+    fn reveal_in_finder_with_feedback_async(
+        &self,
+        path: &std::path::Path,
+    ) -> async_channel::Receiver<Result<(), String>> {
+        let path_str = path.to_string_lossy().to_string();
+        let (result_tx, result_rx) = async_channel::bounded::<Result<(), String>>(1);
+
+        std::thread::spawn(move || {
+            let file_manager = if cfg!(target_os = "macos") {
+                "Finder"
+            } else if cfg!(target_os = "windows") {
+                "Explorer"
+            } else {
+                "File Manager"
+            };
+
+            logging::log(
+                "UI",
+                &format!(
+                    "ACTION_REVEAL_IN_FINDER_START file_manager='{}' path='{}'",
+                    file_manager, path_str
+                ),
+            );
+
+            let reveal_result = match crate::file_search::reveal_in_finder(&path_str) {
+                Ok(()) => {
+                    logging::log(
+                        "UI",
+                        &format!(
+                            "ACTION_REVEAL_IN_FINDER_SUCCESS file_manager='{}' path='{}'",
+                            file_manager, path_str
+                        ),
+                    );
+                    Ok(())
+                }
+                Err(error) => {
+                    logging::log(
+                        "ERROR",
+                        &format!(
+                            "ACTION_REVEAL_IN_FINDER_FAILED attempted='reveal_in_finder' path='{}' file_manager='{}' error='{}'",
+                            path_str, file_manager, error
+                        ),
+                    );
+                    Err(format!("Failed to reveal in {}: {}", file_manager, error))
+                }
+            };
+
+            let _ = result_tx.send_blocking(reveal_result);
+        });
+
+        result_rx
+    }
+
+    /// Launch the configured editor and return completion back to the UI thread for HUD feedback.
+    fn launch_editor_with_feedback_async(
+        &self,
+        path: &std::path::Path,
+    ) -> async_channel::Receiver<Result<(), String>> {
+        let editor = self.config.get_editor();
+        let path_str = path.to_string_lossy().to_string();
+        let (result_tx, result_rx) = async_channel::bounded::<Result<(), String>>(1);
+
+        std::thread::spawn(move || {
+            use std::process::Command;
+
+            logging::log(
+                "UI",
+                &format!(
+                    "ACTION_EDITOR_LAUNCH_START editor='{}' path='{}'",
+                    editor, path_str
+                ),
+            );
+
+            let launch_result = match Command::new(&editor).arg(&path_str).spawn() {
+                Ok(_) => {
+                    logging::log(
+                        "UI",
+                        &format!(
+                            "ACTION_EDITOR_LAUNCH_SUCCESS editor='{}' path='{}'",
+                            editor, path_str
+                        ),
+                    );
+                    Ok(())
+                }
+                Err(error) => {
+                    logging::log(
+                        "ERROR",
+                        &format!(
+                            "ACTION_EDITOR_LAUNCH_FAILED attempted='{} {}' path='{}' error='{}'",
+                            editor, path_str, path_str, error
+                        ),
+                    );
+                    Err(format!("Failed to open in {}: {}", editor, error))
+                }
+            };
+
+            let _ = result_tx.send_blocking(launch_result);
+        });
+
+        result_rx
+    }
+
     /// Copy text to clipboard using pbcopy on macOS.
     /// Critical: This properly closes stdin before waiting to prevent hangs.
     #[cfg(target_os = "macos")]
@@ -471,9 +574,24 @@
                 };
 
                 if let Some(path) = path_opt {
-                    self.reveal_in_finder(&path);
-                    self.show_hud("Opened in Finder".to_string(), Some(1500), cx);
-                    self.hide_main_and_reset(cx);
+                    let reveal_result_rx = self.reveal_in_finder_with_feedback_async(&path);
+                    cx.spawn(async move |this, cx| {
+                        let Ok(reveal_result) = reveal_result_rx.recv().await else {
+                            return;
+                        };
+
+                        this.update(cx, |this, cx| match reveal_result {
+                            Ok(()) => {
+                                this.show_hud("Opened in Finder".to_string(), Some(1500), cx);
+                                this.hide_main_and_reset(cx);
+                            }
+                            Err(message) => {
+                                this.show_hud(message, Some(2500), cx);
+                            }
+                        })
+                        .ok();
+                    })
+                    .detach();
                 } else {
                     self.show_hud(
                         "Cannot reveal this item type in Finder".to_string(),
@@ -884,8 +1002,23 @@
                     };
 
                     if let Some(path) = path_opt {
-                        self.edit_script(&path);
-                        self.hide_main_and_reset(cx);
+                        let editor_launch_rx = self.launch_editor_with_feedback_async(&path);
+                        cx.spawn(async move |this, cx| {
+                            let Ok(launch_result) = editor_launch_rx.recv().await else {
+                                return;
+                            };
+
+                            this.update(cx, |this, cx| match launch_result {
+                                Ok(()) => {
+                                    this.hide_main_and_reset(cx);
+                                }
+                                Err(message) => {
+                                    this.show_hud(message, Some(3000), cx);
+                                }
+                            })
+                            .ok();
+                        })
+                        .detach();
                     } else {
                         self.show_hud("Cannot edit this item type".to_string(), Some(2000), cx);
                     }
@@ -1932,8 +2065,23 @@
                             // Extract just the path without the anchor (e.g., "/path/to/file.md#slug" -> "/path/to/file.md")
                             let path_str = file_path.split('#').next().unwrap_or(file_path);
                             let path = std::path::PathBuf::from(path_str);
-                            self.edit_script(&path);
-                            self.hide_main_and_reset(cx);
+                            let editor_launch_rx = self.launch_editor_with_feedback_async(&path);
+                            cx.spawn(async move |this, cx| {
+                                let Ok(launch_result) = editor_launch_rx.recv().await else {
+                                    return;
+                                };
+
+                                this.update(cx, |this, cx| match launch_result {
+                                    Ok(()) => {
+                                        this.hide_main_and_reset(cx);
+                                    }
+                                    Err(message) => {
+                                        this.show_hud(message, Some(3000), cx);
+                                    }
+                                })
+                                .ok();
+                            })
+                            .detach();
                         } else {
                             self.show_hud(
                                 "Scriptlet has no source file path".to_string(),
@@ -1964,9 +2112,24 @@
                             // Extract just the path without the anchor
                             let path_str = file_path.split('#').next().unwrap_or(file_path);
                             let path = std::path::Path::new(path_str);
-                            self.reveal_in_finder(path);
-                            self.show_hud("Opened in Finder".to_string(), Some(1500), cx);
-                            self.hide_main_and_reset(cx);
+                            let reveal_result_rx = self.reveal_in_finder_with_feedback_async(path);
+                            cx.spawn(async move |this, cx| {
+                                let Ok(reveal_result) = reveal_result_rx.recv().await else {
+                                    return;
+                                };
+
+                                this.update(cx, |this, cx| match reveal_result {
+                                    Ok(()) => {
+                                        this.show_hud("Opened in Finder".to_string(), Some(1500), cx);
+                                        this.hide_main_and_reset(cx);
+                                    }
+                                    Err(message) => {
+                                        this.show_hud(message, Some(2500), cx);
+                                    }
+                                })
+                                .ok();
+                            })
+                            .detach();
                         } else {
                             self.show_hud(
                                 "Scriptlet has no source file path".to_string(),

file update:
diff --git a/src/app_actions/handle_action.rs b/src/app_actions/handle_action.rs
index 6512e920f98eb38811debb5dca005d821b3adb44..dda46dd268dc9fe3130c27b221485ba871f1c703
--- a/src/app_actions/handle_action.rs
+++ b/src/app_actions/handle_action.rs
@@ -32,6 +32,109 @@
         });
     }
 
+    /// Reveal a path and return completion back to the UI thread for HUD feedback.
+    fn reveal_in_finder_with_feedback_async(
+        &self,
+        path: &std::path::Path,
+    ) -> async_channel::Receiver<Result<(), String>> {
+        let path_str = path.to_string_lossy().to_string();
+        let (result_tx, result_rx) = async_channel::bounded::<Result<(), String>>(1);
+
+        std::thread::spawn(move || {
+            let file_manager = if cfg!(target_os = "macos") {
+                "Finder"
+            } else if cfg!(target_os = "windows") {
+                "Explorer"
+            } else {
+                "File Manager"
+            };
+
+            logging::log(
+                "UI",
+                &format!(
+                    "ACTION_REVEAL_IN_FINDER_START file_manager='{}' path='{}'",
+                    file_manager, path_str
+                ),
+            );
+
+            let reveal_result = match crate::file_search::reveal_in_finder(&path_str) {
+                Ok(()) => {
+                    logging::log(
+                        "UI",
+                        &format!(
+                            "ACTION_REVEAL_IN_FINDER_SUCCESS file_manager='{}' path='{}'",
+                            file_manager, path_str
+                        ),
+                    );
+                    Ok(())
+                }
+                Err(error) => {
+                    logging::log(
+                        "ERROR",
+                        &format!(
+                            "ACTION_REVEAL_IN_FINDER_FAILED attempted='reveal_in_finder' path='{}' file_manager='{}' error='{}'",
+                            path_str, file_manager, error
+                        ),
+                    );
+                    Err(format!("Failed to reveal in {}: {}", file_manager, error))
+                }
+            };
+
+            let _ = result_tx.send_blocking(reveal_result);
+        });
+
+        result_rx
+    }
+
+    /// Launch the configured editor and return completion back to the UI thread for HUD feedback.
+    fn launch_editor_with_feedback_async(
+        &self,
+        path: &std::path::Path,
+    ) -> async_channel::Receiver<Result<(), String>> {
+        let editor = self.config.get_editor();
+        let path_str = path.to_string_lossy().to_string();
+        let (result_tx, result_rx) = async_channel::bounded::<Result<(), String>>(1);
+
+        std::thread::spawn(move || {
+            use std::process::Command;
+
+            logging::log(
+                "UI",
+                &format!(
+                    "ACTION_EDITOR_LAUNCH_START editor='{}' path='{}'",
+                    editor, path_str
+                ),
+            );
+
+            let launch_result = match Command::new(&editor).arg(&path_str).spawn() {
+                Ok(_) => {
+                    logging::log(
+                        "UI",
+                        &format!(
+                            "ACTION_EDITOR_LAUNCH_SUCCESS editor='{}' path='{}'",
+                            editor, path_str
+                        ),
+                    );
+                    Ok(())
+                }
+                Err(error) => {
+                    logging::log(
+                        "ERROR",
+                        &format!(
+                            "ACTION_EDITOR_LAUNCH_FAILED attempted='{} {}' path='{}' error='{}'",
+                            editor, path_str, path_str, error
+                        ),
+                    );
+                    Err(format!("Failed to open in {}: {}", editor, error))
+                }
+            };
+
+            let _ = result_tx.send_blocking(launch_result);
+        });
+
+        result_rx
+    }
+
     /// Copy text to clipboard using pbcopy on macOS.
     /// Critical: This properly closes stdin before waiting to prevent hangs.
     #[cfg(target_os = "macos")]
@@ -471,9 +574,24 @@
                 };
 
                 if let Some(path) = path_opt {
-                    self.reveal_in_finder(&path);
-                    self.show_hud("Opened in Finder".to_string(), Some(1500), cx);
-                    self.hide_main_and_reset(cx);
+                    let reveal_result_rx = self.reveal_in_finder_with_feedback_async(&path);
+                    cx.spawn(async move |this, cx| {
+                        let Ok(reveal_result) = reveal_result_rx.recv().await else {
+                            return;
+                        };
+
+                        this.update(cx, |this, cx| match reveal_result {
+                            Ok(()) => {
+                                this.show_hud("Opened in Finder".to_string(), Some(1500), cx);
+                                this.hide_main_and_reset(cx);
+                            }
+                            Err(message) => {
+                                this.show_hud(message, Some(2500), cx);
+                            }
+                        })
+                        .ok();
+                    })
+                    .detach();
                 } else {
                     self.show_hud(
                         "Cannot reveal this item type in Finder".to_string(),
@@ -884,8 +1002,23 @@
                     };
 
                     if let Some(path) = path_opt {
-                        self.edit_script(&path);
-                        self.hide_main_and_reset(cx);
+                        let editor_launch_rx = self.launch_editor_with_feedback_async(&path);
+                        cx.spawn(async move |this, cx| {
+                            let Ok(launch_result) = editor_launch_rx.recv().await else {
+                                return;
+                            };
+
+                            this.update(cx, |this, cx| match launch_result {
+                                Ok(()) => {
+                                    this.hide_main_and_reset(cx);
+                                }
+                                Err(message) => {
+                                    this.show_hud(message, Some(3000), cx);
+                                }
+                            })
+                            .ok();
+                        })
+                        .detach();
                     } else {
                         self.show_hud("Cannot edit this item type".to_string(), Some(2000), cx);
                     }
@@ -1932,8 +2065,23 @@
                             // Extract just the path without the anchor (e.g., "/path/to/file.md#slug" -> "/path/to/file.md")
                             let path_str = file_path.split('#').next().unwrap_or(file_path);
                             let path = std::path::PathBuf::from(path_str);
-                            self.edit_script(&path);
-                            self.hide_main_and_reset(cx);
+                            let editor_launch_rx = self.launch_editor_with_feedback_async(&path);
+                            cx.spawn(async move |this, cx| {
+                                let Ok(launch_result) = editor_launch_rx.recv().await else {
+                                    return;
+                                };
+
+                                this.update(cx, |this, cx| match launch_result {
+                                    Ok(()) => {
+                                        this.hide_main_and_reset(cx);
+                                    }
+                                    Err(message) => {
+                                        this.show_hud(message, Some(3000), cx);
+                                    }
+                                })
+                                .ok();
+                            })
+                            .detach();
                         } else {
                             self.show_hud(
                                 "Scriptlet has no source file path".to_string(),
@@ -1964,9 +2112,24 @@
                             // Extract just the path without the anchor
                             let path_str = file_path.split('#').next().unwrap_or(file_path);
                             let path = std::path::Path::new(path_str);
-                            self.reveal_in_finder(path);
-                            self.show_hud("Opened in Finder".to_string(), Some(1500), cx);
-                            self.hide_main_and_reset(cx);
+                            let reveal_result_rx = self.reveal_in_finder_with_feedback_async(path);
+                            cx.spawn(async move |this, cx| {
+                                let Ok(reveal_result) = reveal_result_rx.recv().await else {
+                                    return;
+                                };
+
+                                this.update(cx, |this, cx| match reveal_result {
+                                    Ok(()) => {
+                                        this.show_hud("Opened in Finder".to_string(), Some(1500), cx);
+                                        this.hide_main_and_reset(cx);
+                                    }
+                                    Err(message) => {
+                                        this.show_hud(message, Some(2500), cx);
+                                    }
+                                })
+                                .ok();
+                            })
+                            .detach();
                         } else {
                             self.show_hud(
                                 "Scriptlet has no source file path".to_string(),


thinking
**Using patch apply for deletion**
file update
D /Users/johnlindquist/dev/script-kit-gpui/src/app_actions/tests/editor_launch_feedback.rs
use std::fs;

fn read(path: &str) -> String {
    fs::read_to_string(path).unwrap_or_else(|_| panic!("Failed to read {path}"))
}

fn count_occurrences(haystack: &str, needle: &str) -> usize {
    haystack.match_indices(needle).count()
}

#[test]
fn test_edit_actions_show_error_feedback_when_editor_launch_fails() {
    let content = read("src/app_actions/handle_action.rs");

    assert!(
        content.contains("fn launch_editor_with_feedback_async"),
        "Expected async editor launch helper to exist"
    );

    let usage_count = count_occurrences(&content, "self.launch_editor_with_feedback_async(&path)");
    assert!(
        usage_count >= 2,
        "Expected edit_script and edit_scriptlet to use async editor launch feedback (found {usage_count} usages)"
    );

    assert!(
        content.contains("this.show_hud(message, Some(3000), cx);"),
        "Expected async editor launch failure to surface a HUD error message"
    );
}

#[test]
fn test_reveal_actions_show_success_hud_after_async_reveal_completion() {
    let content = read("src/app_actions/handle_action.rs");

    assert!(
        content.contains("fn reveal_in_finder_with_feedback_async"),
        "Expected async reveal helper to exist"
    );

    let usage_count = count_occurrences(
        &content,
        "self.reveal_in_finder_with_feedback_async(&path)",
    ) + count_occurrences(
        &content,
        "self.reveal_in_finder_with_feedback_async(path)",
    );
    assert!(
        usage_count >= 2,
        "Expected reveal actions to use async reveal feedback helper (found {usage_count} usages)"
    );

    assert!(
        content.contains("let Ok(reveal_result) = reveal_result_rx.recv().await else {"),
        "Expected reveal actions to await async reveal completion before showing HUD"
    );

    assert!(
        content.contains("this.show_hud(\"Opened in Finder\".to_string(), Some(1500), cx);"),
        "Expected reveal success HUD to be emitted from async completion callback"
    );
}
apply_patch(auto_approved=true) exited 0 in 17ms:
Success. Updated the following files:
D /Users/johnlindquist/dev/script-kit-gpui/src/app_actions/tests/editor_launch_feedback.rs
file update:
diff --git a/src/app_actions/handle_action.rs b/src/app_actions/handle_action.rs
index 6512e920f98eb38811debb5dca005d821b3adb44..dda46dd268dc9fe3130c27b221485ba871f1c703
--- a/src/app_actions/handle_action.rs
+++ b/src/app_actions/handle_action.rs
@@ -32,6 +32,109 @@
         });
     }
 
+    /// Reveal a path and return completion back to the UI thread for HUD feedback.
+    fn reveal_in_finder_with_feedback_async(
+        &self,
+        path: &std::path::Path,
+    ) -> async_channel::Receiver<Result<(), String>> {
+        let path_str = path.to_string_lossy().to_string();
+        let (result_tx, result_rx) = async_channel::bounded::<Result<(), String>>(1);
+
+        std::thread::spawn(move || {
+            let file_manager = if cfg!(target_os = "macos") {
+                "Finder"
+            } else if cfg!(target_os = "windows") {
+                "Explorer"
+            } else {
+                "File Manager"
+            };
+
+            logging::log(
+                "UI",
+                &format!(
+                    "ACTION_REVEAL_IN_FINDER_START file_manager='{}' path='{}'",
+                    file_manager, path_str
+                ),
+            );
+
+            let reveal_result = match crate::file_search::reveal_in_finder(&path_str) {
+                Ok(()) => {
+                    logging::log(
+                        "UI",
+                        &format!(
+                            "ACTION_REVEAL_IN_FINDER_SUCCESS file_manager='{}' path='{}'",
+                            file_manager, path_str
+                        ),
+                    );
+                    Ok(())
+                }
+                Err(error) => {
+                    logging::log(
+                        "ERROR",
+                        &format!(
+                            "ACTION_REVEAL_IN_FINDER_FAILED attempted='reveal_in_finder' path='{}' file_manager='{}' error='{}'",
+                            path_str, file_manager, error
+                        ),
+                    );
+                    Err(format!("Failed to reveal in {}: {}", file_manager, error))
+                }
+            };
+
+            let _ = result_tx.send_blocking(reveal_result);
+        });
+
+        result_rx
+    }
+
+    /// Launch the configured editor and return completion back to the UI thread for HUD feedback.
+    fn launch_editor_with_feedback_async(
+        &self,
+        path: &std::path::Path,
+    ) -> async_channel::Receiver<Result<(), String>> {
+        let editor = self.config.get_editor();
+        let path_str = path.to_string_lossy().to_string();
+        let (result_tx, result_rx) = async_channel::bounded::<Result<(), String>>(1);
+
+        std::thread::spawn(move || {
+            use std::process::Command;
+
+            logging::log(
+                "UI",
+                &format!(
+                    "ACTION_EDITOR_LAUNCH_START editor='{}' path='{}'",
+                    editor, path_str
+                ),
+            );
+
+            let launch_result = match Command::new(&editor).arg(&path_str).spawn() {
+                Ok(_) => {
+                    logging::log(
+                        "UI",
+                        &format!(
+                            "ACTION_EDITOR_LAUNCH_SUCCESS editor='{}' path='{}'",
+                            editor, path_str
+                        ),
+                    );
+                    Ok(())
+                }
+                Err(error) => {
+                    logging::log(
+                        "ERROR",
+                        &format!(
+                            "ACTION_EDITOR_LAUNCH_FAILED attempted='{} {}' path='{}' error='{}'",
+                            editor, path_str, path_str, error
+                        ),
+                    );
+                    Err(format!("Failed to open in {}: {}", editor, error))
+                }
+            };
+
+            let _ = result_tx.send_blocking(launch_result);
+        });
+
+        result_rx
+    }
+
     /// Copy text to clipboard using pbcopy on macOS.
     /// Critical: This properly closes stdin before waiting to prevent hangs.
     #[cfg(target_os = "macos")]
@@ -471,9 +574,24 @@
                 };
 
                 if let Some(path) = path_opt {
-                    self.reveal_in_finder(&path);
-                    self.show_hud("Opened in Finder".to_string(), Some(1500), cx);
-                    self.hide_main_and_reset(cx);
+                    let reveal_result_rx = self.reveal_in_finder_with_feedback_async(&path);
+                    cx.spawn(async move |this, cx| {
+                        let Ok(reveal_result) = reveal_result_rx.recv().await else {
+                            return;
+                        };
+
+                        this.update(cx, |this, cx| match reveal_result {
+                            Ok(()) => {
+                                this.show_hud("Opened in Finder".to_string(), Some(1500), cx);
+                                this.hide_main_and_reset(cx);
+                            }
+                            Err(message) => {
+                                this.show_hud(message, Some(2500), cx);
+                            }
+                        })
+                        .ok();
+                    })
+                    .detach();
                 } else {
                     self.show_hud(
                         "Cannot reveal this item type in Finder".to_string(),
@@ -884,8 +1002,23 @@
                     };
 
                     if let Some(path) = path_opt {
-                        self.edit_script(&path);
-                        self.hide_main_and_reset(cx);
+                        let editor_launch_rx = self.launch_editor_with_feedback_async(&path);
+                        cx.spawn(async move |this, cx| {
+                            let Ok(launch_result) = editor_launch_rx.recv().await else {
+                                return;
+                            };
+
+                            this.update(cx, |this, cx| match launch_result {
+                                Ok(()) => {
+                                    this.hide_main_and_reset(cx);
+                                }
+                                Err(message) => {
+                                    this.show_hud(message, Some(3000), cx);
+                                }
+                            })
+                            .ok();
+                        })
+                        .detach();
                     } else {
                         self.show_hud("Cannot edit this item type".to_string(), Some(2000), cx);
                     }
@@ -1932,8 +2065,23 @@
                             // Extract just the path without the anchor (e.g., "/path/to/file.md#slug" -> "/path/to/file.md")
                             let path_str = file_path.split('#').next().unwrap_or(file_path);
                             let path = std::path::PathBuf::from(path_str);
-                            self.edit_script(&path);
-                            self.hide_main_and_reset(cx);
+                            let editor_launch_rx = self.launch_editor_with_feedback_async(&path);
+                            cx.spawn(async move |this, cx| {
+                                let Ok(launch_result) = editor_launch_rx.recv().await else {
+                                    return;
+                                };
+
+                                this.update(cx, |this, cx| match launch_result {
+                                    Ok(()) => {
+                                        this.hide_main_and_reset(cx);
+                                    }
+                                    Err(message) => {
+                                        this.show_hud(message, Some(3000), cx);
+                                    }
+                                })
+                                .ok();
+                            })
+                            .detach();
                         } else {
                             self.show_hud(
                                 "Scriptlet has no source file path".to_string(),
@@ -1964,9 +2112,24 @@
                             // Extract just the path without the anchor
                             let path_str = file_path.split('#').next().unwrap_or(file_path);
                             let path = std::path::Path::new(path_str);
-                            self.reveal_in_finder(path);
-                            self.show_hud("Opened in Finder".to_string(), Some(1500), cx);
-                            self.hide_main_and_reset(cx);
+                            let reveal_result_rx = self.reveal_in_finder_with_feedback_async(path);
+                            cx.spawn(async move |this, cx| {
+                                let Ok(reveal_result) = reveal_result_rx.recv().await else {
+                                    return;
+                                };
+
+                                this.update(cx, |this, cx| match reveal_result {
+                                    Ok(()) => {
+                                        this.show_hud("Opened in Finder".to_string(), Some(1500), cx);
+                                        this.hide_main_and_reset(cx);
+                                    }
+                                    Err(message) => {
+                                        this.show_hud(message, Some(2500), cx);
+                                    }
+                                })
+                                .ok();
+                            })
+                            .detach();
                         } else {
                             self.show_hud(
                                 "Scriptlet has no source file path".to_string(),
diff --git a/src/app_actions/tests/editor_launch_feedback.rs b/src/app_actions/tests/editor_launch_feedback.rs
deleted file mode 100644
index 18077766837c78518094e45c0da3b2a672b8bd8b..0000000000000000000000000000000000000000
--- a/src/app_actions/tests/editor_launch_feedback.rs
+++ /dev/null
@@ -1,62 +0,0 @@
-use std::fs;
-
-fn read(path: &str) -> String {
-    fs::read_to_string(path).unwrap_or_else(|_| panic!("Failed to read {path}"))
-}
-
-fn count_occurrences(haystack: &str, needle: &str) -> usize {
-    haystack.match_indices(needle).count()
-}
-
-#[test]
-fn test_edit_actions_show_error_feedback_when_editor_launch_fails() {
-    let content = read("src/app_actions/handle_action.rs");
-
-    assert!(
-        content.contains("fn launch_editor_with_feedback_async"),
-        "Expected async editor launch helper to exist"
-    );
-
-    let usage_count = count_occurrences(&content, "self.launch_editor_with_feedback_async(&path)");
-    assert!(
-        usage_count >= 2,
-        "Expected edit_script and edit_scriptlet to use async editor launch feedback (found {usage_count} usages)"
-    );
-
-    assert!(
-        content.contains("this.show_hud(message, Some(3000), cx);"),
-        "Expected async editor launch failure to surface a HUD error message"
-    );
-}
-
-#[test]
-fn test_reveal_actions_show_success_hud_after_async_reveal_completion() {
-    let content = read("src/app_actions/handle_action.rs");
-
-    assert!(
-        content.contains("fn reveal_in_finder_with_feedback_async"),
-        "Expected async reveal helper to exist"
-    );
-
-    let usage_count = count_occurrences(
-        &content,
-        "self.reveal_in_finder_with_feedback_async(&path)",
-    ) + count_occurrences(
-        &content,
-        "self.reveal_in_finder_with_feedback_async(path)",
-    );
-    assert!(
-        usage_count >= 2,
-        "Expected reveal actions to use async reveal feedback helper (found {usage_count} usages)"
-    );
-
-    assert!(
-        content.contains("let Ok(reveal_result) = reveal_result_rx.recv().await else {"),
-        "Expected reveal actions to await async reveal completion before showing HUD"
-    );
-
-    assert!(
-        content.contains("this.show_hud(\"Opened in Finder\".to_string(), Some(1500), cx);"),
-        "Expected reveal success HUD to be emitted from async completion callback"
-    );
-}

file update:
diff --git a/src/app_actions/handle_action.rs b/src/app_actions/handle_action.rs
index 6512e920f98eb38811debb5dca005d821b3adb44..dda46dd268dc9fe3130c27b221485ba871f1c703
--- a/src/app_actions/handle_action.rs
+++ b/src/app_actions/handle_action.rs
@@ -32,6 +32,109 @@
         });
     }
 
+    /// Reveal a path and return completion back to the UI thread for HUD feedback.
+    fn reveal_in_finder_with_feedback_async(
+        &self,
+        path: &std::path::Path,
+    ) -> async_channel::Receiver<Result<(), String>> {
+        let path_str = path.to_string_lossy().to_string();
+        let (result_tx, result_rx) = async_channel::bounded::<Result<(), String>>(1);
+
+        std::thread::spawn(move || {
+            let file_manager = if cfg!(target_os = "macos") {
+                "Finder"
+            } else if cfg!(target_os = "windows") {
+                "Explorer"
+            } else {
+                "File Manager"
+            };
+
+            logging::log(
+                "UI",
+                &format!(
+                    "ACTION_REVEAL_IN_FINDER_START file_manager='{}' path='{}'",
+                    file_manager, path_str
+                ),
+            );
+
+            let reveal_result = match crate::file_search::reveal_in_finder(&path_str) {
+                Ok(()) => {
+                    logging::log(
+                        "UI",
+                        &format!(
+                            "ACTION_REVEAL_IN_FINDER_SUCCESS file_manager='{}' path='{}'",
+                            file_manager, path_str
+                        ),
+                    );
+                    Ok(())
+                }
+                Err(error) => {
+                    logging::log(
+                        "ERROR",
+                        &format!(
+                            "ACTION_REVEAL_IN_FINDER_FAILED attempted='reveal_in_finder' path='{}' file_manager='{}' error='{}'",
+                            path_str, file_manager, error
+                        ),
+                    );
+                    Err(format!("Failed to reveal in {}: {}", file_manager, error))
+                }
+            };
+
+            let _ = result_tx.send_blocking(reveal_result);
+        });
+
+        result_rx
+    }
+
+    /// Launch the configured editor and return completion back to the UI thread for HUD feedback.
+    fn launch_editor_with_feedback_async(
+        &self,
+        path: &std::path::Path,
+    ) -> async_channel::Receiver<Result<(), String>> {
+        let editor = self.config.get_editor();
+        let path_str = path.to_string_lossy().to_string();
+        let (result_tx, result_rx) = async_channel::bounded::<Result<(), String>>(1);
+
+        std::thread::spawn(move || {
+            use std::process::Command;
+
+            logging::log(
+                "UI",
+                &format!(
+                    "ACTION_EDITOR_LAUNCH_START editor='{}' path='{}'",
+                    editor, path_str
+                ),
+            );
+
+            let launch_result = match Command::new(&editor).arg(&path_str).spawn() {
+                Ok(_) => {
+                    logging::log(
+                        "UI",
+                        &format!(
+                            "ACTION_EDITOR_LAUNCH_SUCCESS editor='{}' path='{}'",
+                            editor, path_str
+                        ),
+                    );
+                    Ok(())
+                }
+                Err(error) => {
+                    logging::log(
+                        "ERROR",
+                        &format!(
+                            "ACTION_EDITOR_LAUNCH_FAILED attempted='{} {}' path='{}' error='{}'",
+                            editor, path_str, path_str, error
+                        ),
+                    );
+                    Err(format!("Failed to open in {}: {}", editor, error))
+                }
+            };
+
+            let _ = result_tx.send_blocking(launch_result);
+        });
+
+        result_rx
+    }
+
     /// Copy text to clipboard using pbcopy on macOS.
     /// Critical: This properly closes stdin before waiting to prevent hangs.
     #[cfg(target_os = "macos")]
@@ -471,9 +574,24 @@
                 };
 
                 if let Some(path) = path_opt {
-                    self.reveal_in_finder(&path);
-                    self.show_hud("Opened in Finder".to_string(), Some(1500), cx);
-                    self.hide_main_and_reset(cx);
+                    let reveal_result_rx = self.reveal_in_finder_with_feedback_async(&path);
+                    cx.spawn(async move |this, cx| {
+                        let Ok(reveal_result) = reveal_result_rx.recv().await else {
+                            return;
+                        };
+
+                        this.update(cx, |this, cx| match reveal_result {
+                            Ok(()) => {
+                                this.show_hud("Opened in Finder".to_string(), Some(1500), cx);
+                                this.hide_main_and_reset(cx);
+                            }
+                            Err(message) => {
+                                this.show_hud(message, Some(2500), cx);
+                            }
+                        })
+                        .ok();
+                    })
+                    .detach();
                 } else {
                     self.show_hud(
                         "Cannot reveal this item type in Finder".to_string(),
@@ -884,8 +1002,23 @@
                     };
 
                     if let Some(path) = path_opt {
-                        self.edit_script(&path);
-                        self.hide_main_and_reset(cx);
+                        let editor_launch_rx = self.launch_editor_with_feedback_async(&path);
+                        cx.spawn(async move |this, cx| {
+                            let Ok(launch_result) = editor_launch_rx.recv().await else {
+                                return;
+                            };
+
+                            this.update(cx, |this, cx| match launch_result {
+                                Ok(()) => {
+                                    this.hide_main_and_reset(cx);
+                                }
+                                Err(message) => {
+                                    this.show_hud(message, Some(3000), cx);
+                                }
+                            })
+                            .ok();
+                        })
+                        .detach();
                     } else {
                         self.show_hud("Cannot edit this item type".to_string(), Some(2000), cx);
                     }
@@ -1932,8 +2065,23 @@
                             // Extract just the path without the anchor (e.g., "/path/to/file.md#slug" -> "/path/to/file.md")
                             let path_str = file_path.split('#').next().unwrap_or(file_path);
                             let path = std::path::PathBuf::from(path_str);
-                            self.edit_script(&path);
-                            self.hide_main_and_reset(cx);
+                            let editor_launch_rx = self.launch_editor_with_feedback_async(&path);
+                            cx.spawn(async move |this, cx| {
+                                let Ok(launch_result) = editor_launch_rx.recv().await else {
+                                    return;
+                                };
+
+                                this.update(cx, |this, cx| match launch_result {
+                                    Ok(()) => {
+                                        this.hide_main_and_reset(cx);
+                                    }
+                                    Err(message) => {
+                                        this.show_hud(message, Some(3000), cx);
+                                    }
+                                })
+                                .ok();
+                            })
+                            .detach();
                         } else {
                             self.show_hud(
                                 "Scriptlet has no source file path".to_string(),
@@ -1964,9 +2112,24 @@
                             // Extract just the path without the anchor
                             let path_str = file_path.split('#').next().unwrap_or(file_path);
                             let path = std::path::Path::new(path_str);
-                            self.reveal_in_finder(path);
-                            self.show_hud("Opened in Finder".to_string(), Some(1500), cx);
-                            self.hide_main_and_reset(cx);
+                            let reveal_result_rx = self.reveal_in_finder_with_feedback_async(path);
+                            cx.spawn(async move |this, cx| {
+                                let Ok(reveal_result) = reveal_result_rx.recv().await else {
+                                    return;
+                                };
+
+                                this.update(cx, |this, cx| match reveal_result {
+                                    Ok(()) => {
+                                        this.show_hud("Opened in Finder".to_string(), Some(1500), cx);
+                                        this.hide_main_and_reset(cx);
+                                    }
+                                    Err(message) => {
+                                        this.show_hud(message, Some(2500), cx);
+                                    }
+                                })
+                                .ok();
+                            })
+                            .detach();
                         } else {
                             self.show_hud(
                                 "Scriptlet has no source file path".to_string(),
diff --git a/src/app_actions/tests/editor_launch_feedback.rs b/src/app_actions/tests/editor_launch_feedback.rs
deleted file mode 100644
index 18077766837c78518094e45c0da3b2a672b8bd8b..0000000000000000000000000000000000000000
--- a/src/app_actions/tests/editor_launch_feedback.rs
+++ /dev/null
@@ -1,62 +0,0 @@
-use std::fs;
-
-fn read(path: &str) -> String {
-    fs::read_to_string(path).unwrap_or_else(|_| panic!("Failed to read {path}"))
-}
-
-fn count_occurrences(haystack: &str, needle: &str) -> usize {
-    haystack.match_indices(needle).count()
-}
-
-#[test]
-fn test_edit_actions_show_error_feedback_when_editor_launch_fails() {
-    let content = read("src/app_actions/handle_action.rs");
-
-    assert!(
-        content.contains("fn launch_editor_with_feedback_async"),
-        "Expected async editor launch helper to exist"
-    );
-
-    let usage_count = count_occurrences(&content, "self.launch_editor_with_feedback_async(&path)");
-    assert!(
-        usage_count >= 2,
-        "Expected edit_script and edit_scriptlet to use async editor launch feedback (found {usage_count} usages)"
-    );
-
-    assert!(
-        content.contains("this.show_hud(message, Some(3000), cx);"),
-        "Expected async editor launch failure to surface a HUD error message"
-    );
-}
-
-#[test]
-fn test_reveal_actions_show_success_hud_after_async_reveal_completion() {
-    let content = read("src/app_actions/handle_action.rs");
-
-    assert!(
-        content.contains("fn reveal_in_finder_with_feedback_async"),
-        "Expected async reveal helper to exist"
-    );
-
-    let usage_count = count_occurrences(
-        &content,
-        "self.reveal_in_finder_with_feedback_async(&path)",
-    ) + count_occurrences(
-        &content,
-        "self.reveal_in_finder_with_feedback_async(path)",
-    );
-    assert!(
-        usage_count >= 2,
-        "Expected reveal actions to use async reveal feedback helper (found {usage_count} usages)"
-    );
-
-    assert!(
-        content.contains("let Ok(reveal_result) = reveal_result_rx.recv().await else {"),
-        "Expected reveal actions to await async reveal completion before showing HUD"
-    );
-
-    assert!(
-        content.contains("this.show_hud(\"Opened in Finder\".to_string(), Some(1500), cx);"),
-        "Expected reveal success HUD to be emitted from async completion callback"
-    );
-}


thinking
**Preparing test addition**
exec
/bin/zsh -lc "nl -ba src/app_actions/helpers.rs | sed -n '160,360p'" in /Users/johnlindquist/dev/script-kit-gpui succeeded in 51ms:
   160	        }
   161	    }
   162	}
   163	
   164	#[cfg(test)]
   165	mod app_actions_tests {
   166	    use super::{
   167	        clipboard_pin_action_success_hud, extract_scriptlet_source_path,
   168	        file_search_action_error_hud_prefix, file_search_action_success_hud,
   169	        selection_required_message_for_action, should_transition_to_script_list_after_action,
   170	        script_removal_target_from_result, select_clipboard_entry_meta, ScriptRemovalTarget,
   171	    };
   172	    use crate::AppView;
   173	    use crate::clipboard_history::{ClipboardEntryMeta, ContentType};
   174	    use crate::scripts;
   175	    use std::path::PathBuf;
   176	    use std::sync::Arc;
   177	
   178	    fn entry(id: &str, preview: &str) -> ClipboardEntryMeta {
   179	        ClipboardEntryMeta {
file update:
diff --git a/src/app_actions/handle_action.rs b/src/app_actions/handle_action.rs
index 6512e920f98eb38811debb5dca005d821b3adb44..dda46dd268dc9fe3130c27b221485ba871f1c703
--- a/src/app_actions/handle_action.rs
+++ b/src/app_actions/handle_action.rs
@@ -32,6 +32,109 @@
         });
     }
 
+    /// Reveal a path and return completion back to the UI thread for HUD feedback.
+    fn reveal_in_finder_with_feedback_async(
+        &self,
+        path: &std::path::Path,
+    ) -> async_channel::Receiver<Result<(), String>> {
+        let path_str = path.to_string_lossy().to_string();
+        let (result_tx, result_rx) = async_channel::bounded::<Result<(), String>>(1);
+
+        std::thread::spawn(move || {
+            let file_manager = if cfg!(target_os = "macos") {
+                "Finder"
+            } else if cfg!(target_os = "windows") {
+                "Explorer"
+            } else {
+                "File Manager"
+            };
+
+            logging::log(
+                "UI",
+                &format!(
+                    "ACTION_REVEAL_IN_FINDER_START file_manager='{}' path='{}'",
+                    file_manager, path_str
+                ),
+            );
+
+            let reveal_result = match crate::file_search::reveal_in_finder(&path_str) {
+                Ok(()) => {
+                    logging::log(
+                        "UI",
+                        &format!(
+                            "ACTION_REVEAL_IN_FINDER_SUCCESS file_manager='{}' path='{}'",
+                            file_manager, path_str
+                        ),
+                    );
+                    Ok(())
+                }
+                Err(error) => {
+                    logging::log(
+                        "ERROR",
+                        &format!(
+                            "ACTION_REVEAL_IN_FINDER_FAILED attempted='reveal_in_finder' path='{}' file_manager='{}' error='{}'",
+                            path_str, file_manager, error
+                        ),
+                    );
+                    Err(format!("Failed to reveal in {}: {}", file_manager, error))
+                }
+            };
+
+            let _ = result_tx.send_blocking(reveal_result);
+        });
+
+        result_rx
+    }
+
+    /// Launch the configured editor and return completion back to the UI thread for HUD feedback.
+    fn launch_editor_with_feedback_async(
+        &self,
+        path: &std::path::Path,
+    ) -> async_channel::Receiver<Result<(), String>> {
+        let editor = self.config.get_editor();
+        let path_str = path.to_string_lossy().to_string();
+        let (result_tx, result_rx) = async_channel::bounded::<Result<(), String>>(1);
+
+        std::thread::spawn(move || {
+            use std::process::Command;
+
+            logging::log(
+                "UI",
+                &format!(
+                    "ACTION_EDITOR_LAUNCH_START editor='{}' path='{}'",
+                    editor, path_str
+                ),
+            );
+
+            let launch_result = match Command::new(&editor).arg(&path_str).spawn() {
+                Ok(_) => {
+                    logging::log(
+                        "UI",
+                        &format!(
+                            "ACTION_EDITOR_LAUNCH_SUCCESS editor='{}' path='{}'",
+                            editor, path_str
+                        ),
+                    );
+                    Ok(())
+                }
+                Err(error) => {
+                    logging::log(
+                        "ERROR",
+                        &format!(
+                            "ACTION_EDITOR_LAUNCH_FAILED attempted='{} {}' path='{}' error='{}'",
+                            editor, path_str, path_str, error
+                        ),
+                    );
+                    Err(format!("Failed to open in {}: {}", editor, error))
+                }
+            };
+
+            let _ = result_tx.send_blocking(launch_result);
+        });
+
+        result_rx
+    }
+
     /// Copy text to clipboard using pbcopy on macOS.
     /// Critical: This properly closes stdin before waiting to prevent hangs.
     #[cfg(target_os = "macos")]
@@ -471,9 +574,24 @@
                 };
 
                 if let Some(path) = path_opt {
-                    self.reveal_in_finder(&path);
-                    self.show_hud("Opened in Finder".to_string(), Some(1500), cx);
-                    self.hide_main_and_reset(cx);
+                    let reveal_result_rx = self.reveal_in_finder_with_feedback_async(&path);
+                    cx.spawn(async move |this, cx| {
+                        let Ok(reveal_result) = reveal_result_rx.recv().await else {
+                            return;
+                        };
+
+                        this.update(cx, |this, cx| match reveal_result {
+                            Ok(()) => {
+                                this.show_hud("Opened in Finder".to_string(), Some(1500), cx);
+                                this.hide_main_and_reset(cx);
+                            }
+                            Err(message) => {
+                                this.show_hud(message, Some(2500), cx);
+                            }
+                        })
+                        .ok();
+                    })
+                    .detach();
                 } else {
                     self.show_hud(
                         "Cannot reveal this item type in Finder".to_string(),
@@ -884,8 +1002,23 @@
                     };
 
                     if let Some(path) = path_opt {
-                        self.edit_script(&path);
-                        self.hide_main_and_reset(cx);
+                        let editor_launch_rx = self.launch_editor_with_feedback_async(&path);
+                        cx.spawn(async move |this, cx| {
+                            let Ok(launch_result) = editor_launch_rx.recv().await else {
+                                return;
+                            };
+
+                            this.update(cx, |this, cx| match launch_result {
+                                Ok(()) => {
+                                    this.hide_main_and_reset(cx);
+                                }
+                                Err(message) => {
+                                    this.show_hud(message, Some(3000), cx);
+                                }
+                            })
+                            .ok();
+                        })
+                        .detach();
                     } else {
                         self.show_hud("Cannot edit this item type".to_string(), Some(2000), cx);
                     }
@@ -1932,8 +2065,23 @@
                             // Extract just the path without the anchor (e.g., "/path/to/file.md#slug" -> "/path/to/file.md")
                             let path_str = file_path.split('#').next().unwrap_or(file_path);
                             let path = std::path::PathBuf::from(path_str);
-                            self.edit_script(&path);
-                            self.hide_main_and_reset(cx);
+                            let editor_launch_rx = self.launch_editor_with_feedback_async(&path);
+                            cx.spawn(async move |this, cx| {
+                                let Ok(launch_result) = editor_launch_rx.recv().await else {
+                                    return;
+                                };
+
+                                this.update(cx, |this, cx| match launch_result {
+                                    Ok(()) => {
+                                        this.hide_main_and_reset(cx);
+                                    }
+                                    Err(message) => {
+                                        this.show_hud(message, Some(3000), cx);
+                                    }
+                                })
+                                .ok();
+                            })
+                            .detach();
                         } else {
                             self.show_hud(
                                 "Scriptlet has no source file path".to_string(),
@@ -1964,9 +2112,24 @@
                             // Extract just the path without the anchor
                             let path_str = file_path.split('#').next().unwrap_or(file_path);
                             let path = std::path::Path::new(path_str);
-                            self.reveal_in_finder(path);
-                            self.show_hud("Opened in Finder".to_string(), Some(1500), cx);
-                            self.hide_main_and_reset(cx);
+                            let reveal_result_rx = self.reveal_in_finder_with_feedback_async(path);
+                            cx.spawn(async move |this, cx| {
+                                let Ok(reveal_result) = reveal_result_rx.recv().await else {
+                                    return;
+                                };
+
+                                this.update(cx, |this, cx| match reveal_result {
+                                    Ok(()) => {
+                                        this.show_hud("Opened in Finder".to_string(), Some(1500), cx);
+                                        this.hide_main_and_reset(cx);
+                                    }
+                                    Err(message) => {
+                                        this.show_hud(message, Some(2500), cx);
+                                    }
+                                })
+                                .ok();
+                            })
+                            .detach();
                         } else {
                             self.show_hud(
                                 "Scriptlet has no source file path".to_string(),
diff --git a/src/app_actions/tests/editor_launch_feedback.rs b/src/app_actions/tests/editor_launch_feedback.rs
deleted file mode 100644
index 18077766837c78518094e45c0da3b2a672b8bd8b..0000000000000000000000000000000000000000
--- a/src/app_actions/tests/editor_launch_feedback.rs
+++ /dev/null
@@ -1,62 +0,0 @@
-use std::fs;
-
-fn read(path: &str) -> String {
-    fs::read_to_string(path).unwrap_or_else(|_| panic!("Failed to read {path}"))
-}
-
-fn count_occurrences(haystack: &str, needle: &str) -> usize {
-    haystack.match_indices(needle).count()
-}
-
-#[test]
-fn test_edit_actions_show_error_feedback_when_editor_launch_fails() {
-    let content = read("src/app_actions/handle_action.rs");
-
-    assert!(
-        content.contains("fn launch_editor_with_feedback_async"),
-        "Expected async editor launch helper to exist"
-    );
-
-    let usage_count = count_occurrences(&content, "self.launch_editor_with_feedback_async(&path)");
-    assert!(
-        usage_count >= 2,
-        "Expected edit_script and edit_scriptlet to use async editor launch feedback (found {usage_count} usages)"
-    );
-
-    assert!(
-        content.contains("this.show_hud(message, Some(3000), cx);"),
-        "Expected async editor launch failure to surface a HUD error message"
-    );
-}
-
-#[test]
-fn test_reveal_actions_show_success_hud_after_async_reveal_completion() {
-    let content = read("src/app_actions/handle_action.rs");
-
-    assert!(
-        content.contains("fn reveal_in_finder_with_feedback_async"),
-        "Expected async reveal helper to exist"
-    );
-
-    let usage_count = count_occurrences(
-        &content,
-        "self.reveal_in_finder_with_feedback_async(&path)",
-    ) + count_occurrences(
-        &content,
-        "self.reveal_in_finder_with_feedback_async(path)",
-    );
-    assert!(
-        usage_count >= 2,
-        "Expected reveal actions to use async reveal feedback helper (found {usage_count} usages)"
-    );
-
-    assert!(
-        content.contains("let Ok(reveal_result) = reveal_result_rx.recv().await else {"),
-        "Expected reveal actions to await async reveal completion before showing HUD"
-    );
-
-    assert!(
-        content.contains("this.show_hud(\"Opened in Finder\".to_string(), Some(1500), cx);"),
-        "Expected reveal success HUD to be emitted from async completion callback"
-    );
-}


thinking
**Continuing tail traversal for append**
exec
/bin/zsh -lc "nl -ba src/app_actions/helpers.rs | sed -n '360,520p'" in /Users/johnlindquist/dev/script-kit-gpui succeeded in 51ms:
   360	            Some(ScriptRemovalTarget {
   361	                path: PathBuf::from("/tmp/snippets/tools.md"),
   362	                name: "Open GitHub".to_string(),
   363	                item_kind: "scriptlet",
   364	            })
   365	        );
   366	    }
   367	}
file update:
diff --git a/src/app_actions/handle_action.rs b/src/app_actions/handle_action.rs
index 6512e920f98eb38811debb5dca005d821b3adb44..dda46dd268dc9fe3130c27b221485ba871f1c703
--- a/src/app_actions/handle_action.rs
+++ b/src/app_actions/handle_action.rs
@@ -32,6 +32,109 @@
         });
     }
 
+    /// Reveal a path and return completion back to the UI thread for HUD feedback.
+    fn reveal_in_finder_with_feedback_async(
+        &self,
+        path: &std::path::Path,
+    ) -> async_channel::Receiver<Result<(), String>> {
+        let path_str = path.to_string_lossy().to_string();
+        let (result_tx, result_rx) = async_channel::bounded::<Result<(), String>>(1);
+
+        std::thread::spawn(move || {
+            let file_manager = if cfg!(target_os = "macos") {
+                "Finder"
+            } else if cfg!(target_os = "windows") {
+                "Explorer"
+            } else {
+                "File Manager"
+            };
+
+            logging::log(
+                "UI",
+                &format!(
+                    "ACTION_REVEAL_IN_FINDER_START file_manager='{}' path='{}'",
+                    file_manager, path_str
+                ),
+            );
+
+            let reveal_result = match crate::file_search::reveal_in_finder(&path_str) {
+                Ok(()) => {
+                    logging::log(
+                        "UI",
+                        &format!(
+                            "ACTION_REVEAL_IN_FINDER_SUCCESS file_manager='{}' path='{}'",
+                            file_manager, path_str
+                        ),
+                    );
+                    Ok(())
+                }
+                Err(error) => {
+                    logging::log(
+                        "ERROR",
+                        &format!(
+                            "ACTION_REVEAL_IN_FINDER_FAILED attempted='reveal_in_finder' path='{}' file_manager='{}' error='{}'",
+                            path_str, file_manager, error
+                        ),
+                    );
+                    Err(format!("Failed to reveal in {}: {}", file_manager, error))
+                }
+            };
+
+            let _ = result_tx.send_blocking(reveal_result);
+        });
+
+        result_rx
+    }
+
+    /// Launch the configured editor and return completion back to the UI thread for HUD feedback.
+    fn launch_editor_with_feedback_async(
+        &self,
+        path: &std::path::Path,
+    ) -> async_channel::Receiver<Result<(), String>> {
+        let editor = self.config.get_editor();
+        let path_str = path.to_string_lossy().to_string();
+        let (result_tx, result_rx) = async_channel::bounded::<Result<(), String>>(1);
+
+        std::thread::spawn(move || {
+            use std::process::Command;
+
+            logging::log(
+                "UI",
+                &format!(
+                    "ACTION_EDITOR_LAUNCH_START editor='{}' path='{}'",
+                    editor, path_str
+                ),
+            );
+
+            let launch_result = match Command::new(&editor).arg(&path_str).spawn() {
+                Ok(_) => {
+                    logging::log(
+                        "UI",
+                        &format!(
+                            "ACTION_EDITOR_LAUNCH_SUCCESS editor='{}' path='{}'",
+                            editor, path_str
+                        ),
+                    );
+                    Ok(())
+                }
+                Err(error) => {
+                    logging::log(
+                        "ERROR",
+                        &format!(
+                            "ACTION_EDITOR_LAUNCH_FAILED attempted='{} {}' path='{}' error='{}'",
+                            editor, path_str, path_str, error
+                        ),
+                    );
+                    Err(format!("Failed to open in {}: {}", editor, error))
+                }
+            };
+
+            let _ = result_tx.send_blocking(launch_result);
+        });
+
+        result_rx
+    }
+
     /// Copy text to clipboard using pbcopy on macOS.
     /// Critical: This properly closes stdin before waiting to prevent hangs.
     #[cfg(target_os = "macos")]
@@ -471,9 +574,24 @@
                 };
 
                 if let Some(path) = path_opt {
-                    self.reveal_in_finder(&path);
-                    self.show_hud("Opened in Finder".to_string(), Some(1500), cx);
-                    self.hide_main_and_reset(cx);
+                    let reveal_result_rx = self.reveal_in_finder_with_feedback_async(&path);
+                    cx.spawn(async move |this, cx| {
+                        let Ok(reveal_result) = reveal_result_rx.recv().await else {
+                            return;
+                        };
+
+                        this.update(cx, |this, cx| match reveal_result {
+                            Ok(()) => {
+                                this.show_hud("Opened in Finder".to_string(), Some(1500), cx);
+                                this.hide_main_and_reset(cx);
+                            }
+                            Err(message) => {
+                                this.show_hud(message, Some(2500), cx);
+                            }
+                        })
+                        .ok();
+                    })
+                    .detach();
                 } else {
                     self.show_hud(
                         "Cannot reveal this item type in Finder".to_string(),
@@ -884,8 +1002,23 @@
                     };
 
                     if let Some(path) = path_opt {
-                        self.edit_script(&path);
-                        self.hide_main_and_reset(cx);
+                        let editor_launch_rx = self.launch_editor_with_feedback_async(&path);
+                        cx.spawn(async move |this, cx| {
+                            let Ok(launch_result) = editor_launch_rx.recv().await else {
+                                return;
+                            };
+
+                            this.update(cx, |this, cx| match launch_result {
+                                Ok(()) => {
+                                    this.hide_main_and_reset(cx);
+                                }
+                                Err(message) => {
+                                    this.show_hud(message, Some(3000), cx);
+                                }
+                            })
+                            .ok();
+                        })
+                        .detach();
                     } else {
                         self.show_hud("Cannot edit this item type".to_string(), Some(2000), cx);
                     }
@@ -1932,8 +2065,23 @@
                             // Extract just the path without the anchor (e.g., "/path/to/file.md#slug" -> "/path/to/file.md")
                             let path_str = file_path.split('#').next().unwrap_or(file_path);
                             let path = std::path::PathBuf::from(path_str);
-                            self.edit_script(&path);
-                            self.hide_main_and_reset(cx);
+                            let editor_launch_rx = self.launch_editor_with_feedback_async(&path);
+                            cx.spawn(async move |this, cx| {
+                                let Ok(launch_result) = editor_launch_rx.recv().await else {
+                                    return;
+                                };
+
+                                this.update(cx, |this, cx| match launch_result {
+                                    Ok(()) => {
+                                        this.hide_main_and_reset(cx);
+                                    }
+                                    Err(message) => {
+                                        this.show_hud(message, Some(3000), cx);
+                                    }
+                                })
+                                .ok();
+                            })
+                            .detach();
                         } else {
                             self.show_hud(
                                 "Scriptlet has no source file path".to_string(),
@@ -1964,9 +2112,24 @@
                             // Extract just the path without the anchor
                             let path_str = file_path.split('#').next().unwrap_or(file_path);
                             let path = std::path::Path::new(path_str);
-                            self.reveal_in_finder(path);
-                            self.show_hud("Opened in Finder".to_string(), Some(1500), cx);
-                            self.hide_main_and_reset(cx);
+                            let reveal_result_rx = self.reveal_in_finder_with_feedback_async(path);
+                            cx.spawn(async move |this, cx| {
+                                let Ok(reveal_result) = reveal_result_rx.recv().await else {
+                                    return;
+                                };
+
+                                this.update(cx, |this, cx| match reveal_result {
+                                    Ok(()) => {
+                                        this.show_hud("Opened in Finder".to_string(), Some(1500), cx);
+                                        this.hide_main_and_reset(cx);
+                                    }
+                                    Err(message) => {
+                                        this.show_hud(message, Some(2500), cx);
+                                    }
+                                })
+                                .ok();
+                            })
+                            .detach();
                         } else {
                             self.show_hud(
                                 "Scriptlet has no source file path".to_string(),
diff --git a/src/app_actions/tests/editor_launch_feedback.rs b/src/app_actions/tests/editor_launch_feedback.rs
deleted file mode 100644
index 18077766837c78518094e45c0da3b2a672b8bd8b..0000000000000000000000000000000000000000
--- a/src/app_actions/tests/editor_launch_feedback.rs
+++ /dev/null
@@ -1,62 +0,0 @@
-use std::fs;
-
-fn read(path: &str) -> String {
-    fs::read_to_string(path).unwrap_or_else(|_| panic!("Failed to read {path}"))
-}
-
-fn count_occurrences(haystack: &str, needle: &str) -> usize {
-    haystack.match_indices(needle).count()
-}
-
-#[test]
-fn test_edit_actions_show_error_feedback_when_editor_launch_fails() {
-    let content = read("src/app_actions/handle_action.rs");
-
-    assert!(
-        content.contains("fn launch_editor_with_feedback_async"),
-        "Expected async editor launch helper to exist"
-    );
-
-    let usage_count = count_occurrences(&content, "self.launch_editor_with_feedback_async(&path)");
-    assert!(
-        usage_count >= 2,
-        "Expected edit_script and edit_scriptlet to use async editor launch feedback (found {usage_count} usages)"
-    );
-
-    assert!(
-        content.contains("this.show_hud(message, Some(3000), cx);"),
-        "Expected async editor launch failure to surface a HUD error message"
-    );
-}
-
-#[test]
-fn test_reveal_actions_show_success_hud_after_async_reveal_completion() {
-    let content = read("src/app_actions/handle_action.rs");
-
-    assert!(
-        content.contains("fn reveal_in_finder_with_feedback_async"),
-        "Expected async reveal helper to exist"
-    );
-
-    let usage_count = count_occurrences(
-        &content,
-        "self.reveal_in_finder_with_feedback_async(&path)",
-    ) + count_occurrences(
-        &content,
-        "self.reveal_in_finder_with_feedback_async(path)",
-    );
-    assert!(
-        usage_count >= 2,
-        "Expected reveal actions to use async reveal feedback helper (found {usage_count} usages)"
-    );
-
-    assert!(
-        content.contains("let Ok(reveal_result) = reveal_result_rx.recv().await else {"),
-        "Expected reveal actions to await async reveal completion before showing HUD"
-    );
-
-    assert!(
-        content.contains("this.show_hud(\"Opened in Finder\".to_string(), Some(1500), cx);"),
-        "Expected reveal success HUD to be emitted from async completion callback"
-    );
-}


thinking
**Adding file read helper in tests**
file update
M /Users/johnlindquist/dev/script-kit-gpui/src/app_actions/helpers.rs
@@ -174,2 +174,3 @@
     use crate::scripts;
+    use std::fs;
     use std::path::PathBuf;
@@ -191,2 +192,10 @@
 
+    fn read(path: &str) -> String {
+        fs::read_to_string(path).unwrap_or_else(|_| panic!("Failed to read {path}"))
+    }
+
+    fn count_occurrences(haystack: &str, needle: &str) -> usize {
+        haystack.match_indices(needle).count()
+    }
+
     #[test]
@@ -366,2 +375,56 @@
     }
+
+    #[test]
+    fn test_edit_actions_show_error_feedback_when_editor_launch_fails() {
+        let content = read("src/app_actions/handle_action.rs");
+
+        assert!(
+            content.contains("fn launch_editor_with_feedback_async"),
+            "Expected async editor launch helper to exist"
+        );
+
+        let usage_count =
+            count_occurrences(&content, "self.launch_editor_with_feedback_async(&path)");
+        assert!(
+            usage_count >= 2,
+            "Expected edit_script and edit_scriptlet to use async editor launch feedback (found {usage_count} usages)"
+        );
+
+        assert!(
+            content.contains("this.show_hud(message, Some(3000), cx);"),
+            "Expected async editor launch failure to surface a HUD error message"
+        );
+    }
+
+    #[test]
+    fn test_reveal_actions_show_success_hud_after_async_completion() {
+        let content = read("src/app_actions/handle_action.rs");
+
+        assert!(
+            content.contains("fn reveal_in_finder_with_feedback_async"),
+            "Expected async reveal helper to exist"
+        );
+
+        let usage_count = count_occurrences(
+            &content,
+            "self.reveal_in_finder_with_feedback_async(&path)",
+        ) + count_occurrences(
+            &content,
+            "self.reveal_in_finder_with_feedback_async(path)",
+        );
+        assert!(
+            usage_count >= 2,
+            "Expected reveal actions to use async reveal feedback helper (found {usage_count} usages)"
+        );
+
+        assert!(
+            content.contains("let Ok(reveal_result) = reveal_result_rx.recv().await else {"),
+            "Expected reveal actions to await reveal completion before showing HUD"
+        );
+
+        assert!(
+            content.contains("this.show_hud(\"Opened in Finder\".to_string(), Some(1500), cx);"),
+            "Expected reveal success HUD to be emitted from async completion callback"
+        );
+    }
 }
apply_patch(auto_approved=true) exited 0 in 21ms:
Success. Updated the following files:
M /Users/johnlindquist/dev/script-kit-gpui/src/app_actions/helpers.rs
file update:
diff --git a/src/app_actions/handle_action.rs b/src/app_actions/handle_action.rs
index 6512e920f98eb38811debb5dca005d821b3adb44..dda46dd268dc9fe3130c27b221485ba871f1c703
--- a/src/app_actions/handle_action.rs
+++ b/src/app_actions/handle_action.rs
@@ -32,6 +32,109 @@
         });
     }
 
+    /// Reveal a path and return completion back to the UI thread for HUD feedback.
+    fn reveal_in_finder_with_feedback_async(
+        &self,
+        path: &std::path::Path,
+    ) -> async_channel::Receiver<Result<(), String>> {
+        let path_str = path.to_string_lossy().to_string();
+        let (result_tx, result_rx) = async_channel::bounded::<Result<(), String>>(1);
+
+        std::thread::spawn(move || {
+            let file_manager = if cfg!(target_os = "macos") {
+                "Finder"
+            } else if cfg!(target_os = "windows") {
+                "Explorer"
+            } else {
+                "File Manager"
+            };
+
+            logging::log(
+                "UI",
+                &format!(
+                    "ACTION_REVEAL_IN_FINDER_START file_manager='{}' path='{}'",
+                    file_manager, path_str
+                ),
+            );
+
+            let reveal_result = match crate::file_search::reveal_in_finder(&path_str) {
+                Ok(()) => {
+                    logging::log(
+                        "UI",
+                        &format!(
+                            "ACTION_REVEAL_IN_FINDER_SUCCESS file_manager='{}' path='{}'",
+                            file_manager, path_str
+                        ),
+                    );
+                    Ok(())
+                }
+                Err(error) => {
+                    logging::log(
+                        "ERROR",
+                        &format!(
+                            "ACTION_REVEAL_IN_FINDER_FAILED attempted='reveal_in_finder' path='{}' file_manager='{}' error='{}'",
+                            path_str, file_manager, error
+                        ),
+                    );
+                    Err(format!("Failed to reveal in {}: {}", file_manager, error))
+                }
+            };
+
+            let _ = result_tx.send_blocking(reveal_result);
+        });
+
+        result_rx
+    }
+
+    /// Launch the configured editor and return completion back to the UI thread for HUD feedback.
+    fn launch_editor_with_feedback_async(
+        &self,
+        path: &std::path::Path,
+    ) -> async_channel::Receiver<Result<(), String>> {
+        let editor = self.config.get_editor();
+        let path_str = path.to_string_lossy().to_string();
+        let (result_tx, result_rx) = async_channel::bounded::<Result<(), String>>(1);
+
+        std::thread::spawn(move || {
+            use std::process::Command;
+
+            logging::log(
+                "UI",
+                &format!(
+                    "ACTION_EDITOR_LAUNCH_START editor='{}' path='{}'",
+                    editor, path_str
+                ),
+            );
+
+            let launch_result = match Command::new(&editor).arg(&path_str).spawn() {
+                Ok(_) => {
+                    logging::log(
+                        "UI",
+                        &format!(
+                            "ACTION_EDITOR_LAUNCH_SUCCESS editor='{}' path='{}'",
+                            editor, path_str
+                        ),
+                    );
+                    Ok(())
+                }
+                Err(error) => {
+                    logging::log(
+                        "ERROR",
+                        &format!(
+                            "ACTION_EDITOR_LAUNCH_FAILED attempted='{} {}' path='{}' error='{}'",
+                            editor, path_str, path_str, error
+                        ),
+                    );
+                    Err(format!("Failed to open in {}: {}", editor, error))
+                }
+            };
+
+            let _ = result_tx.send_blocking(launch_result);
+        });
+
+        result_rx
+    }
+
     /// Copy text to clipboard using pbcopy on macOS.
     /// Critical: This properly closes stdin before waiting to prevent hangs.
     #[cfg(target_os = "macos")]
@@ -471,9 +574,24 @@
                 };
 
                 if let Some(path) = path_opt {
-                    self.reveal_in_finder(&path);
-                    self.show_hud("Opened in Finder".to_string(), Some(1500), cx);
-                    self.hide_main_and_reset(cx);
+                    let reveal_result_rx = self.reveal_in_finder_with_feedback_async(&path);
+                    cx.spawn(async move |this, cx| {
+                        let Ok(reveal_result) = reveal_result_rx.recv().await else {
+                            return;
+                        };
+
+                        this.update(cx, |this, cx| match reveal_result {
+                            Ok(()) => {
+                                this.show_hud("Opened in Finder".to_string(), Some(1500), cx);
+                                this.hide_main_and_reset(cx);
+                            }
+                            Err(message) => {
+                                this.show_hud(message, Some(2500), cx);
+                            }
+                        })
+                        .ok();
+                    })
+                    .detach();
                 } else {
                     self.show_hud(
                         "Cannot reveal this item type in Finder".to_string(),
@@ -884,8 +1002,23 @@
                     };
 
                     if let Some(path) = path_opt {
-                        self.edit_script(&path);
-                        self.hide_main_and_reset(cx);
+                        let editor_launch_rx = self.launch_editor_with_feedback_async(&path);
+                        cx.spawn(async move |this, cx| {
+                            let Ok(launch_result) = editor_launch_rx.recv().await else {
+                                return;
+                            };
+
+                            this.update(cx, |this, cx| match launch_result {
+                                Ok(()) => {
+                                    this.hide_main_and_reset(cx);
+                                }
+                                Err(message) => {
+                                    this.show_hud(message, Some(3000), cx);
+                                }
+                            })
+                            .ok();
+                        })
+                        .detach();
                     } else {
                         self.show_hud("Cannot edit this item type".to_string(), Some(2000), cx);
                     }
@@ -1932,8 +2065,23 @@
                             // Extract just the path without the anchor (e.g., "/path/to/file.md#slug" -> "/path/to/file.md")
                             let path_str = file_path.split('#').next().unwrap_or(file_path);
                             let path = std::path::PathBuf::from(path_str);
-                            self.edit_script(&path);
-                            self.hide_main_and_reset(cx);
+                            let editor_launch_rx = self.launch_editor_with_feedback_async(&path);
+                            cx.spawn(async move |this, cx| {
+                                let Ok(launch_result) = editor_launch_rx.recv().await else {
+                                    return;
+                                };
+
+                                this.update(cx, |this, cx| match launch_result {
+                                    Ok(()) => {
+                                        this.hide_main_and_reset(cx);
+                                    }
+                                    Err(message) => {
+                                        this.show_hud(message, Some(3000), cx);
+                                    }
+                                })
+                                .ok();
+                            })
+                            .detach();
                         } else {
                             self.show_hud(
                                 "Scriptlet has no source file path".to_string(),
@@ -1964,9 +2112,24 @@
                             // Extract just the path without the anchor
                             let path_str = file_path.split('#').next().unwrap_or(file_path);
                             let path = std::path::Path::new(path_str);
-                            self.reveal_in_finder(path);
-                            self.show_hud("Opened in Finder".to_string(), Some(1500), cx);
-                            self.hide_main_and_reset(cx);
+                            let reveal_result_rx = self.reveal_in_finder_with_feedback_async(path);
+                            cx.spawn(async move |this, cx| {
+                                let Ok(reveal_result) = reveal_result_rx.recv().await else {
+                                    return;
+                                };
+
+                                this.update(cx, |this, cx| match reveal_result {
+                                    Ok(()) => {
+                                        this.show_hud("Opened in Finder".to_string(), Some(1500), cx);
+                                        this.hide_main_and_reset(cx);
+                                    }
+                                    Err(message) => {
+                                        this.show_hud(message, Some(2500), cx);
+                                    }
+                                })
+                                .ok();
+                            })
+                            .detach();
                         } else {
                             self.show_hud(
                                 "Scriptlet has no source file path".to_string(),
diff --git a/src/app_actions/helpers.rs b/src/app_actions/helpers.rs
index fb50657be41d2650d4e4be37f320f8f2393149b1..b350404d02dd71610199202b59f4fd97d4f27b35
--- a/src/app_actions/helpers.rs
+++ b/src/app_actions/helpers.rs
@@ -172,6 +172,7 @@
     use crate::AppView;
     use crate::clipboard_history::{ClipboardEntryMeta, ContentType};
     use crate::scripts;
+    use std::fs;
     use std::path::PathBuf;
     use std::sync::Arc;
 
@@ -189,6 +190,14 @@
         }
     }
 
+    fn read(path: &str) -> String {
+        fs::read_to_string(path).unwrap_or_else(|_| panic!("Failed to read {path}"))
+    }
+
+    fn count_occurrences(haystack: &str, needle: &str) -> usize {
+        haystack.match_indices(needle).count()
+    }
+
     #[test]
     fn test_select_clipboard_entry_meta_filters_and_clamps() {
         let entries = vec![entry("1", "Alpha"), entry("2", "Beta"), entry("3", "Gamma")];
@@ -364,4 +373,58 @@
             })
         );
     }
+
+    #[test]
+    fn test_edit_actions_show_error_feedback_when_editor_launch_fails() {
+        let content = read("src/app_actions/handle_action.rs");
+
+        assert!(
+            content.contains("fn launch_editor_with_feedback_async"),
+            "Expected async editor launch helper to exist"
+        );
+
+        let usage_count =
+            count_occurrences(&content, "self.launch_editor_with_feedback_async(&path)");
+        assert!(
+            usage_count >= 2,
+            "Expected edit_script and edit_scriptlet to use async editor launch feedback (found {usage_count} usages)"
+        );
+
+        assert!(
+            content.contains("this.show_hud(message, Some(3000), cx);"),
+            "Expected async editor launch failure to surface a HUD error message"
+        );
+    }
+
+    #[test]
+    fn test_reveal_actions_show_success_hud_after_async_completion() {
+        let content = read("src/app_actions/handle_action.rs");
+
+        assert!(
+            content.contains("fn reveal_in_finder_with_feedback_async"),
+            "Expected async reveal helper to exist"
+        );
+
+        let usage_count = count_occurrences(
+            &content,
+            "self.reveal_in_finder_with_feedback_async(&path)",
+        ) + count_occurrences(
+            &content,
+            "self.reveal_in_finder_with_feedback_async(path)",
+        );
+        assert!(
+            usage_count >= 2,
+            "Expected reveal actions to use async reveal feedback helper (found {usage_count} usages)"
+        );
+
+        assert!(
+            content.contains("let Ok(reveal_result) = reveal_result_rx.recv().await else {"),
+            "Expected reveal actions to await reveal completion before showing HUD"
+        );
+
+        assert!(
+            content.contains("this.show_hud(\"Opened in Finder\".to_string(), Some(1500), cx);"),
+            "Expected reveal success HUD to be emitted from async completion callback"
+        );
+    }
 }
diff --git a/src/app_actions/tests/editor_launch_feedback.rs b/src/app_actions/tests/editor_launch_feedback.rs
deleted file mode 100644
index 18077766837c78518094e45c0da3b2a672b8bd8b..0000000000000000000000000000000000000000
--- a/src/app_actions/tests/editor_launch_feedback.rs
+++ /dev/null
@@ -1,62 +0,0 @@
-use std::fs;
-
-fn read(path: &str) -> String {
-    fs::read_to_string(path).unwrap_or_else(|_| panic!("Failed to read {path}"))
-}
-
-fn count_occurrences(haystack: &str, needle: &str) -> usize {
-    haystack.match_indices(needle).count()
-}
-
-#[test]
-fn test_edit_actions_show_error_feedback_when_editor_launch_fails() {
-    let content = read("src/app_actions/handle_action.rs");
-
-    assert!(
-        content.contains("fn launch_editor_with_feedback_async"),
-        "Expected async editor launch helper to exist"
-    );
-
-    let usage_count = count_occurrences(&content, "self.launch_editor_with_feedback_async(&path)");
-    assert!(
-        usage_count >= 2,
-        "Expected edit_script and edit_scriptlet to use async editor launch feedback (found {usage_count} usages)"
-    );
-
-    assert!(
-        content.contains("this.show_hud(message, Some(3000), cx);"),
-        "Expected async editor launch failure to surface a HUD error message"
-    );
-}
-
-#[test]
-fn test_reveal_actions_show_success_hud_after_async_reveal_completion() {
-    let content = read("src/app_actions/handle_action.rs");
-
-    assert!(
-        content.contains("fn reveal_in_finder_with_feedback_async"),
-        "Expected async reveal helper to exist"
-    );
-
-    let usage_count = count_occurrences(
-        &content,
-        "self.reveal_in_finder_with_feedback_async(&path)",
-    ) + count_occurrences(
-        &content,
-        "self.reveal_in_finder_with_feedback_async(path)",
-    );
-    assert!(
-        usage_count >= 2,
-        "Expected reveal actions to use async reveal feedback helper (found {usage_count} usages)"
-    );
-
-    assert!(
-        content.contains("let Ok(reveal_result) = reveal_result_rx.recv().await else {"),
-        "Expected reveal actions to await async reveal completion before showing HUD"
-    );
-
-    assert!(
-        content.contains("this.show_hud(\"Opened in Finder\".to_string(), Some(1500), cx);"),
-        "Expected reveal success HUD to be emitted from async completion callback"
-    );
-}

file update:
diff --git a/src/app_actions/handle_action.rs b/src/app_actions/handle_action.rs
index 6512e920f98eb38811debb5dca005d821b3adb44..dda46dd268dc9fe3130c27b221485ba871f1c703
--- a/src/app_actions/handle_action.rs
+++ b/src/app_actions/handle_action.rs
@@ -32,6 +32,109 @@
         });
     }
 
+    /// Reveal a path and return completion back to the UI thread for HUD feedback.
+    fn reveal_in_finder_with_feedback_async(
+        &self,
+        path: &std::path::Path,
+    ) -> async_channel::Receiver<Result<(), String>> {
+        let path_str = path.to_string_lossy().to_string();
+        let (result_tx, result_rx) = async_channel::bounded::<Result<(), String>>(1);
+
+        std::thread::spawn(move || {
+            let file_manager = if cfg!(target_os = "macos") {
+                "Finder"
+            } else if cfg!(target_os = "windows") {
+                "Explorer"
+            } else {
+                "File Manager"
+            };
+
+            logging::log(
+                "UI",
+                &format!(
+                    "ACTION_REVEAL_IN_FINDER_START file_manager='{}' path='{}'",
+                    file_manager, path_str
+                ),
+            );
+
+            let reveal_result = match crate::file_search::reveal_in_finder(&path_str) {
+                Ok(()) => {
+                    logging::log(
+                        "UI",
+                        &format!(
+                            "ACTION_REVEAL_IN_FINDER_SUCCESS file_manager='{}' path='{}'",
+                            file_manager, path_str
+                        ),
+                    );
+                    Ok(())
+                }
+                Err(error) => {
+                    logging::log(
+                        "ERROR",
+                        &format!(
+                            "ACTION_REVEAL_IN_FINDER_FAILED attempted='reveal_in_finder' path='{}' file_manager='{}' error='{}'",
+                            path_str, file_manager, error
+                        ),
+                    );
+                    Err(format!("Failed to reveal in {}: {}", file_manager, error))
+                }
+            };
+
+            let _ = result_tx.send_blocking(reveal_result);
+        });
+
+        result_rx
+    }
+
+    /// Launch the configured editor and return completion back to the UI thread for HUD feedback.
+    fn launch_editor_with_feedback_async(
+        &self,
+        path: &std::path::Path,
+    ) -> async_channel::Receiver<Result<(), String>> {
+        let editor = self.config.get_editor();
+        let path_str = path.to_string_lossy().to_string();
+        let (result_tx, result_rx) = async_channel::bounded::<Result<(), String>>(1);
+
+        std::thread::spawn(move || {
+            use std::process::Command;
+
+            logging::log(
+                "UI",
+                &format!(
+                    "ACTION_EDITOR_LAUNCH_START editor='{}' path='{}'",
+                    editor, path_str
+                ),
+            );
+
+            let launch_result = match Command::new(&editor).arg(&path_str).spawn() {
+                Ok(_) => {
+                    logging::log(
+                        "UI",
+                        &format!(
+                            "ACTION_EDITOR_LAUNCH_SUCCESS editor='{}' path='{}'",
+                            editor, path_str
+                        ),
+                    );
+                    Ok(())
+                }
+                Err(error) => {
+                    logging::log(
+                        "ERROR",
+                        &format!(
+                            "ACTION_EDITOR_LAUNCH_FAILED attempted='{} {}' path='{}' error='{}'",
+                            editor, path_str, path_str, error
+                        ),
+                    );
+                    Err(format!("Failed to open in {}: {}", editor, error))
+                }
+            };
+
+            let _ = result_tx.send_blocking(launch_result);
+        });
+
+        result_rx
+    }
+
     /// Copy text to clipboard using pbcopy on macOS.
     /// Critical: This properly closes stdin before waiting to prevent hangs.
     #[cfg(target_os = "macos")]
@@ -471,9 +574,24 @@
                 };
 
                 if let Some(path) = path_opt {
-                    self.reveal_in_finder(&path);
-                    self.show_hud("Opened in Finder".to_string(), Some(1500), cx);
-                    self.hide_main_and_reset(cx);
+                    let reveal_result_rx = self.reveal_in_finder_with_feedback_async(&path);
+                    cx.spawn(async move |this, cx| {
+                        let Ok(reveal_result) = reveal_result_rx.recv().await else {
+                            return;
+                        };
+
+                        this.update(cx, |this, cx| match reveal_result {
+                            Ok(()) => {
+                                this.show_hud("Opened in Finder".to_string(), Some(1500), cx);
+                                this.hide_main_and_reset(cx);
+                            }
+                            Err(message) => {
+                                this.show_hud(message, Some(2500), cx);
+                            }
+                        })
+                        .ok();
+                    })
+                    .detach();
                 } else {
                     self.show_hud(
                         "Cannot reveal this item type in Finder".to_string(),
@@ -884,8 +1002,23 @@
                     };
 
                     if let Some(path) = path_opt {
-                        self.edit_script(&path);
-                        self.hide_main_and_reset(cx);
+                        let editor_launch_rx = self.launch_editor_with_feedback_async(&path);
+                        cx.spawn(async move |this, cx| {
+                            let Ok(launch_result) = editor_launch_rx.recv().await else {
+                                return;
+                            };
+
+                            this.update(cx, |this, cx| match launch_result {
+                                Ok(()) => {
+                                    this.hide_main_and_reset(cx);
+                                }
+                                Err(message) => {
+                                    this.show_hud(message, Some(3000), cx);
+                                }
+                            })
+                            .ok();
+                        })
+                        .detach();
                     } else {
                         self.show_hud("Cannot edit this item type".to_string(), Some(2000), cx);
                     }
@@ -1932,8 +2065,23 @@
                             // Extract just the path without the anchor (e.g., "/path/to/file.md#slug" -> "/path/to/file.md")
                             let path_str = file_path.split('#').next().unwrap_or(file_path);
                             let path = std::path::PathBuf::from(path_str);
-                            self.edit_script(&path);
-                            self.hide_main_and_reset(cx);
+                            let editor_launch_rx = self.launch_editor_with_feedback_async(&path);
+                            cx.spawn(async move |this, cx| {
+                                let Ok(launch_result) = editor_launch_rx.recv().await else {
+                                    return;
+                                };
+
+                                this.update(cx, |this, cx| match launch_result {
+                                    Ok(()) => {
+                                        this.hide_main_and_reset(cx);
+                                    }
+                                    Err(message) => {
+                                        this.show_hud(message, Some(3000), cx);
+                                    }
+                                })
+                                .ok();
+                            })
+                            .detach();
                         } else {
                             self.show_hud(
                                 "Scriptlet has no source file path".to_string(),
@@ -1964,9 +2112,24 @@
                             // Extract just the path without the anchor
                             let path_str = file_path.split('#').next().unwrap_or(file_path);
                             let path = std::path::Path::new(path_str);
-                            self.reveal_in_finder(path);
-                            self.show_hud("Opened in Finder".to_string(), Some(1500), cx);
-                            self.hide_main_and_reset(cx);
+                            let reveal_result_rx = self.reveal_in_finder_with_feedback_async(path);
+                            cx.spawn(async move |this, cx| {
+                                let Ok(reveal_result) = reveal_result_rx.recv().await else {
+                                    return;
+                                };
+
+                                this.update(cx, |this, cx| match reveal_result {
+                                    Ok(()) => {
+                                        this.show_hud("Opened in Finder".to_string(), Some(1500), cx);
+                                        this.hide_main_and_reset(cx);
+                                    }
+                                    Err(message) => {
+                                        this.show_hud(message, Some(2500), cx);
+                                    }
+                                })
+                                .ok();
+                            })
+                            .detach();
                         } else {
                             self.show_hud(
                                 "Scriptlet has no source file path".to_string(),
diff --git a/src/app_actions/helpers.rs b/src/app_actions/helpers.rs
index fb50657be41d2650d4e4be37f320f8f2393149b1..b350404d02dd71610199202b59f4fd97d4f27b35
--- a/src/app_actions/helpers.rs
+++ b/src/app_actions/helpers.rs
@@ -172,6 +172,7 @@
     use crate::AppView;
     use crate::clipboard_history::{ClipboardEntryMeta, ContentType};
     use crate::scripts;
+    use std::fs;
     use std::path::PathBuf;
     use std::sync::Arc;
 
@@ -189,6 +190,14 @@
         }
     }
 
+    fn read(path: &str) -> String {
+        fs::read_to_string(path).unwrap_or_else(|_| panic!("Failed to read {path}"))
+    }
+
+    fn count_occurrences(haystack: &str, needle: &str) -> usize {
+        haystack.match_indices(needle).count()
+    }
+
     #[test]
     fn test_select_clipboard_entry_meta_filters_and_clamps() {
         let entries = vec![entry("1", "Alpha"), entry("2", "Beta"), entry("3", "Gamma")];
@@ -364,4 +373,58 @@
             })
         );
     }
+
+    #[test]
+    fn test_edit_actions_show_error_feedback_when_editor_launch_fails() {
+        let content = read("src/app_actions/handle_action.rs");
+
+        assert!(
+            content.contains("fn launch_editor_with_feedback_async"),
+            "Expected async editor launch helper to exist"
+        );
+
+        let usage_count =
+            count_occurrences(&content, "self.launch_editor_with_feedback_async(&path)");
+        assert!(
+            usage_count >= 2,
+            "Expected edit_script and edit_scriptlet to use async editor launch feedback (found {usage_count} usages)"
+        );
+
+        assert!(
+            content.contains("this.show_hud(message, Some(3000), cx);"),
+            "Expected async editor launch failure to surface a HUD error message"
+        );
+    }
+
+    #[test]
+    fn test_reveal_actions_show_success_hud_after_async_completion() {
+        let content = read("src/app_actions/handle_action.rs");
+
+        assert!(
+            content.contains("fn reveal_in_finder_with_feedback_async"),
+            "Expected async reveal helper to exist"
+        );
+
+        let usage_count = count_occurrences(
+            &content,
+            "self.reveal_in_finder_with_feedback_async(&path)",
+        ) + count_occurrences(
+            &content,
+            "self.reveal_in_finder_with_feedback_async(path)",
+        );
+        assert!(
+            usage_count >= 2,
+            "Expected reveal actions to use async reveal feedback helper (found {usage_count} usages)"
+        );
+
+        assert!(
+            content.contains("let Ok(reveal_result) = reveal_result_rx.recv().await else {"),
+            "Expected reveal actions to await reveal completion before showing HUD"
+        );
+
+        assert!(
+            content.contains("this.show_hud(\"Opened in Finder\".to_string(), Some(1500), cx);"),
+            "Expected reveal success HUD to be emitted from async completion callback"
+        );
+    }
 }
diff --git a/src/app_actions/tests/editor_launch_feedback.rs b/src/app_actions/tests/editor_launch_feedback.rs
deleted file mode 100644
index 18077766837c78518094e45c0da3b2a672b8bd8b..0000000000000000000000000000000000000000
--- a/src/app_actions/tests/editor_launch_feedback.rs
+++ /dev/null
@@ -1,62 +0,0 @@
-use std::fs;
-
-fn read(path: &str) -> String {
-    fs::read_to_string(path).unwrap_or_else(|_| panic!("Failed to read {path}"))
-}
-
-fn count_occurrences(haystack: &str, needle: &str) -> usize {
-    haystack.match_indices(needle).count()
-}
-
-#[test]
-fn test_edit_actions_show_error_feedback_when_editor_launch_fails() {
-    let content = read("src/app_actions/handle_action.rs");
-
-    assert!(
-        content.contains("fn launch_editor_with_feedback_async"),
-        "Expected async editor launch helper to exist"
-    );
-
-    let usage_count = count_occurrences(&content, "self.launch_editor_with_feedback_async(&path)");
-    assert!(
-        usage_count >= 2,
-        "Expected edit_script and edit_scriptlet to use async editor launch feedback (found {usage_count} usages)"
-    );
-
-    assert!(
-        content.contains("this.show_hud(message, Some(3000), cx);"),
-        "Expected async editor launch failure to surface a HUD error message"
-    );
-}
-
-#[test]
-fn test_reveal_actions_show_success_hud_after_async_reveal_completion() {
-    let content = read("src/app_actions/handle_action.rs");
-
-    assert!(
-        content.contains("fn reveal_in_finder_with_feedback_async"),
-        "Expected async reveal helper to exist"
-    );
-
-    let usage_count = count_occurrences(
-        &content,
-        "self.reveal_in_finder_with_feedback_async(&path)",
-    ) + count_occurrences(
-        &content,
-        "self.reveal_in_finder_with_feedback_async(path)",
-    );
-    assert!(
-        usage_count >= 2,
-        "Expected reveal actions to use async reveal feedback helper (found {usage_count} usages)"
-    );
-
-    assert!(
-        content.contains("let Ok(reveal_result) = reveal_result_rx.recv().await else {"),
-        "Expected reveal actions to await async reveal completion before showing HUD"
-    );
-
-    assert!(
-        content.contains("this.show_hud(\"Opened in Finder\".to_string(), Some(1500), cx);"),
-        "Expected reveal success HUD to be emitted from async completion callback"
-    );
-}


thinking
**Confirming test file status**
codex
The runtime fix is in place, and I moved regression coverage into the compiled `app_actions/helpers.rs` test module so it actually runs. Next I’ll run a scoped test for the new checks, then run the required check/clippy verification commands.

thinking
**Planning scoped test and lint runs**
exec
/bin/zsh -lc 'cargo test --lib app_actions_tests:: -- --nocapture' in /Users/johnlindquist/dev/script-kit-gpuifile update:
diff --git a/src/app_actions/handle_action.rs b/src/app_actions/handle_action.rs
index 6512e920f98eb38811debb5dca005d821b3adb44..dda46dd268dc9fe3130c27b221485ba871f1c703
--- a/src/app_actions/handle_action.rs
+++ b/src/app_actions/handle_action.rs
@@ -32,6 +32,109 @@
         });
     }
 
+    /// Reveal a path and return completion back to the UI thread for HUD feedback.
+    fn reveal_in_finder_with_feedback_async(
+        &self,
+        path: &std::path::Path,
+    ) -> async_channel::Receiver<Result<(), String>> {
+        let path_str = path.to_string_lossy().to_string();
+        let (result_tx, result_rx) = async_channel::bounded::<Result<(), String>>(1);
+
+        std::thread::spawn(move || {
+            let file_manager = if cfg!(target_os = "macos") {
+                "Finder"
+            } else if cfg!(target_os = "windows") {
+                "Explorer"
+            } else {
+                "File Manager"
+            };
+
+            logging::log(
+                "UI",
+                &format!(
+                    "ACTION_REVEAL_IN_FINDER_START file_manager='{}' path='{}'",
+                    file_manager, path_str
+                ),
+            );
+
+            let reveal_result = match crate::file_search::reveal_in_finder(&path_str) {
+                Ok(()) => {
+                    logging::log(
+                        "UI",
+                        &format!(
+                            "ACTION_REVEAL_IN_FINDER_SUCCESS file_manager='{}' path='{}'",
+                            file_manager, path_str
+                        ),
+                    );
+                    Ok(())
+                }
+                Err(error) => {
+                    logging::log(
+                        "ERROR",
+                        &format!(
+                            "ACTION_REVEAL_IN_FINDER_FAILED attempted='reveal_in_finder' path='{}' file_manager='{}' error='{}'",
+                            path_str, file_manager, error
+                        ),
+                    );
+                    Err(format!("Failed to reveal in {}: {}", file_manager, error))
+                }
+            };
+
+            let _ = result_tx.send_blocking(reveal_result);
+        });
+
+        result_rx
+    }
+
+    /// Launch the configured editor and return completion back to the UI thread for HUD feedback.
+    fn launch_editor_with_feedback_async(
+        &self,
+        path: &std::path::Path,
+    ) -> async_channel::Receiver<Result<(), String>> {
+        let editor = self.config.get_editor();
+        let path_str = path.to_string_lossy().to_string();
+        let (result_tx, result_rx) = async_channel::bounded::<Result<(), String>>(1);
+
+        std::thread::spawn(move || {
+            use std::process::Command;
+
+            logging::log(
+                "UI",
+                &format!(
+                    "ACTION_EDITOR_LAUNCH_START editor='{}' path='{}'",
+                    editor, path_str
+                ),
+            );
+
+            let launch_result = match Command::new(&editor).arg(&path_str).spawn() {
+                Ok(_) => {
+                    logging::log(
+                        "UI",
+                        &format!(
+                            "ACTION_EDITOR_LAUNCH_SUCCESS editor='{}' path='{}'",
+                            editor, path_str
+                        ),
+                    );
+                    Ok(())
+                }
+                Err(error) => {
+                    logging::log(
+                        "ERROR",
+                        &format!(
+                            "ACTION_EDITOR_LAUNCH_FAILED attempted='{} {}' path='{}' error='{}'",
+                            editor, path_str, path_str, error
+                        ),
+                    );
+                    Err(format!("Failed to open in {}: {}", editor, error))
+                }
+            };
+
+            let _ = result_tx.send_blocking(launch_result);
+        });
+
+        result_rx
+    }
+
     /// Copy text to clipboard using pbcopy on macOS.
     /// Critical: This properly closes stdin before waiting to prevent hangs.
     #[cfg(target_os = "macos")]
@@ -471,9 +574,24 @@
                 };
 
                 if let Some(path) = path_opt {
-                    self.reveal_in_finder(&path);
-                    self.show_hud("Opened in Finder".to_string(), Some(1500), cx);
-                    self.hide_main_and_reset(cx);
+                    let reveal_result_rx = self.reveal_in_finder_with_feedback_async(&path);
+                    cx.spawn(async move |this, cx| {
+                        let Ok(reveal_result) = reveal_result_rx.recv().await else {
+                            return;
+                        };
+
+                        this.update(cx, |this, cx| match reveal_result {
+                            Ok(()) => {
+                                this.show_hud("Opened in Finder".to_string(), Some(1500), cx);
+                                this.hide_main_and_reset(cx);
+                            }
+                            Err(message) => {
+                                this.show_hud(message, Some(2500), cx);
+                            }
+                        })
+                        .ok();
+                    })
+                    .detach();
                 } else {
                     self.show_hud(
                         "Cannot reveal this item type in Finder".to_string(),
@@ -884,8 +1002,23 @@
                     };
 
                     if let Some(path) = path_opt {
-                        self.edit_script(&path);
-                        self.hide_main_and_reset(cx);
+                        let editor_launch_rx = self.launch_editor_with_feedback_async(&path);
+                        cx.spawn(async move |this, cx| {
+                            let Ok(launch_result) = editor_launch_rx.recv().await else {
+                                return;
+                            };
+
+                            this.update(cx, |this, cx| match launch_result {
+                                Ok(()) => {
+                                    this.hide_main_and_reset(cx);
+                                }
+                                Err(message) => {
+                                    this.show_hud(message, Some(3000), cx);
+                                }
+                            })
+                            .ok();
+                        })
+                        .detach();
                     } else {
                         self.show_hud("Cannot edit this item type".to_string(), Some(2000), cx);
                     }
@@ -1932,8 +2065,23 @@
                             // Extract just the path without the anchor (e.g., "/path/to/file.md#slug" -> "/path/to/file.md")
                             let path_str = file_path.split('#').next().unwrap_or(file_path);
                             let path = std::path::PathBuf::from(path_str);
-                            self.edit_script(&path);
-                            self.hide_main_and_reset(cx);
+                            let editor_launch_rx = self.launch_editor_with_feedback_async(&path);
+                            cx.spawn(async move |this, cx| {
+                                let Ok(launch_result) = editor_launch_rx.recv().await else {
+                                    return;
+                                };
+
+                                this.update(cx, |this, cx| match launch_result {
+                                    Ok(()) => {
+                                        this.hide_main_and_reset(cx);
+                                    }
+                                    Err(message) => {
+                                        this.show_hud(message, Some(3000), cx);
+                                    }
+                                })
+                                .ok();
+                            })
+                            .detach();
                         } else {
                             self.show_hud(
                                 "Scriptlet has no source file path".to_string(),
@@ -1964,9 +2112,24 @@
                             // Extract just the path without the anchor
                             let path_str = file_path.split('#').next().unwrap_or(file_path);
                             let path = std::path::Path::new(path_str);
-                            self.reveal_in_finder(path);
-                            self.show_hud("Opened in Finder".to_string(), Some(1500), cx);
-                            self.hide_main_and_reset(cx);
+                            let reveal_result_rx = self.reveal_in_finder_with_feedback_async(path);
+                            cx.spawn(async move |this, cx| {
+                                let Ok(reveal_result) = reveal_result_rx.recv().await else {
+                                    return;
+                                };
+
+                                this.update(cx, |this, cx| match reveal_result {
+                                    Ok(()) => {
+                                        this.show_hud("Opened in Finder".to_string(), Some(1500), cx);
+                                        this.hide_main_and_reset(cx);
+                                    }
+                                    Err(message) => {
+                                        this.show_hud(message, Some(2500), cx);
+                                    }
+                                })
+                                .ok();
+                            })
+                            .detach();
                         } else {
                             self.show_hud(
                                 "Scriptlet has no source file path".to_string(),
diff --git a/src/app_actions/helpers.rs b/src/app_actions/helpers.rs
index fb50657be41d2650d4e4be37f320f8f2393149b1..b350404d02dd71610199202b59f4fd97d4f27b35
--- a/src/app_actions/helpers.rs
+++ b/src/app_actions/helpers.rs
@@ -172,6 +172,7 @@
     use crate::AppView;
     use crate::clipboard_history::{ClipboardEntryMeta, ContentType};
     use crate::scripts;
+    use std::fs;
     use std::path::PathBuf;
     use std::sync::Arc;
 
@@ -189,6 +190,14 @@
         }
     }
 
+    fn read(path: &str) -> String {
+        fs::read_to_string(path).unwrap_or_else(|_| panic!("Failed to read {path}"))
+    }
+
+    fn count_occurrences(haystack: &str, needle: &str) -> usize {
+        haystack.match_indices(needle).count()
+    }
+
     #[test]
     fn test_select_clipboard_entry_meta_filters_and_clamps() {
         let entries = vec![entry("1", "Alpha"), entry("2", "Beta"), entry("3", "Gamma")];
@@ -364,4 +373,58 @@
             })
         );
     }
+
+    #[test]
+    fn test_edit_actions_show_error_feedback_when_editor_launch_fails() {
+        let content = read("src/app_actions/handle_action.rs");
+
+        assert!(
+            content.contains("fn launch_editor_with_feedback_async"),
+            "Expected async editor launch helper to exist"
+        );
+
+        let usage_count =
+            count_occurrences(&content, "self.launch_editor_with_feedback_async(&path)");
+        assert!(
+            usage_count >= 2,
+            "Expected edit_script and edit_scriptlet to use async editor launch feedback (found {usage_count} usages)"
+        );
+
+        assert!(
+            content.contains("this.show_hud(message, Some(3000), cx);"),
+            "Expected async editor launch failure to surface a HUD error message"
+        );
+    }
+
+    #[test]
+    fn test_reveal_actions_show_success_hud_after_async_completion() {
+        let content = read("src/app_actions/handle_action.rs");
+
+        assert!(
+            content.contains("fn reveal_in_finder_with_feedback_async"),
+            "Expected async reveal helper to exist"
+        );
+
+        let usage_count = count_occurrences(
+            &content,
+            "self.reveal_in_finder_with_feedback_async(&path)",
+        ) + count_occurrences(
+            &content,
+            "self.reveal_in_finder_with_feedback_async(path)",
+        );
+        assert!(
+            usage_count >= 2,
+            "Expected reveal actions to use async reveal feedback helper (found {usage_count} usages)"
+        );
+
+        assert!(
+            content.contains("let Ok(reveal_result) = reveal_result_rx.recv().await else {"),
+            "Expected reveal actions to await reveal completion before showing HUD"
+        );
+
+        assert!(
+            content.contains("this.show_hud(\"Opened in Finder\".to_string(), Some(1500), cx);"),
+            "Expected reveal success HUD to be emitted from async completion callback"
+        );
+    }
 }
diff --git a/src/app_actions/tests/editor_launch_feedback.rs b/src/app_actions/tests/editor_launch_feedback.rs
deleted file mode 100644
index 18077766837c78518094e45c0da3b2a672b8bd8b..0000000000000000000000000000000000000000
--- a/src/app_actions/tests/editor_launch_feedback.rs
+++ /dev/null
@@ -1,62 +0,0 @@
-use std::fs;
-
-fn read(path: &str) -> String {
-    fs::read_to_string(path).unwrap_or_else(|_| panic!("Failed to read {path}"))
-}
-
-fn count_occurrences(haystack: &str, needle: &str) -> usize {
-    haystack.match_indices(needle).count()
-}
-
-#[test]
-fn test_edit_actions_show_error_feedback_when_editor_launch_fails() {
-    let content = read("src/app_actions/handle_action.rs");
-
-    assert!(
-        content.contains("fn launch_editor_with_feedback_async"),
-        "Expected async editor launch helper to exist"
-    );
-
-    let usage_count = count_occurrences(&content, "self.launch_editor_with_feedback_async(&path)");
-    assert!(
-        usage_count >= 2,
-        "Expected edit_script and edit_scriptlet to use async editor launch feedback (found {usage_count} usages)"
-    );
-
-    assert!(
-        content.contains("this.show_hud(message, Some(3000), cx);"),
-        "Expected async editor launch failure to surface a HUD error message"
-    );
-}
-
-#[test]
-fn test_reveal_actions_show_success_hud_after_async_reveal_completion() {
-    let content = read("src/app_actions/handle_action.rs");
-
-    assert!(
-        content.contains("fn reveal_in_finder_with_feedback_async"),
-        "Expected async reveal helper to exist"
-    );
-
-    let usage_count = count_occurrences(
-        &content,
-        "self.reveal_in_finder_with_feedback_async(&path)",
-    ) + count_occurrences(
-        &content,
-        "self.reveal_in_finder_with_feedback_async(path)",
-    );
-    assert!(
-        usage_count >= 2,
-        "Expected reveal actions to use async reveal feedback helper (found {usage_count} usages)"
-    );
-
-    assert!(
-        content.contains("let Ok(reveal_result) = reveal_result_rx.recv().await else {"),
-        "Expected reveal actions to await async reveal completion before showing HUD"
-    );
-
-    assert!(
-        content.contains("this.show_hud(\"Opened in Finder\".to_string(), Some(1500), cx);"),
-        "Expected reveal success HUD to be emitted from async completion callback"
-    );
-}

 exited 101 in 20.22s:
   Compiling script-kit-gpui v0.1.0 (/Users/johnlindquist/dev/script-kit-gpui)
error[E0761]: file for module `tests` found at both "src/protocol/message/tests.rs" and "src/protocol/message/tests/mod.rs"
  --> src/protocol/message/mod.rs:87:1
   |
87 | mod tests;
   | ^^^^^^^^^^
   |
   = help: delete or rename one of them to remove the ambiguity

error[E0761]: file for module `tests` found at both "src/designs/core/tests.rs" and "src/designs/core/tests/mod.rs"
 --> src/designs/core/part_04.rs:2:1
  |
2 | mod tests;
  | ^^^^^^^^^^
  |
  = help: delete or rename one of them to remove the ambiguity

error[E0412]: cannot find type `Action` in this scope
   --> src/actions/builders_tests/part_01.rs:18:26
    |

thinking
**Analyzing test failure due to parallel conflict**
codex
The scoped unit-test run is currently blocked by an unrelated parallel-agent conflict (`src/protocol/message/tests.rs` and `src/protocol/message/tests/mod.rs` both exist), which breaks `cfg(test)` compilation globally. I’ll still run the required `cargo check` and `cargo clippy` verification now and report exact results.

thinking
**Running exact check and clippy**
exec
/bin/zsh -lc 'cargo check && cargo clippy --all-targets -- -D warnings' in /Users/johnlindquist/dev/script-kit-gpuifile update:
diff --git a/src/app_actions/handle_action.rs b/src/app_actions/handle_action.rs
index 6512e920f98eb38811debb5dca005d821b3adb44..dda46dd268dc9fe3130c27b221485ba871f1c703
--- a/src/app_actions/handle_action.rs
+++ b/src/app_actions/handle_action.rs
@@ -32,6 +32,109 @@
         });
     }
 
+    /// Reveal a path and return completion back to the UI thread for HUD feedback.
+    fn reveal_in_finder_with_feedback_async(
+        &self,
+        path: &std::path::Path,
+    ) -> async_channel::Receiver<Result<(), String>> {
+        let path_str = path.to_string_lossy().to_string();
+        let (result_tx, result_rx) = async_channel::bounded::<Result<(), String>>(1);
+
+        std::thread::spawn(move || {
+            let file_manager = if cfg!(target_os = "macos") {
+                "Finder"
+            } else if cfg!(target_os = "windows") {
+                "Explorer"
+            } else {
+                "File Manager"
+            };
+
+            logging::log(
+                "UI",
+                &format!(
+                    "ACTION_REVEAL_IN_FINDER_START file_manager='{}' path='{}'",
+                    file_manager, path_str
+                ),
+            );
+
+            let reveal_result = match crate::file_search::reveal_in_finder(&path_str) {
+                Ok(()) => {
+                    logging::log(
+                        "UI",
+                        &format!(
+                            "ACTION_REVEAL_IN_FINDER_SUCCESS file_manager='{}' path='{}'",
+                            file_manager, path_str
+                        ),
+                    );
+                    Ok(())
+                }
+                Err(error) => {
+                    logging::log(
+                        "ERROR",
+                        &format!(
+                            "ACTION_REVEAL_IN_FINDER_FAILED attempted='reveal_in_finder' path='{}' file_manager='{}' error='{}'",
+                            path_str, file_manager, error
+                        ),
+                    );
+                    Err(format!("Failed to reveal in {}: {}", file_manager, error))
+                }
+            };
+
+            let _ = result_tx.send_blocking(reveal_result);
+        });
+
+        result_rx
+    }
+
+    /// Launch the configured editor and return completion back to the UI thread for HUD feedback.
+    fn launch_editor_with_feedback_async(
+        &self,
+        path: &std::path::Path,
+    ) -> async_channel::Receiver<Result<(), String>> {
+        let editor = self.config.get_editor();
+        let path_str = path.to_string_lossy().to_string();
+        let (result_tx, result_rx) = async_channel::bounded::<Result<(), String>>(1);
+
+        std::thread::spawn(move || {
+            use std::process::Command;
+
+            logging::log(
+                "UI",
+                &format!(
+                    "ACTION_EDITOR_LAUNCH_START editor='{}' path='{}'",
+                    editor, path_str
+                ),
+            );
+
+            let launch_result = match Command::new(&editor).arg(&path_str).spawn() {
+                Ok(_) => {
+                    logging::log(
+                        "UI",
+                        &format!(
+                            "ACTION_EDITOR_LAUNCH_SUCCESS editor='{}' path='{}'",
+                            editor, path_str
+                        ),
+                    );
+                    Ok(())
+                }
+                Err(error) => {
+                    logging::log(
+                        "ERROR",
+                        &format!(
+                            "ACTION_EDITOR_LAUNCH_FAILED attempted='{} {}' path='{}' error='{}'",
+                            editor, path_str, path_str, error
+                        ),
+                    );
+                    Err(format!("Failed to open in {}: {}", editor, error))
+                }
+            };
+
+            let _ = result_tx.send_blocking(launch_result);
+        });
+
+        result_rx
+    }
+
     /// Copy text to clipboard using pbcopy on macOS.
     /// Critical: This properly closes stdin before waiting to prevent hangs.
     #[cfg(target_os = "macos")]
@@ -471,9 +574,24 @@
                 };
 
                 if let Some(path) = path_opt {
-                    self.reveal_in_finder(&path);
-                    self.show_hud("Opened in Finder".to_string(), Some(1500), cx);
-                    self.hide_main_and_reset(cx);
+                    let reveal_result_rx = self.reveal_in_finder_with_feedback_async(&path);
+                    cx.spawn(async move |this, cx| {
+                        let Ok(reveal_result) = reveal_result_rx.recv().await else {
+                            return;
+                        };
+
+                        this.update(cx, |this, cx| match reveal_result {
+                            Ok(()) => {
+                                this.show_hud("Opened in Finder".to_string(), Some(1500), cx);
+                                this.hide_main_and_reset(cx);
+                            }
+                            Err(message) => {
+                                this.show_hud(message, Some(2500), cx);
+                            }
+                        })
+                        .ok();
+                    })
+                    .detach();
                 } else {
                     self.show_hud(
                         "Cannot reveal this item type in Finder".to_string(),
@@ -884,8 +1002,23 @@
                     };
 
                     if let Some(path) = path_opt {
-                        self.edit_script(&path);
-                        self.hide_main_and_reset(cx);
+                        let editor_launch_rx = self.launch_editor_with_feedback_async(&path);
+                        cx.spawn(async move |this, cx| {
+                            let Ok(launch_result) = editor_launch_rx.recv().await else {
+                                return;
+                            };
+
+                            this.update(cx, |this, cx| match launch_result {
+                                Ok(()) => {
+                                    this.hide_main_and_reset(cx);
+                                }
+                                Err(message) => {
+                                    this.show_hud(message, Some(3000), cx);
+                                }
+                            })
+                            .ok();
+                        })
+                        .detach();
                     } else {
                         self.show_hud("Cannot edit this item type".to_string(), Some(2000), cx);
                     }
@@ -1932,8 +2065,23 @@
                             // Extract just the path without the anchor (e.g., "/path/to/file.md#slug" -> "/path/to/file.md")
                             let path_str = file_path.split('#').next().unwrap_or(file_path);
                             let path = std::path::PathBuf::from(path_str);
-                            self.edit_script(&path);
-                            self.hide_main_and_reset(cx);
+                            let editor_launch_rx = self.launch_editor_with_feedback_async(&path);
+                            cx.spawn(async move |this, cx| {
+                                let Ok(launch_result) = editor_launch_rx.recv().await else {
+                                    return;
+                                };
+
+                                this.update(cx, |this, cx| match launch_result {
+                                    Ok(()) => {
+                                        this.hide_main_and_reset(cx);
+                                    }
+                                    Err(message) => {
+                                        this.show_hud(message, Some(3000), cx);
+                                    }
+                                })
+                                .ok();
+                            })
+                            .detach();
                         } else {
                             self.show_hud(
                                 "Scriptlet has no source file path".to_string(),
@@ -1964,9 +2112,24 @@
                             // Extract just the path without the anchor
                             let path_str = file_path.split('#').next().unwrap_or(file_path);
                             let path = std::path::Path::new(path_str);
-                            self.reveal_in_finder(path);
-                            self.show_hud("Opened in Finder".to_string(), Some(1500), cx);
-                            self.hide_main_and_reset(cx);
+                            let reveal_result_rx = self.reveal_in_finder_with_feedback_async(path);
+                            cx.spawn(async move |this, cx| {
+                                let Ok(reveal_result) = reveal_result_rx.recv().await else {
+                                    return;
+                                };
+
+                                this.update(cx, |this, cx| match reveal_result {
+                                    Ok(()) => {
+                                        this.show_hud("Opened in Finder".to_string(), Some(1500), cx);
+                                        this.hide_main_and_reset(cx);
+                                    }
+                                    Err(message) => {
+                                        this.show_hud(message, Some(2500), cx);
+                                    }
+                                })
+                                .ok();
+                            })
+                            .detach();
                         } else {
                             self.show_hud(
                                 "Scriptlet has no source file path".to_string(),
diff --git a/src/app_actions/helpers.rs b/src/app_actions/helpers.rs
index fb50657be41d2650d4e4be37f320f8f2393149b1..b350404d02dd71610199202b59f4fd97d4f27b35
--- a/src/app_actions/helpers.rs
+++ b/src/app_actions/helpers.rs
@@ -172,6 +172,7 @@
     use crate::AppView;
     use crate::clipboard_history::{ClipboardEntryMeta, ContentType};
     use crate::scripts;
+    use std::fs;
     use std::path::PathBuf;
     use std::sync::Arc;
 
@@ -189,6 +190,14 @@
         }
     }
 
+    fn read(path: &str) -> String {
+        fs::read_to_string(path).unwrap_or_else(|_| panic!("Failed to read {path}"))
+    }
+
+    fn count_occurrences(haystack: &str, needle: &str) -> usize {
+        haystack.match_indices(needle).count()
+    }
+
     #[test]
     fn test_select_clipboard_entry_meta_filters_and_clamps() {
         let entries = vec![entry("1", "Alpha"), entry("2", "Beta"), entry("3", "Gamma")];
@@ -364,4 +373,58 @@
             })
         );
     }
+
+    #[test]
+    fn test_edit_actions_show_error_feedback_when_editor_launch_fails() {
+        let content = read("src/app_actions/handle_action.rs");
+
+        assert!(
+            content.contains("fn launch_editor_with_feedback_async"),
+            "Expected async editor launch helper to exist"
+        );
+
+        let usage_count =
+            count_occurrences(&content, "self.launch_editor_with_feedback_async(&path)");
+        assert!(
+            usage_count >= 2,
+            "Expected edit_script and edit_scriptlet to use async editor launch feedback (found {usage_count} usages)"
+        );
+
+        assert!(
+            content.contains("this.show_hud(message, Some(3000), cx);"),
+            "Expected async editor launch failure to surface a HUD error message"
+        );
+    }
+
+    #[test]
+    fn test_reveal_actions_show_success_hud_after_async_completion() {
+        let content = read("src/app_actions/handle_action.rs");
+
+        assert!(
+            content.contains("fn reveal_in_finder_with_feedback_async"),
+            "Expected async reveal helper to exist"
+        );
+
+        let usage_count = count_occurrences(
+            &content,
+            "self.reveal_in_finder_with_feedback_async(&path)",
+        ) + count_occurrences(
+            &content,
+            "self.reveal_in_finder_with_feedback_async(path)",
+        );
+        assert!(
+            usage_count >= 2,
+            "Expected reveal actions to use async reveal feedback helper (found {usage_count} usages)"
+        );
+
+        assert!(
+            content.contains("let Ok(reveal_result) = reveal_result_rx.recv().await else {"),
+            "Expected reveal actions to await reveal completion before showing HUD"
+        );
+
+        assert!(
+            content.contains("this.show_hud(\"Opened in Finder\".to_string(), Some(1500), cx);"),
+            "Expected reveal success HUD to be emitted from async completion callback"
+        );
+    }
 }
diff --git a/src/app_actions/tests/editor_launch_feedback.rs b/src/app_actions/tests/editor_launch_feedback.rs
deleted file mode 100644
index 18077766837c78518094e45c0da3b2a672b8bd8b..0000000000000000000000000000000000000000
--- a/src/app_actions/tests/editor_launch_feedback.rs
+++ /dev/null
@@ -1,62 +0,0 @@
-use std::fs;
-
-fn read(path: &str) -> String {
-    fs::read_to_string(path).unwrap_or_else(|_| panic!("Failed to read {path}"))
-}
-
-fn count_occurrences(haystack: &str, needle: &str) -> usize {
-    haystack.match_indices(needle).count()
-}
-
-#[test]
-fn test_edit_actions_show_error_feedback_when_editor_launch_fails() {
-    let content = read("src/app_actions/handle_action.rs");
-
-    assert!(
-        content.contains("fn launch_editor_with_feedback_async"),
-        "Expected async editor launch helper to exist"
-    );
-
-    let usage_count = count_occurrences(&content, "self.launch_editor_with_feedback_async(&path)");
-    assert!(
-        usage_count >= 2,
-        "Expected edit_script and edit_scriptlet to use async editor launch feedback (found {usage_count} usages)"
-    );
-
-    assert!(
-        content.contains("this.show_hud(message, Some(3000), cx);"),
-        "Expected async editor launch failure to surface a HUD error message"
-    );
-}
-
-#[test]
-fn test_reveal_actions_show_success_hud_after_async_reveal_completion() {
-    let content = read("src/app_actions/handle_action.rs");
-
-    assert!(
-        content.contains("fn reveal_in_finder_with_feedback_async"),
-        "Expected async reveal helper to exist"
-    );
-
-    let usage_count = count_occurrences(
-        &content,
-        "self.reveal_in_finder_with_feedback_async(&path)",
-    ) + count_occurrences(
-        &content,
-        "self.reveal_in_finder_with_feedback_async(path)",
-    );
-    assert!(
-        usage_count >= 2,
-        "Expected reveal actions to use async reveal feedback helper (found {usage_count} usages)"
-    );
-
-    assert!(
-        content.contains("let Ok(reveal_result) = reveal_result_rx.recv().await else {"),
-        "Expected reveal actions to await async reveal completion before showing HUD"
-    );
-
-    assert!(
-        content.contains("this.show_hud(\"Opened in Finder\".to_string(), Some(1500), cx);"),
-        "Expected reveal success HUD to be emitted from async completion callback"
-    );
-}


thinking
**Waiting for build lock**
codex
`cargo check` is queued behind another Cargo process lock in this shared tree. I’m waiting for the lock to clear and will continue the full check/clippy run automatically.
file update:
diff --git a/src/app_actions/handle_action.rs b/src/app_actions/handle_action.rs
index 6512e920f98eb38811debb5dca005d821b3adb44..dda46dd268dc9fe3130c27b221485ba871f1c703
--- a/src/app_actions/handle_action.rs
+++ b/src/app_actions/handle_action.rs
@@ -32,6 +32,109 @@
         });
     }
 
+    /// Reveal a path and return completion back to the UI thread for HUD feedback.
+    fn reveal_in_finder_with_feedback_async(
+        &self,
+        path: &std::path::Path,
+    ) -> async_channel::Receiver<Result<(), String>> {
+        let path_str = path.to_string_lossy().to_string();
+        let (result_tx, result_rx) = async_channel::bounded::<Result<(), String>>(1);
+
+        std::thread::spawn(move || {
+            let file_manager = if cfg!(target_os = "macos") {
+                "Finder"
+            } else if cfg!(target_os = "windows") {
+                "Explorer"
+            } else {
+                "File Manager"
+            };
+
+            logging::log(
+                "UI",
+                &format!(
+                    "ACTION_REVEAL_IN_FINDER_START file_manager='{}' path='{}'",
+                    file_manager, path_str
+                ),
+            );
+
+            let reveal_result = match crate::file_search::reveal_in_finder(&path_str) {
+                Ok(()) => {
+                    logging::log(
+                        "UI",
+                        &format!(
+                            "ACTION_REVEAL_IN_FINDER_SUCCESS file_manager='{}' path='{}'",
+                            file_manager, path_str
+                        ),
+                    );
+                    Ok(())
+                }
+                Err(error) => {
+                    logging::log(
+                        "ERROR",
+                        &format!(
+                            "ACTION_REVEAL_IN_FINDER_FAILED attempted='reveal_in_finder' path='{}' file_manager='{}' error='{}'",
+                            path_str, file_manager, error
+                        ),
+                    );
+                    Err(format!("Failed to reveal in {}: {}", file_manager, error))
+                }
+            };
+
+            let _ = result_tx.send_blocking(reveal_result);
+        });
+
+        result_rx
+    }
+
+    /// Launch the configured editor and return completion back to the UI thread for HUD feedback.
+    fn launch_editor_with_feedback_async(
+        &self,
+        path: &std::path::Path,
+    ) -> async_channel::Receiver<Result<(), String>> {
+        let editor = self.config.get_editor();
+        let path_str = path.to_string_lossy().to_string();
+        let (result_tx, result_rx) = async_channel::bounded::<Result<(), String>>(1);
+
+        std::thread::spawn(move || {
+            use std::process::Command;
+
+            logging::log(
+                "UI",
+                &format!(
+                    "ACTION_EDITOR_LAUNCH_START editor='{}' path='{}'",
+                    editor, path_str
+                ),
+            );
+
+            let launch_result = match Command::new(&editor).arg(&path_str).spawn() {
+                Ok(_) => {
+                    logging::log(
+                        "UI",
+                        &format!(
+                            "ACTION_EDITOR_LAUNCH_SUCCESS editor='{}' path='{}'",
+                            editor, path_str
+                        ),
+                    );
+                    Ok(())
+                }
+                Err(error) => {
+                    logging::log(
+                        "ERROR",
+                        &format!(
+                            "ACTION_EDITOR_LAUNCH_FAILED attempted='{} {}' path='{}' error='{}'",
+                            editor, path_str, path_str, error
+                        ),
+                    );
+                    Err(format!("Failed to open in {}: {}", editor, error))
+                }
+            };
+
+            let _ = result_tx.send_blocking(launch_result);
+        });
+
+        result_rx
+    }
+
     /// Copy text to clipboard using pbcopy on macOS.
     /// Critical: This properly closes stdin before waiting to prevent hangs.
     #[cfg(target_os = "macos")]
@@ -471,9 +574,24 @@
                 };
 
                 if let Some(path) = path_opt {
-                    self.reveal_in_finder(&path);
-                    self.show_hud("Opened in Finder".to_string(), Some(1500), cx);
-                    self.hide_main_and_reset(cx);
+                    let reveal_result_rx = self.reveal_in_finder_with_feedback_async(&path);
+                    cx.spawn(async move |this, cx| {
+                        let Ok(reveal_result) = reveal_result_rx.recv().await else {
+                            return;
+                        };
+
+                        this.update(cx, |this, cx| match reveal_result {
+                            Ok(()) => {
+                                this.show_hud("Opened in Finder".to_string(), Some(1500), cx);
+                                this.hide_main_and_reset(cx);
+                            }
+                            Err(message) => {
+                                this.show_hud(message, Some(2500), cx);
+                            }
+                        })
+                        .ok();
+                    })
+                    .detach();
                 } else {
                     self.show_hud(
                         "Cannot reveal this item type in Finder".to_string(),
@@ -884,8 +1002,23 @@
                     };
 
                     if let Some(path) = path_opt {
-                        self.edit_script(&path);
-                        self.hide_main_and_reset(cx);
+                        let editor_launch_rx = self.launch_editor_with_feedback_async(&path);
+                        cx.spawn(async move |this, cx| {
+                            let Ok(launch_result) = editor_launch_rx.recv().await else {
+                                return;
+                            };
+
+                            this.update(cx, |this, cx| match launch_result {
+                                Ok(()) => {
+                                    this.hide_main_and_reset(cx);
+                                }
+                                Err(message) => {
+                                    this.show_hud(message, Some(3000), cx);
+                                }
+                            })
+                            .ok();
+                        })
+                        .detach();
                     } else {
                         self.show_hud("Cannot edit this item type".to_string(), Some(2000), cx);
                     }
@@ -1932,8 +2065,23 @@
                             // Extract just the path without the anchor (e.g., "/path/to/file.md#slug" -> "/path/to/file.md")
                             let path_str = file_path.split('#').next().unwrap_or(file_path);
                             let path = std::path::PathBuf::from(path_str);
-                            self.edit_script(&path);
-                            self.hide_main_and_reset(cx);
+                            let editor_launch_rx = self.launch_editor_with_feedback_async(&path);
+                            cx.spawn(async move |this, cx| {
+                                let Ok(launch_result) = editor_launch_rx.recv().await else {
+                                    return;
+                                };
+
+                                this.update(cx, |this, cx| match launch_result {
+                                    Ok(()) => {
+                                        this.hide_main_and_reset(cx);
+                                    }
+                                    Err(message) => {
+                                        this.show_hud(message, Some(3000), cx);
+                                    }
+                                })
+                                .ok();
+                            })
+                            .detach();
                         } else {
                             self.show_hud(
                                 "Scriptlet has no source file path".to_string(),
@@ -1964,9 +2112,24 @@
                             // Extract just the path without the anchor
                             let path_str = file_path.split('#').next().unwrap_or(file_path);
                             let path = std::path::Path::new(path_str);
-                            self.reveal_in_finder(path);
-                            self.show_hud("Opened in Finder".to_string(), Some(1500), cx);
-                            self.hide_main_and_reset(cx);
+                            let reveal_result_rx = self.reveal_in_finder_with_feedback_async(path);
+                            cx.spawn(async move |this, cx| {
+                                let Ok(reveal_result) = reveal_result_rx.recv().await else {
+                                    return;
+                                };
+
+                                this.update(cx, |this, cx| match reveal_result {
+                                    Ok(()) => {
+                                        this.show_hud("Opened in Finder".to_string(), Some(1500), cx);
+                                        this.hide_main_and_reset(cx);
+                                    }
+                                    Err(message) => {
+                                        this.show_hud(message, Some(2500), cx);
+                                    }
+                                })
+                                .ok();
+                            })
+                            .detach();
                         } else {
                             self.show_hud(
                                 "Scriptlet has no source file path".to_string(),
diff --git a/src/app_actions/helpers.rs b/src/app_actions/helpers.rs
index fb50657be41d2650d4e4be37f320f8f2393149b1..b350404d02dd71610199202b59f4fd97d4f27b35
--- a/src/app_actions/helpers.rs
+++ b/src/app_actions/helpers.rs
@@ -172,6 +172,7 @@
     use crate::AppView;
     use crate::clipboard_history::{ClipboardEntryMeta, ContentType};
     use crate::scripts;
+    use std::fs;
     use std::path::PathBuf;
     use std::sync::Arc;
 
@@ -189,6 +190,14 @@
         }
     }
 
+    fn read(path: &str) -> String {
+        fs::read_to_string(path).unwrap_or_else(|_| panic!("Failed to read {path}"))
+    }
+
+    fn count_occurrences(haystack: &str, needle: &str) -> usize {
+        haystack.match_indices(needle).count()
+    }
+
     #[test]
     fn test_select_clipboard_entry_meta_filters_and_clamps() {
         let entries = vec![entry("1", "Alpha"), entry("2", "Beta"), entry("3", "Gamma")];
@@ -364,4 +373,58 @@
             })
         );
     }
+
+    #[test]
+    fn test_edit_actions_show_error_feedback_when_editor_launch_fails() {
+        let content = read("src/app_actions/handle_action.rs");
+
+        assert!(
+            content.contains("fn launch_editor_with_feedback_async"),
+            "Expected async editor launch helper to exist"
+        );
+
+        let usage_count =
+            count_occurrences(&content, "self.launch_editor_with_feedback_async(&path)");
+        assert!(
+            usage_count >= 2,
+            "Expected edit_script and edit_scriptlet to use async editor launch feedback (found {usage_count} usages)"
+        );
+
+        assert!(
+            content.contains("this.show_hud(message, Some(3000), cx);"),
+            "Expected async editor launch failure to surface a HUD error message"
+        );
+    }
+
+    #[test]
+    fn test_reveal_actions_show_success_hud_after_async_completion() {
+        let content = read("src/app_actions/handle_action.rs");
+
+        assert!(
+            content.contains("fn reveal_in_finder_with_feedback_async"),
+            "Expected async reveal helper to exist"
+        );
+
+        let usage_count = count_occurrences(
+            &content,
+            "self.reveal_in_finder_with_feedback_async(&path)",
+        ) + count_occurrences(
+            &content,
+            "self.reveal_in_finder_with_feedback_async(path)",
+        );
+        assert!(
+            usage_count >= 2,
+            "Expected reveal actions to use async reveal feedback helper (found {usage_count} usages)"
+        );
+
+        assert!(
+            content.contains("let Ok(reveal_result) = reveal_result_rx.recv().await else {"),
+            "Expected reveal actions to await reveal completion before showing HUD"
+        );
+
+        assert!(
+            content.contains("this.show_hud(\"Opened in Finder\".to_string(), Some(1500), cx);"),
+            "Expected reveal success HUD to be emitted from async completion callback"
+        );
+    }
 }
diff --git a/src/app_actions/tests/editor_launch_feedback.rs b/src/app_actions/tests/editor_launch_feedback.rs
deleted file mode 100644
index 18077766837c78518094e45c0da3b2a672b8bd8b..0000000000000000000000000000000000000000
--- a/src/app_actions/tests/editor_launch_feedback.rs
+++ /dev/null
@@ -1,62 +0,0 @@
-use std::fs;
-
-fn read(path: &str) -> String {
-    fs::read_to_string(path).unwrap_or_else(|_| panic!("Failed to read {path}"))
-}
-
-fn count_occurrences(haystack: &str, needle: &str) -> usize {
-    haystack.match_indices(needle).count()
-}
-
-#[test]
-fn test_edit_actions_show_error_feedback_when_editor_launch_fails() {
-    let content = read("src/app_actions/handle_action.rs");
-
-    assert!(
-        content.contains("fn launch_editor_with_feedback_async"),
-        "Expected async editor launch helper to exist"
-    );
-
-    let usage_count = count_occurrences(&content, "self.launch_editor_with_feedback_async(&path)");
-    assert!(
-        usage_count >= 2,
-        "Expected edit_script and edit_scriptlet to use async editor launch feedback (found {usage_count} usages)"
-    );
-
-    assert!(
-        content.contains("this.show_hud(message, Some(3000), cx);"),
-        "Expected async editor launch failure to surface a HUD error message"
-    );
-}
-
-#[test]
-fn test_reveal_actions_show_success_hud_after_async_reveal_completion() {
-    let content = read("src/app_actions/handle_action.rs");
-
-    assert!(
-        content.contains("fn reveal_in_finder_with_feedback_async"),
-        "Expected async reveal helper to exist"
-    );
-
-    let usage_count = count_occurrences(
-        &content,
-        "self.reveal_in_finder_with_feedback_async(&path)",
-    ) + count_occurrences(
-        &content,
-        "self.reveal_in_finder_with_feedback_async(path)",
-    );
-    assert!(
-        usage_count >= 2,
-        "Expected reveal actions to use async reveal feedback helper (found {usage_count} usages)"
-    );
-
-    assert!(
-        content.contains("let Ok(reveal_result) = reveal_result_rx.recv().await else {"),
-        "Expected reveal actions to await async reveal completion before showing HUD"
-    );
-
-    assert!(
-        content.contains("this.show_hud(\"Opened in Finder\".to_string(), Some(1500), cx);"),
-        "Expected reveal success HUD to be emitted from async completion callback"
-    );
-}

file update:
diff --git a/src/app_actions/handle_action.rs b/src/app_actions/handle_action.rs
index 6512e920f98eb38811debb5dca005d821b3adb44..dda46dd268dc9fe3130c27b221485ba871f1c703
--- a/src/app_actions/handle_action.rs
+++ b/src/app_actions/handle_action.rs
@@ -32,6 +32,109 @@
         });
     }
 
+    /// Reveal a path and return completion back to the UI thread for HUD feedback.
+    fn reveal_in_finder_with_feedback_async(
+        &self,
+        path: &std::path::Path,
+    ) -> async_channel::Receiver<Result<(), String>> {
+        let path_str = path.to_string_lossy().to_string();
+        let (result_tx, result_rx) = async_channel::bounded::<Result<(), String>>(1);
+
+        std::thread::spawn(move || {
+            let file_manager = if cfg!(target_os = "macos") {
+                "Finder"
+            } else if cfg!(target_os = "windows") {
+                "Explorer"
+            } else {
+                "File Manager"
+            };
+
+            logging::log(
+                "UI",
+                &format!(
+                    "ACTION_REVEAL_IN_FINDER_START file_manager='{}' path='{}'",
+                    file_manager, path_str
+                ),
+            );
+
+            let reveal_result = match crate::file_search::reveal_in_finder(&path_str) {
+                Ok(()) => {
+                    logging::log(
+                        "UI",
+                        &format!(
+                            "ACTION_REVEAL_IN_FINDER_SUCCESS file_manager='{}' path='{}'",
+                            file_manager, path_str
+                        ),
+                    );
+                    Ok(())
+                }
+                Err(error) => {
+                    logging::log(
+                        "ERROR",
+                        &format!(
+                            "ACTION_REVEAL_IN_FINDER_FAILED attempted='reveal_in_finder' path='{}' file_manager='{}' error='{}'",
+                            path_str, file_manager, error
+                        ),
+                    );
+                    Err(format!("Failed to reveal in {}: {}", file_manager, error))
+                }
+            };
+
+            let _ = result_tx.send_blocking(reveal_result);
+        });
+
+        result_rx
+    }
+
+    /// Launch the configured editor and return completion back to the UI thread for HUD feedback.
+    fn launch_editor_with_feedback_async(
+        &self,
+        path: &std::path::Path,
+    ) -> async_channel::Receiver<Result<(), String>> {
+        let editor = self.config.get_editor();
+        let path_str = path.to_string_lossy().to_string();
+        let (result_tx, result_rx) = async_channel::bounded::<Result<(), String>>(1);
+
+        std::thread::spawn(move || {
+            use std::process::Command;
+
+            logging::log(
+                "UI",
+                &format!(
+                    "ACTION_EDITOR_LAUNCH_START editor='{}' path='{}'",
+                    editor, path_str
+                ),
+            );
+
+            let launch_result = match Command::new(&editor).arg(&path_str).spawn() {
+                Ok(_) => {
+                    logging::log(
+                        "UI",
+                        &format!(
+                            "ACTION_EDITOR_LAUNCH_SUCCESS editor='{}' path='{}'",
+                            editor, path_str
+                        ),
+                    );
+                    Ok(())
+                }
+                Err(error) => {
+                    logging::log(
+                        "ERROR",
+                        &format!(
+                            "ACTION_EDITOR_LAUNCH_FAILED attempted='{} {}' path='{}' error='{}'",
+                            editor, path_str, path_str, error
+                        ),
+                    );
+                    Err(format!("Failed to open in {}: {}", editor, error))
+                }
+            };
+
+            let _ = result_tx.send_blocking(launch_result);
+        });
+
+        result_rx
+    }
+
     /// Copy text to clipboard using pbcopy on macOS.
     /// Critical: This properly closes stdin before waiting to prevent hangs.
     #[cfg(target_os = "macos")]
@@ -471,9 +574,24 @@
                 };
 
                 if let Some(path) = path_opt {
-                    self.reveal_in_finder(&path);
-                    self.show_hud("Opened in Finder".to_string(), Some(1500), cx);
-                    self.hide_main_and_reset(cx);
+                    let reveal_result_rx = self.reveal_in_finder_with_feedback_async(&path);
+                    cx.spawn(async move |this, cx| {
+                        let Ok(reveal_result) = reveal_result_rx.recv().await else {
+                            return;
+                        };
+
+                        this.update(cx, |this, cx| match reveal_result {
+                            Ok(()) => {
+                                this.show_hud("Opened in Finder".to_string(), Some(1500), cx);
+                                this.hide_main_and_reset(cx);
+                            }
+                            Err(message) => {
+                                this.show_hud(message, Some(2500), cx);
+                            }
+                        })
+                        .ok();
+                    })
+                    .detach();
                 } else {
                     self.show_hud(
                         "Cannot reveal this item type in Finder".to_string(),
@@ -884,8 +1002,23 @@
                     };
 
                     if let Some(path) = path_opt {
-                        self.edit_script(&path);
-                        self.hide_main_and_reset(cx);
+                        let editor_launch_rx = self.launch_editor_with_feedback_async(&path);
+                        cx.spawn(async move |this, cx| {
+                            let Ok(launch_result) = editor_launch_rx.recv().await else {
+                                return;
+                            };
+
+                            this.update(cx, |this, cx| match launch_result {
+                                Ok(()) => {
+                                    this.hide_main_and_reset(cx);
+                                }
+                                Err(message) => {
+                                    this.show_hud(message, Some(3000), cx);
+                                }
+                            })
+                            .ok();
+                        })
+                        .detach();
                     } else {
                         self.show_hud("Cannot edit this item type".to_string(), Some(2000), cx);
                     }
@@ -1932,8 +2065,23 @@
                             // Extract just the path without the anchor (e.g., "/path/to/file.md#slug" -> "/path/to/file.md")
                             let path_str = file_path.split('#').next().unwrap_or(file_path);
                             let path = std::path::PathBuf::from(path_str);
-                            self.edit_script(&path);
-                            self.hide_main_and_reset(cx);
+                            let editor_launch_rx = self.launch_editor_with_feedback_async(&path);
+                            cx.spawn(async move |this, cx| {
+                                let Ok(launch_result) = editor_launch_rx.recv().await else {
+                                    return;
+                                };
+
+                                this.update(cx, |this, cx| match launch_result {
+                                    Ok(()) => {
+                                        this.hide_main_and_reset(cx);
+                                    }
+                                    Err(message) => {
+                                        this.show_hud(message, Some(3000), cx);
+                                    }
+                                })
+                                .ok();
+                            })
+                            .detach();
                         } else {
                             self.show_hud(
                                 "Scriptlet has no source file path".to_string(),
@@ -1964,9 +2112,24 @@
                             // Extract just the path without the anchor
                             let path_str = file_path.split('#').next().unwrap_or(file_path);
                             let path = std::path::Path::new(path_str);
-                            self.reveal_in_finder(path);
-                            self.show_hud("Opened in Finder".to_string(), Some(1500), cx);
-                            self.hide_main_and_reset(cx);
+                            let reveal_result_rx = self.reveal_in_finder_with_feedback_async(path);
+                            cx.spawn(async move |this, cx| {
+                                let Ok(reveal_result) = reveal_result_rx.recv().await else {
+                                    return;
+                                };
+
+                                this.update(cx, |this, cx| match reveal_result {
+                                    Ok(()) => {
+                                        this.show_hud("Opened in Finder".to_string(), Some(1500), cx);
+                                        this.hide_main_and_reset(cx);
+                                    }
+                                    Err(message) => {
+                                        this.show_hud(message, Some(2500), cx);
+                                    }
+                                })
+                                .ok();
+                            })
+                            .detach();
                         } else {
                             self.show_hud(
                                 "Scriptlet has no source file path".to_string(),
diff --git a/src/app_actions/helpers.rs b/src/app_actions/helpers.rs
index fb50657be41d2650d4e4be37f320f8f2393149b1..b350404d02dd71610199202b59f4fd97d4f27b35
--- a/src/app_actions/helpers.rs
+++ b/src/app_actions/helpers.rs
@@ -172,6 +172,7 @@
     use crate::AppView;
     use crate::clipboard_history::{ClipboardEntryMeta, ContentType};
     use crate::scripts;
+    use std::fs;
     use std::path::PathBuf;
     use std::sync::Arc;
 
@@ -189,6 +190,14 @@
         }
     }
 
+    fn read(path: &str) -> String {
+        fs::read_to_string(path).unwrap_or_else(|_| panic!("Failed to read {path}"))
+    }
+
+    fn count_occurrences(haystack: &str, needle: &str) -> usize {
+        haystack.match_indices(needle).count()
+    }
+
     #[test]
     fn test_select_clipboard_entry_meta_filters_and_clamps() {
         let entries = vec![entry("1", "Alpha"), entry("2", "Beta"), entry("3", "Gamma")];
@@ -364,4 +373,58 @@
             })
         );
     }
+
+    #[test]
+    fn test_edit_actions_show_error_feedback_when_editor_launch_fails() {
+        let content = read("src/app_actions/handle_action.rs");
+
+        assert!(
+            content.contains("fn launch_editor_with_feedback_async"),
+            "Expected async editor launch helper to exist"
+        );
+
+        let usage_count =
+            count_occurrences(&content, "self.launch_editor_with_feedback_async(&path)");
+        assert!(
+            usage_count >= 2,
+            "Expected edit_script and edit_scriptlet to use async editor launch feedback (found {usage_count} usages)"
+        );
+
+        assert!(
+            content.contains("this.show_hud(message, Some(3000), cx);"),
+            "Expected async editor launch failure to surface a HUD error message"
+        );
+    }
+
+    #[test]
+    fn test_reveal_actions_show_success_hud_after_async_completion() {
+        let content = read("src/app_actions/handle_action.rs");
+
+        assert!(
+            content.contains("fn reveal_in_finder_with_feedback_async"),
+            "Expected async reveal helper to exist"
+        );
+
+        let usage_count = count_occurrences(
+            &content,
+            "self.reveal_in_finder_with_feedback_async(&path)",
+        ) + count_occurrences(
+            &content,
+            "self.reveal_in_finder_with_feedback_async(path)",
+        );
+        assert!(
+            usage_count >= 2,
+            "Expected reveal actions to use async reveal feedback helper (found {usage_count} usages)"
+        );
+
+        assert!(
+            content.contains("let Ok(reveal_result) = reveal_result_rx.recv().await else {"),
+            "Expected reveal actions to await reveal completion before showing HUD"
+        );
+
+        assert!(
+            content.contains("this.show_hud(\"Opened in Finder\".to_string(), Some(1500), cx);"),
+            "Expected reveal success HUD to be emitted from async completion callback"
+        );
+    }
 }
diff --git a/src/app_actions/tests/editor_launch_feedback.rs b/src/app_actions/tests/editor_launch_feedback.rs
deleted file mode 100644
index 18077766837c78518094e45c0da3b2a672b8bd8b..0000000000000000000000000000000000000000
--- a/src/app_actions/tests/editor_launch_feedback.rs
+++ /dev/null
@@ -1,62 +0,0 @@
-use std::fs;
-
-fn read(path: &str) -> String {
-    fs::read_to_string(path).unwrap_or_else(|_| panic!("Failed to read {path}"))
-}
-
-fn count_occurrences(haystack: &str, needle: &str) -> usize {
-    haystack.match_indices(needle).count()
-}
-
-#[test]
-fn test_edit_actions_show_error_feedback_when_editor_launch_fails() {
-    let content = read("src/app_actions/handle_action.rs");
-
-    assert!(
-        content.contains("fn launch_editor_with_feedback_async"),
-        "Expected async editor launch helper to exist"
-    );
-
-    let usage_count = count_occurrences(&content, "self.launch_editor_with_feedback_async(&path)");
-    assert!(
-        usage_count >= 2,
-        "Expected edit_script and edit_scriptlet to use async editor launch feedback (found {usage_count} usages)"
-    );
-
-    assert!(
-        content.contains("this.show_hud(message, Some(3000), cx);"),
-        "Expected async editor launch failure to surface a HUD error message"
-    );
-}
-
-#[test]
-fn test_reveal_actions_show_success_hud_after_async_reveal_completion() {
-    let content = read("src/app_actions/handle_action.rs");
-
-    assert!(
-        content.contains("fn reveal_in_finder_with_feedback_async"),
-        "Expected async reveal helper to exist"
-    );
-
-    let usage_count = count_occurrences(
-        &content,
-        "self.reveal_in_finder_with_feedback_async(&path)",
-    ) + count_occurrences(
-        &content,
-        "self.reveal_in_finder_with_feedback_async(path)",
-    );
-    assert!(
-        usage_count >= 2,
-        "Expected reveal actions to use async reveal feedback helper (found {usage_count} usages)"
-    );
-
-    assert!(
-        content.contains("let Ok(reveal_result) = reveal_result_rx.recv().await else {"),
-        "Expected reveal actions to await async reveal completion before showing HUD"
-    );
-
-    assert!(
-        content.contains("this.show_hud(\"Opened in Finder\".to_string(), Some(1500), cx);"),
-        "Expected reveal success HUD to be emitted from async completion callback"
-    );
-}

file update:
diff --git a/src/app_actions/handle_action.rs b/src/app_actions/handle_action.rs
index 6512e920f98eb38811debb5dca005d821b3adb44..dda46dd268dc9fe3130c27b221485ba871f1c703
--- a/src/app_actions/handle_action.rs
+++ b/src/app_actions/handle_action.rs
@@ -32,6 +32,109 @@
         });
     }
 
+    /// Reveal a path and return completion back to the UI thread for HUD feedback.
+    fn reveal_in_finder_with_feedback_async(
+        &self,
+        path: &std::path::Path,
+    ) -> async_channel::Receiver<Result<(), String>> {
+        let path_str = path.to_string_lossy().to_string();
+        let (result_tx, result_rx) = async_channel::bounded::<Result<(), String>>(1);
+
+        std::thread::spawn(move || {
+            let file_manager = if cfg!(target_os = "macos") {
+                "Finder"
+            } else if cfg!(target_os = "windows") {
+                "Explorer"
+            } else {
+                "File Manager"
+            };
+
+            logging::log(
+                "UI",
+                &format!(
+                    "ACTION_REVEAL_IN_FINDER_START file_manager='{}' path='{}'",
+                    file_manager, path_str
+                ),
+            );
+
+            let reveal_result = match crate::file_search::reveal_in_finder(&path_str) {
+                Ok(()) => {
+                    logging::log(
+                        "UI",
+                        &format!(
+                            "ACTION_REVEAL_IN_FINDER_SUCCESS file_manager='{}' path='{}'",
+                            file_manager, path_str
+                        ),
+                    );
+                    Ok(())
+                }
+                Err(error) => {
+                    logging::log(
+                        "ERROR",
+                        &format!(
+                            "ACTION_REVEAL_IN_FINDER_FAILED attempted='reveal_in_finder' path='{}' file_manager='{}' error='{}'",
+                            path_str, file_manager, error
+                        ),
+                    );
+                    Err(format!("Failed to reveal in {}: {}", file_manager, error))
+                }
+            };
+
+            let _ = result_tx.send_blocking(reveal_result);
+        });
+
+        result_rx
+    }
+
+    /// Launch the configured editor and return completion back to the UI thread for HUD feedback.
+    fn launch_editor_with_feedback_async(
+        &self,
+        path: &std::path::Path,
+    ) -> async_channel::Receiver<Result<(), String>> {
+        let editor = self.config.get_editor();
+        let path_str = path.to_string_lossy().to_string();
+        let (result_tx, result_rx) = async_channel::bounded::<Result<(), String>>(1);
+
+        std::thread::spawn(move || {
+            use std::process::Command;
+
+            logging::log(
+                "UI",
+                &format!(
+                    "ACTION_EDITOR_LAUNCH_START editor='{}' path='{}'",
+                    editor, path_str
+                ),
+            );
+
+            let launch_result = match Command::new(&editor).arg(&path_str).spawn() {
+                Ok(_) => {
+                    logging::log(
+                        "UI",
+                        &format!(
+                            "ACTION_EDITOR_LAUNCH_SUCCESS editor='{}' path='{}'",
+                            editor, path_str
+                        ),
+                    );
+                    Ok(())
+                }
+                Err(error) => {
+                    logging::log(
+                        "ERROR",
+                        &format!(
+                            "ACTION_EDITOR_LAUNCH_FAILED attempted='{} {}' path='{}' error='{}'",
+                            editor, path_str, path_str, error
+                        ),
+                    );
+                    Err(format!("Failed to open in {}: {}", editor, error))
+                }
+            };
+
+            let _ = result_tx.send_blocking(launch_result);
+        });
+
+        result_rx
+    }
+
     /// Copy text to clipboard using pbcopy on macOS.
     /// Critical: This properly closes stdin before waiting to prevent hangs.
     #[cfg(target_os = "macos")]
@@ -471,9 +574,24 @@
                 };
 
                 if let Some(path) = path_opt {
-                    self.reveal_in_finder(&path);
-                    self.show_hud("Opened in Finder".to_string(), Some(1500), cx);
-                    self.hide_main_and_reset(cx);
+                    let reveal_result_rx = self.reveal_in_finder_with_feedback_async(&path);
+                    cx.spawn(async move |this, cx| {
+                        let Ok(reveal_result) = reveal_result_rx.recv().await else {
+                            return;
+                        };
+
+                        this.update(cx, |this, cx| match reveal_result {
+                            Ok(()) => {
+                                this.show_hud("Opened in Finder".to_string(), Some(1500), cx);
+                                this.hide_main_and_reset(cx);
+                            }
+                            Err(message) => {
+                                this.show_hud(message, Some(2500), cx);
+                            }
+                        })
+                        .ok();
+                    })
+                    .detach();
                 } else {
                     self.show_hud(
                         "Cannot reveal this item type in Finder".to_string(),
@@ -884,8 +1002,23 @@
                     };
 
                     if let Some(path) = path_opt {
-                        self.edit_script(&path);
-                        self.hide_main_and_reset(cx);
+                        let editor_launch_rx = self.launch_editor_with_feedback_async(&path);
+                        cx.spawn(async move |this, cx| {
+                            let Ok(launch_result) = editor_launch_rx.recv().await else {
+                                return;
+                            };
+
+                            this.update(cx, |this, cx| match launch_result {
+                                Ok(()) => {
+                                    this.hide_main_and_reset(cx);
+                                }
+                                Err(message) => {
+                                    this.show_hud(message, Some(3000), cx);
+                                }
+                            })
+                            .ok();
+                        })
+                        .detach();
                     } else {
                         self.show_hud("Cannot edit this item type".to_string(), Some(2000), cx);
                     }
@@ -1932,8 +2065,23 @@
                             // Extract just the path without the anchor (e.g., "/path/to/file.md#slug" -> "/path/to/file.md")
                             let path_str = file_path.split('#').next().unwrap_or(file_path);
                             let path = std::path::PathBuf::from(path_str);
-                            self.edit_script(&path);
-                            self.hide_main_and_reset(cx);
+                            let editor_launch_rx = self.launch_editor_with_feedback_async(&path);
+                            cx.spawn(async move |this, cx| {
+                                let Ok(launch_result) = editor_launch_rx.recv().await else {
+                                    return;
+                                };
+
+                                this.update(cx, |this, cx| match launch_result {
+                                    Ok(()) => {
+                                        this.hide_main_and_reset(cx);
+                                    }
+                                    Err(message) => {
+                                        this.show_hud(message, Some(3000), cx);
+                                    }
+                                })
+                                .ok();
+                            })
+                            .detach();
                         } else {
                             self.show_hud(
                                 "Scriptlet has no source file path".to_string(),
@@ -1964,9 +2112,24 @@
                             // Extract just the path without the anchor
                             let path_str = file_path.split('#').next().unwrap_or(file_path);
                             let path = std::path::Path::new(path_str);
-                            self.reveal_in_finder(path);
-                            self.show_hud("Opened in Finder".to_string(), Some(1500), cx);
-                            self.hide_main_and_reset(cx);
+                            let reveal_result_rx = self.reveal_in_finder_with_feedback_async(path);
+                            cx.spawn(async move |this, cx| {
+                                let Ok(reveal_result) = reveal_result_rx.recv().await else {
+                                    return;
+                                };
+
+                                this.update(cx, |this, cx| match reveal_result {
+                                    Ok(()) => {
+                                        this.show_hud("Opened in Finder".to_string(), Some(1500), cx);
+                                        this.hide_main_and_reset(cx);
+                                    }
+                                    Err(message) => {
+                                        this.show_hud(message, Some(2500), cx);
+                                    }
+                                })
+                                .ok();
+                            })
+                            .detach();
                         } else {
                             self.show_hud(
                                 "Scriptlet has no source file path".to_string(),
diff --git a/src/app_actions/helpers.rs b/src/app_actions/helpers.rs
index fb50657be41d2650d4e4be37f320f8f2393149b1..b350404d02dd71610199202b59f4fd97d4f27b35
--- a/src/app_actions/helpers.rs
+++ b/src/app_actions/helpers.rs
@@ -172,6 +172,7 @@
     use crate::AppView;
     use crate::clipboard_history::{ClipboardEntryMeta, ContentType};
     use crate::scripts;
+    use std::fs;
     use std::path::PathBuf;
     use std::sync::Arc;
 
@@ -189,6 +190,14 @@
         }
     }
 
+    fn read(path: &str) -> String {
+        fs::read_to_string(path).unwrap_or_else(|_| panic!("Failed to read {path}"))
+    }
+
+    fn count_occurrences(haystack: &str, needle: &str) -> usize {
+        haystack.match_indices(needle).count()
+    }
+
     #[test]
     fn test_select_clipboard_entry_meta_filters_and_clamps() {
         let entries = vec![entry("1", "Alpha"), entry("2", "Beta"), entry("3", "Gamma")];
@@ -364,4 +373,58 @@
             })
         );
     }
+
+    #[test]
+    fn test_edit_actions_show_error_feedback_when_editor_launch_fails() {
+        let content = read("src/app_actions/handle_action.rs");
+
+        assert!(
+            content.contains("fn launch_editor_with_feedback_async"),
+            "Expected async editor launch helper to exist"
+        );
+
+        let usage_count =
+            count_occurrences(&content, "self.launch_editor_with_feedback_async(&path)");
+        assert!(
+            usage_count >= 2,
+            "Expected edit_script and edit_scriptlet to use async editor launch feedback (found {usage_count} usages)"
+        );
+
+        assert!(
+            content.contains("this.show_hud(message, Some(3000), cx);"),
+            "Expected async editor launch failure to surface a HUD error message"
+        );
+    }
+
+    #[test]
+    fn test_reveal_actions_show_success_hud_after_async_completion() {
+        let content = read("src/app_actions/handle_action.rs");
+
+        assert!(
+            content.contains("fn reveal_in_finder_with_feedback_async"),
+            "Expected async reveal helper to exist"
+        );
+
+        let usage_count = count_occurrences(
+            &content,
+            "self.reveal_in_finder_with_feedback_async(&path)",
+        ) + count_occurrences(
+            &content,
+            "self.reveal_in_finder_with_feedback_async(path)",
+        );
+        assert!(
+            usage_count >= 2,
+            "Expected reveal actions to use async reveal feedback helper (found {usage_count} usages)"
+        );
+
+        assert!(
+            content.contains("let Ok(reveal_result) = reveal_result_rx.recv().await else {"),
+            "Expected reveal actions to await reveal completion before showing HUD"
+        );
+
+        assert!(
+            content.contains("this.show_hud(\"Opened in Finder\".to_string(), Some(1500), cx);"),
+            "Expected reveal success HUD to be emitted from async completion callback"
+        );
+    }
 }
diff --git a/src/app_actions/tests/editor_launch_feedback.rs b/src/app_actions/tests/editor_launch_feedback.rs
deleted file mode 100644
index 18077766837c78518094e45c0da3b2a672b8bd8b..0000000000000000000000000000000000000000
--- a/src/app_actions/tests/editor_launch_feedback.rs
+++ /dev/null
@@ -1,62 +0,0 @@
-use std::fs;
-
-fn read(path: &str) -> String {
-    fs::read_to_string(path).unwrap_or_else(|_| panic!("Failed to read {path}"))
-}
-
-fn count_occurrences(haystack: &str, needle: &str) -> usize {
-    haystack.match_indices(needle).count()
-}
-
-#[test]
-fn test_edit_actions_show_error_feedback_when_editor_launch_fails() {
-    let content = read("src/app_actions/handle_action.rs");
-
-    assert!(
-        content.contains("fn launch_editor_with_feedback_async"),
-        "Expected async editor launch helper to exist"
-    );
-
-    let usage_count = count_occurrences(&content, "self.launch_editor_with_feedback_async(&path)");
-    assert!(
-        usage_count >= 2,
-        "Expected edit_script and edit_scriptlet to use async editor launch feedback (found {usage_count} usages)"
-    );
-
-    assert!(
-        content.contains("this.show_hud(message, Some(3000), cx);"),
-        "Expected async editor launch failure to surface a HUD error message"
-    );
-}
-
-#[test]
-fn test_reveal_actions_show_success_hud_after_async_reveal_completion() {
-    let content = read("src/app_actions/handle_action.rs");
-
-    assert!(
-        content.contains("fn reveal_in_finder_with_feedback_async"),
-        "Expected async reveal helper to exist"
-    );
-
-    let usage_count = count_occurrences(
-        &content,
-        "self.reveal_in_finder_with_feedback_async(&path)",
-    ) + count_occurrences(
-        &content,
-        "self.reveal_in_finder_with_feedback_async(path)",
-    );
-    assert!(
-        usage_count >= 2,
-        "Expected reveal actions to use async reveal feedback helper (found {usage_count} usages)"
-    );
-
-    assert!(
-        content.contains("let Ok(reveal_result) = reveal_result_rx.recv().await else {"),
-        "Expected reveal actions to await async reveal completion before showing HUD"
-    );
-
-    assert!(
-        content.contains("this.show_hud(\"Opened in Finder\".to_string(), Some(1500), cx);"),
-        "Expected reveal success HUD to be emitted from async completion callback"
-    );
-}

 exited 101 in 24.19s:
    Blocking waiting for file lock on build directory
    Checking script-kit-gpui v0.1.0 (/Users/johnlindquist/dev/script-kit-gpui)
warning: glob import doesn't reexport anything with visibility `pub(in crate::prompts)` because no imported item is public enough
  --> src/prompts/div/mod.rs:32:16
   |
32 | pub(super) use inline::*;
   |                ^^^^^^^^^
   |
note: the most public imported item is `pub(self)`
  --> src/prompts/div/mod.rs:32:16
   |
32 | pub(super) use inline::*;
   |                ^^^^^^^^^
   = help: reduce the glob import's visibility or increase visibility of imported items
   = note: `#[warn(unused_imports)]` (part of `#[warn(unused)]`) on by default

warning: glob import doesn't reexport anything with visibility `pub(in crate::prompts)` because no imported item is public enough
  --> src/prompts/div/mod.rs:34:16
   |
34 | pub(super) use render_html::*;

thinking
**Confirming command execution flow**
file update:
diff --git a/src/app_actions/handle_action.rs b/src/app_actions/handle_action.rs
index 6512e920f98eb38811debb5dca005d821b3adb44..dda46dd268dc9fe3130c27b221485ba871f1c703
--- a/src/app_actions/handle_action.rs
+++ b/src/app_actions/handle_action.rs
@@ -32,6 +32,109 @@
         });
     }
 
+    /// Reveal a path and return completion back to the UI thread for HUD feedback.
+    fn reveal_in_finder_with_feedback_async(
+        &self,
+        path: &std::path::Path,
+    ) -> async_channel::Receiver<Result<(), String>> {
+        let path_str = path.to_string_lossy().to_string();
+        let (result_tx, result_rx) = async_channel::bounded::<Result<(), String>>(1);
+
+        std::thread::spawn(move || {
+            let file_manager = if cfg!(target_os = "macos") {
+                "Finder"
+            } else if cfg!(target_os = "windows") {
+                "Explorer"
+            } else {
+                "File Manager"
+            };
+
+            logging::log(
+                "UI",
+                &format!(
+                    "ACTION_REVEAL_IN_FINDER_START file_manager='{}' path='{}'",
+                    file_manager, path_str
+                ),
+            );
+
+            let reveal_result = match crate::file_search::reveal_in_finder(&path_str) {
+                Ok(()) => {
+                    logging::log(
+                        "UI",
+                        &format!(
+                            "ACTION_REVEAL_IN_FINDER_SUCCESS file_manager='{}' path='{}'",
+                            file_manager, path_str
+                        ),
+                    );
+                    Ok(())
+                }
+                Err(error) => {
+                    logging::log(
+                        "ERROR",
+                        &format!(
+                            "ACTION_REVEAL_IN_FINDER_FAILED attempted='reveal_in_finder' path='{}' file_manager='{}' error='{}'",
+                            path_str, file_manager, error
+                        ),
+                    );
+                    Err(format!("Failed to reveal in {}: {}", file_manager, error))
+                }
+            };
+
+            let _ = result_tx.send_blocking(reveal_result);
+        });
+
+        result_rx
+    }
+
+    /// Launch the configured editor and return completion back to the UI thread for HUD feedback.
+    fn launch_editor_with_feedback_async(
+        &self,
+        path: &std::path::Path,
+    ) -> async_channel::Receiver<Result<(), String>> {
+        let editor = self.config.get_editor();
+        let path_str = path.to_string_lossy().to_string();
+        let (result_tx, result_rx) = async_channel::bounded::<Result<(), String>>(1);
+
+        std::thread::spawn(move || {
+            use std::process::Command;
+
+            logging::log(
+                "UI",
+                &format!(
+                    "ACTION_EDITOR_LAUNCH_START editor='{}' path='{}'",
+                    editor, path_str
+                ),
+            );
+
+            let launch_result = match Command::new(&editor).arg(&path_str).spawn() {
+                Ok(_) => {
+                    logging::log(
+                        "UI",
+                        &format!(
+                            "ACTION_EDITOR_LAUNCH_SUCCESS editor='{}' path='{}'",
+                            editor, path_str
+                        ),
+                    );
+                    Ok(())
+                }
+                Err(error) => {
+                    logging::log(
+                        "ERROR",
+                        &format!(
+                            "ACTION_EDITOR_LAUNCH_FAILED attempted='{} {}' path='{}' error='{}'",
+                            editor, path_str, path_str, error
+                        ),
+                    );
+                    Err(format!("Failed to open in {}: {}", editor, error))
+                }
+            };
+
+            let _ = result_tx.send_blocking(launch_result);
+        });
+
+        result_rx
+    }
+
     /// Copy text to clipboard using pbcopy on macOS.
     /// Critical: This properly closes stdin before waiting to prevent hangs.
     #[cfg(target_os = "macos")]
@@ -471,9 +574,24 @@
                 };
 
                 if let Some(path) = path_opt {
-                    self.reveal_in_finder(&path);
-                    self.show_hud("Opened in Finder".to_string(), Some(1500), cx);
-                    self.hide_main_and_reset(cx);
+                    let reveal_result_rx = self.reveal_in_finder_with_feedback_async(&path);
+                    cx.spawn(async move |this, cx| {
+                        let Ok(reveal_result) = reveal_result_rx.recv().await else {
+                            return;
+                        };
+
+                        this.update(cx, |this, cx| match reveal_result {
+                            Ok(()) => {
+                                this.show_hud("Opened in Finder".to_string(), Some(1500), cx);
+                                this.hide_main_and_reset(cx);
+                            }
+                            Err(message) => {
+                                this.show_hud(message, Some(2500), cx);
+                            }
+                        })
+                        .ok();
+                    })
+                    .detach();
                 } else {
                     self.show_hud(
                         "Cannot reveal this item type in Finder".to_string(),
@@ -884,8 +1002,23 @@
                     };
 
                     if let Some(path) = path_opt {
-                        self.edit_script(&path);
-                        self.hide_main_and_reset(cx);
+                        let editor_launch_rx = self.launch_editor_with_feedback_async(&path);
+                        cx.spawn(async move |this, cx| {
+                            let Ok(launch_result) = editor_launch_rx.recv().await else {
+                                return;
+                            };
+
+                            this.update(cx, |this, cx| match launch_result {
+                                Ok(()) => {
+                                    this.hide_main_and_reset(cx);
+                                }
+                                Err(message) => {
+                                    this.show_hud(message, Some(3000), cx);
+                                }
+                            })
+                            .ok();
+                        })
+                        .detach();
                     } else {
                         self.show_hud("Cannot edit this item type".to_string(), Some(2000), cx);
                     }
@@ -1932,8 +2065,23 @@
                             // Extract just the path without the anchor (e.g., "/path/to/file.md#slug" -> "/path/to/file.md")
                             let path_str = file_path.split('#').next().unwrap_or(file_path);
                             let path = std::path::PathBuf::from(path_str);
-                            self.edit_script(&path);
-                            self.hide_main_and_reset(cx);
+                            let editor_launch_rx = self.launch_editor_with_feedback_async(&path);
+                            cx.spawn(async move |this, cx| {
+                                let Ok(launch_result) = editor_launch_rx.recv().await else {
+                                    return;
+                                };
+
+                                this.update(cx, |this, cx| match launch_result {
+                                    Ok(()) => {
+                                        this.hide_main_and_reset(cx);
+                                    }
+                                    Err(message) => {
+                                        this.show_hud(message, Some(3000), cx);
+                                    }
+                                })
+                                .ok();
+                            })
+                            .detach();
                         } else {
                             self.show_hud(
                                 "Scriptlet has no source file path".to_string(),
@@ -1964,9 +2112,24 @@
                             // Extract just the path without the anchor
                             let path_str = file_path.split('#').next().unwrap_or(file_path);
                             let path = std::path::Path::new(path_str);
-                            self.reveal_in_finder(path);
-                            self.show_hud("Opened in Finder".to_string(), Some(1500), cx);
-                            self.hide_main_and_reset(cx);
+                            let reveal_result_rx = self.reveal_in_finder_with_feedback_async(path);
+                            cx.spawn(async move |this, cx| {
+                                let Ok(reveal_result) = reveal_result_rx.recv().await else {
+                                    return;
+                                };
+
+                                this.update(cx, |this, cx| match reveal_result {
+                                    Ok(()) => {
+                                        this.show_hud("Opened in Finder".to_string(), Some(1500), cx);
+                                        this.hide_main_and_reset(cx);
+                                    }
+                                    Err(message) => {
+                                        this.show_hud(message, Some(2500), cx);
+                                    }
+                                })
+                                .ok();
+                            })
+                            .detach();
                         } else {
                             self.show_hud(
                                 "Scriptlet has no source file path".to_string(),
diff --git a/src/app_actions/helpers.rs b/src/app_actions/helpers.rs
index fb50657be41d2650d4e4be37f320f8f2393149b1..b350404d02dd71610199202b59f4fd97d4f27b35
--- a/src/app_actions/helpers.rs
+++ b/src/app_actions/helpers.rs
@@ -172,6 +172,7 @@
     use crate::AppView;
     use crate::clipboard_history::{ClipboardEntryMeta, ContentType};
     use crate::scripts;
+    use std::fs;
     use std::path::PathBuf;
     use std::sync::Arc;
 
@@ -189,6 +190,14 @@
         }
     }
 
+    fn read(path: &str) -> String {
+        fs::read_to_string(path).unwrap_or_else(|_| panic!("Failed to read {path}"))
+    }
+
+    fn count_occurrences(haystack: &str, needle: &str) -> usize {
+        haystack.match_indices(needle).count()
+    }
+
     #[test]
     fn test_select_clipboard_entry_meta_filters_and_clamps() {
         let entries = vec![entry("1", "Alpha"), entry("2", "Beta"), entry("3", "Gamma")];
@@ -364,4 +373,58 @@
             })
         );
     }
+
+    #[test]
+    fn test_edit_actions_show_error_feedback_when_editor_launch_fails() {
+        let content = read("src/app_actions/handle_action.rs");
+
+        assert!(
+            content.contains("fn launch_editor_with_feedback_async"),
+            "Expected async editor launch helper to exist"
+        );
+
+        let usage_count =
+            count_occurrences(&content, "self.launch_editor_with_feedback_async(&path)");
+        assert!(
+            usage_count >= 2,
+            "Expected edit_script and edit_scriptlet to use async editor launch feedback (found {usage_count} usages)"
+        );
+
+        assert!(
+            content.contains("this.show_hud(message, Some(3000), cx);"),
+            "Expected async editor launch failure to surface a HUD error message"
+        );
+    }
+
+    #[test]
+    fn test_reveal_actions_show_success_hud_after_async_completion() {
+        let content = read("src/app_actions/handle_action.rs");
+
+        assert!(
+            content.contains("fn reveal_in_finder_with_feedback_async"),
+            "Expected async reveal helper to exist"
+        );
+
+        let usage_count = count_occurrences(
+            &content,
+            "self.reveal_in_finder_with_feedback_async(&path)",
+        ) + count_occurrences(
+            &content,
+            "self.reveal_in_finder_with_feedback_async(path)",
+        );
+        assert!(
+            usage_count >= 2,
+            "Expected reveal actions to use async reveal feedback helper (found {usage_count} usages)"
+        );
+
+        assert!(
+            content.contains("let Ok(reveal_result) = reveal_result_rx.recv().await else {"),
+            "Expected reveal actions to await reveal completion before showing HUD"
+        );
+
+        assert!(
+            content.contains("this.show_hud(\"Opened in Finder\".to_string(), Some(1500), cx);"),
+            "Expected reveal success HUD to be emitted from async completion callback"
+        );
+    }
 }
diff --git a/src/app_actions/tests/editor_launch_feedback.rs b/src/app_actions/tests/editor_launch_feedback.rs
deleted file mode 100644
index 18077766837c78518094e45c0da3b2a672b8bd8b..0000000000000000000000000000000000000000
--- a/src/app_actions/tests/editor_launch_feedback.rs
+++ /dev/null
@@ -1,62 +0,0 @@
-use std::fs;
-
-fn read(path: &str) -> String {
-    fs::read_to_string(path).unwrap_or_else(|_| panic!("Failed to read {path}"))
-}
-
-fn count_occurrences(haystack: &str, needle: &str) -> usize {
-    haystack.match_indices(needle).count()
-}
-
-#[test]
-fn test_edit_actions_show_error_feedback_when_editor_launch_fails() {
-    let content = read("src/app_actions/handle_action.rs");
-
-    assert!(
-        content.contains("fn launch_editor_with_feedback_async"),
-        "Expected async editor launch helper to exist"
-    );
-
-    let usage_count = count_occurrences(&content, "self.launch_editor_with_feedback_async(&path)");
-    assert!(
-        usage_count >= 2,
-        "Expected edit_script and edit_scriptlet to use async editor launch feedback (found {usage_count} usages)"
-    );
-
-    assert!(
-        content.contains("this.show_hud(message, Some(3000), cx);"),
-        "Expected async editor launch failure to surface a HUD error message"
-    );
-}
-
-#[test]
-fn test_reveal_actions_show_success_hud_after_async_reveal_completion() {
-    let content = read("src/app_actions/handle_action.rs");
-
-    assert!(
-        content.contains("fn reveal_in_finder_with_feedback_async"),
-        "Expected async reveal helper to exist"
-    );
-
-    let usage_count = count_occurrences(
-        &content,
-        "self.reveal_in_finder_with_feedback_async(&path)",
-    ) + count_occurrences(
-        &content,
-        "self.reveal_in_finder_with_feedback_async(path)",
-    );
-    assert!(
-        usage_count >= 2,
-        "Expected reveal actions to use async reveal feedback helper (found {usage_count} usages)"
-    );
-
-    assert!(
-        content.contains("let Ok(reveal_result) = reveal_result_rx.recv().await else {"),
-        "Expected reveal actions to await async reveal completion before showing HUD"
-    );
-
-    assert!(
-        content.contains("this.show_hud(\"Opened in Finder\".to_string(), Some(1500), cx);"),
-        "Expected reveal success HUD to be emitted from async completion callback"
-    );
-}


thinking
**Attempting separate clippy run**
exec
/bin/zsh -lc 'cargo clippy --all-targets -- -D warnings' in /Users/johnlindquist/dev/script-kit-gpuifile update:
diff --git a/src/app_actions/handle_action.rs b/src/app_actions/handle_action.rs
index 6512e920f98eb38811debb5dca005d821b3adb44..dda46dd268dc9fe3130c27b221485ba871f1c703
--- a/src/app_actions/handle_action.rs
+++ b/src/app_actions/handle_action.rs
@@ -32,6 +32,109 @@
         });
     }
 
+    /// Reveal a path and return completion back to the UI thread for HUD feedback.
+    fn reveal_in_finder_with_feedback_async(
+        &self,
+        path: &std::path::Path,
+    ) -> async_channel::Receiver<Result<(), String>> {
+        let path_str = path.to_string_lossy().to_string();
+        let (result_tx, result_rx) = async_channel::bounded::<Result<(), String>>(1);
+
+        std::thread::spawn(move || {
+            let file_manager = if cfg!(target_os = "macos") {
+                "Finder"
+            } else if cfg!(target_os = "windows") {
+                "Explorer"
+            } else {
+                "File Manager"
+            };
+
+            logging::log(
+                "UI",
+                &format!(
+                    "ACTION_REVEAL_IN_FINDER_START file_manager='{}' path='{}'",
+                    file_manager, path_str
+                ),
+            );
+
+            let reveal_result = match crate::file_search::reveal_in_finder(&path_str) {
+                Ok(()) => {
+                    logging::log(
+                        "UI",
+                        &format!(
+                            "ACTION_REVEAL_IN_FINDER_SUCCESS file_manager='{}' path='{}'",
+                            file_manager, path_str
+                        ),
+                    );
+                    Ok(())
+                }
+                Err(error) => {
+                    logging::log(
+                        "ERROR",
+                        &format!(
+                            "ACTION_REVEAL_IN_FINDER_FAILED attempted='reveal_in_finder' path='{}' file_manager='{}' error='{}'",
+                            path_str, file_manager, error
+                        ),
+                    );
+                    Err(format!("Failed to reveal in {}: {}", file_manager, error))
+                }
+            };
+
+            let _ = result_tx.send_blocking(reveal_result);
+        });
+
+        result_rx
+    }
+
+    /// Launch the configured editor and return completion back to the UI thread for HUD feedback.
+    fn launch_editor_with_feedback_async(
+        &self,
+        path: &std::path::Path,
+    ) -> async_channel::Receiver<Result<(), String>> {
+        let editor = self.config.get_editor();
+        let path_str = path.to_string_lossy().to_string();
+        let (result_tx, result_rx) = async_channel::bounded::<Result<(), String>>(1);
+
+        std::thread::spawn(move || {
+            use std::process::Command;
+
+            logging::log(
+                "UI",
+                &format!(
+                    "ACTION_EDITOR_LAUNCH_START editor='{}' path='{}'",
+                    editor, path_str
+                ),
+            );
+
+            let launch_result = match Command::new(&editor).arg(&path_str).spawn() {
+                Ok(_) => {
+                    logging::log(
+                        "UI",
+                        &format!(
+                            "ACTION_EDITOR_LAUNCH_SUCCESS editor='{}' path='{}'",
+                            editor, path_str
+                        ),
+                    );
+                    Ok(())
+                }
+                Err(error) => {
+                    logging::log(
+                        "ERROR",
+                        &format!(
+                            "ACTION_EDITOR_LAUNCH_FAILED attempted='{} {}' path='{}' error='{}'",
+                            editor, path_str, path_str, error
+                        ),
+                    );
+                    Err(format!("Failed to open in {}: {}", editor, error))
+                }
+            };
+
+            let _ = result_tx.send_blocking(launch_result);
+        });
+
+        result_rx
+    }
+
     /// Copy text to clipboard using pbcopy on macOS.
     /// Critical: This properly closes stdin before waiting to prevent hangs.
     #[cfg(target_os = "macos")]
@@ -471,9 +574,24 @@
                 };
 
                 if let Some(path) = path_opt {
-                    self.reveal_in_finder(&path);
-                    self.show_hud("Opened in Finder".to_string(), Some(1500), cx);
-                    self.hide_main_and_reset(cx);
+                    let reveal_result_rx = self.reveal_in_finder_with_feedback_async(&path);
+                    cx.spawn(async move |this, cx| {
+                        let Ok(reveal_result) = reveal_result_rx.recv().await else {
+                            return;
+                        };
+
+                        this.update(cx, |this, cx| match reveal_result {
+                            Ok(()) => {
+                                this.show_hud("Opened in Finder".to_string(), Some(1500), cx);
+                                this.hide_main_and_reset(cx);
+                            }
+                            Err(message) => {
+                                this.show_hud(message, Some(2500), cx);
+                            }
+                        })
+                        .ok();
+                    })
+                    .detach();
                 } else {
                     self.show_hud(
                         "Cannot reveal this item type in Finder".to_string(),
@@ -884,8 +1002,23 @@
                     };
 
                     if let Some(path) = path_opt {
-                        self.edit_script(&path);
-                        self.hide_main_and_reset(cx);
+                        let editor_launch_rx = self.launch_editor_with_feedback_async(&path);
+                        cx.spawn(async move |this, cx| {
+                            let Ok(launch_result) = editor_launch_rx.recv().await else {
+                                return;
+                            };
+
+                            this.update(cx, |this, cx| match launch_result {
+                                Ok(()) => {
+                                    this.hide_main_and_reset(cx);
+                                }
+                                Err(message) => {
+                                    this.show_hud(message, Some(3000), cx);
+                                }
+                            })
+                            .ok();
+                        })
+                        .detach();
                     } else {
                         self.show_hud("Cannot edit this item type".to_string(), Some(2000), cx);
                     }
@@ -1932,8 +2065,23 @@
                             // Extract just the path without the anchor (e.g., "/path/to/file.md#slug" -> "/path/to/file.md")
                             let path_str = file_path.split('#').next().unwrap_or(file_path);
                             let path = std::path::PathBuf::from(path_str);
-                            self.edit_script(&path);
-                            self.hide_main_and_reset(cx);
+                            let editor_launch_rx = self.launch_editor_with_feedback_async(&path);
+                            cx.spawn(async move |this, cx| {
+                                let Ok(launch_result) = editor_launch_rx.recv().await else {
+                                    return;
+                                };
+
+                                this.update(cx, |this, cx| match launch_result {
+                                    Ok(()) => {
+                                        this.hide_main_and_reset(cx);
+                                    }
+                                    Err(message) => {
+                                        this.show_hud(message, Some(3000), cx);
+                                    }
+                                })
+                                .ok();
+                            })
+                            .detach();
                         } else {
                             self.show_hud(
                                 "Scriptlet has no source file path".to_string(),
@@ -1964,9 +2112,24 @@
                             // Extract just the path without the anchor
                             let path_str = file_path.split('#').next().unwrap_or(file_path);
                             let path = std::path::Path::new(path_str);
-                            self.reveal_in_finder(path);
-                            self.show_hud("Opened in Finder".to_string(), Some(1500), cx);
-                            self.hide_main_and_reset(cx);
+                            let reveal_result_rx = self.reveal_in_finder_with_feedback_async(path);
+                            cx.spawn(async move |this, cx| {
+                                let Ok(reveal_result) = reveal_result_rx.recv().await else {
+                                    return;
+                                };
+
+                                this.update(cx, |this, cx| match reveal_result {
+                                    Ok(()) => {
+                                        this.show_hud("Opened in Finder".to_string(), Some(1500), cx);
+                                        this.hide_main_and_reset(cx);
+                                    }
+                                    Err(message) => {
+                                        this.show_hud(message, Some(2500), cx);
+                                    }
+                                })
+                                .ok();
+                            })
+                            .detach();
                         } else {
                             self.show_hud(
                                 "Scriptlet has no source file path".to_string(),
diff --git a/src/app_actions/helpers.rs b/src/app_actions/helpers.rs
index fb50657be41d2650d4e4be37f320f8f2393149b1..b350404d02dd71610199202b59f4fd97d4f27b35
--- a/src/app_actions/helpers.rs
+++ b/src/app_actions/helpers.rs
@@ -172,6 +172,7 @@
     use crate::AppView;
     use crate::clipboard_history::{ClipboardEntryMeta, ContentType};
     use crate::scripts;
+    use std::fs;
     use std::path::PathBuf;
     use std::sync::Arc;
 
@@ -189,6 +190,14 @@
         }
     }
 
+    fn read(path: &str) -> String {
+        fs::read_to_string(path).unwrap_or_else(|_| panic!("Failed to read {path}"))
+    }
+
+    fn count_occurrences(haystack: &str, needle: &str) -> usize {
+        haystack.match_indices(needle).count()
+    }
+
     #[test]
     fn test_select_clipboard_entry_meta_filters_and_clamps() {
         let entries = vec![entry("1", "Alpha"), entry("2", "Beta"), entry("3", "Gamma")];
@@ -364,4 +373,58 @@
             })
         );
     }
+
+    #[test]
+    fn test_edit_actions_show_error_feedback_when_editor_launch_fails() {
+        let content = read("src/app_actions/handle_action.rs");
+
+        assert!(
+            content.contains("fn launch_editor_with_feedback_async"),
+            "Expected async editor launch helper to exist"
+        );
+
+        let usage_count =
+            count_occurrences(&content, "self.launch_editor_with_feedback_async(&path)");
+        assert!(
+            usage_count >= 2,
+            "Expected edit_script and edit_scriptlet to use async editor launch feedback (found {usage_count} usages)"
+        );
+
+        assert!(
+            content.contains("this.show_hud(message, Some(3000), cx);"),
+            "Expected async editor launch failure to surface a HUD error message"
+        );
+    }
+
+    #[test]
+    fn test_reveal_actions_show_success_hud_after_async_completion() {
+        let content = read("src/app_actions/handle_action.rs");
+
+        assert!(
+            content.contains("fn reveal_in_finder_with_feedback_async"),
+            "Expected async reveal helper to exist"
+        );
+
+        let usage_count = count_occurrences(
+            &content,
+            "self.reveal_in_finder_with_feedback_async(&path)",
+        ) + count_occurrences(
+            &content,
+            "self.reveal_in_finder_with_feedback_async(path)",
+        );
+        assert!(
+            usage_count >= 2,
+            "Expected reveal actions to use async reveal feedback helper (found {usage_count} usages)"
+        );
+
+        assert!(
+            content.contains("let Ok(reveal_result) = reveal_result_rx.recv().await else {"),
+            "Expected reveal actions to await reveal completion before showing HUD"
+        );
+
+        assert!(
+            content.contains("this.show_hud(\"Opened in Finder\".to_string(), Some(1500), cx);"),
+            "Expected reveal success HUD to be emitted from async completion callback"
+        );
+    }
 }
diff --git a/src/app_actions/tests/editor_launch_feedback.rs b/src/app_actions/tests/editor_launch_feedback.rs
deleted file mode 100644
index 18077766837c78518094e45c0da3b2a672b8bd8b..0000000000000000000000000000000000000000
--- a/src/app_actions/tests/editor_launch_feedback.rs
+++ /dev/null
@@ -1,62 +0,0 @@
-use std::fs;
-
-fn read(path: &str) -> String {
-    fs::read_to_string(path).unwrap_or_else(|_| panic!("Failed to read {path}"))
-}
-
-fn count_occurrences(haystack: &str, needle: &str) -> usize {
-    haystack.match_indices(needle).count()
-}
-
-#[test]
-fn test_edit_actions_show_error_feedback_when_editor_launch_fails() {
-    let content = read("src/app_actions/handle_action.rs");
-
-    assert!(
-        content.contains("fn launch_editor_with_feedback_async"),
-        "Expected async editor launch helper to exist"
-    );
-
-    let usage_count = count_occurrences(&content, "self.launch_editor_with_feedback_async(&path)");
-    assert!(
-        usage_count >= 2,
-        "Expected edit_script and edit_scriptlet to use async editor launch feedback (found {usage_count} usages)"
-    );
-
-    assert!(
-        content.contains("this.show_hud(message, Some(3000), cx);"),
-        "Expected async editor launch failure to surface a HUD error message"
-    );
-}
-
-#[test]
-fn test_reveal_actions_show_success_hud_after_async_reveal_completion() {
-    let content = read("src/app_actions/handle_action.rs");
-
-    assert!(
-        content.contains("fn reveal_in_finder_with_feedback_async"),
-        "Expected async reveal helper to exist"
-    );
-
-    let usage_count = count_occurrences(
-        &content,
-        "self.reveal_in_finder_with_feedback_async(&path)",
-    ) + count_occurrences(
-        &content,
-        "self.reveal_in_finder_with_feedback_async(path)",
-    );
-    assert!(
-        usage_count >= 2,
-        "Expected reveal actions to use async reveal feedback helper (found {usage_count} usages)"
-    );
-
-    assert!(
-        content.contains("let Ok(reveal_result) = reveal_result_rx.recv().await else {"),
-        "Expected reveal actions to await async reveal completion before showing HUD"
-    );
-
-    assert!(
-        content.contains("this.show_hud(\"Opened in Finder\".to_string(), Some(1500), cx);"),
-        "Expected reveal success HUD to be emitted from async completion callback"
-    );
-}

file update:
diff --git a/src/app_actions/handle_action.rs b/src/app_actions/handle_action.rs
index 6512e920f98eb38811debb5dca005d821b3adb44..dda46dd268dc9fe3130c27b221485ba871f1c703
--- a/src/app_actions/handle_action.rs
+++ b/src/app_actions/handle_action.rs
@@ -32,6 +32,109 @@
         });
     }
 
+    /// Reveal a path and return completion back to the UI thread for HUD feedback.
+    fn reveal_in_finder_with_feedback_async(
+        &self,
+        path: &std::path::Path,
+    ) -> async_channel::Receiver<Result<(), String>> {
+        let path_str = path.to_string_lossy().to_string();
+        let (result_tx, result_rx) = async_channel::bounded::<Result<(), String>>(1);
+
+        std::thread::spawn(move || {
+            let file_manager = if cfg!(target_os = "macos") {
+                "Finder"
+            } else if cfg!(target_os = "windows") {
+                "Explorer"
+            } else {
+                "File Manager"
+            };
+
+            logging::log(
+                "UI",
+                &format!(
+                    "ACTION_REVEAL_IN_FINDER_START file_manager='{}' path='{}'",
+                    file_manager, path_str
+                ),
+            );
+
+            let reveal_result = match crate::file_search::reveal_in_finder(&path_str) {
+                Ok(()) => {
+                    logging::log(
+                        "UI",
+                        &format!(
+                            "ACTION_REVEAL_IN_FINDER_SUCCESS file_manager='{}' path='{}'",
+                            file_manager, path_str
+                        ),
+                    );
+                    Ok(())
+                }
+                Err(error) => {
+                    logging::log(
+                        "ERROR",
+                        &format!(
+                            "ACTION_REVEAL_IN_FINDER_FAILED attempted='reveal_in_finder' path='{}' file_manager='{}' error='{}'",
+                            path_str, file_manager, error
+                        ),
+                    );
+                    Err(format!("Failed to reveal in {}: {}", file_manager, error))
+                }
+            };
+
+            let _ = result_tx.send_blocking(reveal_result);
+        });
+
+        result_rx
+    }
+
+    /// Launch the configured editor and return completion back to the UI thread for HUD feedback.
+    fn launch_editor_with_feedback_async(
+        &self,
+        path: &std::path::Path,
+    ) -> async_channel::Receiver<Result<(), String>> {
+        let editor = self.config.get_editor();
+        let path_str = path.to_string_lossy().to_string();
+        let (result_tx, result_rx) = async_channel::bounded::<Result<(), String>>(1);
+
+        std::thread::spawn(move || {
+            use std::process::Command;
+
+            logging::log(
+                "UI",
+                &format!(
+                    "ACTION_EDITOR_LAUNCH_START editor='{}' path='{}'",
+                    editor, path_str
+                ),
+            );
+
+            let launch_result = match Command::new(&editor).arg(&path_str).spawn() {
+                Ok(_) => {
+                    logging::log(
+                        "UI",
+                        &format!(
+                            "ACTION_EDITOR_LAUNCH_SUCCESS editor='{}' path='{}'",
+                            editor, path_str
+                        ),
+                    );
+                    Ok(())
+                }
+                Err(error) => {
+                    logging::log(
+                        "ERROR",
+                        &format!(
+                            "ACTION_EDITOR_LAUNCH_FAILED attempted='{} {}' path='{}' error='{}'",
+                            editor, path_str, path_str, error
+                        ),
+                    );
+                    Err(format!("Failed to open in {}: {}", editor, error))
+                }
+            };
+
+            let _ = result_tx.send_blocking(launch_result);
+        });
+
+        result_rx
+    }
+
     /// Copy text to clipboard using pbcopy on macOS.
     /// Critical: This properly closes stdin before waiting to prevent hangs.
     #[cfg(target_os = "macos")]
@@ -471,9 +574,24 @@
                 };
 
                 if let Some(path) = path_opt {
-                    self.reveal_in_finder(&path);
-                    self.show_hud("Opened in Finder".to_string(), Some(1500), cx);
-                    self.hide_main_and_reset(cx);
+                    let reveal_result_rx = self.reveal_in_finder_with_feedback_async(&path);
+                    cx.spawn(async move |this, cx| {
+                        let Ok(reveal_result) = reveal_result_rx.recv().await else {
+                            return;
+                        };
+
+                        this.update(cx, |this, cx| match reveal_result {
+                            Ok(()) => {
+                                this.show_hud("Opened in Finder".to_string(), Some(1500), cx);
+                                this.hide_main_and_reset(cx);
+                            }
+                            Err(message) => {
+                                this.show_hud(message, Some(2500), cx);
+                            }
+                        })
+                        .ok();
+                    })
+                    .detach();
                 } else {
                     self.show_hud(
                         "Cannot reveal this item type in Finder".to_string(),
@@ -884,8 +1002,23 @@
                     };
 
                     if let Some(path) = path_opt {
-                        self.edit_script(&path);
-                        self.hide_main_and_reset(cx);
+                        let editor_launch_rx = self.launch_editor_with_feedback_async(&path);
+                        cx.spawn(async move |this, cx| {
+                            let Ok(launch_result) = editor_launch_rx.recv().await else {
+                                return;
+                            };
+
+                            this.update(cx, |this, cx| match launch_result {
+                                Ok(()) => {
+                                    this.hide_main_and_reset(cx);
+                                }
+                                Err(message) => {
+                                    this.show_hud(message, Some(3000), cx);
+                                }
+                            })
+                            .ok();
+                        })
+                        .detach();
                     } else {
                         self.show_hud("Cannot edit this item type".to_string(), Some(2000), cx);
                     }
@@ -1932,8 +2065,23 @@
                             // Extract just the path without the anchor (e.g., "/path/to/file.md#slug" -> "/path/to/file.md")
                             let path_str = file_path.split('#').next().unwrap_or(file_path);
                             let path = std::path::PathBuf::from(path_str);
-                            self.edit_script(&path);
-                            self.hide_main_and_reset(cx);
+                            let editor_launch_rx = self.launch_editor_with_feedback_async(&path);
+                            cx.spawn(async move |this, cx| {
+                                let Ok(launch_result) = editor_launch_rx.recv().await else {
+                                    return;
+                                };
+
+                                this.update(cx, |this, cx| match launch_result {
+                                    Ok(()) => {
+                                        this.hide_main_and_reset(cx);
+                                    }
+                                    Err(message) => {
+                                        this.show_hud(message, Some(3000), cx);
+                                    }
+                                })
+                                .ok();
+                            })
+                            .detach();
                         } else {
                             self.show_hud(
                                 "Scriptlet has no source file path".to_string(),
@@ -1964,9 +2112,24 @@
                             // Extract just the path without the anchor
                             let path_str = file_path.split('#').next().unwrap_or(file_path);
                             let path = std::path::Path::new(path_str);
-                            self.reveal_in_finder(path);
-                            self.show_hud("Opened in Finder".to_string(), Some(1500), cx);
-                            self.hide_main_and_reset(cx);
+                            let reveal_result_rx = self.reveal_in_finder_with_feedback_async(path);
+                            cx.spawn(async move |this, cx| {
+                                let Ok(reveal_result) = reveal_result_rx.recv().await else {
+                                    return;
+                                };
+
+                                this.update(cx, |this, cx| match reveal_result {
+                                    Ok(()) => {
+                                        this.show_hud("Opened in Finder".to_string(), Some(1500), cx);
+                                        this.hide_main_and_reset(cx);
+                                    }
+                                    Err(message) => {
+                                        this.show_hud(message, Some(2500), cx);
+                                    }
+                                })
+                                .ok();
+                            })
+                            .detach();
                         } else {
                             self.show_hud(
                                 "Scriptlet has no source file path".to_string(),
diff --git a/src/app_actions/helpers.rs b/src/app_actions/helpers.rs
index fb50657be41d2650d4e4be37f320f8f2393149b1..b350404d02dd71610199202b59f4fd97d4f27b35
--- a/src/app_actions/helpers.rs
+++ b/src/app_actions/helpers.rs
@@ -172,6 +172,7 @@
     use crate::AppView;
     use crate::clipboard_history::{ClipboardEntryMeta, ContentType};
     use crate::scripts;
+    use std::fs;
     use std::path::PathBuf;
     use std::sync::Arc;
 
@@ -189,6 +190,14 @@
         }
     }
 
+    fn read(path: &str) -> String {
+        fs::read_to_string(path).unwrap_or_else(|_| panic!("Failed to read {path}"))
+    }
+
+    fn count_occurrences(haystack: &str, needle: &str) -> usize {
+        haystack.match_indices(needle).count()
+    }
+
     #[test]
     fn test_select_clipboard_entry_meta_filters_and_clamps() {
         let entries = vec![entry("1", "Alpha"), entry("2", "Beta"), entry("3", "Gamma")];
@@ -364,4 +373,58 @@
             })
         );
     }
+
+    #[test]
+    fn test_edit_actions_show_error_feedback_when_editor_launch_fails() {
+        let content = read("src/app_actions/handle_action.rs");
+
+        assert!(
+            content.contains("fn launch_editor_with_feedback_async"),
+            "Expected async editor launch helper to exist"
+        );
+
+        let usage_count =
+            count_occurrences(&content, "self.launch_editor_with_feedback_async(&path)");
+        assert!(
+            usage_count >= 2,
+            "Expected edit_script and edit_scriptlet to use async editor launch feedback (found {usage_count} usages)"
+        );
+
+        assert!(
+            content.contains("this.show_hud(message, Some(3000), cx);"),
+            "Expected async editor launch failure to surface a HUD error message"
+        );
+    }
+
+    #[test]
+    fn test_reveal_actions_show_success_hud_after_async_completion() {
+        let content = read("src/app_actions/handle_action.rs");
+
+        assert!(
+            content.contains("fn reveal_in_finder_with_feedback_async"),
+            "Expected async reveal helper to exist"
+        );
+
+        let usage_count = count_occurrences(
+            &content,
+            "self.reveal_in_finder_with_feedback_async(&path)",
+        ) + count_occurrences(
+            &content,
+            "self.reveal_in_finder_with_feedback_async(path)",
+        );
+        assert!(
+            usage_count >= 2,
+            "Expected reveal actions to use async reveal feedback helper (found {usage_count} usages)"
+        );
+
+        assert!(
+            content.contains("let Ok(reveal_result) = reveal_result_rx.recv().await else {"),
+            "Expected reveal actions to await reveal completion before showing HUD"
+        );
+
+        assert!(
+            content.contains("this.show_hud(\"Opened in Finder\".to_string(), Some(1500), cx);"),
+            "Expected reveal success HUD to be emitted from async completion callback"
+        );
+    }
 }
diff --git a/src/app_actions/tests/editor_launch_feedback.rs b/src/app_actions/tests/editor_launch_feedback.rs
deleted file mode 100644
index 18077766837c78518094e45c0da3b2a672b8bd8b..0000000000000000000000000000000000000000
--- a/src/app_actions/tests/editor_launch_feedback.rs
+++ /dev/null
@@ -1,62 +0,0 @@
-use std::fs;
-
-fn read(path: &str) -> String {
-    fs::read_to_string(path).unwrap_or_else(|_| panic!("Failed to read {path}"))
-}
-
-fn count_occurrences(haystack: &str, needle: &str) -> usize {
-    haystack.match_indices(needle).count()
-}
-
-#[test]
-fn test_edit_actions_show_error_feedback_when_editor_launch_fails() {
-    let content = read("src/app_actions/handle_action.rs");
-
-    assert!(
-        content.contains("fn launch_editor_with_feedback_async"),
-        "Expected async editor launch helper to exist"
-    );
-
-    let usage_count = count_occurrences(&content, "self.launch_editor_with_feedback_async(&path)");
-    assert!(
-        usage_count >= 2,
-        "Expected edit_script and edit_scriptlet to use async editor launch feedback (found {usage_count} usages)"
-    );
-
-    assert!(
-        content.contains("this.show_hud(message, Some(3000), cx);"),
-        "Expected async editor launch failure to surface a HUD error message"
-    );
-}
-
-#[test]
-fn test_reveal_actions_show_success_hud_after_async_reveal_completion() {
-    let content = read("src/app_actions/handle_action.rs");
-
-    assert!(
-        content.contains("fn reveal_in_finder_with_feedback_async"),
-        "Expected async reveal helper to exist"
-    );
-
-    let usage_count = count_occurrences(
-        &content,
-        "self.reveal_in_finder_with_feedback_async(&path)",
-    ) + count_occurrences(
-        &content,
-        "self.reveal_in_finder_with_feedback_async(path)",
-    );
-    assert!(
-        usage_count >= 2,
-        "Expected reveal actions to use async reveal feedback helper (found {usage_count} usages)"
-    );
-
-    assert!(
-        content.contains("let Ok(reveal_result) = reveal_result_rx.recv().await else {"),
-        "Expected reveal actions to await async reveal completion before showing HUD"
-    );
-
-    assert!(
-        content.contains("this.show_hud(\"Opened in Finder\".to_string(), Some(1500), cx);"),
-        "Expected reveal success HUD to be emitted from async completion callback"
-    );
-}


thinking
**Planning process completion poll**
file update:
diff --git a/src/app_actions/handle_action.rs b/src/app_actions/handle_action.rs
index 6512e920f98eb38811debb5dca005d821b3adb44..dda46dd268dc9fe3130c27b221485ba871f1c703
--- a/src/app_actions/handle_action.rs
+++ b/src/app_actions/handle_action.rs
@@ -32,6 +32,109 @@
         });
     }
 
+    /// Reveal a path and return completion back to the UI thread for HUD feedback.
+    fn reveal_in_finder_with_feedback_async(
+        &self,
+        path: &std::path::Path,
+    ) -> async_channel::Receiver<Result<(), String>> {
+        let path_str = path.to_string_lossy().to_string();
+        let (result_tx, result_rx) = async_channel::bounded::<Result<(), String>>(1);
+
+        std::thread::spawn(move || {
+            let file_manager = if cfg!(target_os = "macos") {
+                "Finder"
+            } else if cfg!(target_os = "windows") {
+                "Explorer"
+            } else {
+                "File Manager"
+            };
+
+            logging::log(
+                "UI",
+                &format!(
+                    "ACTION_REVEAL_IN_FINDER_START file_manager='{}' path='{}'",
+                    file_manager, path_str
+                ),
+            );
+
+            let reveal_result = match crate::file_search::reveal_in_finder(&path_str) {
+                Ok(()) => {
+                    logging::log(
+                        "UI",
+                        &format!(
+                            "ACTION_REVEAL_IN_FINDER_SUCCESS file_manager='{}' path='{}'",
+                            file_manager, path_str
+                        ),
+                    );
+                    Ok(())
+                }
+                Err(error) => {
+                    logging::log(
+                        "ERROR",
+                        &format!(
+                            "ACTION_REVEAL_IN_FINDER_FAILED attempted='reveal_in_finder' path='{}' file_manager='{}' error='{}'",
+                            path_str, file_manager, error
+                        ),
+                    );
+                    Err(format!("Failed to reveal in {}: {}", file_manager, error))
+                }
+            };
+
+            let _ = result_tx.send_blocking(reveal_result);
+        });
+
+        result_rx
+    }
+
+    /// Launch the configured editor and return completion back to the UI thread for HUD feedback.
+    fn launch_editor_with_feedback_async(
+        &self,
+        path: &std::path::Path,
+    ) -> async_channel::Receiver<Result<(), String>> {
+        let editor = self.config.get_editor();
+        let path_str = path.to_string_lossy().to_string();
+        let (result_tx, result_rx) = async_channel::bounded::<Result<(), String>>(1);
+
+        std::thread::spawn(move || {
+            use std::process::Command;
+
+            logging::log(
+                "UI",
+                &format!(
+                    "ACTION_EDITOR_LAUNCH_START editor='{}' path='{}'",
+                    editor, path_str
+                ),
+            );
+
+            let launch_result = match Command::new(&editor).arg(&path_str).spawn() {
+                Ok(_) => {
+                    logging::log(
+                        "UI",
+                        &format!(
+                            "ACTION_EDITOR_LAUNCH_SUCCESS editor='{}' path='{}'",
+                            editor, path_str
+                        ),
+                    );
+                    Ok(())
+                }
+                Err(error) => {
+                    logging::log(
+                        "ERROR",
+                        &format!(
+                            "ACTION_EDITOR_LAUNCH_FAILED attempted='{} {}' path='{}' error='{}'",
+                            editor, path_str, path_str, error
+                        ),
+                    );
+                    Err(format!("Failed to open in {}: {}", editor, error))
+                }
+            };
+
+            let _ = result_tx.send_blocking(launch_result);
+        });
+
+        result_rx
+    }
+
     /// Copy text to clipboard using pbcopy on macOS.
     /// Critical: This properly closes stdin before waiting to prevent hangs.
     #[cfg(target_os = "macos")]
@@ -471,9 +574,24 @@
                 };
 
                 if let Some(path) = path_opt {
-                    self.reveal_in_finder(&path);
-                    self.show_hud("Opened in Finder".to_string(), Some(1500), cx);
-                    self.hide_main_and_reset(cx);
+                    let reveal_result_rx = self.reveal_in_finder_with_feedback_async(&path);
+                    cx.spawn(async move |this, cx| {
+                        let Ok(reveal_result) = reveal_result_rx.recv().await else {
+                            return;
+                        };
+
+                        this.update(cx, |this, cx| match reveal_result {
+                            Ok(()) => {
+                                this.show_hud("Opened in Finder".to_string(), Some(1500), cx);
+                                this.hide_main_and_reset(cx);
+                            }
+                            Err(message) => {
+                                this.show_hud(message, Some(2500), cx);
+                            }
+                        })
+                        .ok();
+                    })
+                    .detach();
                 } else {
                     self.show_hud(
                         "Cannot reveal this item type in Finder".to_string(),
@@ -884,8 +1002,23 @@
                     };
 
                     if let Some(path) = path_opt {
-                        self.edit_script(&path);
-                        self.hide_main_and_reset(cx);
+                        let editor_launch_rx = self.launch_editor_with_feedback_async(&path);
+                        cx.spawn(async move |this, cx| {
+                            let Ok(launch_result) = editor_launch_rx.recv().await else {
+                                return;
+                            };
+
+                            this.update(cx, |this, cx| match launch_result {
+                                Ok(()) => {
+                                    this.hide_main_and_reset(cx);
+                                }
+                                Err(message) => {
+                                    this.show_hud(message, Some(3000), cx);
+                                }
+                            })
+                            .ok();
+                        })
+                        .detach();
                     } else {
                         self.show_hud("Cannot edit this item type".to_string(), Some(2000), cx);
                     }
@@ -1932,8 +2065,23 @@
                             // Extract just the path without the anchor (e.g., "/path/to/file.md#slug" -> "/path/to/file.md")
                             let path_str = file_path.split('#').next().unwrap_or(file_path);
                             let path = std::path::PathBuf::from(path_str);
-                            self.edit_script(&path);
-                            self.hide_main_and_reset(cx);
+                            let editor_launch_rx = self.launch_editor_with_feedback_async(&path);
+                            cx.spawn(async move |this, cx| {
+                                let Ok(launch_result) = editor_launch_rx.recv().await else {
+                                    return;
+                                };
+
+                                this.update(cx, |this, cx| match launch_result {
+                                    Ok(()) => {
+                                        this.hide_main_and_reset(cx);
+                                    }
+                                    Err(message) => {
+                                        this.show_hud(message, Some(3000), cx);
+                                    }
+                                })
+                                .ok();
+                            })
+                            .detach();
                         } else {
                             self.show_hud(
                                 "Scriptlet has no source file path".to_string(),
@@ -1964,9 +2112,24 @@
                             // Extract just the path without the anchor
                             let path_str = file_path.split('#').next().unwrap_or(file_path);
                             let path = std::path::Path::new(path_str);
-                            self.reveal_in_finder(path);
-                            self.show_hud("Opened in Finder".to_string(), Some(1500), cx);
-                            self.hide_main_and_reset(cx);
+                            let reveal_result_rx = self.reveal_in_finder_with_feedback_async(path);
+                            cx.spawn(async move |this, cx| {
+                                let Ok(reveal_result) = reveal_result_rx.recv().await else {
+                                    return;
+                                };
+
+                                this.update(cx, |this, cx| match reveal_result {
+                                    Ok(()) => {
+                                        this.show_hud("Opened in Finder".to_string(), Some(1500), cx);
+                                        this.hide_main_and_reset(cx);
+                                    }
+                                    Err(message) => {
+                                        this.show_hud(message, Some(2500), cx);
+                                    }
+                                })
+                                .ok();
+                            })
+                            .detach();
                         } else {
                             self.show_hud(
                                 "Scriptlet has no source file path".to_string(),
diff --git a/src/app_actions/helpers.rs b/src/app_actions/helpers.rs
index fb50657be41d2650d4e4be37f320f8f2393149b1..b350404d02dd71610199202b59f4fd97d4f27b35
--- a/src/app_actions/helpers.rs
+++ b/src/app_actions/helpers.rs
@@ -172,6 +172,7 @@
     use crate::AppView;
     use crate::clipboard_history::{ClipboardEntryMeta, ContentType};
     use crate::scripts;
+    use std::fs;
     use std::path::PathBuf;
     use std::sync::Arc;
 
@@ -189,6 +190,14 @@
         }
     }
 
+    fn read(path: &str) -> String {
+        fs::read_to_string(path).unwrap_or_else(|_| panic!("Failed to read {path}"))
+    }
+
+    fn count_occurrences(haystack: &str, needle: &str) -> usize {
+        haystack.match_indices(needle).count()
+    }
+
     #[test]
     fn test_select_clipboard_entry_meta_filters_and_clamps() {
         let entries = vec![entry("1", "Alpha"), entry("2", "Beta"), entry("3", "Gamma")];
@@ -364,4 +373,58 @@
             })
         );
     }
+
+    #[test]
+    fn test_edit_actions_show_error_feedback_when_editor_launch_fails() {
+        let content = read("src/app_actions/handle_action.rs");
+
+        assert!(
+            content.contains("fn launch_editor_with_feedback_async"),
+            "Expected async editor launch helper to exist"
+        );
+
+        let usage_count =
+            count_occurrences(&content, "self.launch_editor_with_feedback_async(&path)");
+        assert!(
+            usage_count >= 2,
+            "Expected edit_script and edit_scriptlet to use async editor launch feedback (found {usage_count} usages)"
+        );
+
+        assert!(
+            content.contains("this.show_hud(message, Some(3000), cx);"),
+            "Expected async editor launch failure to surface a HUD error message"
+        );
+    }
+
+    #[test]
+    fn test_reveal_actions_show_success_hud_after_async_completion() {
+        let content = read("src/app_actions/handle_action.rs");
+
+        assert!(
+            content.contains("fn reveal_in_finder_with_feedback_async"),
+            "Expected async reveal helper to exist"
+        );
+
+        let usage_count = count_occurrences(
+            &content,
+            "self.reveal_in_finder_with_feedback_async(&path)",
+        ) + count_occurrences(
+            &content,
+            "self.reveal_in_finder_with_feedback_async(path)",
+        );
+        assert!(
+            usage_count >= 2,
+            "Expected reveal actions to use async reveal feedback helper (found {usage_count} usages)"
+        );
+
+        assert!(
+            content.contains("let Ok(reveal_result) = reveal_result_rx.recv().await else {"),
+            "Expected reveal actions to await reveal completion before showing HUD"
+        );
+
+        assert!(
+            content.contains("this.show_hud(\"Opened in Finder\".to_string(), Some(1500), cx);"),
+            "Expected reveal success HUD to be emitted from async completion callback"
+        );
+    }
 }
diff --git a/src/app_actions/tests/editor_launch_feedback.rs b/src/app_actions/tests/editor_launch_feedback.rs
deleted file mode 100644
index 18077766837c78518094e45c0da3b2a672b8bd8b..0000000000000000000000000000000000000000
--- a/src/app_actions/tests/editor_launch_feedback.rs
+++ /dev/null
@@ -1,62 +0,0 @@
-use std::fs;
-
-fn read(path: &str) -> String {
-    fs::read_to_string(path).unwrap_or_else(|_| panic!("Failed to read {path}"))
-}
-
-fn count_occurrences(haystack: &str, needle: &str) -> usize {
-    haystack.match_indices(needle).count()
-}
-
-#[test]
-fn test_edit_actions_show_error_feedback_when_editor_launch_fails() {
-    let content = read("src/app_actions/handle_action.rs");
-
-    assert!(
-        content.contains("fn launch_editor_with_feedback_async"),
-        "Expected async editor launch helper to exist"
-    );
-
-    let usage_count = count_occurrences(&content, "self.launch_editor_with_feedback_async(&path)");
-    assert!(
-        usage_count >= 2,
-        "Expected edit_script and edit_scriptlet to use async editor launch feedback (found {usage_count} usages)"
-    );
-
-    assert!(
-        content.contains("this.show_hud(message, Some(3000), cx);"),
-        "Expected async editor launch failure to surface a HUD error message"
-    );
-}
-
-#[test]
-fn test_reveal_actions_show_success_hud_after_async_reveal_completion() {
-    let content = read("src/app_actions/handle_action.rs");
-
-    assert!(
-        content.contains("fn reveal_in_finder_with_feedback_async"),
-        "Expected async reveal helper to exist"
-    );
-
-    let usage_count = count_occurrences(
-        &content,
-        "self.reveal_in_finder_with_feedback_async(&path)",
-    ) + count_occurrences(
-        &content,
-        "self.reveal_in_finder_with_feedback_async(path)",
-    );
-    assert!(
-        usage_count >= 2,
-        "Expected reveal actions to use async reveal feedback helper (found {usage_count} usages)"
-    );
-
-    assert!(
-        content.contains("let Ok(reveal_result) = reveal_result_rx.recv().await else {"),
-        "Expected reveal actions to await async reveal completion before showing HUD"
-    );
-
-    assert!(
-        content.contains("this.show_hud(\"Opened in Finder\".to_string(), Some(1500), cx);"),
-        "Expected reveal success HUD to be emitted from async completion callback"
-    );
-}


thinking
**Adding exit code poll**
file update:
diff --git a/src/app_actions/handle_action.rs b/src/app_actions/handle_action.rs
index 6512e920f98eb38811debb5dca005d821b3adb44..dda46dd268dc9fe3130c27b221485ba871f1c703
--- a/src/app_actions/handle_action.rs
+++ b/src/app_actions/handle_action.rs
@@ -32,6 +32,109 @@
         });
     }
 
+    /// Reveal a path and return completion back to the UI thread for HUD feedback.
+    fn reveal_in_finder_with_feedback_async(
+        &self,
+        path: &std::path::Path,
+    ) -> async_channel::Receiver<Result<(), String>> {
+        let path_str = path.to_string_lossy().to_string();
+        let (result_tx, result_rx) = async_channel::bounded::<Result<(), String>>(1);
+
+        std::thread::spawn(move || {
+            let file_manager = if cfg!(target_os = "macos") {
+                "Finder"
+            } else if cfg!(target_os = "windows") {
+                "Explorer"
+            } else {
+                "File Manager"
+            };
+
+            logging::log(
+                "UI",
+                &format!(
+                    "ACTION_REVEAL_IN_FINDER_START file_manager='{}' path='{}'",
+                    file_manager, path_str
+                ),
+            );
+
+            let reveal_result = match crate::file_search::reveal_in_finder(&path_str) {
+                Ok(()) => {
+                    logging::log(
+                        "UI",
+                        &format!(
+                            "ACTION_REVEAL_IN_FINDER_SUCCESS file_manager='{}' path='{}'",
+                            file_manager, path_str
+                        ),
+                    );
+                    Ok(())
+                }
+                Err(error) => {
+                    logging::log(
+                        "ERROR",
+                        &format!(
+                            "ACTION_REVEAL_IN_FINDER_FAILED attempted='reveal_in_finder' path='{}' file_manager='{}' error='{}'",
+                            path_str, file_manager, error
+                        ),
+                    );
+                    Err(format!("Failed to reveal in {}: {}", file_manager, error))
+                }
+            };
+
+            let _ = result_tx.send_blocking(reveal_result);
+        });
+
+        result_rx
+    }
+
+    /// Launch the configured editor and return completion back to the UI thread for HUD feedback.
+    fn launch_editor_with_feedback_async(
+        &self,
+        path: &std::path::Path,
+    ) -> async_channel::Receiver<Result<(), String>> {
+        let editor = self.config.get_editor();
+        let path_str = path.to_string_lossy().to_string();
+        let (result_tx, result_rx) = async_channel::bounded::<Result<(), String>>(1);
+
+        std::thread::spawn(move || {
+            use std::process::Command;
+
+            logging::log(
+                "UI",
+                &format!(
+                    "ACTION_EDITOR_LAUNCH_START editor='{}' path='{}'",
+                    editor, path_str
+                ),
+            );
+
+            let launch_result = match Command::new(&editor).arg(&path_str).spawn() {
+                Ok(_) => {
+                    logging::log(
+                        "UI",
+                        &format!(
+                            "ACTION_EDITOR_LAUNCH_SUCCESS editor='{}' path='{}'",
+                            editor, path_str
+                        ),
+                    );
+                    Ok(())
+                }
+                Err(error) => {
+                    logging::log(
+                        "ERROR",
+                        &format!(
+                            "ACTION_EDITOR_LAUNCH_FAILED attempted='{} {}' path='{}' error='{}'",
+                            editor, path_str, path_str, error
+                        ),
+                    );
+                    Err(format!("Failed to open in {}: {}", editor, error))
+                }
+            };
+
+            let _ = result_tx.send_blocking(launch_result);
+        });
+
+        result_rx
+    }
+
     /// Copy text to clipboard using pbcopy on macOS.
     /// Critical: This properly closes stdin before waiting to prevent hangs.
     #[cfg(target_os = "macos")]
@@ -471,9 +574,24 @@
                 };
 
                 if let Some(path) = path_opt {
-                    self.reveal_in_finder(&path);
-                    self.show_hud("Opened in Finder".to_string(), Some(1500), cx);
-                    self.hide_main_and_reset(cx);
+                    let reveal_result_rx = self.reveal_in_finder_with_feedback_async(&path);
+                    cx.spawn(async move |this, cx| {
+                        let Ok(reveal_result) = reveal_result_rx.recv().await else {
+                            return;
+                        };
+
+                        this.update(cx, |this, cx| match reveal_result {
+                            Ok(()) => {
+                                this.show_hud("Opened in Finder".to_string(), Some(1500), cx);
+                                this.hide_main_and_reset(cx);
+                            }
+                            Err(message) => {
+                                this.show_hud(message, Some(2500), cx);
+                            }
+                        })
+                        .ok();
+                    })
+                    .detach();
                 } else {
                     self.show_hud(
                         "Cannot reveal this item type in Finder".to_string(),
@@ -884,8 +1002,23 @@
                     };
 
                     if let Some(path) = path_opt {
-                        self.edit_script(&path);
-                        self.hide_main_and_reset(cx);
+                        let editor_launch_rx = self.launch_editor_with_feedback_async(&path);
+                        cx.spawn(async move |this, cx| {
+                            let Ok(launch_result) = editor_launch_rx.recv().await else {
+                                return;
+                            };
+
+                            this.update(cx, |this, cx| match launch_result {
+                                Ok(()) => {
+                                    this.hide_main_and_reset(cx);
+                                }
+                                Err(message) => {
+                                    this.show_hud(message, Some(3000), cx);
+                                }
+                            })
+                            .ok();
+                        })
+                        .detach();
                     } else {
                         self.show_hud("Cannot edit this item type".to_string(), Some(2000), cx);
                     }
@@ -1932,8 +2065,23 @@
                             // Extract just the path without the anchor (e.g., "/path/to/file.md#slug" -> "/path/to/file.md")
                             let path_str = file_path.split('#').next().unwrap_or(file_path);
                             let path = std::path::PathBuf::from(path_str);
-                            self.edit_script(&path);
-                            self.hide_main_and_reset(cx);
+                            let editor_launch_rx = self.launch_editor_with_feedback_async(&path);
+                            cx.spawn(async move |this, cx| {
+                                let Ok(launch_result) = editor_launch_rx.recv().await else {
+                                    return;
+                                };
+
+                                this.update(cx, |this, cx| match launch_result {
+                                    Ok(()) => {
+                                        this.hide_main_and_reset(cx);
+                                    }
+                                    Err(message) => {
+                                        this.show_hud(message, Some(3000), cx);
+                                    }
+                                })
+                                .ok();
+                            })
+                            .detach();
                         } else {
                             self.show_hud(
                                 "Scriptlet has no source file path".to_string(),
@@ -1964,9 +2112,24 @@
                             // Extract just the path without the anchor
                             let path_str = file_path.split('#').next().unwrap_or(file_path);
                             let path = std::path::Path::new(path_str);
-                            self.reveal_in_finder(path);
-                            self.show_hud("Opened in Finder".to_string(), Some(1500), cx);
-                            self.hide_main_and_reset(cx);
+                            let reveal_result_rx = self.reveal_in_finder_with_feedback_async(path);
+                            cx.spawn(async move |this, cx| {
+                                let Ok(reveal_result) = reveal_result_rx.recv().await else {
+                                    return;
+                                };
+
+                                this.update(cx, |this, cx| match reveal_result {
+                                    Ok(()) => {
+                                        this.show_hud("Opened in Finder".to_string(), Some(1500), cx);
+                                        this.hide_main_and_reset(cx);
+                                    }
+                                    Err(message) => {
+                                        this.show_hud(message, Some(2500), cx);
+                                    }
+                                })
+                                .ok();
+                            })
+                            .detach();
                         } else {
                             self.show_hud(
                                 "Scriptlet has no source file path".to_string(),
diff --git a/src/app_actions/helpers.rs b/src/app_actions/helpers.rs
index fb50657be41d2650d4e4be37f320f8f2393149b1..b350404d02dd71610199202b59f4fd97d4f27b35
--- a/src/app_actions/helpers.rs
+++ b/src/app_actions/helpers.rs
@@ -172,6 +172,7 @@
     use crate::AppView;
     use crate::clipboard_history::{ClipboardEntryMeta, ContentType};
     use crate::scripts;
+    use std::fs;
     use std::path::PathBuf;
     use std::sync::Arc;
 
@@ -189,6 +190,14 @@
         }
     }
 
+    fn read(path: &str) -> String {
+        fs::read_to_string(path).unwrap_or_else(|_| panic!("Failed to read {path}"))
+    }
+
+    fn count_occurrences(haystack: &str, needle: &str) -> usize {
+        haystack.match_indices(needle).count()
+    }
+
     #[test]
     fn test_select_clipboard_entry_meta_filters_and_clamps() {
         let entries = vec![entry("1", "Alpha"), entry("2", "Beta"), entry("3", "Gamma")];
@@ -364,4 +373,58 @@
             })
         );
     }
+
+    #[test]
+    fn test_edit_actions_show_error_feedback_when_editor_launch_fails() {
+        let content = read("src/app_actions/handle_action.rs");
+
+        assert!(
+            content.contains("fn launch_editor_with_feedback_async"),
+            "Expected async editor launch helper to exist"
+        );
+
+        let usage_count =
+            count_occurrences(&content, "self.launch_editor_with_feedback_async(&path)");
+        assert!(
+            usage_count >= 2,
+            "Expected edit_script and edit_scriptlet to use async editor launch feedback (found {usage_count} usages)"
+        );
+
+        assert!(
+            content.contains("this.show_hud(message, Some(3000), cx);"),
+            "Expected async editor launch failure to surface a HUD error message"
+        );
+    }
+
+    #[test]
+    fn test_reveal_actions_show_success_hud_after_async_completion() {
+        let content = read("src/app_actions/handle_action.rs");
+
+        assert!(
+            content.contains("fn reveal_in_finder_with_feedback_async"),
+            "Expected async reveal helper to exist"
+        );
+
+        let usage_count = count_occurrences(
+            &content,
+            "self.reveal_in_finder_with_feedback_async(&path)",
+        ) + count_occurrences(
+            &content,
+            "self.reveal_in_finder_with_feedback_async(path)",
+        );
+        assert!(
+            usage_count >= 2,
+            "Expected reveal actions to use async reveal feedback helper (found {usage_count} usages)"
+        );
+
+        assert!(
+            content.contains("let Ok(reveal_result) = reveal_result_rx.recv().await else {"),
+            "Expected reveal actions to await reveal completion before showing HUD"
+        );
+
+        assert!(
+            content.contains("this.show_hud(\"Opened in Finder\".to_string(), Some(1500), cx);"),
+            "Expected reveal success HUD to be emitted from async completion callback"
+        );
+    }
 }
diff --git a/src/app_actions/tests/editor_launch_feedback.rs b/src/app_actions/tests/editor_launch_feedback.rs
deleted file mode 100644
index 18077766837c78518094e45c0da3b2a672b8bd8b..0000000000000000000000000000000000000000
--- a/src/app_actions/tests/editor_launch_feedback.rs
+++ /dev/null
@@ -1,62 +0,0 @@
-use std::fs;
-
-fn read(path: &str) -> String {
-    fs::read_to_string(path).unwrap_or_else(|_| panic!("Failed to read {path}"))
-}
-
-fn count_occurrences(haystack: &str, needle: &str) -> usize {
-    haystack.match_indices(needle).count()
-}
-
-#[test]
-fn test_edit_actions_show_error_feedback_when_editor_launch_fails() {
-    let content = read("src/app_actions/handle_action.rs");
-
-    assert!(
-        content.contains("fn launch_editor_with_feedback_async"),
-        "Expected async editor launch helper to exist"
-    );
-
-    let usage_count = count_occurrences(&content, "self.launch_editor_with_feedback_async(&path)");
-    assert!(
-        usage_count >= 2,
-        "Expected edit_script and edit_scriptlet to use async editor launch feedback (found {usage_count} usages)"
-    );
-
-    assert!(
-        content.contains("this.show_hud(message, Some(3000), cx);"),
-        "Expected async editor launch failure to surface a HUD error message"
-    );
-}
-
-#[test]
-fn test_reveal_actions_show_success_hud_after_async_reveal_completion() {
-    let content = read("src/app_actions/handle_action.rs");
-
-    assert!(
-        content.contains("fn reveal_in_finder_with_feedback_async"),
-        "Expected async reveal helper to exist"
-    );
-
-    let usage_count = count_occurrences(
-        &content,
-        "self.reveal_in_finder_with_feedback_async(&path)",
-    ) + count_occurrences(
-        &content,
-        "self.reveal_in_finder_with_feedback_async(path)",
-    );
-    assert!(
-        usage_count >= 2,
-        "Expected reveal actions to use async reveal feedback helper (found {usage_count} usages)"
-    );
-
-    assert!(
-        content.contains("let Ok(reveal_result) = reveal_result_rx.recv().await else {"),
-        "Expected reveal actions to await async reveal completion before showing HUD"
-    );
-
-    assert!(
-        content.contains("this.show_hud(\"Opened in Finder\".to_string(), Some(1500), cx);"),
-        "Expected reveal success HUD to be emitted from async completion callback"
-    );
-}

 exited 101 in 23.65s:
    Blocking waiting for file lock on build directory
   Compiling script-kit-gpui v0.1.0 (/Users/johnlindquist/dev/script-kit-gpui)
error[E0761]: file for module `tests` found at both "src/protocol/message/tests.rs" and "src/protocol/message/tests/mod.rs"
  --> src/protocol/message/mod.rs:87:1
   |
87 | mod tests;
   | ^^^^^^^^^^
   |
   = help: delete or rename one of them to remove the ambiguity

error[E0761]: file for module `tests` found at both "src/designs/core/tests.rs" and "src/designs/core/tests/mod.rs"
 --> src/designs/core/part_04.rs:2:1
  |
2 | mod tests;
  | ^^^^^^^^^^
  |
  = help: delete or rename one of them to remove the ambiguity

error: glob import doesn't reexport anything with visibility `pub(in crate::prompts)` because no imported item is public enough
  --> src/prompts/div/mod.rs:32:16
file update:
diff --git a/src/app_actions/handle_action.rs b/src/app_actions/handle_action.rs
index 6512e920f98eb38811debb5dca005d821b3adb44..dda46dd268dc9fe3130c27b221485ba871f1c703
--- a/src/app_actions/handle_action.rs
+++ b/src/app_actions/handle_action.rs
@@ -32,6 +32,109 @@
         });
     }
 
+    /// Reveal a path and return completion back to the UI thread for HUD feedback.
+    fn reveal_in_finder_with_feedback_async(
+        &self,
+        path: &std::path::Path,
+    ) -> async_channel::Receiver<Result<(), String>> {
+        let path_str = path.to_string_lossy().to_string();
+        let (result_tx, result_rx) = async_channel::bounded::<Result<(), String>>(1);
+
+        std::thread::spawn(move || {
+            let file_manager = if cfg!(target_os = "macos") {
+                "Finder"
+            } else if cfg!(target_os = "windows") {
+                "Explorer"
+            } else {
+                "File Manager"
+            };
+
+            logging::log(
+                "UI",
+                &format!(
+                    "ACTION_REVEAL_IN_FINDER_START file_manager='{}' path='{}'",
+                    file_manager, path_str
+                ),
+            );
+
+            let reveal_result = match crate::file_search::reveal_in_finder(&path_str) {
+                Ok(()) => {
+                    logging::log(
+                        "UI",
+                        &format!(
+                            "ACTION_REVEAL_IN_FINDER_SUCCESS file_manager='{}' path='{}'",
+                            file_manager, path_str
+                        ),
+                    );
+                    Ok(())
+                }
+                Err(error) => {
+                    logging::log(
+                        "ERROR",
+                        &format!(
+                            "ACTION_REVEAL_IN_FINDER_FAILED attempted='reveal_in_finder' path='{}' file_manager='{}' error='{}'",
+                            path_str, file_manager, error
+                        ),
+                    );
+                    Err(format!("Failed to reveal in {}: {}", file_manager, error))
+                }
+            };
+
+            let _ = result_tx.send_blocking(reveal_result);
+        });
+
+        result_rx
+    }
+
+    /// Launch the configured editor and return completion back to the UI thread for HUD feedback.
+    fn launch_editor_with_feedback_async(
+        &self,
+        path: &std::path::Path,
+    ) -> async_channel::Receiver<Result<(), String>> {
+        let editor = self.config.get_editor();
+        let path_str = path.to_string_lossy().to_string();
+        let (result_tx, result_rx) = async_channel::bounded::<Result<(), String>>(1);
+
+        std::thread::spawn(move || {
+            use std::process::Command;
+
+            logging::log(
+                "UI",
+                &format!(
+                    "ACTION_EDITOR_LAUNCH_START editor='{}' path='{}'",
+                    editor, path_str
+                ),
+            );
+
+            let launch_result = match Command::new(&editor).arg(&path_str).spawn() {
+                Ok(_) => {
+                    logging::log(
+                        "UI",
+                        &format!(
+                            "ACTION_EDITOR_LAUNCH_SUCCESS editor='{}' path='{}'",
+                            editor, path_str
+                        ),
+                    );
+                    Ok(())
+                }
+                Err(error) => {
+                    logging::log(
+                        "ERROR",
+                        &format!(
+                            "ACTION_EDITOR_LAUNCH_FAILED attempted='{} {}' path='{}' error='{}'",
+                            editor, path_str, path_str, error
+                        ),
+                    );
+                    Err(format!("Failed to open in {}: {}", editor, error))
+                }
+            };
+
+            let _ = result_tx.send_blocking(launch_result);
+        });
+
+        result_rx
+    }
+
     /// Copy text to clipboard using pbcopy on macOS.
     /// Critical: This properly closes stdin before waiting to prevent hangs.
     #[cfg(target_os = "macos")]
@@ -471,9 +574,24 @@
                 };
 
                 if let Some(path) = path_opt {
-                    self.reveal_in_finder(&path);
-                    self.show_hud("Opened in Finder".to_string(), Some(1500), cx);
-                    self.hide_main_and_reset(cx);
+                    let reveal_result_rx = self.reveal_in_finder_with_feedback_async(&path);
+                    cx.spawn(async move |this, cx| {
+                        let Ok(reveal_result) = reveal_result_rx.recv().await else {
+                            return;
+                        };
+
+                        this.update(cx, |this, cx| match reveal_result {
+                            Ok(()) => {
+                                this.show_hud("Opened in Finder".to_string(), Some(1500), cx);
+                                this.hide_main_and_reset(cx);
+                            }
+                            Err(message) => {
+                                this.show_hud(message, Some(2500), cx);
+                            }
+                        })
+                        .ok();
+                    })
+                    .detach();
                 } else {
                     self.show_hud(
                         "Cannot reveal this item type in Finder".to_string(),
@@ -884,8 +1002,23 @@
                     };
 
                     if let Some(path) = path_opt {
-                        self.edit_script(&path);
-                        self.hide_main_and_reset(cx);
+                        let editor_launch_rx = self.launch_editor_with_feedback_async(&path);
+                        cx.spawn(async move |this, cx| {
+                            let Ok(launch_result) = editor_launch_rx.recv().await else {
+                                return;
+                            };
+
+                            this.update(cx, |this, cx| match launch_result {
+                                Ok(()) => {
+                                    this.hide_main_and_reset(cx);
+                                }
+                                Err(message) => {
+                                    this.show_hud(message, Some(3000), cx);
+                                }
+                            })
+                            .ok();
+                        })
+                        .detach();
                     } else {
                         self.show_hud("Cannot edit this item type".to_string(), Some(2000), cx);
                     }
@@ -1932,8 +2065,23 @@
                             // Extract just the path without the anchor (e.g., "/path/to/file.md#slug" -> "/path/to/file.md")
                             let path_str = file_path.split('#').next().unwrap_or(file_path);
                             let path = std::path::PathBuf::from(path_str);
-                            self.edit_script(&path);
-                            self.hide_main_and_reset(cx);
+                            let editor_launch_rx = self.launch_editor_with_feedback_async(&path);
+                            cx.spawn(async move |this, cx| {
+                                let Ok(launch_result) = editor_launch_rx.recv().await else {
+                                    return;
+                                };
+
+                                this.update(cx, |this, cx| match launch_result {
+                                    Ok(()) => {
+                                        this.hide_main_and_reset(cx);
+                                    }
+                                    Err(message) => {
+                                        this.show_hud(message, Some(3000), cx);
+                                    }
+                                })
+                                .ok();
+                            })
+                            .detach();
                         } else {
                             self.show_hud(
                                 "Scriptlet has no source file path".to_string(),
@@ -1964,9 +2112,24 @@
                             // Extract just the path without the anchor
                             let path_str = file_path.split('#').next().unwrap_or(file_path);
                             let path = std::path::Path::new(path_str);
-                            self.reveal_in_finder(path);
-                            self.show_hud("Opened in Finder".to_string(), Some(1500), cx);
-                            self.hide_main_and_reset(cx);
+                            let reveal_result_rx = self.reveal_in_finder_with_feedback_async(path);
+                            cx.spawn(async move |this, cx| {
+                                let Ok(reveal_result) = reveal_result_rx.recv().await else {
+                                    return;
+                                };
+
+                                this.update(cx, |this, cx| match reveal_result {
+                                    Ok(()) => {
+                                        this.show_hud("Opened in Finder".to_string(), Some(1500), cx);
+                                        this.hide_main_and_reset(cx);
+                                    }
+                                    Err(message) => {
+                                        this.show_hud(message, Some(2500), cx);
+                                    }
+                                })
+                                .ok();
+                            })
+                            .detach();
                         } else {
                             self.show_hud(
                                 "Scriptlet has no source file path".to_string(),
diff --git a/src/app_actions/helpers.rs b/src/app_actions/helpers.rs
index fb50657be41d2650d4e4be37f320f8f2393149b1..b350404d02dd71610199202b59f4fd97d4f27b35
--- a/src/app_actions/helpers.rs
+++ b/src/app_actions/helpers.rs
@@ -172,6 +172,7 @@
     use crate::AppView;
     use crate::clipboard_history::{ClipboardEntryMeta, ContentType};
     use crate::scripts;
+    use std::fs;
     use std::path::PathBuf;
     use std::sync::Arc;
 
@@ -189,6 +190,14 @@
         }
     }
 
+    fn read(path: &str) -> String {
+        fs::read_to_string(path).unwrap_or_else(|_| panic!("Failed to read {path}"))
+    }
+
+    fn count_occurrences(haystack: &str, needle: &str) -> usize {
+        haystack.match_indices(needle).count()
+    }
+
     #[test]
     fn test_select_clipboard_entry_meta_filters_and_clamps() {
         let entries = vec![entry("1", "Alpha"), entry("2", "Beta"), entry("3", "Gamma")];
@@ -364,4 +373,58 @@
             })
         );
     }
+
+    #[test]
+    fn test_edit_actions_show_error_feedback_when_editor_launch_fails() {
+        let content = read("src/app_actions/handle_action.rs");
+
+        assert!(
+            content.contains("fn launch_editor_with_feedback_async"),
+            "Expected async editor launch helper to exist"
+        );
+
+        let usage_count =
+            count_occurrences(&content, "self.launch_editor_with_feedback_async(&path)");
+        assert!(
+            usage_count >= 2,
+            "Expected edit_script and edit_scriptlet to use async editor launch feedback (found {usage_count} usages)"
+        );
+
+        assert!(
+            content.contains("this.show_hud(message, Some(3000), cx);"),
+            "Expected async editor launch failure to surface a HUD error message"
+        );
+    }
+
+    #[test]
+    fn test_reveal_actions_show_success_hud_after_async_completion() {
+        let content = read("src/app_actions/handle_action.rs");
+
+        assert!(
+            content.contains("fn reveal_in_finder_with_feedback_async"),
+            "Expected async reveal helper to exist"
+        );
+
+        let usage_count = count_occurrences(
+            &content,
+            "self.reveal_in_finder_with_feedback_async(&path)",
+        ) + count_occurrences(
+            &content,
+            "self.reveal_in_finder_with_feedback_async(path)",
+        );
+        assert!(
+            usage_count >= 2,
+            "Expected reveal actions to use async reveal feedback helper (found {usage_count} usages)"
+        );
+
+        assert!(
+            content.contains("let Ok(reveal_result) = reveal_result_rx.recv().await else {"),
+            "Expected reveal actions to await reveal completion before showing HUD"
+        );
+
+        assert!(
+            content.contains("this.show_hud(\"Opened in Finder\".to_string(), Some(1500), cx);"),
+            "Expected reveal success HUD to be emitted from async completion callback"
+        );
+    }
 }
diff --git a/src/app_actions/tests/editor_launch_feedback.rs b/src/app_actions/tests/editor_launch_feedback.rs
deleted file mode 100644
index 18077766837c78518094e45c0da3b2a672b8bd8b..0000000000000000000000000000000000000000
--- a/src/app_actions/tests/editor_launch_feedback.rs
+++ /dev/null
@@ -1,62 +0,0 @@
-use std::fs;
-
-fn read(path: &str) -> String {
-    fs::read_to_string(path).unwrap_or_else(|_| panic!("Failed to read {path}"))
-}
-
-fn count_occurrences(haystack: &str, needle: &str) -> usize {
-    haystack.match_indices(needle).count()
-}
-
-#[test]
-fn test_edit_actions_show_error_feedback_when_editor_launch_fails() {
-    let content = read("src/app_actions/handle_action.rs");
-
-    assert!(
-        content.contains("fn launch_editor_with_feedback_async"),
-        "Expected async editor launch helper to exist"
-    );
-
-    let usage_count = count_occurrences(&content, "self.launch_editor_with_feedback_async(&path)");
-    assert!(
-        usage_count >= 2,
-        "Expected edit_script and edit_scriptlet to use async editor launch feedback (found {usage_count} usages)"
-    );
-
-    assert!(
-        content.contains("this.show_hud(message, Some(3000), cx);"),
-        "Expected async editor launch failure to surface a HUD error message"
-    );
-}
-
-#[test]
-fn test_reveal_actions_show_success_hud_after_async_reveal_completion() {
-    let content = read("src/app_actions/handle_action.rs");
-
-    assert!(
-        content.contains("fn reveal_in_finder_with_feedback_async"),
-        "Expected async reveal helper to exist"
-    );
-
-    let usage_count = count_occurrences(
-        &content,
-        "self.reveal_in_finder_with_feedback_async(&path)",
-    ) + count_occurrences(
-        &content,
-        "self.reveal_in_finder_with_feedback_async(path)",
-    );
-    assert!(
-        usage_count >= 2,
-        "Expected reveal actions to use async reveal feedback helper (found {usage_count} usages)"
-    );
-
-    assert!(
-        content.contains("let Ok(reveal_result) = reveal_result_rx.recv().await else {"),
-        "Expected reveal actions to await async reveal completion before showing HUD"
-    );
-
-    assert!(
-        content.contains("this.show_hud(\"Opened in Finder\".to_string(), Some(1500), cx);"),
-        "Expected reveal success HUD to be emitted from async completion callback"
-    );
-}


thinking
**Running syntax check with formatter**
exec
/bin/zsh -lc 'rustfmt src/app_actions/handle_action.rs src/app_actions/helpers.rs' in /Users/johnlindquist/dev/script-kit-gpui exited 1 in 51ms:
error: `async move` blocks are only allowed in Rust 2018 or later
   --> /Users/johnlindquist/dev/script-kit-gpui/src/app_actions/handle_action.rs:374:34
    |
374 |                         cx.spawn(async move |_this, _cx| {
    |                                  ^^^^^-^^^^
    |                                       |
    |                                       help: missing `,`

error: `async move` blocks are only allowed in Rust 2018 or later
   --> /Users/johnlindquist/dev/script-kit-gpui/src/app_actions/handle_action.rs:489:34
    |
489 |                         cx.spawn(async move |_this, _cx| {
    |                                  ^^^^^-^^^^
    |                                       |
    |                                       help: missing `,`

error: `async move` blocks are only allowed in Rust 2018 or later
   --> /Users/johnlindquist/dev/script-kit-gpui/src/app_actions/handle_action.rs:578:30
    |
578 |                     cx.spawn(async move |this, cx| {
file update:
diff --git a/src/app_actions/handle_action.rs b/src/app_actions/handle_action.rs
index 6512e920f98eb38811debb5dca005d821b3adb44..dda46dd268dc9fe3130c27b221485ba871f1c703
--- a/src/app_actions/handle_action.rs
+++ b/src/app_actions/handle_action.rs
@@ -32,6 +32,109 @@
         });
     }
 
+    /// Reveal a path and return completion back to the UI thread for HUD feedback.
+    fn reveal_in_finder_with_feedback_async(
+        &self,
+        path: &std::path::Path,
+    ) -> async_channel::Receiver<Result<(), String>> {
+        let path_str = path.to_string_lossy().to_string();
+        let (result_tx, result_rx) = async_channel::bounded::<Result<(), String>>(1);
+
+        std::thread::spawn(move || {
+            let file_manager = if cfg!(target_os = "macos") {
+                "Finder"
+            } else if cfg!(target_os = "windows") {
+                "Explorer"
+            } else {
+                "File Manager"
+            };
+
+            logging::log(
+                "UI",
+                &format!(
+                    "ACTION_REVEAL_IN_FINDER_START file_manager='{}' path='{}'",
+                    file_manager, path_str
+                ),
+            );
+
+            let reveal_result = match crate::file_search::reveal_in_finder(&path_str) {
+                Ok(()) => {
+                    logging::log(
+                        "UI",
+                        &format!(
+                            "ACTION_REVEAL_IN_FINDER_SUCCESS file_manager='{}' path='{}'",
+                            file_manager, path_str
+                        ),
+                    );
+                    Ok(())
+                }
+                Err(error) => {
+                    logging::log(
+                        "ERROR",
+                        &format!(
+                            "ACTION_REVEAL_IN_FINDER_FAILED attempted='reveal_in_finder' path='{}' file_manager='{}' error='{}'",
+                            path_str, file_manager, error
+                        ),
+                    );
+                    Err(format!("Failed to reveal in {}: {}", file_manager, error))
+                }
+            };
+
+            let _ = result_tx.send_blocking(reveal_result);
+        });
+
+        result_rx
+    }
+
+    /// Launch the configured editor and return completion back to the UI thread for HUD feedback.
+    fn launch_editor_with_feedback_async(
+        &self,
+        path: &std::path::Path,
+    ) -> async_channel::Receiver<Result<(), String>> {
+        let editor = self.config.get_editor();
+        let path_str = path.to_string_lossy().to_string();
+        let (result_tx, result_rx) = async_channel::bounded::<Result<(), String>>(1);
+
+        std::thread::spawn(move || {
+            use std::process::Command;
+
+            logging::log(
+                "UI",
+                &format!(
+                    "ACTION_EDITOR_LAUNCH_START editor='{}' path='{}'",
+                    editor, path_str
+                ),
+            );
+
+            let launch_result = match Command::new(&editor).arg(&path_str).spawn() {
+                Ok(_) => {
+                    logging::log(
+                        "UI",
+                        &format!(
+                            "ACTION_EDITOR_LAUNCH_SUCCESS editor='{}' path='{}'",
+                            editor, path_str
+                        ),
+                    );
+                    Ok(())
+                }
+                Err(error) => {
+                    logging::log(
+                        "ERROR",
+                        &format!(
+                            "ACTION_EDITOR_LAUNCH_FAILED attempted='{} {}' path='{}' error='{}'",
+                            editor, path_str, path_str, error
+                        ),
+                    );
+                    Err(format!("Failed to open in {}: {}", editor, error))
+                }
+            };
+
+            let _ = result_tx.send_blocking(launch_result);
+        });
+
+        result_rx
+    }
+
     /// Copy text to clipboard using pbcopy on macOS.
     /// Critical: This properly closes stdin before waiting to prevent hangs.
     #[cfg(target_os = "macos")]
@@ -471,9 +574,24 @@
                 };
 
                 if let Some(path) = path_opt {
-                    self.reveal_in_finder(&path);
-                    self.show_hud("Opened in Finder".to_string(), Some(1500), cx);
-                    self.hide_main_and_reset(cx);
+                    let reveal_result_rx = self.reveal_in_finder_with_feedback_async(&path);
+                    cx.spawn(async move |this, cx| {
+                        let Ok(reveal_result) = reveal_result_rx.recv().await else {
+                            return;
+                        };
+
+                        this.update(cx, |this, cx| match reveal_result {
+                            Ok(()) => {
+                                this.show_hud("Opened in Finder".to_string(), Some(1500), cx);
+                                this.hide_main_and_reset(cx);
+                            }
+                            Err(message) => {
+                                this.show_hud(message, Some(2500), cx);
+                            }
+                        })
+                        .ok();
+                    })
+                    .detach();
                 } else {
                     self.show_hud(
                         "Cannot reveal this item type in Finder".to_string(),
@@ -884,8 +1002,23 @@
                     };
 
                     if let Some(path) = path_opt {
-                        self.edit_script(&path);
-                        self.hide_main_and_reset(cx);
+                        let editor_launch_rx = self.launch_editor_with_feedback_async(&path);
+                        cx.spawn(async move |this, cx| {
+                            let Ok(launch_result) = editor_launch_rx.recv().await else {
+                                return;
+                            };
+
+                            this.update(cx, |this, cx| match launch_result {
+                                Ok(()) => {
+                                    this.hide_main_and_reset(cx);
+                                }
+                                Err(message) => {
+                                    this.show_hud(message, Some(3000), cx);
+                                }
+                            })
+                            .ok();
+                        })
+                        .detach();
                     } else {
                         self.show_hud("Cannot edit this item type".to_string(), Some(2000), cx);
                     }
@@ -1932,8 +2065,23 @@
                             // Extract just the path without the anchor (e.g., "/path/to/file.md#slug" -> "/path/to/file.md")
                             let path_str = file_path.split('#').next().unwrap_or(file_path);
                             let path = std::path::PathBuf::from(path_str);
-                            self.edit_script(&path);
-                            self.hide_main_and_reset(cx);
+                            let editor_launch_rx = self.launch_editor_with_feedback_async(&path);
+                            cx.spawn(async move |this, cx| {
+                                let Ok(launch_result) = editor_launch_rx.recv().await else {
+                                    return;
+                                };
+
+                                this.update(cx, |this, cx| match launch_result {
+                                    Ok(()) => {
+                                        this.hide_main_and_reset(cx);
+                                    }
+                                    Err(message) => {
+                                        this.show_hud(message, Some(3000), cx);
+                                    }
+                                })
+                                .ok();
+                            })
+                            .detach();
                         } else {
                             self.show_hud(
                                 "Scriptlet has no source file path".to_string(),
@@ -1964,9 +2112,24 @@
                             // Extract just the path without the anchor
                             let path_str = file_path.split('#').next().unwrap_or(file_path);
                             let path = std::path::Path::new(path_str);
-                            self.reveal_in_finder(path);
-                            self.show_hud("Opened in Finder".to_string(), Some(1500), cx);
-                            self.hide_main_and_reset(cx);
+                            let reveal_result_rx = self.reveal_in_finder_with_feedback_async(path);
+                            cx.spawn(async move |this, cx| {
+                                let Ok(reveal_result) = reveal_result_rx.recv().await else {
+                                    return;
+                                };
+
+                                this.update(cx, |this, cx| match reveal_result {
+                                    Ok(()) => {
+                                        this.show_hud("Opened in Finder".to_string(), Some(1500), cx);
+                                        this.hide_main_and_reset(cx);
+                                    }
+                                    Err(message) => {
+                                        this.show_hud(message, Some(2500), cx);
+                                    }
+                                })
+                                .ok();
+                            })
+                            .detach();
                         } else {
                             self.show_hud(
                                 "Scriptlet has no source file path".to_string(),
diff --git a/src/app_actions/helpers.rs b/src/app_actions/helpers.rs
index fb50657be41d2650d4e4be37f320f8f2393149b1..d1ffdb92db3025e5830d2f16c0f3b05af0ff26c7
--- a/src/app_actions/helpers.rs
+++ b/src/app_actions/helpers.rs
@@ -166,12 +166,14 @@
     use super::{
         clipboard_pin_action_success_hud, extract_scriptlet_source_path,
         file_search_action_error_hud_prefix, file_search_action_success_hud,
+        script_removal_target_from_result, select_clipboard_entry_meta,
         selection_required_message_for_action, should_transition_to_script_list_after_action,
-        script_removal_target_from_result, select_clipboard_entry_meta, ScriptRemovalTarget,
+        ScriptRemovalTarget,
     };
-    use crate::AppView;
     use crate::clipboard_history::{ClipboardEntryMeta, ContentType};
     use crate::scripts;
+    use crate::AppView;
+    use std::fs;
     use std::path::PathBuf;
     use std::sync::Arc;
 
@@ -189,6 +191,14 @@
         }
     }
 
+    fn read(path: &str) -> String {
+        fs::read_to_string(path).unwrap_or_else(|_| panic!("Failed to read {path}"))
+    }
+
+    fn count_occurrences(haystack: &str, needle: &str) -> usize {
+        haystack.match_indices(needle).count()
+    }
+
     #[test]
     fn test_select_clipboard_entry_meta_filters_and_clamps() {
         let entries = vec![entry("1", "Alpha"), entry("2", "Beta"), entry("3", "Gamma")];
@@ -364,4 +374,54 @@
             })
         );
     }
+
+    #[test]
+    fn test_edit_actions_show_error_feedback_when_editor_launch_fails() {
+        let content = read("src/app_actions/handle_action.rs");
+
+        assert!(
+            content.contains("fn launch_editor_with_feedback_async"),
+            "Expected async editor launch helper to exist"
+        );
+
+        let usage_count =
+            count_occurrences(&content, "self.launch_editor_with_feedback_async(&path)");
+        assert!(
+            usage_count >= 2,
+            "Expected edit_script and edit_scriptlet to use async editor launch feedback (found {usage_count} usages)"
+        );
+
+        assert!(
+            content.contains("this.show_hud(message, Some(3000), cx);"),
+            "Expected async editor launch failure to surface a HUD error message"
+        );
+    }
+
+    #[test]
+    fn test_reveal_actions_show_success_hud_after_async_completion() {
+        let content = read("src/app_actions/handle_action.rs");
+
+        assert!(
+            content.contains("fn reveal_in_finder_with_feedback_async"),
+            "Expected async reveal helper to exist"
+        );
+
+        let usage_count =
+            count_occurrences(&content, "self.reveal_in_finder_with_feedback_async(&path)")
+                + count_occurrences(&content, "self.reveal_in_finder_with_feedback_async(path)");
+        assert!(
+            usage_count >= 2,
+            "Expected reveal actions to use async reveal feedback helper (found {usage_count} usages)"
+        );
+
+        assert!(
+            content.contains("let Ok(reveal_result) = reveal_result_rx.recv().await else {"),
+            "Expected reveal actions to await reveal completion before showing HUD"
+        );
+
+        assert!(
+            content.contains("this.show_hud(\"Opened in Finder\".to_string(), Some(1500), cx);"),
+            "Expected reveal success HUD to be emitted from async completion callback"
+        );
+    }
 }
diff --git a/src/app_actions/tests/editor_launch_feedback.rs b/src/app_actions/tests/editor_launch_feedback.rs
deleted file mode 100644
index 18077766837c78518094e45c0da3b2a672b8bd8b..0000000000000000000000000000000000000000
--- a/src/app_actions/tests/editor_launch_feedback.rs
+++ /dev/null
@@ -1,62 +0,0 @@
-use std::fs;
-
-fn read(path: &str) -> String {
-    fs::read_to_string(path).unwrap_or_else(|_| panic!("Failed to read {path}"))
-}
-
-fn count_occurrences(haystack: &str, needle: &str) -> usize {
-    haystack.match_indices(needle).count()
-}
-
-#[test]
-fn test_edit_actions_show_error_feedback_when_editor_launch_fails() {
-    let content = read("src/app_actions/handle_action.rs");
-
-    assert!(
-        content.contains("fn launch_editor_with_feedback_async"),
-        "Expected async editor launch helper to exist"
-    );
-
-    let usage_count = count_occurrences(&content, "self.launch_editor_with_feedback_async(&path)");
-    assert!(
-        usage_count >= 2,
-        "Expected edit_script and edit_scriptlet to use async editor launch feedback (found {usage_count} usages)"
-    );
-
-    assert!(
-        content.contains("this.show_hud(message, Some(3000), cx);"),
-        "Expected async editor launch failure to surface a HUD error message"
-    );
-}
-
-#[test]
-fn test_reveal_actions_show_success_hud_after_async_reveal_completion() {
-    let content = read("src/app_actions/handle_action.rs");
-
-    assert!(
-        content.contains("fn reveal_in_finder_with_feedback_async"),
-        "Expected async reveal helper to exist"
-    );
-
-    let usage_count = count_occurrences(
-        &content,
-        "self.reveal_in_finder_with_feedback_async(&path)",
-    ) + count_occurrences(
-        &content,
-        "self.reveal_in_finder_with_feedback_async(path)",
-    );
-    assert!(
-        usage_count >= 2,
-        "Expected reveal actions to use async reveal feedback helper (found {usage_count} usages)"
-    );
-
-    assert!(
-        content.contains("let Ok(reveal_result) = reveal_result_rx.recv().await else {"),
-        "Expected reveal actions to await async reveal completion before showing HUD"
-    );
-
-    assert!(
-        content.contains("this.show_hud(\"Opened in Finder\".to_string(), Some(1500), cx);"),
-        "Expected reveal success HUD to be emitted from async completion callback"
-    );
-}


thinking
**Adjusting rustfmt for edition**
exec
/bin/zsh -lc 'rustfmt --edition 2021 src/app_actions/handle_action.rs src/app_actions/helpers.rs' in /Users/johnlindquist/dev/script-kit-gpui succeeded in 52ms:

file update:
diff --git a/src/app_actions/handle_action.rs b/src/app_actions/handle_action.rs
index 6512e920f98eb38811debb5dca005d821b3adb44..a20dbbb8eae9367457a1e25e044924f8664e8dce
--- a/src/app_actions/handle_action.rs
+++ b/src/app_actions/handle_action.rs
@@ -27,11 +27,117 @@
 
             match crate::file_search::reveal_in_finder(&path_str) {
                 Ok(_) => logging::log("UI", &format!("Revealed in {}: {}", file_manager, path_str)),
-                Err(e) => logging::log("ERROR", &format!("Failed to reveal in {}: {}", file_manager, e)),
+                Err(e) => logging::log(
+                    "ERROR",
+                    &format!("Failed to reveal in {}: {}", file_manager, e),
+                ),
             }
         });
     }
 
+    /// Reveal a path and return completion back to the UI thread for HUD feedback.
+    fn reveal_in_finder_with_feedback_async(
+        &self,
+        path: &std::path::Path,
+    ) -> async_channel::Receiver<Result<(), String>> {
+        let path_str = path.to_string_lossy().to_string();
+        let (result_tx, result_rx) = async_channel::bounded::<Result<(), String>>(1);
+
+        std::thread::spawn(move || {
+            let file_manager = if cfg!(target_os = "macos") {
+                "Finder"
+            } else if cfg!(target_os = "windows") {
+                "Explorer"
+            } else {
+                "File Manager"
+            };
+
+            logging::log(
+                "UI",
+                &format!(
+                    "ACTION_REVEAL_IN_FINDER_START file_manager='{}' path='{}'",
+                    file_manager, path_str
+                ),
+            );
+
+            let reveal_result = match crate::file_search::reveal_in_finder(&path_str) {
+                Ok(()) => {
+                    logging::log(
+                        "UI",
+                        &format!(
+                            "ACTION_REVEAL_IN_FINDER_SUCCESS file_manager='{}' path='{}'",
+                            file_manager, path_str
+                        ),
+                    );
+                    Ok(())
+                }
+                Err(error) => {
+                    logging::log(
+                        "ERROR",
+                        &format!(
+                            "ACTION_REVEAL_IN_FINDER_FAILED attempted='reveal_in_finder' path='{}' file_manager='{}' error='{}'",
+                            path_str, file_manager, error
+                        ),
+                    );
+                    Err(format!("Failed to reveal in {}: {}", file_manager, error))
+                }
+            };
+
+            let _ = result_tx.send_blocking(reveal_result);
+        });
+
+        result_rx
+    }
+
+    /// Launch the configured editor and return completion back to the UI thread for HUD feedback.
+    fn launch_editor_with_feedback_async(
+        &self,
+        path: &std::path::Path,
+    ) -> async_channel::Receiver<Result<(), String>> {
+        let editor = self.config.get_editor();
+        let path_str = path.to_string_lossy().to_string();
+        let (result_tx, result_rx) = async_channel::bounded::<Result<(), String>>(1);
+
+        std::thread::spawn(move || {
+            use std::process::Command;
+
+            logging::log(
+                "UI",
+                &format!(
+                    "ACTION_EDITOR_LAUNCH_START editor='{}' path='{}'",
+                    editor, path_str
+                ),
+            );
+
+            let launch_result = match Command::new(&editor).arg(&path_str).spawn() {
+                Ok(_) => {
+                    logging::log(
+                        "UI",
+                        &format!(
+                            "ACTION_EDITOR_LAUNCH_SUCCESS editor='{}' path='{}'",
+                            editor, path_str
+                        ),
+                    );
+                    Ok(())
+                }
+                Err(error) => {
+                    logging::log(
+                        "ERROR",
+                        &format!(
+                            "ACTION_EDITOR_LAUNCH_FAILED attempted='{} {}' path='{}' error='{}'",
+                            editor, path_str, path_str, error
+                        ),
+                    );
+                    Err(format!("Failed to open in {}: {}", editor, error))
+                }
+            };
+
+            let _ = result_tx.send_blocking(launch_result);
+        });
+
+        result_rx
+    }
+
     /// Copy text to clipboard using pbcopy on macOS.
     /// Critical: This properly closes stdin before waiting to prevent hangs.
     #[cfg(target_os = "macos")]
@@ -471,9 +577,24 @@
                 };
 
                 if let Some(path) = path_opt {
-                    self.reveal_in_finder(&path);
-                    self.show_hud("Opened in Finder".to_string(), Some(1500), cx);
-                    self.hide_main_and_reset(cx);
+                    let reveal_result_rx = self.reveal_in_finder_with_feedback_async(&path);
+                    cx.spawn(async move |this, cx| {
+                        let Ok(reveal_result) = reveal_result_rx.recv().await else {
+                            return;
+                        };
+
+                        this.update(cx, |this, cx| match reveal_result {
+                            Ok(()) => {
+                                this.show_hud("Opened in Finder".to_string(), Some(1500), cx);
+                                this.hide_main_and_reset(cx);
+                            }
+                            Err(message) => {
+                                this.show_hud(message, Some(2500), cx);
+                            }
+                        })
+                        .ok();
+                    })
+                    .detach();
                 } else {
                     self.show_hud(
                         "Cannot reveal this item type in Finder".to_string(),
@@ -754,7 +875,6 @@
                 }
             }
             // Alias actions: add_alias, update_alias open the alias input
-
             "add_alias" | "update_alias" => {
                 logging::log("UI", &format!("{} action", action_id));
                 if let Some(result) = self.get_selected_result() {
@@ -884,8 +1004,23 @@
                     };
 
                     if let Some(path) = path_opt {
-                        self.edit_script(&path);
-                        self.hide_main_and_reset(cx);
+                        let editor_launch_rx = self.launch_editor_with_feedback_async(&path);
+                        cx.spawn(async move |this, cx| {
+                            let Ok(launch_result) = editor_launch_rx.recv().await else {
+                                return;
+                            };
+
+                            this.update(cx, |this, cx| match launch_result {
+                                Ok(()) => {
+                                    this.hide_main_and_reset(cx);
+                                }
+                                Err(message) => {
+                                    this.show_hud(message, Some(3000), cx);
+                                }
+                            })
+                            .ok();
+                        })
+                        .detach();
                     } else {
                         self.show_hud("Cannot edit this item type".to_string(), Some(2000), cx);
                     }
@@ -1096,7 +1231,6 @@
                 self.file_search_actions_path = None;
             }
             // File search specific actions
-
             "open_file" | "open_directory" | "quick_look" | "open_with" | "show_info" => {
                 if let Some(path) = self.file_search_actions_path.clone() {
                     logging::log("UI", &format!("File action '{}': {}", action_id, path));
@@ -1424,7 +1558,6 @@
                 }
             }
             // Clipboard delete actions
-
             "clipboard_delete_multiple" => {
                 let filter_text = match &self.current_view {
                     AppView::ClipboardHistoryView { filter, .. } => filter.trim().to_string(),
@@ -1932,8 +2065,23 @@
                             // Extract just the path without the anchor (e.g., "/path/to/file.md#slug" -> "/path/to/file.md")
                             let path_str = file_path.split('#').next().unwrap_or(file_path);
                             let path = std::path::PathBuf::from(path_str);
-                            self.edit_script(&path);
-                            self.hide_main_and_reset(cx);
+                            let editor_launch_rx = self.launch_editor_with_feedback_async(&path);
+                            cx.spawn(async move |this, cx| {
+                                let Ok(launch_result) = editor_launch_rx.recv().await else {
+                                    return;
+                                };
+
+                                this.update(cx, |this, cx| match launch_result {
+                                    Ok(()) => {
+                                        this.hide_main_and_reset(cx);
+                                    }
+                                    Err(message) => {
+                                        this.show_hud(message, Some(3000), cx);
+                                    }
+                                })
+                                .ok();
+                            })
+                            .detach();
                         } else {
                             self.show_hud(
                                 "Scriptlet has no source file path".to_string(),
@@ -1964,9 +2112,28 @@
                             // Extract just the path without the anchor
                             let path_str = file_path.split('#').next().unwrap_or(file_path);
                             let path = std::path::Path::new(path_str);
-                            self.reveal_in_finder(path);
-                            self.show_hud("Opened in Finder".to_string(), Some(1500), cx);
-                            self.hide_main_and_reset(cx);
+                            let reveal_result_rx = self.reveal_in_finder_with_feedback_async(path);
+                            cx.spawn(async move |this, cx| {
+                                let Ok(reveal_result) = reveal_result_rx.recv().await else {
+                                    return;
+                                };
+
+                                this.update(cx, |this, cx| match reveal_result {
+                                    Ok(()) => {
+                                        this.show_hud(
+                                            "Opened in Finder".to_string(),
+                                            Some(1500),
+                                            cx,
+                                        );
+                                        this.hide_main_and_reset(cx);
+                                    }
+                                    Err(message) => {
+                                        this.show_hud(message, Some(2500), cx);
+                                    }
+                                })
+                                .ok();
+                            })
+                            .detach();
                         } else {
                             self.show_hud(
                                 "Scriptlet has no source file path".to_string(),
diff --git a/src/app_actions/helpers.rs b/src/app_actions/helpers.rs
index fb50657be41d2650d4e4be37f320f8f2393149b1..d1ffdb92db3025e5830d2f16c0f3b05af0ff26c7
--- a/src/app_actions/helpers.rs
+++ b/src/app_actions/helpers.rs
@@ -166,12 +166,14 @@
     use super::{
         clipboard_pin_action_success_hud, extract_scriptlet_source_path,
         file_search_action_error_hud_prefix, file_search_action_success_hud,
+        script_removal_target_from_result, select_clipboard_entry_meta,
         selection_required_message_for_action, should_transition_to_script_list_after_action,
-        script_removal_target_from_result, select_clipboard_entry_meta, ScriptRemovalTarget,
+        ScriptRemovalTarget,
     };
-    use crate::AppView;
     use crate::clipboard_history::{ClipboardEntryMeta, ContentType};
     use crate::scripts;
+    use crate::AppView;
+    use std::fs;
     use std::path::PathBuf;
     use std::sync::Arc;
 
@@ -189,6 +191,14 @@
         }
     }
 
+    fn read(path: &str) -> String {
+        fs::read_to_string(path).unwrap_or_else(|_| panic!("Failed to read {path}"))
+    }
+
+    fn count_occurrences(haystack: &str, needle: &str) -> usize {
+        haystack.match_indices(needle).count()
+    }
+
     #[test]
     fn test_select_clipboard_entry_meta_filters_and_clamps() {
         let entries = vec![entry("1", "Alpha"), entry("2", "Beta"), entry("3", "Gamma")];
@@ -364,4 +374,54 @@
             })
         );
     }
+
+    #[test]
+    fn test_edit_actions_show_error_feedback_when_editor_launch_fails() {
+        let content = read("src/app_actions/handle_action.rs");
+
+        assert!(
+            content.contains("fn launch_editor_with_feedback_async"),
+            "Expected async editor launch helper to exist"
+        );
+
+        let usage_count =
+            count_occurrences(&content, "self.launch_editor_with_feedback_async(&path)");
+        assert!(
+            usage_count >= 2,
+            "Expected edit_script and edit_scriptlet to use async editor launch feedback (found {usage_count} usages)"
+        );
+
+        assert!(
+            content.contains("this.show_hud(message, Some(3000), cx);"),
+            "Expected async editor launch failure to surface a HUD error message"
+        );
+    }
+
+    #[test]
+    fn test_reveal_actions_show_success_hud_after_async_completion() {
+        let content = read("src/app_actions/handle_action.rs");
+
+        assert!(
+            content.contains("fn reveal_in_finder_with_feedback_async"),
+            "Expected async reveal helper to exist"
+        );
+
+        let usage_count =
+            count_occurrences(&content, "self.reveal_in_finder_with_feedback_async(&path)")
+                + count_occurrences(&content, "self.reveal_in_finder_with_feedback_async(path)");
+        assert!(
+            usage_count >= 2,
+            "Expected reveal actions to use async reveal feedback helper (found {usage_count} usages)"
+        );
+
+        assert!(
+            content.contains("let Ok(reveal_result) = reveal_result_rx.recv().await else {"),
+            "Expected reveal actions to await reveal completion before showing HUD"
+        );
+
+        assert!(
+            content.contains("this.show_hud(\"Opened in Finder\".to_string(), Some(1500), cx);"),
+            "Expected reveal success HUD to be emitted from async completion callback"
+        );
+    }
 }
diff --git a/src/app_actions/tests/editor_launch_feedback.rs b/src/app_actions/tests/editor_launch_feedback.rs
deleted file mode 100644
index 18077766837c78518094e45c0da3b2a672b8bd8b..0000000000000000000000000000000000000000
--- a/src/app_actions/tests/editor_launch_feedback.rs
+++ /dev/null
@@ -1,62 +0,0 @@
-use std::fs;
-
-fn read(path: &str) -> String {
-    fs::read_to_string(path).unwrap_or_else(|_| panic!("Failed to read {path}"))
-}
-
-fn count_occurrences(haystack: &str, needle: &str) -> usize {
-    haystack.match_indices(needle).count()
-}
-
-#[test]
-fn test_edit_actions_show_error_feedback_when_editor_launch_fails() {
-    let content = read("src/app_actions/handle_action.rs");
-
-    assert!(
-        content.contains("fn launch_editor_with_feedback_async"),
-        "Expected async editor launch helper to exist"
-    );
-
-    let usage_count = count_occurrences(&content, "self.launch_editor_with_feedback_async(&path)");
-    assert!(
-        usage_count >= 2,
-        "Expected edit_script and edit_scriptlet to use async editor launch feedback (found {usage_count} usages)"
-    );
-
-    assert!(
-        content.contains("this.show_hud(message, Some(3000), cx);"),
-        "Expected async editor launch failure to surface a HUD error message"
-    );
-}
-
-#[test]
-fn test_reveal_actions_show_success_hud_after_async_reveal_completion() {
-    let content = read("src/app_actions/handle_action.rs");
-
-    assert!(
-        content.contains("fn reveal_in_finder_with_feedback_async"),
-        "Expected async reveal helper to exist"
-    );
-
-    let usage_count = count_occurrences(
-        &content,
-        "self.reveal_in_finder_with_feedback_async(&path)",
-    ) + count_occurrences(
-        &content,
-        "self.reveal_in_finder_with_feedback_async(path)",
-    );
-    assert!(
-        usage_count >= 2,
-        "Expected reveal actions to use async reveal feedback helper (found {usage_count} usages)"
-    );
-
-    assert!(
-        content.contains("let Ok(reveal_result) = reveal_result_rx.recv().await else {"),
-        "Expected reveal actions to await async reveal completion before showing HUD"
-    );
-
-    assert!(
-        content.contains("this.show_hud(\"Opened in Finder\".to_string(), Some(1500), cx);"),
-        "Expected reveal success HUD to be emitted from async completion callback"
-    );
-}


thinking
**Verifying post-format compile**
exec
/bin/zsh -lc "nl -ba src/app_actions/handle_action.rs | sed -n '1,150p' && nl -ba src/app_actions/handle_action.rs | sed -n '550,625p' && nl -ba src/app_actions/handle_action.rs | sed -n '994,1035p' && nl -ba src/app_actions/handle_action.rs | sed -n '2058,2145p' && nl -ba src/app_actions/helpers.rs | sed -n '160,430p'" in /Users/johnlindquist/dev/script-kit-gpui succeeded in 50ms:
     1	impl ScriptListApp {
     2	    fn hide_main_and_reset(&self, _cx: &mut Context<Self>) {
     3	        if let Some((x, y, w, h)) = platform::get_main_window_bounds() {
     4	            let bounds = crate::window_state::PersistedWindowBounds::new(x, y, w, h);
     5	            let displays = platform::get_macos_displays();
     6	            let _ =
     7	                crate::window_state::save_main_position_with_display_detection(bounds, &displays);
     8	        }
     9	        set_main_window_visible(false);
    10	        NEEDS_RESET.store(true, Ordering::SeqCst);
    11	        // Use platform-specific hide that only hides the main window,
    12	        // not the entire app (cx.hide() would hide HUD too)
    13	        platform::hide_main_window();
    14	    }
    15	
    16	    /// Helper to reveal a path in Finder (macOS)
    17	    fn reveal_in_finder(&self, path: &std::path::Path) {
    18	        let path_str = path.to_string_lossy().to_string();
    19	        std::thread::spawn(move || {
    20	            let file_manager = if cfg!(target_os = "macos") {
file update:
diff --git a/src/app_actions/handle_action.rs b/src/app_actions/handle_action.rs
index 6512e920f98eb38811debb5dca005d821b3adb44..a20dbbb8eae9367457a1e25e044924f8664e8dce
--- a/src/app_actions/handle_action.rs
+++ b/src/app_actions/handle_action.rs
@@ -27,11 +27,117 @@
 
             match crate::file_search::reveal_in_finder(&path_str) {
                 Ok(_) => logging::log("UI", &format!("Revealed in {}: {}", file_manager, path_str)),
-                Err(e) => logging::log("ERROR", &format!("Failed to reveal in {}: {}", file_manager, e)),
+                Err(e) => logging::log(
+                    "ERROR",
+                    &format!("Failed to reveal in {}: {}", file_manager, e),
+                ),
             }
         });
     }
 
+    /// Reveal a path and return completion back to the UI thread for HUD feedback.
+    fn reveal_in_finder_with_feedback_async(
+        &self,
+        path: &std::path::Path,
+    ) -> async_channel::Receiver<Result<(), String>> {
+        let path_str = path.to_string_lossy().to_string();
+        let (result_tx, result_rx) = async_channel::bounded::<Result<(), String>>(1);
+
+        std::thread::spawn(move || {
+            let file_manager = if cfg!(target_os = "macos") {
+                "Finder"
+            } else if cfg!(target_os = "windows") {
+                "Explorer"
+            } else {
+                "File Manager"
+            };
+
+            logging::log(
+                "UI",
+                &format!(
+                    "ACTION_REVEAL_IN_FINDER_START file_manager='{}' path='{}'",
+                    file_manager, path_str
+                ),
+            );
+
+            let reveal_result = match crate::file_search::reveal_in_finder(&path_str) {
+                Ok(()) => {
+                    logging::log(
+                        "UI",
+                        &format!(
+                            "ACTION_REVEAL_IN_FINDER_SUCCESS file_manager='{}' path='{}'",
+                            file_manager, path_str
+                        ),
+                    );
+                    Ok(())
+                }
+                Err(error) => {
+                    logging::log(
+                        "ERROR",
+                        &format!(
+                            "ACTION_REVEAL_IN_FINDER_FAILED attempted='reveal_in_finder' path='{}' file_manager='{}' error='{}'",
+                            path_str, file_manager, error
+                        ),
+                    );
+                    Err(format!("Failed to reveal in {}: {}", file_manager, error))
+                }
+            };
+
+            let _ = result_tx.send_blocking(reveal_result);
+        });
+
+        result_rx
+    }
+
+    /// Launch the configured editor and return completion back to the UI thread for HUD feedback.
+    fn launch_editor_with_feedback_async(
+        &self,
+        path: &std::path::Path,
+    ) -> async_channel::Receiver<Result<(), String>> {
+        let editor = self.config.get_editor();
+        let path_str = path.to_string_lossy().to_string();
+        let (result_tx, result_rx) = async_channel::bounded::<Result<(), String>>(1);
+
+        std::thread::spawn(move || {
+            use std::process::Command;
+
+            logging::log(
+                "UI",
+                &format!(
+                    "ACTION_EDITOR_LAUNCH_START editor='{}' path='{}'",
+                    editor, path_str
+                ),
+            );
+
+            let launch_result = match Command::new(&editor).arg(&path_str).spawn() {
+                Ok(_) => {
+                    logging::log(
+                        "UI",
+                        &format!(
+                            "ACTION_EDITOR_LAUNCH_SUCCESS editor='{}' path='{}'",
+                            editor, path_str
+                        ),
+                    );
+                    Ok(())
+                }
+                Err(error) => {
+                    logging::log(
+                        "ERROR",
+                        &format!(
+                            "ACTION_EDITOR_LAUNCH_FAILED attempted='{} {}' path='{}' error='{}'",
+                            editor, path_str, path_str, error
+                        ),
+                    );
+                    Err(format!("Failed to open in {}: {}", editor, error))
+                }
+            };
+
+            let _ = result_tx.send_blocking(launch_result);
+        });
+
+        result_rx
+    }
+
     /// Copy text to clipboard using pbcopy on macOS.
     /// Critical: This properly closes stdin before waiting to prevent hangs.
     #[cfg(target_os = "macos")]
@@ -471,9 +577,24 @@
                 };
 
                 if let Some(path) = path_opt {
-                    self.reveal_in_finder(&path);
-                    self.show_hud("Opened in Finder".to_string(), Some(1500), cx);
-                    self.hide_main_and_reset(cx);
+                    let reveal_result_rx = self.reveal_in_finder_with_feedback_async(&path);
+                    cx.spawn(async move |this, cx| {
+                        let Ok(reveal_result) = reveal_result_rx.recv().await else {
+                            return;
+                        };
+
+                        this.update(cx, |this, cx| match reveal_result {
+                            Ok(()) => {
+                                this.show_hud("Opened in Finder".to_string(), Some(1500), cx);
+                                this.hide_main_and_reset(cx);
+                            }
+                            Err(message) => {
+                                this.show_hud(message, Some(2500), cx);
+                            }
+                        })
+                        .ok();
+                    })
+                    .detach();
                 } else {
                     self.show_hud(
                         "Cannot reveal this item type in Finder".to_string(),
@@ -754,7 +875,6 @@
                 }
             }
             // Alias actions: add_alias, update_alias open the alias input
-
             "add_alias" | "update_alias" => {
                 logging::log("UI", &format!("{} action", action_id));
                 if let Some(result) = self.get_selected_result() {
@@ -884,8 +1004,23 @@
                     };
 
                     if let Some(path) = path_opt {
-                        self.edit_script(&path);
-                        self.hide_main_and_reset(cx);
+                        let editor_launch_rx = self.launch_editor_with_feedback_async(&path);
+                        cx.spawn(async move |this, cx| {
+                            let Ok(launch_result) = editor_launch_rx.recv().await else {
+                                return;
+                            };
+
+                            this.update(cx, |this, cx| match launch_result {
+                                Ok(()) => {
+                                    this.hide_main_and_reset(cx);
+                                }
+                                Err(message) => {
+                                    this.show_hud(message, Some(3000), cx);
+                                }
+                            })
+                            .ok();
+                        })
+                        .detach();
                     } else {
                         self.show_hud("Cannot edit this item type".to_string(), Some(2000), cx);
                     }
@@ -1096,7 +1231,6 @@
                 self.file_search_actions_path = None;
             }
             // File search specific actions
-
             "open_file" | "open_directory" | "quick_look" | "open_with" | "show_info" => {
                 if let Some(path) = self.file_search_actions_path.clone() {
                     logging::log("UI", &format!("File action '{}': {}", action_id, path));
@@ -1424,7 +1558,6 @@
                 }
             }
             // Clipboard delete actions
-
             "clipboard_delete_multiple" => {
                 let filter_text = match &self.current_view {
                     AppView::ClipboardHistoryView { filter, .. } => filter.trim().to_string(),
@@ -1932,8 +2065,23 @@
                             // Extract just the path without the anchor (e.g., "/path/to/file.md#slug" -> "/path/to/file.md")
                             let path_str = file_path.split('#').next().unwrap_or(file_path);
                             let path = std::path::PathBuf::from(path_str);
-                            self.edit_script(&path);
-                            self.hide_main_and_reset(cx);
+                            let editor_launch_rx = self.launch_editor_with_feedback_async(&path);
+                            cx.spawn(async move |this, cx| {
+                                let Ok(launch_result) = editor_launch_rx.recv().await else {
+                                    return;
+                                };
+
+                                this.update(cx, |this, cx| match launch_result {
+                                    Ok(()) => {
+                                        this.hide_main_and_reset(cx);
+                                    }
+                                    Err(message) => {
+                                        this.show_hud(message, Some(3000), cx);
+                                    }
+                                })
+                                .ok();
+                            })
+                            .detach();
                         } else {
                             self.show_hud(
                                 "Scriptlet has no source file path".to_string(),
@@ -1964,9 +2112,28 @@
                             // Extract just the path without the anchor
                             let path_str = file_path.split('#').next().unwrap_or(file_path);
                             let path = std::path::Path::new(path_str);
-                            self.reveal_in_finder(path);
-                            self.show_hud("Opened in Finder".to_string(), Some(1500), cx);
-                            self.hide_main_and_reset(cx);
+                            let reveal_result_rx = self.reveal_in_finder_with_feedback_async(path);
+                            cx.spawn(async move |this, cx| {
+                                let Ok(reveal_result) = reveal_result_rx.recv().await else {
+                                    return;
+                                };
+
+                                this.update(cx, |this, cx| match reveal_result {
+                                    Ok(()) => {
+                                        this.show_hud(
+                                            "Opened in Finder".to_string(),
+                                            Some(1500),
+                                            cx,
+                                        );
+                                        this.hide_main_and_reset(cx);
+                                    }
+                                    Err(message) => {
+                                        this.show_hud(message, Some(2500), cx);
+                                    }
+                                })
+                                .ok();
+                            })
+                            .detach();
                         } else {
                             self.show_hud(
                                 "Scriptlet has no source file path".to_string(),
diff --git a/src/app_actions/helpers.rs b/src/app_actions/helpers.rs
index fb50657be41d2650d4e4be37f320f8f2393149b1..d1ffdb92db3025e5830d2f16c0f3b05af0ff26c7
--- a/src/app_actions/helpers.rs
+++ b/src/app_actions/helpers.rs
@@ -166,12 +166,14 @@
     use super::{
         clipboard_pin_action_success_hud, extract_scriptlet_source_path,
         file_search_action_error_hud_prefix, file_search_action_success_hud,
+        script_removal_target_from_result, select_clipboard_entry_meta,
         selection_required_message_for_action, should_transition_to_script_list_after_action,
-        script_removal_target_from_result, select_clipboard_entry_meta, ScriptRemovalTarget,
+        ScriptRemovalTarget,
     };
-    use crate::AppView;
     use crate::clipboard_history::{ClipboardEntryMeta, ContentType};
     use crate::scripts;
+    use crate::AppView;
+    use std::fs;
     use std::path::PathBuf;
     use std::sync::Arc;
 
@@ -189,6 +191,14 @@
         }
     }
 
+    fn read(path: &str) -> String {
+        fs::read_to_string(path).unwrap_or_else(|_| panic!("Failed to read {path}"))
+    }
+
+    fn count_occurrences(haystack: &str, needle: &str) -> usize {
+        haystack.match_indices(needle).count()
+    }
+
     #[test]
     fn test_select_clipboard_entry_meta_filters_and_clamps() {
         let entries = vec![entry("1", "Alpha"), entry("2", "Beta"), entry("3", "Gamma")];
@@ -364,4 +374,54 @@
             })
         );
     }
+
+    #[test]
+    fn test_edit_actions_show_error_feedback_when_editor_launch_fails() {
+        let content = read("src/app_actions/handle_action.rs");
+
+        assert!(
+            content.contains("fn launch_editor_with_feedback_async"),
+            "Expected async editor launch helper to exist"
+        );
+
+        let usage_count =
+            count_occurrences(&content, "self.launch_editor_with_feedback_async(&path)");
+        assert!(
+            usage_count >= 2,
+            "Expected edit_script and edit_scriptlet to use async editor launch feedback (found {usage_count} usages)"
+        );
+
+        assert!(
+            content.contains("this.show_hud(message, Some(3000), cx);"),
+            "Expected async editor launch failure to surface a HUD error message"
+        );
+    }
+
+    #[test]
+    fn test_reveal_actions_show_success_hud_after_async_completion() {
+        let content = read("src/app_actions/handle_action.rs");
+
+        assert!(
+            content.contains("fn reveal_in_finder_with_feedback_async"),
+            "Expected async reveal helper to exist"
+        );
+
+        let usage_count =
+            count_occurrences(&content, "self.reveal_in_finder_with_feedback_async(&path)")
+                + count_occurrences(&content, "self.reveal_in_finder_with_feedback_async(path)");
+        assert!(
+            usage_count >= 2,
+            "Expected reveal actions to use async reveal feedback helper (found {usage_count} usages)"
+        );
+
+        assert!(
+            content.contains("let Ok(reveal_result) = reveal_result_rx.recv().await else {"),
+            "Expected reveal actions to await reveal completion before showing HUD"
+        );
+
+        assert!(
+            content.contains("this.show_hud(\"Opened in Finder\".to_string(), Some(1500), cx);"),
+            "Expected reveal success HUD to be emitted from async completion callback"
+        );
+    }
 }
diff --git a/src/app_actions/tests/editor_launch_feedback.rs b/src/app_actions/tests/editor_launch_feedback.rs
deleted file mode 100644
index 18077766837c78518094e45c0da3b2a672b8bd8b..0000000000000000000000000000000000000000
--- a/src/app_actions/tests/editor_launch_feedback.rs
+++ /dev/null
@@ -1,62 +0,0 @@
-use std::fs;
-
-fn read(path: &str) -> String {
-    fs::read_to_string(path).unwrap_or_else(|_| panic!("Failed to read {path}"))
-}
-
-fn count_occurrences(haystack: &str, needle: &str) -> usize {
-    haystack.match_indices(needle).count()
-}
-
-#[test]
-fn test_edit_actions_show_error_feedback_when_editor_launch_fails() {
-    let content = read("src/app_actions/handle_action.rs");
-
-    assert!(
-        content.contains("fn launch_editor_with_feedback_async"),
-        "Expected async editor launch helper to exist"
-    );
-
-    let usage_count = count_occurrences(&content, "self.launch_editor_with_feedback_async(&path)");
-    assert!(
-        usage_count >= 2,
-        "Expected edit_script and edit_scriptlet to use async editor launch feedback (found {usage_count} usages)"
-    );
-
-    assert!(
-        content.contains("this.show_hud(message, Some(3000), cx);"),
-        "Expected async editor launch failure to surface a HUD error message"
-    );
-}
-
-#[test]
-fn test_reveal_actions_show_success_hud_after_async_reveal_completion() {
-    let content = read("src/app_actions/handle_action.rs");
-
-    assert!(
-        content.contains("fn reveal_in_finder_with_feedback_async"),
-        "Expected async reveal helper to exist"
-    );
-
-    let usage_count = count_occurrences(
-        &content,
-        "self.reveal_in_finder_with_feedback_async(&path)",
-    ) + count_occurrences(
-        &content,
-        "self.reveal_in_finder_with_feedback_async(path)",
-    );
-    assert!(
-        usage_count >= 2,
-        "Expected reveal actions to use async reveal feedback helper (found {usage_count} usages)"
-    );
-
-    assert!(
-        content.contains("let Ok(reveal_result) = reveal_result_rx.recv().await else {"),
-        "Expected reveal actions to await async reveal completion before showing HUD"
-    );
-
-    assert!(
-        content.contains("this.show_hud(\"Opened in Finder\".to_string(), Some(1500), cx);"),
-        "Expected reveal success HUD to be emitted from async completion callback"
-    );
-}


thinking
**Checking test file status**
exec
/bin/zsh -lc 'git status --short src/app_actions/handle_action.rs src/app_actions/helpers.rs src/app_actions/tests.rs src/app_actions/tests/editor_launch_feedback.rs' in /Users/johnlindquist/dev/script-kit-gpui succeeded in 51ms:
 M src/app_actions/handle_action.rs
 M src/app_actions/helpers.rs
?? src/app_actions/tests.rs
file update:
diff --git a/src/app_actions/handle_action.rs b/src/app_actions/handle_action.rs
index 6512e920f98eb38811debb5dca005d821b3adb44..a20dbbb8eae9367457a1e25e044924f8664e8dce
--- a/src/app_actions/handle_action.rs
+++ b/src/app_actions/handle_action.rs
@@ -27,11 +27,117 @@
 
             match crate::file_search::reveal_in_finder(&path_str) {
                 Ok(_) => logging::log("UI", &format!("Revealed in {}: {}", file_manager, path_str)),
-                Err(e) => logging::log("ERROR", &format!("Failed to reveal in {}: {}", file_manager, e)),
+                Err(e) => logging::log(
+                    "ERROR",
+                    &format!("Failed to reveal in {}: {}", file_manager, e),
+                ),
             }
         });
     }
 
+    /// Reveal a path and return completion back to the UI thread for HUD feedback.
+    fn reveal_in_finder_with_feedback_async(
+        &self,
+        path: &std::path::Path,
+    ) -> async_channel::Receiver<Result<(), String>> {
+        let path_str = path.to_string_lossy().to_string();
+        let (result_tx, result_rx) = async_channel::bounded::<Result<(), String>>(1);
+
+        std::thread::spawn(move || {
+            let file_manager = if cfg!(target_os = "macos") {
+                "Finder"
+            } else if cfg!(target_os = "windows") {
+                "Explorer"
+            } else {
+                "File Manager"
+            };
+
+            logging::log(
+                "UI",
+                &format!(
+                    "ACTION_REVEAL_IN_FINDER_START file_manager='{}' path='{}'",
+                    file_manager, path_str
+                ),
+            );
+
+            let reveal_result = match crate::file_search::reveal_in_finder(&path_str) {
+                Ok(()) => {
+                    logging::log(
+                        "UI",
+                        &format!(
+                            "ACTION_REVEAL_IN_FINDER_SUCCESS file_manager='{}' path='{}'",
+                            file_manager, path_str
+                        ),
+                    );
+                    Ok(())
+                }
+                Err(error) => {
+                    logging::log(
+                        "ERROR",
+                        &format!(
+                            "ACTION_REVEAL_IN_FINDER_FAILED attempted='reveal_in_finder' path='{}' file_manager='{}' error='{}'",
+                            path_str, file_manager, error
+                        ),
+                    );
+                    Err(format!("Failed to reveal in {}: {}", file_manager, error))
+                }
+            };
+
+            let _ = result_tx.send_blocking(reveal_result);
+        });
+
+        result_rx
+    }
+
+    /// Launch the configured editor and return completion back to the UI thread for HUD feedback.
+    fn launch_editor_with_feedback_async(
+        &self,
+        path: &std::path::Path,
+    ) -> async_channel::Receiver<Result<(), String>> {
+        let editor = self.config.get_editor();
+        let path_str = path.to_string_lossy().to_string();
+        let (result_tx, result_rx) = async_channel::bounded::<Result<(), String>>(1);
+
+        std::thread::spawn(move || {
+            use std::process::Command;
+
+            logging::log(
+                "UI",
+                &format!(
+                    "ACTION_EDITOR_LAUNCH_START editor='{}' path='{}'",
+                    editor, path_str
+                ),
+            );
+
+            let launch_result = match Command::new(&editor).arg(&path_str).spawn() {
+                Ok(_) => {
+                    logging::log(
+                        "UI",
+                        &format!(
+                            "ACTION_EDITOR_LAUNCH_SUCCESS editor='{}' path='{}'",
+                            editor, path_str
+                        ),
+                    );
+                    Ok(())
+                }
+                Err(error) => {
+                    logging::log(
+                        "ERROR",
+                        &format!(
+                            "ACTION_EDITOR_LAUNCH_FAILED attempted='{} {}' path='{}' error='{}'",
+                            editor, path_str, path_str, error
+                        ),
+                    );
+                    Err(format!("Failed to open in {}: {}", editor, error))
+                }
+            };
+
+            let _ = result_tx.send_blocking(launch_result);
+        });
+
+        result_rx
+    }
+
     /// Copy text to clipboard using pbcopy on macOS.
     /// Critical: This properly closes stdin before waiting to prevent hangs.
     #[cfg(target_os = "macos")]
@@ -471,9 +577,24 @@
                 };
 
                 if let Some(path) = path_opt {
-                    self.reveal_in_finder(&path);
-                    self.show_hud("Opened in Finder".to_string(), Some(1500), cx);
-                    self.hide_main_and_reset(cx);
+                    let reveal_result_rx = self.reveal_in_finder_with_feedback_async(&path);
+                    cx.spawn(async move |this, cx| {
+                        let Ok(reveal_result) = reveal_result_rx.recv().await else {
+                            return;
+                        };
+
+                        this.update(cx, |this, cx| match reveal_result {
+                            Ok(()) => {
+                                this.show_hud("Opened in Finder".to_string(), Some(1500), cx);
+                                this.hide_main_and_reset(cx);
+                            }
+                            Err(message) => {
+                                this.show_hud(message, Some(2500), cx);
+                            }
+                        })
+                        .ok();
+                    })
+                    .detach();
                 } else {
                     self.show_hud(
                         "Cannot reveal this item type in Finder".to_string(),
@@ -754,7 +875,6 @@
                 }
             }
             // Alias actions: add_alias, update_alias open the alias input
-
             "add_alias" | "update_alias" => {
                 logging::log("UI", &format!("{} action", action_id));
                 if let Some(result) = self.get_selected_result() {
@@ -884,8 +1004,23 @@
                     };
 
                     if let Some(path) = path_opt {
-                        self.edit_script(&path);
-                        self.hide_main_and_reset(cx);
+                        let editor_launch_rx = self.launch_editor_with_feedback_async(&path);
+                        cx.spawn(async move |this, cx| {
+                            let Ok(launch_result) = editor_launch_rx.recv().await else {
+                                return;
+                            };
+
+                            this.update(cx, |this, cx| match launch_result {
+                                Ok(()) => {
+                                    this.hide_main_and_reset(cx);
+                                }
+                                Err(message) => {
+                                    this.show_hud(message, Some(3000), cx);
+                                }
+                            })
+                            .ok();
+                        })
+                        .detach();
                     } else {
                         self.show_hud("Cannot edit this item type".to_string(), Some(2000), cx);
                     }
@@ -1096,7 +1231,6 @@
                 self.file_search_actions_path = None;
             }
             // File search specific actions
-
             "open_file" | "open_directory" | "quick_look" | "open_with" | "show_info" => {
                 if let Some(path) = self.file_search_actions_path.clone() {
                     logging::log("UI", &format!("File action '{}': {}", action_id, path));
@@ -1424,7 +1558,6 @@
                 }
             }
             // Clipboard delete actions
-
             "clipboard_delete_multiple" => {
                 let filter_text = match &self.current_view {
                     AppView::ClipboardHistoryView { filter, .. } => filter.trim().to_string(),
@@ -1932,8 +2065,23 @@
                             // Extract just the path without the anchor (e.g., "/path/to/file.md#slug" -> "/path/to/file.md")
                             let path_str = file_path.split('#').next().unwrap_or(file_path);
                             let path = std::path::PathBuf::from(path_str);
-                            self.edit_script(&path);
-                            self.hide_main_and_reset(cx);
+                            let editor_launch_rx = self.launch_editor_with_feedback_async(&path);
+                            cx.spawn(async move |this, cx| {
+                                let Ok(launch_result) = editor_launch_rx.recv().await else {
+                                    return;
+                                };
+
+                                this.update(cx, |this, cx| match launch_result {
+                                    Ok(()) => {
+                                        this.hide_main_and_reset(cx);
+                                    }
+                                    Err(message) => {
+                                        this.show_hud(message, Some(3000), cx);
+                                    }
+                                })
+                                .ok();
+                            })
+                            .detach();
                         } else {
                             self.show_hud(
                                 "Scriptlet has no source file path".to_string(),
@@ -1964,9 +2112,28 @@
                             // Extract just the path without the anchor
                             let path_str = file_path.split('#').next().unwrap_or(file_path);
                             let path = std::path::Path::new(path_str);
-                            self.reveal_in_finder(path);
-                            self.show_hud("Opened in Finder".to_string(), Some(1500), cx);
-                            self.hide_main_and_reset(cx);
+                            let reveal_result_rx = self.reveal_in_finder_with_feedback_async(path);
+                            cx.spawn(async move |this, cx| {
+                                let Ok(reveal_result) = reveal_result_rx.recv().await else {
+                                    return;
+                                };
+
+                                this.update(cx, |this, cx| match reveal_result {
+                                    Ok(()) => {
+                                        this.show_hud(
+                                            "Opened in Finder".to_string(),
+                                            Some(1500),
+                                            cx,
+                                        );
+                                        this.hide_main_and_reset(cx);
+                                    }
+                                    Err(message) => {
+                                        this.show_hud(message, Some(2500), cx);
+                                    }
+                                })
+                                .ok();
+                            })
+                            .detach();
                         } else {
                             self.show_hud(
                                 "Scriptlet has no source file path".to_string(),
diff --git a/src/app_actions/helpers.rs b/src/app_actions/helpers.rs
index fb50657be41d2650d4e4be37f320f8f2393149b1..d1ffdb92db3025e5830d2f16c0f3b05af0ff26c7
--- a/src/app_actions/helpers.rs
+++ b/src/app_actions/helpers.rs
@@ -166,12 +166,14 @@
     use super::{
         clipboard_pin_action_success_hud, extract_scriptlet_source_path,
         file_search_action_error_hud_prefix, file_search_action_success_hud,
+        script_removal_target_from_result, select_clipboard_entry_meta,
         selection_required_message_for_action, should_transition_to_script_list_after_action,
-        script_removal_target_from_result, select_clipboard_entry_meta, ScriptRemovalTarget,
+        ScriptRemovalTarget,
     };
-    use crate::AppView;
     use crate::clipboard_history::{ClipboardEntryMeta, ContentType};
     use crate::scripts;
+    use crate::AppView;
+    use std::fs;
     use std::path::PathBuf;
     use std::sync::Arc;
 
@@ -189,6 +191,14 @@
         }
     }
 
+    fn read(path: &str) -> String {
+        fs::read_to_string(path).unwrap_or_else(|_| panic!("Failed to read {path}"))
+    }
+
+    fn count_occurrences(haystack: &str, needle: &str) -> usize {
+        haystack.match_indices(needle).count()
+    }
+
     #[test]
     fn test_select_clipboard_entry_meta_filters_and_clamps() {
         let entries = vec![entry("1", "Alpha"), entry("2", "Beta"), entry("3", "Gamma")];
@@ -364,4 +374,54 @@
             })
         );
     }
+
+    #[test]
+    fn test_edit_actions_show_error_feedback_when_editor_launch_fails() {
+        let content = read("src/app_actions/handle_action.rs");
+
+        assert!(
+            content.contains("fn launch_editor_with_feedback_async"),
+            "Expected async editor launch helper to exist"
+        );
+
+        let usage_count =
+            count_occurrences(&content, "self.launch_editor_with_feedback_async(&path)");
+        assert!(
+            usage_count >= 2,
+            "Expected edit_script and edit_scriptlet to use async editor launch feedback (found {usage_count} usages)"
+        );
+
+        assert!(
+            content.contains("this.show_hud(message, Some(3000), cx);"),
+            "Expected async editor launch failure to surface a HUD error message"
+        );
+    }
+
+    #[test]
+    fn test_reveal_actions_show_success_hud_after_async_completion() {
+        let content = read("src/app_actions/handle_action.rs");
+
+        assert!(
+            content.contains("fn reveal_in_finder_with_feedback_async"),
+            "Expected async reveal helper to exist"
+        );
+
+        let usage_count =
+            count_occurrences(&content, "self.reveal_in_finder_with_feedback_async(&path)")
+                + count_occurrences(&content, "self.reveal_in_finder_with_feedback_async(path)");
+        assert!(
+            usage_count >= 2,
+            "Expected reveal actions to use async reveal feedback helper (found {usage_count} usages)"
+        );
+
+        assert!(
+            content.contains("let Ok(reveal_result) = reveal_result_rx.recv().await else {"),
+            "Expected reveal actions to await reveal completion before showing HUD"
+        );
+
+        assert!(
+            content.contains("this.show_hud(\"Opened in Finder\".to_string(), Some(1500), cx);"),
+            "Expected reveal success HUD to be emitted from async completion callback"
+        );
+    }
 }
diff --git a/src/app_actions/tests/editor_launch_feedback.rs b/src/app_actions/tests/editor_launch_feedback.rs
deleted file mode 100644
index 18077766837c78518094e45c0da3b2a672b8bd8b..0000000000000000000000000000000000000000
--- a/src/app_actions/tests/editor_launch_feedback.rs
+++ /dev/null
@@ -1,62 +0,0 @@
-use std::fs;
-
-fn read(path: &str) -> String {
-    fs::read_to_string(path).unwrap_or_else(|_| panic!("Failed to read {path}"))
-}
-
-fn count_occurrences(haystack: &str, needle: &str) -> usize {
-    haystack.match_indices(needle).count()
-}
-
-#[test]
-fn test_edit_actions_show_error_feedback_when_editor_launch_fails() {
-    let content = read("src/app_actions/handle_action.rs");
-
-    assert!(
-        content.contains("fn launch_editor_with_feedback_async"),
-        "Expected async editor launch helper to exist"
-    );
-
-    let usage_count = count_occurrences(&content, "self.launch_editor_with_feedback_async(&path)");
-    assert!(
-        usage_count >= 2,
-        "Expected edit_script and edit_scriptlet to use async editor launch feedback (found {usage_count} usages)"
-    );
-
-    assert!(
-        content.contains("this.show_hud(message, Some(3000), cx);"),
-        "Expected async editor launch failure to surface a HUD error message"
-    );
-}
-
-#[test]
-fn test_reveal_actions_show_success_hud_after_async_reveal_completion() {
-    let content = read("src/app_actions/handle_action.rs");
-
-    assert!(
-        content.contains("fn reveal_in_finder_with_feedback_async"),
-        "Expected async reveal helper to exist"
-    );
-
-    let usage_count = count_occurrences(
-        &content,
-        "self.reveal_in_finder_with_feedback_async(&path)",
-    ) + count_occurrences(
-        &content,
-        "self.reveal_in_finder_with_feedback_async(path)",
-    );
-    assert!(
-        usage_count >= 2,
-        "Expected reveal actions to use async reveal feedback helper (found {usage_count} usages)"
-    );
-
-    assert!(
-        content.contains("let Ok(reveal_result) = reveal_result_rx.recv().await else {"),
-        "Expected reveal actions to await async reveal completion before showing HUD"
-    );
-
-    assert!(
-        content.contains("this.show_hud(\"Opened in Finder\".to_string(), Some(1500), cx);"),
-        "Expected reveal success HUD to be emitted from async completion callback"
-    );
-}


thinking
**Confirming untracked file status**
exec
/bin/zsh -lc 'git diff -- src/app_actions/handle_action.rs src/app_actions/helpers.rs' in /Users/johnlindquist/dev/script-kit-gpui succeeded in 51ms:
diff --git a/src/app_actions/handle_action.rs b/src/app_actions/handle_action.rs
index 6512e92..a20dbbb 100644
--- a/src/app_actions/handle_action.rs
+++ b/src/app_actions/handle_action.rs
@@ -27,11 +27,117 @@ impl ScriptListApp {
 
             match crate::file_search::reveal_in_finder(&path_str) {
                 Ok(_) => logging::log("UI", &format!("Revealed in {}: {}", file_manager, path_str)),
-                Err(e) => logging::log("ERROR", &format!("Failed to reveal in {}: {}", file_manager, e)),
+                Err(e) => logging::log(
+                    "ERROR",
+                    &format!("Failed to reveal in {}: {}", file_manager, e),
+                ),
             }
         });
     }
 
+    /// Reveal a path and return completion back to the UI thread for HUD feedback.
+    fn reveal_in_finder_with_feedback_async(
+        &self,
file update:
diff --git a/src/app_actions/handle_action.rs b/src/app_actions/handle_action.rs
index 6512e920f98eb38811debb5dca005d821b3adb44..a20dbbb8eae9367457a1e25e044924f8664e8dce
--- a/src/app_actions/handle_action.rs
+++ b/src/app_actions/handle_action.rs
@@ -27,11 +27,117 @@
 
             match crate::file_search::reveal_in_finder(&path_str) {
                 Ok(_) => logging::log("UI", &format!("Revealed in {}: {}", file_manager, path_str)),
-                Err(e) => logging::log("ERROR", &format!("Failed to reveal in {}: {}", file_manager, e)),
+                Err(e) => logging::log(
+                    "ERROR",
+                    &format!("Failed to reveal in {}: {}", file_manager, e),
+                ),
             }
         });
     }
 
+    /// Reveal a path and return completion back to the UI thread for HUD feedback.
+    fn reveal_in_finder_with_feedback_async(
+        &self,
+        path: &std::path::Path,
+    ) -> async_channel::Receiver<Result<(), String>> {
+        let path_str = path.to_string_lossy().to_string();
+        let (result_tx, result_rx) = async_channel::bounded::<Result<(), String>>(1);
+
+        std::thread::spawn(move || {
+            let file_manager = if cfg!(target_os = "macos") {
+                "Finder"
+            } else if cfg!(target_os = "windows") {
+                "Explorer"
+            } else {
+                "File Manager"
+            };
+
+            logging::log(
+                "UI",
+                &format!(
+                    "ACTION_REVEAL_IN_FINDER_START file_manager='{}' path='{}'",
+                    file_manager, path_str
+                ),
+            );
+
+            let reveal_result = match crate::file_search::reveal_in_finder(&path_str) {
+                Ok(()) => {
+                    logging::log(
+                        "UI",
+                        &format!(
+                            "ACTION_REVEAL_IN_FINDER_SUCCESS file_manager='{}' path='{}'",
+                            file_manager, path_str
+                        ),
+                    );
+                    Ok(())
+                }
+                Err(error) => {
+                    logging::log(
+                        "ERROR",
+                        &format!(
+                            "ACTION_REVEAL_IN_FINDER_FAILED attempted='reveal_in_finder' path='{}' file_manager='{}' error='{}'",
+                            path_str, file_manager, error
+                        ),
+                    );
+                    Err(format!("Failed to reveal in {}: {}", file_manager, error))
+                }
+            };
+
+            let _ = result_tx.send_blocking(reveal_result);
+        });
+
+        result_rx
+    }
+
+    /// Launch the configured editor and return completion back to the UI thread for HUD feedback.
+    fn launch_editor_with_feedback_async(
+        &self,
+        path: &std::path::Path,
+    ) -> async_channel::Receiver<Result<(), String>> {
+        let editor = self.config.get_editor();
+        let path_str = path.to_string_lossy().to_string();
+        let (result_tx, result_rx) = async_channel::bounded::<Result<(), String>>(1);
+
+        std::thread::spawn(move || {
+            use std::process::Command;
+
+            logging::log(
+                "UI",
+                &format!(
+                    "ACTION_EDITOR_LAUNCH_START editor='{}' path='{}'",
+                    editor, path_str
+                ),
+            );
+
+            let launch_result = match Command::new(&editor).arg(&path_str).spawn() {
+                Ok(_) => {
+                    logging::log(
+                        "UI",
+                        &format!(
+                            "ACTION_EDITOR_LAUNCH_SUCCESS editor='{}' path='{}'",
+                            editor, path_str
+                        ),
+                    );
+                    Ok(())
+                }
+                Err(error) => {
+                    logging::log(
+                        "ERROR",
+                        &format!(
+                            "ACTION_EDITOR_LAUNCH_FAILED attempted='{} {}' path='{}' error='{}'",
+                            editor, path_str, path_str, error
+                        ),
+                    );
+                    Err(format!("Failed to open in {}: {}", editor, error))
+                }
+            };
+
+            let _ = result_tx.send_blocking(launch_result);
+        });
+
+        result_rx
+    }
+
     /// Copy text to clipboard using pbcopy on macOS.
     /// Critical: This properly closes stdin before waiting to prevent hangs.
     #[cfg(target_os = "macos")]
@@ -471,9 +577,24 @@
                 };
 
                 if let Some(path) = path_opt {
-                    self.reveal_in_finder(&path);
-                    self.show_hud("Opened in Finder".to_string(), Some(1500), cx);
-                    self.hide_main_and_reset(cx);
+                    let reveal_result_rx = self.reveal_in_finder_with_feedback_async(&path);
+                    cx.spawn(async move |this, cx| {
+                        let Ok(reveal_result) = reveal_result_rx.recv().await else {
+                            return;
+                        };
+
+                        this.update(cx, |this, cx| match reveal_result {
+                            Ok(()) => {
+                                this.show_hud("Opened in Finder".to_string(), Some(1500), cx);
+                                this.hide_main_and_reset(cx);
+                            }
+                            Err(message) => {
+                                this.show_hud(message, Some(2500), cx);
+                            }
+                        })
+                        .ok();
+                    })
+                    .detach();
                 } else {
                     self.show_hud(
                         "Cannot reveal this item type in Finder".to_string(),
@@ -754,7 +875,6 @@
                 }
             }
             // Alias actions: add_alias, update_alias open the alias input
-
             "add_alias" | "update_alias" => {
                 logging::log("UI", &format!("{} action", action_id));
                 if let Some(result) = self.get_selected_result() {
@@ -884,8 +1004,23 @@
                     };
 
                     if let Some(path) = path_opt {
-                        self.edit_script(&path);
-                        self.hide_main_and_reset(cx);
+                        let editor_launch_rx = self.launch_editor_with_feedback_async(&path);
+                        cx.spawn(async move |this, cx| {
+                            let Ok(launch_result) = editor_launch_rx.recv().await else {
+                                return;
+                            };
+
+                            this.update(cx, |this, cx| match launch_result {
+                                Ok(()) => {
+                                    this.hide_main_and_reset(cx);
+                                }
+                                Err(message) => {
+                                    this.show_hud(message, Some(3000), cx);
+                                }
+                            })
+                            .ok();
+                        })
+                        .detach();
                     } else {
                         self.show_hud("Cannot edit this item type".to_string(), Some(2000), cx);
                     }
@@ -1096,7 +1231,6 @@
                 self.file_search_actions_path = None;
             }
             // File search specific actions
-
             "open_file" | "open_directory" | "quick_look" | "open_with" | "show_info" => {
                 if let Some(path) = self.file_search_actions_path.clone() {
                     logging::log("UI", &format!("File action '{}': {}", action_id, path));
@@ -1424,7 +1558,6 @@
                 }
             }
             // Clipboard delete actions
-
             "clipboard_delete_multiple" => {
                 let filter_text = match &self.current_view {
                     AppView::ClipboardHistoryView { filter, .. } => filter.trim().to_string(),
@@ -1932,8 +2065,23 @@
                             // Extract just the path without the anchor (e.g., "/path/to/file.md#slug" -> "/path/to/file.md")
                             let path_str = file_path.split('#').next().unwrap_or(file_path);
                             let path = std::path::PathBuf::from(path_str);
-                            self.edit_script(&path);
-                            self.hide_main_and_reset(cx);
+                            let editor_launch_rx = self.launch_editor_with_feedback_async(&path);
+                            cx.spawn(async move |this, cx| {
+                                let Ok(launch_result) = editor_launch_rx.recv().await else {
+                                    return;
+                                };
+
+                                this.update(cx, |this, cx| match launch_result {
+                                    Ok(()) => {
+                                        this.hide_main_and_reset(cx);
+                                    }
+                                    Err(message) => {
+                                        this.show_hud(message, Some(3000), cx);
+                                    }
+                                })
+                                .ok();
+                            })
+                            .detach();
                         } else {
                             self.show_hud(
                                 "Scriptlet has no source file path".to_string(),
@@ -1964,9 +2112,28 @@
                             // Extract just the path without the anchor
                             let path_str = file_path.split('#').next().unwrap_or(file_path);
                             let path = std::path::Path::new(path_str);
-                            self.reveal_in_finder(path);
-                            self.show_hud("Opened in Finder".to_string(), Some(1500), cx);
-                            self.hide_main_and_reset(cx);
+                            let reveal_result_rx = self.reveal_in_finder_with_feedback_async(path);
+                            cx.spawn(async move |this, cx| {
+                                let Ok(reveal_result) = reveal_result_rx.recv().await else {
+                                    return;
+                                };
+
+                                this.update(cx, |this, cx| match reveal_result {
+                                    Ok(()) => {
+                                        this.show_hud(
+                                            "Opened in Finder".to_string(),
+                                            Some(1500),
+                                            cx,
+                                        );
+                                        this.hide_main_and_reset(cx);
+                                    }
+                                    Err(message) => {
+                                        this.show_hud(message, Some(2500), cx);
+                                    }
+                                })
+                                .ok();
+                            })
+                            .detach();
                         } else {
                             self.show_hud(
                                 "Scriptlet has no source file path".to_string(),
diff --git a/src/app_actions/helpers.rs b/src/app_actions/helpers.rs
index fb50657be41d2650d4e4be37f320f8f2393149b1..d1ffdb92db3025e5830d2f16c0f3b05af0ff26c7
--- a/src/app_actions/helpers.rs
+++ b/src/app_actions/helpers.rs
@@ -166,12 +166,14 @@
     use super::{
         clipboard_pin_action_success_hud, extract_scriptlet_source_path,
         file_search_action_error_hud_prefix, file_search_action_success_hud,
+        script_removal_target_from_result, select_clipboard_entry_meta,
         selection_required_message_for_action, should_transition_to_script_list_after_action,
-        script_removal_target_from_result, select_clipboard_entry_meta, ScriptRemovalTarget,
+        ScriptRemovalTarget,
     };
-    use crate::AppView;
     use crate::clipboard_history::{ClipboardEntryMeta, ContentType};
     use crate::scripts;
+    use crate::AppView;
+    use std::fs;
     use std::path::PathBuf;
     use std::sync::Arc;
 
@@ -189,6 +191,14 @@
         }
     }
 
+    fn read(path: &str) -> String {
+        fs::read_to_string(path).unwrap_or_else(|_| panic!("Failed to read {path}"))
+    }
+
+    fn count_occurrences(haystack: &str, needle: &str) -> usize {
+        haystack.match_indices(needle).count()
+    }
+
     #[test]
     fn test_select_clipboard_entry_meta_filters_and_clamps() {
         let entries = vec![entry("1", "Alpha"), entry("2", "Beta"), entry("3", "Gamma")];
@@ -364,4 +374,54 @@
             })
         );
     }
+
+    #[test]
+    fn test_edit_actions_show_error_feedback_when_editor_launch_fails() {
+        let content = read("src/app_actions/handle_action.rs");
+
+        assert!(
+            content.contains("fn launch_editor_with_feedback_async"),
+            "Expected async editor launch helper to exist"
+        );
+
+        let usage_count =
+            count_occurrences(&content, "self.launch_editor_with_feedback_async(&path)");
+        assert!(
+            usage_count >= 2,
+            "Expected edit_script and edit_scriptlet to use async editor launch feedback (found {usage_count} usages)"
+        );
+
+        assert!(
+            content.contains("this.show_hud(message, Some(3000), cx);"),
+            "Expected async editor launch failure to surface a HUD error message"
+        );
+    }
+
+    #[test]
+    fn test_reveal_actions_show_success_hud_after_async_completion() {
+        let content = read("src/app_actions/handle_action.rs");
+
+        assert!(
+            content.contains("fn reveal_in_finder_with_feedback_async"),
+            "Expected async reveal helper to exist"
+        );
+
+        let usage_count =
+            count_occurrences(&content, "self.reveal_in_finder_with_feedback_async(&path)")
+                + count_occurrences(&content, "self.reveal_in_finder_with_feedback_async(path)");
+        assert!(
+            usage_count >= 2,
+            "Expected reveal actions to use async reveal feedback helper (found {usage_count} usages)"
+        );
+
+        assert!(
+            content.contains("let Ok(reveal_result) = reveal_result_rx.recv().await else {"),
+            "Expected reveal actions to await reveal completion before showing HUD"
+        );
+
+        assert!(
+            content.contains("this.show_hud(\"Opened in Finder\".to_string(), Some(1500), cx);"),
+            "Expected reveal success HUD to be emitted from async completion callback"
+        );
+    }
 }
diff --git a/src/app_actions/tests/editor_launch_feedback.rs b/src/app_actions/tests/editor_launch_feedback.rs
deleted file mode 100644
index 18077766837c78518094e45c0da3b2a672b8bd8b..0000000000000000000000000000000000000000
--- a/src/app_actions/tests/editor_launch_feedback.rs
+++ /dev/null
@@ -1,62 +0,0 @@
-use std::fs;
-
-fn read(path: &str) -> String {
-    fs::read_to_string(path).unwrap_or_else(|_| panic!("Failed to read {path}"))
-}
-
-fn count_occurrences(haystack: &str, needle: &str) -> usize {
-    haystack.match_indices(needle).count()
-}
-
-#[test]
-fn test_edit_actions_show_error_feedback_when_editor_launch_fails() {
-    let content = read("src/app_actions/handle_action.rs");
-
-    assert!(
-        content.contains("fn launch_editor_with_feedback_async"),
-        "Expected async editor launch helper to exist"
-    );
-
-    let usage_count = count_occurrences(&content, "self.launch_editor_with_feedback_async(&path)");
-    assert!(
-        usage_count >= 2,
-        "Expected edit_script and edit_scriptlet to use async editor launch feedback (found {usage_count} usages)"
-    );
-
-    assert!(
-        content.contains("this.show_hud(message, Some(3000), cx);"),
-        "Expected async editor launch failure to surface a HUD error message"
-    );
-}
-
-#[test]
-fn test_reveal_actions_show_success_hud_after_async_reveal_completion() {
-    let content = read("src/app_actions/handle_action.rs");
-
-    assert!(
-        content.contains("fn reveal_in_finder_with_feedback_async"),
-        "Expected async reveal helper to exist"
-    );
-
-    let usage_count = count_occurrences(
-        &content,
-        "self.reveal_in_finder_with_feedback_async(&path)",
-    ) + count_occurrences(
-        &content,
-        "self.reveal_in_finder_with_feedback_async(path)",
-    );
-    assert!(
-        usage_count >= 2,
-        "Expected reveal actions to use async reveal feedback helper (found {usage_count} usages)"
-    );
-
-    assert!(
-        content.contains("let Ok(reveal_result) = reveal_result_rx.recv().await else {"),
-        "Expected reveal actions to await async reveal completion before showing HUD"
-    );
-
-    assert!(
-        content.contains("this.show_hud(\"Opened in Finder\".to_string(), Some(1500), cx);"),
-        "Expected reveal success HUD to be emitted from async completion callback"
-    );
-}


thinking
**Marking done with verification blocked**
exec
/bin/zsh -lc 'git status --short src/app_actions/handle_action.rs src/app_actions/helpers.rs src/app_actions/tests.rs' in /Users/johnlindquist/dev/script-kit-gpui succeeded in 52ms:
 M src/app_actions/handle_action.rs
 M src/app_actions/helpers.rs
?? src/app_actions/tests.rs
file update:
diff --git a/src/app_actions/handle_action.rs b/src/app_actions/handle_action.rs
index 6512e920f98eb38811debb5dca005d821b3adb44..a20dbbb8eae9367457a1e25e044924f8664e8dce
--- a/src/app_actions/handle_action.rs
+++ b/src/app_actions/handle_action.rs
@@ -27,11 +27,117 @@
 
             match crate::file_search::reveal_in_finder(&path_str) {
                 Ok(_) => logging::log("UI", &format!("Revealed in {}: {}", file_manager, path_str)),
-                Err(e) => logging::log("ERROR", &format!("Failed to reveal in {}: {}", file_manager, e)),
+                Err(e) => logging::log(
+                    "ERROR",
+                    &format!("Failed to reveal in {}: {}", file_manager, e),
+                ),
             }
         });
     }
 
+    /// Reveal a path and return completion back to the UI thread for HUD feedback.
+    fn reveal_in_finder_with_feedback_async(
+        &self,
+        path: &std::path::Path,
+    ) -> async_channel::Receiver<Result<(), String>> {
+        let path_str = path.to_string_lossy().to_string();
+        let (result_tx, result_rx) = async_channel::bounded::<Result<(), String>>(1);
+
+        std::thread::spawn(move || {
+            let file_manager = if cfg!(target_os = "macos") {
+                "Finder"
+            } else if cfg!(target_os = "windows") {
+                "Explorer"
+            } else {
+                "File Manager"
+            };
+
+            logging::log(
+                "UI",
+                &format!(
+                    "ACTION_REVEAL_IN_FINDER_START file_manager='{}' path='{}'",
+                    file_manager, path_str
+                ),
+            );
+
+            let reveal_result = match crate::file_search::reveal_in_finder(&path_str) {
+                Ok(()) => {
+                    logging::log(
+                        "UI",
+                        &format!(
+                            "ACTION_REVEAL_IN_FINDER_SUCCESS file_manager='{}' path='{}'",
+                            file_manager, path_str
+                        ),
+                    );
+                    Ok(())
+                }
+                Err(error) => {
+                    logging::log(
+                        "ERROR",
+                        &format!(
+                            "ACTION_REVEAL_IN_FINDER_FAILED attempted='reveal_in_finder' path='{}' file_manager='{}' error='{}'",
+                            path_str, file_manager, error
+                        ),
+                    );
+                    Err(format!("Failed to reveal in {}: {}", file_manager, error))
+                }
+            };
+
+            let _ = result_tx.send_blocking(reveal_result);
+        });
+
+        result_rx
+    }
+
+    /// Launch the configured editor and return completion back to the UI thread for HUD feedback.
+    fn launch_editor_with_feedback_async(
+        &self,
+        path: &std::path::Path,
+    ) -> async_channel::Receiver<Result<(), String>> {
+        let editor = self.config.get_editor();
+        let path_str = path.to_string_lossy().to_string();
+        let (result_tx, result_rx) = async_channel::bounded::<Result<(), String>>(1);
+
+        std::thread::spawn(move || {
+            use std::process::Command;
+
+            logging::log(
+                "UI",
+                &format!(
+                    "ACTION_EDITOR_LAUNCH_START editor='{}' path='{}'",
+                    editor, path_str
+                ),
+            );
+
+            let launch_result = match Command::new(&editor).arg(&path_str).spawn() {
+                Ok(_) => {
+                    logging::log(
+                        "UI",
+                        &format!(
+                            "ACTION_EDITOR_LAUNCH_SUCCESS editor='{}' path='{}'",
+                            editor, path_str
+                        ),
+                    );
+                    Ok(())
+                }
+                Err(error) => {
+                    logging::log(
+                        "ERROR",
+                        &format!(
+                            "ACTION_EDITOR_LAUNCH_FAILED attempted='{} {}' path='{}' error='{}'",
+                            editor, path_str, path_str, error
+                        ),
+                    );
+                    Err(format!("Failed to open in {}: {}", editor, error))
+                }
+            };
+
+            let _ = result_tx.send_blocking(launch_result);
+        });
+
+        result_rx
+    }
+
     /// Copy text to clipboard using pbcopy on macOS.
     /// Critical: This properly closes stdin before waiting to prevent hangs.
     #[cfg(target_os = "macos")]
@@ -471,9 +577,24 @@
                 };
 
                 if let Some(path) = path_opt {
-                    self.reveal_in_finder(&path);
-                    self.show_hud("Opened in Finder".to_string(), Some(1500), cx);
-                    self.hide_main_and_reset(cx);
+                    let reveal_result_rx = self.reveal_in_finder_with_feedback_async(&path);
+                    cx.spawn(async move |this, cx| {
+                        let Ok(reveal_result) = reveal_result_rx.recv().await else {
+                            return;
+                        };
+
+                        this.update(cx, |this, cx| match reveal_result {
+                            Ok(()) => {
+                                this.show_hud("Opened in Finder".to_string(), Some(1500), cx);
+                                this.hide_main_and_reset(cx);
+                            }
+                            Err(message) => {
+                                this.show_hud(message, Some(2500), cx);
+                            }
+                        })
+                        .ok();
+                    })
+                    .detach();
                 } else {
                     self.show_hud(
                         "Cannot reveal this item type in Finder".to_string(),
@@ -754,7 +875,6 @@
                 }
             }
             // Alias actions: add_alias, update_alias open the alias input
-
             "add_alias" | "update_alias" => {
                 logging::log("UI", &format!("{} action", action_id));
                 if let Some(result) = self.get_selected_result() {
@@ -884,8 +1004,23 @@
                     };
 
                     if let Some(path) = path_opt {
-                        self.edit_script(&path);
-                        self.hide_main_and_reset(cx);
+                        let editor_launch_rx = self.launch_editor_with_feedback_async(&path);
+                        cx.spawn(async move |this, cx| {
+                            let Ok(launch_result) = editor_launch_rx.recv().await else {
+                                return;
+                            };
+
+                            this.update(cx, |this, cx| match launch_result {
+                                Ok(()) => {
+                                    this.hide_main_and_reset(cx);
+                                }
+                                Err(message) => {
+                                    this.show_hud(message, Some(3000), cx);
+                                }
+                            })
+                            .ok();
+                        })
+                        .detach();
                     } else {
                         self.show_hud("Cannot edit this item type".to_string(), Some(2000), cx);
                     }
@@ -1096,7 +1231,6 @@
                 self.file_search_actions_path = None;
             }
             // File search specific actions
-
             "open_file" | "open_directory" | "quick_look" | "open_with" | "show_info" => {
                 if let Some(path) = self.file_search_actions_path.clone() {
                     logging::log("UI", &format!("File action '{}': {}", action_id, path));
@@ -1424,7 +1558,6 @@
                 }
             }
             // Clipboard delete actions
-
             "clipboard_delete_multiple" => {
                 let filter_text = match &self.current_view {
                     AppView::ClipboardHistoryView { filter, .. } => filter.trim().to_string(),
@@ -1932,8 +2065,23 @@
                             // Extract just the path without the anchor (e.g., "/path/to/file.md#slug" -> "/path/to/file.md")
                             let path_str = file_path.split('#').next().unwrap_or(file_path);
                             let path = std::path::PathBuf::from(path_str);
-                            self.edit_script(&path);
-                            self.hide_main_and_reset(cx);
+                            let editor_launch_rx = self.launch_editor_with_feedback_async(&path);
+                            cx.spawn(async move |this, cx| {
+                                let Ok(launch_result) = editor_launch_rx.recv().await else {
+                                    return;
+                                };
+
+                                this.update(cx, |this, cx| match launch_result {
+                                    Ok(()) => {
+                                        this.hide_main_and_reset(cx);
+                                    }
+                                    Err(message) => {
+                                        this.show_hud(message, Some(3000), cx);
+                                    }
+                                })
+                                .ok();
+                            })
+                            .detach();
                         } else {
                             self.show_hud(
                                 "Scriptlet has no source file path".to_string(),
@@ -1964,9 +2112,28 @@
                             // Extract just the path without the anchor
                             let path_str = file_path.split('#').next().unwrap_or(file_path);
                             let path = std::path::Path::new(path_str);
-                            self.reveal_in_finder(path);
-                            self.show_hud("Opened in Finder".to_string(), Some(1500), cx);
-                            self.hide_main_and_reset(cx);
+                            let reveal_result_rx = self.reveal_in_finder_with_feedback_async(path);
+                            cx.spawn(async move |this, cx| {
+                                let Ok(reveal_result) = reveal_result_rx.recv().await else {
+                                    return;
+                                };
+
+                                this.update(cx, |this, cx| match reveal_result {
+                                    Ok(()) => {
+                                        this.show_hud(
+                                            "Opened in Finder".to_string(),
+                                            Some(1500),
+                                            cx,
+                                        );
+                                        this.hide_main_and_reset(cx);
+                                    }
+                                    Err(message) => {
+                                        this.show_hud(message, Some(2500), cx);
+                                    }
+                                })
+                                .ok();
+                            })
+                            .detach();
                         } else {
                             self.show_hud(
                                 "Scriptlet has no source file path".to_string(),
diff --git a/src/app_actions/helpers.rs b/src/app_actions/helpers.rs
index fb50657be41d2650d4e4be37f320f8f2393149b1..d1ffdb92db3025e5830d2f16c0f3b05af0ff26c7
--- a/src/app_actions/helpers.rs
+++ b/src/app_actions/helpers.rs
@@ -166,12 +166,14 @@
     use super::{
         clipboard_pin_action_success_hud, extract_scriptlet_source_path,
         file_search_action_error_hud_prefix, file_search_action_success_hud,
+        script_removal_target_from_result, select_clipboard_entry_meta,
         selection_required_message_for_action, should_transition_to_script_list_after_action,
-        script_removal_target_from_result, select_clipboard_entry_meta, ScriptRemovalTarget,
+        ScriptRemovalTarget,
     };
-    use crate::AppView;
     use crate::clipboard_history::{ClipboardEntryMeta, ContentType};
     use crate::scripts;
+    use crate::AppView;
+    use std::fs;
     use std::path::PathBuf;
     use std::sync::Arc;
 
@@ -189,6 +191,14 @@
         }
     }
 
+    fn read(path: &str) -> String {
+        fs::read_to_string(path).unwrap_or_else(|_| panic!("Failed to read {path}"))
+    }
+
+    fn count_occurrences(haystack: &str, needle: &str) -> usize {
+        haystack.match_indices(needle).count()
+    }
+
     #[test]
     fn test_select_clipboard_entry_meta_filters_and_clamps() {
         let entries = vec![entry("1", "Alpha"), entry("2", "Beta"), entry("3", "Gamma")];
@@ -364,4 +374,54 @@
             })
         );
     }
+
+    #[test]
+    fn test_edit_actions_show_error_feedback_when_editor_launch_fails() {
+        let content = read("src/app_actions/handle_action.rs");
+
+        assert!(
+            content.contains("fn launch_editor_with_feedback_async"),
+            "Expected async editor launch helper to exist"
+        );
+
+        let usage_count =
+            count_occurrences(&content, "self.launch_editor_with_feedback_async(&path)");
+        assert!(
+            usage_count >= 2,
+            "Expected edit_script and edit_scriptlet to use async editor launch feedback (found {usage_count} usages)"
+        );
+
+        assert!(
+            content.contains("this.show_hud(message, Some(3000), cx);"),
+            "Expected async editor launch failure to surface a HUD error message"
+        );
+    }
+
+    #[test]
+    fn test_reveal_actions_show_success_hud_after_async_completion() {
+        let content = read("src/app_actions/handle_action.rs");
+
+        assert!(
+            content.contains("fn reveal_in_finder_with_feedback_async"),
+            "Expected async reveal helper to exist"
+        );
+
+        let usage_count =
+            count_occurrences(&content, "self.reveal_in_finder_with_feedback_async(&path)")
+                + count_occurrences(&content, "self.reveal_in_finder_with_feedback_async(path)");
+        assert!(
+            usage_count >= 2,
+            "Expected reveal actions to use async reveal feedback helper (found {usage_count} usages)"
+        );
+
+        assert!(
+            content.contains("let Ok(reveal_result) = reveal_result_rx.recv().await else {"),
+            "Expected reveal actions to await reveal completion before showing HUD"
+        );
+
+        assert!(
+            content.contains("this.show_hud(\"Opened in Finder\".to_string(), Some(1500), cx);"),
+            "Expected reveal success HUD to be emitted from async completion callback"
+        );
+    }
 }
diff --git a/src/app_actions/tests/editor_launch_feedback.rs b/src/app_actions/tests/editor_launch_feedback.rs
deleted file mode 100644
index 18077766837c78518094e45c0da3b2a672b8bd8b..0000000000000000000000000000000000000000
--- a/src/app_actions/tests/editor_launch_feedback.rs
+++ /dev/null
@@ -1,62 +0,0 @@
-use std::fs;
-
-fn read(path: &str) -> String {
-    fs::read_to_string(path).unwrap_or_else(|_| panic!("Failed to read {path}"))
-}
-
-fn count_occurrences(haystack: &str, needle: &str) -> usize {
-    haystack.match_indices(needle).count()
-}
-
-#[test]
-fn test_edit_actions_show_error_feedback_when_editor_launch_fails() {
-    let content = read("src/app_actions/handle_action.rs");
-
-    assert!(
-        content.contains("fn launch_editor_with_feedback_async"),
-        "Expected async editor launch helper to exist"
-    );
-
-    let usage_count = count_occurrences(&content, "self.launch_editor_with_feedback_async(&path)");
-    assert!(
-        usage_count >= 2,
-        "Expected edit_script and edit_scriptlet to use async editor launch feedback (found {usage_count} usages)"
-    );
-
-    assert!(
-        content.contains("this.show_hud(message, Some(3000), cx);"),
-        "Expected async editor launch failure to surface a HUD error message"
-    );
-}
-
-#[test]
-fn test_reveal_actions_show_success_hud_after_async_reveal_completion() {
-    let content = read("src/app_actions/handle_action.rs");
-
-    assert!(
-        content.contains("fn reveal_in_finder_with_feedback_async"),
-        "Expected async reveal helper to exist"
-    );
-
-    let usage_count = count_occurrences(
-        &content,
-        "self.reveal_in_finder_with_feedback_async(&path)",
-    ) + count_occurrences(
-        &content,
-        "self.reveal_in_finder_with_feedback_async(path)",
-    );
-    assert!(
-        usage_count >= 2,
-        "Expected reveal actions to use async reveal feedback helper (found {usage_count} usages)"
-    );
-
-    assert!(
-        content.contains("let Ok(reveal_result) = reveal_result_rx.recv().await else {"),
-        "Expected reveal actions to await async reveal completion before showing HUD"
-    );
-
-    assert!(
-        content.contains("this.show_hud(\"Opened in Finder\".to_string(), Some(1500), cx);"),
-        "Expected reveal success HUD to be emitted from async completion callback"
-    );
-}


thinking
**Gathering line numbers for references**
exec
/bin/zsh -lc "rg -n \"reveal_in_finder_with_feedback_async|launch_editor_with_feedback_async|\\\"edit_script\\\" =>|\\\"edit_scriptlet\\\" =>|\\\"reveal_in_finder\\\" =>|\\\"reveal_scriptlet_in_finder\\\" =>|test_edit_actions_show_error_feedback_when_editor_launch_fails|test_reveal_actions_show_success_hud_after_async_completion\" src/app_actions/handle_action.rs src/app_actions/helpers.rs" in /Users/johnlindquist/dev/script-kit-gpui succeeded in 52ms:
src/app_actions/helpers.rs:74:        "edit_scriptlet" => "Select a scriptlet to edit.",
src/app_actions/helpers.rs:75:        "reveal_scriptlet_in_finder" => "Select a scriptlet to reveal in Finder.",
src/app_actions/helpers.rs:379:    fn test_edit_actions_show_error_feedback_when_editor_launch_fails() {
src/app_actions/helpers.rs:383:            content.contains("fn launch_editor_with_feedback_async"),
src/app_actions/helpers.rs:388:            count_occurrences(&content, "self.launch_editor_with_feedback_async(&path)");
src/app_actions/helpers.rs:401:    fn test_reveal_actions_show_success_hud_after_async_completion() {
src/app_actions/helpers.rs:405:            content.contains("fn reveal_in_finder_with_feedback_async"),
src/app_actions/helpers.rs:410:            count_occurrences(&content, "self.reveal_in_finder_with_feedback_async(&path)")
src/app_actions/helpers.rs:411:                + count_occurrences(&content, "self.reveal_in_finder_with_feedback_async(path)");
src/app_actions/handle_action.rs:39:    fn reveal_in_finder_with_feedback_async(
src/app_actions/handle_action.rs:93:    fn launch_editor_with_feedback_async(
src/app_actions/handle_action.rs:558:            "reveal_in_finder" => {
src/app_actions/handle_action.rs:580:                    let reveal_result_rx = self.reveal_in_finder_with_feedback_async(&path);
src/app_actions/handle_action.rs:993:            "edit_script" => {
src/app_actions/handle_action.rs:1007:                        let editor_launch_rx = self.launch_editor_with_feedback_async(&path);
src/app_actions/handle_action.rs:2060:            "edit_scriptlet" => {
src/app_actions/handle_action.rs:2068:                            let editor_launch_rx = self.launch_editor_with_feedback_async(&path);
src/app_actions/handle_action.rs:2107:            "reveal_scriptlet_in_finder" => {
src/app_actions/handle_action.rs:2115:                            let reveal_result_rx = self.reveal_in_finder_with_feedback_async(path);
file update:
diff --git a/src/app_actions/handle_action.rs b/src/app_actions/handle_action.rs
index 6512e920f98eb38811debb5dca005d821b3adb44..a20dbbb8eae9367457a1e25e044924f8664e8dce
--- a/src/app_actions/handle_action.rs
+++ b/src/app_actions/handle_action.rs
@@ -27,11 +27,117 @@
 
             match crate::file_search::reveal_in_finder(&path_str) {
                 Ok(_) => logging::log("UI", &format!("Revealed in {}: {}", file_manager, path_str)),
-                Err(e) => logging::log("ERROR", &format!("Failed to reveal in {}: {}", file_manager, e)),
+                Err(e) => logging::log(
+                    "ERROR",
+                    &format!("Failed to reveal in {}: {}", file_manager, e),
+                ),
             }
         });
     }
 
+    /// Reveal a path and return completion back to the UI thread for HUD feedback.
+    fn reveal_in_finder_with_feedback_async(
+        &self,
+        path: &std::path::Path,
+    ) -> async_channel::Receiver<Result<(), String>> {
+        let path_str = path.to_string_lossy().to_string();
+        let (result_tx, result_rx) = async_channel::bounded::<Result<(), String>>(1);
+
+        std::thread::spawn(move || {
+            let file_manager = if cfg!(target_os = "macos") {
+                "Finder"
+            } else if cfg!(target_os = "windows") {
+                "Explorer"
+            } else {
+                "File Manager"
+            };
+
+            logging::log(
+                "UI",
+                &format!(
+                    "ACTION_REVEAL_IN_FINDER_START file_manager='{}' path='{}'",
+                    file_manager, path_str
+                ),
+            );
+
+            let reveal_result = match crate::file_search::reveal_in_finder(&path_str) {
+                Ok(()) => {
+                    logging::log(
+                        "UI",
+                        &format!(
+                            "ACTION_REVEAL_IN_FINDER_SUCCESS file_manager='{}' path='{}'",
+                            file_manager, path_str
+                        ),
+                    );
+                    Ok(())
+                }
+                Err(error) => {
+                    logging::log(
+                        "ERROR",
+                        &format!(
+                            "ACTION_REVEAL_IN_FINDER_FAILED attempted='reveal_in_finder' path='{}' file_manager='{}' error='{}'",
+                            path_str, file_manager, error
+                        ),
+                    );
+                    Err(format!("Failed to reveal in {}: {}", file_manager, error))
+                }
+            };
+
+            let _ = result_tx.send_blocking(reveal_result);
+        });
+
+        result_rx
+    }
+
+    /// Launch the configured editor and return completion back to the UI thread for HUD feedback.
+    fn launch_editor_with_feedback_async(
+        &self,
+        path: &std::path::Path,
+    ) -> async_channel::Receiver<Result<(), String>> {
+        let editor = self.config.get_editor();
+        let path_str = path.to_string_lossy().to_string();
+        let (result_tx, result_rx) = async_channel::bounded::<Result<(), String>>(1);
+
+        std::thread::spawn(move || {
+            use std::process::Command;
+
+            logging::log(
+                "UI",
+                &format!(
+                    "ACTION_EDITOR_LAUNCH_START editor='{}' path='{}'",
+                    editor, path_str
+                ),
+            );
+
+            let launch_result = match Command::new(&editor).arg(&path_str).spawn() {
+                Ok(_) => {
+                    logging::log(
+                        "UI",
+                        &format!(
+                            "ACTION_EDITOR_LAUNCH_SUCCESS editor='{}' path='{}'",
+                            editor, path_str
+                        ),
+                    );
+                    Ok(())
+                }
+                Err(error) => {
+                    logging::log(
+                        "ERROR",
+                        &format!(
+                            "ACTION_EDITOR_LAUNCH_FAILED attempted='{} {}' path='{}' error='{}'",
+                            editor, path_str, path_str, error
+                        ),
+                    );
+                    Err(format!("Failed to open in {}: {}", editor, error))
+                }
+            };
+
+            let _ = result_tx.send_blocking(launch_result);
+        });
+
+        result_rx
+    }
+
     /// Copy text to clipboard using pbcopy on macOS.
     /// Critical: This properly closes stdin before waiting to prevent hangs.
     #[cfg(target_os = "macos")]
@@ -471,9 +577,24 @@
                 };
 
                 if let Some(path) = path_opt {
-                    self.reveal_in_finder(&path);
-                    self.show_hud("Opened in Finder".to_string(), Some(1500), cx);
-                    self.hide_main_and_reset(cx);
+                    let reveal_result_rx = self.reveal_in_finder_with_feedback_async(&path);
+                    cx.spawn(async move |this, cx| {
+                        let Ok(reveal_result) = reveal_result_rx.recv().await else {
+                            return;
+                        };
+
+                        this.update(cx, |this, cx| match reveal_result {
+                            Ok(()) => {
+                                this.show_hud("Opened in Finder".to_string(), Some(1500), cx);
+                                this.hide_main_and_reset(cx);
+                            }
+                            Err(message) => {
+                                this.show_hud(message, Some(2500), cx);
+                            }
+                        })
+                        .ok();
+                    })
+                    .detach();
                 } else {
                     self.show_hud(
                         "Cannot reveal this item type in Finder".to_string(),
@@ -754,7 +875,6 @@
                 }
             }
             // Alias actions: add_alias, update_alias open the alias input
-
             "add_alias" | "update_alias" => {
                 logging::log("UI", &format!("{} action", action_id));
                 if let Some(result) = self.get_selected_result() {
@@ -884,8 +1004,23 @@
                     };
 
                     if let Some(path) = path_opt {
-                        self.edit_script(&path);
-                        self.hide_main_and_reset(cx);
+                        let editor_launch_rx = self.launch_editor_with_feedback_async(&path);
+                        cx.spawn(async move |this, cx| {
+                            let Ok(launch_result) = editor_launch_rx.recv().await else {
+                                return;
+                            };
+
+                            this.update(cx, |this, cx| match launch_result {
+                                Ok(()) => {
+                                    this.hide_main_and_reset(cx);
+                                }
+                                Err(message) => {
+                                    this.show_hud(message, Some(3000), cx);
+                                }
+                            })
+                            .ok();
+                        })
+                        .detach();
                     } else {
                         self.show_hud("Cannot edit this item type".to_string(), Some(2000), cx);
                     }
@@ -1096,7 +1231,6 @@
                 self.file_search_actions_path = None;
             }
             // File search specific actions
-
             "open_file" | "open_directory" | "quick_look" | "open_with" | "show_info" => {
                 if let Some(path) = self.file_search_actions_path.clone() {
                     logging::log("UI", &format!("File action '{}': {}", action_id, path));
@@ -1424,7 +1558,6 @@
                 }
             }
             // Clipboard delete actions
-
             "clipboard_delete_multiple" => {
                 let filter_text = match &self.current_view {
                     AppView::ClipboardHistoryView { filter, .. } => filter.trim().to_string(),
@@ -1932,8 +2065,23 @@
                             // Extract just the path without the anchor (e.g., "/path/to/file.md#slug" -> "/path/to/file.md")
                             let path_str = file_path.split('#').next().unwrap_or(file_path);
                             let path = std::path::PathBuf::from(path_str);
-                            self.edit_script(&path);
-                            self.hide_main_and_reset(cx);
+                            let editor_launch_rx = self.launch_editor_with_feedback_async(&path);
+                            cx.spawn(async move |this, cx| {
+                                let Ok(launch_result) = editor_launch_rx.recv().await else {
+                                    return;
+                                };
+
+                                this.update(cx, |this, cx| match launch_result {
+                                    Ok(()) => {
+                                        this.hide_main_and_reset(cx);
+                                    }
+                                    Err(message) => {
+                                        this.show_hud(message, Some(3000), cx);
+                                    }
+                                })
+                                .ok();
+                            })
+                            .detach();
                         } else {
                             self.show_hud(
                                 "Scriptlet has no source file path".to_string(),
@@ -1964,9 +2112,28 @@
                             // Extract just the path without the anchor
                             let path_str = file_path.split('#').next().unwrap_or(file_path);
                             let path = std::path::Path::new(path_str);
-                            self.reveal_in_finder(path);
-                            self.show_hud("Opened in Finder".to_string(), Some(1500), cx);
-                            self.hide_main_and_reset(cx);
+                            let reveal_result_rx = self.reveal_in_finder_with_feedback_async(path);
+                            cx.spawn(async move |this, cx| {
+                                let Ok(reveal_result) = reveal_result_rx.recv().await else {
+                                    return;
+                                };
+
+                                this.update(cx, |this, cx| match reveal_result {
+                                    Ok(()) => {
+                                        this.show_hud(
+                                            "Opened in Finder".to_string(),
+                                            Some(1500),
+                                            cx,
+                                        );
+                                        this.hide_main_and_reset(cx);
+                                    }
+                                    Err(message) => {
+                                        this.show_hud(message, Some(2500), cx);
+                                    }
+                                })
+                                .ok();
+                            })
+                            .detach();
                         } else {
                             self.show_hud(
                                 "Scriptlet has no source file path".to_string(),
diff --git a/src/app_actions/helpers.rs b/src/app_actions/helpers.rs
index fb50657be41d2650d4e4be37f320f8f2393149b1..d1ffdb92db3025e5830d2f16c0f3b05af0ff26c7
--- a/src/app_actions/helpers.rs
+++ b/src/app_actions/helpers.rs
@@ -166,12 +166,14 @@
     use super::{
         clipboard_pin_action_success_hud, extract_scriptlet_source_path,
         file_search_action_error_hud_prefix, file_search_action_success_hud,
+        script_removal_target_from_result, select_clipboard_entry_meta,
         selection_required_message_for_action, should_transition_to_script_list_after_action,
-        script_removal_target_from_result, select_clipboard_entry_meta, ScriptRemovalTarget,
+        ScriptRemovalTarget,
     };
-    use crate::AppView;
     use crate::clipboard_history::{ClipboardEntryMeta, ContentType};
     use crate::scripts;
+    use crate::AppView;
+    use std::fs;
     use std::path::PathBuf;
     use std::sync::Arc;
 
@@ -189,6 +191,14 @@
         }
     }
 
+    fn read(path: &str) -> String {
+        fs::read_to_string(path).unwrap_or_else(|_| panic!("Failed to read {path}"))
+    }
+
+    fn count_occurrences(haystack: &str, needle: &str) -> usize {
+        haystack.match_indices(needle).count()
+    }
+
     #[test]
     fn test_select_clipboard_entry_meta_filters_and_clamps() {
         let entries = vec![entry("1", "Alpha"), entry("2", "Beta"), entry("3", "Gamma")];
@@ -364,4 +374,54 @@
             })
         );
     }
+
+    #[test]
+    fn test_edit_actions_show_error_feedback_when_editor_launch_fails() {
+        let content = read("src/app_actions/handle_action.rs");
+
+        assert!(
+            content.contains("fn launch_editor_with_feedback_async"),
+            "Expected async editor launch helper to exist"
+        );
+
+        let usage_count =
+            count_occurrences(&content, "self.launch_editor_with_feedback_async(&path)");
+        assert!(
+            usage_count >= 2,
+            "Expected edit_script and edit_scriptlet to use async editor launch feedback (found {usage_count} usages)"
+        );
+
+        assert!(
+            content.contains("this.show_hud(message, Some(3000), cx);"),
+            "Expected async editor launch failure to surface a HUD error message"
+        );
+    }
+
+    #[test]
+    fn test_reveal_actions_show_success_hud_after_async_completion() {
+        let content = read("src/app_actions/handle_action.rs");
+
+        assert!(
+            content.contains("fn reveal_in_finder_with_feedback_async"),
+            "Expected async reveal helper to exist"
+        );
+
+        let usage_count =
+            count_occurrences(&content, "self.reveal_in_finder_with_feedback_async(&path)")
+                + count_occurrences(&content, "self.reveal_in_finder_with_feedback_async(path)");
+        assert!(
+            usage_count >= 2,
+            "Expected reveal actions to use async reveal feedback helper (found {usage_count} usages)"
+        );
+
+        assert!(
+            content.contains("let Ok(reveal_result) = reveal_result_rx.recv().await else {"),
+            "Expected reveal actions to await reveal completion before showing HUD"
+        );
+
+        assert!(
+            content.contains("this.show_hud(\"Opened in Finder\".to_string(), Some(1500), cx);"),
+            "Expected reveal success HUD to be emitted from async completion callback"
+        );
+    }
 }
diff --git a/src/app_actions/tests/editor_launch_feedback.rs b/src/app_actions/tests/editor_launch_feedback.rs
deleted file mode 100644
index 18077766837c78518094e45c0da3b2a672b8bd8b..0000000000000000000000000000000000000000
--- a/src/app_actions/tests/editor_launch_feedback.rs
+++ /dev/null
@@ -1,62 +0,0 @@
-use std::fs;
-
-fn read(path: &str) -> String {
-    fs::read_to_string(path).unwrap_or_else(|_| panic!("Failed to read {path}"))
-}
-
-fn count_occurrences(haystack: &str, needle: &str) -> usize {
-    haystack.match_indices(needle).count()
-}
-
-#[test]
-fn test_edit_actions_show_error_feedback_when_editor_launch_fails() {
-    let content = read("src/app_actions/handle_action.rs");
-
-    assert!(
-        content.contains("fn launch_editor_with_feedback_async"),
-        "Expected async editor launch helper to exist"
-    );
-
-    let usage_count = count_occurrences(&content, "self.launch_editor_with_feedback_async(&path)");
-    assert!(
-        usage_count >= 2,
-        "Expected edit_script and edit_scriptlet to use async editor launch feedback (found {usage_count} usages)"
-    );
-
-    assert!(
-        content.contains("this.show_hud(message, Some(3000), cx);"),
-        "Expected async editor launch failure to surface a HUD error message"
-    );
-}
-
-#[test]
-fn test_reveal_actions_show_success_hud_after_async_reveal_completion() {
-    let content = read("src/app_actions/handle_action.rs");
-
-    assert!(
-        content.contains("fn reveal_in_finder_with_feedback_async"),
-        "Expected async reveal helper to exist"
-    );
-
-    let usage_count = count_occurrences(
-        &content,
-        "self.reveal_in_finder_with_feedback_async(&path)",
-    ) + count_occurrences(
-        &content,
-        "self.reveal_in_finder_with_feedback_async(path)",
-    );
-    assert!(
-        usage_count >= 2,
-        "Expected reveal actions to use async reveal feedback helper (found {usage_count} usages)"
-    );
-
-    assert!(
-        content.contains("let Ok(reveal_result) = reveal_result_rx.recv().await else {"),
-        "Expected reveal actions to await async reveal completion before showing HUD"
-    );
-
-    assert!(
-        content.contains("this.show_hud(\"Opened in Finder\".to_string(), Some(1500), cx);"),
-        "Expected reveal success HUD to be emitted from async completion callback"
-    );
-}


thinking
**Releasing claimed files and updating status**
codex
I’ve completed the code/test changes and am now releasing file claims and marking this agent done, with notes about the unrelated workspace-wide verification failures encountered during `check/clippy/test`.
exec
/bin/zsh -lc '~/.claude/bin/swarm.ts update --id codex-fix-editor-feedback --status done --notes "Implemented async editor/reveal feedback in handle_action; added regression tests in app_actions/helpers.rs. Verification commands blocked by unrelated workspace errors (protocol/design duplicate test modules and clipboard type changes)."' in /Users/johnlindquist/dev/script-kit-gpuiexec
/bin/zsh -lc '~/.claude/bin/swarm.ts release --id codex-fix-editor-feedback src/app_actions/handle_action.rs src/app_actions/helpers.rs src/app_actions/tests.rs src/app_actions/tests/editor_launch_feedback.rs' in /Users/johnlindquist/dev/script-kit-gpui succeeded in 51ms:
Updated: codex-fix-editor-feedback
 succeeded in 50ms:
Released for codex-fix-editor-feedback: src/app_actions/handle_action.rs, src/app_actions/helpers.rs, src/app_actions/tests.rs, src/app_actions/tests/editor_launch_feedback.rs
file update:
diff --git a/src/app_actions/handle_action.rs b/src/app_actions/handle_action.rs
index 6512e920f98eb38811debb5dca005d821b3adb44..a20dbbb8eae9367457a1e25e044924f8664e8dce
--- a/src/app_actions/handle_action.rs
+++ b/src/app_actions/handle_action.rs
@@ -27,11 +27,117 @@
 
             match crate::file_search::reveal_in_finder(&path_str) {
                 Ok(_) => logging::log("UI", &format!("Revealed in {}: {}", file_manager, path_str)),
-                Err(e) => logging::log("ERROR", &format!("Failed to reveal in {}: {}", file_manager, e)),
+                Err(e) => logging::log(
+                    "ERROR",
+                    &format!("Failed to reveal in {}: {}", file_manager, e),
+                ),
             }
         });
     }
 
+    /// Reveal a path and return completion back to the UI thread for HUD feedback.
+    fn reveal_in_finder_with_feedback_async(
+        &self,
+        path: &std::path::Path,
+    ) -> async_channel::Receiver<Result<(), String>> {
+        let path_str = path.to_string_lossy().to_string();
+        let (result_tx, result_rx) = async_channel::bounded::<Result<(), String>>(1);
+
+        std::thread::spawn(move || {
+            let file_manager = if cfg!(target_os = "macos") {
+                "Finder"
+            } else if cfg!(target_os = "windows") {
+                "Explorer"
+            } else {
+                "File Manager"
+            };
+
+            logging::log(
+                "UI",
+                &format!(
+                    "ACTION_REVEAL_IN_FINDER_START file_manager='{}' path='{}'",
+                    file_manager, path_str
+                ),
+            );
+
+            let reveal_result = match crate::file_search::reveal_in_finder(&path_str) {
+                Ok(()) => {
+                    logging::log(
+                        "UI",
+                        &format!(
+                            "ACTION_REVEAL_IN_FINDER_SUCCESS file_manager='{}' path='{}'",
+                            file_manager, path_str
+                        ),
+                    );
+                    Ok(())
+                }
+                Err(error) => {
+                    logging::log(
+                        "ERROR",
+                        &format!(
+                            "ACTION_REVEAL_IN_FINDER_FAILED attempted='reveal_in_finder' path='{}' file_manager='{}' error='{}'",
+                            path_str, file_manager, error
+                        ),
+                    );
+                    Err(format!("Failed to reveal in {}: {}", file_manager, error))
+                }
+            };
+
+            let _ = result_tx.send_blocking(reveal_result);
+        });
+
+        result_rx
+    }
+
+    /// Launch the configured editor and return completion back to the UI thread for HUD feedback.
+    fn launch_editor_with_feedback_async(
+        &self,
+        path: &std::path::Path,
+    ) -> async_channel::Receiver<Result<(), String>> {
+        let editor = self.config.get_editor();
+        let path_str = path.to_string_lossy().to_string();
+        let (result_tx, result_rx) = async_channel::bounded::<Result<(), String>>(1);
+
+        std::thread::spawn(move || {
+            use std::process::Command;
+
+            logging::log(
+                "UI",
+                &format!(
+                    "ACTION_EDITOR_LAUNCH_START editor='{}' path='{}'",
+                    editor, path_str
+                ),
+            );
+
+            let launch_result = match Command::new(&editor).arg(&path_str).spawn() {
+                Ok(_) => {
+                    logging::log(
+                        "UI",
+                        &format!(
+                            "ACTION_EDITOR_LAUNCH_SUCCESS editor='{}' path='{}'",
+                            editor, path_str
+                        ),
+                    );
+                    Ok(())
+                }
+                Err(error) => {
+                    logging::log(
+                        "ERROR",
+                        &format!(
+                            "ACTION_EDITOR_LAUNCH_FAILED attempted='{} {}' path='{}' error='{}'",
+                            editor, path_str, path_str, error
+                        ),
+                    );
+                    Err(format!("Failed to open in {}: {}", editor, error))
+                }
+            };
+
+            let _ = result_tx.send_blocking(launch_result);
+        });
+
+        result_rx
+    }
+
     /// Copy text to clipboard using pbcopy on macOS.
     /// Critical: This properly closes stdin before waiting to prevent hangs.
     #[cfg(target_os = "macos")]
@@ -471,9 +577,24 @@
                 };
 
                 if let Some(path) = path_opt {
-                    self.reveal_in_finder(&path);
-                    self.show_hud("Opened in Finder".to_string(), Some(1500), cx);
-                    self.hide_main_and_reset(cx);
+                    let reveal_result_rx = self.reveal_in_finder_with_feedback_async(&path);
+                    cx.spawn(async move |this, cx| {
+                        let Ok(reveal_result) = reveal_result_rx.recv().await else {
+                            return;
+                        };
+
+                        this.update(cx, |this, cx| match reveal_result {
+                            Ok(()) => {
+                                this.show_hud("Opened in Finder".to_string(), Some(1500), cx);
+                                this.hide_main_and_reset(cx);
+                            }
+                            Err(message) => {
+                                this.show_hud(message, Some(2500), cx);
+                            }
+                        })
+                        .ok();
+                    })
+                    .detach();
                 } else {
                     self.show_hud(
                         "Cannot reveal this item type in Finder".to_string(),
@@ -754,7 +875,6 @@
                 }
             }
             // Alias actions: add_alias, update_alias open the alias input
-
             "add_alias" | "update_alias" => {
                 logging::log("UI", &format!("{} action", action_id));
                 if let Some(result) = self.get_selected_result() {
@@ -884,8 +1004,23 @@
                     };
 
                     if let Some(path) = path_opt {
-                        self.edit_script(&path);
-                        self.hide_main_and_reset(cx);
+                        let editor_launch_rx = self.launch_editor_with_feedback_async(&path);
+                        cx.spawn(async move |this, cx| {
+                            let Ok(launch_result) = editor_launch_rx.recv().await else {
+                                return;
+                            };
+
+                            this.update(cx, |this, cx| match launch_result {
+                                Ok(()) => {
+                                    this.hide_main_and_reset(cx);
+                                }
+                                Err(message) => {
+                                    this.show_hud(message, Some(3000), cx);
+                                }
+                            })
+                            .ok();
+                        })
+                        .detach();
                     } else {
                         self.show_hud("Cannot edit this item type".to_string(), Some(2000), cx);
                     }
@@ -1096,7 +1231,6 @@
                 self.file_search_actions_path = None;
             }
             // File search specific actions
-
             "open_file" | "open_directory" | "quick_look" | "open_with" | "show_info" => {
                 if let Some(path) = self.file_search_actions_path.clone() {
                     logging::log("UI", &format!("File action '{}': {}", action_id, path));
@@ -1424,7 +1558,6 @@
                 }
             }
             // Clipboard delete actions
-
             "clipboard_delete_multiple" => {
                 let filter_text = match &self.current_view {
                     AppView::ClipboardHistoryView { filter, .. } => filter.trim().to_string(),
@@ -1932,8 +2065,23 @@
                             // Extract just the path without the anchor (e.g., "/path/to/file.md#slug" -> "/path/to/file.md")
                             let path_str = file_path.split('#').next().unwrap_or(file_path);
                             let path = std::path::PathBuf::from(path_str);
-                            self.edit_script(&path);
-                            self.hide_main_and_reset(cx);
+                            let editor_launch_rx = self.launch_editor_with_feedback_async(&path);
+                            cx.spawn(async move |this, cx| {
+                                let Ok(launch_result) = editor_launch_rx.recv().await else {
+                                    return;
+                                };
+
+                                this.update(cx, |this, cx| match launch_result {
+                                    Ok(()) => {
+                                        this.hide_main_and_reset(cx);
+                                    }
+                                    Err(message) => {
+                                        this.show_hud(message, Some(3000), cx);
+                                    }
+                                })
+                                .ok();
+                            })
+                            .detach();
                         } else {
                             self.show_hud(
                                 "Scriptlet has no source file path".to_string(),
@@ -1964,9 +2112,28 @@
                             // Extract just the path without the anchor
                             let path_str = file_path.split('#').next().unwrap_or(file_path);
                             let path = std::path::Path::new(path_str);
-                            self.reveal_in_finder(path);
-                            self.show_hud("Opened in Finder".to_string(), Some(1500), cx);
-                            self.hide_main_and_reset(cx);
+                            let reveal_result_rx = self.reveal_in_finder_with_feedback_async(path);
+                            cx.spawn(async move |this, cx| {
+                                let Ok(reveal_result) = reveal_result_rx.recv().await else {
+                                    return;
+                                };
+
+                                this.update(cx, |this, cx| match reveal_result {
+                                    Ok(()) => {
+                                        this.show_hud(
+                                            "Opened in Finder".to_string(),
+                                            Some(1500),
+                                            cx,
+                                        );
+                                        this.hide_main_and_reset(cx);
+                                    }
+                                    Err(message) => {
+                                        this.show_hud(message, Some(2500), cx);
+                                    }
+                                })
+                                .ok();
+                            })
+                            .detach();
                         } else {
                             self.show_hud(
                                 "Scriptlet has no source file path".to_string(),
diff --git a/src/app_actions/helpers.rs b/src/app_actions/helpers.rs
index fb50657be41d2650d4e4be37f320f8f2393149b1..d1ffdb92db3025e5830d2f16c0f3b05af0ff26c7
--- a/src/app_actions/helpers.rs
+++ b/src/app_actions/helpers.rs
@@ -166,12 +166,14 @@
     use super::{
         clipboard_pin_action_success_hud, extract_scriptlet_source_path,
         file_search_action_error_hud_prefix, file_search_action_success_hud,
+        script_removal_target_from_result, select_clipboard_entry_meta,
         selection_required_message_for_action, should_transition_to_script_list_after_action,
-        script_removal_target_from_result, select_clipboard_entry_meta, ScriptRemovalTarget,
+        ScriptRemovalTarget,
     };
-    use crate::AppView;
     use crate::clipboard_history::{ClipboardEntryMeta, ContentType};
     use crate::scripts;
+    use crate::AppView;
+    use std::fs;
     use std::path::PathBuf;
     use std::sync::Arc;
 
@@ -189,6 +191,14 @@
         }
     }
 
+    fn read(path: &str) -> String {
+        fs::read_to_string(path).unwrap_or_else(|_| panic!("Failed to read {path}"))
+    }
+
+    fn count_occurrences(haystack: &str, needle: &str) -> usize {
+        haystack.match_indices(needle).count()
+    }
+
     #[test]
     fn test_select_clipboard_entry_meta_filters_and_clamps() {
         let entries = vec![entry("1", "Alpha"), entry("2", "Beta"), entry("3", "Gamma")];
@@ -364,4 +374,54 @@
             })
         );
     }
+
+    #[test]
+    fn test_edit_actions_show_error_feedback_when_editor_launch_fails() {
+        let content = read("src/app_actions/handle_action.rs");
+
+        assert!(
+            content.contains("fn launch_editor_with_feedback_async"),
+            "Expected async editor launch helper to exist"
+        );
+
+        let usage_count =
+            count_occurrences(&content, "self.launch_editor_with_feedback_async(&path)");
+        assert!(
+            usage_count >= 2,
+            "Expected edit_script and edit_scriptlet to use async editor launch feedback (found {usage_count} usages)"
+        );
+
+        assert!(
+            content.contains("this.show_hud(message, Some(3000), cx);"),
+            "Expected async editor launch failure to surface a HUD error message"
+        );
+    }
+
+    #[test]
+    fn test_reveal_actions_show_success_hud_after_async_completion() {
+        let content = read("src/app_actions/handle_action.rs");
+
+        assert!(
+            content.contains("fn reveal_in_finder_with_feedback_async"),
+            "Expected async reveal helper to exist"
+        );
+
+        let usage_count =
+            count_occurrences(&content, "self.reveal_in_finder_with_feedback_async(&path)")
+                + count_occurrences(&content, "self.reveal_in_finder_with_feedback_async(path)");
+        assert!(
+            usage_count >= 2,
+            "Expected reveal actions to use async reveal feedback helper (found {usage_count} usages)"
+        );
+
+        assert!(
+            content.contains("let Ok(reveal_result) = reveal_result_rx.recv().await else {"),
+            "Expected reveal actions to await reveal completion before showing HUD"
+        );
+
+        assert!(
+            content.contains("this.show_hud(\"Opened in Finder\".to_string(), Some(1500), cx);"),
+            "Expected reveal success HUD to be emitted from async completion callback"
+        );
+    }
 }
diff --git a/src/app_actions/tests/editor_launch_feedback.rs b/src/app_actions/tests/editor_launch_feedback.rs
deleted file mode 100644
index 18077766837c78518094e45c0da3b2a672b8bd8b..0000000000000000000000000000000000000000
--- a/src/app_actions/tests/editor_launch_feedback.rs
+++ /dev/null
@@ -1,62 +0,0 @@
-use std::fs;
-
-fn read(path: &str) -> String {
-    fs::read_to_string(path).unwrap_or_else(|_| panic!("Failed to read {path}"))
-}
-
-fn count_occurrences(haystack: &str, needle: &str) -> usize {
-    haystack.match_indices(needle).count()
-}
-
-#[test]
-fn test_edit_actions_show_error_feedback_when_editor_launch_fails() {
-    let content = read("src/app_actions/handle_action.rs");
-
-    assert!(
-        content.contains("fn launch_editor_with_feedback_async"),
-        "Expected async editor launch helper to exist"
-    );
-
-    let usage_count = count_occurrences(&content, "self.launch_editor_with_feedback_async(&path)");
-    assert!(
-        usage_count >= 2,
-        "Expected edit_script and edit_scriptlet to use async editor launch feedback (found {usage_count} usages)"
-    );
-
-    assert!(
-        content.contains("this.show_hud(message, Some(3000), cx);"),
-        "Expected async editor launch failure to surface a HUD error message"
-    );
-}
-
-#[test]
-fn test_reveal_actions_show_success_hud_after_async_reveal_completion() {
-    let content = read("src/app_actions/handle_action.rs");
-
-    assert!(
-        content.contains("fn reveal_in_finder_with_feedback_async"),
-        "Expected async reveal helper to exist"
-    );
-
-    let usage_count = count_occurrences(
-        &content,
-        "self.reveal_in_finder_with_feedback_async(&path)",
-    ) + count_occurrences(
-        &content,
-        "self.reveal_in_finder_with_feedback_async(path)",
-    );
-    assert!(
-        usage_count >= 2,
-        "Expected reveal actions to use async reveal feedback helper (found {usage_count} usages)"
-    );
-
-    assert!(
-        content.contains("let Ok(reveal_result) = reveal_result_rx.recv().await else {"),
-        "Expected reveal actions to await async reveal completion before showing HUD"
-    );
-
-    assert!(
-        content.contains("this.show_hud(\"Opened in Finder\".to_string(), Some(1500), cx);"),
-        "Expected reveal success HUD to be emitted from async completion callback"
-    );
-}


thinking
**Summarizing verification and test results**
codex
**Changed files**
- `src/app_actions/handle_action.rs:39`  
  Added `reveal_in_finder_with_feedback_async(...)` and `launch_editor_with_feedback_async(...)` helpers that return async completion results to UI.
- `src/app_actions/handle_action.rs:558`  
  Updated `"reveal_in_finder"` to show success HUD only after async reveal completes; now shows error HUD on failure.
- `src/app_actions/handle_action.rs:993`  
  Updated `"edit_script"` to wait for async editor launch result; now shows error HUD when launch fails.
- `src/app_actions/handle_action.rs:2060`  
  Updated `"edit_scriptlet"` with the same async editor launch feedback flow.
- `src/app_actions/handle_action.rs:2107`  
  Updated `"reveal_scriptlet_in_finder"` to show success/error HUD from async completion.
- `src/app_actions/helpers.rs:379`  
  Added regression tests:
  - `test_edit_actions_show_error_feedback_when_editor_launch_fails`
  - `test_reveal_actions_show_success_hud_after_async_completion`

**Verification run**
- `cargo test --lib app_actions_tests:: -- --nocapture`  
  Failed due unrelated workspace conflict: duplicate module files (`src/protocol/message/tests.rs` and `src/protocol/message/tests/mod.rs`).
- `cargo check && cargo clippy --all-targets -- -D warnings`  
  `cargo check` failed before clippy due unrelated existing workspace errors (clipboard type/field mismatches and non-exhaustive matches).
- `cargo clippy --all-targets -- -D warnings`  
  Failed due many unrelated pre-existing workspace issues (duplicate test modules, missing imports in other test suites, clipboard/type regressions).

**How to test**
1. Set editor to an invalid command in config and trigger `edit_script` / `edit_scriptlet`; confirm HUD shows `Failed to open in <editor>: ...`.
2. Trigger `reveal_in_finder` / `reveal_scriptlet_in_finder`; confirm success HUD appears only after reveal operation completes.
3. After workspace compile issues are resolved, rerun:
   - `cargo check`
   - `cargo clippy --all-targets -- -D warnings`
   - `cargo test --lib app_actions_tests::`

**Risks / known gaps**
- Full compile/lint/test verification is currently blocked by unrelated parallel-agent changes in the shared tree.
- This fix targets `edit_script` and `edit_scriptlet` paths (plus reveal paths touched by m15); other `self.edit_script(...)` call sites keep existing behavior.
file update:
diff --git a/src/app_actions/handle_action.rs b/src/app_actions/handle_action.rs
index 6512e920f98eb38811debb5dca005d821b3adb44..a20dbbb8eae9367457a1e25e044924f8664e8dce
--- a/src/app_actions/handle_action.rs
+++ b/src/app_actions/handle_action.rs
@@ -27,11 +27,117 @@
 
             match crate::file_search::reveal_in_finder(&path_str) {
                 Ok(_) => logging::log("UI", &format!("Revealed in {}: {}", file_manager, path_str)),
-                Err(e) => logging::log("ERROR", &format!("Failed to reveal in {}: {}", file_manager, e)),
+                Err(e) => logging::log(
+                    "ERROR",
+                    &format!("Failed to reveal in {}: {}", file_manager, e),
+                ),
             }
         });
     }
 
+    /// Reveal a path and return completion back to the UI thread for HUD feedback.
+    fn reveal_in_finder_with_feedback_async(
+        &self,
+        path: &std::path::Path,
+    ) -> async_channel::Receiver<Result<(), String>> {
+        let path_str = path.to_string_lossy().to_string();
+        let (result_tx, result_rx) = async_channel::bounded::<Result<(), String>>(1);
+
+        std::thread::spawn(move || {
+            let file_manager = if cfg!(target_os = "macos") {
+                "Finder"
+            } else if cfg!(target_os = "windows") {
+                "Explorer"
+            } else {
+                "File Manager"
+            };
+
+            logging::log(
+                "UI",
+                &format!(
+                    "ACTION_REVEAL_IN_FINDER_START file_manager='{}' path='{}'",
+                    file_manager, path_str
+                ),
+            );
+
+            let reveal_result = match crate::file_search::reveal_in_finder(&path_str) {
+                Ok(()) => {
+                    logging::log(
+                        "UI",
+                        &format!(
+                            "ACTION_REVEAL_IN_FINDER_SUCCESS file_manager='{}' path='{}'",
+                            file_manager, path_str
+                        ),
+                    );
+                    Ok(())
+                }
+                Err(error) => {
+                    logging::log(
+                        "ERROR",
+                        &format!(
+                            "ACTION_REVEAL_IN_FINDER_FAILED attempted='reveal_in_finder' path='{}' file_manager='{}' error='{}'",
+                            path_str, file_manager, error
+                        ),
+                    );
+                    Err(format!("Failed to reveal in {}: {}", file_manager, error))
+                }
+            };
+
+            let _ = result_tx.send_blocking(reveal_result);
+        });
+
+        result_rx
+    }
+
+    /// Launch the configured editor and return completion back to the UI thread for HUD feedback.
+    fn launch_editor_with_feedback_async(
+        &self,
+        path: &std::path::Path,
+    ) -> async_channel::Receiver<Result<(), String>> {
+        let editor = self.config.get_editor();
+        let path_str = path.to_string_lossy().to_string();
+        let (result_tx, result_rx) = async_channel::bounded::<Result<(), String>>(1);
+
+        std::thread::spawn(move || {
+            use std::process::Command;
+
+            logging::log(
+                "UI",
+                &format!(
+                    "ACTION_EDITOR_LAUNCH_START editor='{}' path='{}'",
+                    editor, path_str
+                ),
+            );
+
+            let launch_result = match Command::new(&editor).arg(&path_str).spawn() {
+                Ok(_) => {
+                    logging::log(
+                        "UI",
+                        &format!(
+                            "ACTION_EDITOR_LAUNCH_SUCCESS editor='{}' path='{}'",
+                            editor, path_str
+                        ),
+                    );
+                    Ok(())
+                }
+                Err(error) => {
+                    logging::log(
+                        "ERROR",
+                        &format!(
+                            "ACTION_EDITOR_LAUNCH_FAILED attempted='{} {}' path='{}' error='{}'",
+                            editor, path_str, path_str, error
+                        ),
+                    );
+                    Err(format!("Failed to open in {}: {}", editor, error))
+                }
+            };
+
+            let _ = result_tx.send_blocking(launch_result);
+        });
+
+        result_rx
+    }
+
     /// Copy text to clipboard using pbcopy on macOS.
     /// Critical: This properly closes stdin before waiting to prevent hangs.
     #[cfg(target_os = "macos")]
@@ -471,9 +577,24 @@
                 };
 
                 if let Some(path) = path_opt {
-                    self.reveal_in_finder(&path);
-                    self.show_hud("Opened in Finder".to_string(), Some(1500), cx);
-                    self.hide_main_and_reset(cx);
+                    let reveal_result_rx = self.reveal_in_finder_with_feedback_async(&path);
+                    cx.spawn(async move |this, cx| {
+                        let Ok(reveal_result) = reveal_result_rx.recv().await else {
+                            return;
+                        };
+
+                        this.update(cx, |this, cx| match reveal_result {
+                            Ok(()) => {
+                                this.show_hud("Opened in Finder".to_string(), Some(1500), cx);
+                                this.hide_main_and_reset(cx);
+                            }
+                            Err(message) => {
+                                this.show_hud(message, Some(2500), cx);
+                            }
+                        })
+                        .ok();
+                    })
+                    .detach();
                 } else {
                     self.show_hud(
                         "Cannot reveal this item type in Finder".to_string(),
@@ -754,7 +875,6 @@
                 }
             }
             // Alias actions: add_alias, update_alias open the alias input
-
             "add_alias" | "update_alias" => {
                 logging::log("UI", &format!("{} action", action_id));
                 if let Some(result) = self.get_selected_result() {
@@ -884,8 +1004,23 @@
                     };
 
                     if let Some(path) = path_opt {
-                        self.edit_script(&path);
-                        self.hide_main_and_reset(cx);
+                        let editor_launch_rx = self.launch_editor_with_feedback_async(&path);
+                        cx.spawn(async move |this, cx| {
+                            let Ok(launch_result) = editor_launch_rx.recv().await else {
+                                return;
+                            };
+
+                            this.update(cx, |this, cx| match launch_result {
+                                Ok(()) => {
+                                    this.hide_main_and_reset(cx);
+                                }
+                                Err(message) => {
+                                    this.show_hud(message, Some(3000), cx);
+                                }
+                            })
+                            .ok();
+                        })
+                        .detach();
                     } else {
                         self.show_hud("Cannot edit this item type".to_string(), Some(2000), cx);
                     }
@@ -1096,7 +1231,6 @@
                 self.file_search_actions_path = None;
             }
             // File search specific actions
-
             "open_file" | "open_directory" | "quick_look" | "open_with" | "show_info" => {
                 if let Some(path) = self.file_search_actions_path.clone() {
                     logging::log("UI", &format!("File action '{}': {}", action_id, path));
@@ -1424,7 +1558,6 @@
                 }
             }
             // Clipboard delete actions
-
             "clipboard_delete_multiple" => {
                 let filter_text = match &self.current_view {
                     AppView::ClipboardHistoryView { filter, .. } => filter.trim().to_string(),
@@ -1932,8 +2065,23 @@
                             // Extract just the path without the anchor (e.g., "/path/to/file.md#slug" -> "/path/to/file.md")
                             let path_str = file_path.split('#').next().unwrap_or(file_path);
                             let path = std::path::PathBuf::from(path_str);
-                            self.edit_script(&path);
-                            self.hide_main_and_reset(cx);
+                            let editor_launch_rx = self.launch_editor_with_feedback_async(&path);
+                            cx.spawn(async move |this, cx| {
+                                let Ok(launch_result) = editor_launch_rx.recv().await else {
+                                    return;
+                                };
+
+                                this.update(cx, |this, cx| match launch_result {
+                                    Ok(()) => {
+                                        this.hide_main_and_reset(cx);
+                                    }
+                                    Err(message) => {
+                                        this.show_hud(message, Some(3000), cx);
+                                    }
+                                })
+                                .ok();
+                            })
+                            .detach();
                         } else {
                             self.show_hud(
                                 "Scriptlet has no source file path".to_string(),
@@ -1964,9 +2112,28 @@
                             // Extract just the path without the anchor
                             let path_str = file_path.split('#').next().unwrap_or(file_path);
                             let path = std::path::Path::new(path_str);
-                            self.reveal_in_finder(path);
-                            self.show_hud("Opened in Finder".to_string(), Some(1500), cx);
-                            self.hide_main_and_reset(cx);
+                            let reveal_result_rx = self.reveal_in_finder_with_feedback_async(path);
+                            cx.spawn(async move |this, cx| {
+                                let Ok(reveal_result) = reveal_result_rx.recv().await else {
+                                    return;
+                                };
+
+                                this.update(cx, |this, cx| match reveal_result {
+                                    Ok(()) => {
+                                        this.show_hud(
+                                            "Opened in Finder".to_string(),
+                                            Some(1500),
+                                            cx,
+                                        );
+                                        this.hide_main_and_reset(cx);
+                                    }
+                                    Err(message) => {
+                                        this.show_hud(message, Some(2500), cx);
+                                    }
+                                })
+                                .ok();
+                            })
+                            .detach();
                         } else {
                             self.show_hud(
                                 "Scriptlet has no source file path".to_string(),
diff --git a/src/app_actions/helpers.rs b/src/app_actions/helpers.rs
index fb50657be41d2650d4e4be37f320f8f2393149b1..d1ffdb92db3025e5830d2f16c0f3b05af0ff26c7
--- a/src/app_actions/helpers.rs
+++ b/src/app_actions/helpers.rs
@@ -166,12 +166,14 @@
     use super::{
         clipboard_pin_action_success_hud, extract_scriptlet_source_path,
         file_search_action_error_hud_prefix, file_search_action_success_hud,
+        script_removal_target_from_result, select_clipboard_entry_meta,
         selection_required_message_for_action, should_transition_to_script_list_after_action,
-        script_removal_target_from_result, select_clipboard_entry_meta, ScriptRemovalTarget,
+        ScriptRemovalTarget,
     };
-    use crate::AppView;
     use crate::clipboard_history::{ClipboardEntryMeta, ContentType};
     use crate::scripts;
+    use crate::AppView;
+    use std::fs;
     use std::path::PathBuf;
     use std::sync::Arc;
 
@@ -189,6 +191,14 @@
         }
     }
 
+    fn read(path: &str) -> String {
+        fs::read_to_string(path).unwrap_or_else(|_| panic!("Failed to read {path}"))
+    }
+
+    fn count_occurrences(haystack: &str, needle: &str) -> usize {
+        haystack.match_indices(needle).count()
+    }
+
     #[test]
     fn test_select_clipboard_entry_meta_filters_and_clamps() {
         let entries = vec![entry("1", "Alpha"), entry("2", "Beta"), entry("3", "Gamma")];
@@ -364,4 +374,54 @@
             })
         );
     }
+
+    #[test]
+    fn test_edit_actions_show_error_feedback_when_editor_launch_fails() {
+        let content = read("src/app_actions/handle_action.rs");
+
+        assert!(
+            content.contains("fn launch_editor_with_feedback_async"),
+            "Expected async editor launch helper to exist"
+        );
+
+        let usage_count =
+            count_occurrences(&content, "self.launch_editor_with_feedback_async(&path)");
+        assert!(
+            usage_count >= 2,
+            "Expected edit_script and edit_scriptlet to use async editor launch feedback (found {usage_count} usages)"
+        );
+
+        assert!(
+            content.contains("this.show_hud(message, Some(3000), cx);"),
+            "Expected async editor launch failure to surface a HUD error message"
+        );
+    }
+
+    #[test]
+    fn test_reveal_actions_show_success_hud_after_async_completion() {
+        let content = read("src/app_actions/handle_action.rs");
+
+        assert!(
+            content.contains("fn reveal_in_finder_with_feedback_async"),
+            "Expected async reveal helper to exist"
+        );
+
+        let usage_count =
+            count_occurrences(&content, "self.reveal_in_finder_with_feedback_async(&path)")
+                + count_occurrences(&content, "self.reveal_in_finder_with_feedback_async(path)");
+        assert!(
+            usage_count >= 2,
+            "Expected reveal actions to use async reveal feedback helper (found {usage_count} usages)"
+        );
+
+        assert!(
+            content.contains("let Ok(reveal_result) = reveal_result_rx.recv().await else {"),
+            "Expected reveal actions to await reveal completion before showing HUD"
+        );
+
+        assert!(
+            content.contains("this.show_hud(\"Opened in Finder\".to_string(), Some(1500), cx);"),
+            "Expected reveal success HUD to be emitted from async completion callback"
+        );
+    }
 }
diff --git a/src/app_actions/tests/editor_launch_feedback.rs b/src/app_actions/tests/editor_launch_feedback.rs
deleted file mode 100644
index 18077766837c78518094e45c0da3b2a672b8bd8b..0000000000000000000000000000000000000000
--- a/src/app_actions/tests/editor_launch_feedback.rs
+++ /dev/null
@@ -1,62 +0,0 @@
-use std::fs;
-
-fn read(path: &str) -> String {
-    fs::read_to_string(path).unwrap_or_else(|_| panic!("Failed to read {path}"))
-}
-
-fn count_occurrences(haystack: &str, needle: &str) -> usize {
-    haystack.match_indices(needle).count()
-}
-
-#[test]
-fn test_edit_actions_show_error_feedback_when_editor_launch_fails() {
-    let content = read("src/app_actions/handle_action.rs");
-
-    assert!(
-        content.contains("fn launch_editor_with_feedback_async"),
-        "Expected async editor launch helper to exist"
-    );
-
-    let usage_count = count_occurrences(&content, "self.launch_editor_with_feedback_async(&path)");
-    assert!(
-        usage_count >= 2,
-        "Expected edit_script and edit_scriptlet to use async editor launch feedback (found {usage_count} usages)"
-    );
-
-    assert!(
-        content.contains("this.show_hud(message, Some(3000), cx);"),
-        "Expected async editor launch failure to surface a HUD error message"
-    );
-}
-
-#[test]
-fn test_reveal_actions_show_success_hud_after_async_reveal_completion() {
-    let content = read("src/app_actions/handle_action.rs");
-
-    assert!(
-        content.contains("fn reveal_in_finder_with_feedback_async"),
-        "Expected async reveal helper to exist"
-    );
-
-    let usage_count = count_occurrences(
-        &content,
-        "self.reveal_in_finder_with_feedback_async(&path)",
-    ) + count_occurrences(
-        &content,
-        "self.reveal_in_finder_with_feedback_async(path)",
-    );
-    assert!(
-        usage_count >= 2,
-        "Expected reveal actions to use async reveal feedback helper (found {usage_count} usages)"
-    );
-
-    assert!(
-        content.contains("let Ok(reveal_result) = reveal_result_rx.recv().await else {"),
-        "Expected reveal actions to await async reveal completion before showing HUD"
-    );
-
-    assert!(
-        content.contains("this.show_hud(\"Opened in Finder\".to_string(), Some(1500), cx);"),
-        "Expected reveal success HUD to be emitted from async completion callback"
-    );
-}

tokens used
204,996
**Changed files**
- `src/app_actions/handle_action.rs:39`  
  Added `reveal_in_finder_with_feedback_async(...)` and `launch_editor_with_feedback_async(...)` helpers that return async completion results to UI.
- `src/app_actions/handle_action.rs:558`  
  Updated `"reveal_in_finder"` to show success HUD only after async reveal completes; now shows error HUD on failure.
- `src/app_actions/handle_action.rs:993`  
  Updated `"edit_script"` to wait for async editor launch result; now shows error HUD when launch fails.
- `src/app_actions/handle_action.rs:2060`  
  Updated `"edit_scriptlet"` with the same async editor launch feedback flow.
- `src/app_actions/handle_action.rs:2107`  
  Updated `"reveal_scriptlet_in_finder"` to show success/error HUD from async completion.
- `src/app_actions/helpers.rs:379`  
  Added regression tests:
  - `test_edit_actions_show_error_feedback_when_editor_launch_fails`
  - `test_reveal_actions_show_success_hud_after_async_completion`

**Verification run**
- `cargo test --lib app_actions_tests:: -- --nocapture`  
  Failed due unrelated workspace conflict: duplicate module files (`src/protocol/message/tests.rs` and `src/protocol/message/tests/mod.rs`).
- `cargo check && cargo clippy --all-targets -- -D warnings`  
  `cargo check` failed before clippy due unrelated existing workspace errors (clipboard type/field mismatches and non-exhaustive matches).
- `cargo clippy --all-targets -- -D warnings`  
  Failed due many unrelated pre-existing workspace issues (duplicate test modules, missing imports in other test suites, clipboard/type regressions).

**How to test**
1. Set editor to an invalid command in config and trigger `edit_script` / `edit_scriptlet`; confirm HUD shows `Failed to open in <editor>: ...`.
2. Trigger `reveal_in_finder` / `reveal_scriptlet_in_finder`; confirm success HUD appears only after reveal operation completes.
3. After workspace compile issues are resolved, rerun:
   - `cargo check`
   - `cargo clippy --all-targets -- -D warnings`
   - `cargo test --lib app_actions_tests::`

**Risks / known gaps**
- Full compile/lint/test verification is currently blocked by unrelated parallel-agent changes in the shared tree.
- This fix targets `edit_script` and `edit_scriptlet` paths (plus reveal paths touched by m15); other `self.edit_script(...)` call sites keep existing behavior.


==== exit @ 2026-02-07T23:52:58.049Z code=0 status=done ====
