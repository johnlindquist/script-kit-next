==== spawn @ 2026-02-08T00:13:55.689Z ====
cmd: codex "exec" "--cd" "/Users/johnlindquist/dev/script-kit-gpui" "--model" "gpt-5.3-codex" "-c" "model_reasoning_effort=\"xhigh\"" "-c" "model_auto_compact_token_limit=120000" "-c" "developer_instructions=\"You are Codex implementer agent \\\"codex-fix-builder-error-consistency\\\".\\n\\n## Coordination\\nThis repo runs parallel agents in ONE working tree. Before editing any file, you MUST claim it.\\nCommands (run via shell):\\n  - View roster: ~/.claude/bin/swarm.ts status\\n  - Claim files (blocks until free): ~/.claude/bin/swarm.ts claim --wait --id codex-fix-builder-error-consistency path/to/file\\n  - Release: ~/.claude/bin/swarm.ts release --id codex-fix-builder-error-consistency path/to/file\\n  - Update status/notes: ~/.claude/bin/swarm.ts update --id codex-fix-builder-error-consistency --status in_progress --notes \\\"...\\\"\\nRules:\\n  - Never edit a file you haven't claimed.\\n  - Keep claims tight (claim only what you're actively changing).\\n  - If blocked, set status=blocked and say what you're waiting on.\\n  - When finished, set status=done and release claims.\\n\\n## Development practices (this code is maintained by AI agents)\\n  - Log state transitions with enough context to diagnose failures from logs alone.\\n  - Structured errors: include what was attempted, what failed, and current state.\\n  - Name things for grepability — unique identifiers agents can find on the first search.\\n  - Every behavior change gets a test. Untested code is invisible to the next agent.\\n  - Test names describe the scenario: test_X_does_Y_when_Z.\\n  - Keep functions small and single-purpose. 500-line functions burn agent context.\\n  - Use types to encode constraints (enums > strings for errors).\\n\\n## CRITICAL: Parallel-safe verification\\n  - Other agents are modifying other files RIGHT NOW. Full test suites WILL show their failures.\\n  - ONLY run tests that cover YOUR changed files. Scope every test/check command:\\n    Rust: cargo test -p your-crate -- module::test_name | JS: npx jest your/file.test.ts\\n  - Do NOT run: cargo test (unscoped), cargo check (whole workspace), npm test (unscoped).\\n  - If a scoped test fails, it's YOUR bug — fix it. If tests outside your scope fail, ignore them.\\n\\n## Git commit discipline\\n  - NEVER commit unverified work. Run tests/lints/type-checks FIRST. If it fails, fix it before committing.\\n  - A commit is a declaration: \\\"this works and here's the proof.\\\"\\n  - Commit FREQUENTLY — after each meaningful unit of VERIFIED work, not just at the end.\\n  - A \\\"unit\\\" = one logical change that passes verification (new function, bug fix, refactor, test added).\\n  - NEVER batch an entire task into one giant commit. Small commits are searchable; big ones aren't.\\n  - Commit message format:\\n      Line 1: <type>(<scope>): <what changed> (imperative, max 72 chars)\\n      Line 3+: WHY this change was made, WHAT was verified, and HOW to test it.\\n    Types: feat, fix, refactor, test, docs, chore\\n    Example:\\n      feat(auth): add refresh token rotation\\n      \\n      Tokens now rotate on each refresh call to prevent replay attacks.\\n      The old token is invalidated immediately on rotation.\\n      \\n      Verified: cargo test --lib -- auth::refresh (4 tests pass)\\n      Verified: manual smoke test via curl — token rotates, old token returns 401\\n  - The \\\"Verified:\\\" lines are REQUIRED. Future agents will read git log to understand\\n    what was tested and how to re-verify. This is the most valuable part of the message.\\n  - In your final message, list all commits you made with their hashes.\\n\\n## Time budget\\nYou have approximately 10 minutes. If your task is too broad to complete in time:\\n(1) Commit any verified progress.\\n(2) Run: ~/.claude/bin/swarm.ts update --id YOUR_ID --status needs_split --notes 'suggest: 1) sub-task-desc scope:files 2) sub-task-desc scope:files'.\\n(3) Exit cleanly. The dispatcher will read your suggestions and spawn narrower workers.\"" "--output-last-message" "/Users/johnlindquist/dev/script-kit-gpui/.ai/logs/codex-fix-builder-error-consistency.final.md" "--yolo" "You are agent codex-fix-builder-error-consistency.\n\nCurrent parallel-agent roster (read this first):\n```\nSWARM SNAPSHOT @ 2026-02-08T00:13:55.686Z\n- codex-fix-action-id-namespace [in_progress] scope=src/actions/builders/file_path.rs,src/actions/builders/clipboard.rs,src/actions/builders/chat.rs task=CONSISTENCY FIX: Action IDs can overlap across different builder functions. Add namespace prefixes to action IDs by bui…\n  claims: src/actions/builders/file_path.rs, src/actions/builders/clipboard.rs, src/actions/builders/chat.rs, src/app_actions/handle_action.rs, src/app_impl/execution_paths.rs, src/app_impl/chat_actions.rs, sr…\n  notes: auditing action ids and handlers in scoped builders for namespacing\n- codex-fix-builder-error-consistency [starting] scope=src/actions/builders/chat.rs,src/actions/builders/clipboard.rs,src/actions/builders/file_path.rs task=CONSISTENCY FIX: Make error handling consistent across all action builders. Currently some builders silently return emp…\n- codex-fix-scriptlet-dedup [in_progress] scope=src/actions/builders/scriptlet.rs task=MINOR FIX: In src/actions/builders/scriptlet.rs, two scriptlet H3 actions that resolve to the same command string produ…\n  claims: src/actions/builders/scriptlet.rs\n  notes: claiming scriptlet builder and auditing dedup + parse w…\n```\n\nYour assignment:\n- Task: CONSISTENCY FIX: Make error handling consistent across all action builders. Currently some builders silently return empty Vec on error, others panic. Ensure ALL builders in src/actions/builders/ follow the same pattern: (1) Return empty Vec with tracing::warn when input data is invalid/missing (2) Never panic/unwrap (3) Log at consistent levels. Review and fix: chat.rs, clipboard.rs, file_path.rs, notes.rs, script_context.rs, scriptlet.rs. After fix, run cargo check && cargo clippy --all-targets -- -D warnings\n- Scope: src/actions/builders/chat.rs,src/actions/builders/clipboard.rs,src/actions/builders/file_path.rs\n\nOperating constraints:\n- Single working tree (no worktrees, no patches).\n- You MUST claim files before editing (~/.claude/bin/swarm.ts claim --wait ...).\n\nDeliverables:\n- Make the code changes required by the task.\n- Run the most relevant tests/linters.\n- In your FINAL message, include: changed files, how to test, and any risks/known gaps."

OpenAI Codex v0.98.0 (research preview)
--------
workdir: /Users/johnlindquist/dev/script-kit-gpui
model: gpt-5.3-codex
provider: openai
approval: never
sandbox: danger-full-access
reasoning effort: xhigh
reasoning summaries: auto
session id: 019c3a99-109c-7f73-b8a1-34eb709e30d6
--------
user
You are agent codex-fix-builder-error-consistency.

Current parallel-agent roster (read this first):
```
SWARM SNAPSHOT @ 2026-02-08T00:13:55.686Z
- codex-fix-action-id-namespace [in_progress] scope=src/actions/builders/file_path.rs,src/actions/builders/clipboard.rs,src/actions/builders/chat.rs task=CONSISTENCY FIX: Action IDs can overlap across different builder functions. Add namespace prefixes to action IDs by bui…
  claims: src/actions/builders/file_path.rs, src/actions/builders/clipboard.rs, src/actions/builders/chat.rs, src/app_actions/handle_action.rs, src/app_impl/execution_paths.rs, src/app_impl/chat_actions.rs, sr…
  notes: auditing action ids and handlers in scoped builders for namespacing
- codex-fix-builder-error-consistency [starting] scope=src/actions/builders/chat.rs,src/actions/builders/clipboard.rs,src/actions/builders/file_path.rs task=CONSISTENCY FIX: Make error handling consistent across all action builders. Currently some builders silently return emp…
- codex-fix-scriptlet-dedup [in_progress] scope=src/actions/builders/scriptlet.rs task=MINOR FIX: In src/actions/builders/scriptlet.rs, two scriptlet H3 actions that resolve to the same command string produ…
  claims: src/actions/builders/scriptlet.rs
  notes: claiming scriptlet builder and auditing dedup + parse w…
```

Your assignment:
- Task: CONSISTENCY FIX: Make error handling consistent across all action builders. Currently some builders silently return empty Vec on error, others panic. Ensure ALL builders in src/actions/builders/ follow the same pattern: (1) Return empty Vec with tracing::warn when input data is invalid/missing (2) Never panic/unwrap (3) Log at consistent levels. Review and fix: chat.rs, clipboard.rs, file_path.rs, notes.rs, script_context.rs, scriptlet.rs. After fix, run cargo check && cargo clippy --all-targets -- -D warnings
- Scope: src/actions/builders/chat.rs,src/actions/builders/clipboard.rs,src/actions/builders/file_path.rs

Operating constraints:
- Single working tree (no worktrees, no patches).
- You MUST claim files before editing (~/.claude/bin/swarm.ts claim --wait ...).

Deliverables:
- Make the code changes required by the task.
- Run the most relevant tests/linters.
- In your FINAL message, include: changed files, how to test, and any risks/known gaps.
warning: Under-development features enabled: responses_websockets. Under-development features are incomplete and may behave unpredictably. To suppress this warning, set `suppress_unstable_features_warning = true` in /Users/johnlindquist/.codex/config.toml.
mcp: deepwiki starting
mcp: deepwiki ready
mcp startup: ready: deepwiki

thinking
**Confirming file claims and scope**
codex
I’m taking the builder error-consistency task for `chat.rs`, `clipboard.rs`, and `file_path.rs`. I’ll first check swarm status and acquire claims on those files before auditing current error-handling patterns.
exec
/bin/zsh -lc '~/.claude/bin/swarm.ts status' in /Users/johnlindquist/dev/script-kit-gpui succeeded in 51ms:
Repo: /Users/johnlindquist/dev/script-kit-gpui
Updated: 2026-02-08T00:14:09.051Z

Active agents (3):
codex-fix-action-id-namespace [in_progress] codex/gpt-5.3-codex/exec
  task: CONSISTENCY FIX: Action IDs can overlap across different builder functions. Add namespace prefixes to action IDs by bui…
  scope: src/actions/builders/file_path.rs,src/actions/builders/clipboard.rs,src/actions/builders/chat.rs
  claims(7): src/actions/builders/file_path.rs, src/actions/builders/clipboard.rs, src/actions/builders/chat.rs, src/app_actions/handle_action.rs, src/app_impl/execution_pa…
  notes: auditing action ids and handlers in scoped builders for namespacing

codex-fix-builder-error-consistency [in_progress] codex/gpt-5.3-codex/exec
  task: CONSISTENCY FIX: Make error handling consistent across all action builders. Currently some builders silently return emp…
  scope: src/actions/builders/chat.rs,src/actions/builders/clipboard.rs,src/actions/builders/file_path.rs
  claims: (none)
  notes: spawned codex (exec)

codex-fix-scriptlet-dedup [in_progress] codex/gpt-5.3-codex/exec
  task: MINOR FIX: In src/actions/builders/scriptlet.rs, two scriptlet H3 actions that resolve to the same command string produ…
  scope: src/actions/builders/scriptlet.rs
  claims(1): src/actions/builders/scriptlet.rs

thinking
**Handling file claim blocking**
codex
Current blocker: those three builder files are actively claimed by another agent. I’m updating swarm notes and waiting on claims so we don’t conflict.
exec
/bin/zsh -lc '~/.claude/bin/swarm.ts update --id codex-fix-builder-error-consistency --status blocked --notes "waiting for claims on chat/clipboard/file_path builders currently held by codex-fix-action-id-namespace"' in /Users/johnlindquist/dev/script-kit-gpui succeeded in 51ms:
Updated: codex-fix-builder-error-consistency
exec
/bin/zsh -lc '~/.claude/bin/swarm.ts claim --wait --id codex-fix-builder-error-consistency src/actions/builders/chat.rs src/actions/builders/clipboard.rs src/actions/builders/file_path.rs' in /Users/johnlindquist/dev/script-kit-gpui
thinking
**Planning periodic polling and commentary**
codex
I’m blocked on the claim lock and waiting for the other agent to release these files. I’ll proceed immediately once the claim command returns.

thinking
**Waiting for process completion**

thinking
**Planning delayed commentary insertion**
codex
Still waiting on lock acquisition for `chat.rs`, `clipboard.rs`, and `file_path.rs`. As soon as claims are granted, I’ll audit and patch all three in one pass.

thinking
**Continuing polling operation**
codex
Lock wait is still active; no claim output yet. I’ll keep polling and start edits immediately once the claim command completes.
codex
I’m still blocked waiting on claims from the namespacing agent. Once released, I’ll run a targeted audit for `unwrap`/panic and inconsistent invalid-input logging in those builders.
codex
No claim completion yet; I’m keeping the wait open to avoid racing edits in the shared tree. I’ll post a concrete edit plan as soon as file ownership is acquired.
codex
The claim wait is still pending. If this continues much longer, I’ll sync swarm status again to confirm current holder state.

thinking
**Considering asynchronous status checks**
exec
/bin/zsh -lc '~/.claude/bin/swarm.ts status' in /Users/johnlindquist/dev/script-kit-gpui succeeded in 51ms:
Repo: /Users/johnlindquist/dev/script-kit-gpui
Updated: 2026-02-08T00:16:25.537Z

Active agents (4):
codex-fix-action-id-namespace [in_progress] codex/gpt-5.3-codex/exec
  task: CONSISTENCY FIX: Action IDs can overlap across different builder functions. Add namespace prefixes to action IDs by bui…
  scope: src/actions/builders/file_path.rs,src/actions/builders/clipboard.rs,src/actions/builders/chat.rs
  claims(7): src/actions/builders/file_path.rs, src/actions/builders/clipboard.rs, src/actions/builders/chat.rs, src/app_actions/handle_action.rs, src/app_impl/execution_pa…
  notes: auditing action ids and handlers in scoped builders for namespacing | [claim-wait] codex-fix-builder-error-consistency waiting for src/actions/builders/chat.rs

codex-fix-builder-error-consistency [blocked] codex/gpt-5.3-codex/exec
  task: CONSISTENCY FIX: Make error handling consistent across all action builders. Currently some builders silently return emp…
  scope: src/actions/builders/chat.rs,src/actions/builders/clipboard.rs,src/actions/builders/file_path.rs
  claims: (none)
  notes: waiting for claims on chat/clipboard/file_path builders currently held by codex-fix-action-id-namespace

codex-fix-builder-error-consistency-2 [in_progress] codex/gpt-5.3-codex/exec
  task: CONSISTENCY FIX: Make error handling consistent across action builders part 2. Ensure builders in src/actions/builders/…
  scope: src/actions/builders/notes.rs,src/actions/builders/script_context.rs,src/actions/builders/scriptlet.rs
  claims(2): src/actions/builders/notes.rs, src/actions/builders/script_context.rs

thinking
**Monitoring claim status while preparing**
codex
Status confirms the files are still held by the namespacing agent, so I’m continuing to wait on the queued claim. Once ownership transfers, I’ll do the full consistency sweep and verification immediately.
codex
Claim wait remains active with no release yet. I’m holding position to avoid overlapping edits in those same builder files.
codex
I’m still queued on the file lock; no ownership transfer has happened yet. If this drags on, I’ll reassess whether we should split around the namespacing edits.

thinking
**Checking agent status**
exec
/bin/zsh -lc '~/.claude/bin/swarm.ts status' in /Users/johnlindquist/dev/script-kit-gpui succeeded in 50ms:
Repo: /Users/johnlindquist/dev/script-kit-gpui
Updated: 2026-02-08T00:17:20.711Z

Active agents (3):
codex-fix-action-id-namespace [in_progress] codex/gpt-5.3-codex/exec
  task: CONSISTENCY FIX: Action IDs can overlap across different builder functions. Add namespace prefixes to action IDs by bui…
  scope: src/actions/builders/file_path.rs,src/actions/builders/clipboard.rs,src/actions/builders/chat.rs
  claims(7): src/actions/builders/file_path.rs, src/actions/builders/clipboard.rs, src/actions/builders/chat.rs, src/app_actions/handle_action.rs, src/app_impl/execution_pa…
  notes: namespaced Action::new IDs added in file_path/clipboard/chat; validating handler compatibility and running cargo check/clippy | [claim-wait] codex-fix-builder-error-consistency wa…

codex-fix-builder-error-consistency [blocked] codex/gpt-5.3-codex/exec
  task: CONSISTENCY FIX: Make error handling consistent across all action builders. Currently some builders silently return emp…
  scope: src/actions/builders/chat.rs,src/actions/builders/clipboard.rs,src/actions/builders/file_path.rs
  claims: (none)
  notes: waiting for claims on chat/clipboard/file_path builders currently held by codex-fix-action-id-namespace

codex-fix-builder-error-consistency-2 [in_progress] codex/gpt-5.3-codex/exec
  task: CONSISTENCY FIX: Make error handling consistent across action builders part 2. Ensure builders in src/actions/builders/…
  scope: src/actions/builders/notes.rs,src/actions/builders/script_context.rs,src/actions/builders/scriptlet.rs
  claims(2): src/actions/builders/notes.rs, src/actions/builders/script_context.rs

thinking
**Waiting on build completion**

thinking
**Planning periodic commentary updates**
codex
The namespacing agent is now in validation, so release should be near; I’m still waiting on the claim lock and ready to start immediately after transfer.
codex
No lock handoff yet. I’m continuing to poll and will post a concrete change plan as soon as claims are acquired.

thinking
**Confirming task completion**
 succeeded in 4m 05s:
Claimed for codex-fix-builder-error-consistency: src/actions/builders/chat.rs, src/actions/builders/clipboard.rs, src/actions/builders/file_path.rs

thinking
**Updating commentary and status**
codex
Claims are now acquired for all three files, so I’m starting the audit for invalid-input handling, panic/unwrap usage, and logging consistency across these builders.
exec
/bin/zsh -lc '~/.claude/bin/swarm.ts update --id codex-fix-builder-error-consistency --status in_progress --notes "claimed chat/clipboard/file_path; auditing for invalid input handling, unwrap/panic elimination, and consistent warn-level logging"' in /Users/johnlindquist/dev/script-kit-gpui succeeded in 51ms:
Updated: codex-fix-builder-error-consistency

thinking
**Preparing parallel file inspection**
exec
/bin/zsh -lc 'nl -ba src/actions/builders/chat.rs' in /Users/johnlindquist/dev/script-kit-gpuiexec
/bin/zsh -lc 'nl -ba src/actions/builders/file_path.rs' in /Users/johnlindquist/dev/script-kit-gpuiexec
/bin/zsh -lc 'nl -ba src/actions/builders/clipboard.rs' in /Users/johnlindquist/dev/script-kit-gpui succeeded in 51ms:
     1	use super::types::{Action, ActionCategory};
     2	use crate::designs::icon_variations::IconName;
     3	
     4	/// Information about a chat prompt for action building
     5	#[derive(Debug, Clone)]
     6	pub struct ChatPromptInfo {
     7	    pub current_model: Option<String>,
     8	    pub available_models: Vec<ChatModelInfo>,
     9	    pub has_messages: bool,
    10	    pub has_response: bool,
    11	}
    12	
    13	/// Information about an available chat model
    14	#[derive(Debug, Clone)]
    15	pub struct ChatModelInfo {
    16	    pub id: String,
    17	    pub display_name: String,
    18	    pub provider: String,
    19	}
    20	
 succeeded in 50ms:
     1	use super::types::{Action, ActionCategory};
     2	use crate::file_search::FileInfo;
     3	use crate::prompts::PathInfo;
     4	
     5	/// Get actions specific to a file search result
     6	///
     7	/// Actions vary based on whether the item is a file or directory:
     8	/// - Directory: `file:open_directory` as primary
     9	/// - File: `file:open_file` as primary, plus Quick Look (macOS)
    10	///
    11	/// Common actions for both: file:reveal_in_finder, file:copy_path, file:copy_filename
    12	pub fn get_file_context_actions(file_info: &FileInfo) -> Vec<Action> {
    13	    let mut actions = Vec::new();
    14	
    15	    tracing::debug!(
    16	        target: "script_kit::actions",
    17	        name = %file_info.name,
    18	        is_dir = file_info.is_dir,
    19	        "Building file context actions"
    20	    );
 succeeded in 50ms:
     1	use super::types::{Action, ActionCategory};
     2	use crate::clipboard_history::ContentType;
     3	
     4	/// Information about a clipboard history entry for action building
     5	#[derive(Debug, Clone)]
     6	pub struct ClipboardEntryInfo {
     7	    /// Entry ID in the database
     8	    pub id: String,
     9	    /// Content type (text or image)
    10	    pub content_type: ContentType,
    11	    /// Whether the entry is pinned
    12	    pub pinned: bool,
    13	    /// Preview text (for text entries)
    14	    pub preview: String,
    15	    /// Image dimensions (for image entries)
    16	    #[allow(dead_code)]
    17	    pub image_dimensions: Option<(u32, u32)>,
    18	    /// Name of the frontmost app (for "Paste to [AppName]" action title)
    19	    pub frontmost_app_name: Option<String>,
    20	}

thinking
**Assessing error handling consistency**
codex
I have the files and I’m now mapping a shared validation/logging pattern before editing, so the three builders behave identically on bad input. I’ll compare against existing builder warning style to keep levels and fields consistent.
exec
/bin/zsh -lc "rg -n \"tracing::warn|invalid|missing|return Vec::new|unwrap\\(|expect\\(|panic"'!" src/actions/builders/*.rs' in /Users/johnlindquist/dev/script-kit-gpui succeeded in 51ms:
src/actions/builders/file_path.rs:131:            .expect("missing open_with action");
src/actions/builders/scriptlet.rs:20:        tracing::warn!(
src/actions/builders/notes.rs:206:            .expect("missing copy_note_as action");
src/actions/builders/notes.rs:210:            .expect("missing export action");
src/actions/builders/notes.rs:236:            .expect("missing copy_deeplink action");
src/actions/builders/notes.rs:254:            .expect("missing restore_note action");
src/actions/builders/notes.rs:258:            .expect("missing permanently_delete_note action");
src/actions/builders/notes.rs:363:            .expect("missing preset action");
src/actions/builders/script_context.rs:294:        tracing::warn!(

thinking
**Planning targeted inspection of warning code**
exec
/bin/zsh -lc "nl -ba src/actions/builders/scriptlet.rs | sed -n '1,120p'" in /Users/johnlindquist/dev/script-kit-gpuiexec
/bin/zsh -lc "nl -ba src/actions/builders/script_context.rs | sed -n '250,360p'" in /Users/johnlindquist/dev/script-kit-gpui succeeded in 50ms:
     1	use super::shared::{format_shortcut_hint, to_deeplink_name};
     2	use super::types::{Action, ActionCategory, ScriptInfo};
     3	use crate::scriptlets::Scriptlet;
     4	use std::collections::HashSet;
     5	
     6	const SCRIPTLET_ACTION_ID_PREFIX: &str = "scriptlet_action:";
     7	
     8	fn parse_scriptlet_action_command(action_id: &str) -> Option<&str> {
     9	    action_id
    10	        .strip_prefix(SCRIPTLET_ACTION_ID_PREFIX)
    11	        .filter(|command| !command.trim().is_empty())
    12	}
    13	
    14	fn unique_scriptlet_action_id(
    15	    raw_action_id: &str,
    16	    action_name: &str,
    17	    used_action_ids: &mut HashSet<String>,
    18	) -> Option<String> {
    19	    let Some(action_command) = parse_scriptlet_action_command(raw_action_id) else {
    20	        tracing::warn!(
 succeeded in 51ms:
   250	    let deeplink_name = to_deeplink_name(&script.name);
   251	    actions.push(
   252	        Action::new(
   253	            "copy_deeplink",
   254	            "Copy Deeplink",
   255	            Some(format!(
   256	                "Copy scriptkit://run/{} URL to clipboard",
   257	                deeplink_name
   258	            )),
   259	            ActionCategory::ScriptContext,
   260	        )
   261	        .with_shortcut("⌘⇧D")
   262	        .with_section("Share"),
   263	    );
   264	
   265	    if script.is_suggested {
   266	        destructive_actions.push(
   267	            Action::new(
   268	                "reset_ranking",
   269	                "Reset Ranking",

thinking
**Inspecting FileInfo struct**
exec
/bin/zsh -lc 'rg -n "pub struct FileInfo|pub struct PathInfo|pub struct ClipboardEntryInfo|pub struct ChatPromptInfo" src -n' in /Users/johnlindquist/dev/script-kit-gpui succeeded in 51ms:
src/file_search/part_000.rs:24:pub struct FileInfo {
src/actions/builders/chat.rs:6:pub struct ChatPromptInfo {
src/actions/builders/clipboard.rs:6:pub struct ClipboardEntryInfo {
src/prompts/path/types.rs:20:pub struct PathInfo {

thinking
**Inspecting file search structures**
exec
/bin/zsh -lc "nl -ba src/file_search/part_000.rs | sed -n '1,120p'" in /Users/johnlindquist/dev/script-kit-gpuiexec
/bin/zsh -lc "nl -ba src/prompts/path/types.rs | sed -n '1,120p'" in /Users/johnlindquist/dev/script-kit-gpui succeeded in 50ms:
     1	use std::io::{BufRead, BufReader};
     2	use std::path::Path;
     3	use std::process::{Child, Command, Stdio};
     4	use std::sync::atomic::{AtomicBool, Ordering};
     5	use std::sync::Arc;
     6	use std::time::UNIX_EPOCH;
     7	use tracing::{debug, instrument, warn};
     8	/// File type classification based on extension
     9	#[derive(Debug, Clone, Copy, PartialEq, Eq, Default)]
    10	pub enum FileType {
    11	    File,
    12	    Directory,
    13	    Application,
    14	    Image,
    15	    Document,
    16	    Audio,
    17	    Video,
    18	    #[default]
    19	    Other,
    20	}
 succeeded in 51ms:
     1	use super::*;
     2	
     3	/// Callback for prompt submission
     4	/// Signature: (id: String, value: Option<String>)
     5	pub type SubmitCallback = Arc<dyn Fn(String, Option<String>) + Send + Sync>;
     6	
     7	/// Events emitted by PathPrompt for parent handling
     8	/// Uses GPUI's EventEmitter pattern instead of mutex polling
     9	#[derive(Debug, Clone)]
    10	pub enum PathPromptEvent {
    11	    /// Request to show actions dialog for the given path
    12	    ShowActions(PathInfo),
    13	    /// Request to close actions dialog
    14	    CloseActions,
    15	}
    16	
    17	/// Information about a file/folder path for context-aware actions
    18	/// Used for path-specific actions in the actions dialog
    19	#[derive(Debug, Clone)]
    20	pub struct PathInfo {

thinking
**Planning builder validation**
exec
/bin/zsh -lc 'git status --short' in /Users/johnlindquist/dev/script-kit-gpui succeeded in 52ms:
 M .ai/logs/codex-audit-act-description-quality-v2.final.md
 M .ai/logs/codex-audit-act-execution-builtin.final.md
 M .ai/logs/codex-audit-act-execution-scripts.final.md
 M .ai/logs/codex-audit-act-keyboard-nav.final.md
 M .ai/logs/codex-audit-act-section-grouping.final.md
 M .ai/logs/codex-audit-act-theme-dialog-render.final.md
 M .ai/roster.json
 M src/actions/builders/chat.rs
 M src/actions/builders/clipboard.rs
 M src/actions/builders/file_path.rs
 M src/actions/builders/notes.rs
 M src/actions/builders/scriptlet.rs
 M src/actions/builders/shared.rs
 M src/actions/command_bar/part_01.rs
 M src/actions/command_bar/part_02.rs
 M src/actions/constants.rs
 M src/actions/dialog/part_01.rs
 M src/actions/dialog/part_02/part_01.rs
 M src/actions/dialog/part_02/part_03.rs
 M src/actions/dialog/part_04/body_part_02.rs

thinking
**Planning validation and testing additions**
codex
Plan for this pass:
1. Add upfront input validators in `chat.rs`, `clipboard.rs`, and `file_path.rs` that treat missing required fields as invalid and immediately return `Vec::new()` with `tracing::warn!(target = "script_kit::actions", ...)`.
2. Keep successful-path logging at `debug` and avoid introducing any `unwrap`/panic in production code.
3. Add focused tests in each file to lock the new behavior (`returns empty when input missing/invalid`), then run scoped verification with `cargo check -p script-kit-gpui` and `cargo clippy -p script-kit-gpui --all-targets -- -D warnings`.

thinking
**Planning input validation edits**
codex
I’m now patching the three claimed builders with upfront validation guards and warn-level logs, then I’ll add targeted tests for the new “invalid input returns empty actions” behavior.

thinking
**Patching chat module**
file update
M /Users/johnlindquist/dev/script-kit-gpui/src/actions/builders/chat.rs
@@ -20,4 +20,43 @@
 
+fn has_missing_chat_model_fields(model: &ChatModelInfo) -> bool {
+    model.id.trim().is_empty()
+        || model.display_name.trim().is_empty()
+        || model.provider.trim().is_empty()
+}
+
 /// Get actions specific to a chat prompt.
 pub fn get_chat_context_actions(info: &ChatPromptInfo) -> Vec<Action> {
+    let has_blank_current_model = info
+        .current_model
+        .as_ref()
+        .map(|model| model.trim().is_empty())
+        .unwrap_or(false);
+    if has_blank_current_model {
+        tracing::warn!(
+            target: "script_kit::actions",
+            model_count = info.available_models.len(),
+            has_messages = info.has_messages,
+            has_response = info.has_response,
+            "Invalid chat prompt info: current model name is blank; returning no actions"
+        );
+        return Vec::new();
+    }
+
+    let invalid_model_count = info
+        .available_models
+        .iter()
+        .filter(|model| has_missing_chat_model_fields(model))
+        .count();
+    if invalid_model_count > 0 {
+        tracing::warn!(
+            target: "script_kit::actions",
+            invalid_model_count,
+            model_count = info.available_models.len(),
+            has_messages = info.has_messages,
+            has_response = info.has_response,
+            "Invalid chat prompt info: model metadata missing required fields; returning no actions"
+        );
+        return Vec::new();
+    }
+
     let mut actions = Vec::new();
@@ -229,2 +268,22 @@
     }
+
+    #[test]
+    fn test_get_chat_context_actions_returns_empty_when_model_metadata_missing() {
+        let mut info = sample_prompt_info();
+        info.available_models[0].id = "   ".to_string();
+
+        let actions = get_chat_context_actions(&info);
+
+        assert!(actions.is_empty());
+    }
+
+    #[test]
+    fn test_get_chat_context_actions_returns_empty_when_current_model_is_blank() {
+        let mut info = sample_prompt_info();
+        info.current_model = Some("   ".to_string());
+
+        let actions = get_chat_context_actions(&info);
+
+        assert!(actions.is_empty());
+    }
 }
apply_patch(auto_approved=true) exited 0 in 12ms:
Success. Updated the following files:
M src/actions/builders/chat.rs
file update:
diff --git a/src/actions/builders/chat.rs b/src/actions/builders/chat.rs
index 5bf8650ab171d725e5b79d58333b2ecfad8edb3a..b62991e4ebf542501b6178b3eba85c14f273305a
--- a/src/actions/builders/chat.rs
+++ b/src/actions/builders/chat.rs
@@ -18,8 +18,47 @@
     pub provider: String,
 }
 
+fn has_missing_chat_model_fields(model: &ChatModelInfo) -> bool {
+    model.id.trim().is_empty()
+        || model.display_name.trim().is_empty()
+        || model.provider.trim().is_empty()
+}
+
 /// Get actions specific to a chat prompt.
 pub fn get_chat_context_actions(info: &ChatPromptInfo) -> Vec<Action> {
+    let has_blank_current_model = info
+        .current_model
+        .as_ref()
+        .map(|model| model.trim().is_empty())
+        .unwrap_or(false);
+    if has_blank_current_model {
+        tracing::warn!(
+            target: "script_kit::actions",
+            model_count = info.available_models.len(),
+            has_messages = info.has_messages,
+            has_response = info.has_response,
+            "Invalid chat prompt info: current model name is blank; returning no actions"
+        );
+        return Vec::new();
+    }
+
+    let invalid_model_count = info
+        .available_models
+        .iter()
+        .filter(|model| has_missing_chat_model_fields(model))
+        .count();
+    if invalid_model_count > 0 {
+        tracing::warn!(
+            target: "script_kit::actions",
+            invalid_model_count,
+            model_count = info.available_models.len(),
+            has_messages = info.has_messages,
+            has_response = info.has_response,
+            "Invalid chat prompt info: model metadata missing required fields; returning no actions"
+        );
+        return Vec::new();
+    }
+
     let mut actions = Vec::new();
 
     for model in &info.available_models {
@@ -227,4 +266,24 @@
         let actions = get_ai_command_bar_actions();
         assert!(actions.iter().all(|action| action.id.starts_with("chat:")));
     }
+
+    #[test]
+    fn test_get_chat_context_actions_returns_empty_when_model_metadata_missing() {
+        let mut info = sample_prompt_info();
+        info.available_models[0].id = "   ".to_string();
+
+        let actions = get_chat_context_actions(&info);
+
+        assert!(actions.is_empty());
+    }
+
+    #[test]
+    fn test_get_chat_context_actions_returns_empty_when_current_model_is_blank() {
+        let mut info = sample_prompt_info();
+        info.current_model = Some("   ".to_string());
+
+        let actions = get_chat_context_actions(&info);
+
+        assert!(actions.is_empty());
+    }
 }

file update:
diff --git a/src/actions/builders/chat.rs b/src/actions/builders/chat.rs
index 5bf8650ab171d725e5b79d58333b2ecfad8edb3a..b62991e4ebf542501b6178b3eba85c14f273305a
--- a/src/actions/builders/chat.rs
+++ b/src/actions/builders/chat.rs
@@ -18,8 +18,47 @@
     pub provider: String,
 }
 
+fn has_missing_chat_model_fields(model: &ChatModelInfo) -> bool {
+    model.id.trim().is_empty()
+        || model.display_name.trim().is_empty()
+        || model.provider.trim().is_empty()
+}
+
 /// Get actions specific to a chat prompt.
 pub fn get_chat_context_actions(info: &ChatPromptInfo) -> Vec<Action> {
+    let has_blank_current_model = info
+        .current_model
+        .as_ref()
+        .map(|model| model.trim().is_empty())
+        .unwrap_or(false);
+    if has_blank_current_model {
+        tracing::warn!(
+            target: "script_kit::actions",
+            model_count = info.available_models.len(),
+            has_messages = info.has_messages,
+            has_response = info.has_response,
+            "Invalid chat prompt info: current model name is blank; returning no actions"
+        );
+        return Vec::new();
+    }
+
+    let invalid_model_count = info
+        .available_models
+        .iter()
+        .filter(|model| has_missing_chat_model_fields(model))
+        .count();
+    if invalid_model_count > 0 {
+        tracing::warn!(
+            target: "script_kit::actions",
+            invalid_model_count,
+            model_count = info.available_models.len(),
+            has_messages = info.has_messages,
+            has_response = info.has_response,
+            "Invalid chat prompt info: model metadata missing required fields; returning no actions"
+        );
+        return Vec::new();
+    }
+
     let mut actions = Vec::new();
 
     for model in &info.available_models {
@@ -227,4 +266,24 @@
         let actions = get_ai_command_bar_actions();
         assert!(actions.iter().all(|action| action.id.starts_with("chat:")));
     }
+
+    #[test]
+    fn test_get_chat_context_actions_returns_empty_when_model_metadata_missing() {
+        let mut info = sample_prompt_info();
+        info.available_models[0].id = "   ".to_string();
+
+        let actions = get_chat_context_actions(&info);
+
+        assert!(actions.is_empty());
+    }
+
+    #[test]
+    fn test_get_chat_context_actions_returns_empty_when_current_model_is_blank() {
+        let mut info = sample_prompt_info();
+        info.current_model = Some("   ".to_string());
+
+        let actions = get_chat_context_actions(&info);
+
+        assert!(actions.is_empty());
+    }
 }


thinking
**Patching clipboard integration**
file update
M /Users/johnlindquist/dev/script-kit-gpui/src/actions/builders/clipboard.rs
@@ -24,2 +24,12 @@
 pub fn get_clipboard_history_context_actions(entry: &ClipboardEntryInfo) -> Vec<Action> {
+    if entry.id.trim().is_empty() {
+        tracing::warn!(
+            target: "script_kit::actions",
+            content_type = ?entry.content_type,
+            pinned = entry.pinned,
+            "Invalid clipboard entry context: missing entry id; returning no actions"
+        );
+        return Vec::new();
+    }
+
     let mut actions = Vec::new();
@@ -256,2 +266,12 @@
     }
+
+    #[test]
+    fn test_get_clipboard_history_context_actions_returns_empty_when_entry_id_missing() {
+        let mut entry = entry_info(ContentType::Text, false);
+        entry.id = "   ".to_string();
+
+        let actions = get_clipboard_history_context_actions(&entry);
+
+        assert!(actions.is_empty());
+    }
 }
apply_patch(auto_approved=true) exited 0 in 16ms:
Success. Updated the following files:
M src/actions/builders/clipboard.rs
file update:
diff --git a/src/actions/builders/chat.rs b/src/actions/builders/chat.rs
index 5bf8650ab171d725e5b79d58333b2ecfad8edb3a..b62991e4ebf542501b6178b3eba85c14f273305a
--- a/src/actions/builders/chat.rs
+++ b/src/actions/builders/chat.rs
@@ -18,8 +18,47 @@
     pub provider: String,
 }
 
+fn has_missing_chat_model_fields(model: &ChatModelInfo) -> bool {
+    model.id.trim().is_empty()
+        || model.display_name.trim().is_empty()
+        || model.provider.trim().is_empty()
+}
+
 /// Get actions specific to a chat prompt.
 pub fn get_chat_context_actions(info: &ChatPromptInfo) -> Vec<Action> {
+    let has_blank_current_model = info
+        .current_model
+        .as_ref()
+        .map(|model| model.trim().is_empty())
+        .unwrap_or(false);
+    if has_blank_current_model {
+        tracing::warn!(
+            target: "script_kit::actions",
+            model_count = info.available_models.len(),
+            has_messages = info.has_messages,
+            has_response = info.has_response,
+            "Invalid chat prompt info: current model name is blank; returning no actions"
+        );
+        return Vec::new();
+    }
+
+    let invalid_model_count = info
+        .available_models
+        .iter()
+        .filter(|model| has_missing_chat_model_fields(model))
+        .count();
+    if invalid_model_count > 0 {
+        tracing::warn!(
+            target: "script_kit::actions",
+            invalid_model_count,
+            model_count = info.available_models.len(),
+            has_messages = info.has_messages,
+            has_response = info.has_response,
+            "Invalid chat prompt info: model metadata missing required fields; returning no actions"
+        );
+        return Vec::new();
+    }
+
     let mut actions = Vec::new();
 
     for model in &info.available_models {
@@ -227,4 +266,24 @@
         let actions = get_ai_command_bar_actions();
         assert!(actions.iter().all(|action| action.id.starts_with("chat:")));
     }
+
+    #[test]
+    fn test_get_chat_context_actions_returns_empty_when_model_metadata_missing() {
+        let mut info = sample_prompt_info();
+        info.available_models[0].id = "   ".to_string();
+
+        let actions = get_chat_context_actions(&info);
+
+        assert!(actions.is_empty());
+    }
+
+    #[test]
+    fn test_get_chat_context_actions_returns_empty_when_current_model_is_blank() {
+        let mut info = sample_prompt_info();
+        info.current_model = Some("   ".to_string());
+
+        let actions = get_chat_context_actions(&info);
+
+        assert!(actions.is_empty());
+    }
 }
diff --git a/src/actions/builders/clipboard.rs b/src/actions/builders/clipboard.rs
index 61c4fac2f27aae73b516b1b487482f96e2cd8c56..dc0dd0b3d0d84f9ae8b851d7cb80caf6de122d89
--- a/src/actions/builders/clipboard.rs
+++ b/src/actions/builders/clipboard.rs
@@ -22,6 +22,16 @@
 /// Get actions specific to a clipboard history entry.
 #[allow(clippy::vec_init_then_push)]
 pub fn get_clipboard_history_context_actions(entry: &ClipboardEntryInfo) -> Vec<Action> {
+    if entry.id.trim().is_empty() {
+        tracing::warn!(
+            target: "script_kit::actions",
+            content_type = ?entry.content_type,
+            pinned = entry.pinned,
+            "Invalid clipboard entry context: missing entry id; returning no actions"
+        );
+        return Vec::new();
+    }
+
     let mut actions = Vec::new();
 
     tracing::debug!(
@@ -254,4 +264,14 @@
             .iter()
             .all(|action| action.id.starts_with("clip:")));
     }
+
+    #[test]
+    fn test_get_clipboard_history_context_actions_returns_empty_when_entry_id_missing() {
+        let mut entry = entry_info(ContentType::Text, false);
+        entry.id = "   ".to_string();
+
+        let actions = get_clipboard_history_context_actions(&entry);
+
+        assert!(actions.is_empty());
+    }
 }

file update:
diff --git a/src/actions/builders/chat.rs b/src/actions/builders/chat.rs
index 5bf8650ab171d725e5b79d58333b2ecfad8edb3a..b62991e4ebf542501b6178b3eba85c14f273305a
--- a/src/actions/builders/chat.rs
+++ b/src/actions/builders/chat.rs
@@ -18,8 +18,47 @@
     pub provider: String,
 }
 
+fn has_missing_chat_model_fields(model: &ChatModelInfo) -> bool {
+    model.id.trim().is_empty()
+        || model.display_name.trim().is_empty()
+        || model.provider.trim().is_empty()
+}
+
 /// Get actions specific to a chat prompt.
 pub fn get_chat_context_actions(info: &ChatPromptInfo) -> Vec<Action> {
+    let has_blank_current_model = info
+        .current_model
+        .as_ref()
+        .map(|model| model.trim().is_empty())
+        .unwrap_or(false);
+    if has_blank_current_model {
+        tracing::warn!(
+            target: "script_kit::actions",
+            model_count = info.available_models.len(),
+            has_messages = info.has_messages,
+            has_response = info.has_response,
+            "Invalid chat prompt info: current model name is blank; returning no actions"
+        );
+        return Vec::new();
+    }
+
+    let invalid_model_count = info
+        .available_models
+        .iter()
+        .filter(|model| has_missing_chat_model_fields(model))
+        .count();
+    if invalid_model_count > 0 {
+        tracing::warn!(
+            target: "script_kit::actions",
+            invalid_model_count,
+            model_count = info.available_models.len(),
+            has_messages = info.has_messages,
+            has_response = info.has_response,
+            "Invalid chat prompt info: model metadata missing required fields; returning no actions"
+        );
+        return Vec::new();
+    }
+
     let mut actions = Vec::new();
 
     for model in &info.available_models {
@@ -227,4 +266,24 @@
         let actions = get_ai_command_bar_actions();
         assert!(actions.iter().all(|action| action.id.starts_with("chat:")));
     }
+
+    #[test]
+    fn test_get_chat_context_actions_returns_empty_when_model_metadata_missing() {
+        let mut info = sample_prompt_info();
+        info.available_models[0].id = "   ".to_string();
+
+        let actions = get_chat_context_actions(&info);
+
+        assert!(actions.is_empty());
+    }
+
+    #[test]
+    fn test_get_chat_context_actions_returns_empty_when_current_model_is_blank() {
+        let mut info = sample_prompt_info();
+        info.current_model = Some("   ".to_string());
+
+        let actions = get_chat_context_actions(&info);
+
+        assert!(actions.is_empty());
+    }
 }
diff --git a/src/actions/builders/clipboard.rs b/src/actions/builders/clipboard.rs
index 61c4fac2f27aae73b516b1b487482f96e2cd8c56..dc0dd0b3d0d84f9ae8b851d7cb80caf6de122d89
--- a/src/actions/builders/clipboard.rs
+++ b/src/actions/builders/clipboard.rs
@@ -22,6 +22,16 @@
 /// Get actions specific to a clipboard history entry.
 #[allow(clippy::vec_init_then_push)]
 pub fn get_clipboard_history_context_actions(entry: &ClipboardEntryInfo) -> Vec<Action> {
+    if entry.id.trim().is_empty() {
+        tracing::warn!(
+            target: "script_kit::actions",
+            content_type = ?entry.content_type,
+            pinned = entry.pinned,
+            "Invalid clipboard entry context: missing entry id; returning no actions"
+        );
+        return Vec::new();
+    }
+
     let mut actions = Vec::new();
 
     tracing::debug!(
@@ -254,4 +264,14 @@
             .iter()
             .all(|action| action.id.starts_with("clip:")));
     }
+
+    #[test]
+    fn test_get_clipboard_history_context_actions_returns_empty_when_entry_id_missing() {
+        let mut entry = entry_info(ContentType::Text, false);
+        entry.id = "   ".to_string();
+
+        let actions = get_clipboard_history_context_actions(&entry);
+
+        assert!(actions.is_empty());
+    }
 }


thinking
**Preparing careful patch**
file update
M /Users/johnlindquist/dev/script-kit-gpui/src/actions/builders/file_path.rs
@@ -4,2 +4,6 @@
 
+fn has_missing_file_context_fields(name: &str, path: &str) -> bool {
+    name.trim().is_empty() || path.trim().is_empty()
+}
+
 /// Get actions specific to a file search result
@@ -12,2 +16,13 @@
 pub fn get_file_context_actions(file_info: &FileInfo) -> Vec<Action> {
+    if has_missing_file_context_fields(&file_info.name, &file_info.path) {
+        tracing::warn!(
+            target: "script_kit::actions",
+            name = %file_info.name,
+            path = %file_info.path,
+            is_dir = file_info.is_dir,
+            "Invalid file context info: missing path or name; returning no actions"
+        );
+        return Vec::new();
+    }
+
     let mut actions = Vec::new();
@@ -142,2 +157,13 @@
 pub fn get_path_context_actions(path_info: &PathInfo) -> Vec<Action> {
+    if has_missing_file_context_fields(&path_info.name, &path_info.path) {
+        tracing::warn!(
+            target: "script_kit::actions",
+            name = %path_info.name,
+            path = %path_info.path,
+            is_dir = path_info.is_dir,
+            "Invalid path context info: missing path or name; returning no actions"
+        );
+        return Vec::new();
+    }
+
     let mut actions = vec![
@@ -267,2 +293,22 @@
     }
+
+    #[test]
+    fn test_get_file_context_actions_returns_empty_when_required_fields_missing() {
+        let mut file_info = sample_file_info(false);
+        file_info.path = "   ".to_string();
+
+        let actions = get_file_context_actions(&file_info);
+
+        assert!(actions.is_empty());
+    }
+
+    #[test]
+    fn test_get_path_context_actions_returns_empty_when_required_fields_missing() {
+        let mut path_info = sample_path_info(true);
+        path_info.name = "   ".to_string();
+
+        let actions = get_path_context_actions(&path_info);
+
+        assert!(actions.is_empty());
+    }
 }
apply_patch(auto_approved=true) exited 0 in 23ms:
Success. Updated the following files:
M src/actions/builders/file_path.rs
file update:
diff --git a/src/actions/builders/chat.rs b/src/actions/builders/chat.rs
index 5bf8650ab171d725e5b79d58333b2ecfad8edb3a..b62991e4ebf542501b6178b3eba85c14f273305a
--- a/src/actions/builders/chat.rs
+++ b/src/actions/builders/chat.rs
@@ -18,8 +18,47 @@
     pub provider: String,
 }
 
+fn has_missing_chat_model_fields(model: &ChatModelInfo) -> bool {
+    model.id.trim().is_empty()
+        || model.display_name.trim().is_empty()
+        || model.provider.trim().is_empty()
+}
+
 /// Get actions specific to a chat prompt.
 pub fn get_chat_context_actions(info: &ChatPromptInfo) -> Vec<Action> {
+    let has_blank_current_model = info
+        .current_model
+        .as_ref()
+        .map(|model| model.trim().is_empty())
+        .unwrap_or(false);
+    if has_blank_current_model {
+        tracing::warn!(
+            target: "script_kit::actions",
+            model_count = info.available_models.len(),
+            has_messages = info.has_messages,
+            has_response = info.has_response,
+            "Invalid chat prompt info: current model name is blank; returning no actions"
+        );
+        return Vec::new();
+    }
+
+    let invalid_model_count = info
+        .available_models
+        .iter()
+        .filter(|model| has_missing_chat_model_fields(model))
+        .count();
+    if invalid_model_count > 0 {
+        tracing::warn!(
+            target: "script_kit::actions",
+            invalid_model_count,
+            model_count = info.available_models.len(),
+            has_messages = info.has_messages,
+            has_response = info.has_response,
+            "Invalid chat prompt info: model metadata missing required fields; returning no actions"
+        );
+        return Vec::new();
+    }
+
     let mut actions = Vec::new();
 
     for model in &info.available_models {
@@ -227,4 +266,24 @@
         let actions = get_ai_command_bar_actions();
         assert!(actions.iter().all(|action| action.id.starts_with("chat:")));
     }
+
+    #[test]
+    fn test_get_chat_context_actions_returns_empty_when_model_metadata_missing() {
+        let mut info = sample_prompt_info();
+        info.available_models[0].id = "   ".to_string();
+
+        let actions = get_chat_context_actions(&info);
+
+        assert!(actions.is_empty());
+    }
+
+    #[test]
+    fn test_get_chat_context_actions_returns_empty_when_current_model_is_blank() {
+        let mut info = sample_prompt_info();
+        info.current_model = Some("   ".to_string());
+
+        let actions = get_chat_context_actions(&info);
+
+        assert!(actions.is_empty());
+    }
 }
diff --git a/src/actions/builders/clipboard.rs b/src/actions/builders/clipboard.rs
index 61c4fac2f27aae73b516b1b487482f96e2cd8c56..dc0dd0b3d0d84f9ae8b851d7cb80caf6de122d89
--- a/src/actions/builders/clipboard.rs
+++ b/src/actions/builders/clipboard.rs
@@ -22,6 +22,16 @@
 /// Get actions specific to a clipboard history entry.
 #[allow(clippy::vec_init_then_push)]
 pub fn get_clipboard_history_context_actions(entry: &ClipboardEntryInfo) -> Vec<Action> {
+    if entry.id.trim().is_empty() {
+        tracing::warn!(
+            target: "script_kit::actions",
+            content_type = ?entry.content_type,
+            pinned = entry.pinned,
+            "Invalid clipboard entry context: missing entry id; returning no actions"
+        );
+        return Vec::new();
+    }
+
     let mut actions = Vec::new();
 
     tracing::debug!(
@@ -254,4 +264,14 @@
             .iter()
             .all(|action| action.id.starts_with("clip:")));
     }
+
+    #[test]
+    fn test_get_clipboard_history_context_actions_returns_empty_when_entry_id_missing() {
+        let mut entry = entry_info(ContentType::Text, false);
+        entry.id = "   ".to_string();
+
+        let actions = get_clipboard_history_context_actions(&entry);
+
+        assert!(actions.is_empty());
+    }
 }
diff --git a/src/actions/builders/file_path.rs b/src/actions/builders/file_path.rs
index dfc224185994ff07cf51b25248e26ba16a11b56b..ac82caac18f27e7215572e0e859f856c2aa8291f
--- a/src/actions/builders/file_path.rs
+++ b/src/actions/builders/file_path.rs
@@ -2,6 +2,10 @@
 use crate::file_search::FileInfo;
 use crate::prompts::PathInfo;
 
+fn has_missing_file_context_fields(name: &str, path: &str) -> bool {
+    name.trim().is_empty() || path.trim().is_empty()
+}
+
 /// Get actions specific to a file search result
 ///
 /// Actions vary based on whether the item is a file or directory:
@@ -10,6 +14,17 @@
 ///
 /// Common actions for both: file:reveal_in_finder, file:copy_path, file:copy_filename
 pub fn get_file_context_actions(file_info: &FileInfo) -> Vec<Action> {
+    if has_missing_file_context_fields(&file_info.name, &file_info.path) {
+        tracing::warn!(
+            target: "script_kit::actions",
+            name = %file_info.name,
+            path = %file_info.path,
+            is_dir = file_info.is_dir,
+            "Invalid file context info: missing path or name; returning no actions"
+        );
+        return Vec::new();
+    }
+
     let mut actions = Vec::new();
 
     tracing::debug!(
@@ -140,6 +155,17 @@
 
 /// Get actions specific to a file/folder path
 pub fn get_path_context_actions(path_info: &PathInfo) -> Vec<Action> {
+    if has_missing_file_context_fields(&path_info.name, &path_info.path) {
+        tracing::warn!(
+            target: "script_kit::actions",
+            name = %path_info.name,
+            path = %path_info.path,
+            is_dir = path_info.is_dir,
+            "Invalid path context info: missing path or name; returning no actions"
+        );
+        return Vec::new();
+    }
+
     let mut actions = vec![
         Action::new(
             "file:copy_path",
@@ -265,4 +291,24 @@
             .iter()
             .all(|action| action.id.starts_with("file:")));
     }
+
+    #[test]
+    fn test_get_file_context_actions_returns_empty_when_required_fields_missing() {
+        let mut file_info = sample_file_info(false);
+        file_info.path = "   ".to_string();
+
+        let actions = get_file_context_actions(&file_info);
+
+        assert!(actions.is_empty());
+    }
+
+    #[test]
+    fn test_get_path_context_actions_returns_empty_when_required_fields_missing() {
+        let mut path_info = sample_path_info(true);
+        path_info.name = "   ".to_string();
+
+        let actions = get_path_context_actions(&path_info);
+
+        assert!(actions.is_empty());
+    }
 }

file update:
diff --git a/src/actions/builders/chat.rs b/src/actions/builders/chat.rs
index 5bf8650ab171d725e5b79d58333b2ecfad8edb3a..b62991e4ebf542501b6178b3eba85c14f273305a
--- a/src/actions/builders/chat.rs
+++ b/src/actions/builders/chat.rs
@@ -18,8 +18,47 @@
     pub provider: String,
 }
 
+fn has_missing_chat_model_fields(model: &ChatModelInfo) -> bool {
+    model.id.trim().is_empty()
+        || model.display_name.trim().is_empty()
+        || model.provider.trim().is_empty()
+}
+
 /// Get actions specific to a chat prompt.
 pub fn get_chat_context_actions(info: &ChatPromptInfo) -> Vec<Action> {
+    let has_blank_current_model = info
+        .current_model
+        .as_ref()
+        .map(|model| model.trim().is_empty())
+        .unwrap_or(false);
+    if has_blank_current_model {
+        tracing::warn!(
+            target: "script_kit::actions",
+            model_count = info.available_models.len(),
+            has_messages = info.has_messages,
+            has_response = info.has_response,
+            "Invalid chat prompt info: current model name is blank; returning no actions"
+        );
+        return Vec::new();
+    }
+
+    let invalid_model_count = info
+        .available_models
+        .iter()
+        .filter(|model| has_missing_chat_model_fields(model))
+        .count();
+    if invalid_model_count > 0 {
+        tracing::warn!(
+            target: "script_kit::actions",
+            invalid_model_count,
+            model_count = info.available_models.len(),
+            has_messages = info.has_messages,
+            has_response = info.has_response,
+            "Invalid chat prompt info: model metadata missing required fields; returning no actions"
+        );
+        return Vec::new();
+    }
+
     let mut actions = Vec::new();
 
     for model in &info.available_models {
@@ -227,4 +266,24 @@
         let actions = get_ai_command_bar_actions();
         assert!(actions.iter().all(|action| action.id.starts_with("chat:")));
     }
+
+    #[test]
+    fn test_get_chat_context_actions_returns_empty_when_model_metadata_missing() {
+        let mut info = sample_prompt_info();
+        info.available_models[0].id = "   ".to_string();
+
+        let actions = get_chat_context_actions(&info);
+
+        assert!(actions.is_empty());
+    }
+
+    #[test]
+    fn test_get_chat_context_actions_returns_empty_when_current_model_is_blank() {
+        let mut info = sample_prompt_info();
+        info.current_model = Some("   ".to_string());
+
+        let actions = get_chat_context_actions(&info);
+
+        assert!(actions.is_empty());
+    }
 }
diff --git a/src/actions/builders/clipboard.rs b/src/actions/builders/clipboard.rs
index 61c4fac2f27aae73b516b1b487482f96e2cd8c56..dc0dd0b3d0d84f9ae8b851d7cb80caf6de122d89
--- a/src/actions/builders/clipboard.rs
+++ b/src/actions/builders/clipboard.rs
@@ -22,6 +22,16 @@
 /// Get actions specific to a clipboard history entry.
 #[allow(clippy::vec_init_then_push)]
 pub fn get_clipboard_history_context_actions(entry: &ClipboardEntryInfo) -> Vec<Action> {
+    if entry.id.trim().is_empty() {
+        tracing::warn!(
+            target: "script_kit::actions",
+            content_type = ?entry.content_type,
+            pinned = entry.pinned,
+            "Invalid clipboard entry context: missing entry id; returning no actions"
+        );
+        return Vec::new();
+    }
+
     let mut actions = Vec::new();
 
     tracing::debug!(
@@ -254,4 +264,14 @@
             .iter()
             .all(|action| action.id.starts_with("clip:")));
     }
+
+    #[test]
+    fn test_get_clipboard_history_context_actions_returns_empty_when_entry_id_missing() {
+        let mut entry = entry_info(ContentType::Text, false);
+        entry.id = "   ".to_string();
+
+        let actions = get_clipboard_history_context_actions(&entry);
+
+        assert!(actions.is_empty());
+    }
 }
diff --git a/src/actions/builders/file_path.rs b/src/actions/builders/file_path.rs
index dfc224185994ff07cf51b25248e26ba16a11b56b..ac82caac18f27e7215572e0e859f856c2aa8291f
--- a/src/actions/builders/file_path.rs
+++ b/src/actions/builders/file_path.rs
@@ -2,6 +2,10 @@
 use crate::file_search::FileInfo;
 use crate::prompts::PathInfo;
 
+fn has_missing_file_context_fields(name: &str, path: &str) -> bool {
+    name.trim().is_empty() || path.trim().is_empty()
+}
+
 /// Get actions specific to a file search result
 ///
 /// Actions vary based on whether the item is a file or directory:
@@ -10,6 +14,17 @@
 ///
 /// Common actions for both: file:reveal_in_finder, file:copy_path, file:copy_filename
 pub fn get_file_context_actions(file_info: &FileInfo) -> Vec<Action> {
+    if has_missing_file_context_fields(&file_info.name, &file_info.path) {
+        tracing::warn!(
+            target: "script_kit::actions",
+            name = %file_info.name,
+            path = %file_info.path,
+            is_dir = file_info.is_dir,
+            "Invalid file context info: missing path or name; returning no actions"
+        );
+        return Vec::new();
+    }
+
     let mut actions = Vec::new();
 
     tracing::debug!(
@@ -140,6 +155,17 @@
 
 /// Get actions specific to a file/folder path
 pub fn get_path_context_actions(path_info: &PathInfo) -> Vec<Action> {
+    if has_missing_file_context_fields(&path_info.name, &path_info.path) {
+        tracing::warn!(
+            target: "script_kit::actions",
+            name = %path_info.name,
+            path = %path_info.path,
+            is_dir = path_info.is_dir,
+            "Invalid path context info: missing path or name; returning no actions"
+        );
+        return Vec::new();
+    }
+
     let mut actions = vec![
         Action::new(
             "file:copy_path",
@@ -265,4 +291,24 @@
             .iter()
             .all(|action| action.id.starts_with("file:")));
     }
+
+    #[test]
+    fn test_get_file_context_actions_returns_empty_when_required_fields_missing() {
+        let mut file_info = sample_file_info(false);
+        file_info.path = "   ".to_string();
+
+        let actions = get_file_context_actions(&file_info);
+
+        assert!(actions.is_empty());
+    }
+
+    #[test]
+    fn test_get_path_context_actions_returns_empty_when_required_fields_missing() {
+        let mut path_info = sample_path_info(true);
+        path_info.name = "   ".to_string();
+
+        let actions = get_path_context_actions(&path_info);
+
+        assert!(actions.is_empty());
+    }
 }


thinking
**Inspecting diffs for changed files**
codex
The validation guards and tests are in place in all three files; I’m reviewing the diffs now, then running scoped `cargo check` and `cargo clippy` as requested.
exec
/bin/zsh -lc 'git diff -- src/actions/builders/chat.rs' in /Users/johnlindquist/dev/script-kit-gpuiexec
/bin/zsh -lc 'git diff -- src/actions/builders/file_path.rs' in /Users/johnlindquist/dev/script-kit-gpuiexec
/bin/zsh -lc 'git diff -- src/actions/builders/clipboard.rs' in /Users/johnlindquist/dev/script-kit-gpui succeeded in 52ms:
diff --git a/src/actions/builders/chat.rs b/src/actions/builders/chat.rs
index 68f87ac..b62991e 100644
--- a/src/actions/builders/chat.rs
+++ b/src/actions/builders/chat.rs
@@ -18,8 +18,47 @@ pub struct ChatModelInfo {
     pub provider: String,
 }
 
+fn has_missing_chat_model_fields(model: &ChatModelInfo) -> bool {
+    model.id.trim().is_empty()
+        || model.display_name.trim().is_empty()
+        || model.provider.trim().is_empty()
+}
+
 /// Get actions specific to a chat prompt.
 pub fn get_chat_context_actions(info: &ChatPromptInfo) -> Vec<Action> {
+    let has_blank_current_model = info
+        .current_model
+        .as_ref()
+        .map(|model| model.trim().is_empty())
 succeeded in 50ms:
diff --git a/src/actions/builders/clipboard.rs b/src/actions/builders/clipboard.rs
index 9d7c316..dc0dd0b 100644
--- a/src/actions/builders/clipboard.rs
+++ b/src/actions/builders/clipboard.rs
@@ -22,6 +22,16 @@ pub struct ClipboardEntryInfo {
 /// Get actions specific to a clipboard history entry.
 #[allow(clippy::vec_init_then_push)]
 pub fn get_clipboard_history_context_actions(entry: &ClipboardEntryInfo) -> Vec<Action> {
+    if entry.id.trim().is_empty() {
+        tracing::warn!(
+            target: "script_kit::actions",
+            content_type = ?entry.content_type,
+            pinned = entry.pinned,
+            "Invalid clipboard entry context: missing entry id; returning no actions"
+        );
+        return Vec::new();
+    }
+
     let mut actions = Vec::new();
 
 succeeded in 50ms:
diff --git a/src/actions/builders/file_path.rs b/src/actions/builders/file_path.rs
index 1f22775..ac82caa 100644
--- a/src/actions/builders/file_path.rs
+++ b/src/actions/builders/file_path.rs
@@ -2,14 +2,29 @@ use super::types::{Action, ActionCategory};
 use crate::file_search::FileInfo;
 use crate::prompts::PathInfo;
 
+fn has_missing_file_context_fields(name: &str, path: &str) -> bool {
+    name.trim().is_empty() || path.trim().is_empty()
+}
+
 /// Get actions specific to a file search result
 ///
 /// Actions vary based on whether the item is a file or directory:
-/// - Directory: `open_directory` as primary
-/// - File: `open_file` as primary, plus Quick Look (macOS)
+/// - Directory: `file:open_directory` as primary
+/// - File: `file:open_file` as primary, plus Quick Look (macOS)
 ///
file update:
diff --git a/src/actions/builders/chat.rs b/src/actions/builders/chat.rs
index 5bf8650ab171d725e5b79d58333b2ecfad8edb3a..b62991e4ebf542501b6178b3eba85c14f273305a
--- a/src/actions/builders/chat.rs
+++ b/src/actions/builders/chat.rs
@@ -18,8 +18,47 @@
     pub provider: String,
 }
 
+fn has_missing_chat_model_fields(model: &ChatModelInfo) -> bool {
+    model.id.trim().is_empty()
+        || model.display_name.trim().is_empty()
+        || model.provider.trim().is_empty()
+}
+
 /// Get actions specific to a chat prompt.
 pub fn get_chat_context_actions(info: &ChatPromptInfo) -> Vec<Action> {
+    let has_blank_current_model = info
+        .current_model
+        .as_ref()
+        .map(|model| model.trim().is_empty())
+        .unwrap_or(false);
+    if has_blank_current_model {
+        tracing::warn!(
+            target: "script_kit::actions",
+            model_count = info.available_models.len(),
+            has_messages = info.has_messages,
+            has_response = info.has_response,
+            "Invalid chat prompt info: current model name is blank; returning no actions"
+        );
+        return Vec::new();
+    }
+
+    let invalid_model_count = info
+        .available_models
+        .iter()
+        .filter(|model| has_missing_chat_model_fields(model))
+        .count();
+    if invalid_model_count > 0 {
+        tracing::warn!(
+            target: "script_kit::actions",
+            invalid_model_count,
+            model_count = info.available_models.len(),
+            has_messages = info.has_messages,
+            has_response = info.has_response,
+            "Invalid chat prompt info: model metadata missing required fields; returning no actions"
+        );
+        return Vec::new();
+    }
+
     let mut actions = Vec::new();
 
     for model in &info.available_models {
@@ -227,4 +266,24 @@
         let actions = get_ai_command_bar_actions();
         assert!(actions.iter().all(|action| action.id.starts_with("chat:")));
     }
+
+    #[test]
+    fn test_get_chat_context_actions_returns_empty_when_model_metadata_missing() {
+        let mut info = sample_prompt_info();
+        info.available_models[0].id = "   ".to_string();
+
+        let actions = get_chat_context_actions(&info);
+
+        assert!(actions.is_empty());
+    }
+
+    #[test]
+    fn test_get_chat_context_actions_returns_empty_when_current_model_is_blank() {
+        let mut info = sample_prompt_info();
+        info.current_model = Some("   ".to_string());
+
+        let actions = get_chat_context_actions(&info);
+
+        assert!(actions.is_empty());
+    }
 }
diff --git a/src/actions/builders/clipboard.rs b/src/actions/builders/clipboard.rs
index 61c4fac2f27aae73b516b1b487482f96e2cd8c56..dc0dd0b3d0d84f9ae8b851d7cb80caf6de122d89
--- a/src/actions/builders/clipboard.rs
+++ b/src/actions/builders/clipboard.rs
@@ -22,6 +22,16 @@
 /// Get actions specific to a clipboard history entry.
 #[allow(clippy::vec_init_then_push)]
 pub fn get_clipboard_history_context_actions(entry: &ClipboardEntryInfo) -> Vec<Action> {
+    if entry.id.trim().is_empty() {
+        tracing::warn!(
+            target: "script_kit::actions",
+            content_type = ?entry.content_type,
+            pinned = entry.pinned,
+            "Invalid clipboard entry context: missing entry id; returning no actions"
+        );
+        return Vec::new();
+    }
+
     let mut actions = Vec::new();
 
     tracing::debug!(
@@ -254,4 +264,14 @@
             .iter()
             .all(|action| action.id.starts_with("clip:")));
     }
+
+    #[test]
+    fn test_get_clipboard_history_context_actions_returns_empty_when_entry_id_missing() {
+        let mut entry = entry_info(ContentType::Text, false);
+        entry.id = "   ".to_string();
+
+        let actions = get_clipboard_history_context_actions(&entry);
+
+        assert!(actions.is_empty());
+    }
 }
diff --git a/src/actions/builders/file_path.rs b/src/actions/builders/file_path.rs
index dfc224185994ff07cf51b25248e26ba16a11b56b..ac82caac18f27e7215572e0e859f856c2aa8291f
--- a/src/actions/builders/file_path.rs
+++ b/src/actions/builders/file_path.rs
@@ -2,6 +2,10 @@
 use crate::file_search::FileInfo;
 use crate::prompts::PathInfo;
 
+fn has_missing_file_context_fields(name: &str, path: &str) -> bool {
+    name.trim().is_empty() || path.trim().is_empty()
+}
+
 /// Get actions specific to a file search result
 ///
 /// Actions vary based on whether the item is a file or directory:
@@ -10,6 +14,17 @@
 ///
 /// Common actions for both: file:reveal_in_finder, file:copy_path, file:copy_filename
 pub fn get_file_context_actions(file_info: &FileInfo) -> Vec<Action> {
+    if has_missing_file_context_fields(&file_info.name, &file_info.path) {
+        tracing::warn!(
+            target: "script_kit::actions",
+            name = %file_info.name,
+            path = %file_info.path,
+            is_dir = file_info.is_dir,
+            "Invalid file context info: missing path or name; returning no actions"
+        );
+        return Vec::new();
+    }
+
     let mut actions = Vec::new();
 
     tracing::debug!(
@@ -140,6 +155,17 @@
 
 /// Get actions specific to a file/folder path
 pub fn get_path_context_actions(path_info: &PathInfo) -> Vec<Action> {
+    if has_missing_file_context_fields(&path_info.name, &path_info.path) {
+        tracing::warn!(
+            target: "script_kit::actions",
+            name = %path_info.name,
+            path = %path_info.path,
+            is_dir = path_info.is_dir,
+            "Invalid path context info: missing path or name; returning no actions"
+        );
+        return Vec::new();
+    }
+
     let mut actions = vec![
         Action::new(
             "file:copy_path",
@@ -265,4 +291,24 @@
             .iter()
             .all(|action| action.id.starts_with("file:")));
     }
+
+    #[test]
+    fn test_get_file_context_actions_returns_empty_when_required_fields_missing() {
+        let mut file_info = sample_file_info(false);
+        file_info.path = "   ".to_string();
+
+        let actions = get_file_context_actions(&file_info);
+
+        assert!(actions.is_empty());
+    }
+
+    #[test]
+    fn test_get_path_context_actions_returns_empty_when_required_fields_missing() {
+        let mut path_info = sample_path_info(true);
+        path_info.name = "   ".to_string();
+
+        let actions = get_path_context_actions(&path_info);
+
+        assert!(actions.is_empty());
+    }
 }


thinking
**Planning targeted scoped tests**
codex
I’m starting scoped verification for the new tests first (only the builder tests touched by this change), then I’ll run crate-scoped `cargo check` and `cargo clippy` with warnings denied.

thinking
**Running filtered tests**
exec
/bin/zsh -lc 'cargo test -p script-kit-gpui returns_empty_when' in /Users/johnlindquist/dev/script-kit-gpuifile update:
diff --git a/src/actions/builders/chat.rs b/src/actions/builders/chat.rs
index 5bf8650ab171d725e5b79d58333b2ecfad8edb3a..b62991e4ebf542501b6178b3eba85c14f273305a
--- a/src/actions/builders/chat.rs
+++ b/src/actions/builders/chat.rs
@@ -18,8 +18,47 @@
     pub provider: String,
 }
 
+fn has_missing_chat_model_fields(model: &ChatModelInfo) -> bool {
+    model.id.trim().is_empty()
+        || model.display_name.trim().is_empty()
+        || model.provider.trim().is_empty()
+}
+
 /// Get actions specific to a chat prompt.
 pub fn get_chat_context_actions(info: &ChatPromptInfo) -> Vec<Action> {
+    let has_blank_current_model = info
+        .current_model
+        .as_ref()
+        .map(|model| model.trim().is_empty())
+        .unwrap_or(false);
+    if has_blank_current_model {
+        tracing::warn!(
+            target: "script_kit::actions",
+            model_count = info.available_models.len(),
+            has_messages = info.has_messages,
+            has_response = info.has_response,
+            "Invalid chat prompt info: current model name is blank; returning no actions"
+        );
+        return Vec::new();
+    }
+
+    let invalid_model_count = info
+        .available_models
+        .iter()
+        .filter(|model| has_missing_chat_model_fields(model))
+        .count();
+    if invalid_model_count > 0 {
+        tracing::warn!(
+            target: "script_kit::actions",
+            invalid_model_count,
+            model_count = info.available_models.len(),
+            has_messages = info.has_messages,
+            has_response = info.has_response,
+            "Invalid chat prompt info: model metadata missing required fields; returning no actions"
+        );
+        return Vec::new();
+    }
+
     let mut actions = Vec::new();
 
     for model in &info.available_models {
@@ -227,4 +266,24 @@
         let actions = get_ai_command_bar_actions();
         assert!(actions.iter().all(|action| action.id.starts_with("chat:")));
     }
+
+    #[test]
+    fn test_get_chat_context_actions_returns_empty_when_model_metadata_missing() {
+        let mut info = sample_prompt_info();
+        info.available_models[0].id = "   ".to_string();
+
+        let actions = get_chat_context_actions(&info);
+
+        assert!(actions.is_empty());
+    }
+
+    #[test]
+    fn test_get_chat_context_actions_returns_empty_when_current_model_is_blank() {
+        let mut info = sample_prompt_info();
+        info.current_model = Some("   ".to_string());
+
+        let actions = get_chat_context_actions(&info);
+
+        assert!(actions.is_empty());
+    }
 }
diff --git a/src/actions/builders/clipboard.rs b/src/actions/builders/clipboard.rs
index 61c4fac2f27aae73b516b1b487482f96e2cd8c56..dc0dd0b3d0d84f9ae8b851d7cb80caf6de122d89
--- a/src/actions/builders/clipboard.rs
+++ b/src/actions/builders/clipboard.rs
@@ -22,6 +22,16 @@
 /// Get actions specific to a clipboard history entry.
 #[allow(clippy::vec_init_then_push)]
 pub fn get_clipboard_history_context_actions(entry: &ClipboardEntryInfo) -> Vec<Action> {
+    if entry.id.trim().is_empty() {
+        tracing::warn!(
+            target: "script_kit::actions",
+            content_type = ?entry.content_type,
+            pinned = entry.pinned,
+            "Invalid clipboard entry context: missing entry id; returning no actions"
+        );
+        return Vec::new();
+    }
+
     let mut actions = Vec::new();
 
     tracing::debug!(
@@ -254,4 +264,14 @@
             .iter()
             .all(|action| action.id.starts_with("clip:")));
     }
+
+    #[test]
+    fn test_get_clipboard_history_context_actions_returns_empty_when_entry_id_missing() {
+        let mut entry = entry_info(ContentType::Text, false);
+        entry.id = "   ".to_string();
+
+        let actions = get_clipboard_history_context_actions(&entry);
+
+        assert!(actions.is_empty());
+    }
 }
diff --git a/src/actions/builders/file_path.rs b/src/actions/builders/file_path.rs
index dfc224185994ff07cf51b25248e26ba16a11b56b..ac82caac18f27e7215572e0e859f856c2aa8291f
--- a/src/actions/builders/file_path.rs
+++ b/src/actions/builders/file_path.rs
@@ -2,6 +2,10 @@
 use crate::file_search::FileInfo;
 use crate::prompts::PathInfo;
 
+fn has_missing_file_context_fields(name: &str, path: &str) -> bool {
+    name.trim().is_empty() || path.trim().is_empty()
+}
+
 /// Get actions specific to a file search result
 ///
 /// Actions vary based on whether the item is a file or directory:
@@ -10,6 +14,17 @@
 ///
 /// Common actions for both: file:reveal_in_finder, file:copy_path, file:copy_filename
 pub fn get_file_context_actions(file_info: &FileInfo) -> Vec<Action> {
+    if has_missing_file_context_fields(&file_info.name, &file_info.path) {
+        tracing::warn!(
+            target: "script_kit::actions",
+            name = %file_info.name,
+            path = %file_info.path,
+            is_dir = file_info.is_dir,
+            "Invalid file context info: missing path or name; returning no actions"
+        );
+        return Vec::new();
+    }
+
     let mut actions = Vec::new();
 
     tracing::debug!(
@@ -140,6 +155,17 @@
 
 /// Get actions specific to a file/folder path
 pub fn get_path_context_actions(path_info: &PathInfo) -> Vec<Action> {
+    if has_missing_file_context_fields(&path_info.name, &path_info.path) {
+        tracing::warn!(
+            target: "script_kit::actions",
+            name = %path_info.name,
+            path = %path_info.path,
+            is_dir = path_info.is_dir,
+            "Invalid path context info: missing path or name; returning no actions"
+        );
+        return Vec::new();
+    }
+
     let mut actions = vec![
         Action::new(
             "file:copy_path",
@@ -265,4 +291,24 @@
             .iter()
             .all(|action| action.id.starts_with("file:")));
     }
+
+    #[test]
+    fn test_get_file_context_actions_returns_empty_when_required_fields_missing() {
+        let mut file_info = sample_file_info(false);
+        file_info.path = "   ".to_string();
+
+        let actions = get_file_context_actions(&file_info);
+
+        assert!(actions.is_empty());
+    }
+
+    #[test]
+    fn test_get_path_context_actions_returns_empty_when_required_fields_missing() {
+        let mut path_info = sample_path_info(true);
+        path_info.name = "   ".to_string();
+
+        let actions = get_path_context_actions(&path_info);
+
+        assert!(actions.is_empty());
+    }
 }


thinking
**Checking command session status**
codex
The scoped test run is blocked by unrelated parallel-tree conflicts (`tests.rs` vs `tests/mod.rs` duplicates in other modules), not by these builder changes. I’m proceeding with scoped `cargo check`/`clippy` next to validate what I can in this shared state.
file update:
diff --git a/src/actions/builders/chat.rs b/src/actions/builders/chat.rs
index 5bf8650ab171d725e5b79d58333b2ecfad8edb3a..b62991e4ebf542501b6178b3eba85c14f273305a
--- a/src/actions/builders/chat.rs
+++ b/src/actions/builders/chat.rs
@@ -18,8 +18,47 @@
     pub provider: String,
 }
 
+fn has_missing_chat_model_fields(model: &ChatModelInfo) -> bool {
+    model.id.trim().is_empty()
+        || model.display_name.trim().is_empty()
+        || model.provider.trim().is_empty()
+}
+
 /// Get actions specific to a chat prompt.
 pub fn get_chat_context_actions(info: &ChatPromptInfo) -> Vec<Action> {
+    let has_blank_current_model = info
+        .current_model
+        .as_ref()
+        .map(|model| model.trim().is_empty())
+        .unwrap_or(false);
+    if has_blank_current_model {
+        tracing::warn!(
+            target: "script_kit::actions",
+            model_count = info.available_models.len(),
+            has_messages = info.has_messages,
+            has_response = info.has_response,
+            "Invalid chat prompt info: current model name is blank; returning no actions"
+        );
+        return Vec::new();
+    }
+
+    let invalid_model_count = info
+        .available_models
+        .iter()
+        .filter(|model| has_missing_chat_model_fields(model))
+        .count();
+    if invalid_model_count > 0 {
+        tracing::warn!(
+            target: "script_kit::actions",
+            invalid_model_count,
+            model_count = info.available_models.len(),
+            has_messages = info.has_messages,
+            has_response = info.has_response,
+            "Invalid chat prompt info: model metadata missing required fields; returning no actions"
+        );
+        return Vec::new();
+    }
+
     let mut actions = Vec::new();
 
     for model in &info.available_models {
@@ -227,4 +266,24 @@
         let actions = get_ai_command_bar_actions();
         assert!(actions.iter().all(|action| action.id.starts_with("chat:")));
     }
+
+    #[test]
+    fn test_get_chat_context_actions_returns_empty_when_model_metadata_missing() {
+        let mut info = sample_prompt_info();
+        info.available_models[0].id = "   ".to_string();
+
+        let actions = get_chat_context_actions(&info);
+
+        assert!(actions.is_empty());
+    }
+
+    #[test]
+    fn test_get_chat_context_actions_returns_empty_when_current_model_is_blank() {
+        let mut info = sample_prompt_info();
+        info.current_model = Some("   ".to_string());
+
+        let actions = get_chat_context_actions(&info);
+
+        assert!(actions.is_empty());
+    }
 }
diff --git a/src/actions/builders/clipboard.rs b/src/actions/builders/clipboard.rs
index 61c4fac2f27aae73b516b1b487482f96e2cd8c56..dc0dd0b3d0d84f9ae8b851d7cb80caf6de122d89
--- a/src/actions/builders/clipboard.rs
+++ b/src/actions/builders/clipboard.rs
@@ -22,6 +22,16 @@
 /// Get actions specific to a clipboard history entry.
 #[allow(clippy::vec_init_then_push)]
 pub fn get_clipboard_history_context_actions(entry: &ClipboardEntryInfo) -> Vec<Action> {
+    if entry.id.trim().is_empty() {
+        tracing::warn!(
+            target: "script_kit::actions",
+            content_type = ?entry.content_type,
+            pinned = entry.pinned,
+            "Invalid clipboard entry context: missing entry id; returning no actions"
+        );
+        return Vec::new();
+    }
+
     let mut actions = Vec::new();
 
     tracing::debug!(
@@ -254,4 +264,14 @@
             .iter()
             .all(|action| action.id.starts_with("clip:")));
     }
+
+    #[test]
+    fn test_get_clipboard_history_context_actions_returns_empty_when_entry_id_missing() {
+        let mut entry = entry_info(ContentType::Text, false);
+        entry.id = "   ".to_string();
+
+        let actions = get_clipboard_history_context_actions(&entry);
+
+        assert!(actions.is_empty());
+    }
 }
diff --git a/src/actions/builders/file_path.rs b/src/actions/builders/file_path.rs
index dfc224185994ff07cf51b25248e26ba16a11b56b..ac82caac18f27e7215572e0e859f856c2aa8291f
--- a/src/actions/builders/file_path.rs
+++ b/src/actions/builders/file_path.rs
@@ -2,6 +2,10 @@
 use crate::file_search::FileInfo;
 use crate::prompts::PathInfo;
 
+fn has_missing_file_context_fields(name: &str, path: &str) -> bool {
+    name.trim().is_empty() || path.trim().is_empty()
+}
+
 /// Get actions specific to a file search result
 ///
 /// Actions vary based on whether the item is a file or directory:
@@ -10,6 +14,17 @@
 ///
 /// Common actions for both: file:reveal_in_finder, file:copy_path, file:copy_filename
 pub fn get_file_context_actions(file_info: &FileInfo) -> Vec<Action> {
+    if has_missing_file_context_fields(&file_info.name, &file_info.path) {
+        tracing::warn!(
+            target: "script_kit::actions",
+            name = %file_info.name,
+            path = %file_info.path,
+            is_dir = file_info.is_dir,
+            "Invalid file context info: missing path or name; returning no actions"
+        );
+        return Vec::new();
+    }
+
     let mut actions = Vec::new();
 
     tracing::debug!(
@@ -140,6 +155,17 @@
 
 /// Get actions specific to a file/folder path
 pub fn get_path_context_actions(path_info: &PathInfo) -> Vec<Action> {
+    if has_missing_file_context_fields(&path_info.name, &path_info.path) {
+        tracing::warn!(
+            target: "script_kit::actions",
+            name = %path_info.name,
+            path = %path_info.path,
+            is_dir = path_info.is_dir,
+            "Invalid path context info: missing path or name; returning no actions"
+        );
+        return Vec::new();
+    }
+
     let mut actions = vec![
         Action::new(
             "file:copy_path",
@@ -265,4 +291,24 @@
             .iter()
             .all(|action| action.id.starts_with("file:")));
     }
+
+    #[test]
+    fn test_get_file_context_actions_returns_empty_when_required_fields_missing() {
+        let mut file_info = sample_file_info(false);
+        file_info.path = "   ".to_string();
+
+        let actions = get_file_context_actions(&file_info);
+
+        assert!(actions.is_empty());
+    }
+
+    #[test]
+    fn test_get_path_context_actions_returns_empty_when_required_fields_missing() {
+        let mut path_info = sample_path_info(true);
+        path_info.name = "   ".to_string();
+
+        let actions = get_path_context_actions(&path_info);
+
+        assert!(actions.is_empty());
+    }
 }


thinking
**Checking session status**
file update:
diff --git a/src/actions/builders/chat.rs b/src/actions/builders/chat.rs
index 5bf8650ab171d725e5b79d58333b2ecfad8edb3a..b62991e4ebf542501b6178b3eba85c14f273305a
--- a/src/actions/builders/chat.rs
+++ b/src/actions/builders/chat.rs
@@ -18,8 +18,47 @@
     pub provider: String,
 }
 
+fn has_missing_chat_model_fields(model: &ChatModelInfo) -> bool {
+    model.id.trim().is_empty()
+        || model.display_name.trim().is_empty()
+        || model.provider.trim().is_empty()
+}
+
 /// Get actions specific to a chat prompt.
 pub fn get_chat_context_actions(info: &ChatPromptInfo) -> Vec<Action> {
+    let has_blank_current_model = info
+        .current_model
+        .as_ref()
+        .map(|model| model.trim().is_empty())
+        .unwrap_or(false);
+    if has_blank_current_model {
+        tracing::warn!(
+            target: "script_kit::actions",
+            model_count = info.available_models.len(),
+            has_messages = info.has_messages,
+            has_response = info.has_response,
+            "Invalid chat prompt info: current model name is blank; returning no actions"
+        );
+        return Vec::new();
+    }
+
+    let invalid_model_count = info
+        .available_models
+        .iter()
+        .filter(|model| has_missing_chat_model_fields(model))
+        .count();
+    if invalid_model_count > 0 {
+        tracing::warn!(
+            target: "script_kit::actions",
+            invalid_model_count,
+            model_count = info.available_models.len(),
+            has_messages = info.has_messages,
+            has_response = info.has_response,
+            "Invalid chat prompt info: model metadata missing required fields; returning no actions"
+        );
+        return Vec::new();
+    }
+
     let mut actions = Vec::new();
 
     for model in &info.available_models {
@@ -227,4 +266,24 @@
         let actions = get_ai_command_bar_actions();
         assert!(actions.iter().all(|action| action.id.starts_with("chat:")));
     }
+
+    #[test]
+    fn test_get_chat_context_actions_returns_empty_when_model_metadata_missing() {
+        let mut info = sample_prompt_info();
+        info.available_models[0].id = "   ".to_string();
+
+        let actions = get_chat_context_actions(&info);
+
+        assert!(actions.is_empty());
+    }
+
+    #[test]
+    fn test_get_chat_context_actions_returns_empty_when_current_model_is_blank() {
+        let mut info = sample_prompt_info();
+        info.current_model = Some("   ".to_string());
+
+        let actions = get_chat_context_actions(&info);
+
+        assert!(actions.is_empty());
+    }
 }
diff --git a/src/actions/builders/clipboard.rs b/src/actions/builders/clipboard.rs
index 61c4fac2f27aae73b516b1b487482f96e2cd8c56..dc0dd0b3d0d84f9ae8b851d7cb80caf6de122d89
--- a/src/actions/builders/clipboard.rs
+++ b/src/actions/builders/clipboard.rs
@@ -22,6 +22,16 @@
 /// Get actions specific to a clipboard history entry.
 #[allow(clippy::vec_init_then_push)]
 pub fn get_clipboard_history_context_actions(entry: &ClipboardEntryInfo) -> Vec<Action> {
+    if entry.id.trim().is_empty() {
+        tracing::warn!(
+            target: "script_kit::actions",
+            content_type = ?entry.content_type,
+            pinned = entry.pinned,
+            "Invalid clipboard entry context: missing entry id; returning no actions"
+        );
+        return Vec::new();
+    }
+
     let mut actions = Vec::new();
 
     tracing::debug!(
@@ -254,4 +264,14 @@
             .iter()
             .all(|action| action.id.starts_with("clip:")));
     }
+
+    #[test]
+    fn test_get_clipboard_history_context_actions_returns_empty_when_entry_id_missing() {
+        let mut entry = entry_info(ContentType::Text, false);
+        entry.id = "   ".to_string();
+
+        let actions = get_clipboard_history_context_actions(&entry);
+
+        assert!(actions.is_empty());
+    }
 }
diff --git a/src/actions/builders/file_path.rs b/src/actions/builders/file_path.rs
index dfc224185994ff07cf51b25248e26ba16a11b56b..ac82caac18f27e7215572e0e859f856c2aa8291f
--- a/src/actions/builders/file_path.rs
+++ b/src/actions/builders/file_path.rs
@@ -2,6 +2,10 @@
 use crate::file_search::FileInfo;
 use crate::prompts::PathInfo;
 
+fn has_missing_file_context_fields(name: &str, path: &str) -> bool {
+    name.trim().is_empty() || path.trim().is_empty()
+}
+
 /// Get actions specific to a file search result
 ///
 /// Actions vary based on whether the item is a file or directory:
@@ -10,6 +14,17 @@
 ///
 /// Common actions for both: file:reveal_in_finder, file:copy_path, file:copy_filename
 pub fn get_file_context_actions(file_info: &FileInfo) -> Vec<Action> {
+    if has_missing_file_context_fields(&file_info.name, &file_info.path) {
+        tracing::warn!(
+            target: "script_kit::actions",
+            name = %file_info.name,
+            path = %file_info.path,
+            is_dir = file_info.is_dir,
+            "Invalid file context info: missing path or name; returning no actions"
+        );
+        return Vec::new();
+    }
+
     let mut actions = Vec::new();
 
     tracing::debug!(
@@ -140,6 +155,17 @@
 
 /// Get actions specific to a file/folder path
 pub fn get_path_context_actions(path_info: &PathInfo) -> Vec<Action> {
+    if has_missing_file_context_fields(&path_info.name, &path_info.path) {
+        tracing::warn!(
+            target: "script_kit::actions",
+            name = %path_info.name,
+            path = %path_info.path,
+            is_dir = path_info.is_dir,
+            "Invalid path context info: missing path or name; returning no actions"
+        );
+        return Vec::new();
+    }
+
     let mut actions = vec![
         Action::new(
             "file:copy_path",
@@ -265,4 +291,24 @@
             .iter()
             .all(|action| action.id.starts_with("file:")));
     }
+
+    #[test]
+    fn test_get_file_context_actions_returns_empty_when_required_fields_missing() {
+        let mut file_info = sample_file_info(false);
+        file_info.path = "   ".to_string();
+
+        let actions = get_file_context_actions(&file_info);
+
+        assert!(actions.is_empty());
+    }
+
+    #[test]
+    fn test_get_path_context_actions_returns_empty_when_required_fields_missing() {
+        let mut path_info = sample_path_info(true);
+        path_info.name = "   ".to_string();
+
+        let actions = get_path_context_actions(&path_info);
+
+        assert!(actions.is_empty());
+    }
 }

 exited 101 in 19.06s:
   Compiling script-kit-gpui v0.1.0 (/Users/johnlindquist/dev/script-kit-gpui)
error[E0761]: file for module `tests` found at both "src/protocol/message/tests.rs" and "src/protocol/message/tests/mod.rs"
  --> src/protocol/message/mod.rs:87:1
   |
87 | mod tests;
   | ^^^^^^^^^^
   |
   = help: delete or rename one of them to remove the ambiguity

error[E0761]: file for module `tests` found at both "src/designs/core/tests.rs" and "src/designs/core/tests/mod.rs"
 --> src/designs/core/part_04.rs:2:1
  |
2 | mod tests;
  | ^^^^^^^^^^
  |
  = help: delete or rename one of them to remove the ambiguity

warning: glob import doesn't reexport anything with visibility `pub(in crate::prompts)` because no imported item is public enough
  --> src/prompts/div/mod.rs:32:16
   |
codex
Compilation is failing due unrelated in-flight changes elsewhere (new `ContentType` variants and `ClipboardEntry` fields causing non-exhaustive/missing-field errors), so this workspace can’t currently complete a crate build. I’m collecting enough output to document that these failures are out of scope, then I’ll stop the run and finalize with exact risks.
file update:
diff --git a/src/actions/builders/chat.rs b/src/actions/builders/chat.rs
index 5bf8650ab171d725e5b79d58333b2ecfad8edb3a..b62991e4ebf542501b6178b3eba85c14f273305a
--- a/src/actions/builders/chat.rs
+++ b/src/actions/builders/chat.rs
@@ -18,8 +18,47 @@
     pub provider: String,
 }
 
+fn has_missing_chat_model_fields(model: &ChatModelInfo) -> bool {
+    model.id.trim().is_empty()
+        || model.display_name.trim().is_empty()
+        || model.provider.trim().is_empty()
+}
+
 /// Get actions specific to a chat prompt.
 pub fn get_chat_context_actions(info: &ChatPromptInfo) -> Vec<Action> {
+    let has_blank_current_model = info
+        .current_model
+        .as_ref()
+        .map(|model| model.trim().is_empty())
+        .unwrap_or(false);
+    if has_blank_current_model {
+        tracing::warn!(
+            target: "script_kit::actions",
+            model_count = info.available_models.len(),
+            has_messages = info.has_messages,
+            has_response = info.has_response,
+            "Invalid chat prompt info: current model name is blank; returning no actions"
+        );
+        return Vec::new();
+    }
+
+    let invalid_model_count = info
+        .available_models
+        .iter()
+        .filter(|model| has_missing_chat_model_fields(model))
+        .count();
+    if invalid_model_count > 0 {
+        tracing::warn!(
+            target: "script_kit::actions",
+            invalid_model_count,
+            model_count = info.available_models.len(),
+            has_messages = info.has_messages,
+            has_response = info.has_response,
+            "Invalid chat prompt info: model metadata missing required fields; returning no actions"
+        );
+        return Vec::new();
+    }
+
     let mut actions = Vec::new();
 
     for model in &info.available_models {
@@ -227,4 +266,24 @@
         let actions = get_ai_command_bar_actions();
         assert!(actions.iter().all(|action| action.id.starts_with("chat:")));
     }
+
+    #[test]
+    fn test_get_chat_context_actions_returns_empty_when_model_metadata_missing() {
+        let mut info = sample_prompt_info();
+        info.available_models[0].id = "   ".to_string();
+
+        let actions = get_chat_context_actions(&info);
+
+        assert!(actions.is_empty());
+    }
+
+    #[test]
+    fn test_get_chat_context_actions_returns_empty_when_current_model_is_blank() {
+        let mut info = sample_prompt_info();
+        info.current_model = Some("   ".to_string());
+
+        let actions = get_chat_context_actions(&info);
+
+        assert!(actions.is_empty());
+    }
 }
diff --git a/src/actions/builders/clipboard.rs b/src/actions/builders/clipboard.rs
index 61c4fac2f27aae73b516b1b487482f96e2cd8c56..dc0dd0b3d0d84f9ae8b851d7cb80caf6de122d89
--- a/src/actions/builders/clipboard.rs
+++ b/src/actions/builders/clipboard.rs
@@ -22,6 +22,16 @@
 /// Get actions specific to a clipboard history entry.
 #[allow(clippy::vec_init_then_push)]
 pub fn get_clipboard_history_context_actions(entry: &ClipboardEntryInfo) -> Vec<Action> {
+    if entry.id.trim().is_empty() {
+        tracing::warn!(
+            target: "script_kit::actions",
+            content_type = ?entry.content_type,
+            pinned = entry.pinned,
+            "Invalid clipboard entry context: missing entry id; returning no actions"
+        );
+        return Vec::new();
+    }
+
     let mut actions = Vec::new();
 
     tracing::debug!(
@@ -254,4 +264,14 @@
             .iter()
             .all(|action| action.id.starts_with("clip:")));
     }
+
+    #[test]
+    fn test_get_clipboard_history_context_actions_returns_empty_when_entry_id_missing() {
+        let mut entry = entry_info(ContentType::Text, false);
+        entry.id = "   ".to_string();
+
+        let actions = get_clipboard_history_context_actions(&entry);
+
+        assert!(actions.is_empty());
+    }
 }
diff --git a/src/actions/builders/file_path.rs b/src/actions/builders/file_path.rs
index dfc224185994ff07cf51b25248e26ba16a11b56b..ac82caac18f27e7215572e0e859f856c2aa8291f
--- a/src/actions/builders/file_path.rs
+++ b/src/actions/builders/file_path.rs
@@ -2,6 +2,10 @@
 use crate::file_search::FileInfo;
 use crate::prompts::PathInfo;
 
+fn has_missing_file_context_fields(name: &str, path: &str) -> bool {
+    name.trim().is_empty() || path.trim().is_empty()
+}
+
 /// Get actions specific to a file search result
 ///
 /// Actions vary based on whether the item is a file or directory:
@@ -10,6 +14,17 @@
 ///
 /// Common actions for both: file:reveal_in_finder, file:copy_path, file:copy_filename
 pub fn get_file_context_actions(file_info: &FileInfo) -> Vec<Action> {
+    if has_missing_file_context_fields(&file_info.name, &file_info.path) {
+        tracing::warn!(
+            target: "script_kit::actions",
+            name = %file_info.name,
+            path = %file_info.path,
+            is_dir = file_info.is_dir,
+            "Invalid file context info: missing path or name; returning no actions"
+        );
+        return Vec::new();
+    }
+
     let mut actions = Vec::new();
 
     tracing::debug!(
@@ -140,6 +155,17 @@
 
 /// Get actions specific to a file/folder path
 pub fn get_path_context_actions(path_info: &PathInfo) -> Vec<Action> {
+    if has_missing_file_context_fields(&path_info.name, &path_info.path) {
+        tracing::warn!(
+            target: "script_kit::actions",
+            name = %path_info.name,
+            path = %path_info.path,
+            is_dir = path_info.is_dir,
+            "Invalid path context info: missing path or name; returning no actions"
+        );
+        return Vec::new();
+    }
+
     let mut actions = vec![
         Action::new(
             "file:copy_path",
@@ -265,4 +291,24 @@
             .iter()
             .all(|action| action.id.starts_with("file:")));
     }
+
+    #[test]
+    fn test_get_file_context_actions_returns_empty_when_required_fields_missing() {
+        let mut file_info = sample_file_info(false);
+        file_info.path = "   ".to_string();
+
+        let actions = get_file_context_actions(&file_info);
+
+        assert!(actions.is_empty());
+    }
+
+    #[test]
+    fn test_get_path_context_actions_returns_empty_when_required_fields_missing() {
+        let mut path_info = sample_path_info(true);
+        path_info.name = "   ".to_string();
+
+        let actions = get_path_context_actions(&path_info);
+
+        assert!(actions.is_empty());
+    }
 }


thinking
**Testing compile failures**
exec
/bin/zsh -lc 'cargo check -p script-kit-gpui' in /Users/johnlindquist/dev/script-kit-gpuifile update:
diff --git a/src/actions/builders/chat.rs b/src/actions/builders/chat.rs
index 5bf8650ab171d725e5b79d58333b2ecfad8edb3a..b62991e4ebf542501b6178b3eba85c14f273305a
--- a/src/actions/builders/chat.rs
+++ b/src/actions/builders/chat.rs
@@ -18,8 +18,47 @@
     pub provider: String,
 }
 
+fn has_missing_chat_model_fields(model: &ChatModelInfo) -> bool {
+    model.id.trim().is_empty()
+        || model.display_name.trim().is_empty()
+        || model.provider.trim().is_empty()
+}
+
 /// Get actions specific to a chat prompt.
 pub fn get_chat_context_actions(info: &ChatPromptInfo) -> Vec<Action> {
+    let has_blank_current_model = info
+        .current_model
+        .as_ref()
+        .map(|model| model.trim().is_empty())
+        .unwrap_or(false);
+    if has_blank_current_model {
+        tracing::warn!(
+            target: "script_kit::actions",
+            model_count = info.available_models.len(),
+            has_messages = info.has_messages,
+            has_response = info.has_response,
+            "Invalid chat prompt info: current model name is blank; returning no actions"
+        );
+        return Vec::new();
+    }
+
+    let invalid_model_count = info
+        .available_models
+        .iter()
+        .filter(|model| has_missing_chat_model_fields(model))
+        .count();
+    if invalid_model_count > 0 {
+        tracing::warn!(
+            target: "script_kit::actions",
+            invalid_model_count,
+            model_count = info.available_models.len(),
+            has_messages = info.has_messages,
+            has_response = info.has_response,
+            "Invalid chat prompt info: model metadata missing required fields; returning no actions"
+        );
+        return Vec::new();
+    }
+
     let mut actions = Vec::new();
 
     for model in &info.available_models {
@@ -227,4 +266,24 @@
         let actions = get_ai_command_bar_actions();
         assert!(actions.iter().all(|action| action.id.starts_with("chat:")));
     }
+
+    #[test]
+    fn test_get_chat_context_actions_returns_empty_when_model_metadata_missing() {
+        let mut info = sample_prompt_info();
+        info.available_models[0].id = "   ".to_string();
+
+        let actions = get_chat_context_actions(&info);
+
+        assert!(actions.is_empty());
+    }
+
+    #[test]
+    fn test_get_chat_context_actions_returns_empty_when_current_model_is_blank() {
+        let mut info = sample_prompt_info();
+        info.current_model = Some("   ".to_string());
+
+        let actions = get_chat_context_actions(&info);
+
+        assert!(actions.is_empty());
+    }
 }
diff --git a/src/actions/builders/clipboard.rs b/src/actions/builders/clipboard.rs
index 61c4fac2f27aae73b516b1b487482f96e2cd8c56..dc0dd0b3d0d84f9ae8b851d7cb80caf6de122d89
--- a/src/actions/builders/clipboard.rs
+++ b/src/actions/builders/clipboard.rs
@@ -22,6 +22,16 @@
 /// Get actions specific to a clipboard history entry.
 #[allow(clippy::vec_init_then_push)]
 pub fn get_clipboard_history_context_actions(entry: &ClipboardEntryInfo) -> Vec<Action> {
+    if entry.id.trim().is_empty() {
+        tracing::warn!(
+            target: "script_kit::actions",
+            content_type = ?entry.content_type,
+            pinned = entry.pinned,
+            "Invalid clipboard entry context: missing entry id; returning no actions"
+        );
+        return Vec::new();
+    }
+
     let mut actions = Vec::new();
 
     tracing::debug!(
@@ -254,4 +264,14 @@
             .iter()
             .all(|action| action.id.starts_with("clip:")));
     }
+
+    #[test]
+    fn test_get_clipboard_history_context_actions_returns_empty_when_entry_id_missing() {
+        let mut entry = entry_info(ContentType::Text, false);
+        entry.id = "   ".to_string();
+
+        let actions = get_clipboard_history_context_actions(&entry);
+
+        assert!(actions.is_empty());
+    }
 }
diff --git a/src/actions/builders/file_path.rs b/src/actions/builders/file_path.rs
index dfc224185994ff07cf51b25248e26ba16a11b56b..ac82caac18f27e7215572e0e859f856c2aa8291f
--- a/src/actions/builders/file_path.rs
+++ b/src/actions/builders/file_path.rs
@@ -2,6 +2,10 @@
 use crate::file_search::FileInfo;
 use crate::prompts::PathInfo;
 
+fn has_missing_file_context_fields(name: &str, path: &str) -> bool {
+    name.trim().is_empty() || path.trim().is_empty()
+}
+
 /// Get actions specific to a file search result
 ///
 /// Actions vary based on whether the item is a file or directory:
@@ -10,6 +14,17 @@
 ///
 /// Common actions for both: file:reveal_in_finder, file:copy_path, file:copy_filename
 pub fn get_file_context_actions(file_info: &FileInfo) -> Vec<Action> {
+    if has_missing_file_context_fields(&file_info.name, &file_info.path) {
+        tracing::warn!(
+            target: "script_kit::actions",
+            name = %file_info.name,
+            path = %file_info.path,
+            is_dir = file_info.is_dir,
+            "Invalid file context info: missing path or name; returning no actions"
+        );
+        return Vec::new();
+    }
+
     let mut actions = Vec::new();
 
     tracing::debug!(
@@ -140,6 +155,17 @@
 
 /// Get actions specific to a file/folder path
 pub fn get_path_context_actions(path_info: &PathInfo) -> Vec<Action> {
+    if has_missing_file_context_fields(&path_info.name, &path_info.path) {
+        tracing::warn!(
+            target: "script_kit::actions",
+            name = %path_info.name,
+            path = %path_info.path,
+            is_dir = path_info.is_dir,
+            "Invalid path context info: missing path or name; returning no actions"
+        );
+        return Vec::new();
+    }
+
     let mut actions = vec![
         Action::new(
             "file:copy_path",
@@ -265,4 +291,24 @@
             .iter()
             .all(|action| action.id.starts_with("file:")));
     }
+
+    #[test]
+    fn test_get_file_context_actions_returns_empty_when_required_fields_missing() {
+        let mut file_info = sample_file_info(false);
+        file_info.path = "   ".to_string();
+
+        let actions = get_file_context_actions(&file_info);
+
+        assert!(actions.is_empty());
+    }
+
+    #[test]
+    fn test_get_path_context_actions_returns_empty_when_required_fields_missing() {
+        let mut path_info = sample_path_info(true);
+        path_info.name = "   ".to_string();
+
+        let actions = get_path_context_actions(&path_info);
+
+        assert!(actions.is_empty());
+    }
 }


thinking
**Planning periodic polling**
file update:
diff --git a/src/actions/builders/chat.rs b/src/actions/builders/chat.rs
index 5bf8650ab171d725e5b79d58333b2ecfad8edb3a..b62991e4ebf542501b6178b3eba85c14f273305a
--- a/src/actions/builders/chat.rs
+++ b/src/actions/builders/chat.rs
@@ -18,8 +18,47 @@
     pub provider: String,
 }
 
+fn has_missing_chat_model_fields(model: &ChatModelInfo) -> bool {
+    model.id.trim().is_empty()
+        || model.display_name.trim().is_empty()
+        || model.provider.trim().is_empty()
+}
+
 /// Get actions specific to a chat prompt.
 pub fn get_chat_context_actions(info: &ChatPromptInfo) -> Vec<Action> {
+    let has_blank_current_model = info
+        .current_model
+        .as_ref()
+        .map(|model| model.trim().is_empty())
+        .unwrap_or(false);
+    if has_blank_current_model {
+        tracing::warn!(
+            target: "script_kit::actions",
+            model_count = info.available_models.len(),
+            has_messages = info.has_messages,
+            has_response = info.has_response,
+            "Invalid chat prompt info: current model name is blank; returning no actions"
+        );
+        return Vec::new();
+    }
+
+    let invalid_model_count = info
+        .available_models
+        .iter()
+        .filter(|model| has_missing_chat_model_fields(model))
+        .count();
+    if invalid_model_count > 0 {
+        tracing::warn!(
+            target: "script_kit::actions",
+            invalid_model_count,
+            model_count = info.available_models.len(),
+            has_messages = info.has_messages,
+            has_response = info.has_response,
+            "Invalid chat prompt info: model metadata missing required fields; returning no actions"
+        );
+        return Vec::new();
+    }
+
     let mut actions = Vec::new();
 
     for model in &info.available_models {
@@ -227,4 +266,24 @@
         let actions = get_ai_command_bar_actions();
         assert!(actions.iter().all(|action| action.id.starts_with("chat:")));
     }
+
+    #[test]
+    fn test_get_chat_context_actions_returns_empty_when_model_metadata_missing() {
+        let mut info = sample_prompt_info();
+        info.available_models[0].id = "   ".to_string();
+
+        let actions = get_chat_context_actions(&info);
+
+        assert!(actions.is_empty());
+    }
+
+    #[test]
+    fn test_get_chat_context_actions_returns_empty_when_current_model_is_blank() {
+        let mut info = sample_prompt_info();
+        info.current_model = Some("   ".to_string());
+
+        let actions = get_chat_context_actions(&info);
+
+        assert!(actions.is_empty());
+    }
 }
diff --git a/src/actions/builders/clipboard.rs b/src/actions/builders/clipboard.rs
index 61c4fac2f27aae73b516b1b487482f96e2cd8c56..dc0dd0b3d0d84f9ae8b851d7cb80caf6de122d89
--- a/src/actions/builders/clipboard.rs
+++ b/src/actions/builders/clipboard.rs
@@ -22,6 +22,16 @@
 /// Get actions specific to a clipboard history entry.
 #[allow(clippy::vec_init_then_push)]
 pub fn get_clipboard_history_context_actions(entry: &ClipboardEntryInfo) -> Vec<Action> {
+    if entry.id.trim().is_empty() {
+        tracing::warn!(
+            target: "script_kit::actions",
+            content_type = ?entry.content_type,
+            pinned = entry.pinned,
+            "Invalid clipboard entry context: missing entry id; returning no actions"
+        );
+        return Vec::new();
+    }
+
     let mut actions = Vec::new();
 
     tracing::debug!(
@@ -254,4 +264,14 @@
             .iter()
             .all(|action| action.id.starts_with("clip:")));
     }
+
+    #[test]
+    fn test_get_clipboard_history_context_actions_returns_empty_when_entry_id_missing() {
+        let mut entry = entry_info(ContentType::Text, false);
+        entry.id = "   ".to_string();
+
+        let actions = get_clipboard_history_context_actions(&entry);
+
+        assert!(actions.is_empty());
+    }
 }
diff --git a/src/actions/builders/file_path.rs b/src/actions/builders/file_path.rs
index dfc224185994ff07cf51b25248e26ba16a11b56b..ac82caac18f27e7215572e0e859f856c2aa8291f
--- a/src/actions/builders/file_path.rs
+++ b/src/actions/builders/file_path.rs
@@ -2,6 +2,10 @@
 use crate::file_search::FileInfo;
 use crate::prompts::PathInfo;
 
+fn has_missing_file_context_fields(name: &str, path: &str) -> bool {
+    name.trim().is_empty() || path.trim().is_empty()
+}
+
 /// Get actions specific to a file search result
 ///
 /// Actions vary based on whether the item is a file or directory:
@@ -10,6 +14,17 @@
 ///
 /// Common actions for both: file:reveal_in_finder, file:copy_path, file:copy_filename
 pub fn get_file_context_actions(file_info: &FileInfo) -> Vec<Action> {
+    if has_missing_file_context_fields(&file_info.name, &file_info.path) {
+        tracing::warn!(
+            target: "script_kit::actions",
+            name = %file_info.name,
+            path = %file_info.path,
+            is_dir = file_info.is_dir,
+            "Invalid file context info: missing path or name; returning no actions"
+        );
+        return Vec::new();
+    }
+
     let mut actions = Vec::new();
 
     tracing::debug!(
@@ -140,6 +155,17 @@
 
 /// Get actions specific to a file/folder path
 pub fn get_path_context_actions(path_info: &PathInfo) -> Vec<Action> {
+    if has_missing_file_context_fields(&path_info.name, &path_info.path) {
+        tracing::warn!(
+            target: "script_kit::actions",
+            name = %path_info.name,
+            path = %path_info.path,
+            is_dir = path_info.is_dir,
+            "Invalid path context info: missing path or name; returning no actions"
+        );
+        return Vec::new();
+    }
+
     let mut actions = vec![
         Action::new(
             "file:copy_path",
@@ -265,4 +291,24 @@
             .iter()
             .all(|action| action.id.starts_with("file:")));
     }
+
+    #[test]
+    fn test_get_file_context_actions_returns_empty_when_required_fields_missing() {
+        let mut file_info = sample_file_info(false);
+        file_info.path = "   ".to_string();
+
+        let actions = get_file_context_actions(&file_info);
+
+        assert!(actions.is_empty());
+    }
+
+    #[test]
+    fn test_get_path_context_actions_returns_empty_when_required_fields_missing() {
+        let mut path_info = sample_path_info(true);
+        path_info.name = "   ".to_string();
+
+        let actions = get_path_context_actions(&path_info);
+
+        assert!(actions.is_empty());
+    }
 }


thinking
**Confirming process completion status**
file update:
diff --git a/src/actions/builders/chat.rs b/src/actions/builders/chat.rs
index 5bf8650ab171d725e5b79d58333b2ecfad8edb3a..b62991e4ebf542501b6178b3eba85c14f273305a
--- a/src/actions/builders/chat.rs
+++ b/src/actions/builders/chat.rs
@@ -18,8 +18,47 @@
     pub provider: String,
 }
 
+fn has_missing_chat_model_fields(model: &ChatModelInfo) -> bool {
+    model.id.trim().is_empty()
+        || model.display_name.trim().is_empty()
+        || model.provider.trim().is_empty()
+}
+
 /// Get actions specific to a chat prompt.
 pub fn get_chat_context_actions(info: &ChatPromptInfo) -> Vec<Action> {
+    let has_blank_current_model = info
+        .current_model
+        .as_ref()
+        .map(|model| model.trim().is_empty())
+        .unwrap_or(false);
+    if has_blank_current_model {
+        tracing::warn!(
+            target: "script_kit::actions",
+            model_count = info.available_models.len(),
+            has_messages = info.has_messages,
+            has_response = info.has_response,
+            "Invalid chat prompt info: current model name is blank; returning no actions"
+        );
+        return Vec::new();
+    }
+
+    let invalid_model_count = info
+        .available_models
+        .iter()
+        .filter(|model| has_missing_chat_model_fields(model))
+        .count();
+    if invalid_model_count > 0 {
+        tracing::warn!(
+            target: "script_kit::actions",
+            invalid_model_count,
+            model_count = info.available_models.len(),
+            has_messages = info.has_messages,
+            has_response = info.has_response,
+            "Invalid chat prompt info: model metadata missing required fields; returning no actions"
+        );
+        return Vec::new();
+    }
+
     let mut actions = Vec::new();
 
     for model in &info.available_models {
@@ -227,4 +266,24 @@
         let actions = get_ai_command_bar_actions();
         assert!(actions.iter().all(|action| action.id.starts_with("chat:")));
     }
+
+    #[test]
+    fn test_get_chat_context_actions_returns_empty_when_model_metadata_missing() {
+        let mut info = sample_prompt_info();
+        info.available_models[0].id = "   ".to_string();
+
+        let actions = get_chat_context_actions(&info);
+
+        assert!(actions.is_empty());
+    }
+
+    #[test]
+    fn test_get_chat_context_actions_returns_empty_when_current_model_is_blank() {
+        let mut info = sample_prompt_info();
+        info.current_model = Some("   ".to_string());
+
+        let actions = get_chat_context_actions(&info);
+
+        assert!(actions.is_empty());
+    }
 }
diff --git a/src/actions/builders/clipboard.rs b/src/actions/builders/clipboard.rs
index 61c4fac2f27aae73b516b1b487482f96e2cd8c56..dc0dd0b3d0d84f9ae8b851d7cb80caf6de122d89
--- a/src/actions/builders/clipboard.rs
+++ b/src/actions/builders/clipboard.rs
@@ -22,6 +22,16 @@
 /// Get actions specific to a clipboard history entry.
 #[allow(clippy::vec_init_then_push)]
 pub fn get_clipboard_history_context_actions(entry: &ClipboardEntryInfo) -> Vec<Action> {
+    if entry.id.trim().is_empty() {
+        tracing::warn!(
+            target: "script_kit::actions",
+            content_type = ?entry.content_type,
+            pinned = entry.pinned,
+            "Invalid clipboard entry context: missing entry id; returning no actions"
+        );
+        return Vec::new();
+    }
+
     let mut actions = Vec::new();
 
     tracing::debug!(
@@ -254,4 +264,14 @@
             .iter()
             .all(|action| action.id.starts_with("clip:")));
     }
+
+    #[test]
+    fn test_get_clipboard_history_context_actions_returns_empty_when_entry_id_missing() {
+        let mut entry = entry_info(ContentType::Text, false);
+        entry.id = "   ".to_string();
+
+        let actions = get_clipboard_history_context_actions(&entry);
+
+        assert!(actions.is_empty());
+    }
 }
diff --git a/src/actions/builders/file_path.rs b/src/actions/builders/file_path.rs
index dfc224185994ff07cf51b25248e26ba16a11b56b..ac82caac18f27e7215572e0e859f856c2aa8291f
--- a/src/actions/builders/file_path.rs
+++ b/src/actions/builders/file_path.rs
@@ -2,6 +2,10 @@
 use crate::file_search::FileInfo;
 use crate::prompts::PathInfo;
 
+fn has_missing_file_context_fields(name: &str, path: &str) -> bool {
+    name.trim().is_empty() || path.trim().is_empty()
+}
+
 /// Get actions specific to a file search result
 ///
 /// Actions vary based on whether the item is a file or directory:
@@ -10,6 +14,17 @@
 ///
 /// Common actions for both: file:reveal_in_finder, file:copy_path, file:copy_filename
 pub fn get_file_context_actions(file_info: &FileInfo) -> Vec<Action> {
+    if has_missing_file_context_fields(&file_info.name, &file_info.path) {
+        tracing::warn!(
+            target: "script_kit::actions",
+            name = %file_info.name,
+            path = %file_info.path,
+            is_dir = file_info.is_dir,
+            "Invalid file context info: missing path or name; returning no actions"
+        );
+        return Vec::new();
+    }
+
     let mut actions = Vec::new();
 
     tracing::debug!(
@@ -140,6 +155,17 @@
 
 /// Get actions specific to a file/folder path
 pub fn get_path_context_actions(path_info: &PathInfo) -> Vec<Action> {
+    if has_missing_file_context_fields(&path_info.name, &path_info.path) {
+        tracing::warn!(
+            target: "script_kit::actions",
+            name = %path_info.name,
+            path = %path_info.path,
+            is_dir = path_info.is_dir,
+            "Invalid path context info: missing path or name; returning no actions"
+        );
+        return Vec::new();
+    }
+
     let mut actions = vec![
         Action::new(
             "file:copy_path",
@@ -265,4 +291,24 @@
             .iter()
             .all(|action| action.id.starts_with("file:")));
     }
+
+    #[test]
+    fn test_get_file_context_actions_returns_empty_when_required_fields_missing() {
+        let mut file_info = sample_file_info(false);
+        file_info.path = "   ".to_string();
+
+        let actions = get_file_context_actions(&file_info);
+
+        assert!(actions.is_empty());
+    }
+
+    #[test]
+    fn test_get_path_context_actions_returns_empty_when_required_fields_missing() {
+        let mut path_info = sample_path_info(true);
+        path_info.name = "   ".to_string();
+
+        let actions = get_path_context_actions(&path_info);
+
+        assert!(actions.is_empty());
+    }
 }

 exited 101 in 9.78s:
    Checking script-kit-gpui v0.1.0 (/Users/johnlindquist/dev/script-kit-gpui)
warning: glob import doesn't reexport anything with visibility `pub(in crate::prompts)` because no imported item is public enough
  --> src/prompts/div/mod.rs:32:16
   |
32 | pub(super) use inline::*;
   |                ^^^^^^^^^
   |
note: the most public imported item is `pub(self)`
  --> src/prompts/div/mod.rs:32:16
   |
32 | pub(super) use inline::*;
   |                ^^^^^^^^^
   = help: reduce the glob import's visibility or increase visibility of imported items
   = note: `#[warn(unused_imports)]` (part of `#[warn(unused)]`) on by default

warning: glob import doesn't reexport anything with visibility `pub(in crate::prompts)` because no imported item is public enough
  --> src/prompts/div/mod.rs:34:16
   |
34 | pub(super) use render_html::*;
   |                ^^^^^^^^^^^^^^

thinking
**Testing linting failures**
codex
`cargo check -p script-kit-gpui` fails from unrelated clipboard-history compile breakage in other files, not these builders. I’m running `cargo clippy -p script-kit-gpui --all-targets -- -D warnings` next and will report the exact blocker set.
exec
/bin/zsh -lc 'cargo clippy -p script-kit-gpui --all-targets -- -D warnings' in /Users/johnlindquist/dev/script-kit-gpuifile update:
diff --git a/src/actions/builders/chat.rs b/src/actions/builders/chat.rs
index 5bf8650ab171d725e5b79d58333b2ecfad8edb3a..b62991e4ebf542501b6178b3eba85c14f273305a
--- a/src/actions/builders/chat.rs
+++ b/src/actions/builders/chat.rs
@@ -18,8 +18,47 @@
     pub provider: String,
 }
 
+fn has_missing_chat_model_fields(model: &ChatModelInfo) -> bool {
+    model.id.trim().is_empty()
+        || model.display_name.trim().is_empty()
+        || model.provider.trim().is_empty()
+}
+
 /// Get actions specific to a chat prompt.
 pub fn get_chat_context_actions(info: &ChatPromptInfo) -> Vec<Action> {
+    let has_blank_current_model = info
+        .current_model
+        .as_ref()
+        .map(|model| model.trim().is_empty())
+        .unwrap_or(false);
+    if has_blank_current_model {
+        tracing::warn!(
+            target: "script_kit::actions",
+            model_count = info.available_models.len(),
+            has_messages = info.has_messages,
+            has_response = info.has_response,
+            "Invalid chat prompt info: current model name is blank; returning no actions"
+        );
+        return Vec::new();
+    }
+
+    let invalid_model_count = info
+        .available_models
+        .iter()
+        .filter(|model| has_missing_chat_model_fields(model))
+        .count();
+    if invalid_model_count > 0 {
+        tracing::warn!(
+            target: "script_kit::actions",
+            invalid_model_count,
+            model_count = info.available_models.len(),
+            has_messages = info.has_messages,
+            has_response = info.has_response,
+            "Invalid chat prompt info: model metadata missing required fields; returning no actions"
+        );
+        return Vec::new();
+    }
+
     let mut actions = Vec::new();
 
     for model in &info.available_models {
@@ -227,4 +266,24 @@
         let actions = get_ai_command_bar_actions();
         assert!(actions.iter().all(|action| action.id.starts_with("chat:")));
     }
+
+    #[test]
+    fn test_get_chat_context_actions_returns_empty_when_model_metadata_missing() {
+        let mut info = sample_prompt_info();
+        info.available_models[0].id = "   ".to_string();
+
+        let actions = get_chat_context_actions(&info);
+
+        assert!(actions.is_empty());
+    }
+
+    #[test]
+    fn test_get_chat_context_actions_returns_empty_when_current_model_is_blank() {
+        let mut info = sample_prompt_info();
+        info.current_model = Some("   ".to_string());
+
+        let actions = get_chat_context_actions(&info);
+
+        assert!(actions.is_empty());
+    }
 }
diff --git a/src/actions/builders/clipboard.rs b/src/actions/builders/clipboard.rs
index 61c4fac2f27aae73b516b1b487482f96e2cd8c56..dc0dd0b3d0d84f9ae8b851d7cb80caf6de122d89
--- a/src/actions/builders/clipboard.rs
+++ b/src/actions/builders/clipboard.rs
@@ -22,6 +22,16 @@
 /// Get actions specific to a clipboard history entry.
 #[allow(clippy::vec_init_then_push)]
 pub fn get_clipboard_history_context_actions(entry: &ClipboardEntryInfo) -> Vec<Action> {
+    if entry.id.trim().is_empty() {
+        tracing::warn!(
+            target: "script_kit::actions",
+            content_type = ?entry.content_type,
+            pinned = entry.pinned,
+            "Invalid clipboard entry context: missing entry id; returning no actions"
+        );
+        return Vec::new();
+    }
+
     let mut actions = Vec::new();
 
     tracing::debug!(
@@ -254,4 +264,14 @@
             .iter()
             .all(|action| action.id.starts_with("clip:")));
     }
+
+    #[test]
+    fn test_get_clipboard_history_context_actions_returns_empty_when_entry_id_missing() {
+        let mut entry = entry_info(ContentType::Text, false);
+        entry.id = "   ".to_string();
+
+        let actions = get_clipboard_history_context_actions(&entry);
+
+        assert!(actions.is_empty());
+    }
 }
diff --git a/src/actions/builders/file_path.rs b/src/actions/builders/file_path.rs
index dfc224185994ff07cf51b25248e26ba16a11b56b..ac82caac18f27e7215572e0e859f856c2aa8291f
--- a/src/actions/builders/file_path.rs
+++ b/src/actions/builders/file_path.rs
@@ -2,6 +2,10 @@
 use crate::file_search::FileInfo;
 use crate::prompts::PathInfo;
 
+fn has_missing_file_context_fields(name: &str, path: &str) -> bool {
+    name.trim().is_empty() || path.trim().is_empty()
+}
+
 /// Get actions specific to a file search result
 ///
 /// Actions vary based on whether the item is a file or directory:
@@ -10,6 +14,17 @@
 ///
 /// Common actions for both: file:reveal_in_finder, file:copy_path, file:copy_filename
 pub fn get_file_context_actions(file_info: &FileInfo) -> Vec<Action> {
+    if has_missing_file_context_fields(&file_info.name, &file_info.path) {
+        tracing::warn!(
+            target: "script_kit::actions",
+            name = %file_info.name,
+            path = %file_info.path,
+            is_dir = file_info.is_dir,
+            "Invalid file context info: missing path or name; returning no actions"
+        );
+        return Vec::new();
+    }
+
     let mut actions = Vec::new();
 
     tracing::debug!(
@@ -140,6 +155,17 @@
 
 /// Get actions specific to a file/folder path
 pub fn get_path_context_actions(path_info: &PathInfo) -> Vec<Action> {
+    if has_missing_file_context_fields(&path_info.name, &path_info.path) {
+        tracing::warn!(
+            target: "script_kit::actions",
+            name = %path_info.name,
+            path = %path_info.path,
+            is_dir = path_info.is_dir,
+            "Invalid path context info: missing path or name; returning no actions"
+        );
+        return Vec::new();
+    }
+
     let mut actions = vec![
         Action::new(
             "file:copy_path",
@@ -265,4 +291,24 @@
             .iter()
             .all(|action| action.id.starts_with("file:")));
     }
+
+    #[test]
+    fn test_get_file_context_actions_returns_empty_when_required_fields_missing() {
+        let mut file_info = sample_file_info(false);
+        file_info.path = "   ".to_string();
+
+        let actions = get_file_context_actions(&file_info);
+
+        assert!(actions.is_empty());
+    }
+
+    #[test]
+    fn test_get_path_context_actions_returns_empty_when_required_fields_missing() {
+        let mut path_info = sample_path_info(true);
+        path_info.name = "   ".to_string();
+
+        let actions = get_path_context_actions(&path_info);
+
+        assert!(actions.is_empty());
+    }
 }


thinking
**Planning polling mechanism**
file update:
diff --git a/src/actions/builders/chat.rs b/src/actions/builders/chat.rs
index 5bf8650ab171d725e5b79d58333b2ecfad8edb3a..b62991e4ebf542501b6178b3eba85c14f273305a
--- a/src/actions/builders/chat.rs
+++ b/src/actions/builders/chat.rs
@@ -18,8 +18,47 @@
     pub provider: String,
 }
 
+fn has_missing_chat_model_fields(model: &ChatModelInfo) -> bool {
+    model.id.trim().is_empty()
+        || model.display_name.trim().is_empty()
+        || model.provider.trim().is_empty()
+}
+
 /// Get actions specific to a chat prompt.
 pub fn get_chat_context_actions(info: &ChatPromptInfo) -> Vec<Action> {
+    let has_blank_current_model = info
+        .current_model
+        .as_ref()
+        .map(|model| model.trim().is_empty())
+        .unwrap_or(false);
+    if has_blank_current_model {
+        tracing::warn!(
+            target: "script_kit::actions",
+            model_count = info.available_models.len(),
+            has_messages = info.has_messages,
+            has_response = info.has_response,
+            "Invalid chat prompt info: current model name is blank; returning no actions"
+        );
+        return Vec::new();
+    }
+
+    let invalid_model_count = info
+        .available_models
+        .iter()
+        .filter(|model| has_missing_chat_model_fields(model))
+        .count();
+    if invalid_model_count > 0 {
+        tracing::warn!(
+            target: "script_kit::actions",
+            invalid_model_count,
+            model_count = info.available_models.len(),
+            has_messages = info.has_messages,
+            has_response = info.has_response,
+            "Invalid chat prompt info: model metadata missing required fields; returning no actions"
+        );
+        return Vec::new();
+    }
+
     let mut actions = Vec::new();
 
     for model in &info.available_models {
@@ -227,4 +266,24 @@
         let actions = get_ai_command_bar_actions();
         assert!(actions.iter().all(|action| action.id.starts_with("chat:")));
     }
+
+    #[test]
+    fn test_get_chat_context_actions_returns_empty_when_model_metadata_missing() {
+        let mut info = sample_prompt_info();
+        info.available_models[0].id = "   ".to_string();
+
+        let actions = get_chat_context_actions(&info);
+
+        assert!(actions.is_empty());
+    }
+
+    #[test]
+    fn test_get_chat_context_actions_returns_empty_when_current_model_is_blank() {
+        let mut info = sample_prompt_info();
+        info.current_model = Some("   ".to_string());
+
+        let actions = get_chat_context_actions(&info);
+
+        assert!(actions.is_empty());
+    }
 }
diff --git a/src/actions/builders/clipboard.rs b/src/actions/builders/clipboard.rs
index 61c4fac2f27aae73b516b1b487482f96e2cd8c56..dc0dd0b3d0d84f9ae8b851d7cb80caf6de122d89
--- a/src/actions/builders/clipboard.rs
+++ b/src/actions/builders/clipboard.rs
@@ -22,6 +22,16 @@
 /// Get actions specific to a clipboard history entry.
 #[allow(clippy::vec_init_then_push)]
 pub fn get_clipboard_history_context_actions(entry: &ClipboardEntryInfo) -> Vec<Action> {
+    if entry.id.trim().is_empty() {
+        tracing::warn!(
+            target: "script_kit::actions",
+            content_type = ?entry.content_type,
+            pinned = entry.pinned,
+            "Invalid clipboard entry context: missing entry id; returning no actions"
+        );
+        return Vec::new();
+    }
+
     let mut actions = Vec::new();
 
     tracing::debug!(
@@ -254,4 +264,14 @@
             .iter()
             .all(|action| action.id.starts_with("clip:")));
     }
+
+    #[test]
+    fn test_get_clipboard_history_context_actions_returns_empty_when_entry_id_missing() {
+        let mut entry = entry_info(ContentType::Text, false);
+        entry.id = "   ".to_string();
+
+        let actions = get_clipboard_history_context_actions(&entry);
+
+        assert!(actions.is_empty());
+    }
 }
diff --git a/src/actions/builders/file_path.rs b/src/actions/builders/file_path.rs
index dfc224185994ff07cf51b25248e26ba16a11b56b..ac82caac18f27e7215572e0e859f856c2aa8291f
--- a/src/actions/builders/file_path.rs
+++ b/src/actions/builders/file_path.rs
@@ -2,6 +2,10 @@
 use crate::file_search::FileInfo;
 use crate::prompts::PathInfo;
 
+fn has_missing_file_context_fields(name: &str, path: &str) -> bool {
+    name.trim().is_empty() || path.trim().is_empty()
+}
+
 /// Get actions specific to a file search result
 ///
 /// Actions vary based on whether the item is a file or directory:
@@ -10,6 +14,17 @@
 ///
 /// Common actions for both: file:reveal_in_finder, file:copy_path, file:copy_filename
 pub fn get_file_context_actions(file_info: &FileInfo) -> Vec<Action> {
+    if has_missing_file_context_fields(&file_info.name, &file_info.path) {
+        tracing::warn!(
+            target: "script_kit::actions",
+            name = %file_info.name,
+            path = %file_info.path,
+            is_dir = file_info.is_dir,
+            "Invalid file context info: missing path or name; returning no actions"
+        );
+        return Vec::new();
+    }
+
     let mut actions = Vec::new();
 
     tracing::debug!(
@@ -140,6 +155,17 @@
 
 /// Get actions specific to a file/folder path
 pub fn get_path_context_actions(path_info: &PathInfo) -> Vec<Action> {
+    if has_missing_file_context_fields(&path_info.name, &path_info.path) {
+        tracing::warn!(
+            target: "script_kit::actions",
+            name = %path_info.name,
+            path = %path_info.path,
+            is_dir = path_info.is_dir,
+            "Invalid path context info: missing path or name; returning no actions"
+        );
+        return Vec::new();
+    }
+
     let mut actions = vec![
         Action::new(
             "file:copy_path",
@@ -265,4 +291,24 @@
             .iter()
             .all(|action| action.id.starts_with("file:")));
     }
+
+    #[test]
+    fn test_get_file_context_actions_returns_empty_when_required_fields_missing() {
+        let mut file_info = sample_file_info(false);
+        file_info.path = "   ".to_string();
+
+        let actions = get_file_context_actions(&file_info);
+
+        assert!(actions.is_empty());
+    }
+
+    #[test]
+    fn test_get_path_context_actions_returns_empty_when_required_fields_missing() {
+        let mut path_info = sample_path_info(true);
+        path_info.name = "   ".to_string();
+
+        let actions = get_path_context_actions(&path_info);
+
+        assert!(actions.is_empty());
+    }
 }

file update:
diff --git a/src/actions/builders/chat.rs b/src/actions/builders/chat.rs
index 5bf8650ab171d725e5b79d58333b2ecfad8edb3a..b62991e4ebf542501b6178b3eba85c14f273305a
--- a/src/actions/builders/chat.rs
+++ b/src/actions/builders/chat.rs
@@ -18,8 +18,47 @@
     pub provider: String,
 }
 
+fn has_missing_chat_model_fields(model: &ChatModelInfo) -> bool {
+    model.id.trim().is_empty()
+        || model.display_name.trim().is_empty()
+        || model.provider.trim().is_empty()
+}
+
 /// Get actions specific to a chat prompt.
 pub fn get_chat_context_actions(info: &ChatPromptInfo) -> Vec<Action> {
+    let has_blank_current_model = info
+        .current_model
+        .as_ref()
+        .map(|model| model.trim().is_empty())
+        .unwrap_or(false);
+    if has_blank_current_model {
+        tracing::warn!(
+            target: "script_kit::actions",
+            model_count = info.available_models.len(),
+            has_messages = info.has_messages,
+            has_response = info.has_response,
+            "Invalid chat prompt info: current model name is blank; returning no actions"
+        );
+        return Vec::new();
+    }
+
+    let invalid_model_count = info
+        .available_models
+        .iter()
+        .filter(|model| has_missing_chat_model_fields(model))
+        .count();
+    if invalid_model_count > 0 {
+        tracing::warn!(
+            target: "script_kit::actions",
+            invalid_model_count,
+            model_count = info.available_models.len(),
+            has_messages = info.has_messages,
+            has_response = info.has_response,
+            "Invalid chat prompt info: model metadata missing required fields; returning no actions"
+        );
+        return Vec::new();
+    }
+
     let mut actions = Vec::new();
 
     for model in &info.available_models {
@@ -227,4 +266,24 @@
         let actions = get_ai_command_bar_actions();
         assert!(actions.iter().all(|action| action.id.starts_with("chat:")));
     }
+
+    #[test]
+    fn test_get_chat_context_actions_returns_empty_when_model_metadata_missing() {
+        let mut info = sample_prompt_info();
+        info.available_models[0].id = "   ".to_string();
+
+        let actions = get_chat_context_actions(&info);
+
+        assert!(actions.is_empty());
+    }
+
+    #[test]
+    fn test_get_chat_context_actions_returns_empty_when_current_model_is_blank() {
+        let mut info = sample_prompt_info();
+        info.current_model = Some("   ".to_string());
+
+        let actions = get_chat_context_actions(&info);
+
+        assert!(actions.is_empty());
+    }
 }
diff --git a/src/actions/builders/clipboard.rs b/src/actions/builders/clipboard.rs
index 61c4fac2f27aae73b516b1b487482f96e2cd8c56..dc0dd0b3d0d84f9ae8b851d7cb80caf6de122d89
--- a/src/actions/builders/clipboard.rs
+++ b/src/actions/builders/clipboard.rs
@@ -22,6 +22,16 @@
 /// Get actions specific to a clipboard history entry.
 #[allow(clippy::vec_init_then_push)]
 pub fn get_clipboard_history_context_actions(entry: &ClipboardEntryInfo) -> Vec<Action> {
+    if entry.id.trim().is_empty() {
+        tracing::warn!(
+            target: "script_kit::actions",
+            content_type = ?entry.content_type,
+            pinned = entry.pinned,
+            "Invalid clipboard entry context: missing entry id; returning no actions"
+        );
+        return Vec::new();
+    }
+
     let mut actions = Vec::new();
 
     tracing::debug!(
@@ -254,4 +264,14 @@
             .iter()
             .all(|action| action.id.starts_with("clip:")));
     }
+
+    #[test]
+    fn test_get_clipboard_history_context_actions_returns_empty_when_entry_id_missing() {
+        let mut entry = entry_info(ContentType::Text, false);
+        entry.id = "   ".to_string();
+
+        let actions = get_clipboard_history_context_actions(&entry);
+
+        assert!(actions.is_empty());
+    }
 }
diff --git a/src/actions/builders/file_path.rs b/src/actions/builders/file_path.rs
index dfc224185994ff07cf51b25248e26ba16a11b56b..ac82caac18f27e7215572e0e859f856c2aa8291f
--- a/src/actions/builders/file_path.rs
+++ b/src/actions/builders/file_path.rs
@@ -2,6 +2,10 @@
 use crate::file_search::FileInfo;
 use crate::prompts::PathInfo;
 
+fn has_missing_file_context_fields(name: &str, path: &str) -> bool {
+    name.trim().is_empty() || path.trim().is_empty()
+}
+
 /// Get actions specific to a file search result
 ///
 /// Actions vary based on whether the item is a file or directory:
@@ -10,6 +14,17 @@
 ///
 /// Common actions for both: file:reveal_in_finder, file:copy_path, file:copy_filename
 pub fn get_file_context_actions(file_info: &FileInfo) -> Vec<Action> {
+    if has_missing_file_context_fields(&file_info.name, &file_info.path) {
+        tracing::warn!(
+            target: "script_kit::actions",
+            name = %file_info.name,
+            path = %file_info.path,
+            is_dir = file_info.is_dir,
+            "Invalid file context info: missing path or name; returning no actions"
+        );
+        return Vec::new();
+    }
+
     let mut actions = Vec::new();
 
     tracing::debug!(
@@ -140,6 +155,17 @@
 
 /// Get actions specific to a file/folder path
 pub fn get_path_context_actions(path_info: &PathInfo) -> Vec<Action> {
+    if has_missing_file_context_fields(&path_info.name, &path_info.path) {
+        tracing::warn!(
+            target: "script_kit::actions",
+            name = %path_info.name,
+            path = %path_info.path,
+            is_dir = path_info.is_dir,
+            "Invalid path context info: missing path or name; returning no actions"
+        );
+        return Vec::new();
+    }
+
     let mut actions = vec![
         Action::new(
             "file:copy_path",
@@ -265,4 +291,24 @@
             .iter()
             .all(|action| action.id.starts_with("file:")));
     }
+
+    #[test]
+    fn test_get_file_context_actions_returns_empty_when_required_fields_missing() {
+        let mut file_info = sample_file_info(false);
+        file_info.path = "   ".to_string();
+
+        let actions = get_file_context_actions(&file_info);
+
+        assert!(actions.is_empty());
+    }
+
+    #[test]
+    fn test_get_path_context_actions_returns_empty_when_required_fields_missing() {
+        let mut path_info = sample_path_info(true);
+        path_info.name = "   ".to_string();
+
+        let actions = get_path_context_actions(&path_info);
+
+        assert!(actions.is_empty());
+    }
 }


thinking
**Adjusting polling interval**
file update:
diff --git a/src/actions/builders/chat.rs b/src/actions/builders/chat.rs
index 5bf8650ab171d725e5b79d58333b2ecfad8edb3a..b62991e4ebf542501b6178b3eba85c14f273305a
--- a/src/actions/builders/chat.rs
+++ b/src/actions/builders/chat.rs
@@ -18,8 +18,47 @@
     pub provider: String,
 }
 
+fn has_missing_chat_model_fields(model: &ChatModelInfo) -> bool {
+    model.id.trim().is_empty()
+        || model.display_name.trim().is_empty()
+        || model.provider.trim().is_empty()
+}
+
 /// Get actions specific to a chat prompt.
 pub fn get_chat_context_actions(info: &ChatPromptInfo) -> Vec<Action> {
+    let has_blank_current_model = info
+        .current_model
+        .as_ref()
+        .map(|model| model.trim().is_empty())
+        .unwrap_or(false);
+    if has_blank_current_model {
+        tracing::warn!(
+            target: "script_kit::actions",
+            model_count = info.available_models.len(),
+            has_messages = info.has_messages,
+            has_response = info.has_response,
+            "Invalid chat prompt info: current model name is blank; returning no actions"
+        );
+        return Vec::new();
+    }
+
+    let invalid_model_count = info
+        .available_models
+        .iter()
+        .filter(|model| has_missing_chat_model_fields(model))
+        .count();
+    if invalid_model_count > 0 {
+        tracing::warn!(
+            target: "script_kit::actions",
+            invalid_model_count,
+            model_count = info.available_models.len(),
+            has_messages = info.has_messages,
+            has_response = info.has_response,
+            "Invalid chat prompt info: model metadata missing required fields; returning no actions"
+        );
+        return Vec::new();
+    }
+
     let mut actions = Vec::new();
 
     for model in &info.available_models {
@@ -227,4 +266,24 @@
         let actions = get_ai_command_bar_actions();
         assert!(actions.iter().all(|action| action.id.starts_with("chat:")));
     }
+
+    #[test]
+    fn test_get_chat_context_actions_returns_empty_when_model_metadata_missing() {
+        let mut info = sample_prompt_info();
+        info.available_models[0].id = "   ".to_string();
+
+        let actions = get_chat_context_actions(&info);
+
+        assert!(actions.is_empty());
+    }
+
+    #[test]
+    fn test_get_chat_context_actions_returns_empty_when_current_model_is_blank() {
+        let mut info = sample_prompt_info();
+        info.current_model = Some("   ".to_string());
+
+        let actions = get_chat_context_actions(&info);
+
+        assert!(actions.is_empty());
+    }
 }
diff --git a/src/actions/builders/clipboard.rs b/src/actions/builders/clipboard.rs
index 61c4fac2f27aae73b516b1b487482f96e2cd8c56..dc0dd0b3d0d84f9ae8b851d7cb80caf6de122d89
--- a/src/actions/builders/clipboard.rs
+++ b/src/actions/builders/clipboard.rs
@@ -22,6 +22,16 @@
 /// Get actions specific to a clipboard history entry.
 #[allow(clippy::vec_init_then_push)]
 pub fn get_clipboard_history_context_actions(entry: &ClipboardEntryInfo) -> Vec<Action> {
+    if entry.id.trim().is_empty() {
+        tracing::warn!(
+            target: "script_kit::actions",
+            content_type = ?entry.content_type,
+            pinned = entry.pinned,
+            "Invalid clipboard entry context: missing entry id; returning no actions"
+        );
+        return Vec::new();
+    }
+
     let mut actions = Vec::new();
 
     tracing::debug!(
@@ -254,4 +264,14 @@
             .iter()
             .all(|action| action.id.starts_with("clip:")));
     }
+
+    #[test]
+    fn test_get_clipboard_history_context_actions_returns_empty_when_entry_id_missing() {
+        let mut entry = entry_info(ContentType::Text, false);
+        entry.id = "   ".to_string();
+
+        let actions = get_clipboard_history_context_actions(&entry);
+
+        assert!(actions.is_empty());
+    }
 }
diff --git a/src/actions/builders/file_path.rs b/src/actions/builders/file_path.rs
index dfc224185994ff07cf51b25248e26ba16a11b56b..ac82caac18f27e7215572e0e859f856c2aa8291f
--- a/src/actions/builders/file_path.rs
+++ b/src/actions/builders/file_path.rs
@@ -2,6 +2,10 @@
 use crate::file_search::FileInfo;
 use crate::prompts::PathInfo;
 
+fn has_missing_file_context_fields(name: &str, path: &str) -> bool {
+    name.trim().is_empty() || path.trim().is_empty()
+}
+
 /// Get actions specific to a file search result
 ///
 /// Actions vary based on whether the item is a file or directory:
@@ -10,6 +14,17 @@
 ///
 /// Common actions for both: file:reveal_in_finder, file:copy_path, file:copy_filename
 pub fn get_file_context_actions(file_info: &FileInfo) -> Vec<Action> {
+    if has_missing_file_context_fields(&file_info.name, &file_info.path) {
+        tracing::warn!(
+            target: "script_kit::actions",
+            name = %file_info.name,
+            path = %file_info.path,
+            is_dir = file_info.is_dir,
+            "Invalid file context info: missing path or name; returning no actions"
+        );
+        return Vec::new();
+    }
+
     let mut actions = Vec::new();
 
     tracing::debug!(
@@ -140,6 +155,17 @@
 
 /// Get actions specific to a file/folder path
 pub fn get_path_context_actions(path_info: &PathInfo) -> Vec<Action> {
+    if has_missing_file_context_fields(&path_info.name, &path_info.path) {
+        tracing::warn!(
+            target: "script_kit::actions",
+            name = %path_info.name,
+            path = %path_info.path,
+            is_dir = path_info.is_dir,
+            "Invalid path context info: missing path or name; returning no actions"
+        );
+        return Vec::new();
+    }
+
     let mut actions = vec![
         Action::new(
             "file:copy_path",
@@ -265,4 +291,24 @@
             .iter()
             .all(|action| action.id.starts_with("file:")));
     }
+
+    #[test]
+    fn test_get_file_context_actions_returns_empty_when_required_fields_missing() {
+        let mut file_info = sample_file_info(false);
+        file_info.path = "   ".to_string();
+
+        let actions = get_file_context_actions(&file_info);
+
+        assert!(actions.is_empty());
+    }
+
+    #[test]
+    fn test_get_path_context_actions_returns_empty_when_required_fields_missing() {
+        let mut path_info = sample_path_info(true);
+        path_info.name = "   ".to_string();
+
+        let actions = get_path_context_actions(&path_info);
+
+        assert!(actions.is_empty());
+    }
 }

file update:
diff --git a/src/actions/builders/chat.rs b/src/actions/builders/chat.rs
index 5bf8650ab171d725e5b79d58333b2ecfad8edb3a..b62991e4ebf542501b6178b3eba85c14f273305a
--- a/src/actions/builders/chat.rs
+++ b/src/actions/builders/chat.rs
@@ -18,8 +18,47 @@
     pub provider: String,
 }
 
+fn has_missing_chat_model_fields(model: &ChatModelInfo) -> bool {
+    model.id.trim().is_empty()
+        || model.display_name.trim().is_empty()
+        || model.provider.trim().is_empty()
+}
+
 /// Get actions specific to a chat prompt.
 pub fn get_chat_context_actions(info: &ChatPromptInfo) -> Vec<Action> {
+    let has_blank_current_model = info
+        .current_model
+        .as_ref()
+        .map(|model| model.trim().is_empty())
+        .unwrap_or(false);
+    if has_blank_current_model {
+        tracing::warn!(
+            target: "script_kit::actions",
+            model_count = info.available_models.len(),
+            has_messages = info.has_messages,
+            has_response = info.has_response,
+            "Invalid chat prompt info: current model name is blank; returning no actions"
+        );
+        return Vec::new();
+    }
+
+    let invalid_model_count = info
+        .available_models
+        .iter()
+        .filter(|model| has_missing_chat_model_fields(model))
+        .count();
+    if invalid_model_count > 0 {
+        tracing::warn!(
+            target: "script_kit::actions",
+            invalid_model_count,
+            model_count = info.available_models.len(),
+            has_messages = info.has_messages,
+            has_response = info.has_response,
+            "Invalid chat prompt info: model metadata missing required fields; returning no actions"
+        );
+        return Vec::new();
+    }
+
     let mut actions = Vec::new();
 
     for model in &info.available_models {
@@ -227,4 +266,24 @@
         let actions = get_ai_command_bar_actions();
         assert!(actions.iter().all(|action| action.id.starts_with("chat:")));
     }
+
+    #[test]
+    fn test_get_chat_context_actions_returns_empty_when_model_metadata_missing() {
+        let mut info = sample_prompt_info();
+        info.available_models[0].id = "   ".to_string();
+
+        let actions = get_chat_context_actions(&info);
+
+        assert!(actions.is_empty());
+    }
+
+    #[test]
+    fn test_get_chat_context_actions_returns_empty_when_current_model_is_blank() {
+        let mut info = sample_prompt_info();
+        info.current_model = Some("   ".to_string());
+
+        let actions = get_chat_context_actions(&info);
+
+        assert!(actions.is_empty());
+    }
 }
diff --git a/src/actions/builders/clipboard.rs b/src/actions/builders/clipboard.rs
index 61c4fac2f27aae73b516b1b487482f96e2cd8c56..dc0dd0b3d0d84f9ae8b851d7cb80caf6de122d89
--- a/src/actions/builders/clipboard.rs
+++ b/src/actions/builders/clipboard.rs
@@ -22,6 +22,16 @@
 /// Get actions specific to a clipboard history entry.
 #[allow(clippy::vec_init_then_push)]
 pub fn get_clipboard_history_context_actions(entry: &ClipboardEntryInfo) -> Vec<Action> {
+    if entry.id.trim().is_empty() {
+        tracing::warn!(
+            target: "script_kit::actions",
+            content_type = ?entry.content_type,
+            pinned = entry.pinned,
+            "Invalid clipboard entry context: missing entry id; returning no actions"
+        );
+        return Vec::new();
+    }
+
     let mut actions = Vec::new();
 
     tracing::debug!(
@@ -254,4 +264,14 @@
             .iter()
             .all(|action| action.id.starts_with("clip:")));
     }
+
+    #[test]
+    fn test_get_clipboard_history_context_actions_returns_empty_when_entry_id_missing() {
+        let mut entry = entry_info(ContentType::Text, false);
+        entry.id = "   ".to_string();
+
+        let actions = get_clipboard_history_context_actions(&entry);
+
+        assert!(actions.is_empty());
+    }
 }
diff --git a/src/actions/builders/file_path.rs b/src/actions/builders/file_path.rs
index dfc224185994ff07cf51b25248e26ba16a11b56b..ac82caac18f27e7215572e0e859f856c2aa8291f
--- a/src/actions/builders/file_path.rs
+++ b/src/actions/builders/file_path.rs
@@ -2,6 +2,10 @@
 use crate::file_search::FileInfo;
 use crate::prompts::PathInfo;
 
+fn has_missing_file_context_fields(name: &str, path: &str) -> bool {
+    name.trim().is_empty() || path.trim().is_empty()
+}
+
 /// Get actions specific to a file search result
 ///
 /// Actions vary based on whether the item is a file or directory:
@@ -10,6 +14,17 @@
 ///
 /// Common actions for both: file:reveal_in_finder, file:copy_path, file:copy_filename
 pub fn get_file_context_actions(file_info: &FileInfo) -> Vec<Action> {
+    if has_missing_file_context_fields(&file_info.name, &file_info.path) {
+        tracing::warn!(
+            target: "script_kit::actions",
+            name = %file_info.name,
+            path = %file_info.path,
+            is_dir = file_info.is_dir,
+            "Invalid file context info: missing path or name; returning no actions"
+        );
+        return Vec::new();
+    }
+
     let mut actions = Vec::new();
 
     tracing::debug!(
@@ -140,6 +155,17 @@
 
 /// Get actions specific to a file/folder path
 pub fn get_path_context_actions(path_info: &PathInfo) -> Vec<Action> {
+    if has_missing_file_context_fields(&path_info.name, &path_info.path) {
+        tracing::warn!(
+            target: "script_kit::actions",
+            name = %path_info.name,
+            path = %path_info.path,
+            is_dir = path_info.is_dir,
+            "Invalid path context info: missing path or name; returning no actions"
+        );
+        return Vec::new();
+    }
+
     let mut actions = vec![
         Action::new(
             "file:copy_path",
@@ -265,4 +291,24 @@
             .iter()
             .all(|action| action.id.starts_with("file:")));
     }
+
+    #[test]
+    fn test_get_file_context_actions_returns_empty_when_required_fields_missing() {
+        let mut file_info = sample_file_info(false);
+        file_info.path = "   ".to_string();
+
+        let actions = get_file_context_actions(&file_info);
+
+        assert!(actions.is_empty());
+    }
+
+    #[test]
+    fn test_get_path_context_actions_returns_empty_when_required_fields_missing() {
+        let mut path_info = sample_path_info(true);
+        path_info.name = "   ".to_string();
+
+        let actions = get_path_context_actions(&path_info);
+
+        assert!(actions.is_empty());
+    }
 }


thinking
**Monitoring process completion**
file update:
diff --git a/src/actions/builders/chat.rs b/src/actions/builders/chat.rs
index 5bf8650ab171d725e5b79d58333b2ecfad8edb3a..b62991e4ebf542501b6178b3eba85c14f273305a
--- a/src/actions/builders/chat.rs
+++ b/src/actions/builders/chat.rs
@@ -18,8 +18,47 @@
     pub provider: String,
 }
 
+fn has_missing_chat_model_fields(model: &ChatModelInfo) -> bool {
+    model.id.trim().is_empty()
+        || model.display_name.trim().is_empty()
+        || model.provider.trim().is_empty()
+}
+
 /// Get actions specific to a chat prompt.
 pub fn get_chat_context_actions(info: &ChatPromptInfo) -> Vec<Action> {
+    let has_blank_current_model = info
+        .current_model
+        .as_ref()
+        .map(|model| model.trim().is_empty())
+        .unwrap_or(false);
+    if has_blank_current_model {
+        tracing::warn!(
+            target: "script_kit::actions",
+            model_count = info.available_models.len(),
+            has_messages = info.has_messages,
+            has_response = info.has_response,
+            "Invalid chat prompt info: current model name is blank; returning no actions"
+        );
+        return Vec::new();
+    }
+
+    let invalid_model_count = info
+        .available_models
+        .iter()
+        .filter(|model| has_missing_chat_model_fields(model))
+        .count();
+    if invalid_model_count > 0 {
+        tracing::warn!(
+            target: "script_kit::actions",
+            invalid_model_count,
+            model_count = info.available_models.len(),
+            has_messages = info.has_messages,
+            has_response = info.has_response,
+            "Invalid chat prompt info: model metadata missing required fields; returning no actions"
+        );
+        return Vec::new();
+    }
+
     let mut actions = Vec::new();
 
     for model in &info.available_models {
@@ -227,4 +266,24 @@
         let actions = get_ai_command_bar_actions();
         assert!(actions.iter().all(|action| action.id.starts_with("chat:")));
     }
+
+    #[test]
+    fn test_get_chat_context_actions_returns_empty_when_model_metadata_missing() {
+        let mut info = sample_prompt_info();
+        info.available_models[0].id = "   ".to_string();
+
+        let actions = get_chat_context_actions(&info);
+
+        assert!(actions.is_empty());
+    }
+
+    #[test]
+    fn test_get_chat_context_actions_returns_empty_when_current_model_is_blank() {
+        let mut info = sample_prompt_info();
+        info.current_model = Some("   ".to_string());
+
+        let actions = get_chat_context_actions(&info);
+
+        assert!(actions.is_empty());
+    }
 }
diff --git a/src/actions/builders/clipboard.rs b/src/actions/builders/clipboard.rs
index 61c4fac2f27aae73b516b1b487482f96e2cd8c56..dc0dd0b3d0d84f9ae8b851d7cb80caf6de122d89
--- a/src/actions/builders/clipboard.rs
+++ b/src/actions/builders/clipboard.rs
@@ -22,6 +22,16 @@
 /// Get actions specific to a clipboard history entry.
 #[allow(clippy::vec_init_then_push)]
 pub fn get_clipboard_history_context_actions(entry: &ClipboardEntryInfo) -> Vec<Action> {
+    if entry.id.trim().is_empty() {
+        tracing::warn!(
+            target: "script_kit::actions",
+            content_type = ?entry.content_type,
+            pinned = entry.pinned,
+            "Invalid clipboard entry context: missing entry id; returning no actions"
+        );
+        return Vec::new();
+    }
+
     let mut actions = Vec::new();
 
     tracing::debug!(
@@ -254,4 +264,14 @@
             .iter()
             .all(|action| action.id.starts_with("clip:")));
     }
+
+    #[test]
+    fn test_get_clipboard_history_context_actions_returns_empty_when_entry_id_missing() {
+        let mut entry = entry_info(ContentType::Text, false);
+        entry.id = "   ".to_string();
+
+        let actions = get_clipboard_history_context_actions(&entry);
+
+        assert!(actions.is_empty());
+    }
 }
diff --git a/src/actions/builders/file_path.rs b/src/actions/builders/file_path.rs
index dfc224185994ff07cf51b25248e26ba16a11b56b..ac82caac18f27e7215572e0e859f856c2aa8291f
--- a/src/actions/builders/file_path.rs
+++ b/src/actions/builders/file_path.rs
@@ -2,6 +2,10 @@
 use crate::file_search::FileInfo;
 use crate::prompts::PathInfo;
 
+fn has_missing_file_context_fields(name: &str, path: &str) -> bool {
+    name.trim().is_empty() || path.trim().is_empty()
+}
+
 /// Get actions specific to a file search result
 ///
 /// Actions vary based on whether the item is a file or directory:
@@ -10,6 +14,17 @@
 ///
 /// Common actions for both: file:reveal_in_finder, file:copy_path, file:copy_filename
 pub fn get_file_context_actions(file_info: &FileInfo) -> Vec<Action> {
+    if has_missing_file_context_fields(&file_info.name, &file_info.path) {
+        tracing::warn!(
+            target: "script_kit::actions",
+            name = %file_info.name,
+            path = %file_info.path,
+            is_dir = file_info.is_dir,
+            "Invalid file context info: missing path or name; returning no actions"
+        );
+        return Vec::new();
+    }
+
     let mut actions = Vec::new();
 
     tracing::debug!(
@@ -140,6 +155,17 @@
 
 /// Get actions specific to a file/folder path
 pub fn get_path_context_actions(path_info: &PathInfo) -> Vec<Action> {
+    if has_missing_file_context_fields(&path_info.name, &path_info.path) {
+        tracing::warn!(
+            target: "script_kit::actions",
+            name = %path_info.name,
+            path = %path_info.path,
+            is_dir = path_info.is_dir,
+            "Invalid path context info: missing path or name; returning no actions"
+        );
+        return Vec::new();
+    }
+
     let mut actions = vec![
         Action::new(
             "file:copy_path",
@@ -265,4 +291,24 @@
             .iter()
             .all(|action| action.id.starts_with("file:")));
     }
+
+    #[test]
+    fn test_get_file_context_actions_returns_empty_when_required_fields_missing() {
+        let mut file_info = sample_file_info(false);
+        file_info.path = "   ".to_string();
+
+        let actions = get_file_context_actions(&file_info);
+
+        assert!(actions.is_empty());
+    }
+
+    #[test]
+    fn test_get_path_context_actions_returns_empty_when_required_fields_missing() {
+        let mut path_info = sample_path_info(true);
+        path_info.name = "   ".to_string();
+
+        let actions = get_path_context_actions(&path_info);
+
+        assert!(actions.is_empty());
+    }
 }

 exited 101 in 33.77s:
    Blocking waiting for file lock on build directory
    Checking script-kit-gpui v0.1.0 (/Users/johnlindquist/dev/script-kit-gpui)
error[E0761]: file for module `tests` found at both "src/protocol/message/tests.rs" and "src/protocol/message/tests/mod.rs"
  --> src/protocol/message/mod.rs:87:1
   |
87 | mod tests;
   | ^^^^^^^^^^
   |
   = help: delete or rename one of them to remove the ambiguity

error[E0761]: file for module `tests` found at both "src/designs/core/tests.rs" and "src/designs/core/tests/mod.rs"
 --> src/designs/core/part_04.rs:2:1
  |
2 | mod tests;
  | ^^^^^^^^^^
  |
  = help: delete or rename one of them to remove the ambiguity

error: glob import doesn't reexport anything with visibility `pub(in crate::prompts)` because no imported item is public enough
  --> src/prompts/div/mod.rs:32:16

thinking
**Assessing compile issues blocking tests**
exec
/bin/zsh -lc "rg -n \"unwrap\\(|expect\\(|panic"'!" src/actions/builders/chat.rs src/actions/builders/clipboard.rs src/actions/builders/file_path.rs' in /Users/johnlindquist/dev/script-kit-gpuiexec
/bin/zsh -lc 'rg -n "tracing::warn!" src/actions/builders/chat.rs src/actions/builders/clipboard.rs src/actions/builders/file_path.rs' in /Users/johnlindquist/dev/script-kit-gpui succeeded in 50ms:
src/actions/builders/file_path.rs:146:            .expect("missing open_with action");
 succeeded in 51ms:
src/actions/builders/chat.rs:35:        tracing::warn!(
src/actions/builders/chat.rs:51:        tracing::warn!(
src/actions/builders/file_path.rs:18:        tracing::warn!(
src/actions/builders/file_path.rs:159:        tracing::warn!(
src/actions/builders/clipboard.rs:26:        tracing::warn!(
file update:
diff --git a/src/actions/builders/chat.rs b/src/actions/builders/chat.rs
index 5bf8650ab171d725e5b79d58333b2ecfad8edb3a..b62991e4ebf542501b6178b3eba85c14f273305a
--- a/src/actions/builders/chat.rs
+++ b/src/actions/builders/chat.rs
@@ -18,8 +18,47 @@
     pub provider: String,
 }
 
+fn has_missing_chat_model_fields(model: &ChatModelInfo) -> bool {
+    model.id.trim().is_empty()
+        || model.display_name.trim().is_empty()
+        || model.provider.trim().is_empty()
+}
+
 /// Get actions specific to a chat prompt.
 pub fn get_chat_context_actions(info: &ChatPromptInfo) -> Vec<Action> {
+    let has_blank_current_model = info
+        .current_model
+        .as_ref()
+        .map(|model| model.trim().is_empty())
+        .unwrap_or(false);
+    if has_blank_current_model {
+        tracing::warn!(
+            target: "script_kit::actions",
+            model_count = info.available_models.len(),
+            has_messages = info.has_messages,
+            has_response = info.has_response,
+            "Invalid chat prompt info: current model name is blank; returning no actions"
+        );
+        return Vec::new();
+    }
+
+    let invalid_model_count = info
+        .available_models
+        .iter()
+        .filter(|model| has_missing_chat_model_fields(model))
+        .count();
+    if invalid_model_count > 0 {
+        tracing::warn!(
+            target: "script_kit::actions",
+            invalid_model_count,
+            model_count = info.available_models.len(),
+            has_messages = info.has_messages,
+            has_response = info.has_response,
+            "Invalid chat prompt info: model metadata missing required fields; returning no actions"
+        );
+        return Vec::new();
+    }
+
     let mut actions = Vec::new();
 
     for model in &info.available_models {
@@ -227,4 +266,24 @@
         let actions = get_ai_command_bar_actions();
         assert!(actions.iter().all(|action| action.id.starts_with("chat:")));
     }
+
+    #[test]
+    fn test_get_chat_context_actions_returns_empty_when_model_metadata_missing() {
+        let mut info = sample_prompt_info();
+        info.available_models[0].id = "   ".to_string();
+
+        let actions = get_chat_context_actions(&info);
+
+        assert!(actions.is_empty());
+    }
+
+    #[test]
+    fn test_get_chat_context_actions_returns_empty_when_current_model_is_blank() {
+        let mut info = sample_prompt_info();
+        info.current_model = Some("   ".to_string());
+
+        let actions = get_chat_context_actions(&info);
+
+        assert!(actions.is_empty());
+    }
 }
diff --git a/src/actions/builders/clipboard.rs b/src/actions/builders/clipboard.rs
index 61c4fac2f27aae73b516b1b487482f96e2cd8c56..dc0dd0b3d0d84f9ae8b851d7cb80caf6de122d89
--- a/src/actions/builders/clipboard.rs
+++ b/src/actions/builders/clipboard.rs
@@ -22,6 +22,16 @@
 /// Get actions specific to a clipboard history entry.
 #[allow(clippy::vec_init_then_push)]
 pub fn get_clipboard_history_context_actions(entry: &ClipboardEntryInfo) -> Vec<Action> {
+    if entry.id.trim().is_empty() {
+        tracing::warn!(
+            target: "script_kit::actions",
+            content_type = ?entry.content_type,
+            pinned = entry.pinned,
+            "Invalid clipboard entry context: missing entry id; returning no actions"
+        );
+        return Vec::new();
+    }
+
     let mut actions = Vec::new();
 
     tracing::debug!(
@@ -254,4 +264,14 @@
             .iter()
             .all(|action| action.id.starts_with("clip:")));
     }
+
+    #[test]
+    fn test_get_clipboard_history_context_actions_returns_empty_when_entry_id_missing() {
+        let mut entry = entry_info(ContentType::Text, false);
+        entry.id = "   ".to_string();
+
+        let actions = get_clipboard_history_context_actions(&entry);
+
+        assert!(actions.is_empty());
+    }
 }
diff --git a/src/actions/builders/file_path.rs b/src/actions/builders/file_path.rs
index dfc224185994ff07cf51b25248e26ba16a11b56b..ac82caac18f27e7215572e0e859f856c2aa8291f
--- a/src/actions/builders/file_path.rs
+++ b/src/actions/builders/file_path.rs
@@ -2,6 +2,10 @@
 use crate::file_search::FileInfo;
 use crate::prompts::PathInfo;
 
+fn has_missing_file_context_fields(name: &str, path: &str) -> bool {
+    name.trim().is_empty() || path.trim().is_empty()
+}
+
 /// Get actions specific to a file search result
 ///
 /// Actions vary based on whether the item is a file or directory:
@@ -10,6 +14,17 @@
 ///
 /// Common actions for both: file:reveal_in_finder, file:copy_path, file:copy_filename
 pub fn get_file_context_actions(file_info: &FileInfo) -> Vec<Action> {
+    if has_missing_file_context_fields(&file_info.name, &file_info.path) {
+        tracing::warn!(
+            target: "script_kit::actions",
+            name = %file_info.name,
+            path = %file_info.path,
+            is_dir = file_info.is_dir,
+            "Invalid file context info: missing path or name; returning no actions"
+        );
+        return Vec::new();
+    }
+
     let mut actions = Vec::new();
 
     tracing::debug!(
@@ -140,6 +155,17 @@
 
 /// Get actions specific to a file/folder path
 pub fn get_path_context_actions(path_info: &PathInfo) -> Vec<Action> {
+    if has_missing_file_context_fields(&path_info.name, &path_info.path) {
+        tracing::warn!(
+            target: "script_kit::actions",
+            name = %path_info.name,
+            path = %path_info.path,
+            is_dir = path_info.is_dir,
+            "Invalid path context info: missing path or name; returning no actions"
+        );
+        return Vec::new();
+    }
+
     let mut actions = vec![
         Action::new(
             "file:copy_path",
@@ -265,4 +291,24 @@
             .iter()
             .all(|action| action.id.starts_with("file:")));
     }
+
+    #[test]
+    fn test_get_file_context_actions_returns_empty_when_required_fields_missing() {
+        let mut file_info = sample_file_info(false);
+        file_info.path = "   ".to_string();
+
+        let actions = get_file_context_actions(&file_info);
+
+        assert!(actions.is_empty());
+    }
+
+    #[test]
+    fn test_get_path_context_actions_returns_empty_when_required_fields_missing() {
+        let mut path_info = sample_path_info(true);
+        path_info.name = "   ".to_string();
+
+        let actions = get_path_context_actions(&path_info);
+
+        assert!(actions.is_empty());
+    }
 }


thinking
**Verifying local changes and test scope**
exec
/bin/zsh -lc 'git status --short src/actions/builders/chat.rs src/actions/builders/clipboard.rs src/actions/builders/file_path.rs' in /Users/johnlindquist/dev/script-kit-gpui succeeded in 51ms:
 M src/actions/builders/chat.rs
 M src/actions/builders/clipboard.rs
 M src/actions/builders/file_path.rs
file update:
diff --git a/src/actions/builders/chat.rs b/src/actions/builders/chat.rs
index 5bf8650ab171d725e5b79d58333b2ecfad8edb3a..b62991e4ebf542501b6178b3eba85c14f273305a
--- a/src/actions/builders/chat.rs
+++ b/src/actions/builders/chat.rs
@@ -18,8 +18,47 @@
     pub provider: String,
 }
 
+fn has_missing_chat_model_fields(model: &ChatModelInfo) -> bool {
+    model.id.trim().is_empty()
+        || model.display_name.trim().is_empty()
+        || model.provider.trim().is_empty()
+}
+
 /// Get actions specific to a chat prompt.
 pub fn get_chat_context_actions(info: &ChatPromptInfo) -> Vec<Action> {
+    let has_blank_current_model = info
+        .current_model
+        .as_ref()
+        .map(|model| model.trim().is_empty())
+        .unwrap_or(false);
+    if has_blank_current_model {
+        tracing::warn!(
+            target: "script_kit::actions",
+            model_count = info.available_models.len(),
+            has_messages = info.has_messages,
+            has_response = info.has_response,
+            "Invalid chat prompt info: current model name is blank; returning no actions"
+        );
+        return Vec::new();
+    }
+
+    let invalid_model_count = info
+        .available_models
+        .iter()
+        .filter(|model| has_missing_chat_model_fields(model))
+        .count();
+    if invalid_model_count > 0 {
+        tracing::warn!(
+            target: "script_kit::actions",
+            invalid_model_count,
+            model_count = info.available_models.len(),
+            has_messages = info.has_messages,
+            has_response = info.has_response,
+            "Invalid chat prompt info: model metadata missing required fields; returning no actions"
+        );
+        return Vec::new();
+    }
+
     let mut actions = Vec::new();
 
     for model in &info.available_models {
@@ -227,4 +266,24 @@
         let actions = get_ai_command_bar_actions();
         assert!(actions.iter().all(|action| action.id.starts_with("chat:")));
     }
+
+    #[test]
+    fn test_get_chat_context_actions_returns_empty_when_model_metadata_missing() {
+        let mut info = sample_prompt_info();
+        info.available_models[0].id = "   ".to_string();
+
+        let actions = get_chat_context_actions(&info);
+
+        assert!(actions.is_empty());
+    }
+
+    #[test]
+    fn test_get_chat_context_actions_returns_empty_when_current_model_is_blank() {
+        let mut info = sample_prompt_info();
+        info.current_model = Some("   ".to_string());
+
+        let actions = get_chat_context_actions(&info);
+
+        assert!(actions.is_empty());
+    }
 }
diff --git a/src/actions/builders/clipboard.rs b/src/actions/builders/clipboard.rs
index 61c4fac2f27aae73b516b1b487482f96e2cd8c56..dc0dd0b3d0d84f9ae8b851d7cb80caf6de122d89
--- a/src/actions/builders/clipboard.rs
+++ b/src/actions/builders/clipboard.rs
@@ -22,6 +22,16 @@
 /// Get actions specific to a clipboard history entry.
 #[allow(clippy::vec_init_then_push)]
 pub fn get_clipboard_history_context_actions(entry: &ClipboardEntryInfo) -> Vec<Action> {
+    if entry.id.trim().is_empty() {
+        tracing::warn!(
+            target: "script_kit::actions",
+            content_type = ?entry.content_type,
+            pinned = entry.pinned,
+            "Invalid clipboard entry context: missing entry id; returning no actions"
+        );
+        return Vec::new();
+    }
+
     let mut actions = Vec::new();
 
     tracing::debug!(
@@ -254,4 +264,14 @@
             .iter()
             .all(|action| action.id.starts_with("clip:")));
     }
+
+    #[test]
+    fn test_get_clipboard_history_context_actions_returns_empty_when_entry_id_missing() {
+        let mut entry = entry_info(ContentType::Text, false);
+        entry.id = "   ".to_string();
+
+        let actions = get_clipboard_history_context_actions(&entry);
+
+        assert!(actions.is_empty());
+    }
 }
diff --git a/src/actions/builders/file_path.rs b/src/actions/builders/file_path.rs
index dfc224185994ff07cf51b25248e26ba16a11b56b..ac82caac18f27e7215572e0e859f856c2aa8291f
--- a/src/actions/builders/file_path.rs
+++ b/src/actions/builders/file_path.rs
@@ -2,6 +2,10 @@
 use crate::file_search::FileInfo;
 use crate::prompts::PathInfo;
 
+fn has_missing_file_context_fields(name: &str, path: &str) -> bool {
+    name.trim().is_empty() || path.trim().is_empty()
+}
+
 /// Get actions specific to a file search result
 ///
 /// Actions vary based on whether the item is a file or directory:
@@ -10,6 +14,17 @@
 ///
 /// Common actions for both: file:reveal_in_finder, file:copy_path, file:copy_filename
 pub fn get_file_context_actions(file_info: &FileInfo) -> Vec<Action> {
+    if has_missing_file_context_fields(&file_info.name, &file_info.path) {
+        tracing::warn!(
+            target: "script_kit::actions",
+            name = %file_info.name,
+            path = %file_info.path,
+            is_dir = file_info.is_dir,
+            "Invalid file context info: missing path or name; returning no actions"
+        );
+        return Vec::new();
+    }
+
     let mut actions = Vec::new();
 
     tracing::debug!(
@@ -140,6 +155,17 @@
 
 /// Get actions specific to a file/folder path
 pub fn get_path_context_actions(path_info: &PathInfo) -> Vec<Action> {
+    if has_missing_file_context_fields(&path_info.name, &path_info.path) {
+        tracing::warn!(
+            target: "script_kit::actions",
+            name = %path_info.name,
+            path = %path_info.path,
+            is_dir = path_info.is_dir,
+            "Invalid path context info: missing path or name; returning no actions"
+        );
+        return Vec::new();
+    }
+
     let mut actions = vec![
         Action::new(
             "file:copy_path",
@@ -265,4 +291,24 @@
             .iter()
             .all(|action| action.id.starts_with("file:")));
     }
+
+    #[test]
+    fn test_get_file_context_actions_returns_empty_when_required_fields_missing() {
+        let mut file_info = sample_file_info(false);
+        file_info.path = "   ".to_string();
+
+        let actions = get_file_context_actions(&file_info);
+
+        assert!(actions.is_empty());
+    }
+
+    #[test]
+    fn test_get_path_context_actions_returns_empty_when_required_fields_missing() {
+        let mut path_info = sample_path_info(true);
+        path_info.name = "   ".to_string();
+
+        let actions = get_path_context_actions(&path_info);
+
+        assert!(actions.is_empty());
+    }
 }


thinking
**Deferring commits pending verification**
codex
I’ve validated the edited files contain the new warn+empty guards and no production panic/unwrap calls. Next I’ll release claims and report the exact verification blockers from the shared workspace state.
exec
/bin/zsh -lc "nl -ba src/actions/builders/chat.rs | sed -n '1,130p'" in /Users/johnlindquist/dev/script-kit-gpuiexec
/bin/zsh -lc "nl -ba src/actions/builders/clipboard.rs | sed -n '1,120p'" in /Users/johnlindquist/dev/script-kit-gpuiexec
/bin/zsh -lc "nl -ba src/actions/builders/file_path.rs | sed -n '1,240p'" in /Users/johnlindquist/dev/script-kit-gpui succeeded in 52ms:
     1	use super::types::{Action, ActionCategory};
     2	use crate::designs::icon_variations::IconName;
     3	
     4	/// Information about a chat prompt for action building
     5	#[derive(Debug, Clone)]
     6	pub struct ChatPromptInfo {
     7	    pub current_model: Option<String>,
     8	    pub available_models: Vec<ChatModelInfo>,
     9	    pub has_messages: bool,
    10	    pub has_response: bool,
    11	}
    12	
    13	/// Information about an available chat model
    14	#[derive(Debug, Clone)]
    15	pub struct ChatModelInfo {
    16	    pub id: String,
    17	    pub display_name: String,
    18	    pub provider: String,
    19	}
    20	
 succeeded in 52ms:
     1	use super::types::{Action, ActionCategory};
     2	use crate::clipboard_history::ContentType;
     3	
     4	/// Information about a clipboard history entry for action building
     5	#[derive(Debug, Clone)]
     6	pub struct ClipboardEntryInfo {
     7	    /// Entry ID in the database
     8	    pub id: String,
     9	    /// Content type (text or image)
    10	    pub content_type: ContentType,
    11	    /// Whether the entry is pinned
    12	    pub pinned: bool,
    13	    /// Preview text (for text entries)
    14	    pub preview: String,
    15	    /// Image dimensions (for image entries)
    16	    #[allow(dead_code)]
    17	    pub image_dimensions: Option<(u32, u32)>,
    18	    /// Name of the frontmost app (for "Paste to [AppName]" action title)
    19	    pub frontmost_app_name: Option<String>,
    20	}
 succeeded in 52ms:
     1	use super::types::{Action, ActionCategory};
     2	use crate::file_search::FileInfo;
     3	use crate::prompts::PathInfo;
     4	
     5	fn has_missing_file_context_fields(name: &str, path: &str) -> bool {
     6	    name.trim().is_empty() || path.trim().is_empty()
     7	}
     8	
     9	/// Get actions specific to a file search result
    10	///
    11	/// Actions vary based on whether the item is a file or directory:
    12	/// - Directory: `file:open_directory` as primary
    13	/// - File: `file:open_file` as primary, plus Quick Look (macOS)
    14	///
    15	/// Common actions for both: file:reveal_in_finder, file:copy_path, file:copy_filename
    16	pub fn get_file_context_actions(file_info: &FileInfo) -> Vec<Action> {
    17	    if has_missing_file_context_fields(&file_info.name, &file_info.path) {
    18	        tracing::warn!(
    19	            target: "script_kit::actions",
    20	            name = %file_info.name,
file update:
diff --git a/src/actions/builders/chat.rs b/src/actions/builders/chat.rs
index 5bf8650ab171d725e5b79d58333b2ecfad8edb3a..b62991e4ebf542501b6178b3eba85c14f273305a
--- a/src/actions/builders/chat.rs
+++ b/src/actions/builders/chat.rs
@@ -18,8 +18,47 @@
     pub provider: String,
 }
 
+fn has_missing_chat_model_fields(model: &ChatModelInfo) -> bool {
+    model.id.trim().is_empty()
+        || model.display_name.trim().is_empty()
+        || model.provider.trim().is_empty()
+}
+
 /// Get actions specific to a chat prompt.
 pub fn get_chat_context_actions(info: &ChatPromptInfo) -> Vec<Action> {
+    let has_blank_current_model = info
+        .current_model
+        .as_ref()
+        .map(|model| model.trim().is_empty())
+        .unwrap_or(false);
+    if has_blank_current_model {
+        tracing::warn!(
+            target: "script_kit::actions",
+            model_count = info.available_models.len(),
+            has_messages = info.has_messages,
+            has_response = info.has_response,
+            "Invalid chat prompt info: current model name is blank; returning no actions"
+        );
+        return Vec::new();
+    }
+
+    let invalid_model_count = info
+        .available_models
+        .iter()
+        .filter(|model| has_missing_chat_model_fields(model))
+        .count();
+    if invalid_model_count > 0 {
+        tracing::warn!(
+            target: "script_kit::actions",
+            invalid_model_count,
+            model_count = info.available_models.len(),
+            has_messages = info.has_messages,
+            has_response = info.has_response,
+            "Invalid chat prompt info: model metadata missing required fields; returning no actions"
+        );
+        return Vec::new();
+    }
+
     let mut actions = Vec::new();
 
     for model in &info.available_models {
@@ -227,4 +266,24 @@
         let actions = get_ai_command_bar_actions();
         assert!(actions.iter().all(|action| action.id.starts_with("chat:")));
     }
+
+    #[test]
+    fn test_get_chat_context_actions_returns_empty_when_model_metadata_missing() {
+        let mut info = sample_prompt_info();
+        info.available_models[0].id = "   ".to_string();
+
+        let actions = get_chat_context_actions(&info);
+
+        assert!(actions.is_empty());
+    }
+
+    #[test]
+    fn test_get_chat_context_actions_returns_empty_when_current_model_is_blank() {
+        let mut info = sample_prompt_info();
+        info.current_model = Some("   ".to_string());
+
+        let actions = get_chat_context_actions(&info);
+
+        assert!(actions.is_empty());
+    }
 }
diff --git a/src/actions/builders/clipboard.rs b/src/actions/builders/clipboard.rs
index 61c4fac2f27aae73b516b1b487482f96e2cd8c56..dc0dd0b3d0d84f9ae8b851d7cb80caf6de122d89
--- a/src/actions/builders/clipboard.rs
+++ b/src/actions/builders/clipboard.rs
@@ -22,6 +22,16 @@
 /// Get actions specific to a clipboard history entry.
 #[allow(clippy::vec_init_then_push)]
 pub fn get_clipboard_history_context_actions(entry: &ClipboardEntryInfo) -> Vec<Action> {
+    if entry.id.trim().is_empty() {
+        tracing::warn!(
+            target: "script_kit::actions",
+            content_type = ?entry.content_type,
+            pinned = entry.pinned,
+            "Invalid clipboard entry context: missing entry id; returning no actions"
+        );
+        return Vec::new();
+    }
+
     let mut actions = Vec::new();
 
     tracing::debug!(
@@ -254,4 +264,14 @@
             .iter()
             .all(|action| action.id.starts_with("clip:")));
     }
+
+    #[test]
+    fn test_get_clipboard_history_context_actions_returns_empty_when_entry_id_missing() {
+        let mut entry = entry_info(ContentType::Text, false);
+        entry.id = "   ".to_string();
+
+        let actions = get_clipboard_history_context_actions(&entry);
+
+        assert!(actions.is_empty());
+    }
 }
diff --git a/src/actions/builders/file_path.rs b/src/actions/builders/file_path.rs
index dfc224185994ff07cf51b25248e26ba16a11b56b..ac82caac18f27e7215572e0e859f856c2aa8291f
--- a/src/actions/builders/file_path.rs
+++ b/src/actions/builders/file_path.rs
@@ -2,6 +2,10 @@
 use crate::file_search::FileInfo;
 use crate::prompts::PathInfo;
 
+fn has_missing_file_context_fields(name: &str, path: &str) -> bool {
+    name.trim().is_empty() || path.trim().is_empty()
+}
+
 /// Get actions specific to a file search result
 ///
 /// Actions vary based on whether the item is a file or directory:
@@ -10,6 +14,17 @@
 ///
 /// Common actions for both: file:reveal_in_finder, file:copy_path, file:copy_filename
 pub fn get_file_context_actions(file_info: &FileInfo) -> Vec<Action> {
+    if has_missing_file_context_fields(&file_info.name, &file_info.path) {
+        tracing::warn!(
+            target: "script_kit::actions",
+            name = %file_info.name,
+            path = %file_info.path,
+            is_dir = file_info.is_dir,
+            "Invalid file context info: missing path or name; returning no actions"
+        );
+        return Vec::new();
+    }
+
     let mut actions = Vec::new();
 
     tracing::debug!(
@@ -140,6 +155,17 @@
 
 /// Get actions specific to a file/folder path
 pub fn get_path_context_actions(path_info: &PathInfo) -> Vec<Action> {
+    if has_missing_file_context_fields(&path_info.name, &path_info.path) {
+        tracing::warn!(
+            target: "script_kit::actions",
+            name = %path_info.name,
+            path = %path_info.path,
+            is_dir = path_info.is_dir,
+            "Invalid path context info: missing path or name; returning no actions"
+        );
+        return Vec::new();
+    }
+
     let mut actions = vec![
         Action::new(
             "file:copy_path",
@@ -265,4 +291,24 @@
             .iter()
             .all(|action| action.id.starts_with("file:")));
     }
+
+    #[test]
+    fn test_get_file_context_actions_returns_empty_when_required_fields_missing() {
+        let mut file_info = sample_file_info(false);
+        file_info.path = "   ".to_string();
+
+        let actions = get_file_context_actions(&file_info);
+
+        assert!(actions.is_empty());
+    }
+
+    #[test]
+    fn test_get_path_context_actions_returns_empty_when_required_fields_missing() {
+        let mut path_info = sample_path_info(true);
+        path_info.name = "   ".to_string();
+
+        let actions = get_path_context_actions(&path_info);
+
+        assert!(actions.is_empty());
+    }
 }


thinking
**Gathering test line ranges**
exec
/bin/zsh -lc "nl -ba src/actions/builders/chat.rs | sed -n '220,320p'" in /Users/johnlindquist/dev/script-kit-gpuiexec
/bin/zsh -lc "nl -ba src/actions/builders/file_path.rs | sed -n '240,340p'" in /Users/johnlindquist/dev/script-kit-gpuiexec
/bin/zsh -lc "nl -ba src/actions/builders/clipboard.rs | sed -n '220,320p'" in /Users/johnlindquist/dev/script-kit-gpui succeeded in 51ms:
   220	        .with_shortcut("⌘/")
   221	        .with_icon(IconName::Star)
   222	        .with_section("Help"),
   223	        Action::new(
   224	            "chat:change_model",
   225	            "Change Model",
   226	            Some("Select a different AI model".to_string()),
   227	            ActionCategory::ScriptContext,
   228	        )
   229	        .with_icon(IconName::Settings)
   230	        .with_section("Settings"),
   231	    ]
   232	}
   233	
   234	#[cfg(test)]
   235	mod tests {
   236	    use super::*;
   237	
   238	    fn sample_prompt_info() -> ChatPromptInfo {
   239	        ChatPromptInfo {
 succeeded in 50ms:
   220	        Action::new(
   221	            "clip:clipboard_delete_all",
   222	            "Delete All Entries",
   223	            Some("Clear all clipboard history (except pinned)".to_string()),
   224	            ActionCategory::ScriptContext,
   225	        )
   226	        .with_shortcut("⌃⇧X"),
   227	    );
   228	
   229	    tracing::debug!(
   230	        target: "script_kit::actions",
   231	        action_count = actions.len(),
   232	        "Created clipboard history actions"
   233	    );
   234	
   235	    actions
   236	}
   237	
   238	#[cfg(test)]
   239	mod tests {
 succeeded in 50ms:
   240	    actions
   241	}
   242	
   243	#[cfg(test)]
   244	mod namespace_tests {
   245	    use super::*;
   246	    use crate::file_search::{FileInfo, FileType};
   247	
   248	    fn sample_file_info(is_dir: bool) -> FileInfo {
   249	        FileInfo {
   250	            path: "/tmp/example".to_string(),
   251	            name: "example".to_string(),
   252	            file_type: if is_dir {
   253	                FileType::Directory
   254	            } else {
   255	                FileType::File
   256	            },
   257	            is_dir,
   258	        }
   259	    }
file update:
diff --git a/src/actions/builders/chat.rs b/src/actions/builders/chat.rs
index 5bf8650ab171d725e5b79d58333b2ecfad8edb3a..b62991e4ebf542501b6178b3eba85c14f273305a
--- a/src/actions/builders/chat.rs
+++ b/src/actions/builders/chat.rs
@@ -18,8 +18,47 @@
     pub provider: String,
 }
 
+fn has_missing_chat_model_fields(model: &ChatModelInfo) -> bool {
+    model.id.trim().is_empty()
+        || model.display_name.trim().is_empty()
+        || model.provider.trim().is_empty()
+}
+
 /// Get actions specific to a chat prompt.
 pub fn get_chat_context_actions(info: &ChatPromptInfo) -> Vec<Action> {
+    let has_blank_current_model = info
+        .current_model
+        .as_ref()
+        .map(|model| model.trim().is_empty())
+        .unwrap_or(false);
+    if has_blank_current_model {
+        tracing::warn!(
+            target: "script_kit::actions",
+            model_count = info.available_models.len(),
+            has_messages = info.has_messages,
+            has_response = info.has_response,
+            "Invalid chat prompt info: current model name is blank; returning no actions"
+        );
+        return Vec::new();
+    }
+
+    let invalid_model_count = info
+        .available_models
+        .iter()
+        .filter(|model| has_missing_chat_model_fields(model))
+        .count();
+    if invalid_model_count > 0 {
+        tracing::warn!(
+            target: "script_kit::actions",
+            invalid_model_count,
+            model_count = info.available_models.len(),
+            has_messages = info.has_messages,
+            has_response = info.has_response,
+            "Invalid chat prompt info: model metadata missing required fields; returning no actions"
+        );
+        return Vec::new();
+    }
+
     let mut actions = Vec::new();
 
     for model in &info.available_models {
@@ -227,4 +266,24 @@
         let actions = get_ai_command_bar_actions();
         assert!(actions.iter().all(|action| action.id.starts_with("chat:")));
     }
+
+    #[test]
+    fn test_get_chat_context_actions_returns_empty_when_model_metadata_missing() {
+        let mut info = sample_prompt_info();
+        info.available_models[0].id = "   ".to_string();
+
+        let actions = get_chat_context_actions(&info);
+
+        assert!(actions.is_empty());
+    }
+
+    #[test]
+    fn test_get_chat_context_actions_returns_empty_when_current_model_is_blank() {
+        let mut info = sample_prompt_info();
+        info.current_model = Some("   ".to_string());
+
+        let actions = get_chat_context_actions(&info);
+
+        assert!(actions.is_empty());
+    }
 }
diff --git a/src/actions/builders/clipboard.rs b/src/actions/builders/clipboard.rs
index 61c4fac2f27aae73b516b1b487482f96e2cd8c56..dc0dd0b3d0d84f9ae8b851d7cb80caf6de122d89
--- a/src/actions/builders/clipboard.rs
+++ b/src/actions/builders/clipboard.rs
@@ -22,6 +22,16 @@
 /// Get actions specific to a clipboard history entry.
 #[allow(clippy::vec_init_then_push)]
 pub fn get_clipboard_history_context_actions(entry: &ClipboardEntryInfo) -> Vec<Action> {
+    if entry.id.trim().is_empty() {
+        tracing::warn!(
+            target: "script_kit::actions",
+            content_type = ?entry.content_type,
+            pinned = entry.pinned,
+            "Invalid clipboard entry context: missing entry id; returning no actions"
+        );
+        return Vec::new();
+    }
+
     let mut actions = Vec::new();
 
     tracing::debug!(
@@ -254,4 +264,14 @@
             .iter()
             .all(|action| action.id.starts_with("clip:")));
     }
+
+    #[test]
+    fn test_get_clipboard_history_context_actions_returns_empty_when_entry_id_missing() {
+        let mut entry = entry_info(ContentType::Text, false);
+        entry.id = "   ".to_string();
+
+        let actions = get_clipboard_history_context_actions(&entry);
+
+        assert!(actions.is_empty());
+    }
 }
diff --git a/src/actions/builders/file_path.rs b/src/actions/builders/file_path.rs
index dfc224185994ff07cf51b25248e26ba16a11b56b..ac82caac18f27e7215572e0e859f856c2aa8291f
--- a/src/actions/builders/file_path.rs
+++ b/src/actions/builders/file_path.rs
@@ -2,6 +2,10 @@
 use crate::file_search::FileInfo;
 use crate::prompts::PathInfo;
 
+fn has_missing_file_context_fields(name: &str, path: &str) -> bool {
+    name.trim().is_empty() || path.trim().is_empty()
+}
+
 /// Get actions specific to a file search result
 ///
 /// Actions vary based on whether the item is a file or directory:
@@ -10,6 +14,17 @@
 ///
 /// Common actions for both: file:reveal_in_finder, file:copy_path, file:copy_filename
 pub fn get_file_context_actions(file_info: &FileInfo) -> Vec<Action> {
+    if has_missing_file_context_fields(&file_info.name, &file_info.path) {
+        tracing::warn!(
+            target: "script_kit::actions",
+            name = %file_info.name,
+            path = %file_info.path,
+            is_dir = file_info.is_dir,
+            "Invalid file context info: missing path or name; returning no actions"
+        );
+        return Vec::new();
+    }
+
     let mut actions = Vec::new();
 
     tracing::debug!(
@@ -140,6 +155,17 @@
 
 /// Get actions specific to a file/folder path
 pub fn get_path_context_actions(path_info: &PathInfo) -> Vec<Action> {
+    if has_missing_file_context_fields(&path_info.name, &path_info.path) {
+        tracing::warn!(
+            target: "script_kit::actions",
+            name = %path_info.name,
+            path = %path_info.path,
+            is_dir = path_info.is_dir,
+            "Invalid path context info: missing path or name; returning no actions"
+        );
+        return Vec::new();
+    }
+
     let mut actions = vec![
         Action::new(
             "file:copy_path",
@@ -265,4 +291,24 @@
             .iter()
             .all(|action| action.id.starts_with("file:")));
     }
+
+    #[test]
+    fn test_get_file_context_actions_returns_empty_when_required_fields_missing() {
+        let mut file_info = sample_file_info(false);
+        file_info.path = "   ".to_string();
+
+        let actions = get_file_context_actions(&file_info);
+
+        assert!(actions.is_empty());
+    }
+
+    #[test]
+    fn test_get_path_context_actions_returns_empty_when_required_fields_missing() {
+        let mut path_info = sample_path_info(true);
+        path_info.name = "   ".to_string();
+
+        let actions = get_path_context_actions(&path_info);
+
+        assert!(actions.is_empty());
+    }
 }


thinking
**Updating swarm status without commit**
codex
I’ve finished the scoped code changes and captured verification output; I’m now marking the swarm task done-with-blockers and releasing all three file claims.
exec
/bin/zsh -lc '~/.claude/bin/swarm.ts update --id codex-fix-builder-error-consistency --status done --notes "implemented invalid-input guards + warn logs in chat/clipboard/file_path builders and added tests; cargo check/clippy currently fail from unrelated workspace errors (clipboard ContentType expansion, duplicate test modules, unused imports in other files)"' in /Users/johnlindquist/dev/script-kit-gpui succeeded in 119ms:
Updated: codex-fix-builder-error-consistency
file update:
diff --git a/src/actions/builders/chat.rs b/src/actions/builders/chat.rs
index 5bf8650ab171d725e5b79d58333b2ecfad8edb3a..b62991e4ebf542501b6178b3eba85c14f273305a
--- a/src/actions/builders/chat.rs
+++ b/src/actions/builders/chat.rs
@@ -18,8 +18,47 @@
     pub provider: String,
 }
 
+fn has_missing_chat_model_fields(model: &ChatModelInfo) -> bool {
+    model.id.trim().is_empty()
+        || model.display_name.trim().is_empty()
+        || model.provider.trim().is_empty()
+}
+
 /// Get actions specific to a chat prompt.
 pub fn get_chat_context_actions(info: &ChatPromptInfo) -> Vec<Action> {
+    let has_blank_current_model = info
+        .current_model
+        .as_ref()
+        .map(|model| model.trim().is_empty())
+        .unwrap_or(false);
+    if has_blank_current_model {
+        tracing::warn!(
+            target: "script_kit::actions",
+            model_count = info.available_models.len(),
+            has_messages = info.has_messages,
+            has_response = info.has_response,
+            "Invalid chat prompt info: current model name is blank; returning no actions"
+        );
+        return Vec::new();
+    }
+
+    let invalid_model_count = info
+        .available_models
+        .iter()
+        .filter(|model| has_missing_chat_model_fields(model))
+        .count();
+    if invalid_model_count > 0 {
+        tracing::warn!(
+            target: "script_kit::actions",
+            invalid_model_count,
+            model_count = info.available_models.len(),
+            has_messages = info.has_messages,
+            has_response = info.has_response,
+            "Invalid chat prompt info: model metadata missing required fields; returning no actions"
+        );
+        return Vec::new();
+    }
+
     let mut actions = Vec::new();
 
     for model in &info.available_models {
@@ -227,4 +266,24 @@
         let actions = get_ai_command_bar_actions();
         assert!(actions.iter().all(|action| action.id.starts_with("chat:")));
     }
+
+    #[test]
+    fn test_get_chat_context_actions_returns_empty_when_model_metadata_missing() {
+        let mut info = sample_prompt_info();
+        info.available_models[0].id = "   ".to_string();
+
+        let actions = get_chat_context_actions(&info);
+
+        assert!(actions.is_empty());
+    }
+
+    #[test]
+    fn test_get_chat_context_actions_returns_empty_when_current_model_is_blank() {
+        let mut info = sample_prompt_info();
+        info.current_model = Some("   ".to_string());
+
+        let actions = get_chat_context_actions(&info);
+
+        assert!(actions.is_empty());
+    }
 }
diff --git a/src/actions/builders/clipboard.rs b/src/actions/builders/clipboard.rs
index 61c4fac2f27aae73b516b1b487482f96e2cd8c56..dc0dd0b3d0d84f9ae8b851d7cb80caf6de122d89
--- a/src/actions/builders/clipboard.rs
+++ b/src/actions/builders/clipboard.rs
@@ -22,6 +22,16 @@
 /// Get actions specific to a clipboard history entry.
 #[allow(clippy::vec_init_then_push)]
 pub fn get_clipboard_history_context_actions(entry: &ClipboardEntryInfo) -> Vec<Action> {
+    if entry.id.trim().is_empty() {
+        tracing::warn!(
+            target: "script_kit::actions",
+            content_type = ?entry.content_type,
+            pinned = entry.pinned,
+            "Invalid clipboard entry context: missing entry id; returning no actions"
+        );
+        return Vec::new();
+    }
+
     let mut actions = Vec::new();
 
     tracing::debug!(
@@ -254,4 +264,14 @@
             .iter()
             .all(|action| action.id.starts_with("clip:")));
     }
+
+    #[test]
+    fn test_get_clipboard_history_context_actions_returns_empty_when_entry_id_missing() {
+        let mut entry = entry_info(ContentType::Text, false);
+        entry.id = "   ".to_string();
+
+        let actions = get_clipboard_history_context_actions(&entry);
+
+        assert!(actions.is_empty());
+    }
 }
diff --git a/src/actions/builders/file_path.rs b/src/actions/builders/file_path.rs
index dfc224185994ff07cf51b25248e26ba16a11b56b..ac82caac18f27e7215572e0e859f856c2aa8291f
--- a/src/actions/builders/file_path.rs
+++ b/src/actions/builders/file_path.rs
@@ -2,6 +2,10 @@
 use crate::file_search::FileInfo;
 use crate::prompts::PathInfo;
 
+fn has_missing_file_context_fields(name: &str, path: &str) -> bool {
+    name.trim().is_empty() || path.trim().is_empty()
+}
+
 /// Get actions specific to a file search result
 ///
 /// Actions vary based on whether the item is a file or directory:
@@ -10,6 +14,17 @@
 ///
 /// Common actions for both: file:reveal_in_finder, file:copy_path, file:copy_filename
 pub fn get_file_context_actions(file_info: &FileInfo) -> Vec<Action> {
+    if has_missing_file_context_fields(&file_info.name, &file_info.path) {
+        tracing::warn!(
+            target: "script_kit::actions",
+            name = %file_info.name,
+            path = %file_info.path,
+            is_dir = file_info.is_dir,
+            "Invalid file context info: missing path or name; returning no actions"
+        );
+        return Vec::new();
+    }
+
     let mut actions = Vec::new();
 
     tracing::debug!(
@@ -140,6 +155,17 @@
 
 /// Get actions specific to a file/folder path
 pub fn get_path_context_actions(path_info: &PathInfo) -> Vec<Action> {
+    if has_missing_file_context_fields(&path_info.name, &path_info.path) {
+        tracing::warn!(
+            target: "script_kit::actions",
+            name = %path_info.name,
+            path = %path_info.path,
+            is_dir = path_info.is_dir,
+            "Invalid path context info: missing path or name; returning no actions"
+        );
+        return Vec::new();
+    }
+
     let mut actions = vec![
         Action::new(
             "file:copy_path",
@@ -265,4 +291,24 @@
             .iter()
             .all(|action| action.id.starts_with("file:")));
     }
+
+    #[test]
+    fn test_get_file_context_actions_returns_empty_when_required_fields_missing() {
+        let mut file_info = sample_file_info(false);
+        file_info.path = "   ".to_string();
+
+        let actions = get_file_context_actions(&file_info);
+
+        assert!(actions.is_empty());
+    }
+
+    #[test]
+    fn test_get_path_context_actions_returns_empty_when_required_fields_missing() {
+        let mut path_info = sample_path_info(true);
+        path_info.name = "   ".to_string();
+
+        let actions = get_path_context_actions(&path_info);
+
+        assert!(actions.is_empty());
+    }
 }


thinking
**Releasing resource claims**
exec
/bin/zsh -lc '~/.claude/bin/swarm.ts release --id codex-fix-builder-error-consistency src/actions/builders/chat.rs src/actions/builders/clipboard.rs src/actions/builders/file_path.rs' in /Users/johnlindquist/dev/script-kit-gpui succeeded in 128ms:
Released for codex-fix-builder-error-consistency: src/actions/builders/chat.rs, src/actions/builders/clipboard.rs, src/actions/builders/file_path.rs
file update:
diff --git a/src/actions/builders/chat.rs b/src/actions/builders/chat.rs
index 5bf8650ab171d725e5b79d58333b2ecfad8edb3a..b62991e4ebf542501b6178b3eba85c14f273305a
--- a/src/actions/builders/chat.rs
+++ b/src/actions/builders/chat.rs
@@ -18,8 +18,47 @@
     pub provider: String,
 }
 
+fn has_missing_chat_model_fields(model: &ChatModelInfo) -> bool {
+    model.id.trim().is_empty()
+        || model.display_name.trim().is_empty()
+        || model.provider.trim().is_empty()
+}
+
 /// Get actions specific to a chat prompt.
 pub fn get_chat_context_actions(info: &ChatPromptInfo) -> Vec<Action> {
+    let has_blank_current_model = info
+        .current_model
+        .as_ref()
+        .map(|model| model.trim().is_empty())
+        .unwrap_or(false);
+    if has_blank_current_model {
+        tracing::warn!(
+            target: "script_kit::actions",
+            model_count = info.available_models.len(),
+            has_messages = info.has_messages,
+            has_response = info.has_response,
+            "Invalid chat prompt info: current model name is blank; returning no actions"
+        );
+        return Vec::new();
+    }
+
+    let invalid_model_count = info
+        .available_models
+        .iter()
+        .filter(|model| has_missing_chat_model_fields(model))
+        .count();
+    if invalid_model_count > 0 {
+        tracing::warn!(
+            target: "script_kit::actions",
+            invalid_model_count,
+            model_count = info.available_models.len(),
+            has_messages = info.has_messages,
+            has_response = info.has_response,
+            "Invalid chat prompt info: model metadata missing required fields; returning no actions"
+        );
+        return Vec::new();
+    }
+
     let mut actions = Vec::new();
 
     for model in &info.available_models {
@@ -227,4 +266,24 @@
         let actions = get_ai_command_bar_actions();
         assert!(actions.iter().all(|action| action.id.starts_with("chat:")));
     }
+
+    #[test]
+    fn test_get_chat_context_actions_returns_empty_when_model_metadata_missing() {
+        let mut info = sample_prompt_info();
+        info.available_models[0].id = "   ".to_string();
+
+        let actions = get_chat_context_actions(&info);
+
+        assert!(actions.is_empty());
+    }
+
+    #[test]
+    fn test_get_chat_context_actions_returns_empty_when_current_model_is_blank() {
+        let mut info = sample_prompt_info();
+        info.current_model = Some("   ".to_string());
+
+        let actions = get_chat_context_actions(&info);
+
+        assert!(actions.is_empty());
+    }
 }
diff --git a/src/actions/builders/clipboard.rs b/src/actions/builders/clipboard.rs
index 61c4fac2f27aae73b516b1b487482f96e2cd8c56..dc0dd0b3d0d84f9ae8b851d7cb80caf6de122d89
--- a/src/actions/builders/clipboard.rs
+++ b/src/actions/builders/clipboard.rs
@@ -22,6 +22,16 @@
 /// Get actions specific to a clipboard history entry.
 #[allow(clippy::vec_init_then_push)]
 pub fn get_clipboard_history_context_actions(entry: &ClipboardEntryInfo) -> Vec<Action> {
+    if entry.id.trim().is_empty() {
+        tracing::warn!(
+            target: "script_kit::actions",
+            content_type = ?entry.content_type,
+            pinned = entry.pinned,
+            "Invalid clipboard entry context: missing entry id; returning no actions"
+        );
+        return Vec::new();
+    }
+
     let mut actions = Vec::new();
 
     tracing::debug!(
@@ -254,4 +264,14 @@
             .iter()
             .all(|action| action.id.starts_with("clip:")));
     }
+
+    #[test]
+    fn test_get_clipboard_history_context_actions_returns_empty_when_entry_id_missing() {
+        let mut entry = entry_info(ContentType::Text, false);
+        entry.id = "   ".to_string();
+
+        let actions = get_clipboard_history_context_actions(&entry);
+
+        assert!(actions.is_empty());
+    }
 }
diff --git a/src/actions/builders/file_path.rs b/src/actions/builders/file_path.rs
index dfc224185994ff07cf51b25248e26ba16a11b56b..ac82caac18f27e7215572e0e859f856c2aa8291f
--- a/src/actions/builders/file_path.rs
+++ b/src/actions/builders/file_path.rs
@@ -2,6 +2,10 @@
 use crate::file_search::FileInfo;
 use crate::prompts::PathInfo;
 
+fn has_missing_file_context_fields(name: &str, path: &str) -> bool {
+    name.trim().is_empty() || path.trim().is_empty()
+}
+
 /// Get actions specific to a file search result
 ///
 /// Actions vary based on whether the item is a file or directory:
@@ -10,6 +14,17 @@
 ///
 /// Common actions for both: file:reveal_in_finder, file:copy_path, file:copy_filename
 pub fn get_file_context_actions(file_info: &FileInfo) -> Vec<Action> {
+    if has_missing_file_context_fields(&file_info.name, &file_info.path) {
+        tracing::warn!(
+            target: "script_kit::actions",
+            name = %file_info.name,
+            path = %file_info.path,
+            is_dir = file_info.is_dir,
+            "Invalid file context info: missing path or name; returning no actions"
+        );
+        return Vec::new();
+    }
+
     let mut actions = Vec::new();
 
     tracing::debug!(
@@ -140,6 +155,17 @@
 
 /// Get actions specific to a file/folder path
 pub fn get_path_context_actions(path_info: &PathInfo) -> Vec<Action> {
+    if has_missing_file_context_fields(&path_info.name, &path_info.path) {
+        tracing::warn!(
+            target: "script_kit::actions",
+            name = %path_info.name,
+            path = %path_info.path,
+            is_dir = path_info.is_dir,
+            "Invalid path context info: missing path or name; returning no actions"
+        );
+        return Vec::new();
+    }
+
     let mut actions = vec![
         Action::new(
             "file:copy_path",
@@ -265,4 +291,24 @@
             .iter()
             .all(|action| action.id.starts_with("file:")));
     }
+
+    #[test]
+    fn test_get_file_context_actions_returns_empty_when_required_fields_missing() {
+        let mut file_info = sample_file_info(false);
+        file_info.path = "   ".to_string();
+
+        let actions = get_file_context_actions(&file_info);
+
+        assert!(actions.is_empty());
+    }
+
+    #[test]
+    fn test_get_path_context_actions_returns_empty_when_required_fields_missing() {
+        let mut path_info = sample_path_info(true);
+        path_info.name = "   ".to_string();
+
+        let actions = get_path_context_actions(&path_info);
+
+        assert!(actions.is_empty());
+    }
 }


thinking
**Preparing final response**
codex
Implemented the consistency fix in the claimed builder scope:

- `src/actions/builders/chat.rs:21` added input validation helpers and early-return guards in `get_chat_context_actions` with `tracing::warn!(target = "script_kit::actions", ...)` for invalid/missing model data (`blank current model` or `missing model fields`), returning `Vec::new()`.
- `src/actions/builders/clipboard.rs:24` added early-return guard for invalid clipboard context (`blank entry id`) with consistent `warn` logging and `Vec::new()`.
- `src/actions/builders/file_path.rs:5` added shared field validator and early-return guards in both `get_file_context_actions` (`src/actions/builders/file_path.rs:16`) and `get_path_context_actions` (`src/actions/builders/file_path.rs:157`) with consistent `warn` logs and `Vec::new()`.

Added behavior tests:

- `src/actions/builders/chat.rs:270` and `src/actions/builders/chat.rs:280`
- `src/actions/builders/clipboard.rs:268`
- `src/actions/builders/file_path.rs:295` and `src/actions/builders/file_path.rs:305`

How to test:

1. `cargo test -p script-kit-gpui returns_empty_when`
2. `cargo check -p script-kit-gpui`
3. `cargo clippy -p script-kit-gpui --all-targets -- -D warnings`

Verification results in current shared tree:

- `cargo check -p script-kit-gpui` fails due unrelated workspace breakages (e.g. non-exhaustive `ContentType` matches in `src/clipboard_history/clipboard.rs:53`, missing new fields in `ClipboardEntry` initializers in `src/clipboard_history/database.rs:454`).
- `cargo clippy -p script-kit-gpui --all-targets -- -D warnings` also fails due unrelated pre-existing/in-flight issues (duplicate test module files and many unused-import warnings/errors outside this scope).

Risks / known gaps:

- I could not get a green compile/lint run because the workspace is currently broken by unrelated parallel changes, so new tests could not be executed to completion in this environment.
- No production `unwrap`/panic was introduced in the edited builders; the only `expect` in these files remains in an existing macOS-only test (`src/actions/builders/file_path.rs:146`).

Commits made:

- None.
file update:
diff --git a/src/actions/builders/chat.rs b/src/actions/builders/chat.rs
index 5bf8650ab171d725e5b79d58333b2ecfad8edb3a..b62991e4ebf542501b6178b3eba85c14f273305a
--- a/src/actions/builders/chat.rs
+++ b/src/actions/builders/chat.rs
@@ -18,8 +18,47 @@
     pub provider: String,
 }
 
+fn has_missing_chat_model_fields(model: &ChatModelInfo) -> bool {
+    model.id.trim().is_empty()
+        || model.display_name.trim().is_empty()
+        || model.provider.trim().is_empty()
+}
+
 /// Get actions specific to a chat prompt.
 pub fn get_chat_context_actions(info: &ChatPromptInfo) -> Vec<Action> {
+    let has_blank_current_model = info
+        .current_model
+        .as_ref()
+        .map(|model| model.trim().is_empty())
+        .unwrap_or(false);
+    if has_blank_current_model {
+        tracing::warn!(
+            target: "script_kit::actions",
+            model_count = info.available_models.len(),
+            has_messages = info.has_messages,
+            has_response = info.has_response,
+            "Invalid chat prompt info: current model name is blank; returning no actions"
+        );
+        return Vec::new();
+    }
+
+    let invalid_model_count = info
+        .available_models
+        .iter()
+        .filter(|model| has_missing_chat_model_fields(model))
+        .count();
+    if invalid_model_count > 0 {
+        tracing::warn!(
+            target: "script_kit::actions",
+            invalid_model_count,
+            model_count = info.available_models.len(),
+            has_messages = info.has_messages,
+            has_response = info.has_response,
+            "Invalid chat prompt info: model metadata missing required fields; returning no actions"
+        );
+        return Vec::new();
+    }
+
     let mut actions = Vec::new();
 
     for model in &info.available_models {
@@ -227,4 +266,24 @@
         let actions = get_ai_command_bar_actions();
         assert!(actions.iter().all(|action| action.id.starts_with("chat:")));
     }
+
+    #[test]
+    fn test_get_chat_context_actions_returns_empty_when_model_metadata_missing() {
+        let mut info = sample_prompt_info();
+        info.available_models[0].id = "   ".to_string();
+
+        let actions = get_chat_context_actions(&info);
+
+        assert!(actions.is_empty());
+    }
+
+    #[test]
+    fn test_get_chat_context_actions_returns_empty_when_current_model_is_blank() {
+        let mut info = sample_prompt_info();
+        info.current_model = Some("   ".to_string());
+
+        let actions = get_chat_context_actions(&info);
+
+        assert!(actions.is_empty());
+    }
 }
diff --git a/src/actions/builders/clipboard.rs b/src/actions/builders/clipboard.rs
index 61c4fac2f27aae73b516b1b487482f96e2cd8c56..dc0dd0b3d0d84f9ae8b851d7cb80caf6de122d89
--- a/src/actions/builders/clipboard.rs
+++ b/src/actions/builders/clipboard.rs
@@ -22,6 +22,16 @@
 /// Get actions specific to a clipboard history entry.
 #[allow(clippy::vec_init_then_push)]
 pub fn get_clipboard_history_context_actions(entry: &ClipboardEntryInfo) -> Vec<Action> {
+    if entry.id.trim().is_empty() {
+        tracing::warn!(
+            target: "script_kit::actions",
+            content_type = ?entry.content_type,
+            pinned = entry.pinned,
+            "Invalid clipboard entry context: missing entry id; returning no actions"
+        );
+        return Vec::new();
+    }
+
     let mut actions = Vec::new();
 
     tracing::debug!(
@@ -254,4 +264,14 @@
             .iter()
             .all(|action| action.id.starts_with("clip:")));
     }
+
+    #[test]
+    fn test_get_clipboard_history_context_actions_returns_empty_when_entry_id_missing() {
+        let mut entry = entry_info(ContentType::Text, false);
+        entry.id = "   ".to_string();
+
+        let actions = get_clipboard_history_context_actions(&entry);
+
+        assert!(actions.is_empty());
+    }
 }
diff --git a/src/actions/builders/file_path.rs b/src/actions/builders/file_path.rs
index dfc224185994ff07cf51b25248e26ba16a11b56b..ac82caac18f27e7215572e0e859f856c2aa8291f
--- a/src/actions/builders/file_path.rs
+++ b/src/actions/builders/file_path.rs
@@ -2,6 +2,10 @@
 use crate::file_search::FileInfo;
 use crate::prompts::PathInfo;
 
+fn has_missing_file_context_fields(name: &str, path: &str) -> bool {
+    name.trim().is_empty() || path.trim().is_empty()
+}
+
 /// Get actions specific to a file search result
 ///
 /// Actions vary based on whether the item is a file or directory:
@@ -10,6 +14,17 @@
 ///
 /// Common actions for both: file:reveal_in_finder, file:copy_path, file:copy_filename
 pub fn get_file_context_actions(file_info: &FileInfo) -> Vec<Action> {
+    if has_missing_file_context_fields(&file_info.name, &file_info.path) {
+        tracing::warn!(
+            target: "script_kit::actions",
+            name = %file_info.name,
+            path = %file_info.path,
+            is_dir = file_info.is_dir,
+            "Invalid file context info: missing path or name; returning no actions"
+        );
+        return Vec::new();
+    }
+
     let mut actions = Vec::new();
 
     tracing::debug!(
@@ -140,6 +155,17 @@
 
 /// Get actions specific to a file/folder path
 pub fn get_path_context_actions(path_info: &PathInfo) -> Vec<Action> {
+    if has_missing_file_context_fields(&path_info.name, &path_info.path) {
+        tracing::warn!(
+            target: "script_kit::actions",
+            name = %path_info.name,
+            path = %path_info.path,
+            is_dir = path_info.is_dir,
+            "Invalid path context info: missing path or name; returning no actions"
+        );
+        return Vec::new();
+    }
+
     let mut actions = vec![
         Action::new(
             "file:copy_path",
@@ -265,4 +291,24 @@
             .iter()
             .all(|action| action.id.starts_with("file:")));
     }
+
+    #[test]
+    fn test_get_file_context_actions_returns_empty_when_required_fields_missing() {
+        let mut file_info = sample_file_info(false);
+        file_info.path = "   ".to_string();
+
+        let actions = get_file_context_actions(&file_info);
+
+        assert!(actions.is_empty());
+    }
+
+    #[test]
+    fn test_get_path_context_actions_returns_empty_when_required_fields_missing() {
+        let mut path_info = sample_path_info(true);
+        path_info.name = "   ".to_string();
+
+        let actions = get_path_context_actions(&path_info);
+
+        assert!(actions.is_empty());
+    }
 }

tokens used
122,825
Implemented the consistency fix in the claimed builder scope:

- `src/actions/builders/chat.rs:21` added input validation helpers and early-return guards in `get_chat_context_actions` with `tracing::warn!(target = "script_kit::actions", ...)` for invalid/missing model data (`blank current model` or `missing model fields`), returning `Vec::new()`.
- `src/actions/builders/clipboard.rs:24` added early-return guard for invalid clipboard context (`blank entry id`) with consistent `warn` logging and `Vec::new()`.
- `src/actions/builders/file_path.rs:5` added shared field validator and early-return guards in both `get_file_context_actions` (`src/actions/builders/file_path.rs:16`) and `get_path_context_actions` (`src/actions/builders/file_path.rs:157`) with consistent `warn` logs and `Vec::new()`.

Added behavior tests:

- `src/actions/builders/chat.rs:270` and `src/actions/builders/chat.rs:280`
- `src/actions/builders/clipboard.rs:268`
- `src/actions/builders/file_path.rs:295` and `src/actions/builders/file_path.rs:305`

How to test:

1. `cargo test -p script-kit-gpui returns_empty_when`
2. `cargo check -p script-kit-gpui`
3. `cargo clippy -p script-kit-gpui --all-targets -- -D warnings`

Verification results in current shared tree:

- `cargo check -p script-kit-gpui` fails due unrelated workspace breakages (e.g. non-exhaustive `ContentType` matches in `src/clipboard_history/clipboard.rs:53`, missing new fields in `ClipboardEntry` initializers in `src/clipboard_history/database.rs:454`).
- `cargo clippy -p script-kit-gpui --all-targets -- -D warnings` also fails due unrelated pre-existing/in-flight issues (duplicate test module files and many unused-import warnings/errors outside this scope).

Risks / known gaps:

- I could not get a green compile/lint run because the workspace is currently broken by unrelated parallel changes, so new tests could not be executed to completion in this environment.
- No production `unwrap`/panic was introduced in the edited builders; the only `expect` in these files remains in an existing macOS-only test (`src/actions/builders/file_path.rs:146`).

Commits made:

- None.


==== exit @ 2026-02-08T00:22:02.280Z code=0 status=done ====
