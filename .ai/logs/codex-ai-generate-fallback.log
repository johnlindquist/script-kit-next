==== spawn @ 2026-02-08T08:22:56.396Z ====
cmd: codex "exec" "--cd" "/Users/johnlindquist/dev/script-kit-gpui" "--model" "gpt-5.3-codex" "-c" "model_reasoning_effort=\"xhigh\"" "-c" "model_auto_compact_token_limit=120000" "-c" "developer_instructions=\"You are Codex implementer agent \\\"codex-ai-generate-fallback\\\".\\n\\n## Coordination\\nThis repo runs parallel agents in ONE working tree. Before editing any file, you MUST claim it.\\nCommands (run via shell):\\n  - View roster: ~/.claude/bin/swarm.ts status\\n  - Claim files (blocks until free): ~/.claude/bin/swarm.ts claim --wait --id codex-ai-generate-fallback path/to/file\\n  - Release: ~/.claude/bin/swarm.ts release --id codex-ai-generate-fallback path/to/file\\n  - Update status/notes: ~/.claude/bin/swarm.ts update --id codex-ai-generate-fallback --status in_progress --notes \\\"...\\\"\\nRules:\\n  - Never edit a file you haven't claimed.\\n  - Keep claims tight (claim only what you're actively changing).\\n  - If blocked, set status=blocked and say what you're waiting on.\\n  - When finished, set status=done and release claims.\\n\\n## Development practices (this code is maintained by AI agents)\\n  - Log state transitions with enough context to diagnose failures from logs alone.\\n  - Structured errors: include what was attempted, what failed, and current state.\\n  - Name things for grepability â€” unique identifiers agents can find on the first search.\\n  - Every behavior change gets a test. Untested code is invisible to the next agent.\\n  - Test names describe the scenario: test_X_does_Y_when_Z.\\n  - Keep functions small and single-purpose. 500-line functions burn agent context.\\n  - Use types to encode constraints (enums > strings for errors).\\n\\n## CRITICAL: Parallel-safe verification\\n  - Other agents are modifying other files RIGHT NOW. Full test suites WILL show their failures.\\n  - ONLY run tests that cover YOUR changed files. Scope every test/check command:\\n    Rust: cargo test -p your-crate -- module::test_name | JS: npx jest your/file.test.ts\\n  - Do NOT run: cargo test (unscoped), cargo check (whole workspace), npm test (unscoped).\\n  - If a scoped test fails, it's YOUR bug â€” fix it. If tests outside your scope fail, ignore them.\\n\\n## Git commit discipline\\n  - NEVER commit unverified work. Run tests/lints/type-checks FIRST. If it fails, fix it before committing.\\n  - A commit is a declaration: \\\"this works and here's the proof.\\\"\\n  - Commit FREQUENTLY â€” after each meaningful unit of VERIFIED work, not just at the end.\\n  - A \\\"unit\\\" = one logical change that passes verification (new function, bug fix, refactor, test added).\\n  - NEVER batch an entire task into one giant commit. Small commits are searchable; big ones aren't.\\n  - Commit message format:\\n      Line 1: <type>(<scope>): <what changed> (imperative, max 72 chars)\\n      Line 3+: WHY this change was made, WHAT was verified, and HOW to test it.\\n    Types: feat, fix, refactor, test, docs, chore\\n    Example:\\n      feat(auth): add refresh token rotation\\n      \\n      Tokens now rotate on each refresh call to prevent replay attacks.\\n      The old token is invalidated immediately on rotation.\\n      \\n      Verified: cargo test --lib -- auth::refresh (4 tests pass)\\n      Verified: manual smoke test via curl â€” token rotates, old token returns 401\\n  - The \\\"Verified:\\\" lines are REQUIRED. Future agents will read git log to understand\\n    what was tested and how to re-verify. This is the most valuable part of the message.\\n  - In your final message, list all commits you made with their hashes.\\n\\n## Time budget\\nYou have approximately 10 minutes. If your task is too broad to complete in time:\\n(1) Commit any verified progress.\\n(2) Run: ~/.claude/bin/swarm.ts update --id YOUR_ID --status needs_split --notes 'suggest: 1) sub-task-desc scope:files 2) sub-task-desc scope:files'.\\n(3) Exit cleanly. The dispatcher will read your suggestions and spawn narrower workers.\"" "--output-last-message" "/Users/johnlindquist/dev/script-kit-gpui/.ai/logs/codex-ai-generate-fallback.final.md" "--yolo" "You are agent codex-ai-generate-fallback.\n\nCurrent parallel-agent roster (read this first):\n```\nSWARM SNAPSHOT @ 2026-02-08T08:22:56.393Z\n- codex-ai-generate-fallback [starting] scope=src/fallbacks/builtins.rs,src/app_execute/builtin_execution.rs,src/app_impl/selection_fallback.rs,src/ai/script_generation.rs,src/ai/window/command_bar.rs,src/builtins/part_000.rs,src/builtins/part_001_entries/*.rs,src/main_sections/fallbacks.rs,src/actions/window/*.rs task=The built-in 'Generate Script with AI' command (BuiltInFeature) does nothing when the user hits Enter on it. It should â€¦\n```\n\nYour assignment:\n- Task: The built-in 'Generate Script with AI' command (BuiltInFeature) does nothing when the user hits Enter on it. It should behave identically to pressing Shift+Tab, which triggers AI script generation using the current input text. Look at how Shift+Tab triggers AI generation (likely in src/ai/script_generation.rs or keyboard handling) and how other fallback built-ins pass the input text to their execute logic (see src/fallbacks/builtins.rs, src/app_execute/builtin_execution.rs, src/app_impl/selection_fallback.rs). The 'Generate Script with AI' built-in must follow the same fallback pattern where the input/query text is forwarded to the built-in command's execution. Both Shift+Tab and the built-in entry point should share ALL logic - extract shared code if needed. Check src/builtins/ for where the feature is defined and src/main_sections/fallbacks.rs for fallback registration. Run cargo check && cargo clippy --all-targets -- -D warnings && cargo test after changes.\n- Scope: src/fallbacks/builtins.rs,src/app_execute/builtin_execution.rs,src/app_impl/selection_fallback.rs,src/ai/script_generation.rs,src/ai/window/command_bar.rs,src/builtins/part_000.rs,src/builtins/part_001_entries/*.rs,src/main_sections/fallbacks.rs,src/actions/window/*.rs\n\nOperating constraints:\n- Single working tree (no worktrees, no patches).\n- You MUST claim files before editing (~/.claude/bin/swarm.ts claim --wait ...).\n\nDeliverables:\n- Make the code changes required by the task.\n- Run the most relevant tests/linters.\n- In your FINAL message, include: changed files, how to test, and any risks/known gaps."

OpenAI Codex v0.98.0 (research preview)
--------
workdir: /Users/johnlindquist/dev/script-kit-gpui
model: gpt-5.3-codex
provider: openai
approval: never
sandbox: danger-full-access
reasoning effort: xhigh
reasoning summaries: auto
session id: 019c3c58-c4be-77f0-a25e-9f2d24df15bb
--------
user
You are agent codex-ai-generate-fallback.

Current parallel-agent roster (read this first):
```
SWARM SNAPSHOT @ 2026-02-08T08:22:56.393Z
- codex-ai-generate-fallback [starting] scope=src/fallbacks/builtins.rs,src/app_execute/builtin_execution.rs,src/app_impl/selection_fallback.rs,src/ai/script_generation.rs,src/ai/window/command_bar.rs,src/builtins/part_000.rs,src/builtins/part_001_entries/*.rs,src/main_sections/fallbacks.rs,src/actions/window/*.rs task=The built-in 'Generate Script with AI' command (BuiltInFeature) does nothing when the user hits Enter on it. It should â€¦
```

Your assignment:
- Task: The built-in 'Generate Script with AI' command (BuiltInFeature) does nothing when the user hits Enter on it. It should behave identically to pressing Shift+Tab, which triggers AI script generation using the current input text. Look at how Shift+Tab triggers AI generation (likely in src/ai/script_generation.rs or keyboard handling) and how other fallback built-ins pass the input text to their execute logic (see src/fallbacks/builtins.rs, src/app_execute/builtin_execution.rs, src/app_impl/selection_fallback.rs). The 'Generate Script with AI' built-in must follow the same fallback pattern where the input/query text is forwarded to the built-in command's execution. Both Shift+Tab and the built-in entry point should share ALL logic - extract shared code if needed. Check src/builtins/ for where the feature is defined and src/main_sections/fallbacks.rs for fallback registration. Run cargo check && cargo clippy --all-targets -- -D warnings && cargo test after changes.
- Scope: src/fallbacks/builtins.rs,src/app_execute/builtin_execution.rs,src/app_impl/selection_fallback.rs,src/ai/script_generation.rs,src/ai/window/command_bar.rs,src/builtins/part_000.rs,src/builtins/part_001_entries/*.rs,src/main_sections/fallbacks.rs,src/actions/window/*.rs

Operating constraints:
- Single working tree (no worktrees, no patches).
- You MUST claim files before editing (~/.claude/bin/swarm.ts claim --wait ...).

Deliverables:
- Make the code changes required by the task.
- Run the most relevant tests/linters.
- In your FINAL message, include: changed files, how to test, and any risks/known gaps.
warning: Under-development features enabled: responses_websockets. Under-development features are incomplete and may behave unpredictably. To suppress this warning, set `suppress_unstable_features_warning = true` in /Users/johnlindquist/.codex/config.toml.
mcp: deepwiki starting
mcp: deepwiki ready
mcp startup: ready: deepwiki

thinking
**Resolving instruction conflicts**
codex
Iâ€™m taking this on now: Iâ€™ll inspect how Shift+Tab currently triggers AI generation, then wire the `Generate Script with AI` built-in to the same execution path while forwarding the current input text through the fallback flow. Iâ€™ll check swarm status first, then claim only the files I need before editing.

thinking
**Checking and updating status**
exec
/bin/zsh -lc '~/.claude/bin/swarm.ts status && git status --short' in /Users/johnlindquist/dev/script-kit-gpui succeeded in 51ms:
Repo: /Users/johnlindquist/dev/script-kit-gpui
Updated: 2026-02-08T08:23:08.816Z

Active agents (1):
codex-ai-generate-fallback [in_progress] codex/gpt-5.3-codex/exec
  task: The built-in 'Generate Script with AI' command (BuiltInFeature) does nothing when the user hits Enter on it. It should â€¦
  scope: src/fallbacks/builtins.rs,src/app_execute/builtin_execution.rs,src/app_impl/selection_fallback.rs,src/ai/script_generatâ€¦
  claims: (none)
  notes: spawned codex (exec)

Inactive agents (274):
- codex-accessibility [done] done. exit=0. final=.ai/logs/codex-accessibility.final.md. See final message file.
- codex-action-labels [failed] failed. exit=1. final=.ai/logs/codex-action-labels.final.md.
- codex-actions-audit [failed] failed. exit=1. final=.ai/logs/codex-actions-audit.final.md. See final message file.
- codex-actions-consistency [failed] failed. exit=1. final=.ai/logs/codex-actions-consistency.final.md.
- codex-actions-dialog [done] done. exit=0. final=.ai/logs/codex-actions-dialog.final.md. See final message file.
- codex-actions-feedback [failed] failed. exit=1. final=.ai/logs/codex-actions-feedback.final.md.
- codex-actions-feedback-v2 [done] done. exit=0. final=.ai/logs/codex-actions-feedback-v2.final.md. See final message file.
- codex-actions-ux [done] done. exit=0. final=.ai/logs/codex-actions-ux.final.md. See final message file.
- codex-agents-md [done] done. exit=0. final=.ai/logs/codex-agents-md.final.md. See final message file.

thinking
**Clarifying handling of concurrent modifications**
codex
I confirmed this branch is heavily shared and currently dirty from other agents, so Iâ€™ll keep changes tightly scoped. Next Iâ€™m tracing the current Shift+Tab path and the built-in execution path to identify where query text is dropped.

thinking
**Planning multi-pattern search**
exec
/bin/zsh -lc "rg -n \"shift\\+tab|Shift\\+Tab|generate script|Generate Script with AI|script generation|prompt_ai|tab\" src/ai/script_generation.rs src/ai/window/command_bar.rs src/app_execute/builtin_execution.rs src/app_impl/selection_fallback.rs src/fallbacks/builtins.rs src/builtins/part_000.rs src/builtins/part_001_entries src/main_sections/fallbacks.rs src/actions/window" in /Users/johnlindquist/dev/script-kit-gpui succeeded in 51ms:
src/ai/window/command_bar.rs:323:                    // Handle printable characters for search
src/ai/window/command_bar.rs:362:                "tab" => {
src/ai/script_generation.rs:47:        anyhow::bail!("AI script generation requires a non-empty prompt");
src/ai/script_generation.rs:80:                "AI script generation failed (attempted=send_message, model_id={}, provider_id={})",
src/ai/script_generation.rs:116:        anyhow::bail!("AI script generation requires a non-empty prompt");
src/ai/script_generation.rs:121:        anyhow::bail!("AI returned an empty response for script generation (state=empty_response)");
src/builtins/part_000.rs:107:    /// Send the focused browser tab URL/content to AI Chat
src/fallbacks/builtins.rs:253:        // Generate Script with AI - top fallback when no script matches
src/fallbacks/builtins.rs:256:            name: "Generate Script with AI",
src/app_execute/builtin_execution.rs:1186:                        match platform::get_focused_browser_tab_url() {
src/builtins/part_001_entries/entries_002.rs:65:        "Generate Script with AI",
src/builtins/part_001_entries/entries_002.rs:68:            "generate", "script", "ai", "create", "code", "typescript", "shift", "tab",
src/builtins/part_001_entries/entries_002.rs:126:        "builtin-send-browser-tab-to-ai",
src/builtins/part_001_entries/entries_002.rs:128:        "Send the current browser tab URL to AI Chat",
src/builtins/part_001_entries/entries_002.rs:130:            "send", "browser", "tab", "url", "safari", "chrome", "ai", "chat", "web",
src/actions/window/part_01.rs:75:fn is_selectable_row(row: &GroupedActionItem) -> bool {
src/actions/window/part_01.rs:79:fn first_selectable_index(rows: &[GroupedActionItem]) -> Option<usize> {
src/actions/window/part_01.rs:80:    rows.iter().position(is_selectable_row)
src/actions/window/part_01.rs:83:fn last_selectable_index(rows: &[GroupedActionItem]) -> Option<usize> {
src/actions/window/part_01.rs:84:    rows.iter().rposition(is_selectable_row)

thinking
**Expanding search to relevant directories**
exec
/bin/zsh -lc 'rg -n "shift.?tab|shift_tab|ShiftTab|prompt_ai|generate_script|GenerateScriptWithAI|GenerateScript" src/app_impl src/app_execute src/fallbacks src/ai src/builtins src/main_sections' in /Users/johnlindquist/dev/script-kit-gpui succeeded in 52ms:
src/fallbacks/builtins.rs:563:    fn test_execute_generate_script_with_ai_returns_execute_builtin() {
src/fallbacks/builtins.rs:565:        let generate_script = fallbacks
src/fallbacks/builtins.rs:570:        let result = generate_script.execute("build a git helper").unwrap();
src/fallbacks/builtins.rs:713:    fn test_generate_script_with_ai_is_top_fallback_priority() {
src/builtins/part_000.rs:100:    GenerateScript,
src/app_impl/tests.rs:52:    fn test_shift_tab_routes_to_ai_script_generation_in_script_list_tab_interceptor() {
src/app_impl/tests.rs:58:                && startup_tab.contains("this.generate_script_from_ai_prompt(query, cx);"),
src/app_impl/tests.rs:59:            "Shift+Tab in ScriptList should route to generate_script_from_ai_prompt. \
src/app_execute/builtin_execution.rs:952:                let is_generate_script = matches!(cmd_type, AiCommandType::GenerateScript);
src/app_execute/builtin_execution.rs:953:                if !is_generate_script {
src/app_execute/builtin_execution.rs:1025:                    AiCommandType::GenerateScript => {
src/builtins/part_001_entries/entries_002.rs:70:        BuiltInFeature::AiCommand(AiCommandType::GenerateScript),
src/app_impl/prompt_ai.rs:126:fn generate_script_via_ai_backend(
src/app_impl/prompt_ai.rs:643:    pub fn generate_script_from_ai_prompt(
src/app_impl/prompt_ai.rs:697:                "state=queued attempted=shift_tab_script_generation model_id={} provider={} prompt_len={}",
src/app_impl/prompt_ai.rs:709:                    "state=running attempted=generate_script model_id={} provider={}",
src/app_impl/prompt_ai.rs:715:                generate_script_via_ai_backend(&registry, &model_id, &prompt_description, &config)
src/app_impl/prompt_ai.rs:746:                                    "state=completed attempted=generate_script path={}",
src/app_impl/prompt_ai.rs:762:                                &format!("state=failed attempted=generate_script error={}", error),
src/app_impl/mod.rs:41:#[path = "prompt_ai.rs"]

thinking
**Planning parallel file reading**
codex
I found explicit references to this feature in fallback tests and `builtin_execution`, plus the actual Shift+Tab implementation in `app_impl/prompt_ai.rs`. Iâ€™m now reading those paths in detail to make both entry points call the same shared function.

thinking
**Planning parallel file reads**
exec
/bin/zsh -lc "sed -n '520,780p' src/fallbacks/builtins.rs" in /Users/johnlindquist/dev/script-kit-gpuiexec
/bin/zsh -lc "sed -n '900,1105p' src/app_execute/builtin_execution.rs" in /Users/johnlindquist/dev/script-kit-gpuiexec
/bin/zsh -lc "sed -n '1,220p' src/app_impl/selection_fallback.rs" in /Users/johnlindquist/dev/script-kit-gpuiexec
/bin/zsh -lc "sed -n '600,790p' src/app_impl/prompt_ai.rs" in /Users/johnlindquist/dev/script-kit-gpuiexec
/bin/zsh -lc "sed -n '220,320p' src/fallbacks/builtins.rs" in /Users/johnlindquist/dev/script-kit-gpuiexec
/bin/zsh -lc "sed -n '1,220p' src/ai/script_generation.rs" in /Users/johnlindquist/dev/script-kit-gpui succeeded in 51ms:
            .unwrap();

        let result = copy.execute("test text").unwrap();
        match result {
            FallbackResult::Copy { text } => assert_eq!(text, "test text"),
            _ => panic!("Expected Copy result"),
        }
    }

    #[test]
    fn test_execute_search_google() {
        let fallbacks = get_builtin_fallbacks();
        let google = fallbacks.iter().find(|f| f.id == "search-google").unwrap();

        let result = google.execute("hello world").unwrap();
        match result {
            FallbackResult::OpenUrl { url } => {
                assert!(url.contains("google.com"));
                assert!(url.contains("hello%20world"));
            }
 succeeded in 51ms:
                })
                .detach();
        };

        let placeholder = Some("Describe the script you want to generate...".to_string());

        let mut chat_prompt = ChatPrompt::new(
            "script-generation".to_string(),
            placeholder,
            vec![],
            None,
            None,
            self.focus_handle.clone(),
            noop_callback,
            std::sync::Arc::clone(&self.theme),
        )
        .with_title("Generate Script with AI")
        .with_save_history(false)
        .with_escape_callback(escape_callback)
        .with_run_script_callback(run_script_callback)
 succeeded in 51ms:
                        )
                        .duration_ms(Some(3000)),
                    );
                    cx.notify();
                }
            }

            // NOTE: Window Actions removed - now handled by window-management extension
            // SDK tileWindow() still works via protocol messages in execute_script.rs

            // =========================================================================
            // Notes Commands
            // =========================================================================

            builtins::BuiltInFeature::NotesCommand(cmd_type) => {
                logging::log("EXEC", &format!("Executing notes command: {:?}", cmd_type));

                use builtins::NotesCommandType;

                // All notes commands: reset state, hide main window, open notes
 succeeded in 51ms:
use super::*;

fn resolve_grouped_result_index(
    grouped_items: &[GroupedListItem],
    selected_index: usize,
) -> Option<(usize, usize)> {
    let coerced_index = crate::list_item::coerce_selection(grouped_items, selected_index)?;
    match grouped_items.get(coerced_index) {
        Some(GroupedListItem::Item(result_idx)) => Some((coerced_index, *result_idx)),
        _ => None,
    }
}

impl ScriptListApp {
    #[allow(dead_code)]
    pub(crate) fn filtered_scripts(&self) -> Vec<Arc<scripts::Script>> {
        let filter_text = self.filter_text();
        if filter_text.is_empty() {
            self.scripts.clone()
        } else {
 succeeded in 51ms:
            FallbackAction::ExecuteBuiltin { .. } => {
                format!("Run command with '{}'", truncated)
            }
        }
    }
}

/// Result of executing a fallback action
#[derive(Debug, Clone)]
pub enum FallbackResult {
    /// Run command in terminal
    RunTerminal { command: String },
    /// Add content to notes
    AddNote { content: String },
    /// Copy text to clipboard
    Copy { text: String },
    /// Open URL in browser
    OpenUrl { url: String },
    /// Calculate expression (result will be computed by caller)
    Calculate { expression: String },
 succeeded in 51ms:
use anyhow::{Context, Result};
use std::fs::{self, OpenOptions};
use std::io::{ErrorKind, Write};
use std::path::{Path, PathBuf};
use std::sync::Arc;

use super::config::ModelInfo;
use super::providers::{AiProvider, ProviderMessage, ProviderRegistry};

const AI_SCRIPT_OUTPUT_DIR: &str = "~/.kenv/scripts";
const AI_SCRIPT_DEFAULT_SLUG: &str = "ai-script";
const AI_SCRIPT_MAX_SLUG_LEN: usize = 64;
const SCRIPT_KIT_SDK_IMPORT_MODULE: &str = "@scriptkit/sdk";
const SCRIPT_KIT_SDK_IMPORT_STATEMENT: &str = "import \"@scriptkit/sdk\";";

pub(crate) const AI_SCRIPT_GENERATION_SYSTEM_PROMPT: &str =
    r#"You write production-ready Script Kit TypeScript scripts.

Return ONLY TypeScript source code for one Script Kit script.
Do not return markdown fences or explanations.

thinking
**Inspecting fallback and builtin execution**
exec
/bin/zsh -lc "sed -n '220,520p' src/app_impl/selection_fallback.rs" in /Users/johnlindquist/dev/script-kit-gpuiexec
/bin/zsh -lc "sed -n '1,260p' src/app_impl/tests.rs" in /Users/johnlindquist/dev/script-kit-gpuiexec
/bin/zsh -lc "sed -n '1,240p' src/app_execute/builtin_execution.rs" in /Users/johnlindquist/dev/script-kit-gpui succeeded in 50ms:
#[cfg(test)]
mod app_impl_state_sync_tests {
    use super::{calculate_fallback_error_message, ScriptListApp};
    use std::fs;

    #[test]
    fn test_sync_builtin_query_state_updates_query_and_selection_when_changed() {
        let mut query = String::from("old");
        let mut selected_index = 3;

        let changed =
            ScriptListApp::sync_builtin_query_state(&mut query, &mut selected_index, "new");

        assert!(changed);
        assert_eq!(query, "new");
        assert_eq!(selected_index, 0);
    }

    #[test]
    fn test_sync_builtin_query_state_noop_when_query_is_unchanged() {
 succeeded in 50ms:
        );

        // Check if this is a "stay open" action (like run-in-terminal which opens a view)
        // Check if this is a "stay open" action (opens its own view)
        let should_close = match fallback {
            crate::fallbacks::FallbackItem::Builtin(builtin) => {
                !matches!(builtin.id, "run-in-terminal" | "search-files")
            }
            crate::fallbacks::FallbackItem::Script(_) => false,
        };

        // Execute the fallback action
        match fallback {
            crate::fallbacks::FallbackItem::Builtin(builtin) => {
                let fallback_id = builtin.id.to_string();
                self.execute_builtin_fallback_inline(&fallback_id, &input, cx);
            }
            crate::fallbacks::FallbackItem::Script(config) => {
                self.execute_interactive(&config.script, cx);
            }
 succeeded in 51ms:
fn ai_open_failure_message(error: impl std::fmt::Display) -> String {
    format!("Failed to open AI: {}", error)
}

fn favorites_loaded_message(count: usize) -> String {
    if count == 1 {
        "Loaded 1 favorite".to_string()
    } else {
        format!("Loaded {} favorites", count)
    }
}

#[cfg(target_os = "macos")]
fn applescript_escape(text: &str) -> String {
    text.replace('\\', "\\\\").replace('"', "\\\"")
}

#[cfg(target_os = "macos")]
fn applescript_list_literal(values: &[String]) -> String {
    let escaped_values = values

thinking
**Inspecting tab handling and builtins**
exec
/bin/zsh -lc "rg -n \"execute_builtin\\(|execute_builtin_with|builtin_query|query state|GenerateScript|show_script_generation_chat|generate_script_from_ai_prompt\" src/app_execute/builtin_execution.rs src/app_impl/startup_new_tab.rs src/app_impl/startup.rs src/app_impl/prompt_ai.rs src/ai/window/command_bar.rs src/main_sections/fallbacks.rs src/builtins/part_001_entries/entries_002.rs" in /Users/johnlindquist/dev/script-kit-gpui succeeded in 51ms:
src/app_impl/startup_new_tab.rs:188:                                    this.show_script_generation_chat(Some(query), cx);
src/app_impl/startup.rs:737:                                    this.show_script_generation_chat(Some(query), cx);
src/app_execute/builtin_execution.rs:124:    fn execute_builtin(&mut self, entry: &builtins::BuiltInEntry, cx: &mut Context<Self>) {
src/app_execute/builtin_execution.rs:952:                let is_generate_script = matches!(cmd_type, AiCommandType::GenerateScript);
src/app_execute/builtin_execution.rs:1025:                    AiCommandType::GenerateScript => {
src/app_execute/builtin_execution.rs:1027:                        self.show_script_generation_chat(Some(query), cx);
src/app_impl/prompt_ai.rs:471:    pub fn show_script_generation_chat(
src/app_impl/prompt_ai.rs:643:    pub fn generate_script_from_ai_prompt(
src/main_sections/fallbacks.rs:163:                    app.execute_builtin(&entry, cx);
src/builtins/part_001_entries/entries_002.rs:70:        BuiltInFeature::AiCommand(AiCommandType::GenerateScript),

thinking
**Verifying script generation trigger**
codex
I found two Tab interceptors (`startup_new_tab.rs` and `startup.rs`) that currently route Shift+Tab to `show_script_generation_chat`, while thereâ€™s also a direct `generate_script_from_ai_prompt` path. Iâ€™ll inspect those handlers and align both built-in and Shift+Tab to a single shared generation function.
exec
/bin/zsh -lc "sed -n '130,250p' src/app_impl/startup_new_tab.rs" in /Users/johnlindquist/dev/script-kit-gpuiexec
/bin/zsh -lc "sed -n '120,220p' src/main_sections/fallbacks.rs" in /Users/johnlindquist/dev/script-kit-gpuiexec
/bin/zsh -lc "sed -n '680,780p' src/app_impl/startup.rs" in /Users/johnlindquist/dev/script-kit-gpuiexec
/bin/zsh -lc "sed -n '1,220p' src/builtins/part_001_entries/entries_002.rs" in /Users/johnlindquist/dev/script-kit-gpuiexec
/bin/zsh -lc "sed -n '1,200p' src/builtins/part_000.rs" in /Users/johnlindquist/dev/script-kit-gpui succeeded in 51ms:
                                            cx.notify();
                                        } else {
                                            // File: Autocomplete the full path (terminal-style tab completion)
                                            let shortened =
                                                crate::file_search::shorten_path(&file.path);
                                            crate::logging::log(
                                                "KEY",
                                                &format!(
                                                    "Tab: Autocompleting file path: {}",
                                                    shortened
                                                ),
                                            );

                                            // Set the input to the file's full path
                                            this.gpui_input_state.update(cx, |state, cx| {
                                                state.set_value(shortened.clone(), window, cx);
                                                // Ensure cursor is at end with no selection after programmatic set_value
                                                let len = shortened.len();
                                                state.set_selection(len, len, window, cx);
                                            });
 succeeded in 51ms:
                    }
                }

                FallbackResult::OpenFile { path } => {
                    logging::log("FALLBACK", &format!("OpenFile: {}", path));
                    // Expand ~ to home directory
                    let expanded = shellexpand::tilde(&path).to_string();
                    // Open with default application
                    if let Err(e) = open::that(&expanded) {
                        logging::log("FALLBACK", &format!("Failed to open file: {}", e));
                    } else {
                        logging::log("FALLBACK", "File opened with default application");
                    }
                }

                FallbackResult::SearchFiles { query } => {
                    logging::log("FALLBACK", &format!("SearchFiles: {}", query));
                    app.open_file_search(query, cx);
                }

 succeeded in 51ms:
                                        } else {
                                            // File: Autocomplete the full path (terminal-style tab completion)
                                            let shortened =
                                                crate::file_search::shorten_path(&file.path);
                                            crate::logging::log(
                                                "KEY",
                                                &format!(
                                                    "Tab: Autocompleting file path: {}",
                                                    shortened
                                                ),
                                            );

                                            // Set the input to the file's full path
                                            this.gpui_input_state.update(cx, |state, cx| {
                                                state.set_value(shortened.clone(), window, cx);
                                                // Ensure cursor is at end with no selection after programmatic set_value
                                                let len = shortened.len();
                                                state.set_selection(len, len, window, cx);
                                            });

 succeeded in 51ms:
use crate::config::BuiltInConfig;
use crate::menu_bar::MenuBarItem;
use tracing::debug;
// ============================================================================
// Command Type Enums
// ============================================================================

/// System action types for macOS system commands
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum SystemActionType {
    // Power management
    EmptyTrash,
    LockScreen,
    Sleep,
    Restart,
    ShutDown,
    LogOut,

    // UI controls
    ToggleDarkMode,
 succeeded in 51ms:
{
    // Notes Commands
    // =========================================================================

    entries.push(BuiltInEntry::new_with_icon(
        "builtin-open-notes",
        "Open Notes",
        "Open the Notes window",
        vec!["open", "notes", "window", "note"],
        BuiltInFeature::NotesCommand(NotesCommandType::OpenNotes),
        "ðŸ“",
    ));

    entries.push(BuiltInEntry::new_with_icon(
        "builtin-new-note",
        "New Note",
        "Create a new note",
        vec!["new", "note", "create"],
        BuiltInFeature::NotesCommand(NotesCommandType::NewNote),
        "ðŸ“",

thinking
**Inspecting fallback builtin execution**
exec
/bin/zsh -lc "sed -n '1,260p' src/fallbacks/builtins.rs" in /Users/johnlindquist/dev/script-kit-gpui succeeded in 51ms:
//! Built-in fallback command definitions
//!
//! This module defines the default fallback commands that appear when no scripts
//! match the user's input. Fallbacks are Raycast-style actions like "Search Google",
//! "Open URL", "Calculate", etc.
//!
//! NOTE: Some items are currently unused as this is a new module being integrated.
#![allow(dead_code)]

use crate::scripts::input_detection::{is_file_path, is_math_expression, is_url, InputType};

/// Simple percent-encoding for URL query strings
/// Encodes characters that are not unreserved per RFC 3986
fn percent_encode(input: &str) -> String {
    let mut encoded = String::with_capacity(input.len() * 3);
    for byte in input.bytes() {
        match byte {
            // Unreserved characters: A-Z a-z 0-9 - . _ ~
            b'A'..=b'Z' | b'a'..=b'z' | b'0'..=b'9' | b'-' | b'.' | b'_' | b'~' => {
                encoded.push(byte as char);

thinking
**Planning query forwarding for builtins**
exec
/bin/zsh -lc 'rg -n "sync_builtin_query_state|clear_builtin_query_state|builtin_query|query_override|pending query|execute_builtin_with" src/app_execute/builtin_execution.rs src/main_sections/fallbacks.rs src/app_impl/selection_fallback.rs src/app_impl/mod.rs src/app_impl/*.rs' in /Users/johnlindquist/dev/script-kit-gpui succeeded in 52ms:
src/app_impl/filter_input_core.rs:16:    pub(crate) fn sync_builtin_query_state(
src/app_impl/filter_input_core.rs:30:    pub(crate) fn clear_builtin_query_state(query: &mut String, selected_index: &mut usize) {
src/app_impl/lifecycle_reset.rs:206:                Self::clear_builtin_query_state(filter, selected_index);
src/app_impl/lifecycle_reset.rs:217:                Self::clear_builtin_query_state(filter, selected_index);
src/app_impl/lifecycle_reset.rs:225:                Self::clear_builtin_query_state(filter, selected_index);
src/app_impl/lifecycle_reset.rs:233:                Self::clear_builtin_query_state(filter, selected_index);
src/app_impl/lifecycle_reset.rs:241:                Self::clear_builtin_query_state(filter, selected_index);
src/app_impl/lifecycle_reset.rs:249:                Self::clear_builtin_query_state(query, selected_index);
src/app_impl/filter_input_change.rs:31:                if Self::sync_builtin_query_state(filter, selected_index, &new_text) {
src/app_impl/filter_input_change.rs:55:                if Self::sync_builtin_query_state(filter, selected_index, &new_text) {
src/app_impl/filter_input_change.rs:66:                if Self::sync_builtin_query_state(filter, selected_index, &new_text) {
src/app_impl/filter_input_change.rs:77:                if Self::sync_builtin_query_state(filter, selected_index, &new_text) {
src/app_impl/filter_input_change.rs:88:                if Self::sync_builtin_query_state(filter, selected_index, &new_text) {
src/app_impl/tests.rs:7:    fn test_sync_builtin_query_state_updates_query_and_selection_when_changed() {
src/app_impl/tests.rs:12:            ScriptListApp::sync_builtin_query_state(&mut query, &mut selected_index, "new");
src/app_impl/tests.rs:20:    fn test_sync_builtin_query_state_noop_when_query_is_unchanged() {
src/app_impl/tests.rs:25:            ScriptListApp::sync_builtin_query_state(&mut query, &mut selected_index, "same");
src/app_impl/tests.rs:33:    fn test_clear_builtin_query_state_clears_text_and_resets_selection() {
src/app_impl/tests.rs:37:        ScriptListApp::clear_builtin_query_state(&mut query, &mut selected_index);

thinking
**Inspecting core filter input**
codex
I confirmed the fallback currently resolves to `ExecuteBuiltin` without carrying input, and `execute_builtin` then reads `self.filter_text`, which can be empty at that point. Iâ€™m checking existing builtin query-state helpers so we forward text using the same app pattern instead of inventing a new path.
exec
/bin/zsh -lc "sed -n '1,160p' src/app_impl/filter_input_core.rs" in /Users/johnlindquist/dev/script-kit-gpuiexec
/bin/zsh -lc "sed -n '1,220p' src/app_impl/filter_input_change.rs" in /Users/johnlindquist/dev/script-kit-gpuiexec
/bin/zsh -lc "sed -n '150,290p' src/app_impl/lifecycle_reset.rs" in /Users/johnlindquist/dev/script-kit-gpuiexec
/bin/zsh -lc "rg -n \"struct ScriptListApp|builtin_query|search_files_query|terminal_command|notes_content|chat_message\" src/app.rs src/app_impl -g '*.rs'" in /Users/johnlindquist/dev/script-kit-gpui succeeded in 51ms:
        // cx.hide() hides the ENTIRE app (all windows), so we use
        // platform::hide_main_window() to hide only the main window
        if notes_open || ai_open {
            logging::log(
                "VISIBILITY",
                "Using hide_main_window() - secondary windows are open",
            );
            platform::hide_main_window();
        } else {
            logging::log("VISIBILITY", "Using cx.hide() - no secondary windows");
            cx.hide();
        }
        logging::log("VISIBILITY", "=== Window closed ===");
    }

    /// Clear the current built-in view's filter/query text if non-empty.
    ///
    /// Returns `true` if the filter was cleared (caller should stop processing ESC).
    /// Returns `false` if the filter was already empty (caller should proceed with go_back_or_close).
    ///
 succeeded in 51ms:
use super::*;

impl ScriptListApp {
    pub(crate) fn current_view_uses_shared_filter_input(&self) -> bool {
        matches!(
            self.current_view,
            AppView::ClipboardHistoryView { .. }
                | AppView::AppLauncherView { .. }
                | AppView::WindowSwitcherView { .. }
                | AppView::DesignGalleryView { .. }
                | AppView::ThemeChooserView { .. }
                | AppView::FileSearchView { .. }
        )
    }

    pub(crate) fn sync_builtin_query_state(
        query: &mut String,
        selected_index: &mut usize,
        new_text: &str,
    ) -> bool {
 succeeded in 51ms:
use super::*;

impl ScriptListApp {
    pub(crate) fn handle_filter_input_change(&mut self, window: &mut Window, cx: &mut Context<Self>) {
        let handler_start = std::time::Instant::now();

        if self.suppress_filter_events {
            return;
        }

        // Skip filter updates when actions popup is open
        // (text input should go to actions dialog search, not main filter)
        if self.show_actions_popup {
            return;
        }

        let new_text = self.gpui_input_state.read(cx).value().to_string();

        if self.current_view_uses_shared_filter_input() {
            // Keep shared input state synchronized with view-scoped query/filter fields.
 exited 2 in 51ms:
rg: src/app.rs: No such file or directory (os error 2)
src/app_impl/filter_input_change.rs:31:                if Self::sync_builtin_query_state(filter, selected_index, &new_text) {
src/app_impl/filter_input_change.rs:55:                if Self::sync_builtin_query_state(filter, selected_index, &new_text) {
src/app_impl/filter_input_change.rs:66:                if Self::sync_builtin_query_state(filter, selected_index, &new_text) {
src/app_impl/filter_input_change.rs:77:                if Self::sync_builtin_query_state(filter, selected_index, &new_text) {
src/app_impl/filter_input_change.rs:88:                if Self::sync_builtin_query_state(filter, selected_index, &new_text) {
src/app_impl/tests.rs:7:    fn test_sync_builtin_query_state_updates_query_and_selection_when_changed() {
src/app_impl/tests.rs:12:            ScriptListApp::sync_builtin_query_state(&mut query, &mut selected_index, "new");
src/app_impl/tests.rs:20:    fn test_sync_builtin_query_state_noop_when_query_is_unchanged() {
src/app_impl/tests.rs:25:            ScriptListApp::sync_builtin_query_state(&mut query, &mut selected_index, "same");
src/app_impl/tests.rs:33:    fn test_clear_builtin_query_state_clears_text_and_resets_selection() {
src/app_impl/tests.rs:37:        ScriptListApp::clear_builtin_query_state(&mut query, &mut selected_index);
src/app_impl/actions_toggle.rs:289:    pub fn toggle_terminal_commands(&mut self, cx: &mut Context<Self>, window: &mut Window) {
src/app_impl/actions_toggle.rs:294:        use crate::terminal::get_terminal_commands;
src/app_impl/actions_toggle.rs:299:                "toggle_terminal_commands called: show_actions_popup={}, actions_dialog.is_some={}",
src/app_impl/actions_toggle.rs:313:            let terminal_commands = get_terminal_commands();
src/app_impl/actions_toggle.rs:316:            let actions: Vec<Action> = terminal_commands
src/app_impl/lifecycle_reset.rs:206:                Self::clear_builtin_query_state(filter, selected_index);
src/app_impl/lifecycle_reset.rs:217:                Self::clear_builtin_query_state(filter, selected_index);
src/app_impl/lifecycle_reset.rs:225:                Self::clear_builtin_query_state(filter, selected_index);

thinking
**Planning builtin execution inspection**
exec
/bin/zsh -lc "rg -n \"\\.execute_builtin\\(|execute_builtin\\(&\" src | head -n 200" in /Users/johnlindquist/dev/script-kit-gpui succeeded in 51ms:
src/app_impl/filter_input_change.rs:438:                            self.execute_builtin(&entry, cx);
src/main_sections/fallbacks.rs:163:                    app.execute_builtin(&entry, cx);
src/app_impl/selection_fallback.rs:180:                        self.execute_builtin(&builtin_match.entry, cx);
src/app_impl/selection_fallback.rs:402:                    self.execute_builtin(&entry, cx);
src/app_impl/execution_scripts.rs:378:                        self.execute_builtin(entry, cx);
src/app_execute/builtin_execution.rs:124:    fn execute_builtin(&mut self, entry: &builtins::BuiltInEntry, cx: &mut Context<Self>) {

thinking
**Analyzing method visibility across modules**
exec
/bin/zsh -lc "sed -n '1,220p' src/app_execute/mod.rs" in /Users/johnlindquist/dev/script-kit-gpuiexec
/bin/zsh -lc "sed -n '1,260p' src/app_impl/mod.rs" in /Users/johnlindquist/dev/script-kit-gpui exited 1 in 51ms:
sed: src/app_execute/mod.rs: No such file or directory
 succeeded in 50ms:
#[path = "startup.rs"]
mod startup;
#[path = "theme_focus.rs"]
mod theme_focus;
#[path = "refresh_scriptlets.rs"]
mod refresh_scriptlets;
#[path = "filtering_cache.rs"]
mod filtering_cache;
#[path = "selection_fallback.rs"]
mod selection_fallback;
#[path = "filter_input_core.rs"]
mod filter_input_core;
#[path = "filter_input_change.rs"]
mod filter_input_change;
#[path = "filter_input_updates.rs"]
mod filter_input_updates;
#[path = "ui_window.rs"]
mod ui_window;
#[path = "actions_toggle.rs"]
mod actions_toggle;

thinking
**Inspecting source directory for module**
exec
/bin/zsh -lc "ls src | rg '"'^app_execute|app_impl|main_sections|fallbacks|ai|builtins$'"' -n" in /Users/johnlindquist/dev/script-kit-gpui succeeded in 50ms:
7:ai
11:app_execute
12:app_execute.rs
13:app_impl
24:builtins
43:fallbacks
69:main.rs
70:main_entry
71:main_sections
97:render_builtins

thinking
**Preparing to read source file**
exec
/bin/zsh -lc "sed -n '1,260p' src/app_execute.rs" in /Users/johnlindquist/dev/script-kit-gpui succeeded in 51ms:
// App execution methods split into sub-files for maintainability
include!("app_execute/builtin_execution.rs");
include!("app_execute/execution_helpers.rs");
include!("app_execute/utility_views.rs");
include!("app_execute/builtin_confirmation.rs");

thinking
**Inspecting fallback module for execution**
exec
/bin/zsh -lc "sed -n '1,260p' src/main_sections/fallbacks.rs" in /Users/johnlindquist/dev/script-kit-gpui succeeded in 52ms:
/// Execute a fallback action based on the fallback ID and input text.
///
/// This handles the various fallback action types:
/// - run-in-terminal: Open terminal with command
/// - add-to-notes: Open Notes window with quick capture
/// - copy-to-clipboard: Copy text to clipboard
/// - search-google/search-duckduckgo: Open browser with search URL
/// - open-url: Open the input as a URL
/// - calculate: Evaluate math expression (basic)
/// - open-file: Open file/folder with default app
fn execute_fallback_action(
    app: &mut ScriptListApp,
    fallback_id: &str,
    input: &str,
    _window: &mut Window,
    cx: &mut Context<ScriptListApp>,
) {
    use fallbacks::builtins::{get_builtin_fallbacks, FallbackResult};

    logging::log(

thinking
**Reviewing duplicate code and tab handling**
exec
/bin/zsh -lc "sed -n '300,430p' src/ai/window/command_bar.rs" in /Users/johnlindquist/dev/script-kit-gpui succeeded in 51ms:
        if self.command_bar.is_open() {
            match key_lower.as_str() {
                "up" | "arrowup" => {
                    crate::logging::log("AI", "SimulateKey: Up in command bar");
                    self.command_bar_select_prev(cx);
                }
                "down" | "arrowdown" => {
                    crate::logging::log("AI", "SimulateKey: Down in command bar");
                    self.command_bar_select_next(cx);
                }
                "enter" | "return" => {
                    crate::logging::log("AI", "SimulateKey: Enter in command bar");
                    self.execute_command_bar_action(window, cx);
                }
                "escape" | "esc" => {
                    crate::logging::log("AI", "SimulateKey: Escape - closing command bar");
                    self.hide_command_bar(cx);
                }
                "backspace" | "delete" => {
                    crate::logging::log("AI", "SimulateKey: Backspace in command bar");

thinking
**Inspecting script generation flows**
exec
/bin/zsh -lc "sed -n '430,760p' src/app_impl/prompt_ai.rs" in /Users/johnlindquist/dev/script-kit-gpui succeeded in 51ms:
        // Create a no-op callback since built-in AI handles submissions internally
        let noop_callback: ChatSubmitCallback = std::sync::Arc::new(|_id, _text| {
            // Built-in AI mode handles this internally
        });

        let placeholder = Some("Ask anything...".to_string());

        let mut chat_prompt = ChatPrompt::new(
            "inline-ai".to_string(),
            placeholder,
            vec![],
            None,
            None,
            self.focus_handle.clone(),
            noop_callback,
            std::sync::Arc::clone(&self.theme),
        )
        .with_title("Ask AI")
        .with_save_history(true)
        .with_escape_callback(escape_callback)

thinking
**Analyzing AI script generation flow**
exec
/bin/zsh -lc "rg -n \"execute_fallback_action\\(|execute_builtin_fallback_inline\\(|fallback_id\" src/main.rs src/main_sections src/app_impl src/app_execute -g '*.rs'" in /Users/johnlindquist/dev/script-kit-gpui succeeded in 51ms:
src/main_sections/fallbacks.rs:11:fn execute_fallback_action(
src/main_sections/fallbacks.rs:13:    fallback_id: &str,
src/main_sections/fallbacks.rs:22:        &format!("Executing fallback '{}' with input: {}", fallback_id, input),
src/main_sections/fallbacks.rs:27:    let fallback = fallbacks.iter().find(|f| f.id == fallback_id);
src/main_sections/fallbacks.rs:30:        logging::log("FALLBACK", &format!("Unknown fallback ID: {}", fallback_id));
src/app_impl/selection_fallback.rs:234:                let fallback_id = builtin.id.to_string();
src/app_impl/selection_fallback.rs:235:                self.execute_builtin_fallback_inline(&fallback_id, &input, cx);
src/app_impl/selection_fallback.rs:274:                    let fallback_id = builtin.id.to_string();
src/app_impl/selection_fallback.rs:275:                    self.execute_builtin_fallback_inline(&fallback_id, &input, cx);
src/app_impl/selection_fallback.rs:290:    pub(crate) fn execute_builtin_fallback_inline(
src/app_impl/selection_fallback.rs:292:        fallback_id: &str,
src/app_impl/selection_fallback.rs:300:            &format!("Executing fallback '{}' with input: {}", fallback_id, input),
src/app_impl/selection_fallback.rs:305:        let fallback = fallbacks.iter().find(|f| f.id == fallback_id);
src/app_impl/selection_fallback.rs:308:            logging::log("FALLBACK", &format!("Unknown fallback ID: {}", fallback_id));

thinking
**Investigating fallback code usage**
exec
/bin/zsh -lc "sed -n '260,640p' src/main_sections/fallbacks.rs" in /Users/johnlindquist/dev/script-kit-gpui succeeded in 52ms:


thinking
**Assessing unused function inclusion**
exec
/bin/zsh -lc "rg -n \"execute_fallback_action\" src/main.rs src/main_sections/*.rs src/main_sections -g '*.rs'" in /Users/johnlindquist/dev/script-kit-gpui succeeded in 51ms:
src/main_sections/fallbacks.rs:11:fn execute_fallback_action(
src/main_sections/fallbacks.rs:11:fn execute_fallback_action(

thinking
**Investigating fallback result usage**
codex
I verified the active fallback execution path is `selection_fallback.rs`; `main_sections/fallbacks.rs` appears to be legacy/unused but duplicates logic, so Iâ€™ll keep both paths consistent to avoid drift. Next Iâ€™m locating a clean shared helper in `app_execute` for built-ins with query text.
exec
/bin/zsh -lc "rg -n \"FallbackResult::ExecuteBuiltin|builtin-generate-script-with-ai|AiCommandType::GenerateScript|show_script_generation_chat\\(|generate_script_from_ai_prompt\\(\" src -g '*.rs'" in /Users/johnlindquist/dev/script-kit-gpui succeeded in 51ms:
src/builtins/part_001_entries/entries_002.rs:64:        "builtin-generate-script-with-ai",
src/builtins/part_001_entries/entries_002.rs:70:        BuiltInFeature::AiCommand(AiCommandType::GenerateScript),
src/builtins/tests/part_000.rs:333:            .find(|e| e.id == "builtin-generate-script-with-ai");
src/builtins/tests/part_000.rs:336:            "builtin-generate-script-with-ai should exist"
src/builtins/tests/part_000.rs:341:            BuiltInFeature::AiCommand(AiCommandType::GenerateScript)
src/app_impl/selection_fallback.rs:375:                FallbackResult::ExecuteBuiltin { builtin_id } => {
src/app_impl/tests.rs:58:                && startup_tab.contains("this.generate_script_from_ai_prompt(query, cx);"),
src/app_impl/prompt_ai.rs:471:    pub fn show_script_generation_chat(
src/app_impl/prompt_ai.rs:643:    pub fn generate_script_from_ai_prompt(
src/app_impl/startup.rs:737:                                    this.show_script_generation_chat(Some(query), cx);
src/app_impl/startup_new_tab.rs:188:                                    this.show_script_generation_chat(Some(query), cx);
src/main_sections/fallbacks.rs:140:                FallbackResult::ExecuteBuiltin { builtin_id } => {
src/app_execute/builtin_execution.rs:952:                let is_generate_script = matches!(cmd_type, AiCommandType::GenerateScript);
src/app_execute/builtin_execution.rs:1025:                    AiCommandType::GenerateScript => {
src/app_execute/builtin_execution.rs:1027:                        self.show_script_generation_chat(Some(query), cx);
src/fallbacks/builtins.rs:195:            FallbackAction::ExecuteBuiltin { builtin_id } => Ok(FallbackResult::ExecuteBuiltin {
src/fallbacks/builtins.rs:255:            id: "builtin-generate-script-with-ai",
src/fallbacks/builtins.rs:260:                builtin_id: "builtin-generate-script-with-ai".to_string(),
src/fallbacks/builtins.rs:446:        assert!(ids.contains(&"builtin-generate-script-with-ai"));
src/fallbacks/builtins.rs:567:            .find(|f| f.id == "builtin-generate-script-with-ai")

thinking
**Analyzing fallback query forwarding and close behavior**
exec
/bin/zsh -lc "sed -n '1,120p' src/app_impl/startup.rs" in /Users/johnlindquist/dev/script-kit-gpui succeeded in 51ms:
use super::*;

pub(super) fn calculate_fallback_error_message(expression: &str) -> String {
    format!(
        "Could not evaluate expression \"{}\". Check the syntax and try again.",
        expression
    )
}

impl ScriptListApp {
    pub(crate) fn new(
        config: config::Config,
        bun_available: bool,
        window: &mut Window,
        cx: &mut Context<Self>,
    ) -> Self {
        // PERF: Parallelize script + scriptlet loading to reduce startup wall time.
        let load_start = std::time::Instant::now();
        let (scripts, scriptlets, scripts_elapsed, scriptlets_elapsed) = std::thread::scope(
            |scope| {

thinking
**Assessing startup file references**
exec
/bin/zsh -lc 'rg -n "startup_new_tab|include!'"\\(\" src/app_impl/startup.rs src/app_impl/startup_new_tab.rs" in /Users/johnlindquist/dev/script-kit-gpui exited 1 in 51ms:


thinking
**Investigating module inclusion for new tab**
exec
/bin/zsh -lc 'rg -n "new_tab|tab_interceptor|intercept_keystrokes" src/app_impl/startup.rs' in /Users/johnlindquist/dev/script-kit-gpui succeeded in 51ms:
554:        let tab_interceptor = cx.intercept_keystrokes({
751:        app.gpui_input_subscriptions.push(tab_interceptor);
756:        let arrow_interceptor = cx.intercept_keystrokes({
1066:        let home_end_interceptor = cx.intercept_keystrokes({
1123:        let actions_interceptor = cx.intercept_keystrokes({
1127:                // intercept_keystrokes is GLOBAL and fires for ALL windows in the app

thinking
**Assessing test dependencies on startup snippets**
exec
/bin/zsh -lc "sed -n '1,260p' src/app_impl/startup_new_tab.rs" in /Users/johnlindquist/dev/script-kit-gpui succeeded in 50ms:
        // Add Tab key interceptor for "Ask AI" feature and file search directory navigation
        // This fires BEFORE normal key handling, allowing us to intercept Tab
        // even when the Input component has focus
        let app_entity_for_tab = cx.entity().downgrade();
        let tab_interceptor = cx.intercept_keystrokes({
            let app_entity = app_entity_for_tab;
            move |event, window, cx| {
                let key = event.keystroke.key.to_lowercase();
                let is_tab_key = matches!(event.keystroke.key.as_str(), "tab" | "Tab")
                    || matches!(key.as_str(), "tab");
                let has_shift = event.keystroke.modifiers.shift;
                // Check for Tab key (no cmd/alt/ctrl modifiers, but shift is allowed)
                if is_tab_key
                    && !event.keystroke.modifiers.platform
                    && !event.keystroke.modifiers.alt
                    && !event.keystroke.modifiers.control
                {
                    if let Some(app) = app_entity.upgrade() {
                        app.update(cx, |this, cx| {
                            // FIRST: If confirm dialog is open, route Tab to it for button switching

thinking
**Analyzing fallback builtin execution and UI behavior**
exec
/bin/zsh -lc "sed -n '1,220p' src/main_sections/mod.rs" in /Users/johnlindquist/dev/script-kit-gpui exited 1 in 52ms:
sed: src/main_sections/mod.rs: No such file or directory

thinking
**Examining main_sections directory**
exec
/bin/zsh -lc 'ls src/main_sections' in /Users/johnlindquist/dev/script-kit-gpui succeeded in 51ms:
app_state.rs
app_view_state.rs
deeplink.rs
fallbacks.rs
fonts.rs
prompt_messages.rs
render_impl.rs
window_visibility.rs

thinking
**Inspecting main.rs includes**
exec
/bin/zsh -lc "sed -n '1,180p' src/main.rs" in /Users/johnlindquist/dev/script-kit-gpui succeeded in 50ms:
#![allow(unexpected_cfgs)]

//! Binary entrypoint and GPUI application composition for Script Kit GPUI.
//! It defines the `ScriptListApp` runtime, wires stdin protocol handling in `main`,
//! and includes prompt/builtin render implementations for the primary window.
//! This module depends on app subsystems like `protocol`, `hotkeys`, `watcher`, and `window_manager`.

use gpui::{
    div, hsla, list, point, prelude::*, px, rgb, rgba, size, svg, uniform_list, AnyElement, App,
    Application, BoxShadow, Context, CursorStyle, ElementId, Entity, FocusHandle, Focusable,
    FontWeight, KeyDownEvent, ListAlignment, ListOffset, ListSizingBehavior, ListState,
    MouseMoveEvent, Render, ScrollStrategy, SharedString, Subscription, Timer,
    UniformListScrollHandle, Window, WindowBackgroundAppearance, WindowBounds, WindowHandle,
    WindowKind, WindowOptions,
};

// gpui-component Root wrapper for theme and context provision
use gpui_component::input::{Input, InputEvent, InputState};
use gpui_component::notification::{Notification, NotificationType};
use gpui_component::Root;

thinking
**Planning include file inspection**
exec
/bin/zsh -lc 'rg -n "include!'"\\(\\\"main_sections/|main_sections\" src/main.rs" in /Users/johnlindquist/dev/script-kit-gpui succeeded in 51ms:
261:include!("main_sections/deeplink.rs");
262:include!("main_sections/window_visibility.rs");
263:include!("main_sections/fallbacks.rs");
264:include!("main_sections/fonts.rs");
265:include!("main_sections/app_view_state.rs");
266:include!("main_sections/prompt_messages.rs");
267:include!("main_sections/app_state.rs");
289:include!("main_sections/render_impl.rs");

thinking
**Tracing module inclusion**
exec
/bin/zsh -lc 'rg -n "include!'"\\(\\\"app_execute\" src/main.rs src/app_execute.rs" in /Users/johnlindquist/dev/script-kit-gpui succeeded in 52ms:
src/main.rs:281:include!("app_execute.rs");
src/app_execute.rs:2:include!("app_execute/builtin_execution.rs");
src/app_execute.rs:3:include!("app_execute/execution_helpers.rs");
src/app_execute.rs:4:include!("app_execute/utility_views.rs");
src/app_execute.rs:5:include!("app_execute/builtin_confirmation.rs");

thinking
**Inspecting fallback close handling**
codex
I traced the likely root cause: fallback execution currently closes the window right after executing built-ins, so `Generate Script with AI` can be opened and immediately closed. Iâ€™m going to add a shared â€œAI script generation from queryâ€ helper, route Shift+Tab and the built-in through it, and stop auto-closing for this built-in fallback path.

thinking
**Planning file claims**
exec
/bin/zsh -lc '~/.claude/bin/swarm.ts update --id codex-ai-generate-fallback --status in_progress --notes "Tracing Shift+Tab and fallback built-in query forwarding; preparing shared AI script generation execution path." && ~/.claude/bin/swarm.ts claim --wait --id codex-ai-generate-fallback src/app_impl/prompt_ai.rs src/app_execute/builtin_execution.rs src/app_impl/selection_fallback.rs src/app_impl/startup.rs src/app_impl/startup_new_tab.rs src/main_sections/fallbacks.rs src/app_impl/tests.rs' in /Users/johnlindquist/dev/script-kit-gpui succeeded in 51ms:
Updated: codex-ai-generate-fallback
Claimed for codex-ai-generate-fallback: src/app_impl/prompt_ai.rs, src/app_execute/builtin_execution.rs, src/app_impl/selection_fallback.rs, src/app_impl/startup.rs, src/app_impl/startup_new_tab.rs, src/main_sections/fallbacks.rs, src/app_impl/tests.rs

thinking
**Refactoring script generation flow**
exec
/bin/zsh -lc "sed -n '1,220p' src/fallbacks/mod.rs" in /Users/johnlindquist/dev/script-kit-gpui succeeded in 50ms:
//! Fallback commands module
//!
//! Provides Raycast-style fallback commands that appear when no scripts match
//! the user's input. Includes built-in fallbacks and support for custom fallbacks.

pub mod builtins;
pub mod collector;

#[allow(unused_imports)]
pub use builtins::{
    get_applicable_fallbacks, get_builtin_fallbacks, BuiltinFallback, FallbackAction,
    FallbackCondition, FallbackResult,
};
#[allow(unused_imports)]
pub use collector::{
    collect_builtin_fallbacks, collect_fallbacks, collect_script_fallbacks, FallbackItem,
};

thinking
**Inspecting fallback item instantiation**
exec
/bin/zsh -lc "sed -n '1,260p' src/fallbacks/collector.rs" in /Users/johnlindquist/dev/script-kit-gpui succeeded in 52ms:
//! Fallback collector module
//!
//! Collects and filters all available fallbacks: built-in fallbacks and
//! user scripts with `fallback: true` in their typed metadata.
//!
//! NOTE: Some items are currently unused as this is a new module being integrated.
#![allow(dead_code)]

use std::sync::Arc;

use crate::fallbacks::builtins::{get_applicable_fallbacks, BuiltinFallback};
use crate::scripts::{FallbackConfig, Script};

/// Unified fallback item representing either a built-in fallback or a user script fallback
#[derive(Debug, Clone)]
pub enum FallbackItem {
    /// A built-in fallback command (Search Google, Copy to Clipboard, etc.)
    Builtin(BuiltinFallback),
    /// A user script with `fallback: true` in its metadata
    Script(FallbackConfig),

thinking
**Assessing patch scope and dependencies**
codex
I have the fix direction pinned down: fallback execution needs to preserve window state for this built-in, and both Shift+Tab and built-in execution should call one shared â€œdispatch script generation from queryâ€ helper. Iâ€™m applying those edits now in `prompt_ai`, `builtin_execution`, and fallback execution paths, then adding focused tests.

thinking
**Applying targeted patch to prompt_ai.rs**
file update
M /Users/johnlindquist/dev/script-kit-gpui/src/app_impl/prompt_ai.rs
@@ -640,2 +640,20 @@
 
+    pub(crate) fn dispatch_ai_script_generation_from_query(
+        &mut self,
+        query: String,
+        cx: &mut Context<Self>,
+    ) {
+        let query = query.trim().to_string();
+        if query.is_empty() {
+            logging::log(
+                "AI_SCRIPT_GEN",
+                "state=ignored attempted=dispatch_ai_script_generation_from_query reason=empty_query",
+            );
+            return;
+        }
+
+        self.filter_text.clear();
+        self.show_script_generation_chat(Some(query), cx);
+    }
+
     /// Generate a Script Kit script from a natural-language prompt using the built-in AI backend.
apply_patch(auto_approved=true) exited 0 in 12ms:
Success. Updated the following files:
M src/app_impl/prompt_ai.rs
file update:
diff --git a/src/app_impl/prompt_ai.rs b/src/app_impl/prompt_ai.rs
index 6c10ca4234dc2d80bb14bc0d5163caddf97656cc..f79076d6b5977825788241f2ece9814c6754a4c6
--- a/src/app_impl/prompt_ai.rs
+++ b/src/app_impl/prompt_ai.rs
@@ -638,6 +638,24 @@
         cx.notify();
     }
 
+    pub(crate) fn dispatch_ai_script_generation_from_query(
+        &mut self,
+        query: String,
+        cx: &mut Context<Self>,
+    ) {
+        let query = query.trim().to_string();
+        if query.is_empty() {
+            logging::log(
+                "AI_SCRIPT_GEN",
+                "state=ignored attempted=dispatch_ai_script_generation_from_query reason=empty_query",
+            );
+            return;
+        }
+
+        self.filter_text.clear();
+        self.show_script_generation_chat(Some(query), cx);
+    }
+
     /// Generate a Script Kit script from a natural-language prompt using the built-in AI backend.
     /// The generated script is saved to disk and opened in the configured editor.
     pub fn generate_script_from_ai_prompt(

file update:
diff --git a/src/app_impl/prompt_ai.rs b/src/app_impl/prompt_ai.rs
index 6c10ca4234dc2d80bb14bc0d5163caddf97656cc..f79076d6b5977825788241f2ece9814c6754a4c6
--- a/src/app_impl/prompt_ai.rs
+++ b/src/app_impl/prompt_ai.rs
@@ -638,6 +638,24 @@
         cx.notify();
     }
 
+    pub(crate) fn dispatch_ai_script_generation_from_query(
+        &mut self,
+        query: String,
+        cx: &mut Context<Self>,
+    ) {
+        let query = query.trim().to_string();
+        if query.is_empty() {
+            logging::log(
+                "AI_SCRIPT_GEN",
+                "state=ignored attempted=dispatch_ai_script_generation_from_query reason=empty_query",
+            );
+            return;
+        }
+
+        self.filter_text.clear();
+        self.show_script_generation_chat(Some(query), cx);
+    }
+
     /// Generate a Script Kit script from a natural-language prompt using the built-in AI backend.
     /// The generated script is saved to disk and opened in the configured editor.
     pub fn generate_script_from_ai_prompt(


thinking
**Preparing segment patch**
file update
M /Users/johnlindquist/dev/script-kit-gpui/src/app_impl/startup.rs
@@ -732,8 +732,7 @@
 
-                                // Clear filter text before switching view
-                                this.filter_text.clear();
-
                                 if has_shift {
-                                    this.show_script_generation_chat(Some(query), cx);
+                                    this.dispatch_ai_script_generation_from_query(query, cx);
                                 } else {
+                                    // Clear filter text before switching view
+                                    this.filter_text.clear();
                                     // Show inline AI chat with the query as initial input
apply_patch(auto_approved=true) exited 0 in 16ms:
Success. Updated the following files:
M src/app_impl/startup.rs
file update:
diff --git a/src/app_impl/prompt_ai.rs b/src/app_impl/prompt_ai.rs
index 6c10ca4234dc2d80bb14bc0d5163caddf97656cc..f79076d6b5977825788241f2ece9814c6754a4c6
--- a/src/app_impl/prompt_ai.rs
+++ b/src/app_impl/prompt_ai.rs
@@ -638,6 +638,24 @@
         cx.notify();
     }
 
+    pub(crate) fn dispatch_ai_script_generation_from_query(
+        &mut self,
+        query: String,
+        cx: &mut Context<Self>,
+    ) {
+        let query = query.trim().to_string();
+        if query.is_empty() {
+            logging::log(
+                "AI_SCRIPT_GEN",
+                "state=ignored attempted=dispatch_ai_script_generation_from_query reason=empty_query",
+            );
+            return;
+        }
+
+        self.filter_text.clear();
+        self.show_script_generation_chat(Some(query), cx);
+    }
+
     /// Generate a Script Kit script from a natural-language prompt using the built-in AI backend.
     /// The generated script is saved to disk and opened in the configured editor.
     pub fn generate_script_from_ai_prompt(
diff --git a/src/app_impl/startup.rs b/src/app_impl/startup.rs
index 4fd4dc8c23d8df925c657b8db59f888b855ea6a2..670e087da31d4d0b4c8e21cebc48b3533817041f
--- a/src/app_impl/startup.rs
+++ b/src/app_impl/startup.rs
@@ -730,12 +730,11 @@
                             {
                                 let query = this.filter_text.clone();
 
-                                // Clear filter text before switching view
-                                this.filter_text.clear();
-
                                 if has_shift {
-                                    this.show_script_generation_chat(Some(query), cx);
+                                    this.dispatch_ai_script_generation_from_query(query, cx);
                                 } else {
+                                    // Clear filter text before switching view
+                                    this.filter_text.clear();
                                     // Show inline AI chat with the query as initial input
                                     this.show_inline_ai_chat(Some(query), cx);
                                 }

file update:
diff --git a/src/app_impl/prompt_ai.rs b/src/app_impl/prompt_ai.rs
index 6c10ca4234dc2d80bb14bc0d5163caddf97656cc..f79076d6b5977825788241f2ece9814c6754a4c6
--- a/src/app_impl/prompt_ai.rs
+++ b/src/app_impl/prompt_ai.rs
@@ -638,6 +638,24 @@
         cx.notify();
     }
 
+    pub(crate) fn dispatch_ai_script_generation_from_query(
+        &mut self,
+        query: String,
+        cx: &mut Context<Self>,
+    ) {
+        let query = query.trim().to_string();
+        if query.is_empty() {
+            logging::log(
+                "AI_SCRIPT_GEN",
+                "state=ignored attempted=dispatch_ai_script_generation_from_query reason=empty_query",
+            );
+            return;
+        }
+
+        self.filter_text.clear();
+        self.show_script_generation_chat(Some(query), cx);
+    }
+
     /// Generate a Script Kit script from a natural-language prompt using the built-in AI backend.
     /// The generated script is saved to disk and opened in the configured editor.
     pub fn generate_script_from_ai_prompt(
diff --git a/src/app_impl/startup.rs b/src/app_impl/startup.rs
index 4fd4dc8c23d8df925c657b8db59f888b855ea6a2..670e087da31d4d0b4c8e21cebc48b3533817041f
--- a/src/app_impl/startup.rs
+++ b/src/app_impl/startup.rs
@@ -730,12 +730,11 @@
                             {
                                 let query = this.filter_text.clone();
 
-                                // Clear filter text before switching view
-                                this.filter_text.clear();
-
                                 if has_shift {
-                                    this.show_script_generation_chat(Some(query), cx);
+                                    this.dispatch_ai_script_generation_from_query(query, cx);
                                 } else {
+                                    // Clear filter text before switching view
+                                    this.filter_text.clear();
                                     // Show inline AI chat with the query as initial input
                                     this.show_inline_ai_chat(Some(query), cx);
                                 }


thinking
**Patching new tab startup**
file update
M /Users/johnlindquist/dev/script-kit-gpui/src/app_impl/startup_new_tab.rs
@@ -183,8 +183,7 @@
 
-                                // Clear filter text before switching view
-                                this.filter_text.clear();
-
                                 if has_shift {
-                                    this.show_script_generation_chat(Some(query), cx);
+                                    this.dispatch_ai_script_generation_from_query(query, cx);
                                 } else {
+                                    // Clear filter text before switching view
+                                    this.filter_text.clear();
                                     // Show inline AI chat with the query as initial input
apply_patch(auto_approved=true) exited 0 in 19ms:
Success. Updated the following files:
M src/app_impl/startup_new_tab.rs
file update:
diff --git a/src/app_impl/prompt_ai.rs b/src/app_impl/prompt_ai.rs
index 6c10ca4234dc2d80bb14bc0d5163caddf97656cc..f79076d6b5977825788241f2ece9814c6754a4c6
--- a/src/app_impl/prompt_ai.rs
+++ b/src/app_impl/prompt_ai.rs
@@ -638,6 +638,24 @@
         cx.notify();
     }
 
+    pub(crate) fn dispatch_ai_script_generation_from_query(
+        &mut self,
+        query: String,
+        cx: &mut Context<Self>,
+    ) {
+        let query = query.trim().to_string();
+        if query.is_empty() {
+            logging::log(
+                "AI_SCRIPT_GEN",
+                "state=ignored attempted=dispatch_ai_script_generation_from_query reason=empty_query",
+            );
+            return;
+        }
+
+        self.filter_text.clear();
+        self.show_script_generation_chat(Some(query), cx);
+    }
+
     /// Generate a Script Kit script from a natural-language prompt using the built-in AI backend.
     /// The generated script is saved to disk and opened in the configured editor.
     pub fn generate_script_from_ai_prompt(
diff --git a/src/app_impl/startup.rs b/src/app_impl/startup.rs
index 4fd4dc8c23d8df925c657b8db59f888b855ea6a2..670e087da31d4d0b4c8e21cebc48b3533817041f
--- a/src/app_impl/startup.rs
+++ b/src/app_impl/startup.rs
@@ -730,12 +730,11 @@
                             {
                                 let query = this.filter_text.clone();
 
-                                // Clear filter text before switching view
-                                this.filter_text.clear();
-
                                 if has_shift {
-                                    this.show_script_generation_chat(Some(query), cx);
+                                    this.dispatch_ai_script_generation_from_query(query, cx);
                                 } else {
+                                    // Clear filter text before switching view
+                                    this.filter_text.clear();
                                     // Show inline AI chat with the query as initial input
                                     this.show_inline_ai_chat(Some(query), cx);
                                 }
diff --git a/src/app_impl/startup_new_tab.rs b/src/app_impl/startup_new_tab.rs
index c75a27bf67a5448f59c7700079e8818210722bde..362ad2dcbf87a3a7e4476dcae211899dd788f079
--- a/src/app_impl/startup_new_tab.rs
+++ b/src/app_impl/startup_new_tab.rs
@@ -181,12 +181,11 @@
                             {
                                 let query = this.filter_text.clone();
 
-                                // Clear filter text before switching view
-                                this.filter_text.clear();
-
                                 if has_shift {
-                                    this.show_script_generation_chat(Some(query), cx);
+                                    this.dispatch_ai_script_generation_from_query(query, cx);
                                 } else {
+                                    // Clear filter text before switching view
+                                    this.filter_text.clear();
                                     // Show inline AI chat with the query as initial input
                                     this.show_inline_ai_chat(Some(query), cx);
                                 }

file update:
diff --git a/src/app_impl/prompt_ai.rs b/src/app_impl/prompt_ai.rs
index 6c10ca4234dc2d80bb14bc0d5163caddf97656cc..f79076d6b5977825788241f2ece9814c6754a4c6
--- a/src/app_impl/prompt_ai.rs
+++ b/src/app_impl/prompt_ai.rs
@@ -638,6 +638,24 @@
         cx.notify();
     }
 
+    pub(crate) fn dispatch_ai_script_generation_from_query(
+        &mut self,
+        query: String,
+        cx: &mut Context<Self>,
+    ) {
+        let query = query.trim().to_string();
+        if query.is_empty() {
+            logging::log(
+                "AI_SCRIPT_GEN",
+                "state=ignored attempted=dispatch_ai_script_generation_from_query reason=empty_query",
+            );
+            return;
+        }
+
+        self.filter_text.clear();
+        self.show_script_generation_chat(Some(query), cx);
+    }
+
     /// Generate a Script Kit script from a natural-language prompt using the built-in AI backend.
     /// The generated script is saved to disk and opened in the configured editor.
     pub fn generate_script_from_ai_prompt(
diff --git a/src/app_impl/startup.rs b/src/app_impl/startup.rs
index 4fd4dc8c23d8df925c657b8db59f888b855ea6a2..670e087da31d4d0b4c8e21cebc48b3533817041f
--- a/src/app_impl/startup.rs
+++ b/src/app_impl/startup.rs
@@ -730,12 +730,11 @@
                             {
                                 let query = this.filter_text.clone();
 
-                                // Clear filter text before switching view
-                                this.filter_text.clear();
-
                                 if has_shift {
-                                    this.show_script_generation_chat(Some(query), cx);
+                                    this.dispatch_ai_script_generation_from_query(query, cx);
                                 } else {
+                                    // Clear filter text before switching view
+                                    this.filter_text.clear();
                                     // Show inline AI chat with the query as initial input
                                     this.show_inline_ai_chat(Some(query), cx);
                                 }
diff --git a/src/app_impl/startup_new_tab.rs b/src/app_impl/startup_new_tab.rs
index c75a27bf67a5448f59c7700079e8818210722bde..362ad2dcbf87a3a7e4476dcae211899dd788f079
--- a/src/app_impl/startup_new_tab.rs
+++ b/src/app_impl/startup_new_tab.rs
@@ -181,12 +181,11 @@
                             {
                                 let query = this.filter_text.clone();
 
-                                // Clear filter text before switching view
-                                this.filter_text.clear();
-
                                 if has_shift {
-                                    this.show_script_generation_chat(Some(query), cx);
+                                    this.dispatch_ai_script_generation_from_query(query, cx);
                                 } else {
+                                    // Clear filter text before switching view
+                                    this.filter_text.clear();
                                     // Show inline AI chat with the query as initial input
                                     this.show_inline_ai_chat(Some(query), cx);
                                 }


thinking
**Preparing wrapper introduction**
exec
/bin/zsh -lc "sed -n '90,170p' src/app_execute/builtin_execution.rs" in /Users/johnlindquist/dev/script-kit-gpui succeeded in 51ms:
        ok_button = applescript_escape(ok_button),
    );

    let value = run_osascript(&script)?;
    if value.is_empty() {
        Ok(None)
    } else {
        Ok(Some(value))
    }
}

fn emoji_picker_label(emoji: &script_kit_gpui::emoji::Emoji) -> String {
    format!("{}  {}", emoji.emoji, emoji.name)
}

fn quicklink_picker_label(quicklink: &script_kit_gpui::quicklinks::Quicklink) -> String {
    format!("{}  {}", quicklink.name, quicklink.url_template)
}

impl ScriptListApp {
file update:
diff --git a/src/app_impl/prompt_ai.rs b/src/app_impl/prompt_ai.rs
index 6c10ca4234dc2d80bb14bc0d5163caddf97656cc..f79076d6b5977825788241f2ece9814c6754a4c6
--- a/src/app_impl/prompt_ai.rs
+++ b/src/app_impl/prompt_ai.rs
@@ -638,6 +638,24 @@
         cx.notify();
     }
 
+    pub(crate) fn dispatch_ai_script_generation_from_query(
+        &mut self,
+        query: String,
+        cx: &mut Context<Self>,
+    ) {
+        let query = query.trim().to_string();
+        if query.is_empty() {
+            logging::log(
+                "AI_SCRIPT_GEN",
+                "state=ignored attempted=dispatch_ai_script_generation_from_query reason=empty_query",
+            );
+            return;
+        }
+
+        self.filter_text.clear();
+        self.show_script_generation_chat(Some(query), cx);
+    }
+
     /// Generate a Script Kit script from a natural-language prompt using the built-in AI backend.
     /// The generated script is saved to disk and opened in the configured editor.
     pub fn generate_script_from_ai_prompt(
diff --git a/src/app_impl/startup.rs b/src/app_impl/startup.rs
index 4fd4dc8c23d8df925c657b8db59f888b855ea6a2..670e087da31d4d0b4c8e21cebc48b3533817041f
--- a/src/app_impl/startup.rs
+++ b/src/app_impl/startup.rs
@@ -730,12 +730,11 @@
                             {
                                 let query = this.filter_text.clone();
 
-                                // Clear filter text before switching view
-                                this.filter_text.clear();
-
                                 if has_shift {
-                                    this.show_script_generation_chat(Some(query), cx);
+                                    this.dispatch_ai_script_generation_from_query(query, cx);
                                 } else {
+                                    // Clear filter text before switching view
+                                    this.filter_text.clear();
                                     // Show inline AI chat with the query as initial input
                                     this.show_inline_ai_chat(Some(query), cx);
                                 }
diff --git a/src/app_impl/startup_new_tab.rs b/src/app_impl/startup_new_tab.rs
index c75a27bf67a5448f59c7700079e8818210722bde..362ad2dcbf87a3a7e4476dcae211899dd788f079
--- a/src/app_impl/startup_new_tab.rs
+++ b/src/app_impl/startup_new_tab.rs
@@ -181,12 +181,11 @@
                             {
                                 let query = this.filter_text.clone();
 
-                                // Clear filter text before switching view
-                                this.filter_text.clear();
-
                                 if has_shift {
-                                    this.show_script_generation_chat(Some(query), cx);
+                                    this.dispatch_ai_script_generation_from_query(query, cx);
                                 } else {
+                                    // Clear filter text before switching view
+                                    this.filter_text.clear();
                                     // Show inline AI chat with the query as initial input
                                     this.show_inline_ai_chat(Some(query), cx);
                                 }


thinking
**Inspecting function branch around 1025**
exec
/bin/zsh -lc "sed -n '990,1055p' src/app_execute/builtin_execution.rs" in /Users/johnlindquist/dev/script-kit-gpui succeeded in 50ms:
                                        components::toast::Toast::error(
                                            format!(
                                                "AI history cleared, but failed to open AI: {}",
                                                e
                                            ),
                                            &self.theme,
                                        )
                                        .duration_ms(Some(5000)),
                                    );
                                    cx.notify();
                                } else {
                                    self.show_hud(
                                        "Cleared AI conversations".to_string(),
                                        Some(2000),
                                        cx,
                                    );
                                }
                            }
                            Err(e) => {
                                logging::log(
file update:
diff --git a/src/app_impl/prompt_ai.rs b/src/app_impl/prompt_ai.rs
index 6c10ca4234dc2d80bb14bc0d5163caddf97656cc..f79076d6b5977825788241f2ece9814c6754a4c6
--- a/src/app_impl/prompt_ai.rs
+++ b/src/app_impl/prompt_ai.rs
@@ -638,6 +638,24 @@
         cx.notify();
     }
 
+    pub(crate) fn dispatch_ai_script_generation_from_query(
+        &mut self,
+        query: String,
+        cx: &mut Context<Self>,
+    ) {
+        let query = query.trim().to_string();
+        if query.is_empty() {
+            logging::log(
+                "AI_SCRIPT_GEN",
+                "state=ignored attempted=dispatch_ai_script_generation_from_query reason=empty_query",
+            );
+            return;
+        }
+
+        self.filter_text.clear();
+        self.show_script_generation_chat(Some(query), cx);
+    }
+
     /// Generate a Script Kit script from a natural-language prompt using the built-in AI backend.
     /// The generated script is saved to disk and opened in the configured editor.
     pub fn generate_script_from_ai_prompt(
diff --git a/src/app_impl/startup.rs b/src/app_impl/startup.rs
index 4fd4dc8c23d8df925c657b8db59f888b855ea6a2..670e087da31d4d0b4c8e21cebc48b3533817041f
--- a/src/app_impl/startup.rs
+++ b/src/app_impl/startup.rs
@@ -730,12 +730,11 @@
                             {
                                 let query = this.filter_text.clone();
 
-                                // Clear filter text before switching view
-                                this.filter_text.clear();
-
                                 if has_shift {
-                                    this.show_script_generation_chat(Some(query), cx);
+                                    this.dispatch_ai_script_generation_from_query(query, cx);
                                 } else {
+                                    // Clear filter text before switching view
+                                    this.filter_text.clear();
                                     // Show inline AI chat with the query as initial input
                                     this.show_inline_ai_chat(Some(query), cx);
                                 }
diff --git a/src/app_impl/startup_new_tab.rs b/src/app_impl/startup_new_tab.rs
index c75a27bf67a5448f59c7700079e8818210722bde..362ad2dcbf87a3a7e4476dcae211899dd788f079
--- a/src/app_impl/startup_new_tab.rs
+++ b/src/app_impl/startup_new_tab.rs
@@ -181,12 +181,11 @@
                             {
                                 let query = this.filter_text.clone();
 
-                                // Clear filter text before switching view
-                                this.filter_text.clear();
-
                                 if has_shift {
-                                    this.show_script_generation_chat(Some(query), cx);
+                                    this.dispatch_ai_script_generation_from_query(query, cx);
                                 } else {
+                                    // Clear filter text before switching view
+                                    this.filter_text.clear();
                                     // Show inline AI chat with the query as initial input
                                     this.show_inline_ai_chat(Some(query), cx);
                                 }


thinking
**Planning wrapper insertion**
file update
M /Users/johnlindquist/dev/script-kit-gpui/src/app_execute/builtin_execution.rs
@@ -124,2 +124,11 @@
     fn execute_builtin(&mut self, entry: &builtins::BuiltInEntry, cx: &mut Context<Self>) {
+        self.execute_builtin_with_query(entry, None, cx);
+    }
+
+    fn execute_builtin_with_query(
+        &mut self,
+        entry: &builtins::BuiltInEntry,
+        query_override: Option<&str>,
+        cx: &mut Context<Self>,
+    ) {
         logging::log(
@@ -1025,4 +1034,4 @@
                     AiCommandType::GenerateScript => {
-                        let query = self.filter_text.trim().to_string();
-                        self.show_script_generation_chat(Some(query), cx);
+                        let query = query_override.unwrap_or(&self.filter_text).to_string();
+                        self.dispatch_ai_script_generation_from_query(query, cx);
                     }
apply_patch(auto_approved=true) exited 0 in 26ms:
Success. Updated the following files:
M src/app_execute/builtin_execution.rs
file update:
diff --git a/src/app_execute/builtin_execution.rs b/src/app_execute/builtin_execution.rs
index dbce42e2664627892bed0da4fee92f6621cd2afd..9c0181eecf499492796afa9819219127d9c04de7
--- a/src/app_execute/builtin_execution.rs
+++ b/src/app_execute/builtin_execution.rs
@@ -122,6 +122,15 @@
     }
 
     fn execute_builtin(&mut self, entry: &builtins::BuiltInEntry, cx: &mut Context<Self>) {
+        self.execute_builtin_with_query(entry, None, cx);
+    }
+
+    fn execute_builtin_with_query(
+        &mut self,
+        entry: &builtins::BuiltInEntry,
+        query_override: Option<&str>,
+        cx: &mut Context<Self>,
+    ) {
         logging::log(
             "EXEC",
             &format!("Executing built-in: {} (id: {})", entry.name, entry.id),
@@ -1023,8 +1032,8 @@
                     }
 
                     AiCommandType::GenerateScript => {
-                        let query = self.filter_text.trim().to_string();
-                        self.show_script_generation_chat(Some(query), cx);
+                        let query = query_override.unwrap_or(&self.filter_text).to_string();
+                        self.dispatch_ai_script_generation_from_query(query, cx);
                     }
 
                     AiCommandType::SendScreenToAi => {
diff --git a/src/app_impl/prompt_ai.rs b/src/app_impl/prompt_ai.rs
index 6c10ca4234dc2d80bb14bc0d5163caddf97656cc..f79076d6b5977825788241f2ece9814c6754a4c6
--- a/src/app_impl/prompt_ai.rs
+++ b/src/app_impl/prompt_ai.rs
@@ -638,6 +638,24 @@
         cx.notify();
     }
 
+    pub(crate) fn dispatch_ai_script_generation_from_query(
+        &mut self,
+        query: String,
+        cx: &mut Context<Self>,
+    ) {
+        let query = query.trim().to_string();
+        if query.is_empty() {
+            logging::log(
+                "AI_SCRIPT_GEN",
+                "state=ignored attempted=dispatch_ai_script_generation_from_query reason=empty_query",
+            );
+            return;
+        }
+
+        self.filter_text.clear();
+        self.show_script_generation_chat(Some(query), cx);
+    }
+
     /// Generate a Script Kit script from a natural-language prompt using the built-in AI backend.
     /// The generated script is saved to disk and opened in the configured editor.
     pub fn generate_script_from_ai_prompt(
diff --git a/src/app_impl/startup.rs b/src/app_impl/startup.rs
index 4fd4dc8c23d8df925c657b8db59f888b855ea6a2..670e087da31d4d0b4c8e21cebc48b3533817041f
--- a/src/app_impl/startup.rs
+++ b/src/app_impl/startup.rs
@@ -730,12 +730,11 @@
                             {
                                 let query = this.filter_text.clone();
 
-                                // Clear filter text before switching view
-                                this.filter_text.clear();
-
                                 if has_shift {
-                                    this.show_script_generation_chat(Some(query), cx);
+                                    this.dispatch_ai_script_generation_from_query(query, cx);
                                 } else {
+                                    // Clear filter text before switching view
+                                    this.filter_text.clear();
                                     // Show inline AI chat with the query as initial input
                                     this.show_inline_ai_chat(Some(query), cx);
                                 }
diff --git a/src/app_impl/startup_new_tab.rs b/src/app_impl/startup_new_tab.rs
index c75a27bf67a5448f59c7700079e8818210722bde..362ad2dcbf87a3a7e4476dcae211899dd788f079
--- a/src/app_impl/startup_new_tab.rs
+++ b/src/app_impl/startup_new_tab.rs
@@ -181,12 +181,11 @@
                             {
                                 let query = this.filter_text.clone();
 
-                                // Clear filter text before switching view
-                                this.filter_text.clear();
-
                                 if has_shift {
-                                    this.show_script_generation_chat(Some(query), cx);
+                                    this.dispatch_ai_script_generation_from_query(query, cx);
                                 } else {
+                                    // Clear filter text before switching view
+                                    this.filter_text.clear();
                                     // Show inline AI chat with the query as initial input
                                     this.show_inline_ai_chat(Some(query), cx);
                                 }

file update:
diff --git a/src/app_execute/builtin_execution.rs b/src/app_execute/builtin_execution.rs
index dbce42e2664627892bed0da4fee92f6621cd2afd..9c0181eecf499492796afa9819219127d9c04de7
--- a/src/app_execute/builtin_execution.rs
+++ b/src/app_execute/builtin_execution.rs
@@ -122,6 +122,15 @@
     }
 
     fn execute_builtin(&mut self, entry: &builtins::BuiltInEntry, cx: &mut Context<Self>) {
+        self.execute_builtin_with_query(entry, None, cx);
+    }
+
+    fn execute_builtin_with_query(
+        &mut self,
+        entry: &builtins::BuiltInEntry,
+        query_override: Option<&str>,
+        cx: &mut Context<Self>,
+    ) {
         logging::log(
             "EXEC",
             &format!("Executing built-in: {} (id: {})", entry.name, entry.id),
@@ -1023,8 +1032,8 @@
                     }
 
                     AiCommandType::GenerateScript => {
-                        let query = self.filter_text.trim().to_string();
-                        self.show_script_generation_chat(Some(query), cx);
+                        let query = query_override.unwrap_or(&self.filter_text).to_string();
+                        self.dispatch_ai_script_generation_from_query(query, cx);
                     }
 
                     AiCommandType::SendScreenToAi => {
diff --git a/src/app_impl/prompt_ai.rs b/src/app_impl/prompt_ai.rs
index 6c10ca4234dc2d80bb14bc0d5163caddf97656cc..f79076d6b5977825788241f2ece9814c6754a4c6
--- a/src/app_impl/prompt_ai.rs
+++ b/src/app_impl/prompt_ai.rs
@@ -638,6 +638,24 @@
         cx.notify();
     }
 
+    pub(crate) fn dispatch_ai_script_generation_from_query(
+        &mut self,
+        query: String,
+        cx: &mut Context<Self>,
+    ) {
+        let query = query.trim().to_string();
+        if query.is_empty() {
+            logging::log(
+                "AI_SCRIPT_GEN",
+                "state=ignored attempted=dispatch_ai_script_generation_from_query reason=empty_query",
+            );
+            return;
+        }
+
+        self.filter_text.clear();
+        self.show_script_generation_chat(Some(query), cx);
+    }
+
     /// Generate a Script Kit script from a natural-language prompt using the built-in AI backend.
     /// The generated script is saved to disk and opened in the configured editor.
     pub fn generate_script_from_ai_prompt(
diff --git a/src/app_impl/startup.rs b/src/app_impl/startup.rs
index 4fd4dc8c23d8df925c657b8db59f888b855ea6a2..670e087da31d4d0b4c8e21cebc48b3533817041f
--- a/src/app_impl/startup.rs
+++ b/src/app_impl/startup.rs
@@ -730,12 +730,11 @@
                             {
                                 let query = this.filter_text.clone();
 
-                                // Clear filter text before switching view
-                                this.filter_text.clear();
-
                                 if has_shift {
-                                    this.show_script_generation_chat(Some(query), cx);
+                                    this.dispatch_ai_script_generation_from_query(query, cx);
                                 } else {
+                                    // Clear filter text before switching view
+                                    this.filter_text.clear();
                                     // Show inline AI chat with the query as initial input
                                     this.show_inline_ai_chat(Some(query), cx);
                                 }
diff --git a/src/app_impl/startup_new_tab.rs b/src/app_impl/startup_new_tab.rs
index c75a27bf67a5448f59c7700079e8818210722bde..362ad2dcbf87a3a7e4476dcae211899dd788f079
--- a/src/app_impl/startup_new_tab.rs
+++ b/src/app_impl/startup_new_tab.rs
@@ -181,12 +181,11 @@
                             {
                                 let query = this.filter_text.clone();
 
-                                // Clear filter text before switching view
-                                this.filter_text.clear();
-
                                 if has_shift {
-                                    this.show_script_generation_chat(Some(query), cx);
+                                    this.dispatch_ai_script_generation_from_query(query, cx);
                                 } else {
+                                    // Clear filter text before switching view
+                                    this.filter_text.clear();
                                     // Show inline AI chat with the query as initial input
                                     this.show_inline_ai_chat(Some(query), cx);
                                 }


thinking
**Inspecting helper functions for patch**
exec
/bin/zsh -lc "sed -n '1,120p' src/app_impl/selection_fallback.rs" in /Users/johnlindquist/dev/script-kit-gpui succeeded in 50ms:
use super::*;

fn resolve_grouped_result_index(
    grouped_items: &[GroupedListItem],
    selected_index: usize,
) -> Option<(usize, usize)> {
    let coerced_index = crate::list_item::coerce_selection(grouped_items, selected_index)?;
    match grouped_items.get(coerced_index) {
        Some(GroupedListItem::Item(result_idx)) => Some((coerced_index, *result_idx)),
        _ => None,
    }
}

impl ScriptListApp {
    #[allow(dead_code)]
    pub(crate) fn filtered_scripts(&self) -> Vec<Arc<scripts::Script>> {
        let filter_text = self.filter_text();
        if filter_text.is_empty() {
            self.scripts.clone()
        } else {
file update:
diff --git a/src/app_execute/builtin_execution.rs b/src/app_execute/builtin_execution.rs
index dbce42e2664627892bed0da4fee92f6621cd2afd..9c0181eecf499492796afa9819219127d9c04de7
--- a/src/app_execute/builtin_execution.rs
+++ b/src/app_execute/builtin_execution.rs
@@ -122,6 +122,15 @@
     }
 
     fn execute_builtin(&mut self, entry: &builtins::BuiltInEntry, cx: &mut Context<Self>) {
+        self.execute_builtin_with_query(entry, None, cx);
+    }
+
+    fn execute_builtin_with_query(
+        &mut self,
+        entry: &builtins::BuiltInEntry,
+        query_override: Option<&str>,
+        cx: &mut Context<Self>,
+    ) {
         logging::log(
             "EXEC",
             &format!("Executing built-in: {} (id: {})", entry.name, entry.id),
@@ -1023,8 +1032,8 @@
                     }
 
                     AiCommandType::GenerateScript => {
-                        let query = self.filter_text.trim().to_string();
-                        self.show_script_generation_chat(Some(query), cx);
+                        let query = query_override.unwrap_or(&self.filter_text).to_string();
+                        self.dispatch_ai_script_generation_from_query(query, cx);
                     }
 
                     AiCommandType::SendScreenToAi => {
diff --git a/src/app_impl/prompt_ai.rs b/src/app_impl/prompt_ai.rs
index 6c10ca4234dc2d80bb14bc0d5163caddf97656cc..f79076d6b5977825788241f2ece9814c6754a4c6
--- a/src/app_impl/prompt_ai.rs
+++ b/src/app_impl/prompt_ai.rs
@@ -638,6 +638,24 @@
         cx.notify();
     }
 
+    pub(crate) fn dispatch_ai_script_generation_from_query(
+        &mut self,
+        query: String,
+        cx: &mut Context<Self>,
+    ) {
+        let query = query.trim().to_string();
+        if query.is_empty() {
+            logging::log(
+                "AI_SCRIPT_GEN",
+                "state=ignored attempted=dispatch_ai_script_generation_from_query reason=empty_query",
+            );
+            return;
+        }
+
+        self.filter_text.clear();
+        self.show_script_generation_chat(Some(query), cx);
+    }
+
     /// Generate a Script Kit script from a natural-language prompt using the built-in AI backend.
     /// The generated script is saved to disk and opened in the configured editor.
     pub fn generate_script_from_ai_prompt(
diff --git a/src/app_impl/startup.rs b/src/app_impl/startup.rs
index 4fd4dc8c23d8df925c657b8db59f888b855ea6a2..670e087da31d4d0b4c8e21cebc48b3533817041f
--- a/src/app_impl/startup.rs
+++ b/src/app_impl/startup.rs
@@ -730,12 +730,11 @@
                             {
                                 let query = this.filter_text.clone();
 
-                                // Clear filter text before switching view
-                                this.filter_text.clear();
-
                                 if has_shift {
-                                    this.show_script_generation_chat(Some(query), cx);
+                                    this.dispatch_ai_script_generation_from_query(query, cx);
                                 } else {
+                                    // Clear filter text before switching view
+                                    this.filter_text.clear();
                                     // Show inline AI chat with the query as initial input
                                     this.show_inline_ai_chat(Some(query), cx);
                                 }
diff --git a/src/app_impl/startup_new_tab.rs b/src/app_impl/startup_new_tab.rs
index c75a27bf67a5448f59c7700079e8818210722bde..362ad2dcbf87a3a7e4476dcae211899dd788f079
--- a/src/app_impl/startup_new_tab.rs
+++ b/src/app_impl/startup_new_tab.rs
@@ -181,12 +181,11 @@
                             {
                                 let query = this.filter_text.clone();
 
-                                // Clear filter text before switching view
-                                this.filter_text.clear();
-
                                 if has_shift {
-                                    this.show_script_generation_chat(Some(query), cx);
+                                    this.dispatch_ai_script_generation_from_query(query, cx);
                                 } else {
+                                    // Clear filter text before switching view
+                                    this.filter_text.clear();
                                     // Show inline AI chat with the query as initial input
                                     this.show_inline_ai_chat(Some(query), cx);
                                 }


thinking
**Adding helper function and patching logic**
file update
M /Users/johnlindquist/dev/script-kit-gpui/src/app_impl/selection_fallback.rs
@@ -13,2 +13,12 @@
 
+fn fallback_keeps_window_open(fallback: &crate::fallbacks::FallbackItem) -> bool {
+    match fallback {
+        crate::fallbacks::FallbackItem::Builtin(builtin) => matches!(
+            builtin.id,
+            "run-in-terminal" | "search-files" | "builtin-generate-script-with-ai"
+        ),
+        crate::fallbacks::FallbackItem::Script(_) => true,
+    }
+}
+
 impl ScriptListApp {
apply_patch(auto_approved=true) exited 0 in 29ms:
Success. Updated the following files:
M src/app_impl/selection_fallback.rs
file update:
diff --git a/src/app_execute/builtin_execution.rs b/src/app_execute/builtin_execution.rs
index dbce42e2664627892bed0da4fee92f6621cd2afd..9c0181eecf499492796afa9819219127d9c04de7
--- a/src/app_execute/builtin_execution.rs
+++ b/src/app_execute/builtin_execution.rs
@@ -122,6 +122,15 @@
     }
 
     fn execute_builtin(&mut self, entry: &builtins::BuiltInEntry, cx: &mut Context<Self>) {
+        self.execute_builtin_with_query(entry, None, cx);
+    }
+
+    fn execute_builtin_with_query(
+        &mut self,
+        entry: &builtins::BuiltInEntry,
+        query_override: Option<&str>,
+        cx: &mut Context<Self>,
+    ) {
         logging::log(
             "EXEC",
             &format!("Executing built-in: {} (id: {})", entry.name, entry.id),
@@ -1023,8 +1032,8 @@
                     }
 
                     AiCommandType::GenerateScript => {
-                        let query = self.filter_text.trim().to_string();
-                        self.show_script_generation_chat(Some(query), cx);
+                        let query = query_override.unwrap_or(&self.filter_text).to_string();
+                        self.dispatch_ai_script_generation_from_query(query, cx);
                     }
 
                     AiCommandType::SendScreenToAi => {
diff --git a/src/app_impl/prompt_ai.rs b/src/app_impl/prompt_ai.rs
index 6c10ca4234dc2d80bb14bc0d5163caddf97656cc..f79076d6b5977825788241f2ece9814c6754a4c6
--- a/src/app_impl/prompt_ai.rs
+++ b/src/app_impl/prompt_ai.rs
@@ -638,6 +638,24 @@
         cx.notify();
     }
 
+    pub(crate) fn dispatch_ai_script_generation_from_query(
+        &mut self,
+        query: String,
+        cx: &mut Context<Self>,
+    ) {
+        let query = query.trim().to_string();
+        if query.is_empty() {
+            logging::log(
+                "AI_SCRIPT_GEN",
+                "state=ignored attempted=dispatch_ai_script_generation_from_query reason=empty_query",
+            );
+            return;
+        }
+
+        self.filter_text.clear();
+        self.show_script_generation_chat(Some(query), cx);
+    }
+
     /// Generate a Script Kit script from a natural-language prompt using the built-in AI backend.
     /// The generated script is saved to disk and opened in the configured editor.
     pub fn generate_script_from_ai_prompt(
diff --git a/src/app_impl/selection_fallback.rs b/src/app_impl/selection_fallback.rs
index 9dcd609c870dcb8be976ed0dac0045ff196f31e3..2bc40073a3544f7f38b28a6f03387d4e889d822f
--- a/src/app_impl/selection_fallback.rs
+++ b/src/app_impl/selection_fallback.rs
@@ -11,6 +11,16 @@
     }
 }
 
+fn fallback_keeps_window_open(fallback: &crate::fallbacks::FallbackItem) -> bool {
+    match fallback {
+        crate::fallbacks::FallbackItem::Builtin(builtin) => matches!(
+            builtin.id,
+            "run-in-terminal" | "search-files" | "builtin-generate-script-with-ai"
+        ),
+        crate::fallbacks::FallbackItem::Script(_) => true,
+    }
+}
+
 impl ScriptListApp {
     #[allow(dead_code)]
     pub(crate) fn filtered_scripts(&self) -> Vec<Arc<scripts::Script>> {
diff --git a/src/app_impl/startup.rs b/src/app_impl/startup.rs
index 4fd4dc8c23d8df925c657b8db59f888b855ea6a2..670e087da31d4d0b4c8e21cebc48b3533817041f
--- a/src/app_impl/startup.rs
+++ b/src/app_impl/startup.rs
@@ -730,12 +730,11 @@
                             {
                                 let query = this.filter_text.clone();
 
-                                // Clear filter text before switching view
-                                this.filter_text.clear();
-
                                 if has_shift {
-                                    this.show_script_generation_chat(Some(query), cx);
+                                    this.dispatch_ai_script_generation_from_query(query, cx);
                                 } else {
+                                    // Clear filter text before switching view
+                                    this.filter_text.clear();
                                     // Show inline AI chat with the query as initial input
                                     this.show_inline_ai_chat(Some(query), cx);
                                 }
diff --git a/src/app_impl/startup_new_tab.rs b/src/app_impl/startup_new_tab.rs
index c75a27bf67a5448f59c7700079e8818210722bde..362ad2dcbf87a3a7e4476dcae211899dd788f079
--- a/src/app_impl/startup_new_tab.rs
+++ b/src/app_impl/startup_new_tab.rs
@@ -181,12 +181,11 @@
                             {
                                 let query = this.filter_text.clone();
 
-                                // Clear filter text before switching view
-                                this.filter_text.clear();
-
                                 if has_shift {
-                                    this.show_script_generation_chat(Some(query), cx);
+                                    this.dispatch_ai_script_generation_from_query(query, cx);
                                 } else {
+                                    // Clear filter text before switching view
+                                    this.filter_text.clear();
                                     // Show inline AI chat with the query as initial input
                                     this.show_inline_ai_chat(Some(query), cx);
                                 }

file update:
diff --git a/src/app_execute/builtin_execution.rs b/src/app_execute/builtin_execution.rs
index dbce42e2664627892bed0da4fee92f6621cd2afd..9c0181eecf499492796afa9819219127d9c04de7
--- a/src/app_execute/builtin_execution.rs
+++ b/src/app_execute/builtin_execution.rs
@@ -122,6 +122,15 @@
     }
 
     fn execute_builtin(&mut self, entry: &builtins::BuiltInEntry, cx: &mut Context<Self>) {
+        self.execute_builtin_with_query(entry, None, cx);
+    }
+
+    fn execute_builtin_with_query(
+        &mut self,
+        entry: &builtins::BuiltInEntry,
+        query_override: Option<&str>,
+        cx: &mut Context<Self>,
+    ) {
         logging::log(
             "EXEC",
             &format!("Executing built-in: {} (id: {})", entry.name, entry.id),
@@ -1023,8 +1032,8 @@
                     }
 
                     AiCommandType::GenerateScript => {
-                        let query = self.filter_text.trim().to_string();
-                        self.show_script_generation_chat(Some(query), cx);
+                        let query = query_override.unwrap_or(&self.filter_text).to_string();
+                        self.dispatch_ai_script_generation_from_query(query, cx);
                     }
 
                     AiCommandType::SendScreenToAi => {
diff --git a/src/app_impl/prompt_ai.rs b/src/app_impl/prompt_ai.rs
index 6c10ca4234dc2d80bb14bc0d5163caddf97656cc..f79076d6b5977825788241f2ece9814c6754a4c6
--- a/src/app_impl/prompt_ai.rs
+++ b/src/app_impl/prompt_ai.rs
@@ -638,6 +638,24 @@
         cx.notify();
     }
 
+    pub(crate) fn dispatch_ai_script_generation_from_query(
+        &mut self,
+        query: String,
+        cx: &mut Context<Self>,
+    ) {
+        let query = query.trim().to_string();
+        if query.is_empty() {
+            logging::log(
+                "AI_SCRIPT_GEN",
+                "state=ignored attempted=dispatch_ai_script_generation_from_query reason=empty_query",
+            );
+            return;
+        }
+
+        self.filter_text.clear();
+        self.show_script_generation_chat(Some(query), cx);
+    }
+
     /// Generate a Script Kit script from a natural-language prompt using the built-in AI backend.
     /// The generated script is saved to disk and opened in the configured editor.
     pub fn generate_script_from_ai_prompt(
diff --git a/src/app_impl/selection_fallback.rs b/src/app_impl/selection_fallback.rs
index 9dcd609c870dcb8be976ed0dac0045ff196f31e3..2bc40073a3544f7f38b28a6f03387d4e889d822f
--- a/src/app_impl/selection_fallback.rs
+++ b/src/app_impl/selection_fallback.rs
@@ -11,6 +11,16 @@
     }
 }
 
+fn fallback_keeps_window_open(fallback: &crate::fallbacks::FallbackItem) -> bool {
+    match fallback {
+        crate::fallbacks::FallbackItem::Builtin(builtin) => matches!(
+            builtin.id,
+            "run-in-terminal" | "search-files" | "builtin-generate-script-with-ai"
+        ),
+        crate::fallbacks::FallbackItem::Script(_) => true,
+    }
+}
+
 impl ScriptListApp {
     #[allow(dead_code)]
     pub(crate) fn filtered_scripts(&self) -> Vec<Arc<scripts::Script>> {
diff --git a/src/app_impl/startup.rs b/src/app_impl/startup.rs
index 4fd4dc8c23d8df925c657b8db59f888b855ea6a2..670e087da31d4d0b4c8e21cebc48b3533817041f
--- a/src/app_impl/startup.rs
+++ b/src/app_impl/startup.rs
@@ -730,12 +730,11 @@
                             {
                                 let query = this.filter_text.clone();
 
-                                // Clear filter text before switching view
-                                this.filter_text.clear();
-
                                 if has_shift {
-                                    this.show_script_generation_chat(Some(query), cx);
+                                    this.dispatch_ai_script_generation_from_query(query, cx);
                                 } else {
+                                    // Clear filter text before switching view
+                                    this.filter_text.clear();
                                     // Show inline AI chat with the query as initial input
                                     this.show_inline_ai_chat(Some(query), cx);
                                 }
diff --git a/src/app_impl/startup_new_tab.rs b/src/app_impl/startup_new_tab.rs
index c75a27bf67a5448f59c7700079e8818210722bde..362ad2dcbf87a3a7e4476dcae211899dd788f079
--- a/src/app_impl/startup_new_tab.rs
+++ b/src/app_impl/startup_new_tab.rs
@@ -181,12 +181,11 @@
                             {
                                 let query = this.filter_text.clone();
 
-                                // Clear filter text before switching view
-                                this.filter_text.clear();
-
                                 if has_shift {
-                                    this.show_script_generation_chat(Some(query), cx);
+                                    this.dispatch_ai_script_generation_from_query(query, cx);
                                 } else {
+                                    // Clear filter text before switching view
+                                    this.filter_text.clear();
                                     // Show inline AI chat with the query as initial input
                                     this.show_inline_ai_chat(Some(query), cx);
                                 }


thinking
**Patching matching snippet occurrences**
file update
M /Users/johnlindquist/dev/script-kit-gpui/src/app_impl/selection_fallback.rs
@@ -231,10 +231,3 @@
 
-        // Check if this is a "stay open" action (like run-in-terminal which opens a view)
-        // Check if this is a "stay open" action (opens its own view)
-        let should_close = match fallback {
-            crate::fallbacks::FallbackItem::Builtin(builtin) => {
-                !matches!(builtin.id, "run-in-terminal" | "search-files")
-            }
-            crate::fallbacks::FallbackItem::Script(_) => false,
-        };
+        let should_close = !fallback_keeps_window_open(fallback);
 
@@ -272,9 +265,3 @@
 
-            // Check if this is a "stay open" action (opens its own view)
-            let should_close = match &fallback {
-                crate::fallbacks::FallbackItem::Builtin(builtin) => {
-                    !matches!(builtin.id, "run-in-terminal" | "search-files")
-                }
-                crate::fallbacks::FallbackItem::Script(_) => false,
-            };
+            let should_close = !fallback_keeps_window_open(&fallback);
 
apply_patch(auto_approved=true) exited 0 in 32ms:
Success. Updated the following files:
M src/app_impl/selection_fallback.rs
file update:
diff --git a/src/app_execute/builtin_execution.rs b/src/app_execute/builtin_execution.rs
index dbce42e2664627892bed0da4fee92f6621cd2afd..9c0181eecf499492796afa9819219127d9c04de7
--- a/src/app_execute/builtin_execution.rs
+++ b/src/app_execute/builtin_execution.rs
@@ -122,6 +122,15 @@
     }
 
     fn execute_builtin(&mut self, entry: &builtins::BuiltInEntry, cx: &mut Context<Self>) {
+        self.execute_builtin_with_query(entry, None, cx);
+    }
+
+    fn execute_builtin_with_query(
+        &mut self,
+        entry: &builtins::BuiltInEntry,
+        query_override: Option<&str>,
+        cx: &mut Context<Self>,
+    ) {
         logging::log(
             "EXEC",
             &format!("Executing built-in: {} (id: {})", entry.name, entry.id),
@@ -1023,8 +1032,8 @@
                     }
 
                     AiCommandType::GenerateScript => {
-                        let query = self.filter_text.trim().to_string();
-                        self.show_script_generation_chat(Some(query), cx);
+                        let query = query_override.unwrap_or(&self.filter_text).to_string();
+                        self.dispatch_ai_script_generation_from_query(query, cx);
                     }
 
                     AiCommandType::SendScreenToAi => {
diff --git a/src/app_impl/prompt_ai.rs b/src/app_impl/prompt_ai.rs
index 6c10ca4234dc2d80bb14bc0d5163caddf97656cc..f79076d6b5977825788241f2ece9814c6754a4c6
--- a/src/app_impl/prompt_ai.rs
+++ b/src/app_impl/prompt_ai.rs
@@ -638,6 +638,24 @@
         cx.notify();
     }
 
+    pub(crate) fn dispatch_ai_script_generation_from_query(
+        &mut self,
+        query: String,
+        cx: &mut Context<Self>,
+    ) {
+        let query = query.trim().to_string();
+        if query.is_empty() {
+            logging::log(
+                "AI_SCRIPT_GEN",
+                "state=ignored attempted=dispatch_ai_script_generation_from_query reason=empty_query",
+            );
+            return;
+        }
+
+        self.filter_text.clear();
+        self.show_script_generation_chat(Some(query), cx);
+    }
+
     /// Generate a Script Kit script from a natural-language prompt using the built-in AI backend.
     /// The generated script is saved to disk and opened in the configured editor.
     pub fn generate_script_from_ai_prompt(
diff --git a/src/app_impl/selection_fallback.rs b/src/app_impl/selection_fallback.rs
index 9dcd609c870dcb8be976ed0dac0045ff196f31e3..88ea45f2c4d1c8b8ec1a07648dc92e67f3103049
--- a/src/app_impl/selection_fallback.rs
+++ b/src/app_impl/selection_fallback.rs
@@ -11,6 +11,16 @@
     }
 }
 
+fn fallback_keeps_window_open(fallback: &crate::fallbacks::FallbackItem) -> bool {
+    match fallback {
+        crate::fallbacks::FallbackItem::Builtin(builtin) => matches!(
+            builtin.id,
+            "run-in-terminal" | "search-files" | "builtin-generate-script-with-ai"
+        ),
+        crate::fallbacks::FallbackItem::Script(_) => true,
+    }
+}
+
 impl ScriptListApp {
     #[allow(dead_code)]
     pub(crate) fn filtered_scripts(&self) -> Vec<Arc<scripts::Script>> {
@@ -219,14 +229,7 @@
             ),
         );
 
-        // Check if this is a "stay open" action (like run-in-terminal which opens a view)
-        // Check if this is a "stay open" action (opens its own view)
-        let should_close = match fallback {
-            crate::fallbacks::FallbackItem::Builtin(builtin) => {
-                !matches!(builtin.id, "run-in-terminal" | "search-files")
-            }
-            crate::fallbacks::FallbackItem::Script(_) => false,
-        };
+        let should_close = !fallback_keeps_window_open(fallback);
 
         // Execute the fallback action
         match fallback {
@@ -260,13 +263,7 @@
         {
             logging::log("EXEC", &format!("Executing fallback: {}", fallback.name()));
 
-            // Check if this is a "stay open" action (opens its own view)
-            let should_close = match &fallback {
-                crate::fallbacks::FallbackItem::Builtin(builtin) => {
-                    !matches!(builtin.id, "run-in-terminal" | "search-files")
-                }
-                crate::fallbacks::FallbackItem::Script(_) => false,
-            };
+            let should_close = !fallback_keeps_window_open(&fallback);
 
             // Execute the fallback action
             match &fallback {
diff --git a/src/app_impl/startup.rs b/src/app_impl/startup.rs
index 4fd4dc8c23d8df925c657b8db59f888b855ea6a2..670e087da31d4d0b4c8e21cebc48b3533817041f
--- a/src/app_impl/startup.rs
+++ b/src/app_impl/startup.rs
@@ -730,12 +730,11 @@
                             {
                                 let query = this.filter_text.clone();
 
-                                // Clear filter text before switching view
-                                this.filter_text.clear();
-
                                 if has_shift {
-                                    this.show_script_generation_chat(Some(query), cx);
+                                    this.dispatch_ai_script_generation_from_query(query, cx);
                                 } else {
+                                    // Clear filter text before switching view
+                                    this.filter_text.clear();
                                     // Show inline AI chat with the query as initial input
                                     this.show_inline_ai_chat(Some(query), cx);
                                 }
diff --git a/src/app_impl/startup_new_tab.rs b/src/app_impl/startup_new_tab.rs
index c75a27bf67a5448f59c7700079e8818210722bde..362ad2dcbf87a3a7e4476dcae211899dd788f079
--- a/src/app_impl/startup_new_tab.rs
+++ b/src/app_impl/startup_new_tab.rs
@@ -181,12 +181,11 @@
                             {
                                 let query = this.filter_text.clone();
 
-                                // Clear filter text before switching view
-                                this.filter_text.clear();
-
                                 if has_shift {
-                                    this.show_script_generation_chat(Some(query), cx);
+                                    this.dispatch_ai_script_generation_from_query(query, cx);
                                 } else {
+                                    // Clear filter text before switching view
+                                    this.filter_text.clear();
                                     // Show inline AI chat with the query as initial input
                                     this.show_inline_ai_chat(Some(query), cx);
                                 }

file update:
diff --git a/src/app_execute/builtin_execution.rs b/src/app_execute/builtin_execution.rs
index dbce42e2664627892bed0da4fee92f6621cd2afd..9c0181eecf499492796afa9819219127d9c04de7
--- a/src/app_execute/builtin_execution.rs
+++ b/src/app_execute/builtin_execution.rs
@@ -122,6 +122,15 @@
     }
 
     fn execute_builtin(&mut self, entry: &builtins::BuiltInEntry, cx: &mut Context<Self>) {
+        self.execute_builtin_with_query(entry, None, cx);
+    }
+
+    fn execute_builtin_with_query(
+        &mut self,
+        entry: &builtins::BuiltInEntry,
+        query_override: Option<&str>,
+        cx: &mut Context<Self>,
+    ) {
         logging::log(
             "EXEC",
             &format!("Executing built-in: {} (id: {})", entry.name, entry.id),
@@ -1023,8 +1032,8 @@
                     }
 
                     AiCommandType::GenerateScript => {
-                        let query = self.filter_text.trim().to_string();
-                        self.show_script_generation_chat(Some(query), cx);
+                        let query = query_override.unwrap_or(&self.filter_text).to_string();
+                        self.dispatch_ai_script_generation_from_query(query, cx);
                     }
 
                     AiCommandType::SendScreenToAi => {
diff --git a/src/app_impl/prompt_ai.rs b/src/app_impl/prompt_ai.rs
index 6c10ca4234dc2d80bb14bc0d5163caddf97656cc..f79076d6b5977825788241f2ece9814c6754a4c6
--- a/src/app_impl/prompt_ai.rs
+++ b/src/app_impl/prompt_ai.rs
@@ -638,6 +638,24 @@
         cx.notify();
     }
 
+    pub(crate) fn dispatch_ai_script_generation_from_query(
+        &mut self,
+        query: String,
+        cx: &mut Context<Self>,
+    ) {
+        let query = query.trim().to_string();
+        if query.is_empty() {
+            logging::log(
+                "AI_SCRIPT_GEN",
+                "state=ignored attempted=dispatch_ai_script_generation_from_query reason=empty_query",
+            );
+            return;
+        }
+
+        self.filter_text.clear();
+        self.show_script_generation_chat(Some(query), cx);
+    }
+
     /// Generate a Script Kit script from a natural-language prompt using the built-in AI backend.
     /// The generated script is saved to disk and opened in the configured editor.
     pub fn generate_script_from_ai_prompt(
diff --git a/src/app_impl/selection_fallback.rs b/src/app_impl/selection_fallback.rs
index 9dcd609c870dcb8be976ed0dac0045ff196f31e3..88ea45f2c4d1c8b8ec1a07648dc92e67f3103049
--- a/src/app_impl/selection_fallback.rs
+++ b/src/app_impl/selection_fallback.rs
@@ -11,6 +11,16 @@
     }
 }
 
+fn fallback_keeps_window_open(fallback: &crate::fallbacks::FallbackItem) -> bool {
+    match fallback {
+        crate::fallbacks::FallbackItem::Builtin(builtin) => matches!(
+            builtin.id,
+            "run-in-terminal" | "search-files" | "builtin-generate-script-with-ai"
+        ),
+        crate::fallbacks::FallbackItem::Script(_) => true,
+    }
+}
+
 impl ScriptListApp {
     #[allow(dead_code)]
     pub(crate) fn filtered_scripts(&self) -> Vec<Arc<scripts::Script>> {
@@ -219,14 +229,7 @@
             ),
         );
 
-        // Check if this is a "stay open" action (like run-in-terminal which opens a view)
-        // Check if this is a "stay open" action (opens its own view)
-        let should_close = match fallback {
-            crate::fallbacks::FallbackItem::Builtin(builtin) => {
-                !matches!(builtin.id, "run-in-terminal" | "search-files")
-            }
-            crate::fallbacks::FallbackItem::Script(_) => false,
-        };
+        let should_close = !fallback_keeps_window_open(fallback);
 
         // Execute the fallback action
         match fallback {
@@ -260,13 +263,7 @@
         {
             logging::log("EXEC", &format!("Executing fallback: {}", fallback.name()));
 
-            // Check if this is a "stay open" action (opens its own view)
-            let should_close = match &fallback {
-                crate::fallbacks::FallbackItem::Builtin(builtin) => {
-                    !matches!(builtin.id, "run-in-terminal" | "search-files")
-                }
-                crate::fallbacks::FallbackItem::Script(_) => false,
-            };
+            let should_close = !fallback_keeps_window_open(&fallback);
 
             // Execute the fallback action
             match &fallback {
diff --git a/src/app_impl/startup.rs b/src/app_impl/startup.rs
index 4fd4dc8c23d8df925c657b8db59f888b855ea6a2..670e087da31d4d0b4c8e21cebc48b3533817041f
--- a/src/app_impl/startup.rs
+++ b/src/app_impl/startup.rs
@@ -730,12 +730,11 @@
                             {
                                 let query = this.filter_text.clone();
 
-                                // Clear filter text before switching view
-                                this.filter_text.clear();
-
                                 if has_shift {
-                                    this.show_script_generation_chat(Some(query), cx);
+                                    this.dispatch_ai_script_generation_from_query(query, cx);
                                 } else {
+                                    // Clear filter text before switching view
+                                    this.filter_text.clear();
                                     // Show inline AI chat with the query as initial input
                                     this.show_inline_ai_chat(Some(query), cx);
                                 }
diff --git a/src/app_impl/startup_new_tab.rs b/src/app_impl/startup_new_tab.rs
index c75a27bf67a5448f59c7700079e8818210722bde..362ad2dcbf87a3a7e4476dcae211899dd788f079
--- a/src/app_impl/startup_new_tab.rs
+++ b/src/app_impl/startup_new_tab.rs
@@ -181,12 +181,11 @@
                             {
                                 let query = this.filter_text.clone();
 
-                                // Clear filter text before switching view
-                                this.filter_text.clear();
-
                                 if has_shift {
-                                    this.show_script_generation_chat(Some(query), cx);
+                                    this.dispatch_ai_script_generation_from_query(query, cx);
                                 } else {
+                                    // Clear filter text before switching view
+                                    this.filter_text.clear();
                                     // Show inline AI chat with the query as initial input
                                     this.show_inline_ai_chat(Some(query), cx);
                                 }


thinking
**Patching builtin execution call**
file update
M /Users/johnlindquist/dev/script-kit-gpui/src/app_impl/selection_fallback.rs
@@ -398,3 +398,3 @@
 
-                    self.execute_builtin(&entry, cx);
+                    self.execute_builtin_with_query(&entry, Some(input), cx);
                 }
apply_patch(auto_approved=true) exited 0 in 29ms:
Success. Updated the following files:
M src/app_impl/selection_fallback.rs
file update:
diff --git a/src/app_execute/builtin_execution.rs b/src/app_execute/builtin_execution.rs
index dbce42e2664627892bed0da4fee92f6621cd2afd..9c0181eecf499492796afa9819219127d9c04de7
--- a/src/app_execute/builtin_execution.rs
+++ b/src/app_execute/builtin_execution.rs
@@ -122,6 +122,15 @@
     }
 
     fn execute_builtin(&mut self, entry: &builtins::BuiltInEntry, cx: &mut Context<Self>) {
+        self.execute_builtin_with_query(entry, None, cx);
+    }
+
+    fn execute_builtin_with_query(
+        &mut self,
+        entry: &builtins::BuiltInEntry,
+        query_override: Option<&str>,
+        cx: &mut Context<Self>,
+    ) {
         logging::log(
             "EXEC",
             &format!("Executing built-in: {} (id: {})", entry.name, entry.id),
@@ -1023,8 +1032,8 @@
                     }
 
                     AiCommandType::GenerateScript => {
-                        let query = self.filter_text.trim().to_string();
-                        self.show_script_generation_chat(Some(query), cx);
+                        let query = query_override.unwrap_or(&self.filter_text).to_string();
+                        self.dispatch_ai_script_generation_from_query(query, cx);
                     }
 
                     AiCommandType::SendScreenToAi => {
diff --git a/src/app_impl/prompt_ai.rs b/src/app_impl/prompt_ai.rs
index 6c10ca4234dc2d80bb14bc0d5163caddf97656cc..f79076d6b5977825788241f2ece9814c6754a4c6
--- a/src/app_impl/prompt_ai.rs
+++ b/src/app_impl/prompt_ai.rs
@@ -638,6 +638,24 @@
         cx.notify();
     }
 
+    pub(crate) fn dispatch_ai_script_generation_from_query(
+        &mut self,
+        query: String,
+        cx: &mut Context<Self>,
+    ) {
+        let query = query.trim().to_string();
+        if query.is_empty() {
+            logging::log(
+                "AI_SCRIPT_GEN",
+                "state=ignored attempted=dispatch_ai_script_generation_from_query reason=empty_query",
+            );
+            return;
+        }
+
+        self.filter_text.clear();
+        self.show_script_generation_chat(Some(query), cx);
+    }
+
     /// Generate a Script Kit script from a natural-language prompt using the built-in AI backend.
     /// The generated script is saved to disk and opened in the configured editor.
     pub fn generate_script_from_ai_prompt(
diff --git a/src/app_impl/selection_fallback.rs b/src/app_impl/selection_fallback.rs
index 9dcd609c870dcb8be976ed0dac0045ff196f31e3..57e4804067c56ea115a33896c116ebbc293f5b4d
--- a/src/app_impl/selection_fallback.rs
+++ b/src/app_impl/selection_fallback.rs
@@ -11,6 +11,16 @@
     }
 }
 
+fn fallback_keeps_window_open(fallback: &crate::fallbacks::FallbackItem) -> bool {
+    match fallback {
+        crate::fallbacks::FallbackItem::Builtin(builtin) => matches!(
+            builtin.id,
+            "run-in-terminal" | "search-files" | "builtin-generate-script-with-ai"
+        ),
+        crate::fallbacks::FallbackItem::Script(_) => true,
+    }
+}
+
 impl ScriptListApp {
     #[allow(dead_code)]
     pub(crate) fn filtered_scripts(&self) -> Vec<Arc<scripts::Script>> {
@@ -219,14 +229,7 @@
             ),
         );
 
-        // Check if this is a "stay open" action (like run-in-terminal which opens a view)
-        // Check if this is a "stay open" action (opens its own view)
-        let should_close = match fallback {
-            crate::fallbacks::FallbackItem::Builtin(builtin) => {
-                !matches!(builtin.id, "run-in-terminal" | "search-files")
-            }
-            crate::fallbacks::FallbackItem::Script(_) => false,
-        };
+        let should_close = !fallback_keeps_window_open(fallback);
 
         // Execute the fallback action
         match fallback {
@@ -260,13 +263,7 @@
         {
             logging::log("EXEC", &format!("Executing fallback: {}", fallback.name()));
 
-            // Check if this is a "stay open" action (opens its own view)
-            let should_close = match &fallback {
-                crate::fallbacks::FallbackItem::Builtin(builtin) => {
-                    !matches!(builtin.id, "run-in-terminal" | "search-files")
-                }
-                crate::fallbacks::FallbackItem::Script(_) => false,
-            };
+            let should_close = !fallback_keeps_window_open(&fallback);
 
             // Execute the fallback action
             match &fallback {
@@ -399,7 +396,7 @@
                         return;
                     };
 
-                    self.execute_builtin(&entry, cx);
+                    self.execute_builtin_with_query(&entry, Some(input), cx);
                 }
             },
             Err(e) => {
diff --git a/src/app_impl/startup.rs b/src/app_impl/startup.rs
index 4fd4dc8c23d8df925c657b8db59f888b855ea6a2..670e087da31d4d0b4c8e21cebc48b3533817041f
--- a/src/app_impl/startup.rs
+++ b/src/app_impl/startup.rs
@@ -730,12 +730,11 @@
                             {
                                 let query = this.filter_text.clone();
 
-                                // Clear filter text before switching view
-                                this.filter_text.clear();
-
                                 if has_shift {
-                                    this.show_script_generation_chat(Some(query), cx);
+                                    this.dispatch_ai_script_generation_from_query(query, cx);
                                 } else {
+                                    // Clear filter text before switching view
+                                    this.filter_text.clear();
                                     // Show inline AI chat with the query as initial input
                                     this.show_inline_ai_chat(Some(query), cx);
                                 }
diff --git a/src/app_impl/startup_new_tab.rs b/src/app_impl/startup_new_tab.rs
index c75a27bf67a5448f59c7700079e8818210722bde..362ad2dcbf87a3a7e4476dcae211899dd788f079
--- a/src/app_impl/startup_new_tab.rs
+++ b/src/app_impl/startup_new_tab.rs
@@ -181,12 +181,11 @@
                             {
                                 let query = this.filter_text.clone();
 
-                                // Clear filter text before switching view
-                                this.filter_text.clear();
-
                                 if has_shift {
-                                    this.show_script_generation_chat(Some(query), cx);
+                                    this.dispatch_ai_script_generation_from_query(query, cx);
                                 } else {
+                                    // Clear filter text before switching view
+                                    this.filter_text.clear();
                                     // Show inline AI chat with the query as initial input
                                     this.show_inline_ai_chat(Some(query), cx);
                                 }

file update:
diff --git a/src/app_execute/builtin_execution.rs b/src/app_execute/builtin_execution.rs
index dbce42e2664627892bed0da4fee92f6621cd2afd..9c0181eecf499492796afa9819219127d9c04de7
--- a/src/app_execute/builtin_execution.rs
+++ b/src/app_execute/builtin_execution.rs
@@ -122,6 +122,15 @@
     }
 
     fn execute_builtin(&mut self, entry: &builtins::BuiltInEntry, cx: &mut Context<Self>) {
+        self.execute_builtin_with_query(entry, None, cx);
+    }
+
+    fn execute_builtin_with_query(
+        &mut self,
+        entry: &builtins::BuiltInEntry,
+        query_override: Option<&str>,
+        cx: &mut Context<Self>,
+    ) {
         logging::log(
             "EXEC",
             &format!("Executing built-in: {} (id: {})", entry.name, entry.id),
@@ -1023,8 +1032,8 @@
                     }
 
                     AiCommandType::GenerateScript => {
-                        let query = self.filter_text.trim().to_string();
-                        self.show_script_generation_chat(Some(query), cx);
+                        let query = query_override.unwrap_or(&self.filter_text).to_string();
+                        self.dispatch_ai_script_generation_from_query(query, cx);
                     }
 
                     AiCommandType::SendScreenToAi => {
diff --git a/src/app_impl/prompt_ai.rs b/src/app_impl/prompt_ai.rs
index 6c10ca4234dc2d80bb14bc0d5163caddf97656cc..f79076d6b5977825788241f2ece9814c6754a4c6
--- a/src/app_impl/prompt_ai.rs
+++ b/src/app_impl/prompt_ai.rs
@@ -638,6 +638,24 @@
         cx.notify();
     }
 
+    pub(crate) fn dispatch_ai_script_generation_from_query(
+        &mut self,
+        query: String,
+        cx: &mut Context<Self>,
+    ) {
+        let query = query.trim().to_string();
+        if query.is_empty() {
+            logging::log(
+                "AI_SCRIPT_GEN",
+                "state=ignored attempted=dispatch_ai_script_generation_from_query reason=empty_query",
+            );
+            return;
+        }
+
+        self.filter_text.clear();
+        self.show_script_generation_chat(Some(query), cx);
+    }
+
     /// Generate a Script Kit script from a natural-language prompt using the built-in AI backend.
     /// The generated script is saved to disk and opened in the configured editor.
     pub fn generate_script_from_ai_prompt(
diff --git a/src/app_impl/selection_fallback.rs b/src/app_impl/selection_fallback.rs
index 9dcd609c870dcb8be976ed0dac0045ff196f31e3..57e4804067c56ea115a33896c116ebbc293f5b4d
--- a/src/app_impl/selection_fallback.rs
+++ b/src/app_impl/selection_fallback.rs
@@ -11,6 +11,16 @@
     }
 }
 
+fn fallback_keeps_window_open(fallback: &crate::fallbacks::FallbackItem) -> bool {
+    match fallback {
+        crate::fallbacks::FallbackItem::Builtin(builtin) => matches!(
+            builtin.id,
+            "run-in-terminal" | "search-files" | "builtin-generate-script-with-ai"
+        ),
+        crate::fallbacks::FallbackItem::Script(_) => true,
+    }
+}
+
 impl ScriptListApp {
     #[allow(dead_code)]
     pub(crate) fn filtered_scripts(&self) -> Vec<Arc<scripts::Script>> {
@@ -219,14 +229,7 @@
             ),
         );
 
-        // Check if this is a "stay open" action (like run-in-terminal which opens a view)
-        // Check if this is a "stay open" action (opens its own view)
-        let should_close = match fallback {
-            crate::fallbacks::FallbackItem::Builtin(builtin) => {
-                !matches!(builtin.id, "run-in-terminal" | "search-files")
-            }
-            crate::fallbacks::FallbackItem::Script(_) => false,
-        };
+        let should_close = !fallback_keeps_window_open(fallback);
 
         // Execute the fallback action
         match fallback {
@@ -260,13 +263,7 @@
         {
             logging::log("EXEC", &format!("Executing fallback: {}", fallback.name()));
 
-            // Check if this is a "stay open" action (opens its own view)
-            let should_close = match &fallback {
-                crate::fallbacks::FallbackItem::Builtin(builtin) => {
-                    !matches!(builtin.id, "run-in-terminal" | "search-files")
-                }
-                crate::fallbacks::FallbackItem::Script(_) => false,
-            };
+            let should_close = !fallback_keeps_window_open(&fallback);
 
             // Execute the fallback action
             match &fallback {
@@ -399,7 +396,7 @@
                         return;
                     };
 
-                    self.execute_builtin(&entry, cx);
+                    self.execute_builtin_with_query(&entry, Some(input), cx);
                 }
             },
             Err(e) => {
diff --git a/src/app_impl/startup.rs b/src/app_impl/startup.rs
index 4fd4dc8c23d8df925c657b8db59f888b855ea6a2..670e087da31d4d0b4c8e21cebc48b3533817041f
--- a/src/app_impl/startup.rs
+++ b/src/app_impl/startup.rs
@@ -730,12 +730,11 @@
                             {
                                 let query = this.filter_text.clone();
 
-                                // Clear filter text before switching view
-                                this.filter_text.clear();
-
                                 if has_shift {
-                                    this.show_script_generation_chat(Some(query), cx);
+                                    this.dispatch_ai_script_generation_from_query(query, cx);
                                 } else {
+                                    // Clear filter text before switching view
+                                    this.filter_text.clear();
                                     // Show inline AI chat with the query as initial input
                                     this.show_inline_ai_chat(Some(query), cx);
                                 }
diff --git a/src/app_impl/startup_new_tab.rs b/src/app_impl/startup_new_tab.rs
index c75a27bf67a5448f59c7700079e8818210722bde..362ad2dcbf87a3a7e4476dcae211899dd788f079
--- a/src/app_impl/startup_new_tab.rs
+++ b/src/app_impl/startup_new_tab.rs
@@ -181,12 +181,11 @@
                             {
                                 let query = this.filter_text.clone();
 
-                                // Clear filter text before switching view
-                                this.filter_text.clear();
-
                                 if has_shift {
-                                    this.show_script_generation_chat(Some(query), cx);
+                                    this.dispatch_ai_script_generation_from_query(query, cx);
                                 } else {
+                                    // Clear filter text before switching view
+                                    this.filter_text.clear();
                                     // Show inline AI chat with the query as initial input
                                     this.show_inline_ai_chat(Some(query), cx);
                                 }


thinking
**Planning test additions**
file update
M /Users/johnlindquist/dev/script-kit-gpui/src/app_impl/selection_fallback.rs
@@ -449,2 +449,26 @@
     }
+
+    #[test]
+    fn test_fallback_keeps_window_open_for_generate_script_builtin() {
+        let fallback = crate::fallbacks::FallbackItem::Builtin(
+            crate::fallbacks::builtins::get_builtin_fallbacks()
+                .into_iter()
+                .find(|fallback| fallback.id == "builtin-generate-script-with-ai")
+                .expect("generate-script fallback should exist"),
+        );
+
+        assert!(fallback_keeps_window_open(&fallback));
+    }
+
+    #[test]
+    fn test_fallback_keeps_window_open_is_false_for_regular_builtin() {
+        let fallback = crate::fallbacks::FallbackItem::Builtin(
+            crate::fallbacks::builtins::get_builtin_fallbacks()
+                .into_iter()
+                .find(|fallback| fallback.id == "search-google")
+                .expect("search-google fallback should exist"),
+        );
+
+        assert!(!fallback_keeps_window_open(&fallback));
+    }
 }
apply_patch(auto_approved=true) exited 0 in 29ms:
Success. Updated the following files:
M src/app_impl/selection_fallback.rs
file update:
diff --git a/src/app_execute/builtin_execution.rs b/src/app_execute/builtin_execution.rs
index dbce42e2664627892bed0da4fee92f6621cd2afd..9c0181eecf499492796afa9819219127d9c04de7
--- a/src/app_execute/builtin_execution.rs
+++ b/src/app_execute/builtin_execution.rs
@@ -122,6 +122,15 @@
     }
 
     fn execute_builtin(&mut self, entry: &builtins::BuiltInEntry, cx: &mut Context<Self>) {
+        self.execute_builtin_with_query(entry, None, cx);
+    }
+
+    fn execute_builtin_with_query(
+        &mut self,
+        entry: &builtins::BuiltInEntry,
+        query_override: Option<&str>,
+        cx: &mut Context<Self>,
+    ) {
         logging::log(
             "EXEC",
             &format!("Executing built-in: {} (id: {})", entry.name, entry.id),
@@ -1023,8 +1032,8 @@
                     }
 
                     AiCommandType::GenerateScript => {
-                        let query = self.filter_text.trim().to_string();
-                        self.show_script_generation_chat(Some(query), cx);
+                        let query = query_override.unwrap_or(&self.filter_text).to_string();
+                        self.dispatch_ai_script_generation_from_query(query, cx);
                     }
 
                     AiCommandType::SendScreenToAi => {
diff --git a/src/app_impl/prompt_ai.rs b/src/app_impl/prompt_ai.rs
index 6c10ca4234dc2d80bb14bc0d5163caddf97656cc..f79076d6b5977825788241f2ece9814c6754a4c6
--- a/src/app_impl/prompt_ai.rs
+++ b/src/app_impl/prompt_ai.rs
@@ -638,6 +638,24 @@
         cx.notify();
     }
 
+    pub(crate) fn dispatch_ai_script_generation_from_query(
+        &mut self,
+        query: String,
+        cx: &mut Context<Self>,
+    ) {
+        let query = query.trim().to_string();
+        if query.is_empty() {
+            logging::log(
+                "AI_SCRIPT_GEN",
+                "state=ignored attempted=dispatch_ai_script_generation_from_query reason=empty_query",
+            );
+            return;
+        }
+
+        self.filter_text.clear();
+        self.show_script_generation_chat(Some(query), cx);
+    }
+
     /// Generate a Script Kit script from a natural-language prompt using the built-in AI backend.
     /// The generated script is saved to disk and opened in the configured editor.
     pub fn generate_script_from_ai_prompt(
diff --git a/src/app_impl/selection_fallback.rs b/src/app_impl/selection_fallback.rs
index 9dcd609c870dcb8be976ed0dac0045ff196f31e3..8473dc467e6038b38319848a8da32f9997b36b36
--- a/src/app_impl/selection_fallback.rs
+++ b/src/app_impl/selection_fallback.rs
@@ -11,6 +11,16 @@
     }
 }
 
+fn fallback_keeps_window_open(fallback: &crate::fallbacks::FallbackItem) -> bool {
+    match fallback {
+        crate::fallbacks::FallbackItem::Builtin(builtin) => matches!(
+            builtin.id,
+            "run-in-terminal" | "search-files" | "builtin-generate-script-with-ai"
+        ),
+        crate::fallbacks::FallbackItem::Script(_) => true,
+    }
+}
+
 impl ScriptListApp {
     #[allow(dead_code)]
     pub(crate) fn filtered_scripts(&self) -> Vec<Arc<scripts::Script>> {
@@ -219,14 +229,7 @@
             ),
         );
 
-        // Check if this is a "stay open" action (like run-in-terminal which opens a view)
-        // Check if this is a "stay open" action (opens its own view)
-        let should_close = match fallback {
-            crate::fallbacks::FallbackItem::Builtin(builtin) => {
-                !matches!(builtin.id, "run-in-terminal" | "search-files")
-            }
-            crate::fallbacks::FallbackItem::Script(_) => false,
-        };
+        let should_close = !fallback_keeps_window_open(fallback);
 
         // Execute the fallback action
         match fallback {
@@ -260,13 +263,7 @@
         {
             logging::log("EXEC", &format!("Executing fallback: {}", fallback.name()));
 
-            // Check if this is a "stay open" action (opens its own view)
-            let should_close = match &fallback {
-                crate::fallbacks::FallbackItem::Builtin(builtin) => {
-                    !matches!(builtin.id, "run-in-terminal" | "search-files")
-                }
-                crate::fallbacks::FallbackItem::Script(_) => false,
-            };
+            let should_close = !fallback_keeps_window_open(&fallback);
 
             // Execute the fallback action
             match &fallback {
@@ -399,7 +396,7 @@
                         return;
                     };
 
-                    self.execute_builtin(&entry, cx);
+                    self.execute_builtin_with_query(&entry, Some(input), cx);
                 }
             },
             Err(e) => {
@@ -450,4 +447,28 @@
 
         assert_eq!(resolve_grouped_result_index(&grouped_items, 0), None);
     }
+
+    #[test]
+    fn test_fallback_keeps_window_open_for_generate_script_builtin() {
+        let fallback = crate::fallbacks::FallbackItem::Builtin(
+            crate::fallbacks::builtins::get_builtin_fallbacks()
+                .into_iter()
+                .find(|fallback| fallback.id == "builtin-generate-script-with-ai")
+                .expect("generate-script fallback should exist"),
+        );
+
+        assert!(fallback_keeps_window_open(&fallback));
+    }
+
+    #[test]
+    fn test_fallback_keeps_window_open_is_false_for_regular_builtin() {
+        let fallback = crate::fallbacks::FallbackItem::Builtin(
+            crate::fallbacks::builtins::get_builtin_fallbacks()
+                .into_iter()
+                .find(|fallback| fallback.id == "search-google")
+                .expect("search-google fallback should exist"),
+        );
+
+        assert!(!fallback_keeps_window_open(&fallback));
+    }
 }
diff --git a/src/app_impl/startup.rs b/src/app_impl/startup.rs
index 4fd4dc8c23d8df925c657b8db59f888b855ea6a2..670e087da31d4d0b4c8e21cebc48b3533817041f
--- a/src/app_impl/startup.rs
+++ b/src/app_impl/startup.rs
@@ -730,12 +730,11 @@
                             {
                                 let query = this.filter_text.clone();
 
-                                // Clear filter text before switching view
-                                this.filter_text.clear();
-
                                 if has_shift {
-                                    this.show_script_generation_chat(Some(query), cx);
+                                    this.dispatch_ai_script_generation_from_query(query, cx);
                                 } else {
+                                    // Clear filter text before switching view
+                                    this.filter_text.clear();
                                     // Show inline AI chat with the query as initial input
                                     this.show_inline_ai_chat(Some(query), cx);
                                 }
diff --git a/src/app_impl/startup_new_tab.rs b/src/app_impl/startup_new_tab.rs
index c75a27bf67a5448f59c7700079e8818210722bde..362ad2dcbf87a3a7e4476dcae211899dd788f079
--- a/src/app_impl/startup_new_tab.rs
+++ b/src/app_impl/startup_new_tab.rs
@@ -181,12 +181,11 @@
                             {
                                 let query = this.filter_text.clone();
 
-                                // Clear filter text before switching view
-                                this.filter_text.clear();
-
                                 if has_shift {
-                                    this.show_script_generation_chat(Some(query), cx);
+                                    this.dispatch_ai_script_generation_from_query(query, cx);
                                 } else {
+                                    // Clear filter text before switching view
+                                    this.filter_text.clear();
                                     // Show inline AI chat with the query as initial input
                                     this.show_inline_ai_chat(Some(query), cx);
                                 }

file update:
diff --git a/src/app_execute/builtin_execution.rs b/src/app_execute/builtin_execution.rs
index dbce42e2664627892bed0da4fee92f6621cd2afd..9c0181eecf499492796afa9819219127d9c04de7
--- a/src/app_execute/builtin_execution.rs
+++ b/src/app_execute/builtin_execution.rs
@@ -122,6 +122,15 @@
     }
 
     fn execute_builtin(&mut self, entry: &builtins::BuiltInEntry, cx: &mut Context<Self>) {
+        self.execute_builtin_with_query(entry, None, cx);
+    }
+
+    fn execute_builtin_with_query(
+        &mut self,
+        entry: &builtins::BuiltInEntry,
+        query_override: Option<&str>,
+        cx: &mut Context<Self>,
+    ) {
         logging::log(
             "EXEC",
             &format!("Executing built-in: {} (id: {})", entry.name, entry.id),
@@ -1023,8 +1032,8 @@
                     }
 
                     AiCommandType::GenerateScript => {
-                        let query = self.filter_text.trim().to_string();
-                        self.show_script_generation_chat(Some(query), cx);
+                        let query = query_override.unwrap_or(&self.filter_text).to_string();
+                        self.dispatch_ai_script_generation_from_query(query, cx);
                     }
 
                     AiCommandType::SendScreenToAi => {
diff --git a/src/app_impl/prompt_ai.rs b/src/app_impl/prompt_ai.rs
index 6c10ca4234dc2d80bb14bc0d5163caddf97656cc..f79076d6b5977825788241f2ece9814c6754a4c6
--- a/src/app_impl/prompt_ai.rs
+++ b/src/app_impl/prompt_ai.rs
@@ -638,6 +638,24 @@
         cx.notify();
     }
 
+    pub(crate) fn dispatch_ai_script_generation_from_query(
+        &mut self,
+        query: String,
+        cx: &mut Context<Self>,
+    ) {
+        let query = query.trim().to_string();
+        if query.is_empty() {
+            logging::log(
+                "AI_SCRIPT_GEN",
+                "state=ignored attempted=dispatch_ai_script_generation_from_query reason=empty_query",
+            );
+            return;
+        }
+
+        self.filter_text.clear();
+        self.show_script_generation_chat(Some(query), cx);
+    }
+
     /// Generate a Script Kit script from a natural-language prompt using the built-in AI backend.
     /// The generated script is saved to disk and opened in the configured editor.
     pub fn generate_script_from_ai_prompt(
diff --git a/src/app_impl/selection_fallback.rs b/src/app_impl/selection_fallback.rs
index 9dcd609c870dcb8be976ed0dac0045ff196f31e3..8473dc467e6038b38319848a8da32f9997b36b36
--- a/src/app_impl/selection_fallback.rs
+++ b/src/app_impl/selection_fallback.rs
@@ -11,6 +11,16 @@
     }
 }
 
+fn fallback_keeps_window_open(fallback: &crate::fallbacks::FallbackItem) -> bool {
+    match fallback {
+        crate::fallbacks::FallbackItem::Builtin(builtin) => matches!(
+            builtin.id,
+            "run-in-terminal" | "search-files" | "builtin-generate-script-with-ai"
+        ),
+        crate::fallbacks::FallbackItem::Script(_) => true,
+    }
+}
+
 impl ScriptListApp {
     #[allow(dead_code)]
     pub(crate) fn filtered_scripts(&self) -> Vec<Arc<scripts::Script>> {
@@ -219,14 +229,7 @@
             ),
         );
 
-        // Check if this is a "stay open" action (like run-in-terminal which opens a view)
-        // Check if this is a "stay open" action (opens its own view)
-        let should_close = match fallback {
-            crate::fallbacks::FallbackItem::Builtin(builtin) => {
-                !matches!(builtin.id, "run-in-terminal" | "search-files")
-            }
-            crate::fallbacks::FallbackItem::Script(_) => false,
-        };
+        let should_close = !fallback_keeps_window_open(fallback);
 
         // Execute the fallback action
         match fallback {
@@ -260,13 +263,7 @@
         {
             logging::log("EXEC", &format!("Executing fallback: {}", fallback.name()));
 
-            // Check if this is a "stay open" action (opens its own view)
-            let should_close = match &fallback {
-                crate::fallbacks::FallbackItem::Builtin(builtin) => {
-                    !matches!(builtin.id, "run-in-terminal" | "search-files")
-                }
-                crate::fallbacks::FallbackItem::Script(_) => false,
-            };
+            let should_close = !fallback_keeps_window_open(&fallback);
 
             // Execute the fallback action
             match &fallback {
@@ -399,7 +396,7 @@
                         return;
                     };
 
-                    self.execute_builtin(&entry, cx);
+                    self.execute_builtin_with_query(&entry, Some(input), cx);
                 }
             },
             Err(e) => {
@@ -450,4 +447,28 @@
 
         assert_eq!(resolve_grouped_result_index(&grouped_items, 0), None);
     }
+
+    #[test]
+    fn test_fallback_keeps_window_open_for_generate_script_builtin() {
+        let fallback = crate::fallbacks::FallbackItem::Builtin(
+            crate::fallbacks::builtins::get_builtin_fallbacks()
+                .into_iter()
+                .find(|fallback| fallback.id == "builtin-generate-script-with-ai")
+                .expect("generate-script fallback should exist"),
+        );
+
+        assert!(fallback_keeps_window_open(&fallback));
+    }
+
+    #[test]
+    fn test_fallback_keeps_window_open_is_false_for_regular_builtin() {
+        let fallback = crate::fallbacks::FallbackItem::Builtin(
+            crate::fallbacks::builtins::get_builtin_fallbacks()
+                .into_iter()
+                .find(|fallback| fallback.id == "search-google")
+                .expect("search-google fallback should exist"),
+        );
+
+        assert!(!fallback_keeps_window_open(&fallback));
+    }
 }
diff --git a/src/app_impl/startup.rs b/src/app_impl/startup.rs
index 4fd4dc8c23d8df925c657b8db59f888b855ea6a2..670e087da31d4d0b4c8e21cebc48b3533817041f
--- a/src/app_impl/startup.rs
+++ b/src/app_impl/startup.rs
@@ -730,12 +730,11 @@
                             {
                                 let query = this.filter_text.clone();
 
-                                // Clear filter text before switching view
-                                this.filter_text.clear();
-
                                 if has_shift {
-                                    this.show_script_generation_chat(Some(query), cx);
+                                    this.dispatch_ai_script_generation_from_query(query, cx);
                                 } else {
+                                    // Clear filter text before switching view
+                                    this.filter_text.clear();
                                     // Show inline AI chat with the query as initial input
                                     this.show_inline_ai_chat(Some(query), cx);
                                 }
diff --git a/src/app_impl/startup_new_tab.rs b/src/app_impl/startup_new_tab.rs
index c75a27bf67a5448f59c7700079e8818210722bde..362ad2dcbf87a3a7e4476dcae211899dd788f079
--- a/src/app_impl/startup_new_tab.rs
+++ b/src/app_impl/startup_new_tab.rs
@@ -181,12 +181,11 @@
                             {
                                 let query = this.filter_text.clone();
 
-                                // Clear filter text before switching view
-                                this.filter_text.clear();
-
                                 if has_shift {
-                                    this.show_script_generation_chat(Some(query), cx);
+                                    this.dispatch_ai_script_generation_from_query(query, cx);
                                 } else {
+                                    // Clear filter text before switching view
+                                    this.filter_text.clear();
                                     // Show inline AI chat with the query as initial input
                                     this.show_inline_ai_chat(Some(query), cx);
                                 }


thinking
**Patching fallback execution**
file update
M /Users/johnlindquist/dev/script-kit-gpui/src/main_sections/fallbacks.rs
@@ -162,3 +162,3 @@
 
-                    app.execute_builtin(&entry, cx);
+                    app.execute_builtin_with_query(&entry, Some(input), cx);
                 }
apply_patch(auto_approved=true) exited 0 in 32ms:
Success. Updated the following files:
M src/main_sections/fallbacks.rs
file update:
diff --git a/src/app_execute/builtin_execution.rs b/src/app_execute/builtin_execution.rs
index dbce42e2664627892bed0da4fee92f6621cd2afd..9c0181eecf499492796afa9819219127d9c04de7
--- a/src/app_execute/builtin_execution.rs
+++ b/src/app_execute/builtin_execution.rs
@@ -122,6 +122,15 @@
     }
 
     fn execute_builtin(&mut self, entry: &builtins::BuiltInEntry, cx: &mut Context<Self>) {
+        self.execute_builtin_with_query(entry, None, cx);
+    }
+
+    fn execute_builtin_with_query(
+        &mut self,
+        entry: &builtins::BuiltInEntry,
+        query_override: Option<&str>,
+        cx: &mut Context<Self>,
+    ) {
         logging::log(
             "EXEC",
             &format!("Executing built-in: {} (id: {})", entry.name, entry.id),
@@ -1023,8 +1032,8 @@
                     }
 
                     AiCommandType::GenerateScript => {
-                        let query = self.filter_text.trim().to_string();
-                        self.show_script_generation_chat(Some(query), cx);
+                        let query = query_override.unwrap_or(&self.filter_text).to_string();
+                        self.dispatch_ai_script_generation_from_query(query, cx);
                     }
 
                     AiCommandType::SendScreenToAi => {
diff --git a/src/app_impl/prompt_ai.rs b/src/app_impl/prompt_ai.rs
index 6c10ca4234dc2d80bb14bc0d5163caddf97656cc..f79076d6b5977825788241f2ece9814c6754a4c6
--- a/src/app_impl/prompt_ai.rs
+++ b/src/app_impl/prompt_ai.rs
@@ -638,6 +638,24 @@
         cx.notify();
     }
 
+    pub(crate) fn dispatch_ai_script_generation_from_query(
+        &mut self,
+        query: String,
+        cx: &mut Context<Self>,
+    ) {
+        let query = query.trim().to_string();
+        if query.is_empty() {
+            logging::log(
+                "AI_SCRIPT_GEN",
+                "state=ignored attempted=dispatch_ai_script_generation_from_query reason=empty_query",
+            );
+            return;
+        }
+
+        self.filter_text.clear();
+        self.show_script_generation_chat(Some(query), cx);
+    }
+
     /// Generate a Script Kit script from a natural-language prompt using the built-in AI backend.
     /// The generated script is saved to disk and opened in the configured editor.
     pub fn generate_script_from_ai_prompt(
diff --git a/src/app_impl/selection_fallback.rs b/src/app_impl/selection_fallback.rs
index 9dcd609c870dcb8be976ed0dac0045ff196f31e3..8473dc467e6038b38319848a8da32f9997b36b36
--- a/src/app_impl/selection_fallback.rs
+++ b/src/app_impl/selection_fallback.rs
@@ -11,6 +11,16 @@
     }
 }
 
+fn fallback_keeps_window_open(fallback: &crate::fallbacks::FallbackItem) -> bool {
+    match fallback {
+        crate::fallbacks::FallbackItem::Builtin(builtin) => matches!(
+            builtin.id,
+            "run-in-terminal" | "search-files" | "builtin-generate-script-with-ai"
+        ),
+        crate::fallbacks::FallbackItem::Script(_) => true,
+    }
+}
+
 impl ScriptListApp {
     #[allow(dead_code)]
     pub(crate) fn filtered_scripts(&self) -> Vec<Arc<scripts::Script>> {
@@ -219,14 +229,7 @@
             ),
         );
 
-        // Check if this is a "stay open" action (like run-in-terminal which opens a view)
-        // Check if this is a "stay open" action (opens its own view)
-        let should_close = match fallback {
-            crate::fallbacks::FallbackItem::Builtin(builtin) => {
-                !matches!(builtin.id, "run-in-terminal" | "search-files")
-            }
-            crate::fallbacks::FallbackItem::Script(_) => false,
-        };
+        let should_close = !fallback_keeps_window_open(fallback);
 
         // Execute the fallback action
         match fallback {
@@ -260,13 +263,7 @@
         {
             logging::log("EXEC", &format!("Executing fallback: {}", fallback.name()));
 
-            // Check if this is a "stay open" action (opens its own view)
-            let should_close = match &fallback {
-                crate::fallbacks::FallbackItem::Builtin(builtin) => {
-                    !matches!(builtin.id, "run-in-terminal" | "search-files")
-                }
-                crate::fallbacks::FallbackItem::Script(_) => false,
-            };
+            let should_close = !fallback_keeps_window_open(&fallback);
 
             // Execute the fallback action
             match &fallback {
@@ -399,7 +396,7 @@
                         return;
                     };
 
-                    self.execute_builtin(&entry, cx);
+                    self.execute_builtin_with_query(&entry, Some(input), cx);
                 }
             },
             Err(e) => {
@@ -450,4 +447,28 @@
 
         assert_eq!(resolve_grouped_result_index(&grouped_items, 0), None);
     }
+
+    #[test]
+    fn test_fallback_keeps_window_open_for_generate_script_builtin() {
+        let fallback = crate::fallbacks::FallbackItem::Builtin(
+            crate::fallbacks::builtins::get_builtin_fallbacks()
+                .into_iter()
+                .find(|fallback| fallback.id == "builtin-generate-script-with-ai")
+                .expect("generate-script fallback should exist"),
+        );
+
+        assert!(fallback_keeps_window_open(&fallback));
+    }
+
+    #[test]
+    fn test_fallback_keeps_window_open_is_false_for_regular_builtin() {
+        let fallback = crate::fallbacks::FallbackItem::Builtin(
+            crate::fallbacks::builtins::get_builtin_fallbacks()
+                .into_iter()
+                .find(|fallback| fallback.id == "search-google")
+                .expect("search-google fallback should exist"),
+        );
+
+        assert!(!fallback_keeps_window_open(&fallback));
+    }
 }
diff --git a/src/app_impl/startup.rs b/src/app_impl/startup.rs
index 4fd4dc8c23d8df925c657b8db59f888b855ea6a2..670e087da31d4d0b4c8e21cebc48b3533817041f
--- a/src/app_impl/startup.rs
+++ b/src/app_impl/startup.rs
@@ -730,12 +730,11 @@
                             {
                                 let query = this.filter_text.clone();
 
-                                // Clear filter text before switching view
-                                this.filter_text.clear();
-
                                 if has_shift {
-                                    this.show_script_generation_chat(Some(query), cx);
+                                    this.dispatch_ai_script_generation_from_query(query, cx);
                                 } else {
+                                    // Clear filter text before switching view
+                                    this.filter_text.clear();
                                     // Show inline AI chat with the query as initial input
                                     this.show_inline_ai_chat(Some(query), cx);
                                 }
diff --git a/src/app_impl/startup_new_tab.rs b/src/app_impl/startup_new_tab.rs
index c75a27bf67a5448f59c7700079e8818210722bde..362ad2dcbf87a3a7e4476dcae211899dd788f079
--- a/src/app_impl/startup_new_tab.rs
+++ b/src/app_impl/startup_new_tab.rs
@@ -181,12 +181,11 @@
                             {
                                 let query = this.filter_text.clone();
 
-                                // Clear filter text before switching view
-                                this.filter_text.clear();
-
                                 if has_shift {
-                                    this.show_script_generation_chat(Some(query), cx);
+                                    this.dispatch_ai_script_generation_from_query(query, cx);
                                 } else {
+                                    // Clear filter text before switching view
+                                    this.filter_text.clear();
                                     // Show inline AI chat with the query as initial input
                                     this.show_inline_ai_chat(Some(query), cx);
                                 }
diff --git a/src/main_sections/fallbacks.rs b/src/main_sections/fallbacks.rs
index 7742144684c5c00faffe448c3939b7b4517276bd..5b3881467e2ce686581f30b828f5d44849dcad56
--- a/src/main_sections/fallbacks.rs
+++ b/src/main_sections/fallbacks.rs
@@ -160,7 +160,7 @@
                         return;
                     };
 
-                    app.execute_builtin(&entry, cx);
+                    app.execute_builtin_with_query(&entry, Some(input), cx);
                 }
             }
         }

file update:
diff --git a/src/app_execute/builtin_execution.rs b/src/app_execute/builtin_execution.rs
index dbce42e2664627892bed0da4fee92f6621cd2afd..9c0181eecf499492796afa9819219127d9c04de7
--- a/src/app_execute/builtin_execution.rs
+++ b/src/app_execute/builtin_execution.rs
@@ -122,6 +122,15 @@
     }
 
     fn execute_builtin(&mut self, entry: &builtins::BuiltInEntry, cx: &mut Context<Self>) {
+        self.execute_builtin_with_query(entry, None, cx);
+    }
+
+    fn execute_builtin_with_query(
+        &mut self,
+        entry: &builtins::BuiltInEntry,
+        query_override: Option<&str>,
+        cx: &mut Context<Self>,
+    ) {
         logging::log(
             "EXEC",
             &format!("Executing built-in: {} (id: {})", entry.name, entry.id),
@@ -1023,8 +1032,8 @@
                     }
 
                     AiCommandType::GenerateScript => {
-                        let query = self.filter_text.trim().to_string();
-                        self.show_script_generation_chat(Some(query), cx);
+                        let query = query_override.unwrap_or(&self.filter_text).to_string();
+                        self.dispatch_ai_script_generation_from_query(query, cx);
                     }
 
                     AiCommandType::SendScreenToAi => {
diff --git a/src/app_impl/prompt_ai.rs b/src/app_impl/prompt_ai.rs
index 6c10ca4234dc2d80bb14bc0d5163caddf97656cc..f79076d6b5977825788241f2ece9814c6754a4c6
--- a/src/app_impl/prompt_ai.rs
+++ b/src/app_impl/prompt_ai.rs
@@ -638,6 +638,24 @@
         cx.notify();
     }
 
+    pub(crate) fn dispatch_ai_script_generation_from_query(
+        &mut self,
+        query: String,
+        cx: &mut Context<Self>,
+    ) {
+        let query = query.trim().to_string();
+        if query.is_empty() {
+            logging::log(
+                "AI_SCRIPT_GEN",
+                "state=ignored attempted=dispatch_ai_script_generation_from_query reason=empty_query",
+            );
+            return;
+        }
+
+        self.filter_text.clear();
+        self.show_script_generation_chat(Some(query), cx);
+    }
+
     /// Generate a Script Kit script from a natural-language prompt using the built-in AI backend.
     /// The generated script is saved to disk and opened in the configured editor.
     pub fn generate_script_from_ai_prompt(
diff --git a/src/app_impl/selection_fallback.rs b/src/app_impl/selection_fallback.rs
index 9dcd609c870dcb8be976ed0dac0045ff196f31e3..8473dc467e6038b38319848a8da32f9997b36b36
--- a/src/app_impl/selection_fallback.rs
+++ b/src/app_impl/selection_fallback.rs
@@ -11,6 +11,16 @@
     }
 }
 
+fn fallback_keeps_window_open(fallback: &crate::fallbacks::FallbackItem) -> bool {
+    match fallback {
+        crate::fallbacks::FallbackItem::Builtin(builtin) => matches!(
+            builtin.id,
+            "run-in-terminal" | "search-files" | "builtin-generate-script-with-ai"
+        ),
+        crate::fallbacks::FallbackItem::Script(_) => true,
+    }
+}
+
 impl ScriptListApp {
     #[allow(dead_code)]
     pub(crate) fn filtered_scripts(&self) -> Vec<Arc<scripts::Script>> {
@@ -219,14 +229,7 @@
             ),
         );
 
-        // Check if this is a "stay open" action (like run-in-terminal which opens a view)
-        // Check if this is a "stay open" action (opens its own view)
-        let should_close = match fallback {
-            crate::fallbacks::FallbackItem::Builtin(builtin) => {
-                !matches!(builtin.id, "run-in-terminal" | "search-files")
-            }
-            crate::fallbacks::FallbackItem::Script(_) => false,
-        };
+        let should_close = !fallback_keeps_window_open(fallback);
 
         // Execute the fallback action
         match fallback {
@@ -260,13 +263,7 @@
         {
             logging::log("EXEC", &format!("Executing fallback: {}", fallback.name()));
 
-            // Check if this is a "stay open" action (opens its own view)
-            let should_close = match &fallback {
-                crate::fallbacks::FallbackItem::Builtin(builtin) => {
-                    !matches!(builtin.id, "run-in-terminal" | "search-files")
-                }
-                crate::fallbacks::FallbackItem::Script(_) => false,
-            };
+            let should_close = !fallback_keeps_window_open(&fallback);
 
             // Execute the fallback action
             match &fallback {
@@ -399,7 +396,7 @@
                         return;
                     };
 
-                    self.execute_builtin(&entry, cx);
+                    self.execute_builtin_with_query(&entry, Some(input), cx);
                 }
             },
             Err(e) => {
@@ -450,4 +447,28 @@
 
         assert_eq!(resolve_grouped_result_index(&grouped_items, 0), None);
     }
+
+    #[test]
+    fn test_fallback_keeps_window_open_for_generate_script_builtin() {
+        let fallback = crate::fallbacks::FallbackItem::Builtin(
+            crate::fallbacks::builtins::get_builtin_fallbacks()
+                .into_iter()
+                .find(|fallback| fallback.id == "builtin-generate-script-with-ai")
+                .expect("generate-script fallback should exist"),
+        );
+
+        assert!(fallback_keeps_window_open(&fallback));
+    }
+
+    #[test]
+    fn test_fallback_keeps_window_open_is_false_for_regular_builtin() {
+        let fallback = crate::fallbacks::FallbackItem::Builtin(
+            crate::fallbacks::builtins::get_builtin_fallbacks()
+                .into_iter()
+                .find(|fallback| fallback.id == "search-google")
+                .expect("search-google fallback should exist"),
+        );
+
+        assert!(!fallback_keeps_window_open(&fallback));
+    }
 }
diff --git a/src/app_impl/startup.rs b/src/app_impl/startup.rs
index 4fd4dc8c23d8df925c657b8db59f888b855ea6a2..670e087da31d4d0b4c8e21cebc48b3533817041f
--- a/src/app_impl/startup.rs
+++ b/src/app_impl/startup.rs
@@ -730,12 +730,11 @@
                             {
                                 let query = this.filter_text.clone();
 
-                                // Clear filter text before switching view
-                                this.filter_text.clear();
-
                                 if has_shift {
-                                    this.show_script_generation_chat(Some(query), cx);
+                                    this.dispatch_ai_script_generation_from_query(query, cx);
                                 } else {
+                                    // Clear filter text before switching view
+                                    this.filter_text.clear();
                                     // Show inline AI chat with the query as initial input
                                     this.show_inline_ai_chat(Some(query), cx);
                                 }
diff --git a/src/app_impl/startup_new_tab.rs b/src/app_impl/startup_new_tab.rs
index c75a27bf67a5448f59c7700079e8818210722bde..362ad2dcbf87a3a7e4476dcae211899dd788f079
--- a/src/app_impl/startup_new_tab.rs
+++ b/src/app_impl/startup_new_tab.rs
@@ -181,12 +181,11 @@
                             {
                                 let query = this.filter_text.clone();
 
-                                // Clear filter text before switching view
-                                this.filter_text.clear();
-
                                 if has_shift {
-                                    this.show_script_generation_chat(Some(query), cx);
+                                    this.dispatch_ai_script_generation_from_query(query, cx);
                                 } else {
+                                    // Clear filter text before switching view
+                                    this.filter_text.clear();
                                     // Show inline AI chat with the query as initial input
                                     this.show_inline_ai_chat(Some(query), cx);
                                 }
diff --git a/src/main_sections/fallbacks.rs b/src/main_sections/fallbacks.rs
index 7742144684c5c00faffe448c3939b7b4517276bd..5b3881467e2ce686581f30b828f5d44849dcad56
--- a/src/main_sections/fallbacks.rs
+++ b/src/main_sections/fallbacks.rs
@@ -160,7 +160,7 @@
                         return;
                     };
 
-                    app.execute_builtin(&entry, cx);
+                    app.execute_builtin_with_query(&entry, Some(input), cx);
                 }
             }
         }


thinking
**Identifying test update needed**
exec
/bin/zsh -lc "sed -n '1,220p' src/app_impl/tests.rs" in /Users/johnlindquist/dev/script-kit-gpui succeeded in 50ms:
#[cfg(test)]
mod app_impl_state_sync_tests {
    use super::{calculate_fallback_error_message, ScriptListApp};
    use std::fs;

    #[test]
    fn test_sync_builtin_query_state_updates_query_and_selection_when_changed() {
        let mut query = String::from("old");
        let mut selected_index = 3;

        let changed =
            ScriptListApp::sync_builtin_query_state(&mut query, &mut selected_index, "new");

        assert!(changed);
        assert_eq!(query, "new");
        assert_eq!(selected_index, 0);
    }

    #[test]
    fn test_sync_builtin_query_state_noop_when_query_is_unchanged() {
file update:
diff --git a/src/app_execute/builtin_execution.rs b/src/app_execute/builtin_execution.rs
index dbce42e2664627892bed0da4fee92f6621cd2afd..9c0181eecf499492796afa9819219127d9c04de7
--- a/src/app_execute/builtin_execution.rs
+++ b/src/app_execute/builtin_execution.rs
@@ -122,6 +122,15 @@
     }
 
     fn execute_builtin(&mut self, entry: &builtins::BuiltInEntry, cx: &mut Context<Self>) {
+        self.execute_builtin_with_query(entry, None, cx);
+    }
+
+    fn execute_builtin_with_query(
+        &mut self,
+        entry: &builtins::BuiltInEntry,
+        query_override: Option<&str>,
+        cx: &mut Context<Self>,
+    ) {
         logging::log(
             "EXEC",
             &format!("Executing built-in: {} (id: {})", entry.name, entry.id),
@@ -1023,8 +1032,8 @@
                     }
 
                     AiCommandType::GenerateScript => {
-                        let query = self.filter_text.trim().to_string();
-                        self.show_script_generation_chat(Some(query), cx);
+                        let query = query_override.unwrap_or(&self.filter_text).to_string();
+                        self.dispatch_ai_script_generation_from_query(query, cx);
                     }
 
                     AiCommandType::SendScreenToAi => {
diff --git a/src/app_impl/prompt_ai.rs b/src/app_impl/prompt_ai.rs
index 6c10ca4234dc2d80bb14bc0d5163caddf97656cc..f79076d6b5977825788241f2ece9814c6754a4c6
--- a/src/app_impl/prompt_ai.rs
+++ b/src/app_impl/prompt_ai.rs
@@ -638,6 +638,24 @@
         cx.notify();
     }
 
+    pub(crate) fn dispatch_ai_script_generation_from_query(
+        &mut self,
+        query: String,
+        cx: &mut Context<Self>,
+    ) {
+        let query = query.trim().to_string();
+        if query.is_empty() {
+            logging::log(
+                "AI_SCRIPT_GEN",
+                "state=ignored attempted=dispatch_ai_script_generation_from_query reason=empty_query",
+            );
+            return;
+        }
+
+        self.filter_text.clear();
+        self.show_script_generation_chat(Some(query), cx);
+    }
+
     /// Generate a Script Kit script from a natural-language prompt using the built-in AI backend.
     /// The generated script is saved to disk and opened in the configured editor.
     pub fn generate_script_from_ai_prompt(
diff --git a/src/app_impl/selection_fallback.rs b/src/app_impl/selection_fallback.rs
index 9dcd609c870dcb8be976ed0dac0045ff196f31e3..8473dc467e6038b38319848a8da32f9997b36b36
--- a/src/app_impl/selection_fallback.rs
+++ b/src/app_impl/selection_fallback.rs
@@ -11,6 +11,16 @@
     }
 }
 
+fn fallback_keeps_window_open(fallback: &crate::fallbacks::FallbackItem) -> bool {
+    match fallback {
+        crate::fallbacks::FallbackItem::Builtin(builtin) => matches!(
+            builtin.id,
+            "run-in-terminal" | "search-files" | "builtin-generate-script-with-ai"
+        ),
+        crate::fallbacks::FallbackItem::Script(_) => true,
+    }
+}
+
 impl ScriptListApp {
     #[allow(dead_code)]
     pub(crate) fn filtered_scripts(&self) -> Vec<Arc<scripts::Script>> {
@@ -219,14 +229,7 @@
             ),
         );
 
-        // Check if this is a "stay open" action (like run-in-terminal which opens a view)
-        // Check if this is a "stay open" action (opens its own view)
-        let should_close = match fallback {
-            crate::fallbacks::FallbackItem::Builtin(builtin) => {
-                !matches!(builtin.id, "run-in-terminal" | "search-files")
-            }
-            crate::fallbacks::FallbackItem::Script(_) => false,
-        };
+        let should_close = !fallback_keeps_window_open(fallback);
 
         // Execute the fallback action
         match fallback {
@@ -260,13 +263,7 @@
         {
             logging::log("EXEC", &format!("Executing fallback: {}", fallback.name()));
 
-            // Check if this is a "stay open" action (opens its own view)
-            let should_close = match &fallback {
-                crate::fallbacks::FallbackItem::Builtin(builtin) => {
-                    !matches!(builtin.id, "run-in-terminal" | "search-files")
-                }
-                crate::fallbacks::FallbackItem::Script(_) => false,
-            };
+            let should_close = !fallback_keeps_window_open(&fallback);
 
             // Execute the fallback action
             match &fallback {
@@ -399,7 +396,7 @@
                         return;
                     };
 
-                    self.execute_builtin(&entry, cx);
+                    self.execute_builtin_with_query(&entry, Some(input), cx);
                 }
             },
             Err(e) => {
@@ -450,4 +447,28 @@
 
         assert_eq!(resolve_grouped_result_index(&grouped_items, 0), None);
     }
+
+    #[test]
+    fn test_fallback_keeps_window_open_for_generate_script_builtin() {
+        let fallback = crate::fallbacks::FallbackItem::Builtin(
+            crate::fallbacks::builtins::get_builtin_fallbacks()
+                .into_iter()
+                .find(|fallback| fallback.id == "builtin-generate-script-with-ai")
+                .expect("generate-script fallback should exist"),
+        );
+
+        assert!(fallback_keeps_window_open(&fallback));
+    }
+
+    #[test]
+    fn test_fallback_keeps_window_open_is_false_for_regular_builtin() {
+        let fallback = crate::fallbacks::FallbackItem::Builtin(
+            crate::fallbacks::builtins::get_builtin_fallbacks()
+                .into_iter()
+                .find(|fallback| fallback.id == "search-google")
+                .expect("search-google fallback should exist"),
+        );
+
+        assert!(!fallback_keeps_window_open(&fallback));
+    }
 }
diff --git a/src/app_impl/startup.rs b/src/app_impl/startup.rs
index 4fd4dc8c23d8df925c657b8db59f888b855ea6a2..670e087da31d4d0b4c8e21cebc48b3533817041f
--- a/src/app_impl/startup.rs
+++ b/src/app_impl/startup.rs
@@ -730,12 +730,11 @@
                             {
                                 let query = this.filter_text.clone();
 
-                                // Clear filter text before switching view
-                                this.filter_text.clear();
-
                                 if has_shift {
-                                    this.show_script_generation_chat(Some(query), cx);
+                                    this.dispatch_ai_script_generation_from_query(query, cx);
                                 } else {
+                                    // Clear filter text before switching view
+                                    this.filter_text.clear();
                                     // Show inline AI chat with the query as initial input
                                     this.show_inline_ai_chat(Some(query), cx);
                                 }
diff --git a/src/app_impl/startup_new_tab.rs b/src/app_impl/startup_new_tab.rs
index c75a27bf67a5448f59c7700079e8818210722bde..362ad2dcbf87a3a7e4476dcae211899dd788f079
--- a/src/app_impl/startup_new_tab.rs
+++ b/src/app_impl/startup_new_tab.rs
@@ -181,12 +181,11 @@
                             {
                                 let query = this.filter_text.clone();
 
-                                // Clear filter text before switching view
-                                this.filter_text.clear();
-
                                 if has_shift {
-                                    this.show_script_generation_chat(Some(query), cx);
+                                    this.dispatch_ai_script_generation_from_query(query, cx);
                                 } else {
+                                    // Clear filter text before switching view
+                                    this.filter_text.clear();
                                     // Show inline AI chat with the query as initial input
                                     this.show_inline_ai_chat(Some(query), cx);
                                 }
diff --git a/src/main_sections/fallbacks.rs b/src/main_sections/fallbacks.rs
index 7742144684c5c00faffe448c3939b7b4517276bd..5b3881467e2ce686581f30b828f5d44849dcad56
--- a/src/main_sections/fallbacks.rs
+++ b/src/main_sections/fallbacks.rs
@@ -160,7 +160,7 @@
                         return;
                     };
 
-                    app.execute_builtin(&entry, cx);
+                    app.execute_builtin_with_query(&entry, Some(input), cx);
                 }
             }
         }


thinking
**Adding test for builtin execution helper**
file update
M /Users/johnlindquist/dev/script-kit-gpui/src/app_impl/tests.rs
@@ -51,3 +51,3 @@
     #[test]
-    fn test_shift_tab_routes_to_ai_script_generation_in_script_list_tab_interceptor() {
+    fn test_shift_tab_routes_to_shared_ai_script_generation_handler() {
         let startup_tab = fs::read_to_string("src/app_impl/startup_new_tab.rs")
@@ -57,4 +57,4 @@
             startup_tab.contains("if has_shift")
-                && startup_tab.contains("this.generate_script_from_ai_prompt(query, cx);"),
-            "Shift+Tab in ScriptList should route to generate_script_from_ai_prompt. \
+                && startup_tab.contains("this.dispatch_ai_script_generation_from_query(query, cx);"),
+            "Shift+Tab in ScriptList should route to dispatch_ai_script_generation_from_query. \
              Missing expected branch in startup_new_tab.rs"
@@ -64,2 +64,13 @@
     #[test]
+    fn test_generate_script_builtin_routes_to_shared_ai_script_generation_handler() {
+        let builtin_execution = fs::read_to_string("src/app_execute/builtin_execution.rs")
+            .expect("Failed to read src/app_execute/builtin_execution.rs");
+
+        assert!(
+            builtin_execution.contains("self.dispatch_ai_script_generation_from_query(query, cx);"),
+            "Generate Script built-in should route to dispatch_ai_script_generation_from_query"
+        );
+    }
+
+    #[test]
     fn test_tab_still_routes_to_inline_ai_chat_in_script_list_tab_interceptor() {
apply_patch(auto_approved=true) exited 0 in 37ms:
Success. Updated the following files:
M src/app_impl/tests.rs
file update:
diff --git a/src/app_execute/builtin_execution.rs b/src/app_execute/builtin_execution.rs
index dbce42e2664627892bed0da4fee92f6621cd2afd..9c0181eecf499492796afa9819219127d9c04de7
--- a/src/app_execute/builtin_execution.rs
+++ b/src/app_execute/builtin_execution.rs
@@ -122,6 +122,15 @@
     }
 
     fn execute_builtin(&mut self, entry: &builtins::BuiltInEntry, cx: &mut Context<Self>) {
+        self.execute_builtin_with_query(entry, None, cx);
+    }
+
+    fn execute_builtin_with_query(
+        &mut self,
+        entry: &builtins::BuiltInEntry,
+        query_override: Option<&str>,
+        cx: &mut Context<Self>,
+    ) {
         logging::log(
             "EXEC",
             &format!("Executing built-in: {} (id: {})", entry.name, entry.id),
@@ -1023,8 +1032,8 @@
                     }
 
                     AiCommandType::GenerateScript => {
-                        let query = self.filter_text.trim().to_string();
-                        self.show_script_generation_chat(Some(query), cx);
+                        let query = query_override.unwrap_or(&self.filter_text).to_string();
+                        self.dispatch_ai_script_generation_from_query(query, cx);
                     }
 
                     AiCommandType::SendScreenToAi => {
diff --git a/src/app_impl/prompt_ai.rs b/src/app_impl/prompt_ai.rs
index 6c10ca4234dc2d80bb14bc0d5163caddf97656cc..f79076d6b5977825788241f2ece9814c6754a4c6
--- a/src/app_impl/prompt_ai.rs
+++ b/src/app_impl/prompt_ai.rs
@@ -638,6 +638,24 @@
         cx.notify();
     }
 
+    pub(crate) fn dispatch_ai_script_generation_from_query(
+        &mut self,
+        query: String,
+        cx: &mut Context<Self>,
+    ) {
+        let query = query.trim().to_string();
+        if query.is_empty() {
+            logging::log(
+                "AI_SCRIPT_GEN",
+                "state=ignored attempted=dispatch_ai_script_generation_from_query reason=empty_query",
+            );
+            return;
+        }
+
+        self.filter_text.clear();
+        self.show_script_generation_chat(Some(query), cx);
+    }
+
     /// Generate a Script Kit script from a natural-language prompt using the built-in AI backend.
     /// The generated script is saved to disk and opened in the configured editor.
     pub fn generate_script_from_ai_prompt(
diff --git a/src/app_impl/selection_fallback.rs b/src/app_impl/selection_fallback.rs
index 9dcd609c870dcb8be976ed0dac0045ff196f31e3..8473dc467e6038b38319848a8da32f9997b36b36
--- a/src/app_impl/selection_fallback.rs
+++ b/src/app_impl/selection_fallback.rs
@@ -11,6 +11,16 @@
     }
 }
 
+fn fallback_keeps_window_open(fallback: &crate::fallbacks::FallbackItem) -> bool {
+    match fallback {
+        crate::fallbacks::FallbackItem::Builtin(builtin) => matches!(
+            builtin.id,
+            "run-in-terminal" | "search-files" | "builtin-generate-script-with-ai"
+        ),
+        crate::fallbacks::FallbackItem::Script(_) => true,
+    }
+}
+
 impl ScriptListApp {
     #[allow(dead_code)]
     pub(crate) fn filtered_scripts(&self) -> Vec<Arc<scripts::Script>> {
@@ -219,14 +229,7 @@
             ),
         );
 
-        // Check if this is a "stay open" action (like run-in-terminal which opens a view)
-        // Check if this is a "stay open" action (opens its own view)
-        let should_close = match fallback {
-            crate::fallbacks::FallbackItem::Builtin(builtin) => {
-                !matches!(builtin.id, "run-in-terminal" | "search-files")
-            }
-            crate::fallbacks::FallbackItem::Script(_) => false,
-        };
+        let should_close = !fallback_keeps_window_open(fallback);
 
         // Execute the fallback action
         match fallback {
@@ -260,13 +263,7 @@
         {
             logging::log("EXEC", &format!("Executing fallback: {}", fallback.name()));
 
-            // Check if this is a "stay open" action (opens its own view)
-            let should_close = match &fallback {
-                crate::fallbacks::FallbackItem::Builtin(builtin) => {
-                    !matches!(builtin.id, "run-in-terminal" | "search-files")
-                }
-                crate::fallbacks::FallbackItem::Script(_) => false,
-            };
+            let should_close = !fallback_keeps_window_open(&fallback);
 
             // Execute the fallback action
             match &fallback {
@@ -399,7 +396,7 @@
                         return;
                     };
 
-                    self.execute_builtin(&entry, cx);
+                    self.execute_builtin_with_query(&entry, Some(input), cx);
                 }
             },
             Err(e) => {
@@ -450,4 +447,28 @@
 
         assert_eq!(resolve_grouped_result_index(&grouped_items, 0), None);
     }
+
+    #[test]
+    fn test_fallback_keeps_window_open_for_generate_script_builtin() {
+        let fallback = crate::fallbacks::FallbackItem::Builtin(
+            crate::fallbacks::builtins::get_builtin_fallbacks()
+                .into_iter()
+                .find(|fallback| fallback.id == "builtin-generate-script-with-ai")
+                .expect("generate-script fallback should exist"),
+        );
+
+        assert!(fallback_keeps_window_open(&fallback));
+    }
+
+    #[test]
+    fn test_fallback_keeps_window_open_is_false_for_regular_builtin() {
+        let fallback = crate::fallbacks::FallbackItem::Builtin(
+            crate::fallbacks::builtins::get_builtin_fallbacks()
+                .into_iter()
+                .find(|fallback| fallback.id == "search-google")
+                .expect("search-google fallback should exist"),
+        );
+
+        assert!(!fallback_keeps_window_open(&fallback));
+    }
 }
diff --git a/src/app_impl/startup.rs b/src/app_impl/startup.rs
index 4fd4dc8c23d8df925c657b8db59f888b855ea6a2..670e087da31d4d0b4c8e21cebc48b3533817041f
--- a/src/app_impl/startup.rs
+++ b/src/app_impl/startup.rs
@@ -730,12 +730,11 @@
                             {
                                 let query = this.filter_text.clone();
 
-                                // Clear filter text before switching view
-                                this.filter_text.clear();
-
                                 if has_shift {
-                                    this.show_script_generation_chat(Some(query), cx);
+                                    this.dispatch_ai_script_generation_from_query(query, cx);
                                 } else {
+                                    // Clear filter text before switching view
+                                    this.filter_text.clear();
                                     // Show inline AI chat with the query as initial input
                                     this.show_inline_ai_chat(Some(query), cx);
                                 }
diff --git a/src/app_impl/startup_new_tab.rs b/src/app_impl/startup_new_tab.rs
index c75a27bf67a5448f59c7700079e8818210722bde..362ad2dcbf87a3a7e4476dcae211899dd788f079
--- a/src/app_impl/startup_new_tab.rs
+++ b/src/app_impl/startup_new_tab.rs
@@ -181,12 +181,11 @@
                             {
                                 let query = this.filter_text.clone();
 
-                                // Clear filter text before switching view
-                                this.filter_text.clear();
-
                                 if has_shift {
-                                    this.show_script_generation_chat(Some(query), cx);
+                                    this.dispatch_ai_script_generation_from_query(query, cx);
                                 } else {
+                                    // Clear filter text before switching view
+                                    this.filter_text.clear();
                                     // Show inline AI chat with the query as initial input
                                     this.show_inline_ai_chat(Some(query), cx);
                                 }
diff --git a/src/app_impl/tests.rs b/src/app_impl/tests.rs
index 3f0fbd1ccbc2f1e3d515ac1edf9666035f09eaf4..8458f7cda5196dcf4ef3413b30efe4d33ce54c11
--- a/src/app_impl/tests.rs
+++ b/src/app_impl/tests.rs
@@ -49,19 +49,30 @@
     }
 
     #[test]
-    fn test_shift_tab_routes_to_ai_script_generation_in_script_list_tab_interceptor() {
+    fn test_shift_tab_routes_to_shared_ai_script_generation_handler() {
         let startup_tab = fs::read_to_string("src/app_impl/startup_new_tab.rs")
             .expect("Failed to read src/app_impl/startup_new_tab.rs");
 
         assert!(
             startup_tab.contains("if has_shift")
-                && startup_tab.contains("this.generate_script_from_ai_prompt(query, cx);"),
-            "Shift+Tab in ScriptList should route to generate_script_from_ai_prompt. \
+                && startup_tab.contains("this.dispatch_ai_script_generation_from_query(query, cx);"),
+            "Shift+Tab in ScriptList should route to dispatch_ai_script_generation_from_query. \
              Missing expected branch in startup_new_tab.rs"
         );
     }
 
     #[test]
+    fn test_generate_script_builtin_routes_to_shared_ai_script_generation_handler() {
+        let builtin_execution = fs::read_to_string("src/app_execute/builtin_execution.rs")
+            .expect("Failed to read src/app_execute/builtin_execution.rs");
+
+        assert!(
+            builtin_execution.contains("self.dispatch_ai_script_generation_from_query(query, cx);"),
+            "Generate Script built-in should route to dispatch_ai_script_generation_from_query"
+        );
+    }
+
+    #[test]
     fn test_tab_still_routes_to_inline_ai_chat_in_script_list_tab_interceptor() {
         let startup_tab = fs::read_to_string("src/app_impl/startup_new_tab.rs")
             .expect("Failed to read src/app_impl/startup_new_tab.rs");
diff --git a/src/main_sections/fallbacks.rs b/src/main_sections/fallbacks.rs
index 7742144684c5c00faffe448c3939b7b4517276bd..5b3881467e2ce686581f30b828f5d44849dcad56
--- a/src/main_sections/fallbacks.rs
+++ b/src/main_sections/fallbacks.rs
@@ -160,7 +160,7 @@
                         return;
                     };
 
-                    app.execute_builtin(&entry, cx);
+                    app.execute_builtin_with_query(&entry, Some(input), cx);
                 }
             }
         }

file update:
diff --git a/src/app_execute/builtin_execution.rs b/src/app_execute/builtin_execution.rs
index dbce42e2664627892bed0da4fee92f6621cd2afd..9c0181eecf499492796afa9819219127d9c04de7
--- a/src/app_execute/builtin_execution.rs
+++ b/src/app_execute/builtin_execution.rs
@@ -122,6 +122,15 @@
     }
 
     fn execute_builtin(&mut self, entry: &builtins::BuiltInEntry, cx: &mut Context<Self>) {
+        self.execute_builtin_with_query(entry, None, cx);
+    }
+
+    fn execute_builtin_with_query(
+        &mut self,
+        entry: &builtins::BuiltInEntry,
+        query_override: Option<&str>,
+        cx: &mut Context<Self>,
+    ) {
         logging::log(
             "EXEC",
             &format!("Executing built-in: {} (id: {})", entry.name, entry.id),
@@ -1023,8 +1032,8 @@
                     }
 
                     AiCommandType::GenerateScript => {
-                        let query = self.filter_text.trim().to_string();
-                        self.show_script_generation_chat(Some(query), cx);
+                        let query = query_override.unwrap_or(&self.filter_text).to_string();
+                        self.dispatch_ai_script_generation_from_query(query, cx);
                     }
 
                     AiCommandType::SendScreenToAi => {
diff --git a/src/app_impl/prompt_ai.rs b/src/app_impl/prompt_ai.rs
index 6c10ca4234dc2d80bb14bc0d5163caddf97656cc..f79076d6b5977825788241f2ece9814c6754a4c6
--- a/src/app_impl/prompt_ai.rs
+++ b/src/app_impl/prompt_ai.rs
@@ -638,6 +638,24 @@
         cx.notify();
     }
 
+    pub(crate) fn dispatch_ai_script_generation_from_query(
+        &mut self,
+        query: String,
+        cx: &mut Context<Self>,
+    ) {
+        let query = query.trim().to_string();
+        if query.is_empty() {
+            logging::log(
+                "AI_SCRIPT_GEN",
+                "state=ignored attempted=dispatch_ai_script_generation_from_query reason=empty_query",
+            );
+            return;
+        }
+
+        self.filter_text.clear();
+        self.show_script_generation_chat(Some(query), cx);
+    }
+
     /// Generate a Script Kit script from a natural-language prompt using the built-in AI backend.
     /// The generated script is saved to disk and opened in the configured editor.
     pub fn generate_script_from_ai_prompt(
diff --git a/src/app_impl/selection_fallback.rs b/src/app_impl/selection_fallback.rs
index 9dcd609c870dcb8be976ed0dac0045ff196f31e3..8473dc467e6038b38319848a8da32f9997b36b36
--- a/src/app_impl/selection_fallback.rs
+++ b/src/app_impl/selection_fallback.rs
@@ -11,6 +11,16 @@
     }
 }
 
+fn fallback_keeps_window_open(fallback: &crate::fallbacks::FallbackItem) -> bool {
+    match fallback {
+        crate::fallbacks::FallbackItem::Builtin(builtin) => matches!(
+            builtin.id,
+            "run-in-terminal" | "search-files" | "builtin-generate-script-with-ai"
+        ),
+        crate::fallbacks::FallbackItem::Script(_) => true,
+    }
+}
+
 impl ScriptListApp {
     #[allow(dead_code)]
     pub(crate) fn filtered_scripts(&self) -> Vec<Arc<scripts::Script>> {
@@ -219,14 +229,7 @@
             ),
         );
 
-        // Check if this is a "stay open" action (like run-in-terminal which opens a view)
-        // Check if this is a "stay open" action (opens its own view)
-        let should_close = match fallback {
-            crate::fallbacks::FallbackItem::Builtin(builtin) => {
-                !matches!(builtin.id, "run-in-terminal" | "search-files")
-            }
-            crate::fallbacks::FallbackItem::Script(_) => false,
-        };
+        let should_close = !fallback_keeps_window_open(fallback);
 
         // Execute the fallback action
         match fallback {
@@ -260,13 +263,7 @@
         {
             logging::log("EXEC", &format!("Executing fallback: {}", fallback.name()));
 
-            // Check if this is a "stay open" action (opens its own view)
-            let should_close = match &fallback {
-                crate::fallbacks::FallbackItem::Builtin(builtin) => {
-                    !matches!(builtin.id, "run-in-terminal" | "search-files")
-                }
-                crate::fallbacks::FallbackItem::Script(_) => false,
-            };
+            let should_close = !fallback_keeps_window_open(&fallback);
 
             // Execute the fallback action
             match &fallback {
@@ -399,7 +396,7 @@
                         return;
                     };
 
-                    self.execute_builtin(&entry, cx);
+                    self.execute_builtin_with_query(&entry, Some(input), cx);
                 }
             },
             Err(e) => {
@@ -450,4 +447,28 @@
 
         assert_eq!(resolve_grouped_result_index(&grouped_items, 0), None);
     }
+
+    #[test]
+    fn test_fallback_keeps_window_open_for_generate_script_builtin() {
+        let fallback = crate::fallbacks::FallbackItem::Builtin(
+            crate::fallbacks::builtins::get_builtin_fallbacks()
+                .into_iter()
+                .find(|fallback| fallback.id == "builtin-generate-script-with-ai")
+                .expect("generate-script fallback should exist"),
+        );
+
+        assert!(fallback_keeps_window_open(&fallback));
+    }
+
+    #[test]
+    fn test_fallback_keeps_window_open_is_false_for_regular_builtin() {
+        let fallback = crate::fallbacks::FallbackItem::Builtin(
+            crate::fallbacks::builtins::get_builtin_fallbacks()
+                .into_iter()
+                .find(|fallback| fallback.id == "search-google")
+                .expect("search-google fallback should exist"),
+        );
+
+        assert!(!fallback_keeps_window_open(&fallback));
+    }
 }
diff --git a/src/app_impl/startup.rs b/src/app_impl/startup.rs
index 4fd4dc8c23d8df925c657b8db59f888b855ea6a2..670e087da31d4d0b4c8e21cebc48b3533817041f
--- a/src/app_impl/startup.rs
+++ b/src/app_impl/startup.rs
@@ -730,12 +730,11 @@
                             {
                                 let query = this.filter_text.clone();
 
-                                // Clear filter text before switching view
-                                this.filter_text.clear();
-
                                 if has_shift {
-                                    this.show_script_generation_chat(Some(query), cx);
+                                    this.dispatch_ai_script_generation_from_query(query, cx);
                                 } else {
+                                    // Clear filter text before switching view
+                                    this.filter_text.clear();
                                     // Show inline AI chat with the query as initial input
                                     this.show_inline_ai_chat(Some(query), cx);
                                 }
diff --git a/src/app_impl/startup_new_tab.rs b/src/app_impl/startup_new_tab.rs
index c75a27bf67a5448f59c7700079e8818210722bde..362ad2dcbf87a3a7e4476dcae211899dd788f079
--- a/src/app_impl/startup_new_tab.rs
+++ b/src/app_impl/startup_new_tab.rs
@@ -181,12 +181,11 @@
                             {
                                 let query = this.filter_text.clone();
 
-                                // Clear filter text before switching view
-                                this.filter_text.clear();
-
                                 if has_shift {
-                                    this.show_script_generation_chat(Some(query), cx);
+                                    this.dispatch_ai_script_generation_from_query(query, cx);
                                 } else {
+                                    // Clear filter text before switching view
+                                    this.filter_text.clear();
                                     // Show inline AI chat with the query as initial input
                                     this.show_inline_ai_chat(Some(query), cx);
                                 }
diff --git a/src/app_impl/tests.rs b/src/app_impl/tests.rs
index 3f0fbd1ccbc2f1e3d515ac1edf9666035f09eaf4..8458f7cda5196dcf4ef3413b30efe4d33ce54c11
--- a/src/app_impl/tests.rs
+++ b/src/app_impl/tests.rs
@@ -49,19 +49,30 @@
     }
 
     #[test]
-    fn test_shift_tab_routes_to_ai_script_generation_in_script_list_tab_interceptor() {
+    fn test_shift_tab_routes_to_shared_ai_script_generation_handler() {
         let startup_tab = fs::read_to_string("src/app_impl/startup_new_tab.rs")
             .expect("Failed to read src/app_impl/startup_new_tab.rs");
 
         assert!(
             startup_tab.contains("if has_shift")
-                && startup_tab.contains("this.generate_script_from_ai_prompt(query, cx);"),
-            "Shift+Tab in ScriptList should route to generate_script_from_ai_prompt. \
+                && startup_tab.contains("this.dispatch_ai_script_generation_from_query(query, cx);"),
+            "Shift+Tab in ScriptList should route to dispatch_ai_script_generation_from_query. \
              Missing expected branch in startup_new_tab.rs"
         );
     }
 
     #[test]
+    fn test_generate_script_builtin_routes_to_shared_ai_script_generation_handler() {
+        let builtin_execution = fs::read_to_string("src/app_execute/builtin_execution.rs")
+            .expect("Failed to read src/app_execute/builtin_execution.rs");
+
+        assert!(
+            builtin_execution.contains("self.dispatch_ai_script_generation_from_query(query, cx);"),
+            "Generate Script built-in should route to dispatch_ai_script_generation_from_query"
+        );
+    }
+
+    #[test]
     fn test_tab_still_routes_to_inline_ai_chat_in_script_list_tab_interceptor() {
         let startup_tab = fs::read_to_string("src/app_impl/startup_new_tab.rs")
             .expect("Failed to read src/app_impl/startup_new_tab.rs");
diff --git a/src/main_sections/fallbacks.rs b/src/main_sections/fallbacks.rs
index 7742144684c5c00faffe448c3939b7b4517276bd..5b3881467e2ce686581f30b828f5d44849dcad56
--- a/src/main_sections/fallbacks.rs
+++ b/src/main_sections/fallbacks.rs
@@ -160,7 +160,7 @@
                         return;
                     };
 
-                    app.execute_builtin(&entry, cx);
+                    app.execute_builtin_with_query(&entry, Some(input), cx);
                 }
             }
         }

Reconnecting... 1/5 (stream disconnected before completion: websocket closed by server before response.completed)

thinking
**Assessing fallback compilation issues**
codex
Iâ€™ve applied the core wiring changes: Shift+Tab and the Generate Script built-in now route through one shared dispatch helper, fallback execution now forwards query text into built-in execution, and the generate-script fallback no longer auto-closes the window immediately. Iâ€™m running focused tests/checks for the touched modules next.

thinking
**Planning scoped Rust tests**
exec
/bin/zsh -lc 'cargo check -p script-kit-gpui' in /Users/johnlindquist/dev/script-kit-gpuifile update:
diff --git a/src/app_execute/builtin_execution.rs b/src/app_execute/builtin_execution.rs
index dbce42e2664627892bed0da4fee92f6621cd2afd..9c0181eecf499492796afa9819219127d9c04de7
--- a/src/app_execute/builtin_execution.rs
+++ b/src/app_execute/builtin_execution.rs
@@ -122,6 +122,15 @@
     }
 
     fn execute_builtin(&mut self, entry: &builtins::BuiltInEntry, cx: &mut Context<Self>) {
+        self.execute_builtin_with_query(entry, None, cx);
+    }
+
+    fn execute_builtin_with_query(
+        &mut self,
+        entry: &builtins::BuiltInEntry,
+        query_override: Option<&str>,
+        cx: &mut Context<Self>,
+    ) {
         logging::log(
             "EXEC",
             &format!("Executing built-in: {} (id: {})", entry.name, entry.id),
@@ -1023,8 +1032,8 @@
                     }
 
                     AiCommandType::GenerateScript => {
-                        let query = self.filter_text.trim().to_string();
-                        self.show_script_generation_chat(Some(query), cx);
+                        let query = query_override.unwrap_or(&self.filter_text).to_string();
+                        self.dispatch_ai_script_generation_from_query(query, cx);
                     }
 
                     AiCommandType::SendScreenToAi => {
diff --git a/src/app_impl/prompt_ai.rs b/src/app_impl/prompt_ai.rs
index 6c10ca4234dc2d80bb14bc0d5163caddf97656cc..f79076d6b5977825788241f2ece9814c6754a4c6
--- a/src/app_impl/prompt_ai.rs
+++ b/src/app_impl/prompt_ai.rs
@@ -638,6 +638,24 @@
         cx.notify();
     }
 
+    pub(crate) fn dispatch_ai_script_generation_from_query(
+        &mut self,
+        query: String,
+        cx: &mut Context<Self>,
+    ) {
+        let query = query.trim().to_string();
+        if query.is_empty() {
+            logging::log(
+                "AI_SCRIPT_GEN",
+                "state=ignored attempted=dispatch_ai_script_generation_from_query reason=empty_query",
+            );
+            return;
+        }
+
+        self.filter_text.clear();
+        self.show_script_generation_chat(Some(query), cx);
+    }
+
     /// Generate a Script Kit script from a natural-language prompt using the built-in AI backend.
     /// The generated script is saved to disk and opened in the configured editor.
     pub fn generate_script_from_ai_prompt(
diff --git a/src/app_impl/selection_fallback.rs b/src/app_impl/selection_fallback.rs
index 9dcd609c870dcb8be976ed0dac0045ff196f31e3..8473dc467e6038b38319848a8da32f9997b36b36
--- a/src/app_impl/selection_fallback.rs
+++ b/src/app_impl/selection_fallback.rs
@@ -11,6 +11,16 @@
     }
 }
 
+fn fallback_keeps_window_open(fallback: &crate::fallbacks::FallbackItem) -> bool {
+    match fallback {
+        crate::fallbacks::FallbackItem::Builtin(builtin) => matches!(
+            builtin.id,
+            "run-in-terminal" | "search-files" | "builtin-generate-script-with-ai"
+        ),
+        crate::fallbacks::FallbackItem::Script(_) => true,
+    }
+}
+
 impl ScriptListApp {
     #[allow(dead_code)]
     pub(crate) fn filtered_scripts(&self) -> Vec<Arc<scripts::Script>> {
@@ -219,14 +229,7 @@
             ),
         );
 
-        // Check if this is a "stay open" action (like run-in-terminal which opens a view)
-        // Check if this is a "stay open" action (opens its own view)
-        let should_close = match fallback {
-            crate::fallbacks::FallbackItem::Builtin(builtin) => {
-                !matches!(builtin.id, "run-in-terminal" | "search-files")
-            }
-            crate::fallbacks::FallbackItem::Script(_) => false,
-        };
+        let should_close = !fallback_keeps_window_open(fallback);
 
         // Execute the fallback action
         match fallback {
@@ -260,13 +263,7 @@
         {
             logging::log("EXEC", &format!("Executing fallback: {}", fallback.name()));
 
-            // Check if this is a "stay open" action (opens its own view)
-            let should_close = match &fallback {
-                crate::fallbacks::FallbackItem::Builtin(builtin) => {
-                    !matches!(builtin.id, "run-in-terminal" | "search-files")
-                }
-                crate::fallbacks::FallbackItem::Script(_) => false,
-            };
+            let should_close = !fallback_keeps_window_open(&fallback);
 
             // Execute the fallback action
             match &fallback {
@@ -399,7 +396,7 @@
                         return;
                     };
 
-                    self.execute_builtin(&entry, cx);
+                    self.execute_builtin_with_query(&entry, Some(input), cx);
                 }
             },
             Err(e) => {
@@ -450,4 +447,28 @@
 
         assert_eq!(resolve_grouped_result_index(&grouped_items, 0), None);
     }
+
+    #[test]
+    fn test_fallback_keeps_window_open_for_generate_script_builtin() {
+        let fallback = crate::fallbacks::FallbackItem::Builtin(
+            crate::fallbacks::builtins::get_builtin_fallbacks()
+                .into_iter()
+                .find(|fallback| fallback.id == "builtin-generate-script-with-ai")
+                .expect("generate-script fallback should exist"),
+        );
+
+        assert!(fallback_keeps_window_open(&fallback));
+    }
+
+    #[test]
+    fn test_fallback_keeps_window_open_is_false_for_regular_builtin() {
+        let fallback = crate::fallbacks::FallbackItem::Builtin(
+            crate::fallbacks::builtins::get_builtin_fallbacks()
+                .into_iter()
+                .find(|fallback| fallback.id == "search-google")
+                .expect("search-google fallback should exist"),
+        );
+
+        assert!(!fallback_keeps_window_open(&fallback));
+    }
 }
diff --git a/src/app_impl/startup.rs b/src/app_impl/startup.rs
index 4fd4dc8c23d8df925c657b8db59f888b855ea6a2..670e087da31d4d0b4c8e21cebc48b3533817041f
--- a/src/app_impl/startup.rs
+++ b/src/app_impl/startup.rs
@@ -730,12 +730,11 @@
                             {
                                 let query = this.filter_text.clone();
 
-                                // Clear filter text before switching view
-                                this.filter_text.clear();
-
                                 if has_shift {
-                                    this.show_script_generation_chat(Some(query), cx);
+                                    this.dispatch_ai_script_generation_from_query(query, cx);
                                 } else {
+                                    // Clear filter text before switching view
+                                    this.filter_text.clear();
                                     // Show inline AI chat with the query as initial input
                                     this.show_inline_ai_chat(Some(query), cx);
                                 }
diff --git a/src/app_impl/startup_new_tab.rs b/src/app_impl/startup_new_tab.rs
index c75a27bf67a5448f59c7700079e8818210722bde..362ad2dcbf87a3a7e4476dcae211899dd788f079
--- a/src/app_impl/startup_new_tab.rs
+++ b/src/app_impl/startup_new_tab.rs
@@ -181,12 +181,11 @@
                             {
                                 let query = this.filter_text.clone();
 
-                                // Clear filter text before switching view
-                                this.filter_text.clear();
-
                                 if has_shift {
-                                    this.show_script_generation_chat(Some(query), cx);
+                                    this.dispatch_ai_script_generation_from_query(query, cx);
                                 } else {
+                                    // Clear filter text before switching view
+                                    this.filter_text.clear();
                                     // Show inline AI chat with the query as initial input
                                     this.show_inline_ai_chat(Some(query), cx);
                                 }
diff --git a/src/app_impl/tests.rs b/src/app_impl/tests.rs
index 3f0fbd1ccbc2f1e3d515ac1edf9666035f09eaf4..8458f7cda5196dcf4ef3413b30efe4d33ce54c11
--- a/src/app_impl/tests.rs
+++ b/src/app_impl/tests.rs
@@ -49,19 +49,30 @@
     }
 
     #[test]
-    fn test_shift_tab_routes_to_ai_script_generation_in_script_list_tab_interceptor() {
+    fn test_shift_tab_routes_to_shared_ai_script_generation_handler() {
         let startup_tab = fs::read_to_string("src/app_impl/startup_new_tab.rs")
             .expect("Failed to read src/app_impl/startup_new_tab.rs");
 
         assert!(
             startup_tab.contains("if has_shift")
-                && startup_tab.contains("this.generate_script_from_ai_prompt(query, cx);"),
-            "Shift+Tab in ScriptList should route to generate_script_from_ai_prompt. \
+                && startup_tab.contains("this.dispatch_ai_script_generation_from_query(query, cx);"),
+            "Shift+Tab in ScriptList should route to dispatch_ai_script_generation_from_query. \
              Missing expected branch in startup_new_tab.rs"
         );
     }
 
     #[test]
+    fn test_generate_script_builtin_routes_to_shared_ai_script_generation_handler() {
+        let builtin_execution = fs::read_to_string("src/app_execute/builtin_execution.rs")
+            .expect("Failed to read src/app_execute/builtin_execution.rs");
+
+        assert!(
+            builtin_execution.contains("self.dispatch_ai_script_generation_from_query(query, cx);"),
+            "Generate Script built-in should route to dispatch_ai_script_generation_from_query"
+        );
+    }
+
+    #[test]
     fn test_tab_still_routes_to_inline_ai_chat_in_script_list_tab_interceptor() {
         let startup_tab = fs::read_to_string("src/app_impl/startup_new_tab.rs")
             .expect("Failed to read src/app_impl/startup_new_tab.rs");
diff --git a/src/main_sections/fallbacks.rs b/src/main_sections/fallbacks.rs
index 7742144684c5c00faffe448c3939b7b4517276bd..5b3881467e2ce686581f30b828f5d44849dcad56
--- a/src/main_sections/fallbacks.rs
+++ b/src/main_sections/fallbacks.rs
@@ -160,7 +160,7 @@
                         return;
                     };
 
-                    app.execute_builtin(&entry, cx);
+                    app.execute_builtin_with_query(&entry, Some(input), cx);
                 }
             }
         }


thinking
**Tracking process completion**
codex
Iâ€™m in verification now. `cargo check -p script-kit-gpui` is running; once it finishes Iâ€™ll run scoped clippy and targeted tests for the changed modules.
file update:
diff --git a/src/app_execute/builtin_execution.rs b/src/app_execute/builtin_execution.rs
index dbce42e2664627892bed0da4fee92f6621cd2afd..9c0181eecf499492796afa9819219127d9c04de7
--- a/src/app_execute/builtin_execution.rs
+++ b/src/app_execute/builtin_execution.rs
@@ -122,6 +122,15 @@
     }
 
     fn execute_builtin(&mut self, entry: &builtins::BuiltInEntry, cx: &mut Context<Self>) {
+        self.execute_builtin_with_query(entry, None, cx);
+    }
+
+    fn execute_builtin_with_query(
+        &mut self,
+        entry: &builtins::BuiltInEntry,
+        query_override: Option<&str>,
+        cx: &mut Context<Self>,
+    ) {
         logging::log(
             "EXEC",
             &format!("Executing built-in: {} (id: {})", entry.name, entry.id),
@@ -1023,8 +1032,8 @@
                     }
 
                     AiCommandType::GenerateScript => {
-                        let query = self.filter_text.trim().to_string();
-                        self.show_script_generation_chat(Some(query), cx);
+                        let query = query_override.unwrap_or(&self.filter_text).to_string();
+                        self.dispatch_ai_script_generation_from_query(query, cx);
                     }
 
                     AiCommandType::SendScreenToAi => {
diff --git a/src/app_impl/prompt_ai.rs b/src/app_impl/prompt_ai.rs
index 6c10ca4234dc2d80bb14bc0d5163caddf97656cc..f79076d6b5977825788241f2ece9814c6754a4c6
--- a/src/app_impl/prompt_ai.rs
+++ b/src/app_impl/prompt_ai.rs
@@ -638,6 +638,24 @@
         cx.notify();
     }
 
+    pub(crate) fn dispatch_ai_script_generation_from_query(
+        &mut self,
+        query: String,
+        cx: &mut Context<Self>,
+    ) {
+        let query = query.trim().to_string();
+        if query.is_empty() {
+            logging::log(
+                "AI_SCRIPT_GEN",
+                "state=ignored attempted=dispatch_ai_script_generation_from_query reason=empty_query",
+            );
+            return;
+        }
+
+        self.filter_text.clear();
+        self.show_script_generation_chat(Some(query), cx);
+    }
+
     /// Generate a Script Kit script from a natural-language prompt using the built-in AI backend.
     /// The generated script is saved to disk and opened in the configured editor.
     pub fn generate_script_from_ai_prompt(
diff --git a/src/app_impl/selection_fallback.rs b/src/app_impl/selection_fallback.rs
index 9dcd609c870dcb8be976ed0dac0045ff196f31e3..8473dc467e6038b38319848a8da32f9997b36b36
--- a/src/app_impl/selection_fallback.rs
+++ b/src/app_impl/selection_fallback.rs
@@ -11,6 +11,16 @@
     }
 }
 
+fn fallback_keeps_window_open(fallback: &crate::fallbacks::FallbackItem) -> bool {
+    match fallback {
+        crate::fallbacks::FallbackItem::Builtin(builtin) => matches!(
+            builtin.id,
+            "run-in-terminal" | "search-files" | "builtin-generate-script-with-ai"
+        ),
+        crate::fallbacks::FallbackItem::Script(_) => true,
+    }
+}
+
 impl ScriptListApp {
     #[allow(dead_code)]
     pub(crate) fn filtered_scripts(&self) -> Vec<Arc<scripts::Script>> {
@@ -219,14 +229,7 @@
             ),
         );
 
-        // Check if this is a "stay open" action (like run-in-terminal which opens a view)
-        // Check if this is a "stay open" action (opens its own view)
-        let should_close = match fallback {
-            crate::fallbacks::FallbackItem::Builtin(builtin) => {
-                !matches!(builtin.id, "run-in-terminal" | "search-files")
-            }
-            crate::fallbacks::FallbackItem::Script(_) => false,
-        };
+        let should_close = !fallback_keeps_window_open(fallback);
 
         // Execute the fallback action
         match fallback {
@@ -260,13 +263,7 @@
         {
             logging::log("EXEC", &format!("Executing fallback: {}", fallback.name()));
 
-            // Check if this is a "stay open" action (opens its own view)
-            let should_close = match &fallback {
-                crate::fallbacks::FallbackItem::Builtin(builtin) => {
-                    !matches!(builtin.id, "run-in-terminal" | "search-files")
-                }
-                crate::fallbacks::FallbackItem::Script(_) => false,
-            };
+            let should_close = !fallback_keeps_window_open(&fallback);
 
             // Execute the fallback action
             match &fallback {
@@ -399,7 +396,7 @@
                         return;
                     };
 
-                    self.execute_builtin(&entry, cx);
+                    self.execute_builtin_with_query(&entry, Some(input), cx);
                 }
             },
             Err(e) => {
@@ -450,4 +447,28 @@
 
         assert_eq!(resolve_grouped_result_index(&grouped_items, 0), None);
     }
+
+    #[test]
+    fn test_fallback_keeps_window_open_for_generate_script_builtin() {
+        let fallback = crate::fallbacks::FallbackItem::Builtin(
+            crate::fallbacks::builtins::get_builtin_fallbacks()
+                .into_iter()
+                .find(|fallback| fallback.id == "builtin-generate-script-with-ai")
+                .expect("generate-script fallback should exist"),
+        );
+
+        assert!(fallback_keeps_window_open(&fallback));
+    }
+
+    #[test]
+    fn test_fallback_keeps_window_open_is_false_for_regular_builtin() {
+        let fallback = crate::fallbacks::FallbackItem::Builtin(
+            crate::fallbacks::builtins::get_builtin_fallbacks()
+                .into_iter()
+                .find(|fallback| fallback.id == "search-google")
+                .expect("search-google fallback should exist"),
+        );
+
+        assert!(!fallback_keeps_window_open(&fallback));
+    }
 }
diff --git a/src/app_impl/startup.rs b/src/app_impl/startup.rs
index 4fd4dc8c23d8df925c657b8db59f888b855ea6a2..670e087da31d4d0b4c8e21cebc48b3533817041f
--- a/src/app_impl/startup.rs
+++ b/src/app_impl/startup.rs
@@ -730,12 +730,11 @@
                             {
                                 let query = this.filter_text.clone();
 
-                                // Clear filter text before switching view
-                                this.filter_text.clear();
-
                                 if has_shift {
-                                    this.show_script_generation_chat(Some(query), cx);
+                                    this.dispatch_ai_script_generation_from_query(query, cx);
                                 } else {
+                                    // Clear filter text before switching view
+                                    this.filter_text.clear();
                                     // Show inline AI chat with the query as initial input
                                     this.show_inline_ai_chat(Some(query), cx);
                                 }
diff --git a/src/app_impl/startup_new_tab.rs b/src/app_impl/startup_new_tab.rs
index c75a27bf67a5448f59c7700079e8818210722bde..362ad2dcbf87a3a7e4476dcae211899dd788f079
--- a/src/app_impl/startup_new_tab.rs
+++ b/src/app_impl/startup_new_tab.rs
@@ -181,12 +181,11 @@
                             {
                                 let query = this.filter_text.clone();
 
-                                // Clear filter text before switching view
-                                this.filter_text.clear();
-
                                 if has_shift {
-                                    this.show_script_generation_chat(Some(query), cx);
+                                    this.dispatch_ai_script_generation_from_query(query, cx);
                                 } else {
+                                    // Clear filter text before switching view
+                                    this.filter_text.clear();
                                     // Show inline AI chat with the query as initial input
                                     this.show_inline_ai_chat(Some(query), cx);
                                 }
diff --git a/src/app_impl/tests.rs b/src/app_impl/tests.rs
index 3f0fbd1ccbc2f1e3d515ac1edf9666035f09eaf4..8458f7cda5196dcf4ef3413b30efe4d33ce54c11
--- a/src/app_impl/tests.rs
+++ b/src/app_impl/tests.rs
@@ -49,19 +49,30 @@
     }
 
     #[test]
-    fn test_shift_tab_routes_to_ai_script_generation_in_script_list_tab_interceptor() {
+    fn test_shift_tab_routes_to_shared_ai_script_generation_handler() {
         let startup_tab = fs::read_to_string("src/app_impl/startup_new_tab.rs")
             .expect("Failed to read src/app_impl/startup_new_tab.rs");
 
         assert!(
             startup_tab.contains("if has_shift")
-                && startup_tab.contains("this.generate_script_from_ai_prompt(query, cx);"),
-            "Shift+Tab in ScriptList should route to generate_script_from_ai_prompt. \
+                && startup_tab.contains("this.dispatch_ai_script_generation_from_query(query, cx);"),
+            "Shift+Tab in ScriptList should route to dispatch_ai_script_generation_from_query. \
              Missing expected branch in startup_new_tab.rs"
         );
     }
 
     #[test]
+    fn test_generate_script_builtin_routes_to_shared_ai_script_generation_handler() {
+        let builtin_execution = fs::read_to_string("src/app_execute/builtin_execution.rs")
+            .expect("Failed to read src/app_execute/builtin_execution.rs");
+
+        assert!(
+            builtin_execution.contains("self.dispatch_ai_script_generation_from_query(query, cx);"),
+            "Generate Script built-in should route to dispatch_ai_script_generation_from_query"
+        );
+    }
+
+    #[test]
     fn test_tab_still_routes_to_inline_ai_chat_in_script_list_tab_interceptor() {
         let startup_tab = fs::read_to_string("src/app_impl/startup_new_tab.rs")
             .expect("Failed to read src/app_impl/startup_new_tab.rs");
diff --git a/src/main_sections/fallbacks.rs b/src/main_sections/fallbacks.rs
index 7742144684c5c00faffe448c3939b7b4517276bd..5b3881467e2ce686581f30b828f5d44849dcad56
--- a/src/main_sections/fallbacks.rs
+++ b/src/main_sections/fallbacks.rs
@@ -160,7 +160,7 @@
                         return;
                     };
 
-                    app.execute_builtin(&entry, cx);
+                    app.execute_builtin_with_query(&entry, Some(input), cx);
                 }
             }
         }

 succeeded in 6.33s:
    Checking script-kit-gpui v0.1.0 (/Users/johnlindquist/dev/script-kit-gpui)
warning: glob import doesn't reexport anything with visibility `pub(in crate::prompts)` because no imported item is public enough
  --> src/prompts/div/mod.rs:32:16
   |
32 | pub(super) use inline::*;
   |                ^^^^^^^^^
   |
note: the most public imported item is `pub(self)`
  --> src/prompts/div/mod.rs:32:16
   |
32 | pub(super) use inline::*;
   |                ^^^^^^^^^
   = help: reduce the glob import's visibility or increase visibility of imported items
   = note: `#[warn(unused_imports)]` (part of `#[warn(unused)]`) on by default

warning: glob import doesn't reexport anything with visibility `pub(in crate::prompts)` because no imported item is public enough
  --> src/prompts/div/mod.rs:34:16
   |
34 | pub(super) use render_html::*;
   |                ^^^^^^^^^^^^^^

thinking
**Scoping tests due to clippy warnings**
exec
/bin/zsh -lc 'cargo test -p script-kit-gpui app_impl_state_sync_tests::' in /Users/johnlindquist/dev/script-kit-gpuifile update:
diff --git a/src/app_execute/builtin_execution.rs b/src/app_execute/builtin_execution.rs
index dbce42e2664627892bed0da4fee92f6621cd2afd..9c0181eecf499492796afa9819219127d9c04de7
--- a/src/app_execute/builtin_execution.rs
+++ b/src/app_execute/builtin_execution.rs
@@ -122,6 +122,15 @@
     }
 
     fn execute_builtin(&mut self, entry: &builtins::BuiltInEntry, cx: &mut Context<Self>) {
+        self.execute_builtin_with_query(entry, None, cx);
+    }
+
+    fn execute_builtin_with_query(
+        &mut self,
+        entry: &builtins::BuiltInEntry,
+        query_override: Option<&str>,
+        cx: &mut Context<Self>,
+    ) {
         logging::log(
             "EXEC",
             &format!("Executing built-in: {} (id: {})", entry.name, entry.id),
@@ -1023,8 +1032,8 @@
                     }
 
                     AiCommandType::GenerateScript => {
-                        let query = self.filter_text.trim().to_string();
-                        self.show_script_generation_chat(Some(query), cx);
+                        let query = query_override.unwrap_or(&self.filter_text).to_string();
+                        self.dispatch_ai_script_generation_from_query(query, cx);
                     }
 
                     AiCommandType::SendScreenToAi => {
diff --git a/src/app_impl/prompt_ai.rs b/src/app_impl/prompt_ai.rs
index 6c10ca4234dc2d80bb14bc0d5163caddf97656cc..f79076d6b5977825788241f2ece9814c6754a4c6
--- a/src/app_impl/prompt_ai.rs
+++ b/src/app_impl/prompt_ai.rs
@@ -638,6 +638,24 @@
         cx.notify();
     }
 
+    pub(crate) fn dispatch_ai_script_generation_from_query(
+        &mut self,
+        query: String,
+        cx: &mut Context<Self>,
+    ) {
+        let query = query.trim().to_string();
+        if query.is_empty() {
+            logging::log(
+                "AI_SCRIPT_GEN",
+                "state=ignored attempted=dispatch_ai_script_generation_from_query reason=empty_query",
+            );
+            return;
+        }
+
+        self.filter_text.clear();
+        self.show_script_generation_chat(Some(query), cx);
+    }
+
     /// Generate a Script Kit script from a natural-language prompt using the built-in AI backend.
     /// The generated script is saved to disk and opened in the configured editor.
     pub fn generate_script_from_ai_prompt(
diff --git a/src/app_impl/selection_fallback.rs b/src/app_impl/selection_fallback.rs
index 9dcd609c870dcb8be976ed0dac0045ff196f31e3..8473dc467e6038b38319848a8da32f9997b36b36
--- a/src/app_impl/selection_fallback.rs
+++ b/src/app_impl/selection_fallback.rs
@@ -11,6 +11,16 @@
     }
 }
 
+fn fallback_keeps_window_open(fallback: &crate::fallbacks::FallbackItem) -> bool {
+    match fallback {
+        crate::fallbacks::FallbackItem::Builtin(builtin) => matches!(
+            builtin.id,
+            "run-in-terminal" | "search-files" | "builtin-generate-script-with-ai"
+        ),
+        crate::fallbacks::FallbackItem::Script(_) => true,
+    }
+}
+
 impl ScriptListApp {
     #[allow(dead_code)]
     pub(crate) fn filtered_scripts(&self) -> Vec<Arc<scripts::Script>> {
@@ -219,14 +229,7 @@
             ),
         );
 
-        // Check if this is a "stay open" action (like run-in-terminal which opens a view)
-        // Check if this is a "stay open" action (opens its own view)
-        let should_close = match fallback {
-            crate::fallbacks::FallbackItem::Builtin(builtin) => {
-                !matches!(builtin.id, "run-in-terminal" | "search-files")
-            }
-            crate::fallbacks::FallbackItem::Script(_) => false,
-        };
+        let should_close = !fallback_keeps_window_open(fallback);
 
         // Execute the fallback action
         match fallback {
@@ -260,13 +263,7 @@
         {
             logging::log("EXEC", &format!("Executing fallback: {}", fallback.name()));
 
-            // Check if this is a "stay open" action (opens its own view)
-            let should_close = match &fallback {
-                crate::fallbacks::FallbackItem::Builtin(builtin) => {
-                    !matches!(builtin.id, "run-in-terminal" | "search-files")
-                }
-                crate::fallbacks::FallbackItem::Script(_) => false,
-            };
+            let should_close = !fallback_keeps_window_open(&fallback);
 
             // Execute the fallback action
             match &fallback {
@@ -399,7 +396,7 @@
                         return;
                     };
 
-                    self.execute_builtin(&entry, cx);
+                    self.execute_builtin_with_query(&entry, Some(input), cx);
                 }
             },
             Err(e) => {
@@ -450,4 +447,28 @@
 
         assert_eq!(resolve_grouped_result_index(&grouped_items, 0), None);
     }
+
+    #[test]
+    fn test_fallback_keeps_window_open_for_generate_script_builtin() {
+        let fallback = crate::fallbacks::FallbackItem::Builtin(
+            crate::fallbacks::builtins::get_builtin_fallbacks()
+                .into_iter()
+                .find(|fallback| fallback.id == "builtin-generate-script-with-ai")
+                .expect("generate-script fallback should exist"),
+        );
+
+        assert!(fallback_keeps_window_open(&fallback));
+    }
+
+    #[test]
+    fn test_fallback_keeps_window_open_is_false_for_regular_builtin() {
+        let fallback = crate::fallbacks::FallbackItem::Builtin(
+            crate::fallbacks::builtins::get_builtin_fallbacks()
+                .into_iter()
+                .find(|fallback| fallback.id == "search-google")
+                .expect("search-google fallback should exist"),
+        );
+
+        assert!(!fallback_keeps_window_open(&fallback));
+    }
 }
diff --git a/src/app_impl/startup.rs b/src/app_impl/startup.rs
index 4fd4dc8c23d8df925c657b8db59f888b855ea6a2..670e087da31d4d0b4c8e21cebc48b3533817041f
--- a/src/app_impl/startup.rs
+++ b/src/app_impl/startup.rs
@@ -730,12 +730,11 @@
                             {
                                 let query = this.filter_text.clone();
 
-                                // Clear filter text before switching view
-                                this.filter_text.clear();
-
                                 if has_shift {
-                                    this.show_script_generation_chat(Some(query), cx);
+                                    this.dispatch_ai_script_generation_from_query(query, cx);
                                 } else {
+                                    // Clear filter text before switching view
+                                    this.filter_text.clear();
                                     // Show inline AI chat with the query as initial input
                                     this.show_inline_ai_chat(Some(query), cx);
                                 }
diff --git a/src/app_impl/startup_new_tab.rs b/src/app_impl/startup_new_tab.rs
index c75a27bf67a5448f59c7700079e8818210722bde..362ad2dcbf87a3a7e4476dcae211899dd788f079
--- a/src/app_impl/startup_new_tab.rs
+++ b/src/app_impl/startup_new_tab.rs
@@ -181,12 +181,11 @@
                             {
                                 let query = this.filter_text.clone();
 
-                                // Clear filter text before switching view
-                                this.filter_text.clear();
-
                                 if has_shift {
-                                    this.show_script_generation_chat(Some(query), cx);
+                                    this.dispatch_ai_script_generation_from_query(query, cx);
                                 } else {
+                                    // Clear filter text before switching view
+                                    this.filter_text.clear();
                                     // Show inline AI chat with the query as initial input
                                     this.show_inline_ai_chat(Some(query), cx);
                                 }
diff --git a/src/app_impl/tests.rs b/src/app_impl/tests.rs
index 3f0fbd1ccbc2f1e3d515ac1edf9666035f09eaf4..8458f7cda5196dcf4ef3413b30efe4d33ce54c11
--- a/src/app_impl/tests.rs
+++ b/src/app_impl/tests.rs
@@ -49,19 +49,30 @@
     }
 
     #[test]
-    fn test_shift_tab_routes_to_ai_script_generation_in_script_list_tab_interceptor() {
+    fn test_shift_tab_routes_to_shared_ai_script_generation_handler() {
         let startup_tab = fs::read_to_string("src/app_impl/startup_new_tab.rs")
             .expect("Failed to read src/app_impl/startup_new_tab.rs");
 
         assert!(
             startup_tab.contains("if has_shift")
-                && startup_tab.contains("this.generate_script_from_ai_prompt(query, cx);"),
-            "Shift+Tab in ScriptList should route to generate_script_from_ai_prompt. \
+                && startup_tab.contains("this.dispatch_ai_script_generation_from_query(query, cx);"),
+            "Shift+Tab in ScriptList should route to dispatch_ai_script_generation_from_query. \
              Missing expected branch in startup_new_tab.rs"
         );
     }
 
     #[test]
+    fn test_generate_script_builtin_routes_to_shared_ai_script_generation_handler() {
+        let builtin_execution = fs::read_to_string("src/app_execute/builtin_execution.rs")
+            .expect("Failed to read src/app_execute/builtin_execution.rs");
+
+        assert!(
+            builtin_execution.contains("self.dispatch_ai_script_generation_from_query(query, cx);"),
+            "Generate Script built-in should route to dispatch_ai_script_generation_from_query"
+        );
+    }
+
+    #[test]
     fn test_tab_still_routes_to_inline_ai_chat_in_script_list_tab_interceptor() {
         let startup_tab = fs::read_to_string("src/app_impl/startup_new_tab.rs")
             .expect("Failed to read src/app_impl/startup_new_tab.rs");
diff --git a/src/main_sections/fallbacks.rs b/src/main_sections/fallbacks.rs
index 7742144684c5c00faffe448c3939b7b4517276bd..5b3881467e2ce686581f30b828f5d44849dcad56
--- a/src/main_sections/fallbacks.rs
+++ b/src/main_sections/fallbacks.rs
@@ -160,7 +160,7 @@
                         return;
                     };
 
-                    app.execute_builtin(&entry, cx);
+                    app.execute_builtin_with_query(&entry, Some(input), cx);
                 }
             }
         }


thinking
**Isolating test scope amid conflicts**
exec
/bin/zsh -lc 'cargo test -p script-kit-gpui --lib app_impl_state_sync_tests::' in /Users/johnlindquist/dev/script-kit-gpuifile update:
diff --git a/src/app_execute/builtin_execution.rs b/src/app_execute/builtin_execution.rs
index dbce42e2664627892bed0da4fee92f6621cd2afd..9c0181eecf499492796afa9819219127d9c04de7
--- a/src/app_execute/builtin_execution.rs
+++ b/src/app_execute/builtin_execution.rs
@@ -122,6 +122,15 @@
     }
 
     fn execute_builtin(&mut self, entry: &builtins::BuiltInEntry, cx: &mut Context<Self>) {
+        self.execute_builtin_with_query(entry, None, cx);
+    }
+
+    fn execute_builtin_with_query(
+        &mut self,
+        entry: &builtins::BuiltInEntry,
+        query_override: Option<&str>,
+        cx: &mut Context<Self>,
+    ) {
         logging::log(
             "EXEC",
             &format!("Executing built-in: {} (id: {})", entry.name, entry.id),
@@ -1023,8 +1032,8 @@
                     }
 
                     AiCommandType::GenerateScript => {
-                        let query = self.filter_text.trim().to_string();
-                        self.show_script_generation_chat(Some(query), cx);
+                        let query = query_override.unwrap_or(&self.filter_text).to_string();
+                        self.dispatch_ai_script_generation_from_query(query, cx);
                     }
 
                     AiCommandType::SendScreenToAi => {
diff --git a/src/app_impl/prompt_ai.rs b/src/app_impl/prompt_ai.rs
index 6c10ca4234dc2d80bb14bc0d5163caddf97656cc..f79076d6b5977825788241f2ece9814c6754a4c6
--- a/src/app_impl/prompt_ai.rs
+++ b/src/app_impl/prompt_ai.rs
@@ -638,6 +638,24 @@
         cx.notify();
     }
 
+    pub(crate) fn dispatch_ai_script_generation_from_query(
+        &mut self,
+        query: String,
+        cx: &mut Context<Self>,
+    ) {
+        let query = query.trim().to_string();
+        if query.is_empty() {
+            logging::log(
+                "AI_SCRIPT_GEN",
+                "state=ignored attempted=dispatch_ai_script_generation_from_query reason=empty_query",
+            );
+            return;
+        }
+
+        self.filter_text.clear();
+        self.show_script_generation_chat(Some(query), cx);
+    }
+
     /// Generate a Script Kit script from a natural-language prompt using the built-in AI backend.
     /// The generated script is saved to disk and opened in the configured editor.
     pub fn generate_script_from_ai_prompt(
diff --git a/src/app_impl/selection_fallback.rs b/src/app_impl/selection_fallback.rs
index 9dcd609c870dcb8be976ed0dac0045ff196f31e3..8473dc467e6038b38319848a8da32f9997b36b36
--- a/src/app_impl/selection_fallback.rs
+++ b/src/app_impl/selection_fallback.rs
@@ -11,6 +11,16 @@
     }
 }
 
+fn fallback_keeps_window_open(fallback: &crate::fallbacks::FallbackItem) -> bool {
+    match fallback {
+        crate::fallbacks::FallbackItem::Builtin(builtin) => matches!(
+            builtin.id,
+            "run-in-terminal" | "search-files" | "builtin-generate-script-with-ai"
+        ),
+        crate::fallbacks::FallbackItem::Script(_) => true,
+    }
+}
+
 impl ScriptListApp {
     #[allow(dead_code)]
     pub(crate) fn filtered_scripts(&self) -> Vec<Arc<scripts::Script>> {
@@ -219,14 +229,7 @@
             ),
         );
 
-        // Check if this is a "stay open" action (like run-in-terminal which opens a view)
-        // Check if this is a "stay open" action (opens its own view)
-        let should_close = match fallback {
-            crate::fallbacks::FallbackItem::Builtin(builtin) => {
-                !matches!(builtin.id, "run-in-terminal" | "search-files")
-            }
-            crate::fallbacks::FallbackItem::Script(_) => false,
-        };
+        let should_close = !fallback_keeps_window_open(fallback);
 
         // Execute the fallback action
         match fallback {
@@ -260,13 +263,7 @@
         {
             logging::log("EXEC", &format!("Executing fallback: {}", fallback.name()));
 
-            // Check if this is a "stay open" action (opens its own view)
-            let should_close = match &fallback {
-                crate::fallbacks::FallbackItem::Builtin(builtin) => {
-                    !matches!(builtin.id, "run-in-terminal" | "search-files")
-                }
-                crate::fallbacks::FallbackItem::Script(_) => false,
-            };
+            let should_close = !fallback_keeps_window_open(&fallback);
 
             // Execute the fallback action
             match &fallback {
@@ -399,7 +396,7 @@
                         return;
                     };
 
-                    self.execute_builtin(&entry, cx);
+                    self.execute_builtin_with_query(&entry, Some(input), cx);
                 }
             },
             Err(e) => {
@@ -450,4 +447,28 @@
 
         assert_eq!(resolve_grouped_result_index(&grouped_items, 0), None);
     }
+
+    #[test]
+    fn test_fallback_keeps_window_open_for_generate_script_builtin() {
+        let fallback = crate::fallbacks::FallbackItem::Builtin(
+            crate::fallbacks::builtins::get_builtin_fallbacks()
+                .into_iter()
+                .find(|fallback| fallback.id == "builtin-generate-script-with-ai")
+                .expect("generate-script fallback should exist"),
+        );
+
+        assert!(fallback_keeps_window_open(&fallback));
+    }
+
+    #[test]
+    fn test_fallback_keeps_window_open_is_false_for_regular_builtin() {
+        let fallback = crate::fallbacks::FallbackItem::Builtin(
+            crate::fallbacks::builtins::get_builtin_fallbacks()
+                .into_iter()
+                .find(|fallback| fallback.id == "search-google")
+                .expect("search-google fallback should exist"),
+        );
+
+        assert!(!fallback_keeps_window_open(&fallback));
+    }
 }
diff --git a/src/app_impl/startup.rs b/src/app_impl/startup.rs
index 4fd4dc8c23d8df925c657b8db59f888b855ea6a2..670e087da31d4d0b4c8e21cebc48b3533817041f
--- a/src/app_impl/startup.rs
+++ b/src/app_impl/startup.rs
@@ -730,12 +730,11 @@
                             {
                                 let query = this.filter_text.clone();
 
-                                // Clear filter text before switching view
-                                this.filter_text.clear();
-
                                 if has_shift {
-                                    this.show_script_generation_chat(Some(query), cx);
+                                    this.dispatch_ai_script_generation_from_query(query, cx);
                                 } else {
+                                    // Clear filter text before switching view
+                                    this.filter_text.clear();
                                     // Show inline AI chat with the query as initial input
                                     this.show_inline_ai_chat(Some(query), cx);
                                 }
diff --git a/src/app_impl/startup_new_tab.rs b/src/app_impl/startup_new_tab.rs
index c75a27bf67a5448f59c7700079e8818210722bde..362ad2dcbf87a3a7e4476dcae211899dd788f079
--- a/src/app_impl/startup_new_tab.rs
+++ b/src/app_impl/startup_new_tab.rs
@@ -181,12 +181,11 @@
                             {
                                 let query = this.filter_text.clone();
 
-                                // Clear filter text before switching view
-                                this.filter_text.clear();
-
                                 if has_shift {
-                                    this.show_script_generation_chat(Some(query), cx);
+                                    this.dispatch_ai_script_generation_from_query(query, cx);
                                 } else {
+                                    // Clear filter text before switching view
+                                    this.filter_text.clear();
                                     // Show inline AI chat with the query as initial input
                                     this.show_inline_ai_chat(Some(query), cx);
                                 }
diff --git a/src/app_impl/tests.rs b/src/app_impl/tests.rs
index 3f0fbd1ccbc2f1e3d515ac1edf9666035f09eaf4..8458f7cda5196dcf4ef3413b30efe4d33ce54c11
--- a/src/app_impl/tests.rs
+++ b/src/app_impl/tests.rs
@@ -49,19 +49,30 @@
     }
 
     #[test]
-    fn test_shift_tab_routes_to_ai_script_generation_in_script_list_tab_interceptor() {
+    fn test_shift_tab_routes_to_shared_ai_script_generation_handler() {
         let startup_tab = fs::read_to_string("src/app_impl/startup_new_tab.rs")
             .expect("Failed to read src/app_impl/startup_new_tab.rs");
 
         assert!(
             startup_tab.contains("if has_shift")
-                && startup_tab.contains("this.generate_script_from_ai_prompt(query, cx);"),
-            "Shift+Tab in ScriptList should route to generate_script_from_ai_prompt. \
+                && startup_tab.contains("this.dispatch_ai_script_generation_from_query(query, cx);"),
+            "Shift+Tab in ScriptList should route to dispatch_ai_script_generation_from_query. \
              Missing expected branch in startup_new_tab.rs"
         );
     }
 
     #[test]
+    fn test_generate_script_builtin_routes_to_shared_ai_script_generation_handler() {
+        let builtin_execution = fs::read_to_string("src/app_execute/builtin_execution.rs")
+            .expect("Failed to read src/app_execute/builtin_execution.rs");
+
+        assert!(
+            builtin_execution.contains("self.dispatch_ai_script_generation_from_query(query, cx);"),
+            "Generate Script built-in should route to dispatch_ai_script_generation_from_query"
+        );
+    }
+
+    #[test]
     fn test_tab_still_routes_to_inline_ai_chat_in_script_list_tab_interceptor() {
         let startup_tab = fs::read_to_string("src/app_impl/startup_new_tab.rs")
             .expect("Failed to read src/app_impl/startup_new_tab.rs");
diff --git a/src/main_sections/fallbacks.rs b/src/main_sections/fallbacks.rs
index 7742144684c5c00faffe448c3939b7b4517276bd..5b3881467e2ce686581f30b828f5d44849dcad56
--- a/src/main_sections/fallbacks.rs
+++ b/src/main_sections/fallbacks.rs
@@ -160,7 +160,7 @@
                         return;
                     };
 
-                    app.execute_builtin(&entry, cx);
+                    app.execute_builtin_with_query(&entry, Some(input), cx);
                 }
             }
         }


thinking
**Identifying potential leftover compile lock impacting session**
codex
The first targeted test run hit an unrelated compile conflict in another area (`src/protocol/message/tests.rs` vs `src/protocol/message/tests/mod.rs`). Iâ€™m retrying with `--lib` scoping to isolate our module tests from that parallel-agent churn.
 exited 101 in 18.91s:
warning: glob import doesn't reexport anything with visibility `pub(in crate::prompts)` because no imported item is public enough
  --> src/prompts/div/mod.rs:32:16
   |
32 | pub(super) use inline::*;
   |                ^^^^^^^^^
   |
note: the most public imported item is `pub(self)`
  --> src/prompts/div/mod.rs:32:16
   |
32 | pub(super) use inline::*;
   |                ^^^^^^^^^
   = help: reduce the glob import's visibility or increase visibility of imported items
   = note: `#[warn(unused_imports)]` (part of `#[warn(unused)]`) on by default

warning: glob import doesn't reexport anything with visibility `pub(in crate::prompts)` because no imported item is public enough
  --> src/prompts/div/mod.rs:34:16
   |
34 | pub(super) use render_html::*;
   |                ^^^^^^^^^^^^^^
   |
file update:
diff --git a/src/app_execute/builtin_execution.rs b/src/app_execute/builtin_execution.rs
index dbce42e2664627892bed0da4fee92f6621cd2afd..9c0181eecf499492796afa9819219127d9c04de7
--- a/src/app_execute/builtin_execution.rs
+++ b/src/app_execute/builtin_execution.rs
@@ -122,6 +122,15 @@
     }
 
     fn execute_builtin(&mut self, entry: &builtins::BuiltInEntry, cx: &mut Context<Self>) {
+        self.execute_builtin_with_query(entry, None, cx);
+    }
+
+    fn execute_builtin_with_query(
+        &mut self,
+        entry: &builtins::BuiltInEntry,
+        query_override: Option<&str>,
+        cx: &mut Context<Self>,
+    ) {
         logging::log(
             "EXEC",
             &format!("Executing built-in: {} (id: {})", entry.name, entry.id),
@@ -1023,8 +1032,8 @@
                     }
 
                     AiCommandType::GenerateScript => {
-                        let query = self.filter_text.trim().to_string();
-                        self.show_script_generation_chat(Some(query), cx);
+                        let query = query_override.unwrap_or(&self.filter_text).to_string();
+                        self.dispatch_ai_script_generation_from_query(query, cx);
                     }
 
                     AiCommandType::SendScreenToAi => {
diff --git a/src/app_impl/prompt_ai.rs b/src/app_impl/prompt_ai.rs
index 6c10ca4234dc2d80bb14bc0d5163caddf97656cc..f79076d6b5977825788241f2ece9814c6754a4c6
--- a/src/app_impl/prompt_ai.rs
+++ b/src/app_impl/prompt_ai.rs
@@ -638,6 +638,24 @@
         cx.notify();
     }
 
+    pub(crate) fn dispatch_ai_script_generation_from_query(
+        &mut self,
+        query: String,
+        cx: &mut Context<Self>,
+    ) {
+        let query = query.trim().to_string();
+        if query.is_empty() {
+            logging::log(
+                "AI_SCRIPT_GEN",
+                "state=ignored attempted=dispatch_ai_script_generation_from_query reason=empty_query",
+            );
+            return;
+        }
+
+        self.filter_text.clear();
+        self.show_script_generation_chat(Some(query), cx);
+    }
+
     /// Generate a Script Kit script from a natural-language prompt using the built-in AI backend.
     /// The generated script is saved to disk and opened in the configured editor.
     pub fn generate_script_from_ai_prompt(
diff --git a/src/app_impl/selection_fallback.rs b/src/app_impl/selection_fallback.rs
index 9dcd609c870dcb8be976ed0dac0045ff196f31e3..8473dc467e6038b38319848a8da32f9997b36b36
--- a/src/app_impl/selection_fallback.rs
+++ b/src/app_impl/selection_fallback.rs
@@ -11,6 +11,16 @@
     }
 }
 
+fn fallback_keeps_window_open(fallback: &crate::fallbacks::FallbackItem) -> bool {
+    match fallback {
+        crate::fallbacks::FallbackItem::Builtin(builtin) => matches!(
+            builtin.id,
+            "run-in-terminal" | "search-files" | "builtin-generate-script-with-ai"
+        ),
+        crate::fallbacks::FallbackItem::Script(_) => true,
+    }
+}
+
 impl ScriptListApp {
     #[allow(dead_code)]
     pub(crate) fn filtered_scripts(&self) -> Vec<Arc<scripts::Script>> {
@@ -219,14 +229,7 @@
             ),
         );
 
-        // Check if this is a "stay open" action (like run-in-terminal which opens a view)
-        // Check if this is a "stay open" action (opens its own view)
-        let should_close = match fallback {
-            crate::fallbacks::FallbackItem::Builtin(builtin) => {
-                !matches!(builtin.id, "run-in-terminal" | "search-files")
-            }
-            crate::fallbacks::FallbackItem::Script(_) => false,
-        };
+        let should_close = !fallback_keeps_window_open(fallback);
 
         // Execute the fallback action
         match fallback {
@@ -260,13 +263,7 @@
         {
             logging::log("EXEC", &format!("Executing fallback: {}", fallback.name()));
 
-            // Check if this is a "stay open" action (opens its own view)
-            let should_close = match &fallback {
-                crate::fallbacks::FallbackItem::Builtin(builtin) => {
-                    !matches!(builtin.id, "run-in-terminal" | "search-files")
-                }
-                crate::fallbacks::FallbackItem::Script(_) => false,
-            };
+            let should_close = !fallback_keeps_window_open(&fallback);
 
             // Execute the fallback action
             match &fallback {
@@ -399,7 +396,7 @@
                         return;
                     };
 
-                    self.execute_builtin(&entry, cx);
+                    self.execute_builtin_with_query(&entry, Some(input), cx);
                 }
             },
             Err(e) => {
@@ -450,4 +447,28 @@
 
         assert_eq!(resolve_grouped_result_index(&grouped_items, 0), None);
     }
+
+    #[test]
+    fn test_fallback_keeps_window_open_for_generate_script_builtin() {
+        let fallback = crate::fallbacks::FallbackItem::Builtin(
+            crate::fallbacks::builtins::get_builtin_fallbacks()
+                .into_iter()
+                .find(|fallback| fallback.id == "builtin-generate-script-with-ai")
+                .expect("generate-script fallback should exist"),
+        );
+
+        assert!(fallback_keeps_window_open(&fallback));
+    }
+
+    #[test]
+    fn test_fallback_keeps_window_open_is_false_for_regular_builtin() {
+        let fallback = crate::fallbacks::FallbackItem::Builtin(
+            crate::fallbacks::builtins::get_builtin_fallbacks()
+                .into_iter()
+                .find(|fallback| fallback.id == "search-google")
+                .expect("search-google fallback should exist"),
+        );
+
+        assert!(!fallback_keeps_window_open(&fallback));
+    }
 }
diff --git a/src/app_impl/startup.rs b/src/app_impl/startup.rs
index 4fd4dc8c23d8df925c657b8db59f888b855ea6a2..670e087da31d4d0b4c8e21cebc48b3533817041f
--- a/src/app_impl/startup.rs
+++ b/src/app_impl/startup.rs
@@ -730,12 +730,11 @@
                             {
                                 let query = this.filter_text.clone();
 
-                                // Clear filter text before switching view
-                                this.filter_text.clear();
-
                                 if has_shift {
-                                    this.show_script_generation_chat(Some(query), cx);
+                                    this.dispatch_ai_script_generation_from_query(query, cx);
                                 } else {
+                                    // Clear filter text before switching view
+                                    this.filter_text.clear();
                                     // Show inline AI chat with the query as initial input
                                     this.show_inline_ai_chat(Some(query), cx);
                                 }
diff --git a/src/app_impl/startup_new_tab.rs b/src/app_impl/startup_new_tab.rs
index c75a27bf67a5448f59c7700079e8818210722bde..362ad2dcbf87a3a7e4476dcae211899dd788f079
--- a/src/app_impl/startup_new_tab.rs
+++ b/src/app_impl/startup_new_tab.rs
@@ -181,12 +181,11 @@
                             {
                                 let query = this.filter_text.clone();
 
-                                // Clear filter text before switching view
-                                this.filter_text.clear();
-
                                 if has_shift {
-                                    this.show_script_generation_chat(Some(query), cx);
+                                    this.dispatch_ai_script_generation_from_query(query, cx);
                                 } else {
+                                    // Clear filter text before switching view
+                                    this.filter_text.clear();
                                     // Show inline AI chat with the query as initial input
                                     this.show_inline_ai_chat(Some(query), cx);
                                 }
diff --git a/src/app_impl/tests.rs b/src/app_impl/tests.rs
index 3f0fbd1ccbc2f1e3d515ac1edf9666035f09eaf4..8458f7cda5196dcf4ef3413b30efe4d33ce54c11
--- a/src/app_impl/tests.rs
+++ b/src/app_impl/tests.rs
@@ -49,19 +49,30 @@
     }
 
     #[test]
-    fn test_shift_tab_routes_to_ai_script_generation_in_script_list_tab_interceptor() {
+    fn test_shift_tab_routes_to_shared_ai_script_generation_handler() {
         let startup_tab = fs::read_to_string("src/app_impl/startup_new_tab.rs")
             .expect("Failed to read src/app_impl/startup_new_tab.rs");
 
         assert!(
             startup_tab.contains("if has_shift")
-                && startup_tab.contains("this.generate_script_from_ai_prompt(query, cx);"),
-            "Shift+Tab in ScriptList should route to generate_script_from_ai_prompt. \
+                && startup_tab.contains("this.dispatch_ai_script_generation_from_query(query, cx);"),
+            "Shift+Tab in ScriptList should route to dispatch_ai_script_generation_from_query. \
              Missing expected branch in startup_new_tab.rs"
         );
     }
 
     #[test]
+    fn test_generate_script_builtin_routes_to_shared_ai_script_generation_handler() {
+        let builtin_execution = fs::read_to_string("src/app_execute/builtin_execution.rs")
+            .expect("Failed to read src/app_execute/builtin_execution.rs");
+
+        assert!(
+            builtin_execution.contains("self.dispatch_ai_script_generation_from_query(query, cx);"),
+            "Generate Script built-in should route to dispatch_ai_script_generation_from_query"
+        );
+    }
+
+    #[test]
     fn test_tab_still_routes_to_inline_ai_chat_in_script_list_tab_interceptor() {
         let startup_tab = fs::read_to_string("src/app_impl/startup_new_tab.rs")
             .expect("Failed to read src/app_impl/startup_new_tab.rs");
diff --git a/src/main_sections/fallbacks.rs b/src/main_sections/fallbacks.rs
index 7742144684c5c00faffe448c3939b7b4517276bd..5b3881467e2ce686581f30b828f5d44849dcad56
--- a/src/main_sections/fallbacks.rs
+++ b/src/main_sections/fallbacks.rs
@@ -160,7 +160,7 @@
                         return;
                     };
 
-                    app.execute_builtin(&entry, cx);
+                    app.execute_builtin_with_query(&entry, Some(input), cx);
                 }
             }
         }


thinking
**Detecting ongoing test errors**
file update:
diff --git a/src/app_execute/builtin_execution.rs b/src/app_execute/builtin_execution.rs
index dbce42e2664627892bed0da4fee92f6621cd2afd..9c0181eecf499492796afa9819219127d9c04de7
--- a/src/app_execute/builtin_execution.rs
+++ b/src/app_execute/builtin_execution.rs
@@ -122,6 +122,15 @@
     }
 
     fn execute_builtin(&mut self, entry: &builtins::BuiltInEntry, cx: &mut Context<Self>) {
+        self.execute_builtin_with_query(entry, None, cx);
+    }
+
+    fn execute_builtin_with_query(
+        &mut self,
+        entry: &builtins::BuiltInEntry,
+        query_override: Option<&str>,
+        cx: &mut Context<Self>,
+    ) {
         logging::log(
             "EXEC",
             &format!("Executing built-in: {} (id: {})", entry.name, entry.id),
@@ -1023,8 +1032,8 @@
                     }
 
                     AiCommandType::GenerateScript => {
-                        let query = self.filter_text.trim().to_string();
-                        self.show_script_generation_chat(Some(query), cx);
+                        let query = query_override.unwrap_or(&self.filter_text).to_string();
+                        self.dispatch_ai_script_generation_from_query(query, cx);
                     }
 
                     AiCommandType::SendScreenToAi => {
diff --git a/src/app_impl/prompt_ai.rs b/src/app_impl/prompt_ai.rs
index 6c10ca4234dc2d80bb14bc0d5163caddf97656cc..f79076d6b5977825788241f2ece9814c6754a4c6
--- a/src/app_impl/prompt_ai.rs
+++ b/src/app_impl/prompt_ai.rs
@@ -638,6 +638,24 @@
         cx.notify();
     }
 
+    pub(crate) fn dispatch_ai_script_generation_from_query(
+        &mut self,
+        query: String,
+        cx: &mut Context<Self>,
+    ) {
+        let query = query.trim().to_string();
+        if query.is_empty() {
+            logging::log(
+                "AI_SCRIPT_GEN",
+                "state=ignored attempted=dispatch_ai_script_generation_from_query reason=empty_query",
+            );
+            return;
+        }
+
+        self.filter_text.clear();
+        self.show_script_generation_chat(Some(query), cx);
+    }
+
     /// Generate a Script Kit script from a natural-language prompt using the built-in AI backend.
     /// The generated script is saved to disk and opened in the configured editor.
     pub fn generate_script_from_ai_prompt(
diff --git a/src/app_impl/selection_fallback.rs b/src/app_impl/selection_fallback.rs
index 9dcd609c870dcb8be976ed0dac0045ff196f31e3..8473dc467e6038b38319848a8da32f9997b36b36
--- a/src/app_impl/selection_fallback.rs
+++ b/src/app_impl/selection_fallback.rs
@@ -11,6 +11,16 @@
     }
 }
 
+fn fallback_keeps_window_open(fallback: &crate::fallbacks::FallbackItem) -> bool {
+    match fallback {
+        crate::fallbacks::FallbackItem::Builtin(builtin) => matches!(
+            builtin.id,
+            "run-in-terminal" | "search-files" | "builtin-generate-script-with-ai"
+        ),
+        crate::fallbacks::FallbackItem::Script(_) => true,
+    }
+}
+
 impl ScriptListApp {
     #[allow(dead_code)]
     pub(crate) fn filtered_scripts(&self) -> Vec<Arc<scripts::Script>> {
@@ -219,14 +229,7 @@
             ),
         );
 
-        // Check if this is a "stay open" action (like run-in-terminal which opens a view)
-        // Check if this is a "stay open" action (opens its own view)
-        let should_close = match fallback {
-            crate::fallbacks::FallbackItem::Builtin(builtin) => {
-                !matches!(builtin.id, "run-in-terminal" | "search-files")
-            }
-            crate::fallbacks::FallbackItem::Script(_) => false,
-        };
+        let should_close = !fallback_keeps_window_open(fallback);
 
         // Execute the fallback action
         match fallback {
@@ -260,13 +263,7 @@
         {
             logging::log("EXEC", &format!("Executing fallback: {}", fallback.name()));
 
-            // Check if this is a "stay open" action (opens its own view)
-            let should_close = match &fallback {
-                crate::fallbacks::FallbackItem::Builtin(builtin) => {
-                    !matches!(builtin.id, "run-in-terminal" | "search-files")
-                }
-                crate::fallbacks::FallbackItem::Script(_) => false,
-            };
+            let should_close = !fallback_keeps_window_open(&fallback);
 
             // Execute the fallback action
             match &fallback {
@@ -399,7 +396,7 @@
                         return;
                     };
 
-                    self.execute_builtin(&entry, cx);
+                    self.execute_builtin_with_query(&entry, Some(input), cx);
                 }
             },
             Err(e) => {
@@ -450,4 +447,28 @@
 
         assert_eq!(resolve_grouped_result_index(&grouped_items, 0), None);
     }
+
+    #[test]
+    fn test_fallback_keeps_window_open_for_generate_script_builtin() {
+        let fallback = crate::fallbacks::FallbackItem::Builtin(
+            crate::fallbacks::builtins::get_builtin_fallbacks()
+                .into_iter()
+                .find(|fallback| fallback.id == "builtin-generate-script-with-ai")
+                .expect("generate-script fallback should exist"),
+        );
+
+        assert!(fallback_keeps_window_open(&fallback));
+    }
+
+    #[test]
+    fn test_fallback_keeps_window_open_is_false_for_regular_builtin() {
+        let fallback = crate::fallbacks::FallbackItem::Builtin(
+            crate::fallbacks::builtins::get_builtin_fallbacks()
+                .into_iter()
+                .find(|fallback| fallback.id == "search-google")
+                .expect("search-google fallback should exist"),
+        );
+
+        assert!(!fallback_keeps_window_open(&fallback));
+    }
 }
diff --git a/src/app_impl/startup.rs b/src/app_impl/startup.rs
index 4fd4dc8c23d8df925c657b8db59f888b855ea6a2..670e087da31d4d0b4c8e21cebc48b3533817041f
--- a/src/app_impl/startup.rs
+++ b/src/app_impl/startup.rs
@@ -730,12 +730,11 @@
                             {
                                 let query = this.filter_text.clone();
 
-                                // Clear filter text before switching view
-                                this.filter_text.clear();
-
                                 if has_shift {
-                                    this.show_script_generation_chat(Some(query), cx);
+                                    this.dispatch_ai_script_generation_from_query(query, cx);
                                 } else {
+                                    // Clear filter text before switching view
+                                    this.filter_text.clear();
                                     // Show inline AI chat with the query as initial input
                                     this.show_inline_ai_chat(Some(query), cx);
                                 }
diff --git a/src/app_impl/startup_new_tab.rs b/src/app_impl/startup_new_tab.rs
index c75a27bf67a5448f59c7700079e8818210722bde..362ad2dcbf87a3a7e4476dcae211899dd788f079
--- a/src/app_impl/startup_new_tab.rs
+++ b/src/app_impl/startup_new_tab.rs
@@ -181,12 +181,11 @@
                             {
                                 let query = this.filter_text.clone();
 
-                                // Clear filter text before switching view
-                                this.filter_text.clear();
-
                                 if has_shift {
-                                    this.show_script_generation_chat(Some(query), cx);
+                                    this.dispatch_ai_script_generation_from_query(query, cx);
                                 } else {
+                                    // Clear filter text before switching view
+                                    this.filter_text.clear();
                                     // Show inline AI chat with the query as initial input
                                     this.show_inline_ai_chat(Some(query), cx);
                                 }
diff --git a/src/app_impl/tests.rs b/src/app_impl/tests.rs
index 3f0fbd1ccbc2f1e3d515ac1edf9666035f09eaf4..8458f7cda5196dcf4ef3413b30efe4d33ce54c11
--- a/src/app_impl/tests.rs
+++ b/src/app_impl/tests.rs
@@ -49,19 +49,30 @@
     }
 
     #[test]
-    fn test_shift_tab_routes_to_ai_script_generation_in_script_list_tab_interceptor() {
+    fn test_shift_tab_routes_to_shared_ai_script_generation_handler() {
         let startup_tab = fs::read_to_string("src/app_impl/startup_new_tab.rs")
             .expect("Failed to read src/app_impl/startup_new_tab.rs");
 
         assert!(
             startup_tab.contains("if has_shift")
-                && startup_tab.contains("this.generate_script_from_ai_prompt(query, cx);"),
-            "Shift+Tab in ScriptList should route to generate_script_from_ai_prompt. \
+                && startup_tab.contains("this.dispatch_ai_script_generation_from_query(query, cx);"),
+            "Shift+Tab in ScriptList should route to dispatch_ai_script_generation_from_query. \
              Missing expected branch in startup_new_tab.rs"
         );
     }
 
     #[test]
+    fn test_generate_script_builtin_routes_to_shared_ai_script_generation_handler() {
+        let builtin_execution = fs::read_to_string("src/app_execute/builtin_execution.rs")
+            .expect("Failed to read src/app_execute/builtin_execution.rs");
+
+        assert!(
+            builtin_execution.contains("self.dispatch_ai_script_generation_from_query(query, cx);"),
+            "Generate Script built-in should route to dispatch_ai_script_generation_from_query"
+        );
+    }
+
+    #[test]
     fn test_tab_still_routes_to_inline_ai_chat_in_script_list_tab_interceptor() {
         let startup_tab = fs::read_to_string("src/app_impl/startup_new_tab.rs")
             .expect("Failed to read src/app_impl/startup_new_tab.rs");
diff --git a/src/main_sections/fallbacks.rs b/src/main_sections/fallbacks.rs
index 7742144684c5c00faffe448c3939b7b4517276bd..5b3881467e2ce686581f30b828f5d44849dcad56
--- a/src/main_sections/fallbacks.rs
+++ b/src/main_sections/fallbacks.rs
@@ -160,7 +160,7 @@
                         return;
                     };
 
-                    app.execute_builtin(&entry, cx);
+                    app.execute_builtin_with_query(&entry, Some(input), cx);
                 }
             }
         }


thinking
**Polling session status**
file update:
diff --git a/src/app_execute/builtin_execution.rs b/src/app_execute/builtin_execution.rs
index dbce42e2664627892bed0da4fee92f6621cd2afd..9c0181eecf499492796afa9819219127d9c04de7
--- a/src/app_execute/builtin_execution.rs
+++ b/src/app_execute/builtin_execution.rs
@@ -122,6 +122,15 @@
     }
 
     fn execute_builtin(&mut self, entry: &builtins::BuiltInEntry, cx: &mut Context<Self>) {
+        self.execute_builtin_with_query(entry, None, cx);
+    }
+
+    fn execute_builtin_with_query(
+        &mut self,
+        entry: &builtins::BuiltInEntry,
+        query_override: Option<&str>,
+        cx: &mut Context<Self>,
+    ) {
         logging::log(
             "EXEC",
             &format!("Executing built-in: {} (id: {})", entry.name, entry.id),
@@ -1023,8 +1032,8 @@
                     }
 
                     AiCommandType::GenerateScript => {
-                        let query = self.filter_text.trim().to_string();
-                        self.show_script_generation_chat(Some(query), cx);
+                        let query = query_override.unwrap_or(&self.filter_text).to_string();
+                        self.dispatch_ai_script_generation_from_query(query, cx);
                     }
 
                     AiCommandType::SendScreenToAi => {
diff --git a/src/app_impl/prompt_ai.rs b/src/app_impl/prompt_ai.rs
index 6c10ca4234dc2d80bb14bc0d5163caddf97656cc..f79076d6b5977825788241f2ece9814c6754a4c6
--- a/src/app_impl/prompt_ai.rs
+++ b/src/app_impl/prompt_ai.rs
@@ -638,6 +638,24 @@
         cx.notify();
     }
 
+    pub(crate) fn dispatch_ai_script_generation_from_query(
+        &mut self,
+        query: String,
+        cx: &mut Context<Self>,
+    ) {
+        let query = query.trim().to_string();
+        if query.is_empty() {
+            logging::log(
+                "AI_SCRIPT_GEN",
+                "state=ignored attempted=dispatch_ai_script_generation_from_query reason=empty_query",
+            );
+            return;
+        }
+
+        self.filter_text.clear();
+        self.show_script_generation_chat(Some(query), cx);
+    }
+
     /// Generate a Script Kit script from a natural-language prompt using the built-in AI backend.
     /// The generated script is saved to disk and opened in the configured editor.
     pub fn generate_script_from_ai_prompt(
diff --git a/src/app_impl/selection_fallback.rs b/src/app_impl/selection_fallback.rs
index 9dcd609c870dcb8be976ed0dac0045ff196f31e3..8473dc467e6038b38319848a8da32f9997b36b36
--- a/src/app_impl/selection_fallback.rs
+++ b/src/app_impl/selection_fallback.rs
@@ -11,6 +11,16 @@
     }
 }
 
+fn fallback_keeps_window_open(fallback: &crate::fallbacks::FallbackItem) -> bool {
+    match fallback {
+        crate::fallbacks::FallbackItem::Builtin(builtin) => matches!(
+            builtin.id,
+            "run-in-terminal" | "search-files" | "builtin-generate-script-with-ai"
+        ),
+        crate::fallbacks::FallbackItem::Script(_) => true,
+    }
+}
+
 impl ScriptListApp {
     #[allow(dead_code)]
     pub(crate) fn filtered_scripts(&self) -> Vec<Arc<scripts::Script>> {
@@ -219,14 +229,7 @@
             ),
         );
 
-        // Check if this is a "stay open" action (like run-in-terminal which opens a view)
-        // Check if this is a "stay open" action (opens its own view)
-        let should_close = match fallback {
-            crate::fallbacks::FallbackItem::Builtin(builtin) => {
-                !matches!(builtin.id, "run-in-terminal" | "search-files")
-            }
-            crate::fallbacks::FallbackItem::Script(_) => false,
-        };
+        let should_close = !fallback_keeps_window_open(fallback);
 
         // Execute the fallback action
         match fallback {
@@ -260,13 +263,7 @@
         {
             logging::log("EXEC", &format!("Executing fallback: {}", fallback.name()));
 
-            // Check if this is a "stay open" action (opens its own view)
-            let should_close = match &fallback {
-                crate::fallbacks::FallbackItem::Builtin(builtin) => {
-                    !matches!(builtin.id, "run-in-terminal" | "search-files")
-                }
-                crate::fallbacks::FallbackItem::Script(_) => false,
-            };
+            let should_close = !fallback_keeps_window_open(&fallback);
 
             // Execute the fallback action
             match &fallback {
@@ -399,7 +396,7 @@
                         return;
                     };
 
-                    self.execute_builtin(&entry, cx);
+                    self.execute_builtin_with_query(&entry, Some(input), cx);
                 }
             },
             Err(e) => {
@@ -450,4 +447,28 @@
 
         assert_eq!(resolve_grouped_result_index(&grouped_items, 0), None);
     }
+
+    #[test]
+    fn test_fallback_keeps_window_open_for_generate_script_builtin() {
+        let fallback = crate::fallbacks::FallbackItem::Builtin(
+            crate::fallbacks::builtins::get_builtin_fallbacks()
+                .into_iter()
+                .find(|fallback| fallback.id == "builtin-generate-script-with-ai")
+                .expect("generate-script fallback should exist"),
+        );
+
+        assert!(fallback_keeps_window_open(&fallback));
+    }
+
+    #[test]
+    fn test_fallback_keeps_window_open_is_false_for_regular_builtin() {
+        let fallback = crate::fallbacks::FallbackItem::Builtin(
+            crate::fallbacks::builtins::get_builtin_fallbacks()
+                .into_iter()
+                .find(|fallback| fallback.id == "search-google")
+                .expect("search-google fallback should exist"),
+        );
+
+        assert!(!fallback_keeps_window_open(&fallback));
+    }
 }
diff --git a/src/app_impl/startup.rs b/src/app_impl/startup.rs
index 4fd4dc8c23d8df925c657b8db59f888b855ea6a2..670e087da31d4d0b4c8e21cebc48b3533817041f
--- a/src/app_impl/startup.rs
+++ b/src/app_impl/startup.rs
@@ -730,12 +730,11 @@
                             {
                                 let query = this.filter_text.clone();
 
-                                // Clear filter text before switching view
-                                this.filter_text.clear();
-
                                 if has_shift {
-                                    this.show_script_generation_chat(Some(query), cx);
+                                    this.dispatch_ai_script_generation_from_query(query, cx);
                                 } else {
+                                    // Clear filter text before switching view
+                                    this.filter_text.clear();
                                     // Show inline AI chat with the query as initial input
                                     this.show_inline_ai_chat(Some(query), cx);
                                 }
diff --git a/src/app_impl/startup_new_tab.rs b/src/app_impl/startup_new_tab.rs
index c75a27bf67a5448f59c7700079e8818210722bde..362ad2dcbf87a3a7e4476dcae211899dd788f079
--- a/src/app_impl/startup_new_tab.rs
+++ b/src/app_impl/startup_new_tab.rs
@@ -181,12 +181,11 @@
                             {
                                 let query = this.filter_text.clone();
 
-                                // Clear filter text before switching view
-                                this.filter_text.clear();
-
                                 if has_shift {
-                                    this.show_script_generation_chat(Some(query), cx);
+                                    this.dispatch_ai_script_generation_from_query(query, cx);
                                 } else {
+                                    // Clear filter text before switching view
+                                    this.filter_text.clear();
                                     // Show inline AI chat with the query as initial input
                                     this.show_inline_ai_chat(Some(query), cx);
                                 }
diff --git a/src/app_impl/tests.rs b/src/app_impl/tests.rs
index 3f0fbd1ccbc2f1e3d515ac1edf9666035f09eaf4..8458f7cda5196dcf4ef3413b30efe4d33ce54c11
--- a/src/app_impl/tests.rs
+++ b/src/app_impl/tests.rs
@@ -49,19 +49,30 @@
     }
 
     #[test]
-    fn test_shift_tab_routes_to_ai_script_generation_in_script_list_tab_interceptor() {
+    fn test_shift_tab_routes_to_shared_ai_script_generation_handler() {
         let startup_tab = fs::read_to_string("src/app_impl/startup_new_tab.rs")
             .expect("Failed to read src/app_impl/startup_new_tab.rs");
 
         assert!(
             startup_tab.contains("if has_shift")
-                && startup_tab.contains("this.generate_script_from_ai_prompt(query, cx);"),
-            "Shift+Tab in ScriptList should route to generate_script_from_ai_prompt. \
+                && startup_tab.contains("this.dispatch_ai_script_generation_from_query(query, cx);"),
+            "Shift+Tab in ScriptList should route to dispatch_ai_script_generation_from_query. \
              Missing expected branch in startup_new_tab.rs"
         );
     }
 
     #[test]
+    fn test_generate_script_builtin_routes_to_shared_ai_script_generation_handler() {
+        let builtin_execution = fs::read_to_string("src/app_execute/builtin_execution.rs")
+            .expect("Failed to read src/app_execute/builtin_execution.rs");
+
+        assert!(
+            builtin_execution.contains("self.dispatch_ai_script_generation_from_query(query, cx);"),
+            "Generate Script built-in should route to dispatch_ai_script_generation_from_query"
+        );
+    }
+
+    #[test]
     fn test_tab_still_routes_to_inline_ai_chat_in_script_list_tab_interceptor() {
         let startup_tab = fs::read_to_string("src/app_impl/startup_new_tab.rs")
             .expect("Failed to read src/app_impl/startup_new_tab.rs");
diff --git a/src/main_sections/fallbacks.rs b/src/main_sections/fallbacks.rs
index 7742144684c5c00faffe448c3939b7b4517276bd..5b3881467e2ce686581f30b828f5d44849dcad56
--- a/src/main_sections/fallbacks.rs
+++ b/src/main_sections/fallbacks.rs
@@ -160,7 +160,7 @@
                         return;
                     };
 
-                    app.execute_builtin(&entry, cx);
+                    app.execute_builtin_with_query(&entry, Some(input), cx);
                 }
             }
         }

file update:
diff --git a/src/app_execute/builtin_execution.rs b/src/app_execute/builtin_execution.rs
index dbce42e2664627892bed0da4fee92f6621cd2afd..9c0181eecf499492796afa9819219127d9c04de7
--- a/src/app_execute/builtin_execution.rs
+++ b/src/app_execute/builtin_execution.rs
@@ -122,6 +122,15 @@
     }
 
     fn execute_builtin(&mut self, entry: &builtins::BuiltInEntry, cx: &mut Context<Self>) {
+        self.execute_builtin_with_query(entry, None, cx);
+    }
+
+    fn execute_builtin_with_query(
+        &mut self,
+        entry: &builtins::BuiltInEntry,
+        query_override: Option<&str>,
+        cx: &mut Context<Self>,
+    ) {
         logging::log(
             "EXEC",
             &format!("Executing built-in: {} (id: {})", entry.name, entry.id),
@@ -1023,8 +1032,8 @@
                     }
 
                     AiCommandType::GenerateScript => {
-                        let query = self.filter_text.trim().to_string();
-                        self.show_script_generation_chat(Some(query), cx);
+                        let query = query_override.unwrap_or(&self.filter_text).to_string();
+                        self.dispatch_ai_script_generation_from_query(query, cx);
                     }
 
                     AiCommandType::SendScreenToAi => {
diff --git a/src/app_impl/prompt_ai.rs b/src/app_impl/prompt_ai.rs
index 6c10ca4234dc2d80bb14bc0d5163caddf97656cc..f79076d6b5977825788241f2ece9814c6754a4c6
--- a/src/app_impl/prompt_ai.rs
+++ b/src/app_impl/prompt_ai.rs
@@ -638,6 +638,24 @@
         cx.notify();
     }
 
+    pub(crate) fn dispatch_ai_script_generation_from_query(
+        &mut self,
+        query: String,
+        cx: &mut Context<Self>,
+    ) {
+        let query = query.trim().to_string();
+        if query.is_empty() {
+            logging::log(
+                "AI_SCRIPT_GEN",
+                "state=ignored attempted=dispatch_ai_script_generation_from_query reason=empty_query",
+            );
+            return;
+        }
+
+        self.filter_text.clear();
+        self.show_script_generation_chat(Some(query), cx);
+    }
+
     /// Generate a Script Kit script from a natural-language prompt using the built-in AI backend.
     /// The generated script is saved to disk and opened in the configured editor.
     pub fn generate_script_from_ai_prompt(
diff --git a/src/app_impl/selection_fallback.rs b/src/app_impl/selection_fallback.rs
index 9dcd609c870dcb8be976ed0dac0045ff196f31e3..8473dc467e6038b38319848a8da32f9997b36b36
--- a/src/app_impl/selection_fallback.rs
+++ b/src/app_impl/selection_fallback.rs
@@ -11,6 +11,16 @@
     }
 }
 
+fn fallback_keeps_window_open(fallback: &crate::fallbacks::FallbackItem) -> bool {
+    match fallback {
+        crate::fallbacks::FallbackItem::Builtin(builtin) => matches!(
+            builtin.id,
+            "run-in-terminal" | "search-files" | "builtin-generate-script-with-ai"
+        ),
+        crate::fallbacks::FallbackItem::Script(_) => true,
+    }
+}
+
 impl ScriptListApp {
     #[allow(dead_code)]
     pub(crate) fn filtered_scripts(&self) -> Vec<Arc<scripts::Script>> {
@@ -219,14 +229,7 @@
             ),
         );
 
-        // Check if this is a "stay open" action (like run-in-terminal which opens a view)
-        // Check if this is a "stay open" action (opens its own view)
-        let should_close = match fallback {
-            crate::fallbacks::FallbackItem::Builtin(builtin) => {
-                !matches!(builtin.id, "run-in-terminal" | "search-files")
-            }
-            crate::fallbacks::FallbackItem::Script(_) => false,
-        };
+        let should_close = !fallback_keeps_window_open(fallback);
 
         // Execute the fallback action
         match fallback {
@@ -260,13 +263,7 @@
         {
             logging::log("EXEC", &format!("Executing fallback: {}", fallback.name()));
 
-            // Check if this is a "stay open" action (opens its own view)
-            let should_close = match &fallback {
-                crate::fallbacks::FallbackItem::Builtin(builtin) => {
-                    !matches!(builtin.id, "run-in-terminal" | "search-files")
-                }
-                crate::fallbacks::FallbackItem::Script(_) => false,
-            };
+            let should_close = !fallback_keeps_window_open(&fallback);
 
             // Execute the fallback action
             match &fallback {
@@ -399,7 +396,7 @@
                         return;
                     };
 
-                    self.execute_builtin(&entry, cx);
+                    self.execute_builtin_with_query(&entry, Some(input), cx);
                 }
             },
             Err(e) => {
@@ -450,4 +447,28 @@
 
         assert_eq!(resolve_grouped_result_index(&grouped_items, 0), None);
     }
+
+    #[test]
+    fn test_fallback_keeps_window_open_for_generate_script_builtin() {
+        let fallback = crate::fallbacks::FallbackItem::Builtin(
+            crate::fallbacks::builtins::get_builtin_fallbacks()
+                .into_iter()
+                .find(|fallback| fallback.id == "builtin-generate-script-with-ai")
+                .expect("generate-script fallback should exist"),
+        );
+
+        assert!(fallback_keeps_window_open(&fallback));
+    }
+
+    #[test]
+    fn test_fallback_keeps_window_open_is_false_for_regular_builtin() {
+        let fallback = crate::fallbacks::FallbackItem::Builtin(
+            crate::fallbacks::builtins::get_builtin_fallbacks()
+                .into_iter()
+                .find(|fallback| fallback.id == "search-google")
+                .expect("search-google fallback should exist"),
+        );
+
+        assert!(!fallback_keeps_window_open(&fallback));
+    }
 }
diff --git a/src/app_impl/startup.rs b/src/app_impl/startup.rs
index 4fd4dc8c23d8df925c657b8db59f888b855ea6a2..670e087da31d4d0b4c8e21cebc48b3533817041f
--- a/src/app_impl/startup.rs
+++ b/src/app_impl/startup.rs
@@ -730,12 +730,11 @@
                             {
                                 let query = this.filter_text.clone();
 
-                                // Clear filter text before switching view
-                                this.filter_text.clear();
-
                                 if has_shift {
-                                    this.show_script_generation_chat(Some(query), cx);
+                                    this.dispatch_ai_script_generation_from_query(query, cx);
                                 } else {
+                                    // Clear filter text before switching view
+                                    this.filter_text.clear();
                                     // Show inline AI chat with the query as initial input
                                     this.show_inline_ai_chat(Some(query), cx);
                                 }
diff --git a/src/app_impl/startup_new_tab.rs b/src/app_impl/startup_new_tab.rs
index c75a27bf67a5448f59c7700079e8818210722bde..362ad2dcbf87a3a7e4476dcae211899dd788f079
--- a/src/app_impl/startup_new_tab.rs
+++ b/src/app_impl/startup_new_tab.rs
@@ -181,12 +181,11 @@
                             {
                                 let query = this.filter_text.clone();
 
-                                // Clear filter text before switching view
-                                this.filter_text.clear();
-
                                 if has_shift {
-                                    this.show_script_generation_chat(Some(query), cx);
+                                    this.dispatch_ai_script_generation_from_query(query, cx);
                                 } else {
+                                    // Clear filter text before switching view
+                                    this.filter_text.clear();
                                     // Show inline AI chat with the query as initial input
                                     this.show_inline_ai_chat(Some(query), cx);
                                 }
diff --git a/src/app_impl/tests.rs b/src/app_impl/tests.rs
index 3f0fbd1ccbc2f1e3d515ac1edf9666035f09eaf4..8458f7cda5196dcf4ef3413b30efe4d33ce54c11
--- a/src/app_impl/tests.rs
+++ b/src/app_impl/tests.rs
@@ -49,19 +49,30 @@
     }
 
     #[test]
-    fn test_shift_tab_routes_to_ai_script_generation_in_script_list_tab_interceptor() {
+    fn test_shift_tab_routes_to_shared_ai_script_generation_handler() {
         let startup_tab = fs::read_to_string("src/app_impl/startup_new_tab.rs")
             .expect("Failed to read src/app_impl/startup_new_tab.rs");
 
         assert!(
             startup_tab.contains("if has_shift")
-                && startup_tab.contains("this.generate_script_from_ai_prompt(query, cx);"),
-            "Shift+Tab in ScriptList should route to generate_script_from_ai_prompt. \
+                && startup_tab.contains("this.dispatch_ai_script_generation_from_query(query, cx);"),
+            "Shift+Tab in ScriptList should route to dispatch_ai_script_generation_from_query. \
              Missing expected branch in startup_new_tab.rs"
         );
     }
 
     #[test]
+    fn test_generate_script_builtin_routes_to_shared_ai_script_generation_handler() {
+        let builtin_execution = fs::read_to_string("src/app_execute/builtin_execution.rs")
+            .expect("Failed to read src/app_execute/builtin_execution.rs");
+
+        assert!(
+            builtin_execution.contains("self.dispatch_ai_script_generation_from_query(query, cx);"),
+            "Generate Script built-in should route to dispatch_ai_script_generation_from_query"
+        );
+    }
+
+    #[test]
     fn test_tab_still_routes_to_inline_ai_chat_in_script_list_tab_interceptor() {
         let startup_tab = fs::read_to_string("src/app_impl/startup_new_tab.rs")
             .expect("Failed to read src/app_impl/startup_new_tab.rs");
diff --git a/src/main_sections/fallbacks.rs b/src/main_sections/fallbacks.rs
index 7742144684c5c00faffe448c3939b7b4517276bd..5b3881467e2ce686581f30b828f5d44849dcad56
--- a/src/main_sections/fallbacks.rs
+++ b/src/main_sections/fallbacks.rs
@@ -160,7 +160,7 @@
                         return;
                     };
 
-                    app.execute_builtin(&entry, cx);
+                    app.execute_builtin_with_query(&entry, Some(input), cx);
                 }
             }
         }

 exited 101 in 23.31s:
    Blocking waiting for file lock on build directory
   Compiling script-kit-gpui v0.1.0 (/Users/johnlindquist/dev/script-kit-gpui)
error[E0761]: file for module `tests` found at both "src/protocol/message/tests.rs" and "src/protocol/message/tests/mod.rs"
  --> src/protocol/message/mod.rs:87:1
   |
87 | mod tests;
   | ^^^^^^^^^^
   |
   = help: delete or rename one of them to remove the ambiguity

error[E0761]: file for module `tests` found at both "src/designs/core/tests.rs" and "src/designs/core/tests/mod.rs"
 --> src/designs/core/part_04.rs:2:1
  |
2 | mod tests;
  | ^^^^^^^^^^
  |
  = help: delete or rename one of them to remove the ambiguity

error[E0412]: cannot find type `Action` in this scope
   --> src/actions/builders_tests/part_01.rs:18:26

thinking
**Testing clippy despite errors**
exec
/bin/zsh -lc 'cargo clippy -p script-kit-gpui --all-targets -- -D warnings' in /Users/johnlindquist/dev/script-kit-gpuifile update:
diff --git a/src/app_execute/builtin_execution.rs b/src/app_execute/builtin_execution.rs
index dbce42e2664627892bed0da4fee92f6621cd2afd..9c0181eecf499492796afa9819219127d9c04de7
--- a/src/app_execute/builtin_execution.rs
+++ b/src/app_execute/builtin_execution.rs
@@ -122,6 +122,15 @@
     }
 
     fn execute_builtin(&mut self, entry: &builtins::BuiltInEntry, cx: &mut Context<Self>) {
+        self.execute_builtin_with_query(entry, None, cx);
+    }
+
+    fn execute_builtin_with_query(
+        &mut self,
+        entry: &builtins::BuiltInEntry,
+        query_override: Option<&str>,
+        cx: &mut Context<Self>,
+    ) {
         logging::log(
             "EXEC",
             &format!("Executing built-in: {} (id: {})", entry.name, entry.id),
@@ -1023,8 +1032,8 @@
                     }
 
                     AiCommandType::GenerateScript => {
-                        let query = self.filter_text.trim().to_string();
-                        self.show_script_generation_chat(Some(query), cx);
+                        let query = query_override.unwrap_or(&self.filter_text).to_string();
+                        self.dispatch_ai_script_generation_from_query(query, cx);
                     }
 
                     AiCommandType::SendScreenToAi => {
diff --git a/src/app_impl/prompt_ai.rs b/src/app_impl/prompt_ai.rs
index 6c10ca4234dc2d80bb14bc0d5163caddf97656cc..f79076d6b5977825788241f2ece9814c6754a4c6
--- a/src/app_impl/prompt_ai.rs
+++ b/src/app_impl/prompt_ai.rs
@@ -638,6 +638,24 @@
         cx.notify();
     }
 
+    pub(crate) fn dispatch_ai_script_generation_from_query(
+        &mut self,
+        query: String,
+        cx: &mut Context<Self>,
+    ) {
+        let query = query.trim().to_string();
+        if query.is_empty() {
+            logging::log(
+                "AI_SCRIPT_GEN",
+                "state=ignored attempted=dispatch_ai_script_generation_from_query reason=empty_query",
+            );
+            return;
+        }
+
+        self.filter_text.clear();
+        self.show_script_generation_chat(Some(query), cx);
+    }
+
     /// Generate a Script Kit script from a natural-language prompt using the built-in AI backend.
     /// The generated script is saved to disk and opened in the configured editor.
     pub fn generate_script_from_ai_prompt(
diff --git a/src/app_impl/selection_fallback.rs b/src/app_impl/selection_fallback.rs
index 9dcd609c870dcb8be976ed0dac0045ff196f31e3..8473dc467e6038b38319848a8da32f9997b36b36
--- a/src/app_impl/selection_fallback.rs
+++ b/src/app_impl/selection_fallback.rs
@@ -11,6 +11,16 @@
     }
 }
 
+fn fallback_keeps_window_open(fallback: &crate::fallbacks::FallbackItem) -> bool {
+    match fallback {
+        crate::fallbacks::FallbackItem::Builtin(builtin) => matches!(
+            builtin.id,
+            "run-in-terminal" | "search-files" | "builtin-generate-script-with-ai"
+        ),
+        crate::fallbacks::FallbackItem::Script(_) => true,
+    }
+}
+
 impl ScriptListApp {
     #[allow(dead_code)]
     pub(crate) fn filtered_scripts(&self) -> Vec<Arc<scripts::Script>> {
@@ -219,14 +229,7 @@
             ),
         );
 
-        // Check if this is a "stay open" action (like run-in-terminal which opens a view)
-        // Check if this is a "stay open" action (opens its own view)
-        let should_close = match fallback {
-            crate::fallbacks::FallbackItem::Builtin(builtin) => {
-                !matches!(builtin.id, "run-in-terminal" | "search-files")
-            }
-            crate::fallbacks::FallbackItem::Script(_) => false,
-        };
+        let should_close = !fallback_keeps_window_open(fallback);
 
         // Execute the fallback action
         match fallback {
@@ -260,13 +263,7 @@
         {
             logging::log("EXEC", &format!("Executing fallback: {}", fallback.name()));
 
-            // Check if this is a "stay open" action (opens its own view)
-            let should_close = match &fallback {
-                crate::fallbacks::FallbackItem::Builtin(builtin) => {
-                    !matches!(builtin.id, "run-in-terminal" | "search-files")
-                }
-                crate::fallbacks::FallbackItem::Script(_) => false,
-            };
+            let should_close = !fallback_keeps_window_open(&fallback);
 
             // Execute the fallback action
             match &fallback {
@@ -399,7 +396,7 @@
                         return;
                     };
 
-                    self.execute_builtin(&entry, cx);
+                    self.execute_builtin_with_query(&entry, Some(input), cx);
                 }
             },
             Err(e) => {
@@ -450,4 +447,28 @@
 
         assert_eq!(resolve_grouped_result_index(&grouped_items, 0), None);
     }
+
+    #[test]
+    fn test_fallback_keeps_window_open_for_generate_script_builtin() {
+        let fallback = crate::fallbacks::FallbackItem::Builtin(
+            crate::fallbacks::builtins::get_builtin_fallbacks()
+                .into_iter()
+                .find(|fallback| fallback.id == "builtin-generate-script-with-ai")
+                .expect("generate-script fallback should exist"),
+        );
+
+        assert!(fallback_keeps_window_open(&fallback));
+    }
+
+    #[test]
+    fn test_fallback_keeps_window_open_is_false_for_regular_builtin() {
+        let fallback = crate::fallbacks::FallbackItem::Builtin(
+            crate::fallbacks::builtins::get_builtin_fallbacks()
+                .into_iter()
+                .find(|fallback| fallback.id == "search-google")
+                .expect("search-google fallback should exist"),
+        );
+
+        assert!(!fallback_keeps_window_open(&fallback));
+    }
 }
diff --git a/src/app_impl/startup.rs b/src/app_impl/startup.rs
index 4fd4dc8c23d8df925c657b8db59f888b855ea6a2..670e087da31d4d0b4c8e21cebc48b3533817041f
--- a/src/app_impl/startup.rs
+++ b/src/app_impl/startup.rs
@@ -730,12 +730,11 @@
                             {
                                 let query = this.filter_text.clone();
 
-                                // Clear filter text before switching view
-                                this.filter_text.clear();
-
                                 if has_shift {
-                                    this.show_script_generation_chat(Some(query), cx);
+                                    this.dispatch_ai_script_generation_from_query(query, cx);
                                 } else {
+                                    // Clear filter text before switching view
+                                    this.filter_text.clear();
                                     // Show inline AI chat with the query as initial input
                                     this.show_inline_ai_chat(Some(query), cx);
                                 }
diff --git a/src/app_impl/startup_new_tab.rs b/src/app_impl/startup_new_tab.rs
index c75a27bf67a5448f59c7700079e8818210722bde..362ad2dcbf87a3a7e4476dcae211899dd788f079
--- a/src/app_impl/startup_new_tab.rs
+++ b/src/app_impl/startup_new_tab.rs
@@ -181,12 +181,11 @@
                             {
                                 let query = this.filter_text.clone();
 
-                                // Clear filter text before switching view
-                                this.filter_text.clear();
-
                                 if has_shift {
-                                    this.show_script_generation_chat(Some(query), cx);
+                                    this.dispatch_ai_script_generation_from_query(query, cx);
                                 } else {
+                                    // Clear filter text before switching view
+                                    this.filter_text.clear();
                                     // Show inline AI chat with the query as initial input
                                     this.show_inline_ai_chat(Some(query), cx);
                                 }
diff --git a/src/app_impl/tests.rs b/src/app_impl/tests.rs
index 3f0fbd1ccbc2f1e3d515ac1edf9666035f09eaf4..8458f7cda5196dcf4ef3413b30efe4d33ce54c11
--- a/src/app_impl/tests.rs
+++ b/src/app_impl/tests.rs
@@ -49,19 +49,30 @@
     }
 
     #[test]
-    fn test_shift_tab_routes_to_ai_script_generation_in_script_list_tab_interceptor() {
+    fn test_shift_tab_routes_to_shared_ai_script_generation_handler() {
         let startup_tab = fs::read_to_string("src/app_impl/startup_new_tab.rs")
             .expect("Failed to read src/app_impl/startup_new_tab.rs");
 
         assert!(
             startup_tab.contains("if has_shift")
-                && startup_tab.contains("this.generate_script_from_ai_prompt(query, cx);"),
-            "Shift+Tab in ScriptList should route to generate_script_from_ai_prompt. \
+                && startup_tab.contains("this.dispatch_ai_script_generation_from_query(query, cx);"),
+            "Shift+Tab in ScriptList should route to dispatch_ai_script_generation_from_query. \
              Missing expected branch in startup_new_tab.rs"
         );
     }
 
     #[test]
+    fn test_generate_script_builtin_routes_to_shared_ai_script_generation_handler() {
+        let builtin_execution = fs::read_to_string("src/app_execute/builtin_execution.rs")
+            .expect("Failed to read src/app_execute/builtin_execution.rs");
+
+        assert!(
+            builtin_execution.contains("self.dispatch_ai_script_generation_from_query(query, cx);"),
+            "Generate Script built-in should route to dispatch_ai_script_generation_from_query"
+        );
+    }
+
+    #[test]
     fn test_tab_still_routes_to_inline_ai_chat_in_script_list_tab_interceptor() {
         let startup_tab = fs::read_to_string("src/app_impl/startup_new_tab.rs")
             .expect("Failed to read src/app_impl/startup_new_tab.rs");
diff --git a/src/main_sections/fallbacks.rs b/src/main_sections/fallbacks.rs
index 7742144684c5c00faffe448c3939b7b4517276bd..5b3881467e2ce686581f30b828f5d44849dcad56
--- a/src/main_sections/fallbacks.rs
+++ b/src/main_sections/fallbacks.rs
@@ -160,7 +160,7 @@
                         return;
                     };
 
-                    app.execute_builtin(&entry, cx);
+                    app.execute_builtin_with_query(&entry, Some(input), cx);
                 }
             }
         }


thinking
**Polling for continued errors**
codex
Clippy immediately fails on unrelated parallel-agent breakages (duplicate test module files), before reaching our touched code. Iâ€™m collecting a clean diff summary and then Iâ€™ll run one more focused compile check to confirm our edits themselves still typecheck.

thinking
**Identifying incomplete polling session**
file update:
diff --git a/src/app_execute/builtin_execution.rs b/src/app_execute/builtin_execution.rs
index dbce42e2664627892bed0da4fee92f6621cd2afd..9c0181eecf499492796afa9819219127d9c04de7
--- a/src/app_execute/builtin_execution.rs
+++ b/src/app_execute/builtin_execution.rs
@@ -122,6 +122,15 @@
     }
 
     fn execute_builtin(&mut self, entry: &builtins::BuiltInEntry, cx: &mut Context<Self>) {
+        self.execute_builtin_with_query(entry, None, cx);
+    }
+
+    fn execute_builtin_with_query(
+        &mut self,
+        entry: &builtins::BuiltInEntry,
+        query_override: Option<&str>,
+        cx: &mut Context<Self>,
+    ) {
         logging::log(
             "EXEC",
             &format!("Executing built-in: {} (id: {})", entry.name, entry.id),
@@ -1023,8 +1032,8 @@
                     }
 
                     AiCommandType::GenerateScript => {
-                        let query = self.filter_text.trim().to_string();
-                        self.show_script_generation_chat(Some(query), cx);
+                        let query = query_override.unwrap_or(&self.filter_text).to_string();
+                        self.dispatch_ai_script_generation_from_query(query, cx);
                     }
 
                     AiCommandType::SendScreenToAi => {
diff --git a/src/app_impl/prompt_ai.rs b/src/app_impl/prompt_ai.rs
index 6c10ca4234dc2d80bb14bc0d5163caddf97656cc..f79076d6b5977825788241f2ece9814c6754a4c6
--- a/src/app_impl/prompt_ai.rs
+++ b/src/app_impl/prompt_ai.rs
@@ -638,6 +638,24 @@
         cx.notify();
     }
 
+    pub(crate) fn dispatch_ai_script_generation_from_query(
+        &mut self,
+        query: String,
+        cx: &mut Context<Self>,
+    ) {
+        let query = query.trim().to_string();
+        if query.is_empty() {
+            logging::log(
+                "AI_SCRIPT_GEN",
+                "state=ignored attempted=dispatch_ai_script_generation_from_query reason=empty_query",
+            );
+            return;
+        }
+
+        self.filter_text.clear();
+        self.show_script_generation_chat(Some(query), cx);
+    }
+
     /// Generate a Script Kit script from a natural-language prompt using the built-in AI backend.
     /// The generated script is saved to disk and opened in the configured editor.
     pub fn generate_script_from_ai_prompt(
diff --git a/src/app_impl/selection_fallback.rs b/src/app_impl/selection_fallback.rs
index 9dcd609c870dcb8be976ed0dac0045ff196f31e3..8473dc467e6038b38319848a8da32f9997b36b36
--- a/src/app_impl/selection_fallback.rs
+++ b/src/app_impl/selection_fallback.rs
@@ -11,6 +11,16 @@
     }
 }
 
+fn fallback_keeps_window_open(fallback: &crate::fallbacks::FallbackItem) -> bool {
+    match fallback {
+        crate::fallbacks::FallbackItem::Builtin(builtin) => matches!(
+            builtin.id,
+            "run-in-terminal" | "search-files" | "builtin-generate-script-with-ai"
+        ),
+        crate::fallbacks::FallbackItem::Script(_) => true,
+    }
+}
+
 impl ScriptListApp {
     #[allow(dead_code)]
     pub(crate) fn filtered_scripts(&self) -> Vec<Arc<scripts::Script>> {
@@ -219,14 +229,7 @@
             ),
         );
 
-        // Check if this is a "stay open" action (like run-in-terminal which opens a view)
-        // Check if this is a "stay open" action (opens its own view)
-        let should_close = match fallback {
-            crate::fallbacks::FallbackItem::Builtin(builtin) => {
-                !matches!(builtin.id, "run-in-terminal" | "search-files")
-            }
-            crate::fallbacks::FallbackItem::Script(_) => false,
-        };
+        let should_close = !fallback_keeps_window_open(fallback);
 
         // Execute the fallback action
         match fallback {
@@ -260,13 +263,7 @@
         {
             logging::log("EXEC", &format!("Executing fallback: {}", fallback.name()));
 
-            // Check if this is a "stay open" action (opens its own view)
-            let should_close = match &fallback {
-                crate::fallbacks::FallbackItem::Builtin(builtin) => {
-                    !matches!(builtin.id, "run-in-terminal" | "search-files")
-                }
-                crate::fallbacks::FallbackItem::Script(_) => false,
-            };
+            let should_close = !fallback_keeps_window_open(&fallback);
 
             // Execute the fallback action
             match &fallback {
@@ -399,7 +396,7 @@
                         return;
                     };
 
-                    self.execute_builtin(&entry, cx);
+                    self.execute_builtin_with_query(&entry, Some(input), cx);
                 }
             },
             Err(e) => {
@@ -450,4 +447,28 @@
 
         assert_eq!(resolve_grouped_result_index(&grouped_items, 0), None);
     }
+
+    #[test]
+    fn test_fallback_keeps_window_open_for_generate_script_builtin() {
+        let fallback = crate::fallbacks::FallbackItem::Builtin(
+            crate::fallbacks::builtins::get_builtin_fallbacks()
+                .into_iter()
+                .find(|fallback| fallback.id == "builtin-generate-script-with-ai")
+                .expect("generate-script fallback should exist"),
+        );
+
+        assert!(fallback_keeps_window_open(&fallback));
+    }
+
+    #[test]
+    fn test_fallback_keeps_window_open_is_false_for_regular_builtin() {
+        let fallback = crate::fallbacks::FallbackItem::Builtin(
+            crate::fallbacks::builtins::get_builtin_fallbacks()
+                .into_iter()
+                .find(|fallback| fallback.id == "search-google")
+                .expect("search-google fallback should exist"),
+        );
+
+        assert!(!fallback_keeps_window_open(&fallback));
+    }
 }
diff --git a/src/app_impl/startup.rs b/src/app_impl/startup.rs
index 4fd4dc8c23d8df925c657b8db59f888b855ea6a2..670e087da31d4d0b4c8e21cebc48b3533817041f
--- a/src/app_impl/startup.rs
+++ b/src/app_impl/startup.rs
@@ -730,12 +730,11 @@
                             {
                                 let query = this.filter_text.clone();
 
-                                // Clear filter text before switching view
-                                this.filter_text.clear();
-
                                 if has_shift {
-                                    this.show_script_generation_chat(Some(query), cx);
+                                    this.dispatch_ai_script_generation_from_query(query, cx);
                                 } else {
+                                    // Clear filter text before switching view
+                                    this.filter_text.clear();
                                     // Show inline AI chat with the query as initial input
                                     this.show_inline_ai_chat(Some(query), cx);
                                 }
diff --git a/src/app_impl/startup_new_tab.rs b/src/app_impl/startup_new_tab.rs
index c75a27bf67a5448f59c7700079e8818210722bde..362ad2dcbf87a3a7e4476dcae211899dd788f079
--- a/src/app_impl/startup_new_tab.rs
+++ b/src/app_impl/startup_new_tab.rs
@@ -181,12 +181,11 @@
                             {
                                 let query = this.filter_text.clone();
 
-                                // Clear filter text before switching view
-                                this.filter_text.clear();
-
                                 if has_shift {
-                                    this.show_script_generation_chat(Some(query), cx);
+                                    this.dispatch_ai_script_generation_from_query(query, cx);
                                 } else {
+                                    // Clear filter text before switching view
+                                    this.filter_text.clear();
                                     // Show inline AI chat with the query as initial input
                                     this.show_inline_ai_chat(Some(query), cx);
                                 }
diff --git a/src/app_impl/tests.rs b/src/app_impl/tests.rs
index 3f0fbd1ccbc2f1e3d515ac1edf9666035f09eaf4..8458f7cda5196dcf4ef3413b30efe4d33ce54c11
--- a/src/app_impl/tests.rs
+++ b/src/app_impl/tests.rs
@@ -49,19 +49,30 @@
     }
 
     #[test]
-    fn test_shift_tab_routes_to_ai_script_generation_in_script_list_tab_interceptor() {
+    fn test_shift_tab_routes_to_shared_ai_script_generation_handler() {
         let startup_tab = fs::read_to_string("src/app_impl/startup_new_tab.rs")
             .expect("Failed to read src/app_impl/startup_new_tab.rs");
 
         assert!(
             startup_tab.contains("if has_shift")
-                && startup_tab.contains("this.generate_script_from_ai_prompt(query, cx);"),
-            "Shift+Tab in ScriptList should route to generate_script_from_ai_prompt. \
+                && startup_tab.contains("this.dispatch_ai_script_generation_from_query(query, cx);"),
+            "Shift+Tab in ScriptList should route to dispatch_ai_script_generation_from_query. \
              Missing expected branch in startup_new_tab.rs"
         );
     }
 
     #[test]
+    fn test_generate_script_builtin_routes_to_shared_ai_script_generation_handler() {
+        let builtin_execution = fs::read_to_string("src/app_execute/builtin_execution.rs")
+            .expect("Failed to read src/app_execute/builtin_execution.rs");
+
+        assert!(
+            builtin_execution.contains("self.dispatch_ai_script_generation_from_query(query, cx);"),
+            "Generate Script built-in should route to dispatch_ai_script_generation_from_query"
+        );
+    }
+
+    #[test]
     fn test_tab_still_routes_to_inline_ai_chat_in_script_list_tab_interceptor() {
         let startup_tab = fs::read_to_string("src/app_impl/startup_new_tab.rs")
             .expect("Failed to read src/app_impl/startup_new_tab.rs");
diff --git a/src/main_sections/fallbacks.rs b/src/main_sections/fallbacks.rs
index 7742144684c5c00faffe448c3939b7b4517276bd..5b3881467e2ce686581f30b828f5d44849dcad56
--- a/src/main_sections/fallbacks.rs
+++ b/src/main_sections/fallbacks.rs
@@ -160,7 +160,7 @@
                         return;
                     };
 
-                    app.execute_builtin(&entry, cx);
+                    app.execute_builtin_with_query(&entry, Some(input), cx);
                 }
             }
         }


thinking
**Checking session output completion**
file update:
diff --git a/src/app_execute/builtin_execution.rs b/src/app_execute/builtin_execution.rs
index dbce42e2664627892bed0da4fee92f6621cd2afd..9c0181eecf499492796afa9819219127d9c04de7
--- a/src/app_execute/builtin_execution.rs
+++ b/src/app_execute/builtin_execution.rs
@@ -122,6 +122,15 @@
     }
 
     fn execute_builtin(&mut self, entry: &builtins::BuiltInEntry, cx: &mut Context<Self>) {
+        self.execute_builtin_with_query(entry, None, cx);
+    }
+
+    fn execute_builtin_with_query(
+        &mut self,
+        entry: &builtins::BuiltInEntry,
+        query_override: Option<&str>,
+        cx: &mut Context<Self>,
+    ) {
         logging::log(
             "EXEC",
             &format!("Executing built-in: {} (id: {})", entry.name, entry.id),
@@ -1023,8 +1032,8 @@
                     }
 
                     AiCommandType::GenerateScript => {
-                        let query = self.filter_text.trim().to_string();
-                        self.show_script_generation_chat(Some(query), cx);
+                        let query = query_override.unwrap_or(&self.filter_text).to_string();
+                        self.dispatch_ai_script_generation_from_query(query, cx);
                     }
 
                     AiCommandType::SendScreenToAi => {
diff --git a/src/app_impl/prompt_ai.rs b/src/app_impl/prompt_ai.rs
index 6c10ca4234dc2d80bb14bc0d5163caddf97656cc..f79076d6b5977825788241f2ece9814c6754a4c6
--- a/src/app_impl/prompt_ai.rs
+++ b/src/app_impl/prompt_ai.rs
@@ -638,6 +638,24 @@
         cx.notify();
     }
 
+    pub(crate) fn dispatch_ai_script_generation_from_query(
+        &mut self,
+        query: String,
+        cx: &mut Context<Self>,
+    ) {
+        let query = query.trim().to_string();
+        if query.is_empty() {
+            logging::log(
+                "AI_SCRIPT_GEN",
+                "state=ignored attempted=dispatch_ai_script_generation_from_query reason=empty_query",
+            );
+            return;
+        }
+
+        self.filter_text.clear();
+        self.show_script_generation_chat(Some(query), cx);
+    }
+
     /// Generate a Script Kit script from a natural-language prompt using the built-in AI backend.
     /// The generated script is saved to disk and opened in the configured editor.
     pub fn generate_script_from_ai_prompt(
diff --git a/src/app_impl/selection_fallback.rs b/src/app_impl/selection_fallback.rs
index 9dcd609c870dcb8be976ed0dac0045ff196f31e3..8473dc467e6038b38319848a8da32f9997b36b36
--- a/src/app_impl/selection_fallback.rs
+++ b/src/app_impl/selection_fallback.rs
@@ -11,6 +11,16 @@
     }
 }
 
+fn fallback_keeps_window_open(fallback: &crate::fallbacks::FallbackItem) -> bool {
+    match fallback {
+        crate::fallbacks::FallbackItem::Builtin(builtin) => matches!(
+            builtin.id,
+            "run-in-terminal" | "search-files" | "builtin-generate-script-with-ai"
+        ),
+        crate::fallbacks::FallbackItem::Script(_) => true,
+    }
+}
+
 impl ScriptListApp {
     #[allow(dead_code)]
     pub(crate) fn filtered_scripts(&self) -> Vec<Arc<scripts::Script>> {
@@ -219,14 +229,7 @@
             ),
         );
 
-        // Check if this is a "stay open" action (like run-in-terminal which opens a view)
-        // Check if this is a "stay open" action (opens its own view)
-        let should_close = match fallback {
-            crate::fallbacks::FallbackItem::Builtin(builtin) => {
-                !matches!(builtin.id, "run-in-terminal" | "search-files")
-            }
-            crate::fallbacks::FallbackItem::Script(_) => false,
-        };
+        let should_close = !fallback_keeps_window_open(fallback);
 
         // Execute the fallback action
         match fallback {
@@ -260,13 +263,7 @@
         {
             logging::log("EXEC", &format!("Executing fallback: {}", fallback.name()));
 
-            // Check if this is a "stay open" action (opens its own view)
-            let should_close = match &fallback {
-                crate::fallbacks::FallbackItem::Builtin(builtin) => {
-                    !matches!(builtin.id, "run-in-terminal" | "search-files")
-                }
-                crate::fallbacks::FallbackItem::Script(_) => false,
-            };
+            let should_close = !fallback_keeps_window_open(&fallback);
 
             // Execute the fallback action
             match &fallback {
@@ -399,7 +396,7 @@
                         return;
                     };
 
-                    self.execute_builtin(&entry, cx);
+                    self.execute_builtin_with_query(&entry, Some(input), cx);
                 }
             },
             Err(e) => {
@@ -450,4 +447,28 @@
 
         assert_eq!(resolve_grouped_result_index(&grouped_items, 0), None);
     }
+
+    #[test]
+    fn test_fallback_keeps_window_open_for_generate_script_builtin() {
+        let fallback = crate::fallbacks::FallbackItem::Builtin(
+            crate::fallbacks::builtins::get_builtin_fallbacks()
+                .into_iter()
+                .find(|fallback| fallback.id == "builtin-generate-script-with-ai")
+                .expect("generate-script fallback should exist"),
+        );
+
+        assert!(fallback_keeps_window_open(&fallback));
+    }
+
+    #[test]
+    fn test_fallback_keeps_window_open_is_false_for_regular_builtin() {
+        let fallback = crate::fallbacks::FallbackItem::Builtin(
+            crate::fallbacks::builtins::get_builtin_fallbacks()
+                .into_iter()
+                .find(|fallback| fallback.id == "search-google")
+                .expect("search-google fallback should exist"),
+        );
+
+        assert!(!fallback_keeps_window_open(&fallback));
+    }
 }
diff --git a/src/app_impl/startup.rs b/src/app_impl/startup.rs
index 4fd4dc8c23d8df925c657b8db59f888b855ea6a2..670e087da31d4d0b4c8e21cebc48b3533817041f
--- a/src/app_impl/startup.rs
+++ b/src/app_impl/startup.rs
@@ -730,12 +730,11 @@
                             {
                                 let query = this.filter_text.clone();
 
-                                // Clear filter text before switching view
-                                this.filter_text.clear();
-
                                 if has_shift {
-                                    this.show_script_generation_chat(Some(query), cx);
+                                    this.dispatch_ai_script_generation_from_query(query, cx);
                                 } else {
+                                    // Clear filter text before switching view
+                                    this.filter_text.clear();
                                     // Show inline AI chat with the query as initial input
                                     this.show_inline_ai_chat(Some(query), cx);
                                 }
diff --git a/src/app_impl/startup_new_tab.rs b/src/app_impl/startup_new_tab.rs
index c75a27bf67a5448f59c7700079e8818210722bde..362ad2dcbf87a3a7e4476dcae211899dd788f079
--- a/src/app_impl/startup_new_tab.rs
+++ b/src/app_impl/startup_new_tab.rs
@@ -181,12 +181,11 @@
                             {
                                 let query = this.filter_text.clone();
 
-                                // Clear filter text before switching view
-                                this.filter_text.clear();
-
                                 if has_shift {
-                                    this.show_script_generation_chat(Some(query), cx);
+                                    this.dispatch_ai_script_generation_from_query(query, cx);
                                 } else {
+                                    // Clear filter text before switching view
+                                    this.filter_text.clear();
                                     // Show inline AI chat with the query as initial input
                                     this.show_inline_ai_chat(Some(query), cx);
                                 }
diff --git a/src/app_impl/tests.rs b/src/app_impl/tests.rs
index 3f0fbd1ccbc2f1e3d515ac1edf9666035f09eaf4..8458f7cda5196dcf4ef3413b30efe4d33ce54c11
--- a/src/app_impl/tests.rs
+++ b/src/app_impl/tests.rs
@@ -49,19 +49,30 @@
     }
 
     #[test]
-    fn test_shift_tab_routes_to_ai_script_generation_in_script_list_tab_interceptor() {
+    fn test_shift_tab_routes_to_shared_ai_script_generation_handler() {
         let startup_tab = fs::read_to_string("src/app_impl/startup_new_tab.rs")
             .expect("Failed to read src/app_impl/startup_new_tab.rs");
 
         assert!(
             startup_tab.contains("if has_shift")
-                && startup_tab.contains("this.generate_script_from_ai_prompt(query, cx);"),
-            "Shift+Tab in ScriptList should route to generate_script_from_ai_prompt. \
+                && startup_tab.contains("this.dispatch_ai_script_generation_from_query(query, cx);"),
+            "Shift+Tab in ScriptList should route to dispatch_ai_script_generation_from_query. \
              Missing expected branch in startup_new_tab.rs"
         );
     }
 
     #[test]
+    fn test_generate_script_builtin_routes_to_shared_ai_script_generation_handler() {
+        let builtin_execution = fs::read_to_string("src/app_execute/builtin_execution.rs")
+            .expect("Failed to read src/app_execute/builtin_execution.rs");
+
+        assert!(
+            builtin_execution.contains("self.dispatch_ai_script_generation_from_query(query, cx);"),
+            "Generate Script built-in should route to dispatch_ai_script_generation_from_query"
+        );
+    }
+
+    #[test]
     fn test_tab_still_routes_to_inline_ai_chat_in_script_list_tab_interceptor() {
         let startup_tab = fs::read_to_string("src/app_impl/startup_new_tab.rs")
             .expect("Failed to read src/app_impl/startup_new_tab.rs");
diff --git a/src/main_sections/fallbacks.rs b/src/main_sections/fallbacks.rs
index 7742144684c5c00faffe448c3939b7b4517276bd..5b3881467e2ce686581f30b828f5d44849dcad56
--- a/src/main_sections/fallbacks.rs
+++ b/src/main_sections/fallbacks.rs
@@ -160,7 +160,7 @@
                         return;
                     };
 
-                    app.execute_builtin(&entry, cx);
+                    app.execute_builtin_with_query(&entry, Some(input), cx);
                 }
             }
         }


thinking
**Polling process completion**
file update:
diff --git a/src/app_execute/builtin_execution.rs b/src/app_execute/builtin_execution.rs
index dbce42e2664627892bed0da4fee92f6621cd2afd..9c0181eecf499492796afa9819219127d9c04de7
--- a/src/app_execute/builtin_execution.rs
+++ b/src/app_execute/builtin_execution.rs
@@ -122,6 +122,15 @@
     }
 
     fn execute_builtin(&mut self, entry: &builtins::BuiltInEntry, cx: &mut Context<Self>) {
+        self.execute_builtin_with_query(entry, None, cx);
+    }
+
+    fn execute_builtin_with_query(
+        &mut self,
+        entry: &builtins::BuiltInEntry,
+        query_override: Option<&str>,
+        cx: &mut Context<Self>,
+    ) {
         logging::log(
             "EXEC",
             &format!("Executing built-in: {} (id: {})", entry.name, entry.id),
@@ -1023,8 +1032,8 @@
                     }
 
                     AiCommandType::GenerateScript => {
-                        let query = self.filter_text.trim().to_string();
-                        self.show_script_generation_chat(Some(query), cx);
+                        let query = query_override.unwrap_or(&self.filter_text).to_string();
+                        self.dispatch_ai_script_generation_from_query(query, cx);
                     }
 
                     AiCommandType::SendScreenToAi => {
diff --git a/src/app_impl/prompt_ai.rs b/src/app_impl/prompt_ai.rs
index 6c10ca4234dc2d80bb14bc0d5163caddf97656cc..f79076d6b5977825788241f2ece9814c6754a4c6
--- a/src/app_impl/prompt_ai.rs
+++ b/src/app_impl/prompt_ai.rs
@@ -638,6 +638,24 @@
         cx.notify();
     }
 
+    pub(crate) fn dispatch_ai_script_generation_from_query(
+        &mut self,
+        query: String,
+        cx: &mut Context<Self>,
+    ) {
+        let query = query.trim().to_string();
+        if query.is_empty() {
+            logging::log(
+                "AI_SCRIPT_GEN",
+                "state=ignored attempted=dispatch_ai_script_generation_from_query reason=empty_query",
+            );
+            return;
+        }
+
+        self.filter_text.clear();
+        self.show_script_generation_chat(Some(query), cx);
+    }
+
     /// Generate a Script Kit script from a natural-language prompt using the built-in AI backend.
     /// The generated script is saved to disk and opened in the configured editor.
     pub fn generate_script_from_ai_prompt(
diff --git a/src/app_impl/selection_fallback.rs b/src/app_impl/selection_fallback.rs
index 9dcd609c870dcb8be976ed0dac0045ff196f31e3..8473dc467e6038b38319848a8da32f9997b36b36
--- a/src/app_impl/selection_fallback.rs
+++ b/src/app_impl/selection_fallback.rs
@@ -11,6 +11,16 @@
     }
 }
 
+fn fallback_keeps_window_open(fallback: &crate::fallbacks::FallbackItem) -> bool {
+    match fallback {
+        crate::fallbacks::FallbackItem::Builtin(builtin) => matches!(
+            builtin.id,
+            "run-in-terminal" | "search-files" | "builtin-generate-script-with-ai"
+        ),
+        crate::fallbacks::FallbackItem::Script(_) => true,
+    }
+}
+
 impl ScriptListApp {
     #[allow(dead_code)]
     pub(crate) fn filtered_scripts(&self) -> Vec<Arc<scripts::Script>> {
@@ -219,14 +229,7 @@
             ),
         );
 
-        // Check if this is a "stay open" action (like run-in-terminal which opens a view)
-        // Check if this is a "stay open" action (opens its own view)
-        let should_close = match fallback {
-            crate::fallbacks::FallbackItem::Builtin(builtin) => {
-                !matches!(builtin.id, "run-in-terminal" | "search-files")
-            }
-            crate::fallbacks::FallbackItem::Script(_) => false,
-        };
+        let should_close = !fallback_keeps_window_open(fallback);
 
         // Execute the fallback action
         match fallback {
@@ -260,13 +263,7 @@
         {
             logging::log("EXEC", &format!("Executing fallback: {}", fallback.name()));
 
-            // Check if this is a "stay open" action (opens its own view)
-            let should_close = match &fallback {
-                crate::fallbacks::FallbackItem::Builtin(builtin) => {
-                    !matches!(builtin.id, "run-in-terminal" | "search-files")
-                }
-                crate::fallbacks::FallbackItem::Script(_) => false,
-            };
+            let should_close = !fallback_keeps_window_open(&fallback);
 
             // Execute the fallback action
             match &fallback {
@@ -399,7 +396,7 @@
                         return;
                     };
 
-                    self.execute_builtin(&entry, cx);
+                    self.execute_builtin_with_query(&entry, Some(input), cx);
                 }
             },
             Err(e) => {
@@ -450,4 +447,28 @@
 
         assert_eq!(resolve_grouped_result_index(&grouped_items, 0), None);
     }
+
+    #[test]
+    fn test_fallback_keeps_window_open_for_generate_script_builtin() {
+        let fallback = crate::fallbacks::FallbackItem::Builtin(
+            crate::fallbacks::builtins::get_builtin_fallbacks()
+                .into_iter()
+                .find(|fallback| fallback.id == "builtin-generate-script-with-ai")
+                .expect("generate-script fallback should exist"),
+        );
+
+        assert!(fallback_keeps_window_open(&fallback));
+    }
+
+    #[test]
+    fn test_fallback_keeps_window_open_is_false_for_regular_builtin() {
+        let fallback = crate::fallbacks::FallbackItem::Builtin(
+            crate::fallbacks::builtins::get_builtin_fallbacks()
+                .into_iter()
+                .find(|fallback| fallback.id == "search-google")
+                .expect("search-google fallback should exist"),
+        );
+
+        assert!(!fallback_keeps_window_open(&fallback));
+    }
 }
diff --git a/src/app_impl/startup.rs b/src/app_impl/startup.rs
index 4fd4dc8c23d8df925c657b8db59f888b855ea6a2..670e087da31d4d0b4c8e21cebc48b3533817041f
--- a/src/app_impl/startup.rs
+++ b/src/app_impl/startup.rs
@@ -730,12 +730,11 @@
                             {
                                 let query = this.filter_text.clone();
 
-                                // Clear filter text before switching view
-                                this.filter_text.clear();
-
                                 if has_shift {
-                                    this.show_script_generation_chat(Some(query), cx);
+                                    this.dispatch_ai_script_generation_from_query(query, cx);
                                 } else {
+                                    // Clear filter text before switching view
+                                    this.filter_text.clear();
                                     // Show inline AI chat with the query as initial input
                                     this.show_inline_ai_chat(Some(query), cx);
                                 }
diff --git a/src/app_impl/startup_new_tab.rs b/src/app_impl/startup_new_tab.rs
index c75a27bf67a5448f59c7700079e8818210722bde..362ad2dcbf87a3a7e4476dcae211899dd788f079
--- a/src/app_impl/startup_new_tab.rs
+++ b/src/app_impl/startup_new_tab.rs
@@ -181,12 +181,11 @@
                             {
                                 let query = this.filter_text.clone();
 
-                                // Clear filter text before switching view
-                                this.filter_text.clear();
-
                                 if has_shift {
-                                    this.show_script_generation_chat(Some(query), cx);
+                                    this.dispatch_ai_script_generation_from_query(query, cx);
                                 } else {
+                                    // Clear filter text before switching view
+                                    this.filter_text.clear();
                                     // Show inline AI chat with the query as initial input
                                     this.show_inline_ai_chat(Some(query), cx);
                                 }
diff --git a/src/app_impl/tests.rs b/src/app_impl/tests.rs
index 3f0fbd1ccbc2f1e3d515ac1edf9666035f09eaf4..8458f7cda5196dcf4ef3413b30efe4d33ce54c11
--- a/src/app_impl/tests.rs
+++ b/src/app_impl/tests.rs
@@ -49,19 +49,30 @@
     }
 
     #[test]
-    fn test_shift_tab_routes_to_ai_script_generation_in_script_list_tab_interceptor() {
+    fn test_shift_tab_routes_to_shared_ai_script_generation_handler() {
         let startup_tab = fs::read_to_string("src/app_impl/startup_new_tab.rs")
             .expect("Failed to read src/app_impl/startup_new_tab.rs");
 
         assert!(
             startup_tab.contains("if has_shift")
-                && startup_tab.contains("this.generate_script_from_ai_prompt(query, cx);"),
-            "Shift+Tab in ScriptList should route to generate_script_from_ai_prompt. \
+                && startup_tab.contains("this.dispatch_ai_script_generation_from_query(query, cx);"),
+            "Shift+Tab in ScriptList should route to dispatch_ai_script_generation_from_query. \
              Missing expected branch in startup_new_tab.rs"
         );
     }
 
     #[test]
+    fn test_generate_script_builtin_routes_to_shared_ai_script_generation_handler() {
+        let builtin_execution = fs::read_to_string("src/app_execute/builtin_execution.rs")
+            .expect("Failed to read src/app_execute/builtin_execution.rs");
+
+        assert!(
+            builtin_execution.contains("self.dispatch_ai_script_generation_from_query(query, cx);"),
+            "Generate Script built-in should route to dispatch_ai_script_generation_from_query"
+        );
+    }
+
+    #[test]
     fn test_tab_still_routes_to_inline_ai_chat_in_script_list_tab_interceptor() {
         let startup_tab = fs::read_to_string("src/app_impl/startup_new_tab.rs")
             .expect("Failed to read src/app_impl/startup_new_tab.rs");
diff --git a/src/main_sections/fallbacks.rs b/src/main_sections/fallbacks.rs
index 7742144684c5c00faffe448c3939b7b4517276bd..5b3881467e2ce686581f30b828f5d44849dcad56
--- a/src/main_sections/fallbacks.rs
+++ b/src/main_sections/fallbacks.rs
@@ -160,7 +160,7 @@
                         return;
                     };
 
-                    app.execute_builtin(&entry, cx);
+                    app.execute_builtin_with_query(&entry, Some(input), cx);
                 }
             }
         }

 exited 101 in 17.80s:
    Checking script-kit-gpui v0.1.0 (/Users/johnlindquist/dev/script-kit-gpui)
error[E0761]: file for module `tests` found at both "src/protocol/message/tests.rs" and "src/protocol/message/tests/mod.rs"
  --> src/protocol/message/mod.rs:87:1
   |
87 | mod tests;
   | ^^^^^^^^^^
   |
   = help: delete or rename one of them to remove the ambiguity

error[E0761]: file for module `tests` found at both "src/designs/core/tests.rs" and "src/designs/core/tests/mod.rs"
 --> src/designs/core/part_04.rs:2:1
  |
2 | mod tests;
  | ^^^^^^^^^^
  |
  = help: delete or rename one of them to remove the ambiguity

error: glob import doesn't reexport anything with visibility `pub(in crate::prompts)` because no imported item is public enough
  --> src/prompts/div/mod.rs:32:16
   |

thinking
**Verifying successful build and formatting**
exec
/bin/zsh -lc 'git diff -- src/app_impl/prompt_ai.rs src/app_execute/builtin_execution.rs src/app_impl/selection_fallback.rs src/app_impl/startup.rs src/app_impl/startup_new_tab.rs src/main_sections/fallbacks.rs src/app_impl/tests.rs' in /Users/johnlindquist/dev/script-kit-gpui succeeded in 51ms:
Total output lines: 1128

diff --git a/src/app_execute/builtin_execution.rs b/src/app_execute/builtin_execution.rs
index c141cbd..9c0181e 100644
--- a/src/app_execute/builtin_execution.rs
+++ b/src/app_execute/builtin_execution.rs
@@ -10,6 +10,102 @@ fn favorites_loaded_message(count: usize) -> String {
     }
 }
 
+#[cfg(target_os = "macos")]
+fn applescript_escape(text: &str) -> String {
+    text.replace('\\', "\\\\").replace('"', "\\\"")
+}
+
+#[cfg(target_os = "macos")]
+fn applescript_list_literal(values: &[String]) -> String {
+    let escaped_values = values
+        .iter()
+        .map(|value| format!("\"{}\"", applescript_escape(value)))
file update:
diff --git a/src/app_execute/builtin_execution.rs b/src/app_execute/builtin_execution.rs
index dbce42e2664627892bed0da4fee92f6621cd2afd..9c0181eecf499492796afa9819219127d9c04de7
--- a/src/app_execute/builtin_execution.rs
+++ b/src/app_execute/builtin_execution.rs
@@ -122,6 +122,15 @@
     }
 
     fn execute_builtin(&mut self, entry: &builtins::BuiltInEntry, cx: &mut Context<Self>) {
+        self.execute_builtin_with_query(entry, None, cx);
+    }
+
+    fn execute_builtin_with_query(
+        &mut self,
+        entry: &builtins::BuiltInEntry,
+        query_override: Option<&str>,
+        cx: &mut Context<Self>,
+    ) {
         logging::log(
             "EXEC",
             &format!("Executing built-in: {} (id: {})", entry.name, entry.id),
@@ -1023,8 +1032,8 @@
                     }
 
                     AiCommandType::GenerateScript => {
-                        let query = self.filter_text.trim().to_string();
-                        self.show_script_generation_chat(Some(query), cx);
+                        let query = query_override.unwrap_or(&self.filter_text).to_string();
+                        self.dispatch_ai_script_generation_from_query(query, cx);
                     }
 
                     AiCommandType::SendScreenToAi => {
diff --git a/src/app_impl/prompt_ai.rs b/src/app_impl/prompt_ai.rs
index 6c10ca4234dc2d80bb14bc0d5163caddf97656cc..f79076d6b5977825788241f2ece9814c6754a4c6
--- a/src/app_impl/prompt_ai.rs
+++ b/src/app_impl/prompt_ai.rs
@@ -638,6 +638,24 @@
         cx.notify();
     }
 
+    pub(crate) fn dispatch_ai_script_generation_from_query(
+        &mut self,
+        query: String,
+        cx: &mut Context<Self>,
+    ) {
+        let query = query.trim().to_string();
+        if query.is_empty() {
+            logging::log(
+                "AI_SCRIPT_GEN",
+                "state=ignored attempted=dispatch_ai_script_generation_from_query reason=empty_query",
+            );
+            return;
+        }
+
+        self.filter_text.clear();
+        self.show_script_generation_chat(Some(query), cx);
+    }
+
     /// Generate a Script Kit script from a natural-language prompt using the built-in AI backend.
     /// The generated script is saved to disk and opened in the configured editor.
     pub fn generate_script_from_ai_prompt(
diff --git a/src/app_impl/selection_fallback.rs b/src/app_impl/selection_fallback.rs
index 9dcd609c870dcb8be976ed0dac0045ff196f31e3..8473dc467e6038b38319848a8da32f9997b36b36
--- a/src/app_impl/selection_fallback.rs
+++ b/src/app_impl/selection_fallback.rs
@@ -11,6 +11,16 @@
     }
 }
 
+fn fallback_keeps_window_open(fallback: &crate::fallbacks::FallbackItem) -> bool {
+    match fallback {
+        crate::fallbacks::FallbackItem::Builtin(builtin) => matches!(
+            builtin.id,
+            "run-in-terminal" | "search-files" | "builtin-generate-script-with-ai"
+        ),
+        crate::fallbacks::FallbackItem::Script(_) => true,
+    }
+}
+
 impl ScriptListApp {
     #[allow(dead_code)]
     pub(crate) fn filtered_scripts(&self) -> Vec<Arc<scripts::Script>> {
@@ -219,14 +229,7 @@
             ),
         );
 
-        // Check if this is a "stay open" action (like run-in-terminal which opens a view)
-        // Check if this is a "stay open" action (opens its own view)
-        let should_close = match fallback {
-            crate::fallbacks::FallbackItem::Builtin(builtin) => {
-                !matches!(builtin.id, "run-in-terminal" | "search-files")
-            }
-            crate::fallbacks::FallbackItem::Script(_) => false,
-        };
+        let should_close = !fallback_keeps_window_open(fallback);
 
         // Execute the fallback action
         match fallback {
@@ -260,13 +263,7 @@
         {
             logging::log("EXEC", &format!("Executing fallback: {}", fallback.name()));
 
-            // Check if this is a "stay open" action (opens its own view)
-            let should_close = match &fallback {
-                crate::fallbacks::FallbackItem::Builtin(builtin) => {
-                    !matches!(builtin.id, "run-in-terminal" | "search-files")
-                }
-                crate::fallbacks::FallbackItem::Script(_) => false,
-            };
+            let should_close = !fallback_keeps_window_open(&fallback);
 
             // Execute the fallback action
             match &fallback {
@@ -399,7 +396,7 @@
                         return;
                     };
 
-                    self.execute_builtin(&entry, cx);
+                    self.execute_builtin_with_query(&entry, Some(input), cx);
                 }
             },
             Err(e) => {
@@ -450,4 +447,28 @@
 
         assert_eq!(resolve_grouped_result_index(&grouped_items, 0), None);
     }
+
+    #[test]
+    fn test_fallback_keeps_window_open_for_generate_script_builtin() {
+        let fallback = crate::fallbacks::FallbackItem::Builtin(
+            crate::fallbacks::builtins::get_builtin_fallbacks()
+                .into_iter()
+                .find(|fallback| fallback.id == "builtin-generate-script-with-ai")
+                .expect("generate-script fallback should exist"),
+        );
+
+        assert!(fallback_keeps_window_open(&fallback));
+    }
+
+    #[test]
+    fn test_fallback_keeps_window_open_is_false_for_regular_builtin() {
+        let fallback = crate::fallbacks::FallbackItem::Builtin(
+            crate::fallbacks::builtins::get_builtin_fallbacks()
+                .into_iter()
+                .find(|fallback| fallback.id == "search-google")
+                .expect("search-google fallback should exist"),
+        );
+
+        assert!(!fallback_keeps_window_open(&fallback));
+    }
 }
diff --git a/src/app_impl/startup.rs b/src/app_impl/startup.rs
index 4fd4dc8c23d8df925c657b8db59f888b855ea6a2..670e087da31d4d0b4c8e21cebc48b3533817041f
--- a/src/app_impl/startup.rs
+++ b/src/app_impl/startup.rs
@@ -730,12 +730,11 @@
                             {
                                 let query = this.filter_text.clone();
 
-                                // Clear filter text before switching view
-                                this.filter_text.clear();
-
                                 if has_shift {
-                                    this.show_script_generation_chat(Some(query), cx);
+                                    this.dispatch_ai_script_generation_from_query(query, cx);
                                 } else {
+                                    // Clear filter text before switching view
+                                    this.filter_text.clear();
                                     // Show inline AI chat with the query as initial input
                                     this.show_inline_ai_chat(Some(query), cx);
                                 }
diff --git a/src/app_impl/startup_new_tab.rs b/src/app_impl/startup_new_tab.rs
index c75a27bf67a5448f59c7700079e8818210722bde..362ad2dcbf87a3a7e4476dcae211899dd788f079
--- a/src/app_impl/startup_new_tab.rs
+++ b/src/app_impl/startup_new_tab.rs
@@ -181,12 +181,11 @@
                             {
                                 let query = this.filter_text.clone();
 
-                                // Clear filter text before switching view
-                                this.filter_text.clear();
-
                                 if has_shift {
-                                    this.show_script_generation_chat(Some(query), cx);
+                                    this.dispatch_ai_script_generation_from_query(query, cx);
                                 } else {
+                                    // Clear filter text before switching view
+                                    this.filter_text.clear();
                                     // Show inline AI chat with the query as initial input
                                     this.show_inline_ai_chat(Some(query), cx);
                                 }
diff --git a/src/app_impl/tests.rs b/src/app_impl/tests.rs
index 3f0fbd1ccbc2f1e3d515ac1edf9666035f09eaf4..8458f7cda5196dcf4ef3413b30efe4d33ce54c11
--- a/src/app_impl/tests.rs
+++ b/src/app_impl/tests.rs
@@ -49,19 +49,30 @@
     }
 
     #[test]
-    fn test_shift_tab_routes_to_ai_script_generation_in_script_list_tab_interceptor() {
+    fn test_shift_tab_routes_to_shared_ai_script_generation_handler() {
         let startup_tab = fs::read_to_string("src/app_impl/startup_new_tab.rs")
             .expect("Failed to read src/app_impl/startup_new_tab.rs");
 
         assert!(
             startup_tab.contains("if has_shift")
-                && startup_tab.contains("this.generate_script_from_ai_prompt(query, cx);"),
-            "Shift+Tab in ScriptList should route to generate_script_from_ai_prompt. \
+                && startup_tab.contains("this.dispatch_ai_script_generation_from_query(query, cx);"),
+            "Shift+Tab in ScriptList should route to dispatch_ai_script_generation_from_query. \
              Missing expected branch in startup_new_tab.rs"
         );
     }
 
     #[test]
+    fn test_generate_script_builtin_routes_to_shared_ai_script_generation_handler() {
+        let builtin_execution = fs::read_to_string("src/app_execute/builtin_execution.rs")
+            .expect("Failed to read src/app_execute/builtin_execution.rs");
+
+        assert!(
+            builtin_execution.contains("self.dispatch_ai_script_generation_from_query(query, cx);"),
+            "Generate Script built-in should route to dispatch_ai_script_generation_from_query"
+        );
+    }
+
+    #[test]
     fn test_tab_still_routes_to_inline_ai_chat_in_script_list_tab_interceptor() {
         let startup_tab = fs::read_to_string("src/app_impl/startup_new_tab.rs")
             .expect("Failed to read src/app_impl/startup_new_tab.rs");
diff --git a/src/main_sections/fallbacks.rs b/src/main_sections/fallbacks.rs
index 7742144684c5c00faffe448c3939b7b4517276bd..5b3881467e2ce686581f30b828f5d44849dcad56
--- a/src/main_sections/fallbacks.rs
+++ b/src/main_sections/fallbacks.rs
@@ -160,7 +160,7 @@
                         return;
                     };
 
-                    app.execute_builtin(&entry, cx);
+                    app.execute_builtin_with_query(&entry, Some(input), cx);
                 }
             }
         }


thinking
**Investigating concurrent file modifications**
exec
/bin/zsh -lc "sed -n '710,770p' src/app_impl/startup.rs" in /Users/johnlindquist/dev/script-kit-gpuiexec
/bin/zsh -lc "sed -n '1000,1060p' src/app_execute/builtin_execution.rs" in /Users/johnlindquist/dev/script-kit-gpuiexec
/bin/zsh -lc "sed -n '640,710p' src/app_impl/prompt_ai.rs" in /Users/johnlindquist/dev/script-kit-gpuiexec
/bin/zsh -lc "sed -n '110,170p' src/app_execute/builtin_execution.rs" in /Users/johnlindquist/dev/script-kit-gpuiexec
/bin/zsh -lc "sed -n '166,210p' src/app_impl/startup_new_tab.rs" in /Users/johnlindquist/dev/script-kit-gpuiexec
/bin/zsh -lc "sed -n '350,430p' src/app_impl/selection_fallback.rs" in /Users/johnlindquist/dev/script-kit-gpuiexec
/bin/zsh -lc "sed -n '1,80p' src/app_impl/selection_fallback.rs" in /Users/johnlindquist/dev/script-kit-gpuiexec
/bin/zsh -lc "sed -n '40,120p' src/app_impl/tests.rs" in /Users/johnlindquist/dev/script-kit-gpuiexec
/bin/zsh -lc "sed -n '214,320p' src/app_impl/selection_fallback.rs" in /Users/johnlindquist/dev/script-kit-gpuiexec
/bin/zsh -lc "sed -n '120,200p' src/main_sections/fallbacks.rs" in /Users/johnlindquist/dev/script-kit-gpui succeeded in 51ms:
                            let message = calculate_fallback_error_message(&expression);
                            crate::hud_manager::show_hud(message, Some(3000), cx);
                        }
                    }
                }
                FallbackResult::OpenFile { path } => {
                    logging::log("FALLBACK", &format!("OpenFile: {}", path));
                    let expanded = if path.starts_with("~") {
                        if let Some(home) = dirs::home_dir() {
                            path.replacen("~", &home.to_string_lossy(), 1)
                        } else {
                            path.clone()
                        }
                    } else {
                        path.clone()
                    };
                    let _ = open::that(&expanded);
                }
                FallbackResult::SearchFiles { query } => {
                    logging::log("FALLBACK", &format!("SearchFiles: {}", query));
 succeeded in 52ms:

    pub(crate) fn dispatch_ai_script_generation_from_query(
        &mut self,
        query: String,
        cx: &mut Context<Self>,
    ) {
        let query = query.trim().to_string();
        if query.is_empty() {
            logging::log(
                "AI_SCRIPT_GEN",
                "state=ignored attempted=dispatch_ai_script_generation_from_query reason=empty_query",
            );
            return;
        }

        self.filter_text.clear();
        self.show_script_generation_chat(Some(query), cx);
    }

    /// Generate a Script Kit script from a natural-language prompt using the built-in AI backend.
 succeeded in 52ms:
    fn system_action_feedback_message(
        &self,
        action_type: &builtins::SystemActionType,
    ) -> Option<String> {
        let dark_mode_enabled = if matches!(action_type, builtins::SystemActionType::ToggleDarkMode)
        {
            system_actions::is_dark_mode().ok()
        } else {
            None
        };

        builtins::system_action_hud_message(*action_type, dark_mode_enabled)
    }

    fn execute_builtin(&mut self, entry: &builtins::BuiltInEntry, cx: &mut Context<Self>) {
        self.execute_builtin_with_query(entry, None, cx);
    }

    fn execute_builtin_with_query(
        &mut self,
 succeeded in 52ms:
                            if let AppView::ChatPrompt { entity, .. } = &this.current_view {
                                let handled = entity.update(cx, |chat, cx| {
                                    chat.handle_setup_key("tab", has_shift, cx)
                                });
                                if handled {
                                    cx.stop_propagation();
                                    return;
                                }
                            }

                            // Handle Tab/Shift+Tab in ScriptList view for AI actions.
                            // Tab opens Ask AI chat, Shift+Tab opens script generation chat mode.
                            if matches!(this.current_view, AppView::ScriptList)
                                && !this.filter_text.is_empty()
                                && !this.show_actions_popup
                            {
                                let query = this.filter_text.clone();

                                if has_shift {
                                    this.dispatch_ai_script_generation_from_query(query, cx);
 succeeded in 52ms:
                                return;
                            }

                            // Handle Tab/Shift+Tab in ChatPrompt setup mode
                            // Must intercept here to prevent GPUI focus traversal from consuming Tab
                            if let AppView::ChatPrompt { entity, .. } = &this.current_view {
                                let handled = entity.update(cx, |chat, cx| {
                                    chat.handle_setup_key("tab", has_shift, cx)
                                });
                                if handled {
                                    cx.stop_propagation();
                                    return;
                                }
                            }

                            // Handle Tab/Shift+Tab in ScriptList view for AI actions.
                            // Tab opens Ask AI chat, Shift+Tab opens script generation chat mode.
                            if matches!(this.current_view, AppView::ScriptList)
                                && !this.filter_text.is_empty()
                                && !this.show_actions_popup
 succeeded in 52ms:
                                            format!(
                                                "AI history cleared, but failed to open AI: {}",
                                                e
                                            ),
                                            &self.theme,
                                        )
                                        .duration_ms(Some(5000)),
                                    );
                                    cx.notify();
                                } else {
                                    self.show_hud(
                                        "Cleared AI conversations".to_string(),
                                        Some(2000),
                                        cx,
                                    );
                                }
                            }
                            Err(e) => {
                                logging::log(
                                    "ERROR",
 succeeded in 51ms:
    /// Execute a fallback item (from the "Use with..." section in search results)
    /// This is called when a fallback is selected from the grouped list
    pub fn execute_fallback_item(
        &mut self,
        fallback: &crate::fallbacks::FallbackItem,
        cx: &mut Context<Self>,
    ) {
        let input = self.filter_text.clone();

        logging::log(
            "EXEC",
            &format!(
                "Executing fallback item: {} with input: '{}'",
                fallback.name(),
                input
            ),
        );

        let should_close = !fallback_keeps_window_open(fallback);

 succeeded in 51ms:
        assert_eq!(selected_index, 0);
    }

    #[test]
    fn test_calculate_fallback_error_message_includes_expression_and_recovery() {
        let message = calculate_fallback_error_message("2 + )");
        assert!(message.contains("2 + )"));
        assert!(message.contains("Could not evaluate expression"));
        assert!(message.contains("Check the syntax and try again"));
    }

    #[test]
    fn test_shift_tab_routes_to_shared_ai_script_generation_handler() {
        let startup_tab = fs::read_to_string("src/app_impl/startup_new_tab.rs")
            .expect("Failed to read src/app_impl/startup_new_tab.rs");

        assert!(
            startup_tab.contains("if has_shift")
                && startup_tab.contains("this.dispatch_ai_script_generation_from_query(query, cx);"),
            "Shift+Tab in ScriptList should route to dispatch_ai_script_generation_from_query. \
 succeeded in 51ms:
use super::*;

fn resolve_grouped_result_index(
    grouped_items: &[GroupedListItem],
    selected_index: usize,
) -> Option<(usize, usize)> {
    let coerced_index = crate::list_item::coerce_selection(grouped_items, selected_index)?;
    match grouped_items.get(coerced_index) {
        Some(GroupedListItem::Item(result_idx)) => Some((coerced_index, *result_idx)),
        _ => None,
    }
}

fn fallback_keeps_window_open(fallback: &crate::fallbacks::FallbackItem) -> bool {
    match fallback {
        crate::fallbacks::FallbackItem::Builtin(builtin) => matches!(
            builtin.id,
            "run-in-terminal" | "search-files" | "builtin-generate-script-with-ai"
        ),
        crate::fallbacks::FallbackItem::Script(_) => true,
 succeeded in 50ms:
                    }
                }

                FallbackResult::OpenFile { path } => {
                    logging::log("FALLBACK", &format!("OpenFile: {}", path));
                    // Expand ~ to home directory
                    let expanded = shellexpand::tilde(&path).to_string();
                    // Open with default application
                    if let Err(e) = open::that(&expanded) {
                        logging::log("FALLBACK", &format!("Failed to open file: {}", e));
                    } else {
                        logging::log("FALLBACK", "File opened with default application");
                    }
                }

                FallbackResult::SearchFiles { query } => {
                    logging::log("FALLBACK", &format!("SearchFiles: {}", query));
                    app.open_file_search(query, cx);
                }

file update:
diff --git a/src/app_execute/builtin_execution.rs b/src/app_execute/builtin_execution.rs
index dbce42e2664627892bed0da4fee92f6621cd2afd..9c0181eecf499492796afa9819219127d9c04de7
--- a/src/app_execute/builtin_execution.rs
+++ b/src/app_execute/builtin_execution.rs
@@ -122,6 +122,15 @@
     }
 
     fn execute_builtin(&mut self, entry: &builtins::BuiltInEntry, cx: &mut Context<Self>) {
+        self.execute_builtin_with_query(entry, None, cx);
+    }
+
+    fn execute_builtin_with_query(
+        &mut self,
+        entry: &builtins::BuiltInEntry,
+        query_override: Option<&str>,
+        cx: &mut Context<Self>,
+    ) {
         logging::log(
             "EXEC",
             &format!("Executing built-in: {} (id: {})", entry.name, entry.id),
@@ -1023,8 +1032,8 @@
                     }
 
                     AiCommandType::GenerateScript => {
-                        let query = self.filter_text.trim().to_string();
-                        self.show_script_generation_chat(Some(query), cx);
+                        let query = query_override.unwrap_or(&self.filter_text).to_string();
+                        self.dispatch_ai_script_generation_from_query(query, cx);
                     }
 
                     AiCommandType::SendScreenToAi => {
diff --git a/src/app_impl/prompt_ai.rs b/src/app_impl/prompt_ai.rs
index 6c10ca4234dc2d80bb14bc0d5163caddf97656cc..f79076d6b5977825788241f2ece9814c6754a4c6
--- a/src/app_impl/prompt_ai.rs
+++ b/src/app_impl/prompt_ai.rs
@@ -638,6 +638,24 @@
         cx.notify();
     }
 
+    pub(crate) fn dispatch_ai_script_generation_from_query(
+        &mut self,
+        query: String,
+        cx: &mut Context<Self>,
+    ) {
+        let query = query.trim().to_string();
+        if query.is_empty() {
+            logging::log(
+                "AI_SCRIPT_GEN",
+                "state=ignored attempted=dispatch_ai_script_generation_from_query reason=empty_query",
+            );
+            return;
+        }
+
+        self.filter_text.clear();
+        self.show_script_generation_chat(Some(query), cx);
+    }
+
     /// Generate a Script Kit script from a natural-language prompt using the built-in AI backend.
     /// The generated script is saved to disk and opened in the configured editor.
     pub fn generate_script_from_ai_prompt(
diff --git a/src/app_impl/selection_fallback.rs b/src/app_impl/selection_fallback.rs
index 9dcd609c870dcb8be976ed0dac0045ff196f31e3..8473dc467e6038b38319848a8da32f9997b36b36
--- a/src/app_impl/selection_fallback.rs
+++ b/src/app_impl/selection_fallback.rs
@@ -11,6 +11,16 @@
     }
 }
 
+fn fallback_keeps_window_open(fallback: &crate::fallbacks::FallbackItem) -> bool {
+    match fallback {
+        crate::fallbacks::FallbackItem::Builtin(builtin) => matches!(
+            builtin.id,
+            "run-in-terminal" | "search-files" | "builtin-generate-script-with-ai"
+        ),
+        crate::fallbacks::FallbackItem::Script(_) => true,
+    }
+}
+
 impl ScriptListApp {
     #[allow(dead_code)]
     pub(crate) fn filtered_scripts(&self) -> Vec<Arc<scripts::Script>> {
@@ -219,14 +229,7 @@
             ),
         );
 
-        // Check if this is a "stay open" action (like run-in-terminal which opens a view)
-        // Check if this is a "stay open" action (opens its own view)
-        let should_close = match fallback {
-            crate::fallbacks::FallbackItem::Builtin(builtin) => {
-                !matches!(builtin.id, "run-in-terminal" | "search-files")
-            }
-            crate::fallbacks::FallbackItem::Script(_) => false,
-        };
+        let should_close = !fallback_keeps_window_open(fallback);
 
         // Execute the fallback action
         match fallback {
@@ -260,13 +263,7 @@
         {
             logging::log("EXEC", &format!("Executing fallback: {}", fallback.name()));
 
-            // Check if this is a "stay open" action (opens its own view)
-            let should_close = match &fallback {
-                crate::fallbacks::FallbackItem::Builtin(builtin) => {
-                    !matches!(builtin.id, "run-in-terminal" | "search-files")
-                }
-                crate::fallbacks::FallbackItem::Script(_) => false,
-            };
+            let should_close = !fallback_keeps_window_open(&fallback);
 
             // Execute the fallback action
             match &fallback {
@@ -399,7 +396,7 @@
                         return;
                     };
 
-                    self.execute_builtin(&entry, cx);
+                    self.execute_builtin_with_query(&entry, Some(input), cx);
                 }
             },
             Err(e) => {
@@ -450,4 +447,28 @@
 
         assert_eq!(resolve_grouped_result_index(&grouped_items, 0), None);
     }
+
+    #[test]
+    fn test_fallback_keeps_window_open_for_generate_script_builtin() {
+        let fallback = crate::fallbacks::FallbackItem::Builtin(
+            crate::fallbacks::builtins::get_builtin_fallbacks()
+                .into_iter()
+                .find(|fallback| fallback.id == "builtin-generate-script-with-ai")
+                .expect("generate-script fallback should exist"),
+        );
+
+        assert!(fallback_keeps_window_open(&fallback));
+    }
+
+    #[test]
+    fn test_fallback_keeps_window_open_is_false_for_regular_builtin() {
+        let fallback = crate::fallbacks::FallbackItem::Builtin(
+            crate::fallbacks::builtins::get_builtin_fallbacks()
+                .into_iter()
+                .find(|fallback| fallback.id == "search-google")
+                .expect("search-google fallback should exist"),
+        );
+
+        assert!(!fallback_keeps_window_open(&fallback));
+    }
 }
diff --git a/src/app_impl/startup.rs b/src/app_impl/startup.rs
index 4fd4dc8c23d8df925c657b8db59f888b855ea6a2..670e087da31d4d0b4c8e21cebc48b3533817041f
--- a/src/app_impl/startup.rs
+++ b/src/app_impl/startup.rs
@@ -730,12 +730,11 @@
                             {
                                 let query = this.filter_text.clone();
 
-                                // Clear filter text before switching view
-                                this.filter_text.clear();
-
                                 if has_shift {
-                                    this.show_script_generation_chat(Some(query), cx);
+                                    this.dispatch_ai_script_generation_from_query(query, cx);
                                 } else {
+                                    // Clear filter text before switching view
+                                    this.filter_text.clear();
                                     // Show inline AI chat with the query as initial input
                                     this.show_inline_ai_chat(Some(query), cx);
                                 }
diff --git a/src/app_impl/startup_new_tab.rs b/src/app_impl/startup_new_tab.rs
index c75a27bf67a5448f59c7700079e8818210722bde..362ad2dcbf87a3a7e4476dcae211899dd788f079
--- a/src/app_impl/startup_new_tab.rs
+++ b/src/app_impl/startup_new_tab.rs
@@ -181,12 +181,11 @@
                             {
                                 let query = this.filter_text.clone();
 
-                                // Clear filter text before switching view
-                                this.filter_text.clear();
-
                                 if has_shift {
-                                    this.show_script_generation_chat(Some(query), cx);
+                                    this.dispatch_ai_script_generation_from_query(query, cx);
                                 } else {
+                                    // Clear filter text before switching view
+                                    this.filter_text.clear();
                                     // Show inline AI chat with the query as initial input
                                     this.show_inline_ai_chat(Some(query), cx);
                                 }
diff --git a/src/app_impl/tests.rs b/src/app_impl/tests.rs
index 3f0fbd1ccbc2f1e3d515ac1edf9666035f09eaf4..8458f7cda5196dcf4ef3413b30efe4d33ce54c11
--- a/src/app_impl/tests.rs
+++ b/src/app_impl/tests.rs
@@ -49,19 +49,30 @@
     }
 
     #[test]
-    fn test_shift_tab_routes_to_ai_script_generation_in_script_list_tab_interceptor() {
+    fn test_shift_tab_routes_to_shared_ai_script_generation_handler() {
         let startup_tab = fs::read_to_string("src/app_impl/startup_new_tab.rs")
             .expect("Failed to read src/app_impl/startup_new_tab.rs");
 
         assert!(
             startup_tab.contains("if has_shift")
-                && startup_tab.contains("this.generate_script_from_ai_prompt(query, cx);"),
-            "Shift+Tab in ScriptList should route to generate_script_from_ai_prompt. \
+                && startup_tab.contains("this.dispatch_ai_script_generation_from_query(query, cx);"),
+            "Shift+Tab in ScriptList should route to dispatch_ai_script_generation_from_query. \
              Missing expected branch in startup_new_tab.rs"
         );
     }
 
     #[test]
+    fn test_generate_script_builtin_routes_to_shared_ai_script_generation_handler() {
+        let builtin_execution = fs::read_to_string("src/app_execute/builtin_execution.rs")
+            .expect("Failed to read src/app_execute/builtin_execution.rs");
+
+        assert!(
+            builtin_execution.contains("self.dispatch_ai_script_generation_from_query(query, cx);"),
+            "Generate Script built-in should route to dispatch_ai_script_generation_from_query"
+        );
+    }
+
+    #[test]
     fn test_tab_still_routes_to_inline_ai_chat_in_script_list_tab_interceptor() {
         let startup_tab = fs::read_to_string("src/app_impl/startup_new_tab.rs")
             .expect("Failed to read src/app_impl/startup_new_tab.rs");
diff --git a/src/main_sections/fallbacks.rs b/src/main_sections/fallbacks.rs
index 7742144684c5c00faffe448c3939b7b4517276bd..5b3881467e2ce686581f30b828f5d44849dcad56
--- a/src/main_sections/fallbacks.rs
+++ b/src/main_sections/fallbacks.rs
@@ -160,7 +160,7 @@
                         return;
                     };
 
-                    app.execute_builtin(&entry, cx);
+                    app.execute_builtin_with_query(&entry, Some(input), cx);
                 }
             }
         }


thinking
**Verifying duplicate definitions**
exec
/bin/zsh -lc 'cargo check -p script-kit-gpui' in /Users/johnlindquist/dev/script-kit-gpui succeeded in 368ms:
warning: glob import doesn't reexport anything with visibility `pub(in crate::prompts)` because no imported item is public enough
  --> src/prompts/div/mod.rs:32:16
   |
32 | pub(super) use inline::*;
   |                ^^^^^^^^^
   |
note: the most public imported item is `pub(self)`
  --> src/prompts/div/mod.rs:32:16
   |
32 | pub(super) use inline::*;
   |                ^^^^^^^^^
   = help: reduce the glob import's visibility or increase visibility of imported items
   = note: `#[warn(unused_imports)]` (part of `#[warn(unused)]`) on by default

warning: glob import doesn't reexport anything with visibility `pub(in crate::prompts)` because no imported item is public enough
  --> src/prompts/div/mod.rs:34:16
   |
34 | pub(super) use render_html::*;
   |                ^^^^^^^^^^^^^^
   |
file update:
diff --git a/src/app_execute/builtin_execution.rs b/src/app_execute/builtin_execution.rs
index dbce42e2664627892bed0da4fee92f6621cd2afd..9c0181eecf499492796afa9819219127d9c04de7
--- a/src/app_execute/builtin_execution.rs
+++ b/src/app_execute/builtin_execution.rs
@@ -122,6 +122,15 @@
     }
 
     fn execute_builtin(&mut self, entry: &builtins::BuiltInEntry, cx: &mut Context<Self>) {
+        self.execute_builtin_with_query(entry, None, cx);
+    }
+
+    fn execute_builtin_with_query(
+        &mut self,
+        entry: &builtins::BuiltInEntry,
+        query_override: Option<&str>,
+        cx: &mut Context<Self>,
+    ) {
         logging::log(
             "EXEC",
             &format!("Executing built-in: {} (id: {})", entry.name, entry.id),
@@ -1023,8 +1032,8 @@
                     }
 
                     AiCommandType::GenerateScript => {
-                        let query = self.filter_text.trim().to_string();
-                        self.show_script_generation_chat(Some(query), cx);
+                        let query = query_override.unwrap_or(&self.filter_text).to_string();
+                        self.dispatch_ai_script_generation_from_query(query, cx);
                     }
 
                     AiCommandType::SendScreenToAi => {
diff --git a/src/app_impl/prompt_ai.rs b/src/app_impl/prompt_ai.rs
index 6c10ca4234dc2d80bb14bc0d5163caddf97656cc..f79076d6b5977825788241f2ece9814c6754a4c6
--- a/src/app_impl/prompt_ai.rs
+++ b/src/app_impl/prompt_ai.rs
@@ -638,6 +638,24 @@
         cx.notify();
     }
 
+    pub(crate) fn dispatch_ai_script_generation_from_query(
+        &mut self,
+        query: String,
+        cx: &mut Context<Self>,
+    ) {
+        let query = query.trim().to_string();
+        if query.is_empty() {
+            logging::log(
+                "AI_SCRIPT_GEN",
+                "state=ignored attempted=dispatch_ai_script_generation_from_query reason=empty_query",
+            );
+            return;
+        }
+
+        self.filter_text.clear();
+        self.show_script_generation_chat(Some(query), cx);
+    }
+
     /// Generate a Script Kit script from a natural-language prompt using the built-in AI backend.
     /// The generated script is saved to disk and opened in the configured editor.
     pub fn generate_script_from_ai_prompt(
diff --git a/src/app_impl/selection_fallback.rs b/src/app_impl/selection_fallback.rs
index 9dcd609c870dcb8be976ed0dac0045ff196f31e3..8473dc467e6038b38319848a8da32f9997b36b36
--- a/src/app_impl/selection_fallback.rs
+++ b/src/app_impl/selection_fallback.rs
@@ -11,6 +11,16 @@
     }
 }
 
+fn fallback_keeps_window_open(fallback: &crate::fallbacks::FallbackItem) -> bool {
+    match fallback {
+        crate::fallbacks::FallbackItem::Builtin(builtin) => matches!(
+            builtin.id,
+            "run-in-terminal" | "search-files" | "builtin-generate-script-with-ai"
+        ),
+        crate::fallbacks::FallbackItem::Script(_) => true,
+    }
+}
+
 impl ScriptListApp {
     #[allow(dead_code)]
     pub(crate) fn filtered_scripts(&self) -> Vec<Arc<scripts::Script>> {
@@ -219,14 +229,7 @@
             ),
         );
 
-        // Check if this is a "stay open" action (like run-in-terminal which opens a view)
-        // Check if this is a "stay open" action (opens its own view)
-        let should_close = match fallback {
-            crate::fallbacks::FallbackItem::Builtin(builtin) => {
-                !matches!(builtin.id, "run-in-terminal" | "search-files")
-            }
-            crate::fallbacks::FallbackItem::Script(_) => false,
-        };
+        let should_close = !fallback_keeps_window_open(fallback);
 
         // Execute the fallback action
         match fallback {
@@ -260,13 +263,7 @@
         {
             logging::log("EXEC", &format!("Executing fallback: {}", fallback.name()));
 
-            // Check if this is a "stay open" action (opens its own view)
-            let should_close = match &fallback {
-                crate::fallbacks::FallbackItem::Builtin(builtin) => {
-                    !matches!(builtin.id, "run-in-terminal" | "search-files")
-                }
-                crate::fallbacks::FallbackItem::Script(_) => false,
-            };
+            let should_close = !fallback_keeps_window_open(&fallback);
 
             // Execute the fallback action
             match &fallback {
@@ -399,7 +396,7 @@
                         return;
                     };
 
-                    self.execute_builtin(&entry, cx);
+                    self.execute_builtin_with_query(&entry, Some(input), cx);
                 }
             },
             Err(e) => {
@@ -450,4 +447,28 @@
 
         assert_eq!(resolve_grouped_result_index(&grouped_items, 0), None);
     }
+
+    #[test]
+    fn test_fallback_keeps_window_open_for_generate_script_builtin() {
+        let fallback = crate::fallbacks::FallbackItem::Builtin(
+            crate::fallbacks::builtins::get_builtin_fallbacks()
+                .into_iter()
+                .find(|fallback| fallback.id == "builtin-generate-script-with-ai")
+                .expect("generate-script fallback should exist"),
+        );
+
+        assert!(fallback_keeps_window_open(&fallback));
+    }
+
+    #[test]
+    fn test_fallback_keeps_window_open_is_false_for_regular_builtin() {
+        let fallback = crate::fallbacks::FallbackItem::Builtin(
+            crate::fallbacks::builtins::get_builtin_fallbacks()
+                .into_iter()
+                .find(|fallback| fallback.id == "search-google")
+                .expect("search-google fallback should exist"),
+        );
+
+        assert!(!fallback_keeps_window_open(&fallback));
+    }
 }
diff --git a/src/app_impl/startup.rs b/src/app_impl/startup.rs
index 4fd4dc8c23d8df925c657b8db59f888b855ea6a2..670e087da31d4d0b4c8e21cebc48b3533817041f
--- a/src/app_impl/startup.rs
+++ b/src/app_impl/startup.rs
@@ -730,12 +730,11 @@
                             {
                                 let query = this.filter_text.clone();
 
-                                // Clear filter text before switching view
-                                this.filter_text.clear();
-
                                 if has_shift {
-                                    this.show_script_generation_chat(Some(query), cx);
+                                    this.dispatch_ai_script_generation_from_query(query, cx);
                                 } else {
+                                    // Clear filter text before switching view
+                                    this.filter_text.clear();
                                     // Show inline AI chat with the query as initial input
                                     this.show_inline_ai_chat(Some(query), cx);
                                 }
diff --git a/src/app_impl/startup_new_tab.rs b/src/app_impl/startup_new_tab.rs
index c75a27bf67a5448f59c7700079e8818210722bde..362ad2dcbf87a3a7e4476dcae211899dd788f079
--- a/src/app_impl/startup_new_tab.rs
+++ b/src/app_impl/startup_new_tab.rs
@@ -181,12 +181,11 @@
                             {
                                 let query = this.filter_text.clone();
 
-                                // Clear filter text before switching view
-                                this.filter_text.clear();
-
                                 if has_shift {
-                                    this.show_script_generation_chat(Some(query), cx);
+                                    this.dispatch_ai_script_generation_from_query(query, cx);
                                 } else {
+                                    // Clear filter text before switching view
+                                    this.filter_text.clear();
                                     // Show inline AI chat with the query as initial input
                                     this.show_inline_ai_chat(Some(query), cx);
                                 }
diff --git a/src/app_impl/tests.rs b/src/app_impl/tests.rs
index 3f0fbd1ccbc2f1e3d515ac1edf9666035f09eaf4..8458f7cda5196dcf4ef3413b30efe4d33ce54c11
--- a/src/app_impl/tests.rs
+++ b/src/app_impl/tests.rs
@@ -49,19 +49,30 @@
     }
 
     #[test]
-    fn test_shift_tab_routes_to_ai_script_generation_in_script_list_tab_interceptor() {
+    fn test_shift_tab_routes_to_shared_ai_script_generation_handler() {
         let startup_tab = fs::read_to_string("src/app_impl/startup_new_tab.rs")
             .expect("Failed to read src/app_impl/startup_new_tab.rs");
 
         assert!(
             startup_tab.contains("if has_shift")
-                && startup_tab.contains("this.generate_script_from_ai_prompt(query, cx);"),
-            "Shift+Tab in ScriptList should route to generate_script_from_ai_prompt. \
+                && startup_tab.contains("this.dispatch_ai_script_generation_from_query(query, cx);"),
+            "Shift+Tab in ScriptList should route to dispatch_ai_script_generation_from_query. \
              Missing expected branch in startup_new_tab.rs"
         );
     }
 
     #[test]
+    fn test_generate_script_builtin_routes_to_shared_ai_script_generation_handler() {
+        let builtin_execution = fs::read_to_string("src/app_execute/builtin_execution.rs")
+            .expect("Failed to read src/app_execute/builtin_execution.rs");
+
+        assert!(
+            builtin_execution.contains("self.dispatch_ai_script_generation_from_query(query, cx);"),
+            "Generate Script built-in should route to dispatch_ai_script_generation_from_query"
+        );
+    }
+
+    #[test]
     fn test_tab_still_routes_to_inline_ai_chat_in_script_list_tab_interceptor() {
         let startup_tab = fs::read_to_string("src/app_impl/startup_new_tab.rs")
             .expect("Failed to read src/app_impl/startup_new_tab.rs");
diff --git a/src/main_sections/fallbacks.rs b/src/main_sections/fallbacks.rs
index 7742144684c5c00faffe448c3939b7b4517276bd..5b3881467e2ce686581f30b828f5d44849dcad56
--- a/src/main_sections/fallbacks.rs
+++ b/src/main_sections/fallbacks.rs
@@ -160,7 +160,7 @@
                         return;
                     };
 
-                    app.execute_builtin(&entry, cx);
+                    app.execute_builtin_with_query(&entry, Some(input), cx);
                 }
             }
         }


thinking
**Confirming test limitations and commit avoidance**
codex
Iâ€™ve completed the implementation edits and confirmed they compile with `cargo check -p script-kit-gpui`. Iâ€™m now releasing my file claims and then Iâ€™ll summarize exactly what changed plus the verification limits caused by unrelated parallel-agent test breakages.

thinking
**Running update and release**
exec
/bin/zsh -lc '~/.claude/bin/swarm.ts update --id codex-ai-generate-fallback --status done --notes "Implemented shared AI script generation dispatch for Shift+Tab and builtin execution; fallback now forwards input query and keeps window open for generate-script builtin. Verified cargo check scoped; clippy/test blocked by unrelated parallel-agent compile failures." && ~/.claude/bin/swarm.ts release --id codex-ai-generate-fallback src/app_impl/prompt_ai.rs src/app_execute/builtin_execution.rs src/app_impl/selection_fallback.rs src/app_impl/startup.rs src/app_impl/startup_new_tab.rs src/main_sections/fallbacks.rs src/app_impl/tests.rs' in /Users/johnlindquist/dev/script-kit-gpui succeeded in 52ms:
Updated: codex-ai-generate-fallback
Released for codex-ai-generate-fallback: src/app_impl/prompt_ai.rs, src/app_execute/builtin_execution.rs, src/app_impl/selection_fallback.rs, src/app_impl/startup.rs, src/app_impl/startup_new_tab.rs, src/main_sections/fallbacks.rs, src/app_impl/tests.rs
file update:
diff --git a/src/app_execute/builtin_execution.rs b/src/app_execute/builtin_execution.rs
index dbce42e2664627892bed0da4fee92f6621cd2afd..9c0181eecf499492796afa9819219127d9c04de7
--- a/src/app_execute/builtin_execution.rs
+++ b/src/app_execute/builtin_execution.rs
@@ -122,6 +122,15 @@
     }
 
     fn execute_builtin(&mut self, entry: &builtins::BuiltInEntry, cx: &mut Context<Self>) {
+        self.execute_builtin_with_query(entry, None, cx);
+    }
+
+    fn execute_builtin_with_query(
+        &mut self,
+        entry: &builtins::BuiltInEntry,
+        query_override: Option<&str>,
+        cx: &mut Context<Self>,
+    ) {
         logging::log(
             "EXEC",
             &format!("Executing built-in: {} (id: {})", entry.name, entry.id),
@@ -1023,8 +1032,8 @@
                     }
 
                     AiCommandType::GenerateScript => {
-                        let query = self.filter_text.trim().to_string();
-                        self.show_script_generation_chat(Some(query), cx);
+                        let query = query_override.unwrap_or(&self.filter_text).to_string();
+                        self.dispatch_ai_script_generation_from_query(query, cx);
                     }
 
                     AiCommandType::SendScreenToAi => {
diff --git a/src/app_impl/prompt_ai.rs b/src/app_impl/prompt_ai.rs
index 6c10ca4234dc2d80bb14bc0d5163caddf97656cc..f79076d6b5977825788241f2ece9814c6754a4c6
--- a/src/app_impl/prompt_ai.rs
+++ b/src/app_impl/prompt_ai.rs
@@ -638,6 +638,24 @@
         cx.notify();
     }
 
+    pub(crate) fn dispatch_ai_script_generation_from_query(
+        &mut self,
+        query: String,
+        cx: &mut Context<Self>,
+    ) {
+        let query = query.trim().to_string();
+        if query.is_empty() {
+            logging::log(
+                "AI_SCRIPT_GEN",
+                "state=ignored attempted=dispatch_ai_script_generation_from_query reason=empty_query",
+            );
+            return;
+        }
+
+        self.filter_text.clear();
+        self.show_script_generation_chat(Some(query), cx);
+    }
+
     /// Generate a Script Kit script from a natural-language prompt using the built-in AI backend.
     /// The generated script is saved to disk and opened in the configured editor.
     pub fn generate_script_from_ai_prompt(
diff --git a/src/app_impl/selection_fallback.rs b/src/app_impl/selection_fallback.rs
index 9dcd609c870dcb8be976ed0dac0045ff196f31e3..8473dc467e6038b38319848a8da32f9997b36b36
--- a/src/app_impl/selection_fallback.rs
+++ b/src/app_impl/selection_fallback.rs
@@ -11,6 +11,16 @@
     }
 }
 
+fn fallback_keeps_window_open(fallback: &crate::fallbacks::FallbackItem) -> bool {
+    match fallback {
+        crate::fallbacks::FallbackItem::Builtin(builtin) => matches!(
+            builtin.id,
+            "run-in-terminal" | "search-files" | "builtin-generate-script-with-ai"
+        ),
+        crate::fallbacks::FallbackItem::Script(_) => true,
+    }
+}
+
 impl ScriptListApp {
     #[allow(dead_code)]
     pub(crate) fn filtered_scripts(&self) -> Vec<Arc<scripts::Script>> {
@@ -219,14 +229,7 @@
             ),
         );
 
-        // Check if this is a "stay open" action (like run-in-terminal which opens a view)
-        // Check if this is a "stay open" action (opens its own view)
-        let should_close = match fallback {
-            crate::fallbacks::FallbackItem::Builtin(builtin) => {
-                !matches!(builtin.id, "run-in-terminal" | "search-files")
-            }
-            crate::fallbacks::FallbackItem::Script(_) => false,
-        };
+        let should_close = !fallback_keeps_window_open(fallback);
 
         // Execute the fallback action
         match fallback {
@@ -260,13 +263,7 @@
         {
             logging::log("EXEC", &format!("Executing fallback: {}", fallback.name()));
 
-            // Check if this is a "stay open" action (opens its own view)
-            let should_close = match &fallback {
-                crate::fallbacks::FallbackItem::Builtin(builtin) => {
-                    !matches!(builtin.id, "run-in-terminal" | "search-files")
-                }
-                crate::fallbacks::FallbackItem::Script(_) => false,
-            };
+            let should_close = !fallback_keeps_window_open(&fallback);
 
             // Execute the fallback action
             match &fallback {
@@ -399,7 +396,7 @@
                         return;
                     };
 
-                    self.execute_builtin(&entry, cx);
+                    self.execute_builtin_with_query(&entry, Some(input), cx);
                 }
             },
             Err(e) => {
@@ -450,4 +447,28 @@
 
         assert_eq!(resolve_grouped_result_index(&grouped_items, 0), None);
     }
+
+    #[test]
+    fn test_fallback_keeps_window_open_for_generate_script_builtin() {
+        let fallback = crate::fallbacks::FallbackItem::Builtin(
+            crate::fallbacks::builtins::get_builtin_fallbacks()
+                .into_iter()
+                .find(|fallback| fallback.id == "builtin-generate-script-with-ai")
+                .expect("generate-script fallback should exist"),
+        );
+
+        assert!(fallback_keeps_window_open(&fallback));
+    }
+
+    #[test]
+    fn test_fallback_keeps_window_open_is_false_for_regular_builtin() {
+        let fallback = crate::fallbacks::FallbackItem::Builtin(
+            crate::fallbacks::builtins::get_builtin_fallbacks()
+                .into_iter()
+                .find(|fallback| fallback.id == "search-google")
+                .expect("search-google fallback should exist"),
+        );
+
+        assert!(!fallback_keeps_window_open(&fallback));
+    }
 }
diff --git a/src/app_impl/startup.rs b/src/app_impl/startup.rs
index 4fd4dc8c23d8df925c657b8db59f888b855ea6a2..670e087da31d4d0b4c8e21cebc48b3533817041f
--- a/src/app_impl/startup.rs
+++ b/src/app_impl/startup.rs
@@ -730,12 +730,11 @@
                             {
                                 let query = this.filter_text.clone();
 
-                                // Clear filter text before switching view
-                                this.filter_text.clear();
-
                                 if has_shift {
-                                    this.show_script_generation_chat(Some(query), cx);
+                                    this.dispatch_ai_script_generation_from_query(query, cx);
                                 } else {
+                                    // Clear filter text before switching view
+                                    this.filter_text.clear();
                                     // Show inline AI chat with the query as initial input
                                     this.show_inline_ai_chat(Some(query), cx);
                                 }
diff --git a/src/app_impl/startup_new_tab.rs b/src/app_impl/startup_new_tab.rs
index c75a27bf67a5448f59c7700079e8818210722bde..362ad2dcbf87a3a7e4476dcae211899dd788f079
--- a/src/app_impl/startup_new_tab.rs
+++ b/src/app_impl/startup_new_tab.rs
@@ -181,12 +181,11 @@
                             {
                                 let query = this.filter_text.clone();
 
-                                // Clear filter text before switching view
-                                this.filter_text.clear();
-
                                 if has_shift {
-                                    this.show_script_generation_chat(Some(query), cx);
+                                    this.dispatch_ai_script_generation_from_query(query, cx);
                                 } else {
+                                    // Clear filter text before switching view
+                                    this.filter_text.clear();
                                     // Show inline AI chat with the query as initial input
                                     this.show_inline_ai_chat(Some(query), cx);
                                 }
diff --git a/src/app_impl/tests.rs b/src/app_impl/tests.rs
index 3f0fbd1ccbc2f1e3d515ac1edf9666035f09eaf4..8458f7cda5196dcf4ef3413b30efe4d33ce54c11
--- a/src/app_impl/tests.rs
+++ b/src/app_impl/tests.rs
@@ -49,19 +49,30 @@
     }
 
     #[test]
-    fn test_shift_tab_routes_to_ai_script_generation_in_script_list_tab_interceptor() {
+    fn test_shift_tab_routes_to_shared_ai_script_generation_handler() {
         let startup_tab = fs::read_to_string("src/app_impl/startup_new_tab.rs")
             .expect("Failed to read src/app_impl/startup_new_tab.rs");
 
         assert!(
             startup_tab.contains("if has_shift")
-                && startup_tab.contains("this.generate_script_from_ai_prompt(query, cx);"),
-            "Shift+Tab in ScriptList should route to generate_script_from_ai_prompt. \
+                && startup_tab.contains("this.dispatch_ai_script_generation_from_query(query, cx);"),
+            "Shift+Tab in ScriptList should route to dispatch_ai_script_generation_from_query. \
              Missing expected branch in startup_new_tab.rs"
         );
     }
 
     #[test]
+    fn test_generate_script_builtin_routes_to_shared_ai_script_generation_handler() {
+        let builtin_execution = fs::read_to_string("src/app_execute/builtin_execution.rs")
+            .expect("Failed to read src/app_execute/builtin_execution.rs");
+
+        assert!(
+            builtin_execution.contains("self.dispatch_ai_script_generation_from_query(query, cx);"),
+            "Generate Script built-in should route to dispatch_ai_script_generation_from_query"
+        );
+    }
+
+    #[test]
     fn test_tab_still_routes_to_inline_ai_chat_in_script_list_tab_interceptor() {
         let startup_tab = fs::read_to_string("src/app_impl/startup_new_tab.rs")
             .expect("Failed to read src/app_impl/startup_new_tab.rs");
diff --git a/src/main_sections/fallbacks.rs b/src/main_sections/fallbacks.rs
index 7742144684c5c00faffe448c3939b7b4517276bd..5b3881467e2ce686581f30b828f5d44849dcad56
--- a/src/main_sections/fallbacks.rs
+++ b/src/main_sections/fallbacks.rs
@@ -160,7 +160,7 @@
                         return;
                     };
 
-                    app.execute_builtin(&entry, cx);
+                    app.execute_builtin_with_query(&entry, Some(input), cx);
                 }
             }
         }


thinking
**Planning line reference gathering**
exec
/bin/zsh -lc "rg -n \"dispatch_ai_script_generation_from_query|execute_builtin_with_query\\(|fallback_keeps_window_open|builtin-generate-script-with-ai|execute_builtin_with_query\\(&entry, Some\\(input\\)|dispatch_ai_script_generation_from_query\\(query, cx\\)\" src/app_impl/prompt_ai.rs src/app_execute/builtin_execution.rs src/app_impl/selection_fallback.rs src/app_impl/startup.rs src/app_impl/startup_new_tab.rs src/main_sections/fallbacks.rs src/app_impl/tests.rs" in /Users/johnlindquist/dev/script-kit-gpui succeeded in 51ms:
src/app_execute/builtin_execution.rs:125:        self.execute_builtin_with_query(entry, None, cx);
src/app_execute/builtin_execution.rs:128:    fn execute_builtin_with_query(
src/app_execute/builtin_execution.rs:1036:                        self.dispatch_ai_script_generation_from_query(query, cx);
src/app_impl/selection_fallback.rs:14:fn fallback_keeps_window_open(fallback: &crate::fallbacks::FallbackItem) -> bool {
src/app_impl/selection_fallback.rs:18:            "run-in-terminal" | "search-files" | "builtin-generate-script-with-ai"
src/app_impl/selection_fallback.rs:232:        let should_close = !fallback_keeps_window_open(fallback);
src/app_impl/selection_fallback.rs:266:            let should_close = !fallback_keeps_window_open(&fallback);
src/app_impl/selection_fallback.rs:399:                    self.execute_builtin_with_query(&entry, Some(input), cx);
src/app_impl/selection_fallback.rs:452:    fn test_fallback_keeps_window_open_for_generate_script_builtin() {
src/app_impl/selection_fallback.rs:456:                .find(|fallback| fallback.id == "builtin-generate-script-with-ai")
src/app_impl/selection_fallback.rs:460:        assert!(fallback_keeps_window_open(&fallback));
src/app_impl/selection_fallback.rs:464:    fn test_fallback_keeps_window_open_is_false_for_regular_builtin() {
src/app_impl/selection_fallback.rs:472:        assert!(!fallback_keeps_window_open(&fallback));
src/app_impl/prompt_ai.rs:641:    pub(crate) fn dispatch_ai_script_generation_from_query(
src/app_impl/prompt_ai.rs:650:                "state=ignored attempted=dispatch_ai_script_generation_from_query reason=empty_query",
src/app_impl/startup_new_tab.rs:185:                                    this.dispatch_ai_script_generation_from_query(query, cx);
src/app_impl/startup.rs:734:                                    this.dispatch_ai_script_generation_from_query(query, cx);
src/main_sections/fallbacks.rs:163:                    app.execute_builtin_with_query(&entry, Some(input), cx);
src/app_impl/tests.rs:58:                && startup_tab.contains("this.dispatch_ai_script_generation_from_query(query, cx);"),
src/app_impl/tests.rs:59:            "Shift+Tab in ScriptList should route to dispatch_ai_script_generation_from_query. \
file update:
diff --git a/src/app_execute/builtin_execution.rs b/src/app_execute/builtin_execution.rs
index dbce42e2664627892bed0da4fee92f6621cd2afd..9c0181eecf499492796afa9819219127d9c04de7
--- a/src/app_execute/builtin_execution.rs
+++ b/src/app_execute/builtin_execution.rs
@@ -122,6 +122,15 @@
     }
 
     fn execute_builtin(&mut self, entry: &builtins::BuiltInEntry, cx: &mut Context<Self>) {
+        self.execute_builtin_with_query(entry, None, cx);
+    }
+
+    fn execute_builtin_with_query(
+        &mut self,
+        entry: &builtins::BuiltInEntry,
+        query_override: Option<&str>,
+        cx: &mut Context<Self>,
+    ) {
         logging::log(
             "EXEC",
             &format!("Executing built-in: {} (id: {})", entry.name, entry.id),
@@ -1023,8 +1032,8 @@
                     }
 
                     AiCommandType::GenerateScript => {
-                        let query = self.filter_text.trim().to_string();
-                        self.show_script_generation_chat(Some(query), cx);
+                        let query = query_override.unwrap_or(&self.filter_text).to_string();
+                        self.dispatch_ai_script_generation_from_query(query, cx);
                     }
 
                     AiCommandType::SendScreenToAi => {
diff --git a/src/app_impl/prompt_ai.rs b/src/app_impl/prompt_ai.rs
index 6c10ca4234dc2d80bb14bc0d5163caddf97656cc..f79076d6b5977825788241f2ece9814c6754a4c6
--- a/src/app_impl/prompt_ai.rs
+++ b/src/app_impl/prompt_ai.rs
@@ -638,6 +638,24 @@
         cx.notify();
     }
 
+    pub(crate) fn dispatch_ai_script_generation_from_query(
+        &mut self,
+        query: String,
+        cx: &mut Context<Self>,
+    ) {
+        let query = query.trim().to_string();
+        if query.is_empty() {
+            logging::log(
+                "AI_SCRIPT_GEN",
+                "state=ignored attempted=dispatch_ai_script_generation_from_query reason=empty_query",
+            );
+            return;
+        }
+
+        self.filter_text.clear();
+        self.show_script_generation_chat(Some(query), cx);
+    }
+
     /// Generate a Script Kit script from a natural-language prompt using the built-in AI backend.
     /// The generated script is saved to disk and opened in the configured editor.
     pub fn generate_script_from_ai_prompt(
diff --git a/src/app_impl/selection_fallback.rs b/src/app_impl/selection_fallback.rs
index 9dcd609c870dcb8be976ed0dac0045ff196f31e3..8473dc467e6038b38319848a8da32f9997b36b36
--- a/src/app_impl/selection_fallback.rs
+++ b/src/app_impl/selection_fallback.rs
@@ -11,6 +11,16 @@
     }
 }
 
+fn fallback_keeps_window_open(fallback: &crate::fallbacks::FallbackItem) -> bool {
+    match fallback {
+        crate::fallbacks::FallbackItem::Builtin(builtin) => matches!(
+            builtin.id,
+            "run-in-terminal" | "search-files" | "builtin-generate-script-with-ai"
+        ),
+        crate::fallbacks::FallbackItem::Script(_) => true,
+    }
+}
+
 impl ScriptListApp {
     #[allow(dead_code)]
     pub(crate) fn filtered_scripts(&self) -> Vec<Arc<scripts::Script>> {
@@ -219,14 +229,7 @@
             ),
         );
 
-        // Check if this is a "stay open" action (like run-in-terminal which opens a view)
-        // Check if this is a "stay open" action (opens its own view)
-        let should_close = match fallback {
-            crate::fallbacks::FallbackItem::Builtin(builtin) => {
-                !matches!(builtin.id, "run-in-terminal" | "search-files")
-            }
-            crate::fallbacks::FallbackItem::Script(_) => false,
-        };
+        let should_close = !fallback_keeps_window_open(fallback);
 
         // Execute the fallback action
         match fallback {
@@ -260,13 +263,7 @@
         {
             logging::log("EXEC", &format!("Executing fallback: {}", fallback.name()));
 
-            // Check if this is a "stay open" action (opens its own view)
-            let should_close = match &fallback {
-                crate::fallbacks::FallbackItem::Builtin(builtin) => {
-                    !matches!(builtin.id, "run-in-terminal" | "search-files")
-                }
-                crate::fallbacks::FallbackItem::Script(_) => false,
-            };
+            let should_close = !fallback_keeps_window_open(&fallback);
 
             // Execute the fallback action
             match &fallback {
@@ -399,7 +396,7 @@
                         return;
                     };
 
-                    self.execute_builtin(&entry, cx);
+                    self.execute_builtin_with_query(&entry, Some(input), cx);
                 }
             },
             Err(e) => {
@@ -450,4 +447,28 @@
 
         assert_eq!(resolve_grouped_result_index(&grouped_items, 0), None);
     }
+
+    #[test]
+    fn test_fallback_keeps_window_open_for_generate_script_builtin() {
+        let fallback = crate::fallbacks::FallbackItem::Builtin(
+            crate::fallbacks::builtins::get_builtin_fallbacks()
+                .into_iter()
+                .find(|fallback| fallback.id == "builtin-generate-script-with-ai")
+                .expect("generate-script fallback should exist"),
+        );
+
+        assert!(fallback_keeps_window_open(&fallback));
+    }
+
+    #[test]
+    fn test_fallback_keeps_window_open_is_false_for_regular_builtin() {
+        let fallback = crate::fallbacks::FallbackItem::Builtin(
+            crate::fallbacks::builtins::get_builtin_fallbacks()
+                .into_iter()
+                .find(|fallback| fallback.id == "search-google")
+                .expect("search-google fallback should exist"),
+        );
+
+        assert!(!fallback_keeps_window_open(&fallback));
+    }
 }
diff --git a/src/app_impl/startup.rs b/src/app_impl/startup.rs
index 4fd4dc8c23d8df925c657b8db59f888b855ea6a2..670e087da31d4d0b4c8e21cebc48b3533817041f
--- a/src/app_impl/startup.rs
+++ b/src/app_impl/startup.rs
@@ -730,12 +730,11 @@
                             {
                                 let query = this.filter_text.clone();
 
-                                // Clear filter text before switching view
-                                this.filter_text.clear();
-
                                 if has_shift {
-                                    this.show_script_generation_chat(Some(query), cx);
+                                    this.dispatch_ai_script_generation_from_query(query, cx);
                                 } else {
+                                    // Clear filter text before switching view
+                                    this.filter_text.clear();
                                     // Show inline AI chat with the query as initial input
                                     this.show_inline_ai_chat(Some(query), cx);
                                 }
diff --git a/src/app_impl/startup_new_tab.rs b/src/app_impl/startup_new_tab.rs
index c75a27bf67a5448f59c7700079e8818210722bde..362ad2dcbf87a3a7e4476dcae211899dd788f079
--- a/src/app_impl/startup_new_tab.rs
+++ b/src/app_impl/startup_new_tab.rs
@@ -181,12 +181,11 @@
                             {
                                 let query = this.filter_text.clone();
 
-                                // Clear filter text before switching view
-                                this.filter_text.clear();
-
                                 if has_shift {
-                                    this.show_script_generation_chat(Some(query), cx);
+                                    this.dispatch_ai_script_generation_from_query(query, cx);
                                 } else {
+                                    // Clear filter text before switching view
+                                    this.filter_text.clear();
                                     // Show inline AI chat with the query as initial input
                                     this.show_inline_ai_chat(Some(query), cx);
                                 }
diff --git a/src/app_impl/tests.rs b/src/app_impl/tests.rs
index 3f0fbd1ccbc2f1e3d515ac1edf9666035f09eaf4..8458f7cda5196dcf4ef3413b30efe4d33ce54c11
--- a/src/app_impl/tests.rs
+++ b/src/app_impl/tests.rs
@@ -49,19 +49,30 @@
     }
 
     #[test]
-    fn test_shift_tab_routes_to_ai_script_generation_in_script_list_tab_interceptor() {
+    fn test_shift_tab_routes_to_shared_ai_script_generation_handler() {
         let startup_tab = fs::read_to_string("src/app_impl/startup_new_tab.rs")
             .expect("Failed to read src/app_impl/startup_new_tab.rs");
 
         assert!(
             startup_tab.contains("if has_shift")
-                && startup_tab.contains("this.generate_script_from_ai_prompt(query, cx);"),
-            "Shift+Tab in ScriptList should route to generate_script_from_ai_prompt. \
+                && startup_tab.contains("this.dispatch_ai_script_generation_from_query(query, cx);"),
+            "Shift+Tab in ScriptList should route to dispatch_ai_script_generation_from_query. \
              Missing expected branch in startup_new_tab.rs"
         );
     }
 
     #[test]
+    fn test_generate_script_builtin_routes_to_shared_ai_script_generation_handler() {
+        let builtin_execution = fs::read_to_string("src/app_execute/builtin_execution.rs")
+            .expect("Failed to read src/app_execute/builtin_execution.rs");
+
+        assert!(
+            builtin_execution.contains("self.dispatch_ai_script_generation_from_query(query, cx);"),
+            "Generate Script built-in should route to dispatch_ai_script_generation_from_query"
+        );
+    }
+
+    #[test]
     fn test_tab_still_routes_to_inline_ai_chat_in_script_list_tab_interceptor() {
         let startup_tab = fs::read_to_string("src/app_impl/startup_new_tab.rs")
             .expect("Failed to read src/app_impl/startup_new_tab.rs");
diff --git a/src/main_sections/fallbacks.rs b/src/main_sections/fallbacks.rs
index 7742144684c5c00faffe448c3939b7b4517276bd..5b3881467e2ce686581f30b828f5d44849dcad56
--- a/src/main_sections/fallbacks.rs
+++ b/src/main_sections/fallbacks.rs
@@ -160,7 +160,7 @@
                         return;
                     };
 
-                    app.execute_builtin(&entry, cx);
+                    app.execute_builtin_with_query(&entry, Some(input), cx);
                 }
             }
         }


thinking
**Summarizing test results and changes**
codex
Implemented: `Generate Script with AI` now shares the same query-driven execution path as Shift+Tab, and fallback execution now forwards input text into built-in execution without immediately closing the window.

Changed files:
- `src/app_impl/prompt_ai.rs:641`
  - Added shared helper `dispatch_ai_script_generation_from_query(...)` (trim/empty guard + open script-generation chat from query).
- `src/app_execute/builtin_execution.rs:125`
  - Added `execute_builtin_with_query(...)`; `execute_builtin(...)` now delegates to it.
- `src/app_execute/builtin_execution.rs:1036`
  - `AiCommandType::GenerateScript` now routes through `dispatch_ai_script_generation_from_query(...)` using forwarded query when provided.
- `src/app_impl/startup.rs:734`
  - Shift+Tab now calls `dispatch_ai_script_generation_from_query(...)`.
- `src/app_impl/startup_new_tab.rs:185`
  - Same Shift+Tab routing update (kept in sync with interceptor reference file).
- `src/app_impl/selection_fallback.rs:14`
  - Added `fallback_keeps_window_open(...)` and treated `builtin-generate-script-with-ai` as stay-open.
- `src/app_impl/selection_fallback.rs:399`
  - `FallbackResult::ExecuteBuiltin` now calls `execute_builtin_with_query(&entry, Some(input), ...)`.
- `src/main_sections/fallbacks.rs:163`
  - Same fallback query-forwarding update for legacy fallback execution path.
- `src/app_impl/tests.rs:52`
  - Updated routing assertions to shared helper; added assertion that built-in Generate Script also routes to shared helper.
- `src/app_impl/selection_fallback.rs:452`
  - Added tests for keep-window-open behavior for generate-script fallback.

Verification run:
- `cargo check -p script-kit-gpui` âœ… passes.
- `cargo clippy -p script-kit-gpui --all-targets -- -D warnings` âŒ blocked by unrelated existing repo issues (for example duplicate test module files and many pre-existing lint/test errors outside this scope).
- Scoped test attempts (`cargo test -p script-kit-gpui app_impl_state_sync_tests::` and `cargo test -p script-kit-gpui --lib app_impl_state_sync_tests::`) âŒ blocked by unrelated existing compile failures in other test modules.

How to test manually:
1. Launch app and type prompt text in ScriptList (for example: `build a weather script`).
2. Press Shift+Tab.
3. Confirm script-generation chat opens using that prompt.
4. Return to ScriptList, type prompt text again, select fallback `Generate Script with AI`, press Enter.
5. Confirm behavior matches Shift+Tab (same flow, query preserved, window not immediately closed).

Risks / known gaps:
- Full clippy/test gate is currently not runnable in this shared tree due unrelated parallel-agent breakages; only scoped compile verification (`cargo check -p script-kit-gpui`) completed successfully.
file update:
diff --git a/src/app_execute/builtin_execution.rs b/src/app_execute/builtin_execution.rs
index dbce42e2664627892bed0da4fee92f6621cd2afd..9c0181eecf499492796afa9819219127d9c04de7
--- a/src/app_execute/builtin_execution.rs
+++ b/src/app_execute/builtin_execution.rs
@@ -122,6 +122,15 @@
     }
 
     fn execute_builtin(&mut self, entry: &builtins::BuiltInEntry, cx: &mut Context<Self>) {
+        self.execute_builtin_with_query(entry, None, cx);
+    }
+
+    fn execute_builtin_with_query(
+        &mut self,
+        entry: &builtins::BuiltInEntry,
+        query_override: Option<&str>,
+        cx: &mut Context<Self>,
+    ) {
         logging::log(
             "EXEC",
             &format!("Executing built-in: {} (id: {})", entry.name, entry.id),
@@ -1023,8 +1032,8 @@
                     }
 
                     AiCommandType::GenerateScript => {
-                        let query = self.filter_text.trim().to_string();
-                        self.show_script_generation_chat(Some(query), cx);
+                        let query = query_override.unwrap_or(&self.filter_text).to_string();
+                        self.dispatch_ai_script_generation_from_query(query, cx);
                     }
 
                     AiCommandType::SendScreenToAi => {
diff --git a/src/app_impl/prompt_ai.rs b/src/app_impl/prompt_ai.rs
index 6c10ca4234dc2d80bb14bc0d5163caddf97656cc..f79076d6b5977825788241f2ece9814c6754a4c6
--- a/src/app_impl/prompt_ai.rs
+++ b/src/app_impl/prompt_ai.rs
@@ -638,6 +638,24 @@
         cx.notify();
     }
 
+    pub(crate) fn dispatch_ai_script_generation_from_query(
+        &mut self,
+        query: String,
+        cx: &mut Context<Self>,
+    ) {
+        let query = query.trim().to_string();
+        if query.is_empty() {
+            logging::log(
+                "AI_SCRIPT_GEN",
+                "state=ignored attempted=dispatch_ai_script_generation_from_query reason=empty_query",
+            );
+            return;
+        }
+
+        self.filter_text.clear();
+        self.show_script_generation_chat(Some(query), cx);
+    }
+
     /// Generate a Script Kit script from a natural-language prompt using the built-in AI backend.
     /// The generated script is saved to disk and opened in the configured editor.
     pub fn generate_script_from_ai_prompt(
diff --git a/src/app_impl/selection_fallback.rs b/src/app_impl/selection_fallback.rs
index 9dcd609c870dcb8be976ed0dac0045ff196f31e3..8473dc467e6038b38319848a8da32f9997b36b36
--- a/src/app_impl/selection_fallback.rs
+++ b/src/app_impl/selection_fallback.rs
@@ -11,6 +11,16 @@
     }
 }
 
+fn fallback_keeps_window_open(fallback: &crate::fallbacks::FallbackItem) -> bool {
+    match fallback {
+        crate::fallbacks::FallbackItem::Builtin(builtin) => matches!(
+            builtin.id,
+            "run-in-terminal" | "search-files" | "builtin-generate-script-with-ai"
+        ),
+        crate::fallbacks::FallbackItem::Script(_) => true,
+    }
+}
+
 impl ScriptListApp {
     #[allow(dead_code)]
     pub(crate) fn filtered_scripts(&self) -> Vec<Arc<scripts::Script>> {
@@ -219,14 +229,7 @@
             ),
         );
 
-        // Check if this is a "stay open" action (like run-in-terminal which opens a view)
-        // Check if this is a "stay open" action (opens its own view)
-        let should_close = match fallback {
-            crate::fallbacks::FallbackItem::Builtin(builtin) => {
-                !matches!(builtin.id, "run-in-terminal" | "search-files")
-            }
-            crate::fallbacks::FallbackItem::Script(_) => false,
-        };
+        let should_close = !fallback_keeps_window_open(fallback);
 
         // Execute the fallback action
         match fallback {
@@ -260,13 +263,7 @@
         {
             logging::log("EXEC", &format!("Executing fallback: {}", fallback.name()));
 
-            // Check if this is a "stay open" action (opens its own view)
-            let should_close = match &fallback {
-                crate::fallbacks::FallbackItem::Builtin(builtin) => {
-                    !matches!(builtin.id, "run-in-terminal" | "search-files")
-                }
-                crate::fallbacks::FallbackItem::Script(_) => false,
-            };
+            let should_close = !fallback_keeps_window_open(&fallback);
 
             // Execute the fallback action
             match &fallback {
@@ -399,7 +396,7 @@
                         return;
                     };
 
-                    self.execute_builtin(&entry, cx);
+                    self.execute_builtin_with_query(&entry, Some(input), cx);
                 }
             },
             Err(e) => {
@@ -450,4 +447,28 @@
 
         assert_eq!(resolve_grouped_result_index(&grouped_items, 0), None);
     }
+
+    #[test]
+    fn test_fallback_keeps_window_open_for_generate_script_builtin() {
+        let fallback = crate::fallbacks::FallbackItem::Builtin(
+            crate::fallbacks::builtins::get_builtin_fallbacks()
+                .into_iter()
+                .find(|fallback| fallback.id == "builtin-generate-script-with-ai")
+                .expect("generate-script fallback should exist"),
+        );
+
+        assert!(fallback_keeps_window_open(&fallback));
+    }
+
+    #[test]
+    fn test_fallback_keeps_window_open_is_false_for_regular_builtin() {
+        let fallback = crate::fallbacks::FallbackItem::Builtin(
+            crate::fallbacks::builtins::get_builtin_fallbacks()
+                .into_iter()
+                .find(|fallback| fallback.id == "search-google")
+                .expect("search-google fallback should exist"),
+        );
+
+        assert!(!fallback_keeps_window_open(&fallback));
+    }
 }
diff --git a/src/app_impl/startup.rs b/src/app_impl/startup.rs
index 4fd4dc8c23d8df925c657b8db59f888b855ea6a2..670e087da31d4d0b4c8e21cebc48b3533817041f
--- a/src/app_impl/startup.rs
+++ b/src/app_impl/startup.rs
@@ -730,12 +730,11 @@
                             {
                                 let query = this.filter_text.clone();
 
-                                // Clear filter text before switching view
-                                this.filter_text.clear();
-
                                 if has_shift {
-                                    this.show_script_generation_chat(Some(query), cx);
+                                    this.dispatch_ai_script_generation_from_query(query, cx);
                                 } else {
+                                    // Clear filter text before switching view
+                                    this.filter_text.clear();
                                     // Show inline AI chat with the query as initial input
                                     this.show_inline_ai_chat(Some(query), cx);
                                 }
diff --git a/src/app_impl/startup_new_tab.rs b/src/app_impl/startup_new_tab.rs
index c75a27bf67a5448f59c7700079e8818210722bde..362ad2dcbf87a3a7e4476dcae211899dd788f079
--- a/src/app_impl/startup_new_tab.rs
+++ b/src/app_impl/startup_new_tab.rs
@@ -181,12 +181,11 @@
                             {
                                 let query = this.filter_text.clone();
 
-                                // Clear filter text before switching view
-                                this.filter_text.clear();
-
                                 if has_shift {
-                                    this.show_script_generation_chat(Some(query), cx);
+                                    this.dispatch_ai_script_generation_from_query(query, cx);
                                 } else {
+                                    // Clear filter text before switching view
+                                    this.filter_text.clear();
                                     // Show inline AI chat with the query as initial input
                                     this.show_inline_ai_chat(Some(query), cx);
                                 }
diff --git a/src/app_impl/tests.rs b/src/app_impl/tests.rs
index 3f0fbd1ccbc2f1e3d515ac1edf9666035f09eaf4..8458f7cda5196dcf4ef3413b30efe4d33ce54c11
--- a/src/app_impl/tests.rs
+++ b/src/app_impl/tests.rs
@@ -49,19 +49,30 @@
     }
 
     #[test]
-    fn test_shift_tab_routes_to_ai_script_generation_in_script_list_tab_interceptor() {
+    fn test_shift_tab_routes_to_shared_ai_script_generation_handler() {
         let startup_tab = fs::read_to_string("src/app_impl/startup_new_tab.rs")
             .expect("Failed to read src/app_impl/startup_new_tab.rs");
 
         assert!(
             startup_tab.contains("if has_shift")
-                && startup_tab.contains("this.generate_script_from_ai_prompt(query, cx);"),
-            "Shift+Tab in ScriptList should route to generate_script_from_ai_prompt. \
+                && startup_tab.contains("this.dispatch_ai_script_generation_from_query(query, cx);"),
+            "Shift+Tab in ScriptList should route to dispatch_ai_script_generation_from_query. \
              Missing expected branch in startup_new_tab.rs"
         );
     }
 
     #[test]
+    fn test_generate_script_builtin_routes_to_shared_ai_script_generation_handler() {
+        let builtin_execution = fs::read_to_string("src/app_execute/builtin_execution.rs")
+            .expect("Failed to read src/app_execute/builtin_execution.rs");
+
+        assert!(
+            builtin_execution.contains("self.dispatch_ai_script_generation_from_query(query, cx);"),
+            "Generate Script built-in should route to dispatch_ai_script_generation_from_query"
+        );
+    }
+
+    #[test]
     fn test_tab_still_routes_to_inline_ai_chat_in_script_list_tab_interceptor() {
         let startup_tab = fs::read_to_string("src/app_impl/startup_new_tab.rs")
             .expect("Failed to read src/app_impl/startup_new_tab.rs");
diff --git a/src/main_sections/fallbacks.rs b/src/main_sections/fallbacks.rs
index 7742144684c5c00faffe448c3939b7b4517276bd..5b3881467e2ce686581f30b828f5d44849dcad56
--- a/src/main_sections/fallbacks.rs
+++ b/src/main_sections/fallbacks.rs
@@ -160,7 +160,7 @@
                         return;
                     };
 
-                    app.execute_builtin(&entry, cx);
+                    app.execute_builtin_with_query(&entry, Some(input), cx);
                 }
             }
         }

tokens used
245,311
Implemented: `Generate Script with AI` now shares the same query-driven execution path as Shift+Tab, and fallback execution now forwards input text into built-in execution without immediately closing the window.

Changed files:
- `src/app_impl/prompt_ai.rs:641`
  - Added shared helper `dispatch_ai_script_generation_from_query(...)` (trim/empty guard + open script-generation chat from query).
- `src/app_execute/builtin_execution.rs:125`
  - Added `execute_builtin_with_query(...)`; `execute_builtin(...)` now delegates to it.
- `src/app_execute/builtin_execution.rs:1036`
  - `AiCommandType::GenerateScript` now routes through `dispatch_ai_script_generation_from_query(...)` using forwarded query when provided.
- `src/app_impl/startup.rs:734`
  - Shift+Tab now calls `dispatch_ai_script_generation_from_query(...)`.
- `src/app_impl/startup_new_tab.rs:185`
  - Same Shift+Tab routing update (kept in sync with interceptor reference file).
- `src/app_impl/selection_fallback.rs:14`
  - Added `fallback_keeps_window_open(...)` and treated `builtin-generate-script-with-ai` as stay-open.
- `src/app_impl/selection_fallback.rs:399`
  - `FallbackResult::ExecuteBuiltin` now calls `execute_builtin_with_query(&entry, Some(input), ...)`.
- `src/main_sections/fallbacks.rs:163`
  - Same fallback query-forwarding update for legacy fallback execution path.
- `src/app_impl/tests.rs:52`
  - Updated routing assertions to shared helper; added assertion that built-in Generate Script also routes to shared helper.
- `src/app_impl/selection_fallback.rs:452`
  - Added tests for keep-window-open behavior for generate-script fallback.

Verification run:
- `cargo check -p script-kit-gpui` âœ… passes.
- `cargo clippy -p script-kit-gpui --all-targets -- -D warnings` âŒ blocked by unrelated existing repo issues (for example duplicate test module files and many pre-existing lint/test errors outside this scope).
- Scoped test attempts (`cargo test -p script-kit-gpui app_impl_state_sync_tests::` and `cargo test -p script-kit-gpui --lib app_impl_state_sync_tests::`) âŒ blocked by unrelated existing compile failures in other test modules.

How to test manually:
1. Launch app and type prompt text in ScriptList (for example: `build a weather script`).
2. Press Shift+Tab.
3. Confirm script-generation chat opens using that prompt.
4. Return to ScriptList, type prompt text again, select fallback `Generate Script with AI`, press Enter.
5. Confirm behavior matches Shift+Tab (same flow, query preserved, window not immediately closed).

Risks / known gaps:
- Full clippy/test gate is currently not runnable in this shared tree due unrelated parallel-agent breakages; only scoped compile verification (`cargo check -p script-kit-gpui`) completed successfully.


==== exit @ 2026-02-08T08:29:26.761Z code=0 status=done ====
