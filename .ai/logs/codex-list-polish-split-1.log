==== spawn @ 2026-02-10T05:31:43.125Z ====
cmd: codex "exec" "--cd" "/Users/johnlindquist/dev/script-kit-gpui" "--model" "gpt-5.3-codex" "-c" "model_reasoning_effort=\"xhigh\"" "-c" "model_auto_compact_token_limit=120000" "-c" "developer_instructions=\"You are Codex implementer agent \\\"codex-list-polish-split-1\\\".\\n\\n## Coordination\\nThis repo runs parallel agents in ONE working tree. Before editing any file, you MUST claim it.\\nCommands (run via shell):\\n  - View roster: ~/.claude/bin/swarm.ts status\\n  - Claim files (blocks until free): ~/.claude/bin/swarm.ts claim --wait --id codex-list-polish-split-1 path/to/file\\n  - Release: ~/.claude/bin/swarm.ts release --id codex-list-polish-split-1 path/to/file\\n  - Update status/notes: ~/.claude/bin/swarm.ts update --id codex-list-polish-split-1 --status in_progress --notes \\\"...\\\"\\nRules:\\n  - Never edit a file you haven't claimed.\\n  - Keep claims tight (claim only what you're actively changing).\\n  - If blocked, set status=blocked and say what you're waiting on.\\n  - When finished, set status=done and release claims.\\n\\n## Development practices (this code is maintained by AI agents)\\n  - Log state transitions with enough context to diagnose failures from logs alone.\\n  - Structured errors: include what was attempted, what failed, and current state.\\n  - Name things for grepability — unique identifiers agents can find on the first search.\\n  - Every behavior change gets a test. Untested code is invisible to the next agent.\\n  - Test names describe the scenario: test_X_does_Y_when_Z.\\n  - Keep functions small and single-purpose. 500-line functions burn agent context.\\n  - Use types to encode constraints (enums > strings for errors).\\n\\n## CRITICAL: Parallel-safe verification\\n  - Other agents are modifying other files RIGHT NOW. Full test suites WILL show their failures.\\n  - ONLY run tests that cover YOUR changed files. Scope every test/check command:\\n    Rust: cargo test -p your-crate -- module::test_name | JS: npx jest your/file.test.ts\\n  - Do NOT run: cargo test (unscoped), cargo check (whole workspace), npm test (unscoped).\\n  - If a scoped test fails, it's YOUR bug — fix it. If tests outside your scope fail, ignore them.\\n\\n## Git commit discipline\\n  - NEVER commit unverified work. Run tests/lints/type-checks FIRST. If it fails, fix it before committing.\\n  - A commit is a declaration: \\\"this works and here's the proof.\\\"\\n  - Commit FREQUENTLY — after each meaningful unit of VERIFIED work, not just at the end.\\n  - A \\\"unit\\\" = one logical change that passes verification (new function, bug fix, refactor, test added).\\n  - NEVER batch an entire task into one giant commit. Small commits are searchable; big ones aren't.\\n  - Commit message format:\\n      Line 1: <type>(<scope>): <what changed> (imperative, max 72 chars)\\n      Line 3+: WHY this change was made, WHAT was verified, and HOW to test it.\\n    Types: feat, fix, refactor, test, docs, chore\\n    Example:\\n      feat(auth): add refresh token rotation\\n      \\n      Tokens now rotate on each refresh call to prevent replay attacks.\\n      The old token is invalidated immediately on rotation.\\n      \\n      Verified: cargo test --lib -- auth::refresh (4 tests pass)\\n      Verified: manual smoke test via curl — token rotates, old token returns 401\\n  - The \\\"Verified:\\\" lines are REQUIRED. Future agents will read git log to understand\\n    what was tested and how to re-verify. This is the most valuable part of the message.\\n  - In your final message, list all commits you made with their hashes.\\n\\n## Time budget\\nYou have approximately 10 minutes. If your task is too broad to complete in time:\\n(1) Commit any verified progress.\\n(2) Run: ~/.claude/bin/swarm.ts update --id YOUR_ID --status needs_split --notes 'suggest: 1) sub-task-desc scope:files 2) sub-task-desc scope:files'.\\n(3) Exit cleanly. The dispatcher will read your suggestions and spawn narrower workers.\"" "--output-last-message" "/Users/johnlindquist/dev/script-kit-gpui/.ai/logs/codex-list-polish-split-1.final.md" "--yolo" "You are agent codex-list-polish-split-1.\n\nCurrent parallel-agent roster (read this first):\n```\nSWARM SNAPSHOT @ 2026-02-10T05:31:43.118Z\n- codex-list-polish-split-1 [starting] scope=src/prompts/select/render.rs task=In src/prompts/select/render.rs, remove per-row bottom borders (.border_b_1().border_color(...)) from list item rows. A…\n```\n\nYour assignment:\n- Task: In src/prompts/select/render.rs, remove per-row bottom borders (.border_b_1().border_color(...)) from list item rows. Add horizontal padding .px(px(8.0)) to the choices_container div so rows are inset from window edges. Wrap each list item row in .rounded(px(8.0)). For the focused/selected row, apply a translucent background using the theme accent color with alpha 0x3A. This makes the list feel like Raycast with rounded pill-style focus highlights instead of bordered rows. Run cargo check && cargo clippy --all-targets -- -D warnings && cargo test after.\n- Scope: src/prompts/select/render.rs\n\nOperating constraints:\n- Single working tree (no worktrees, no patches).\n- You MUST claim files before editing (~/.claude/bin/swarm.ts claim --wait ...).\n\nDeliverables:\n- Make the code changes required by the task.\n- Run the most relevant tests/linters.\n- In your FINAL message, include: changed files, how to test, and any risks/known gaps."

OpenAI Codex v0.98.0 (research preview)
--------
workdir: /Users/johnlindquist/dev/script-kit-gpui
model: gpt-5.3-codex
provider: openai
approval: never
sandbox: danger-full-access
reasoning effort: xhigh
reasoning summaries: auto
session id: 019c4608-bacf-7c02-8df1-438a597e1efa
--------
user
You are agent codex-list-polish-split-1.

Current parallel-agent roster (read this first):
```
SWARM SNAPSHOT @ 2026-02-10T05:31:43.118Z
- codex-list-polish-split-1 [starting] scope=src/prompts/select/render.rs task=In src/prompts/select/render.rs, remove per-row bottom borders (.border_b_1().border_color(...)) from list item rows. A…
```

Your assignment:
- Task: In src/prompts/select/render.rs, remove per-row bottom borders (.border_b_1().border_color(...)) from list item rows. Add horizontal padding .px(px(8.0)) to the choices_container div so rows are inset from window edges. Wrap each list item row in .rounded(px(8.0)). For the focused/selected row, apply a translucent background using the theme accent color with alpha 0x3A. This makes the list feel like Raycast with rounded pill-style focus highlights instead of bordered rows. Run cargo check && cargo clippy --all-targets -- -D warnings && cargo test after.
- Scope: src/prompts/select/render.rs

Operating constraints:
- Single working tree (no worktrees, no patches).
- You MUST claim files before editing (~/.claude/bin/swarm.ts claim --wait ...).

Deliverables:
- Make the code changes required by the task.
- Run the most relevant tests/linters.
- In your FINAL message, include: changed files, how to test, and any risks/known gaps.
warning: Under-development features enabled: responses_websockets. Under-development features are incomplete and may behave unpredictably. To suppress this warning, set `suppress_unstable_features_warning = true` in /Users/johnlindquist/.codex/config.toml.
mcp: deepwiki starting
mcp: deepwiki ready
mcp startup: ready: deepwiki

thinking
**Clarifying commit and swarm protocol**
codex
I’ll update swarm status, claim `src/prompts/select/render.rs`, inspect the current row styling, then apply the requested list-polish changes and run the required Rust verification commands.

thinking
**Checking repository status**
exec
/bin/zsh -lc '~/.claude/bin/swarm.ts status' in /Users/johnlindquist/dev/script-kit-gpui succeeded in 52ms:
Repo: /Users/johnlindquist/dev/script-kit-gpui
Updated: 2026-02-10T05:31:54.739Z

Active agents (1):
codex-list-polish-split-1 [in_progress] codex/gpt-5.3-codex/exec
  task: In src/prompts/select/render.rs, remove per-row bottom borders (.border_b_1().border_color(...)) from list item rows. A…
  scope: src/prompts/select/render.rs
  claims: (none)
  notes: spawned codex (exec)

Inactive agents (281):
- codex-accessibility [done] done. exit=0. final=.ai/logs/codex-accessibility.final.md. See final message file.
- codex-action-labels [failed] failed. exit=1. final=.ai/logs/codex-action-labels.final.md.
- codex-actions-audit [failed] failed. exit=1. final=.ai/logs/codex-actions-audit.final.md. See final message file.
- codex-actions-consistency [failed] failed. exit=1. final=.ai/logs/codex-actions-consistency.final.md.
- codex-actions-dialog [done] done. exit=0. final=.ai/logs/codex-actions-dialog.final.md. See final message file.
- codex-actions-feedback [failed] failed. exit=1. final=.ai/logs/codex-actions-feedback.final.md.
- codex-actions-feedback-v2 [done] done. exit=0. final=.ai/logs/codex-actions-feedback-v2.final.md. See final message file.
- codex-actions-ux [done] done. exit=0. final=.ai/logs/codex-actions-ux.final.md. See final message file.
- codex-agents-md [done] done. exit=0. final=.ai/logs/codex-agents-md.final.md. See final message file.

thinking
**Sequencing claim and update actions**
exec
/bin/zsh -lc '~/.claude/bin/swarm.ts update --id codex-list-polish-split-1 --status in_progress --notes "claiming render.rs and applying row style changes" && ~/.claude/bin/swarm.ts claim --wait --id codex-list-polish-split-1 src/prompts/select/render.rs' in /Users/johnlindquist/dev/script-kit-gpui succeeded in 52ms:
Updated: codex-list-polish-split-1
Claimed for codex-list-polish-split-1: src/prompts/select/render.rs

thinking
**Planning simultaneous file inspection**
codex
I’ve claimed the target file and I’m locating the exact row container styles so I can make only the requested visual changes.
exec
/bin/zsh -lc 'rg -n "border_b_1|choices_container|rounded|accent|list item|select" src/prompts/select/render.rs' in /Users/johnlindquist/dev/script-kit-gpuiexec
/bin/zsh -lc "sed -n '1,260p' src/prompts/select/render.rs" in /Users/johnlindquist/dev/script-kit-gpui succeeded in 51ms:
9:    pub is_selected: bool,
17:    selected: &HashSet<usize>,
22:        is_selected: selected.contains(&choice_idx),
96:                // Handle Ctrl/Cmd+A for select all
98:                    this.toggle_select_all_filtered(cx);
107:                            this.toggle_selection(cx);
152:        let row_accent_color = if self.design_variant == DesignVariant::Default {
153:            self.theme.colors.accent.selected
155:            colors.accent
157:        let focused_row_bg = rgba((row_accent_color << 8) | ROW_FOCUSED_BG_ALPHA);
158:        let hovered_row_bg = rgba((row_accent_color << 8) | ROW_HOVER_BG_ALPHA);
173:            .id(gpui::ElementId::Name("input:select-filter".into()))
179:            .border_b_1()
201:                        .child(format!("{} selected", self.selected.len())),
222:                "select-choices",
230:                            selected_opacity: 0.0,
245:                                            &this.selected,
249:                                        let is_selected = row_state.is_selected;
257:                                                choice_selection_indicator(true, is_selected)
309:                                            .rounded(px(8.0))
 succeeded in 51ms:
use super::*;

const ROW_FOCUSED_BG_ALPHA: u32 = 0x3A;
const ROW_HOVER_BG_ALPHA: u32 = 0x26;

#[derive(Clone, Copy, Debug, PartialEq, Eq)]
pub(super) struct SelectRowState {
    pub is_focused: bool,
    pub is_selected: bool,
    pub is_hovered: bool,
}

pub(super) fn compute_row_state(
    display_idx: usize,
    focused_index: usize,
    choice_idx: usize,
    selected: &HashSet<usize>,
    hovered_index: Option<usize>,
) -> SelectRowState {
    SelectRowState {

thinking
**Extending code context around row builder**
exec
/bin/zsh -lc "sed -n '240,430p' src/prompts/select/render.rs" in /Users/johnlindquist/dev/script-kit-gpui succeeded in 52ms:
                                    {
                                        let row_state = compute_row_state(
                                            display_idx,
                                            this.focused_index,
                                            choice_idx,
                                            &this.selected,
                                            this.hovered_index,
                                        );
                                        let is_focused = row_state.is_focused;
                                        let is_selected = row_state.is_selected;
                                        let is_hovered = row_state.is_hovered;
                                        let semantic_id =
                                            choice.semantic_id.clone().unwrap_or_else(|| {
                                                indexed_choice.stable_semantic_id.clone()
                                            });
                                        let leading = if this.multiple {
                                            Some(LeadingContent::Emoji(
                                                choice_selection_indicator(true, is_selected)
                                                    .into(),
                                            ))

thinking
**Inspecting row border logic**
codex
I found that the file already has row rounding and list padding, but row background currently only highlights `is_focused`, not `is_selected`. I’m now checking `UnifiedListItem` defaults to confirm where per-row borders come from before applying a minimal fix.
exec
/bin/zsh -lc "rg -n \"struct UnifiedListItemColors|border_b_1|separator|list item|UnifiedListItem\" src -g '*.rs'" in /Users/johnlindquist/dev/script-kit-gpuiexec
/bin/zsh -lc "rg -n \"selected_opacity|hover_opacity\" src -g '*.rs'" in /Users/johnlindquist/dev/script-kit-gpui succeeded in 52ms:
Total output lines: 583

src/menu_bar_tests.rs:62:    // Empty titles are valid (for separators converted to items)
src/menu_bar_tests.rs:248:fn test_separator_detection_by_role() {
src/menu_bar_tests.rs:249:    // AXMenuItemRole separator has specific characteristics
src/menu_bar_tests.rs:250:    // We represent separators as items with special marker
src/menu_bar_tests.rs:251:    let sep = MenuBarItem::separator(vec![1, 2]);
src/menu_bar_tests.rs:252:    assert!(sep.is_separator());
src/menu_bar_tests.rs:257:fn test_separator_in_menu_list() {
src/menu_bar_tests.rs:258:    // Menu with items and separators
src/menu_bar_tests.rs:270:        MenuBarItem::separator(vec![2, 1]),
src/menu_bar_tests.rs:282:    assert!(!items[0].is_separator());
src/menu_bar_tests.rs:283:    assert!(items[1].is_separator());
src/menu_bar_tests.rs:284:    assert!(!items[2].is_separator());
src/builtins/part_000.rs:206:    /// Design gallery for viewing separator and icon variations
src/designs/apple_hig.rs:47:/// Separator inset from left edge (for iOS-style indented separators)
src/designs/apple_hig.rs:56:/// - Light gray separators between items
src/designs/apple_hig.rs:68:    /// Render a single list item in Apple HIG style
src/designs/apple_hig.rs:175:    /// Render a separator between list items
src/designs/apple_hig.rs:176:    fn render_separator(&self) -> Div {
 succeeded in 51ms:
src/list_item/part_000.rs:463:    pub selected_opacity: f32,
src/list_item/part_000.rs:465:    pub hover_opacity: f32,
src/list_item/part_001.rs:14:            selected_opacity: opacity.selected,
src/list_item/part_001.rs:15:            hover_opacity: opacity.hover,
src/list_item/part_001.rs:48:        let (selected_opacity, hover_opacity) = if is_dark {
src/list_item/part_001.rs:63:            selected_opacity,
src/list_item/part_001.rs:64:            hover_opacity,
src/list_item/part_002.rs:11:        let selected_alpha = (colors.selected_opacity * 255.0) as u8;
src/list_item/part_002.rs:12:        let hover_alpha = (colors.hover_opacity * 255.0) as u8;
src/theme/types/part_01.rs:81:    #[serde(default = "default_selected_opacity")]
src/theme/types/part_01.rs:84:    #[serde(default = "default_hover_opacity")]
src/theme/types/part_01.rs:117:fn default_selected_opacity() -> f32 {
src/theme/types/part_01.rs:121:fn default_hover_opacity() -> f32 {
src/stories/header_button_variations.rs:222:fn ask_ai_button(colors: PromptHeaderColors, hover_opacity: f32) -> Stateful<Div> {
src/stories/header_button_variations.rs:223:    let hover_alpha = (hover_opacity * 255.0) as u32;
src/stories/header_button_variations.rs:257:fn run_button(colors: PromptHeaderColors, hover_opacity: f32) -> Stateful<Div> {
src/stories/header_button_variations.rs:258:    let hover_alpha = (hover_opacity * 255.0) as u32;
src/stories/header_button_variations.rs:288:fn actions_button(colors: PromptHeaderColors, hover_opacity: f32) -> Stateful<Div> {
src/stories/header_button_variations.rs:289:    let hover_alpha = (hover_opacity * 255.0) as u32;
src/stories/header_button_variations.rs:443:fn render_hover_intensity(colors: PromptHeaderColors, hover_opacity: f32) -> impl IntoElement {

thinking
**Inspecting item border rendering**
exec
/bin/zsh -lc "sed -n '1,240p' src/components/unified_list_item/render.rs" in /Users/johnlindquist/dev/script-kit-gpuiexec
/bin/zsh -lc "sed -n '240,420p' src/components/unified_list_item/render.rs" in /Users/johnlindquist/dev/script-kit-gpui succeeded in 51ms:
//! Render implementation for UnifiedListItem.

// Allow dead_code - this is new code not yet integrated into the main app
#![allow(dead_code)]

use gpui::prelude::FluentBuilder;
use gpui::*;

use crate::designs::icon_variations::{icon_name_from_str, IconName};

use super::types::*;

// =============================================================================
// UnifiedListItem - The main component
// =============================================================================

/// A unified, presentational list item component.
#[derive(IntoElement)]
pub struct UnifiedListItem {
    id: ElementId,
 succeeded in 51ms:
                .flex()
                .items_center()
                .justify_center()
                .text_sm()
                .text_color(icon_color)
                .flex_shrink_0()
                .child(emoji.clone()),
        ),
        Some(LeadingContent::Icon { name, color }) => {
            let icon_color_final = color.map(rgb).unwrap_or(icon_color);
            let svg_path = icon_name_from_str(name)
                .map(|i| i.external_path())
                .unwrap_or_else(|| IconName::Code.external_path());
            Some(
                div()
                    .w(px(layout.leading_size))
                    .h(px(layout.leading_size))
                    .flex()
                    .items_center()
                    .justify_center()

thinking
**Reviewing list item styling and borders**
exec
/bin/zsh -lc "sed -n '250,380p' src/components/unified_list_item/types.rs" in /Users/johnlindquist/dev/script-kit-gpui succeeded in 52ms:
        match density {
            Density::Comfortable => Self {
                height: canonical_height,
                padding_x: 12.0,
                padding_y: 6.0,
                gap: 8.0,
                leading_size: 20.0,
                radius: 6.0,
            },
            Density::Compact => Self {
                height: canonical_height,
                padding_x: 8.0,
                padding_y: 4.0,
                gap: 6.0,
                leading_size: 16.0,
                radius: 4.0,
            },
        }
    }
}

thinking
**Refining row background logic**
exec
/bin/zsh -lc "rg -n \"compute_row_state|SelectRowState|render.rs\" src/prompts/select -g '*.rs'" in /Users/johnlindquist/dev/script-kit-gpui succeeded in 51ms:
src/prompts/select/tests.rs:208:fn test_select_prompt_compute_row_state_keeps_focus_and_selection_independent() {
src/prompts/select/tests.rs:210:    let focused_but_unselected = render::compute_row_state(2, 2, 1, &selected, Some(1));
src/prompts/select/tests.rs:215:    let selected_but_unfocused = render::compute_row_state(1, 2, 5, &selected, Some(1));
src/prompts/select/render.rs:7:pub(super) struct SelectRowState {
src/prompts/select/render.rs:13:pub(super) fn compute_row_state(
src/prompts/select/render.rs:19:) -> SelectRowState {
src/prompts/select/render.rs:20:    SelectRowState {
src/prompts/select/render.rs:241:                                        let row_state = compute_row_state(

thinking
**Evaluating in-file test additions**
exec
/bin/zsh -lc "sed -n '170,280p' src/prompts/select/tests.rs" in /Users/johnlindquist/dev/script-kit-gpui succeeded in 51ms:
    let mut theme = theme::Theme::default();
    theme.colors.background.search_box = 0x112233;

    let design_colors = DesignColors {
        background_secondary: 0x445566,
        ..Default::default()
    };

    assert_eq!(
        resolve_search_box_bg_hex(&theme, DesignVariant::Default, &design_colors),
        0x112233
    );
    assert_eq!(
        resolve_search_box_bg_hex(&theme, DesignVariant::Minimal, &design_colors),
        0x445566
    );
}

#[test]
fn test_select_prompt_extracts_icon_hint_from_choice_metadata() {

thinking
**Planning pure helper with tests**
codex
I confirmed there are no remaining per-row `.border_b_1()` calls in this file; I’m now making the functional tweak so selected rows share the same accent pill background as focused rows and adding a small unit test in `render.rs` for that mapping.

thinking
**Implementing helper for row background resolution**
file update
M /Users/johnlindquist/dev/script-kit-gpui/src/prompts/select/render.rs
@@ -26,2 +26,16 @@
 
+pub(super) fn resolve_row_bg_hex(
+    row_state: SelectRowState,
+    focused_bg_hex: u32,
+    hovered_bg_hex: u32,
+) -> u32 {
+    if row_state.is_focused || row_state.is_selected {
+        focused_bg_hex
+    } else if row_state.is_hovered {
+        hovered_bg_hex
+    } else {
+        0x00000000
+    }
+}
+
 pub(super) fn extract_choice_icon_hint(description: Option<&str>) -> Option<&str> {
@@ -156,4 +170,5 @@
         };
-        let focused_row_bg = rgba((row_accent_color << 8) | ROW_FOCUSED_BG_ALPHA);
-        let hovered_row_bg = rgba((row_accent_color << 8) | ROW_HOVER_BG_ALPHA);
+        let focused_row_bg_hex = (row_accent_color << 8) | ROW_FOCUSED_BG_ALPHA;
+        let hovered_row_bg_hex = (row_accent_color << 8) | ROW_HOVER_BG_ALPHA;
+        let hovered_row_bg = rgba(hovered_row_bg_hex);
 
@@ -280,9 +295,7 @@
                                             );
-                                        let row_bg = if is_focused {
-                                            focused_row_bg
-                                        } else if is_hovered {
-                                            hovered_row_bg
-                                        } else {
-                                            rgba(0x00000000)
-                                        };
+                                        let row_bg = rgba(resolve_row_bg_hex(
+                                            row_state,
+                                            focused_row_bg_hex,
+                                            hovered_row_bg_hex,
+                                        ));
                                         let hover_handler = cx.listener(
@@ -329,3 +342,3 @@
 
-                                        if !is_focused {
+                                        if !is_focused && !is_selected {
                                             row = row.hover(move |s| s.bg(hovered_row_bg));
apply_patch(auto_approved=true) exited 0 in 12ms:
Success. Updated the following files:
M src/prompts/select/render.rs
file update:
diff --git a/src/prompts/select/render.rs b/src/prompts/select/render.rs
index d0e0a5485f10066de9a287b70a4c3ae891e5cd99..76ed3c14c99542986c871e69a612f50aa79a75c6
--- a/src/prompts/select/render.rs
+++ b/src/prompts/select/render.rs
@@ -24,6 +24,20 @@
     }
 }
 
+pub(super) fn resolve_row_bg_hex(
+    row_state: SelectRowState,
+    focused_bg_hex: u32,
+    hovered_bg_hex: u32,
+) -> u32 {
+    if row_state.is_focused || row_state.is_selected {
+        focused_bg_hex
+    } else if row_state.is_hovered {
+        hovered_bg_hex
+    } else {
+        0x00000000
+    }
+}
+
 pub(super) fn extract_choice_icon_hint(description: Option<&str>) -> Option<&str> {
     description.and_then(|raw| {
         raw.split(['•', '|', '\n'])
@@ -154,8 +168,9 @@
         } else {
             colors.accent
         };
-        let focused_row_bg = rgba((row_accent_color << 8) | ROW_FOCUSED_BG_ALPHA);
-        let hovered_row_bg = rgba((row_accent_color << 8) | ROW_HOVER_BG_ALPHA);
+        let focused_row_bg_hex = (row_accent_color << 8) | ROW_FOCUSED_BG_ALPHA;
+        let hovered_row_bg_hex = (row_accent_color << 8) | ROW_HOVER_BG_ALPHA;
+        let hovered_row_bg = rgba(hovered_row_bg_hex);
 
         let placeholder = self
             .placeholder
@@ -278,13 +293,11 @@
                                                     ))
                                                 },
                                             );
-                                        let row_bg = if is_focused {
-                                            focused_row_bg
-                                        } else if is_hovered {
-                                            hovered_row_bg
-                                        } else {
-                                            rgba(0x00000000)
-                                        };
+                                        let row_bg = rgba(resolve_row_bg_hex(
+                                            row_state,
+                                            focused_row_bg_hex,
+                                            hovered_row_bg_hex,
+                                        ));
                                         let hover_handler = cx.listener(
                                             move |this: &mut SelectPrompt,
                                                   hovered: &bool,
@@ -327,7 +340,7 @@
                                                 .colors(item_colors),
                                             );
 
-                                        if !is_focused {
+                                        if !is_focused && !is_selected {
                                             row = row.hover(move |s| s.bg(hovered_row_bg));
                                         }
 

file update:
diff --git a/src/prompts/select/render.rs b/src/prompts/select/render.rs
index d0e0a5485f10066de9a287b70a4c3ae891e5cd99..76ed3c14c99542986c871e69a612f50aa79a75c6
--- a/src/prompts/select/render.rs
+++ b/src/prompts/select/render.rs
@@ -24,6 +24,20 @@
     }
 }
 
+pub(super) fn resolve_row_bg_hex(
+    row_state: SelectRowState,
+    focused_bg_hex: u32,
+    hovered_bg_hex: u32,
+) -> u32 {
+    if row_state.is_focused || row_state.is_selected {
+        focused_bg_hex
+    } else if row_state.is_hovered {
+        hovered_bg_hex
+    } else {
+        0x00000000
+    }
+}
+
 pub(super) fn extract_choice_icon_hint(description: Option<&str>) -> Option<&str> {
     description.and_then(|raw| {
         raw.split(['•', '|', '\n'])
@@ -154,8 +168,9 @@
         } else {
             colors.accent
         };
-        let focused_row_bg = rgba((row_accent_color << 8) | ROW_FOCUSED_BG_ALPHA);
-        let hovered_row_bg = rgba((row_accent_color << 8) | ROW_HOVER_BG_ALPHA);
+        let focused_row_bg_hex = (row_accent_color << 8) | ROW_FOCUSED_BG_ALPHA;
+        let hovered_row_bg_hex = (row_accent_color << 8) | ROW_HOVER_BG_ALPHA;
+        let hovered_row_bg = rgba(hovered_row_bg_hex);
 
         let placeholder = self
             .placeholder
@@ -278,13 +293,11 @@
                                                     ))
                                                 },
                                             );
-                                        let row_bg = if is_focused {
-                                            focused_row_bg
-                                        } else if is_hovered {
-                                            hovered_row_bg
-                                        } else {
-                                            rgba(0x00000000)
-                                        };
+                                        let row_bg = rgba(resolve_row_bg_hex(
+                                            row_state,
+                                            focused_row_bg_hex,
+                                            hovered_row_bg_hex,
+                                        ));
                                         let hover_handler = cx.listener(
                                             move |this: &mut SelectPrompt,
                                                   hovered: &bool,
@@ -327,7 +340,7 @@
                                                 .colors(item_colors),
                                             );
 
-                                        if !is_focused {
+                                        if !is_focused && !is_selected {
                                             row = row.hover(move |s| s.bg(hovered_row_bg));
                                         }
 


thinking
**Planning test module addition**
exec
/bin/zsh -lc "rg -n \"cfg\\(test\\)|resolve_row_bg_hex\" src/prompts/select/render.rs" in /Users/johnlindquist/dev/script-kit-gpui succeeded in 50ms:
27:pub(super) fn resolve_row_bg_hex(
296:                                        let row_bg = rgba(resolve_row_bg_hex(
file update:
diff --git a/src/prompts/select/render.rs b/src/prompts/select/render.rs
index d0e0a5485f10066de9a287b70a4c3ae891e5cd99..76ed3c14c99542986c871e69a612f50aa79a75c6
--- a/src/prompts/select/render.rs
+++ b/src/prompts/select/render.rs
@@ -24,6 +24,20 @@
     }
 }
 
+pub(super) fn resolve_row_bg_hex(
+    row_state: SelectRowState,
+    focused_bg_hex: u32,
+    hovered_bg_hex: u32,
+) -> u32 {
+    if row_state.is_focused || row_state.is_selected {
+        focused_bg_hex
+    } else if row_state.is_hovered {
+        hovered_bg_hex
+    } else {
+        0x00000000
+    }
+}
+
 pub(super) fn extract_choice_icon_hint(description: Option<&str>) -> Option<&str> {
     description.and_then(|raw| {
         raw.split(['•', '|', '\n'])
@@ -154,8 +168,9 @@
         } else {
             colors.accent
         };
-        let focused_row_bg = rgba((row_accent_color << 8) | ROW_FOCUSED_BG_ALPHA);
-        let hovered_row_bg = rgba((row_accent_color << 8) | ROW_HOVER_BG_ALPHA);
+        let focused_row_bg_hex = (row_accent_color << 8) | ROW_FOCUSED_BG_ALPHA;
+        let hovered_row_bg_hex = (row_accent_color << 8) | ROW_HOVER_BG_ALPHA;
+        let hovered_row_bg = rgba(hovered_row_bg_hex);
 
         let placeholder = self
             .placeholder
@@ -278,13 +293,11 @@
                                                     ))
                                                 },
                                             );
-                                        let row_bg = if is_focused {
-                                            focused_row_bg
-                                        } else if is_hovered {
-                                            hovered_row_bg
-                                        } else {
-                                            rgba(0x00000000)
-                                        };
+                                        let row_bg = rgba(resolve_row_bg_hex(
+                                            row_state,
+                                            focused_row_bg_hex,
+                                            hovered_row_bg_hex,
+                                        ));
                                         let hover_handler = cx.listener(
                                             move |this: &mut SelectPrompt,
                                                   hovered: &bool,
@@ -327,7 +340,7 @@
                                                 .colors(item_colors),
                                             );
 
-                                        if !is_focused {
+                                        if !is_focused && !is_selected {
                                             row = row.hover(move |s| s.bg(hovered_row_bg));
                                         }
 


thinking
**Adding module and patch**
file update
M /Users/johnlindquist/dev/script-kit-gpui/src/prompts/select/render.rs
@@ -391 +391,40 @@
 }
+
+#[cfg(test)]
+mod tests {
+    use super::{resolve_row_bg_hex, SelectRowState};
+
+    #[test]
+    fn test_resolve_row_bg_hex_uses_focused_accent_for_selected_row() {
+        let focused_bg_hex = 0x55AAFF3A;
+        let hovered_bg_hex = 0x55AAFF26;
+
+        let selected_row = SelectRowState {
+            is_focused: false,
+            is_selected: true,
+            is_hovered: false,
+        };
+
+        assert_eq!(
+            resolve_row_bg_hex(selected_row, focused_bg_hex, hovered_bg_hex),
+            focused_bg_hex
+        );
+    }
+
+    #[test]
+    fn test_resolve_row_bg_hex_uses_hover_color_for_unselected_hovered_row() {
+        let focused_bg_hex = 0x55AAFF3A;
+        let hovered_bg_hex = 0x55AAFF26;
+
+        let hovered_row = SelectRowState {
+            is_focused: false,
+            is_selected: false,
+            is_hovered: true,
+        };
+
+        assert_eq!(
+            resolve_row_bg_hex(hovered_row, focused_bg_hex, hovered_bg_hex),
+            hovered_bg_hex
+        );
+    }
+}
apply_patch(auto_approved=true) exited 0 in 12ms:
Success. Updated the following files:
M src/prompts/select/render.rs
file update:
diff --git a/src/prompts/select/render.rs b/src/prompts/select/render.rs
index d0e0a5485f10066de9a287b70a4c3ae891e5cd99..95986e736108239384817ce9f36e8ea8c64a84a7
--- a/src/prompts/select/render.rs
+++ b/src/prompts/select/render.rs
@@ -24,6 +24,20 @@
     }
 }
 
+pub(super) fn resolve_row_bg_hex(
+    row_state: SelectRowState,
+    focused_bg_hex: u32,
+    hovered_bg_hex: u32,
+) -> u32 {
+    if row_state.is_focused || row_state.is_selected {
+        focused_bg_hex
+    } else if row_state.is_hovered {
+        hovered_bg_hex
+    } else {
+        0x00000000
+    }
+}
+
 pub(super) fn extract_choice_icon_hint(description: Option<&str>) -> Option<&str> {
     description.and_then(|raw| {
         raw.split(['•', '|', '\n'])
@@ -154,8 +168,9 @@
         } else {
             colors.accent
         };
-        let focused_row_bg = rgba((row_accent_color << 8) | ROW_FOCUSED_BG_ALPHA);
-        let hovered_row_bg = rgba((row_accent_color << 8) | ROW_HOVER_BG_ALPHA);
+        let focused_row_bg_hex = (row_accent_color << 8) | ROW_FOCUSED_BG_ALPHA;
+        let hovered_row_bg_hex = (row_accent_color << 8) | ROW_HOVER_BG_ALPHA;
+        let hovered_row_bg = rgba(hovered_row_bg_hex);
 
         let placeholder = self
             .placeholder
@@ -278,13 +293,11 @@
                                                     ))
                                                 },
                                             );
-                                        let row_bg = if is_focused {
-                                            focused_row_bg
-                                        } else if is_hovered {
-                                            hovered_row_bg
-                                        } else {
-                                            rgba(0x00000000)
-                                        };
+                                        let row_bg = rgba(resolve_row_bg_hex(
+                                            row_state,
+                                            focused_row_bg_hex,
+                                            hovered_row_bg_hex,
+                                        ));
                                         let hover_handler = cx.listener(
                                             move |this: &mut SelectPrompt,
                                                   hovered: &bool,
@@ -327,7 +340,7 @@
                                                 .colors(item_colors),
                                             );
 
-                                        if !is_focused {
+                                        if !is_focused && !is_selected {
                                             row = row.hover(move |s| s.bg(hovered_row_bg));
                                         }
 
@@ -376,3 +389,42 @@
             .child(choices_container)
     }
 }
+
+#[cfg(test)]
+mod tests {
+    use super::{resolve_row_bg_hex, SelectRowState};
+
+    #[test]
+    fn test_resolve_row_bg_hex_uses_focused_accent_for_selected_row() {
+        let focused_bg_hex = 0x55AAFF3A;
+        let hovered_bg_hex = 0x55AAFF26;
+
+        let selected_row = SelectRowState {
+            is_focused: false,
+            is_selected: true,
+            is_hovered: false,
+        };
+
+        assert_eq!(
+            resolve_row_bg_hex(selected_row, focused_bg_hex, hovered_bg_hex),
+            focused_bg_hex
+        );
+    }
+
+    #[test]
+    fn test_resolve_row_bg_hex_uses_hover_color_for_unselected_hovered_row() {
+        let focused_bg_hex = 0x55AAFF3A;
+        let hovered_bg_hex = 0x55AAFF26;
+
+        let hovered_row = SelectRowState {
+            is_focused: false,
+            is_selected: false,
+            is_hovered: true,
+        };
+
+        assert_eq!(
+            resolve_row_bg_hex(hovered_row, focused_bg_hex, hovered_bg_hex),
+            hovered_bg_hex
+        );
+    }
+}

file update:
diff --git a/src/prompts/select/render.rs b/src/prompts/select/render.rs
index d0e0a5485f10066de9a287b70a4c3ae891e5cd99..95986e736108239384817ce9f36e8ea8c64a84a7
--- a/src/prompts/select/render.rs
+++ b/src/prompts/select/render.rs
@@ -24,6 +24,20 @@
     }
 }
 
+pub(super) fn resolve_row_bg_hex(
+    row_state: SelectRowState,
+    focused_bg_hex: u32,
+    hovered_bg_hex: u32,
+) -> u32 {
+    if row_state.is_focused || row_state.is_selected {
+        focused_bg_hex
+    } else if row_state.is_hovered {
+        hovered_bg_hex
+    } else {
+        0x00000000
+    }
+}
+
 pub(super) fn extract_choice_icon_hint(description: Option<&str>) -> Option<&str> {
     description.and_then(|raw| {
         raw.split(['•', '|', '\n'])
@@ -154,8 +168,9 @@
         } else {
             colors.accent
         };
-        let focused_row_bg = rgba((row_accent_color << 8) | ROW_FOCUSED_BG_ALPHA);
-        let hovered_row_bg = rgba((row_accent_color << 8) | ROW_HOVER_BG_ALPHA);
+        let focused_row_bg_hex = (row_accent_color << 8) | ROW_FOCUSED_BG_ALPHA;
+        let hovered_row_bg_hex = (row_accent_color << 8) | ROW_HOVER_BG_ALPHA;
+        let hovered_row_bg = rgba(hovered_row_bg_hex);
 
         let placeholder = self
             .placeholder
@@ -278,13 +293,11 @@
                                                     ))
                                                 },
                                             );
-                                        let row_bg = if is_focused {
-                                            focused_row_bg
-                                        } else if is_hovered {
-                                            hovered_row_bg
-                                        } else {
-                                            rgba(0x00000000)
-                                        };
+                                        let row_bg = rgba(resolve_row_bg_hex(
+                                            row_state,
+                                            focused_row_bg_hex,
+                                            hovered_row_bg_hex,
+                                        ));
                                         let hover_handler = cx.listener(
                                             move |this: &mut SelectPrompt,
                                                   hovered: &bool,
@@ -327,7 +340,7 @@
                                                 .colors(item_colors),
                                             );
 
-                                        if !is_focused {
+                                        if !is_focused && !is_selected {
                                             row = row.hover(move |s| s.bg(hovered_row_bg));
                                         }
 
@@ -376,3 +389,42 @@
             .child(choices_container)
     }
 }
+
+#[cfg(test)]
+mod tests {
+    use super::{resolve_row_bg_hex, SelectRowState};
+
+    #[test]
+    fn test_resolve_row_bg_hex_uses_focused_accent_for_selected_row() {
+        let focused_bg_hex = 0x55AAFF3A;
+        let hovered_bg_hex = 0x55AAFF26;
+
+        let selected_row = SelectRowState {
+            is_focused: false,
+            is_selected: true,
+            is_hovered: false,
+        };
+
+        assert_eq!(
+            resolve_row_bg_hex(selected_row, focused_bg_hex, hovered_bg_hex),
+            focused_bg_hex
+        );
+    }
+
+    #[test]
+    fn test_resolve_row_bg_hex_uses_hover_color_for_unselected_hovered_row() {
+        let focused_bg_hex = 0x55AAFF3A;
+        let hovered_bg_hex = 0x55AAFF26;
+
+        let hovered_row = SelectRowState {
+            is_focused: false,
+            is_selected: false,
+            is_hovered: true,
+        };
+
+        assert_eq!(
+            resolve_row_bg_hex(hovered_row, focused_bg_hex, hovered_bg_hex),
+            hovered_bg_hex
+        );
+    }
+}


thinking
**Checking formatting necessity**
exec
/bin/zsh -lc "git diff -- src/prompts/select/render.rs | sed -n '1,220p'" in /Users/johnlindquist/dev/script-kit-gpui succeeded in 50ms:
diff --git a/src/prompts/select/render.rs b/src/prompts/select/render.rs
index 82fd8c4..95986e7 100644
--- a/src/prompts/select/render.rs
+++ b/src/prompts/select/render.rs
@@ -1,5 +1,92 @@
 use super::*;
 
+const ROW_FOCUSED_BG_ALPHA: u32 = 0x3A;
+const ROW_HOVER_BG_ALPHA: u32 = 0x26;
+
+#[derive(Clone, Copy, Debug, PartialEq, Eq)]
+pub(super) struct SelectRowState {
+    pub is_focused: bool,
+    pub is_selected: bool,
+    pub is_hovered: bool,
+}
+
+pub(super) fn compute_row_state(
+    display_idx: usize,
+    focused_index: usize,
file update:
diff --git a/src/prompts/select/render.rs b/src/prompts/select/render.rs
index d0e0a5485f10066de9a287b70a4c3ae891e5cd99..95986e736108239384817ce9f36e8ea8c64a84a7
--- a/src/prompts/select/render.rs
+++ b/src/prompts/select/render.rs
@@ -24,6 +24,20 @@
     }
 }
 
+pub(super) fn resolve_row_bg_hex(
+    row_state: SelectRowState,
+    focused_bg_hex: u32,
+    hovered_bg_hex: u32,
+) -> u32 {
+    if row_state.is_focused || row_state.is_selected {
+        focused_bg_hex
+    } else if row_state.is_hovered {
+        hovered_bg_hex
+    } else {
+        0x00000000
+    }
+}
+
 pub(super) fn extract_choice_icon_hint(description: Option<&str>) -> Option<&str> {
     description.and_then(|raw| {
         raw.split(['•', '|', '\n'])
@@ -154,8 +168,9 @@
         } else {
             colors.accent
         };
-        let focused_row_bg = rgba((row_accent_color << 8) | ROW_FOCUSED_BG_ALPHA);
-        let hovered_row_bg = rgba((row_accent_color << 8) | ROW_HOVER_BG_ALPHA);
+        let focused_row_bg_hex = (row_accent_color << 8) | ROW_FOCUSED_BG_ALPHA;
+        let hovered_row_bg_hex = (row_accent_color << 8) | ROW_HOVER_BG_ALPHA;
+        let hovered_row_bg = rgba(hovered_row_bg_hex);
 
         let placeholder = self
             .placeholder
@@ -278,13 +293,11 @@
                                                     ))
                                                 },
                                             );
-                                        let row_bg = if is_focused {
-                                            focused_row_bg
-                                        } else if is_hovered {
-                                            hovered_row_bg
-                                        } else {
-                                            rgba(0x00000000)
-                                        };
+                                        let row_bg = rgba(resolve_row_bg_hex(
+                                            row_state,
+                                            focused_row_bg_hex,
+                                            hovered_row_bg_hex,
+                                        ));
                                         let hover_handler = cx.listener(
                                             move |this: &mut SelectPrompt,
                                                   hovered: &bool,
@@ -327,7 +340,7 @@
                                                 .colors(item_colors),
                                             );
 
-                                        if !is_focused {
+                                        if !is_focused && !is_selected {
                                             row = row.hover(move |s| s.bg(hovered_row_bg));
                                         }
 
@@ -376,3 +389,42 @@
             .child(choices_container)
     }
 }
+
+#[cfg(test)]
+mod tests {
+    use super::{resolve_row_bg_hex, SelectRowState};
+
+    #[test]
+    fn test_resolve_row_bg_hex_uses_focused_accent_for_selected_row() {
+        let focused_bg_hex = 0x55AAFF3A;
+        let hovered_bg_hex = 0x55AAFF26;
+
+        let selected_row = SelectRowState {
+            is_focused: false,
+            is_selected: true,
+            is_hovered: false,
+        };
+
+        assert_eq!(
+            resolve_row_bg_hex(selected_row, focused_bg_hex, hovered_bg_hex),
+            focused_bg_hex
+        );
+    }
+
+    #[test]
+    fn test_resolve_row_bg_hex_uses_hover_color_for_unselected_hovered_row() {
+        let focused_bg_hex = 0x55AAFF3A;
+        let hovered_bg_hex = 0x55AAFF26;
+
+        let hovered_row = SelectRowState {
+            is_focused: false,
+            is_selected: false,
+            is_hovered: true,
+        };
+
+        assert_eq!(
+            resolve_row_bg_hex(hovered_row, focused_bg_hex, hovered_bg_hex),
+            hovered_bg_hex
+        );
+    }
+}


thinking
**Assessing preexisting file modifications**
exec
/bin/zsh -lc "sed -n '1,220p' src/prompts/select/render.rs" in /Users/johnlindquist/dev/script-kit-gpui succeeded in 52ms:
use super::*;

const ROW_FOCUSED_BG_ALPHA: u32 = 0x3A;
const ROW_HOVER_BG_ALPHA: u32 = 0x26;

#[derive(Clone, Copy, Debug, PartialEq, Eq)]
pub(super) struct SelectRowState {
    pub is_focused: bool,
    pub is_selected: bool,
    pub is_hovered: bool,
}

pub(super) fn compute_row_state(
    display_idx: usize,
    focused_index: usize,
    choice_idx: usize,
    selected: &HashSet<usize>,
    hovered_index: Option<usize>,
) -> SelectRowState {
    SelectRowState {
file update:
diff --git a/src/prompts/select/render.rs b/src/prompts/select/render.rs
index d0e0a5485f10066de9a287b70a4c3ae891e5cd99..95986e736108239384817ce9f36e8ea8c64a84a7
--- a/src/prompts/select/render.rs
+++ b/src/prompts/select/render.rs
@@ -24,6 +24,20 @@
     }
 }
 
+pub(super) fn resolve_row_bg_hex(
+    row_state: SelectRowState,
+    focused_bg_hex: u32,
+    hovered_bg_hex: u32,
+) -> u32 {
+    if row_state.is_focused || row_state.is_selected {
+        focused_bg_hex
+    } else if row_state.is_hovered {
+        hovered_bg_hex
+    } else {
+        0x00000000
+    }
+}
+
 pub(super) fn extract_choice_icon_hint(description: Option<&str>) -> Option<&str> {
     description.and_then(|raw| {
         raw.split(['•', '|', '\n'])
@@ -154,8 +168,9 @@
         } else {
             colors.accent
         };
-        let focused_row_bg = rgba((row_accent_color << 8) | ROW_FOCUSED_BG_ALPHA);
-        let hovered_row_bg = rgba((row_accent_color << 8) | ROW_HOVER_BG_ALPHA);
+        let focused_row_bg_hex = (row_accent_color << 8) | ROW_FOCUSED_BG_ALPHA;
+        let hovered_row_bg_hex = (row_accent_color << 8) | ROW_HOVER_BG_ALPHA;
+        let hovered_row_bg = rgba(hovered_row_bg_hex);
 
         let placeholder = self
             .placeholder
@@ -278,13 +293,11 @@
                                                     ))
                                                 },
                                             );
-                                        let row_bg = if is_focused {
-                                            focused_row_bg
-                                        } else if is_hovered {
-                                            hovered_row_bg
-                                        } else {
-                                            rgba(0x00000000)
-                                        };
+                                        let row_bg = rgba(resolve_row_bg_hex(
+                                            row_state,
+                                            focused_row_bg_hex,
+                                            hovered_row_bg_hex,
+                                        ));
                                         let hover_handler = cx.listener(
                                             move |this: &mut SelectPrompt,
                                                   hovered: &bool,
@@ -327,7 +340,7 @@
                                                 .colors(item_colors),
                                             );
 
-                                        if !is_focused {
+                                        if !is_focused && !is_selected {
                                             row = row.hover(move |s| s.bg(hovered_row_bg));
                                         }
 
@@ -376,3 +389,42 @@
             .child(choices_container)
     }
 }
+
+#[cfg(test)]
+mod tests {
+    use super::{resolve_row_bg_hex, SelectRowState};
+
+    #[test]
+    fn test_resolve_row_bg_hex_uses_focused_accent_for_selected_row() {
+        let focused_bg_hex = 0x55AAFF3A;
+        let hovered_bg_hex = 0x55AAFF26;
+
+        let selected_row = SelectRowState {
+            is_focused: false,
+            is_selected: true,
+            is_hovered: false,
+        };
+
+        assert_eq!(
+            resolve_row_bg_hex(selected_row, focused_bg_hex, hovered_bg_hex),
+            focused_bg_hex
+        );
+    }
+
+    #[test]
+    fn test_resolve_row_bg_hex_uses_hover_color_for_unselected_hovered_row() {
+        let focused_bg_hex = 0x55AAFF3A;
+        let hovered_bg_hex = 0x55AAFF26;
+
+        let hovered_row = SelectRowState {
+            is_focused: false,
+            is_selected: false,
+            is_hovered: true,
+        };
+
+        assert_eq!(
+            resolve_row_bg_hex(hovered_row, focused_bg_hex, hovered_bg_hex),
+            hovered_bg_hex
+        );
+    }
+}


thinking
**Planning visual test verification**
exec
/bin/zsh -lc "sed -n '220,470p' src/prompts/select/render.rs" in /Users/johnlindquist/dev/script-kit-gpui succeeded in 51ms:
        // Choices list
        let filtered_len = self.filtered_choices.len();
        let choices_content: AnyElement = if filtered_len == 0 {
            let empty_message = if self.filter_text.trim().is_empty() {
                "No choices available"
            } else {
                "No choices match your filter"
            };
            div()
                .w_full()
                .py(px(spacing.padding_xl))
                .px(px(spacing.item_padding_x))
                .text_color(muted_color)
                .child(empty_message)
                .into_any_element()
        } else {
            uniform_list(
                "select-choices",
                filtered_len,
                cx.processor(
file update:
diff --git a/src/prompts/select/render.rs b/src/prompts/select/render.rs
index d0e0a5485f10066de9a287b70a4c3ae891e5cd99..95986e736108239384817ce9f36e8ea8c64a84a7
--- a/src/prompts/select/render.rs
+++ b/src/prompts/select/render.rs
@@ -24,6 +24,20 @@
     }
 }
 
+pub(super) fn resolve_row_bg_hex(
+    row_state: SelectRowState,
+    focused_bg_hex: u32,
+    hovered_bg_hex: u32,
+) -> u32 {
+    if row_state.is_focused || row_state.is_selected {
+        focused_bg_hex
+    } else if row_state.is_hovered {
+        hovered_bg_hex
+    } else {
+        0x00000000
+    }
+}
+
 pub(super) fn extract_choice_icon_hint(description: Option<&str>) -> Option<&str> {
     description.and_then(|raw| {
         raw.split(['•', '|', '\n'])
@@ -154,8 +168,9 @@
         } else {
             colors.accent
         };
-        let focused_row_bg = rgba((row_accent_color << 8) | ROW_FOCUSED_BG_ALPHA);
-        let hovered_row_bg = rgba((row_accent_color << 8) | ROW_HOVER_BG_ALPHA);
+        let focused_row_bg_hex = (row_accent_color << 8) | ROW_FOCUSED_BG_ALPHA;
+        let hovered_row_bg_hex = (row_accent_color << 8) | ROW_HOVER_BG_ALPHA;
+        let hovered_row_bg = rgba(hovered_row_bg_hex);
 
         let placeholder = self
             .placeholder
@@ -278,13 +293,11 @@
                                                     ))
                                                 },
                                             );
-                                        let row_bg = if is_focused {
-                                            focused_row_bg
-                                        } else if is_hovered {
-                                            hovered_row_bg
-                                        } else {
-                                            rgba(0x00000000)
-                                        };
+                                        let row_bg = rgba(resolve_row_bg_hex(
+                                            row_state,
+                                            focused_row_bg_hex,
+                                            hovered_row_bg_hex,
+                                        ));
                                         let hover_handler = cx.listener(
                                             move |this: &mut SelectPrompt,
                                                   hovered: &bool,
@@ -327,7 +340,7 @@
                                                 .colors(item_colors),
                                             );
 
-                                        if !is_focused {
+                                        if !is_focused && !is_selected {
                                             row = row.hover(move |s| s.bg(hovered_row_bg));
                                         }
 
@@ -376,3 +389,42 @@
             .child(choices_container)
     }
 }
+
+#[cfg(test)]
+mod tests {
+    use super::{resolve_row_bg_hex, SelectRowState};
+
+    #[test]
+    fn test_resolve_row_bg_hex_uses_focused_accent_for_selected_row() {
+        let focused_bg_hex = 0x55AAFF3A;
+        let hovered_bg_hex = 0x55AAFF26;
+
+        let selected_row = SelectRowState {
+            is_focused: false,
+            is_selected: true,
+            is_hovered: false,
+        };
+
+        assert_eq!(
+            resolve_row_bg_hex(selected_row, focused_bg_hex, hovered_bg_hex),
+            focused_bg_hex
+        );
+    }
+
+    #[test]
+    fn test_resolve_row_bg_hex_uses_hover_color_for_unselected_hovered_row() {
+        let focused_bg_hex = 0x55AAFF3A;
+        let hovered_bg_hex = 0x55AAFF26;
+
+        let hovered_row = SelectRowState {
+            is_focused: false,
+            is_selected: false,
+            is_hovered: true,
+        };
+
+        assert_eq!(
+            resolve_row_bg_hex(hovered_row, focused_bg_hex, hovered_bg_hex),
+            hovered_bg_hex
+        );
+    }
+}


thinking
**Reconciling conflicting test requirements**
exec
/bin/zsh -lc 'rg -n "''^name'"\\s*=\\s*\\\"\" Cargo.toml" in /Users/johnlindquist/dev/script-kit-gpui succeeded in 51ms:
2:name = "script-kit-gpui"
8:name = "script_kit_gpui"
12:name = "script-kit-gpui"
17:name = "smoke-test"
22:name = "storybook"
177:name = "Script Kit"
file update:
diff --git a/src/prompts/select/render.rs b/src/prompts/select/render.rs
index d0e0a5485f10066de9a287b70a4c3ae891e5cd99..95986e736108239384817ce9f36e8ea8c64a84a7
--- a/src/prompts/select/render.rs
+++ b/src/prompts/select/render.rs
@@ -24,6 +24,20 @@
     }
 }
 
+pub(super) fn resolve_row_bg_hex(
+    row_state: SelectRowState,
+    focused_bg_hex: u32,
+    hovered_bg_hex: u32,
+) -> u32 {
+    if row_state.is_focused || row_state.is_selected {
+        focused_bg_hex
+    } else if row_state.is_hovered {
+        hovered_bg_hex
+    } else {
+        0x00000000
+    }
+}
+
 pub(super) fn extract_choice_icon_hint(description: Option<&str>) -> Option<&str> {
     description.and_then(|raw| {
         raw.split(['•', '|', '\n'])
@@ -154,8 +168,9 @@
         } else {
             colors.accent
         };
-        let focused_row_bg = rgba((row_accent_color << 8) | ROW_FOCUSED_BG_ALPHA);
-        let hovered_row_bg = rgba((row_accent_color << 8) | ROW_HOVER_BG_ALPHA);
+        let focused_row_bg_hex = (row_accent_color << 8) | ROW_FOCUSED_BG_ALPHA;
+        let hovered_row_bg_hex = (row_accent_color << 8) | ROW_HOVER_BG_ALPHA;
+        let hovered_row_bg = rgba(hovered_row_bg_hex);
 
         let placeholder = self
             .placeholder
@@ -278,13 +293,11 @@
                                                     ))
                                                 },
                                             );
-                                        let row_bg = if is_focused {
-                                            focused_row_bg
-                                        } else if is_hovered {
-                                            hovered_row_bg
-                                        } else {
-                                            rgba(0x00000000)
-                                        };
+                                        let row_bg = rgba(resolve_row_bg_hex(
+                                            row_state,
+                                            focused_row_bg_hex,
+                                            hovered_row_bg_hex,
+                                        ));
                                         let hover_handler = cx.listener(
                                             move |this: &mut SelectPrompt,
                                                   hovered: &bool,
@@ -327,7 +340,7 @@
                                                 .colors(item_colors),
                                             );
 
-                                        if !is_focused {
+                                        if !is_focused && !is_selected {
                                             row = row.hover(move |s| s.bg(hovered_row_bg));
                                         }
 
@@ -376,3 +389,42 @@
             .child(choices_container)
     }
 }
+
+#[cfg(test)]
+mod tests {
+    use super::{resolve_row_bg_hex, SelectRowState};
+
+    #[test]
+    fn test_resolve_row_bg_hex_uses_focused_accent_for_selected_row() {
+        let focused_bg_hex = 0x55AAFF3A;
+        let hovered_bg_hex = 0x55AAFF26;
+
+        let selected_row = SelectRowState {
+            is_focused: false,
+            is_selected: true,
+            is_hovered: false,
+        };
+
+        assert_eq!(
+            resolve_row_bg_hex(selected_row, focused_bg_hex, hovered_bg_hex),
+            focused_bg_hex
+        );
+    }
+
+    #[test]
+    fn test_resolve_row_bg_hex_uses_hover_color_for_unselected_hovered_row() {
+        let focused_bg_hex = 0x55AAFF3A;
+        let hovered_bg_hex = 0x55AAFF26;
+
+        let hovered_row = SelectRowState {
+            is_focused: false,
+            is_selected: false,
+            is_hovered: true,
+        };
+
+        assert_eq!(
+            resolve_row_bg_hex(hovered_row, focused_bg_hex, hovered_bg_hex),
+            hovered_bg_hex
+        );
+    }
+}


thinking
**Planning targeted test runs**
codex
I’ve applied the row-highlight logic and a focused unit test. Next I’m running scoped Rust verification for the `script-kit-gpui` crate and `prompts::select` tests to stay parallel-safe in this shared tree.

thinking
**Starting cargo check with timeout**
exec
/bin/zsh -lc 'cargo check -p script-kit-gpui' in /Users/johnlindquist/dev/script-kit-gpuifile update:
diff --git a/src/prompts/select/render.rs b/src/prompts/select/render.rs
index d0e0a5485f10066de9a287b70a4c3ae891e5cd99..95986e736108239384817ce9f36e8ea8c64a84a7
--- a/src/prompts/select/render.rs
+++ b/src/prompts/select/render.rs
@@ -24,6 +24,20 @@
     }
 }
 
+pub(super) fn resolve_row_bg_hex(
+    row_state: SelectRowState,
+    focused_bg_hex: u32,
+    hovered_bg_hex: u32,
+) -> u32 {
+    if row_state.is_focused || row_state.is_selected {
+        focused_bg_hex
+    } else if row_state.is_hovered {
+        hovered_bg_hex
+    } else {
+        0x00000000
+    }
+}
+
 pub(super) fn extract_choice_icon_hint(description: Option<&str>) -> Option<&str> {
     description.and_then(|raw| {
         raw.split(['•', '|', '\n'])
@@ -154,8 +168,9 @@
         } else {
             colors.accent
         };
-        let focused_row_bg = rgba((row_accent_color << 8) | ROW_FOCUSED_BG_ALPHA);
-        let hovered_row_bg = rgba((row_accent_color << 8) | ROW_HOVER_BG_ALPHA);
+        let focused_row_bg_hex = (row_accent_color << 8) | ROW_FOCUSED_BG_ALPHA;
+        let hovered_row_bg_hex = (row_accent_color << 8) | ROW_HOVER_BG_ALPHA;
+        let hovered_row_bg = rgba(hovered_row_bg_hex);
 
         let placeholder = self
             .placeholder
@@ -278,13 +293,11 @@
                                                     ))
                                                 },
                                             );
-                                        let row_bg = if is_focused {
-                                            focused_row_bg
-                                        } else if is_hovered {
-                                            hovered_row_bg
-                                        } else {
-                                            rgba(0x00000000)
-                                        };
+                                        let row_bg = rgba(resolve_row_bg_hex(
+                                            row_state,
+                                            focused_row_bg_hex,
+                                            hovered_row_bg_hex,
+                                        ));
                                         let hover_handler = cx.listener(
                                             move |this: &mut SelectPrompt,
                                                   hovered: &bool,
@@ -327,7 +340,7 @@
                                                 .colors(item_colors),
                                             );
 
-                                        if !is_focused {
+                                        if !is_focused && !is_selected {
                                             row = row.hover(move |s| s.bg(hovered_row_bg));
                                         }
 
@@ -376,3 +389,42 @@
             .child(choices_container)
     }
 }
+
+#[cfg(test)]
+mod tests {
+    use super::{resolve_row_bg_hex, SelectRowState};
+
+    #[test]
+    fn test_resolve_row_bg_hex_uses_focused_accent_for_selected_row() {
+        let focused_bg_hex = 0x55AAFF3A;
+        let hovered_bg_hex = 0x55AAFF26;
+
+        let selected_row = SelectRowState {
+            is_focused: false,
+            is_selected: true,
+            is_hovered: false,
+        };
+
+        assert_eq!(
+            resolve_row_bg_hex(selected_row, focused_bg_hex, hovered_bg_hex),
+            focused_bg_hex
+        );
+    }
+
+    #[test]
+    fn test_resolve_row_bg_hex_uses_hover_color_for_unselected_hovered_row() {
+        let focused_bg_hex = 0x55AAFF3A;
+        let hovered_bg_hex = 0x55AAFF26;
+
+        let hovered_row = SelectRowState {
+            is_focused: false,
+            is_selected: false,
+            is_hovered: true,
+        };
+
+        assert_eq!(
+            resolve_row_bg_hex(hovered_row, focused_bg_hex, hovered_bg_hex),
+            hovered_bg_hex
+        );
+    }
+}

file update:
diff --git a/src/prompts/select/render.rs b/src/prompts/select/render.rs
index d0e0a5485f10066de9a287b70a4c3ae891e5cd99..95986e736108239384817ce9f36e8ea8c64a84a7
--- a/src/prompts/select/render.rs
+++ b/src/prompts/select/render.rs
@@ -24,6 +24,20 @@
     }
 }
 
+pub(super) fn resolve_row_bg_hex(
+    row_state: SelectRowState,
+    focused_bg_hex: u32,
+    hovered_bg_hex: u32,
+) -> u32 {
+    if row_state.is_focused || row_state.is_selected {
+        focused_bg_hex
+    } else if row_state.is_hovered {
+        hovered_bg_hex
+    } else {
+        0x00000000
+    }
+}
+
 pub(super) fn extract_choice_icon_hint(description: Option<&str>) -> Option<&str> {
     description.and_then(|raw| {
         raw.split(['•', '|', '\n'])
@@ -154,8 +168,9 @@
         } else {
             colors.accent
         };
-        let focused_row_bg = rgba((row_accent_color << 8) | ROW_FOCUSED_BG_ALPHA);
-        let hovered_row_bg = rgba((row_accent_color << 8) | ROW_HOVER_BG_ALPHA);
+        let focused_row_bg_hex = (row_accent_color << 8) | ROW_FOCUSED_BG_ALPHA;
+        let hovered_row_bg_hex = (row_accent_color << 8) | ROW_HOVER_BG_ALPHA;
+        let hovered_row_bg = rgba(hovered_row_bg_hex);
 
         let placeholder = self
             .placeholder
@@ -278,13 +293,11 @@
                                                     ))
                                                 },
                                             );
-                                        let row_bg = if is_focused {
-                                            focused_row_bg
-                                        } else if is_hovered {
-                                            hovered_row_bg
-                                        } else {
-                                            rgba(0x00000000)
-                                        };
+                                        let row_bg = rgba(resolve_row_bg_hex(
+                                            row_state,
+                                            focused_row_bg_hex,
+                                            hovered_row_bg_hex,
+                                        ));
                                         let hover_handler = cx.listener(
                                             move |this: &mut SelectPrompt,
                                                   hovered: &bool,
@@ -327,7 +340,7 @@
                                                 .colors(item_colors),
                                             );
 
-                                        if !is_focused {
+                                        if !is_focused && !is_selected {
                                             row = row.hover(move |s| s.bg(hovered_row_bg));
                                         }
 
@@ -376,3 +389,42 @@
             .child(choices_container)
     }
 }
+
+#[cfg(test)]
+mod tests {
+    use super::{resolve_row_bg_hex, SelectRowState};
+
+    #[test]
+    fn test_resolve_row_bg_hex_uses_focused_accent_for_selected_row() {
+        let focused_bg_hex = 0x55AAFF3A;
+        let hovered_bg_hex = 0x55AAFF26;
+
+        let selected_row = SelectRowState {
+            is_focused: false,
+            is_selected: true,
+            is_hovered: false,
+        };
+
+        assert_eq!(
+            resolve_row_bg_hex(selected_row, focused_bg_hex, hovered_bg_hex),
+            focused_bg_hex
+        );
+    }
+
+    #[test]
+    fn test_resolve_row_bg_hex_uses_hover_color_for_unselected_hovered_row() {
+        let focused_bg_hex = 0x55AAFF3A;
+        let hovered_bg_hex = 0x55AAFF26;
+
+        let hovered_row = SelectRowState {
+            is_focused: false,
+            is_selected: false,
+            is_hovered: true,
+        };
+
+        assert_eq!(
+            resolve_row_bg_hex(hovered_row, focused_bg_hex, hovered_bg_hex),
+            hovered_bg_hex
+        );
+    }
+}

 exited 101 in 2.84s:
    Checking script-kit-gpui v0.1.0 (/Users/johnlindquist/dev/script-kit-gpui)
error[E0599]: no method named `opacity` found for struct `gpui::Rgba` in the current scope
   --> src/prompts/select/render.rs:383:40
    |
383 |             .border_color(border_color.opacity(0.25))
    |                                        ^^^^^^^ method not found in `gpui::Rgba`

For more information about this error, try `rustc --explain E0599`.
error: could not compile `script-kit-gpui` (lib) due to 1 previous error

thinking
**Fixing opacity compile error**
codex
`cargo check` surfaced a compile error in this same file (`Rgba::opacity` is not available). I’m patching that border alpha call to explicit RGBA construction so verification can complete.

thinking
**Applying patch**
file update
M /Users/johnlindquist/dev/script-kit-gpui/src/prompts/select/render.rs
@@ -144,3 +144,3 @@
 
-        let (_main_bg, text_color, muted_color, border_color) =
+        let (_main_bg, text_color, muted_color, border_color, border_color_hex) =
             if self.design_variant == DesignVariant::Default {
@@ -151,2 +151,3 @@
                     rgb(self.theme.colors.ui.border),
+                    self.theme.colors.ui.border,
                 )
@@ -158,2 +159,3 @@
                     rgb(colors.border),
+                    colors.border,
                 )
@@ -382,3 +384,3 @@
             .border_1()
-            .border_color(border_color.opacity(0.25))
+            .border_color(rgba((border_color_hex << 8) | 0x40))
             .text_color(text_color)
apply_patch(auto_approved=true) exited 0 in 13ms:
Success. Updated the following files:
M src/prompts/select/render.rs
file update:
diff --git a/src/prompts/select/render.rs b/src/prompts/select/render.rs
index d0e0a5485f10066de9a287b70a4c3ae891e5cd99..c26ba855b7e69a16a4d3e1b048889d3588ac5525
--- a/src/prompts/select/render.rs
+++ b/src/prompts/select/render.rs
@@ -24,6 +24,20 @@
     }
 }
 
+pub(super) fn resolve_row_bg_hex(
+    row_state: SelectRowState,
+    focused_bg_hex: u32,
+    hovered_bg_hex: u32,
+) -> u32 {
+    if row_state.is_focused || row_state.is_selected {
+        focused_bg_hex
+    } else if row_state.is_hovered {
+        hovered_bg_hex
+    } else {
+        0x00000000
+    }
+}
+
 pub(super) fn extract_choice_icon_hint(description: Option<&str>) -> Option<&str> {
     description.and_then(|raw| {
         raw.split(['•', '|', '\n'])
@@ -128,13 +142,14 @@
         // VIBRANCY: Optional background override when a vibrancy surface is available.
         let vibrancy_bg = get_vibrancy_background(&self.theme);
 
-        let (_main_bg, text_color, muted_color, border_color) =
+        let (_main_bg, text_color, muted_color, border_color, border_color_hex) =
             if self.design_variant == DesignVariant::Default {
                 (
                     rgb(self.theme.colors.background.main),
                     rgb(self.theme.colors.text.secondary),
                     rgb(self.theme.colors.text.muted),
                     rgb(self.theme.colors.ui.border),
+                    self.theme.colors.ui.border,
                 )
             } else {
                 (
@@ -142,6 +157,7 @@
                     rgb(colors.text_secondary),
                     rgb(colors.text_muted),
                     rgb(colors.border),
+                    colors.border,
                 )
             };
         let search_box_bg = rgb(resolve_search_box_bg_hex(
@@ -154,8 +170,9 @@
         } else {
             colors.accent
         };
-        let focused_row_bg = rgba((row_accent_color << 8) | ROW_FOCUSED_BG_ALPHA);
-        let hovered_row_bg = rgba((row_accent_color << 8) | ROW_HOVER_BG_ALPHA);
+        let focused_row_bg_hex = (row_accent_color << 8) | ROW_FOCUSED_BG_ALPHA;
+        let hovered_row_bg_hex = (row_accent_color << 8) | ROW_HOVER_BG_ALPHA;
+        let hovered_row_bg = rgba(hovered_row_bg_hex);
 
         let placeholder = self
             .placeholder
@@ -278,13 +295,11 @@
                                                     ))
                                                 },
                                             );
-                                        let row_bg = if is_focused {
-                                            focused_row_bg
-                                        } else if is_hovered {
-                                            hovered_row_bg
-                                        } else {
-                                            rgba(0x00000000)
-                                        };
+                                        let row_bg = rgba(resolve_row_bg_hex(
+                                            row_state,
+                                            focused_row_bg_hex,
+                                            hovered_row_bg_hex,
+                                        ));
                                         let hover_handler = cx.listener(
                                             move |this: &mut SelectPrompt,
                                                   hovered: &bool,
@@ -327,7 +342,7 @@
                                                 .colors(item_colors),
                                             );
 
-                                        if !is_focused {
+                                        if !is_focused && !is_selected {
                                             row = row.hover(move |s| s.bg(hovered_row_bg));
                                         }
 
@@ -367,7 +382,7 @@
             .rounded(px(12.0))
             .overflow_hidden()
             .border_1()
-            .border_color(border_color.opacity(0.25))
+            .border_color(rgba((border_color_hex << 8) | 0x40))
             .text_color(text_color)
             .key_context("select_prompt")
             .track_focus(&self.focus_handle)
@@ -376,3 +391,42 @@
             .child(choices_container)
     }
 }
+
+#[cfg(test)]
+mod tests {
+    use super::{resolve_row_bg_hex, SelectRowState};
+
+    #[test]
+    fn test_resolve_row_bg_hex_uses_focused_accent_for_selected_row() {
+        let focused_bg_hex = 0x55AAFF3A;
+        let hovered_bg_hex = 0x55AAFF26;
+
+        let selected_row = SelectRowState {
+            is_focused: false,
+            is_selected: true,
+            is_hovered: false,
+        };
+
+        assert_eq!(
+            resolve_row_bg_hex(selected_row, focused_bg_hex, hovered_bg_hex),
+            focused_bg_hex
+        );
+    }
+
+    #[test]
+    fn test_resolve_row_bg_hex_uses_hover_color_for_unselected_hovered_row() {
+        let focused_bg_hex = 0x55AAFF3A;
+        let hovered_bg_hex = 0x55AAFF26;
+
+        let hovered_row = SelectRowState {
+            is_focused: false,
+            is_selected: false,
+            is_hovered: true,
+        };
+
+        assert_eq!(
+            resolve_row_bg_hex(hovered_row, focused_bg_hex, hovered_bg_hex),
+            hovered_bg_hex
+        );
+    }
+}

file update:
diff --git a/src/prompts/select/render.rs b/src/prompts/select/render.rs
index d0e0a5485f10066de9a287b70a4c3ae891e5cd99..c26ba855b7e69a16a4d3e1b048889d3588ac5525
--- a/src/prompts/select/render.rs
+++ b/src/prompts/select/render.rs
@@ -24,6 +24,20 @@
     }
 }
 
+pub(super) fn resolve_row_bg_hex(
+    row_state: SelectRowState,
+    focused_bg_hex: u32,
+    hovered_bg_hex: u32,
+) -> u32 {
+    if row_state.is_focused || row_state.is_selected {
+        focused_bg_hex
+    } else if row_state.is_hovered {
+        hovered_bg_hex
+    } else {
+        0x00000000
+    }
+}
+
 pub(super) fn extract_choice_icon_hint(description: Option<&str>) -> Option<&str> {
     description.and_then(|raw| {
         raw.split(['•', '|', '\n'])
@@ -128,13 +142,14 @@
         // VIBRANCY: Optional background override when a vibrancy surface is available.
         let vibrancy_bg = get_vibrancy_background(&self.theme);
 
-        let (_main_bg, text_color, muted_color, border_color) =
+        let (_main_bg, text_color, muted_color, border_color, border_color_hex) =
             if self.design_variant == DesignVariant::Default {
                 (
                     rgb(self.theme.colors.background.main),
                     rgb(self.theme.colors.text.secondary),
                     rgb(self.theme.colors.text.muted),
                     rgb(self.theme.colors.ui.border),
+                    self.theme.colors.ui.border,
                 )
             } else {
                 (
@@ -142,6 +157,7 @@
                     rgb(colors.text_secondary),
                     rgb(colors.text_muted),
                     rgb(colors.border),
+                    colors.border,
                 )
             };
         let search_box_bg = rgb(resolve_search_box_bg_hex(
@@ -154,8 +170,9 @@
         } else {
             colors.accent
         };
-        let focused_row_bg = rgba((row_accent_color << 8) | ROW_FOCUSED_BG_ALPHA);
-        let hovered_row_bg = rgba((row_accent_color << 8) | ROW_HOVER_BG_ALPHA);
+        let focused_row_bg_hex = (row_accent_color << 8) | ROW_FOCUSED_BG_ALPHA;
+        let hovered_row_bg_hex = (row_accent_color << 8) | ROW_HOVER_BG_ALPHA;
+        let hovered_row_bg = rgba(hovered_row_bg_hex);
 
         let placeholder = self
             .placeholder
@@ -278,13 +295,11 @@
                                                     ))
                                                 },
                                             );
-                                        let row_bg = if is_focused {
-                                            focused_row_bg
-                                        } else if is_hovered {
-                                            hovered_row_bg
-                                        } else {
-                                            rgba(0x00000000)
-                                        };
+                                        let row_bg = rgba(resolve_row_bg_hex(
+                                            row_state,
+                                            focused_row_bg_hex,
+                                            hovered_row_bg_hex,
+                                        ));
                                         let hover_handler = cx.listener(
                                             move |this: &mut SelectPrompt,
                                                   hovered: &bool,
@@ -327,7 +342,7 @@
                                                 .colors(item_colors),
                                             );
 
-                                        if !is_focused {
+                                        if !is_focused && !is_selected {
                                             row = row.hover(move |s| s.bg(hovered_row_bg));
                                         }
 
@@ -367,7 +382,7 @@
             .rounded(px(12.0))
             .overflow_hidden()
             .border_1()
-            .border_color(border_color.opacity(0.25))
+            .border_color(rgba((border_color_hex << 8) | 0x40))
             .text_color(text_color)
             .key_context("select_prompt")
             .track_focus(&self.focus_handle)
@@ -376,3 +391,42 @@
             .child(choices_container)
     }
 }
+
+#[cfg(test)]
+mod tests {
+    use super::{resolve_row_bg_hex, SelectRowState};
+
+    #[test]
+    fn test_resolve_row_bg_hex_uses_focused_accent_for_selected_row() {
+        let focused_bg_hex = 0x55AAFF3A;
+        let hovered_bg_hex = 0x55AAFF26;
+
+        let selected_row = SelectRowState {
+            is_focused: false,
+            is_selected: true,
+            is_hovered: false,
+        };
+
+        assert_eq!(
+            resolve_row_bg_hex(selected_row, focused_bg_hex, hovered_bg_hex),
+            focused_bg_hex
+        );
+    }
+
+    #[test]
+    fn test_resolve_row_bg_hex_uses_hover_color_for_unselected_hovered_row() {
+        let focused_bg_hex = 0x55AAFF3A;
+        let hovered_bg_hex = 0x55AAFF26;
+
+        let hovered_row = SelectRowState {
+            is_focused: false,
+            is_selected: false,
+            is_hovered: true,
+        };
+
+        assert_eq!(
+            resolve_row_bg_hex(hovered_row, focused_bg_hex, hovered_bg_hex),
+            hovered_bg_hex
+        );
+    }
+}


thinking
**Restarting build checks**
exec
/bin/zsh -lc 'cargo check -p script-kit-gpui' in /Users/johnlindquist/dev/script-kit-gpuifile update:
diff --git a/src/prompts/select/render.rs b/src/prompts/select/render.rs
index d0e0a5485f10066de9a287b70a4c3ae891e5cd99..c26ba855b7e69a16a4d3e1b048889d3588ac5525
--- a/src/prompts/select/render.rs
+++ b/src/prompts/select/render.rs
@@ -24,6 +24,20 @@
     }
 }
 
+pub(super) fn resolve_row_bg_hex(
+    row_state: SelectRowState,
+    focused_bg_hex: u32,
+    hovered_bg_hex: u32,
+) -> u32 {
+    if row_state.is_focused || row_state.is_selected {
+        focused_bg_hex
+    } else if row_state.is_hovered {
+        hovered_bg_hex
+    } else {
+        0x00000000
+    }
+}
+
 pub(super) fn extract_choice_icon_hint(description: Option<&str>) -> Option<&str> {
     description.and_then(|raw| {
         raw.split(['•', '|', '\n'])
@@ -128,13 +142,14 @@
         // VIBRANCY: Optional background override when a vibrancy surface is available.
         let vibrancy_bg = get_vibrancy_background(&self.theme);
 
-        let (_main_bg, text_color, muted_color, border_color) =
+        let (_main_bg, text_color, muted_color, border_color, border_color_hex) =
             if self.design_variant == DesignVariant::Default {
                 (
                     rgb(self.theme.colors.background.main),
                     rgb(self.theme.colors.text.secondary),
                     rgb(self.theme.colors.text.muted),
                     rgb(self.theme.colors.ui.border),
+                    self.theme.colors.ui.border,
                 )
             } else {
                 (
@@ -142,6 +157,7 @@
                     rgb(colors.text_secondary),
                     rgb(colors.text_muted),
                     rgb(colors.border),
+                    colors.border,
                 )
             };
         let search_box_bg = rgb(resolve_search_box_bg_hex(
@@ -154,8 +170,9 @@
         } else {
             colors.accent
         };
-        let focused_row_bg = rgba((row_accent_color << 8) | ROW_FOCUSED_BG_ALPHA);
-        let hovered_row_bg = rgba((row_accent_color << 8) | ROW_HOVER_BG_ALPHA);
+        let focused_row_bg_hex = (row_accent_color << 8) | ROW_FOCUSED_BG_ALPHA;
+        let hovered_row_bg_hex = (row_accent_color << 8) | ROW_HOVER_BG_ALPHA;
+        let hovered_row_bg = rgba(hovered_row_bg_hex);
 
         let placeholder = self
             .placeholder
@@ -278,13 +295,11 @@
                                                     ))
                                                 },
                                             );
-                                        let row_bg = if is_focused {
-                                            focused_row_bg
-                                        } else if is_hovered {
-                                            hovered_row_bg
-                                        } else {
-                                            rgba(0x00000000)
-                                        };
+                                        let row_bg = rgba(resolve_row_bg_hex(
+                                            row_state,
+                                            focused_row_bg_hex,
+                                            hovered_row_bg_hex,
+                                        ));
                                         let hover_handler = cx.listener(
                                             move |this: &mut SelectPrompt,
                                                   hovered: &bool,
@@ -327,7 +342,7 @@
                                                 .colors(item_colors),
                                             );
 
-                                        if !is_focused {
+                                        if !is_focused && !is_selected {
                                             row = row.hover(move |s| s.bg(hovered_row_bg));
                                         }
 
@@ -367,7 +382,7 @@
             .rounded(px(12.0))
             .overflow_hidden()
             .border_1()
-            .border_color(border_color.opacity(0.25))
+            .border_color(rgba((border_color_hex << 8) | 0x40))
             .text_color(text_color)
             .key_context("select_prompt")
             .track_focus(&self.focus_handle)
@@ -376,3 +391,42 @@
             .child(choices_container)
     }
 }
+
+#[cfg(test)]
+mod tests {
+    use super::{resolve_row_bg_hex, SelectRowState};
+
+    #[test]
+    fn test_resolve_row_bg_hex_uses_focused_accent_for_selected_row() {
+        let focused_bg_hex = 0x55AAFF3A;
+        let hovered_bg_hex = 0x55AAFF26;
+
+        let selected_row = SelectRowState {
+            is_focused: false,
+            is_selected: true,
+            is_hovered: false,
+        };
+
+        assert_eq!(
+            resolve_row_bg_hex(selected_row, focused_bg_hex, hovered_bg_hex),
+            focused_bg_hex
+        );
+    }
+
+    #[test]
+    fn test_resolve_row_bg_hex_uses_hover_color_for_unselected_hovered_row() {
+        let focused_bg_hex = 0x55AAFF3A;
+        let hovered_bg_hex = 0x55AAFF26;
+
+        let hovered_row = SelectRowState {
+            is_focused: false,
+            is_selected: false,
+            is_hovered: true,
+        };
+
+        assert_eq!(
+            resolve_row_bg_hex(hovered_row, focused_bg_hex, hovered_bg_hex),
+            hovered_bg_hex
+        );
+    }
+}


thinking
**Planning completion polling**
file update:
diff --git a/src/prompts/select/render.rs b/src/prompts/select/render.rs
index d0e0a5485f10066de9a287b70a4c3ae891e5cd99..c26ba855b7e69a16a4d3e1b048889d3588ac5525
--- a/src/prompts/select/render.rs
+++ b/src/prompts/select/render.rs
@@ -24,6 +24,20 @@
     }
 }
 
+pub(super) fn resolve_row_bg_hex(
+    row_state: SelectRowState,
+    focused_bg_hex: u32,
+    hovered_bg_hex: u32,
+) -> u32 {
+    if row_state.is_focused || row_state.is_selected {
+        focused_bg_hex
+    } else if row_state.is_hovered {
+        hovered_bg_hex
+    } else {
+        0x00000000
+    }
+}
+
 pub(super) fn extract_choice_icon_hint(description: Option<&str>) -> Option<&str> {
     description.and_then(|raw| {
         raw.split(['•', '|', '\n'])
@@ -128,13 +142,14 @@
         // VIBRANCY: Optional background override when a vibrancy surface is available.
         let vibrancy_bg = get_vibrancy_background(&self.theme);
 
-        let (_main_bg, text_color, muted_color, border_color) =
+        let (_main_bg, text_color, muted_color, border_color, border_color_hex) =
             if self.design_variant == DesignVariant::Default {
                 (
                     rgb(self.theme.colors.background.main),
                     rgb(self.theme.colors.text.secondary),
                     rgb(self.theme.colors.text.muted),
                     rgb(self.theme.colors.ui.border),
+                    self.theme.colors.ui.border,
                 )
             } else {
                 (
@@ -142,6 +157,7 @@
                     rgb(colors.text_secondary),
                     rgb(colors.text_muted),
                     rgb(colors.border),
+                    colors.border,
                 )
             };
         let search_box_bg = rgb(resolve_search_box_bg_hex(
@@ -154,8 +170,9 @@
         } else {
             colors.accent
         };
-        let focused_row_bg = rgba((row_accent_color << 8) | ROW_FOCUSED_BG_ALPHA);
-        let hovered_row_bg = rgba((row_accent_color << 8) | ROW_HOVER_BG_ALPHA);
+        let focused_row_bg_hex = (row_accent_color << 8) | ROW_FOCUSED_BG_ALPHA;
+        let hovered_row_bg_hex = (row_accent_color << 8) | ROW_HOVER_BG_ALPHA;
+        let hovered_row_bg = rgba(hovered_row_bg_hex);
 
         let placeholder = self
             .placeholder
@@ -278,13 +295,11 @@
                                                     ))
                                                 },
                                             );
-                                        let row_bg = if is_focused {
-                                            focused_row_bg
-                                        } else if is_hovered {
-                                            hovered_row_bg
-                                        } else {
-                                            rgba(0x00000000)
-                                        };
+                                        let row_bg = rgba(resolve_row_bg_hex(
+                                            row_state,
+                                            focused_row_bg_hex,
+                                            hovered_row_bg_hex,
+                                        ));
                                         let hover_handler = cx.listener(
                                             move |this: &mut SelectPrompt,
                                                   hovered: &bool,
@@ -327,7 +342,7 @@
                                                 .colors(item_colors),
                                             );
 
-                                        if !is_focused {
+                                        if !is_focused && !is_selected {
                                             row = row.hover(move |s| s.bg(hovered_row_bg));
                                         }
 
@@ -367,7 +382,7 @@
             .rounded(px(12.0))
             .overflow_hidden()
             .border_1()
-            .border_color(border_color.opacity(0.25))
+            .border_color(rgba((border_color_hex << 8) | 0x40))
             .text_color(text_color)
             .key_context("select_prompt")
             .track_focus(&self.focus_handle)
@@ -376,3 +391,42 @@
             .child(choices_container)
     }
 }
+
+#[cfg(test)]
+mod tests {
+    use super::{resolve_row_bg_hex, SelectRowState};
+
+    #[test]
+    fn test_resolve_row_bg_hex_uses_focused_accent_for_selected_row() {
+        let focused_bg_hex = 0x55AAFF3A;
+        let hovered_bg_hex = 0x55AAFF26;
+
+        let selected_row = SelectRowState {
+            is_focused: false,
+            is_selected: true,
+            is_hovered: false,
+        };
+
+        assert_eq!(
+            resolve_row_bg_hex(selected_row, focused_bg_hex, hovered_bg_hex),
+            focused_bg_hex
+        );
+    }
+
+    #[test]
+    fn test_resolve_row_bg_hex_uses_hover_color_for_unselected_hovered_row() {
+        let focused_bg_hex = 0x55AAFF3A;
+        let hovered_bg_hex = 0x55AAFF26;
+
+        let hovered_row = SelectRowState {
+            is_focused: false,
+            is_selected: false,
+            is_hovered: true,
+        };
+
+        assert_eq!(
+            resolve_row_bg_hex(hovered_row, focused_bg_hex, hovered_bg_hex),
+            hovered_bg_hex
+        );
+    }
+}

file update:
diff --git a/src/prompts/select/render.rs b/src/prompts/select/render.rs
index d0e0a5485f10066de9a287b70a4c3ae891e5cd99..c26ba855b7e69a16a4d3e1b048889d3588ac5525
--- a/src/prompts/select/render.rs
+++ b/src/prompts/select/render.rs
@@ -24,6 +24,20 @@
     }
 }
 
+pub(super) fn resolve_row_bg_hex(
+    row_state: SelectRowState,
+    focused_bg_hex: u32,
+    hovered_bg_hex: u32,
+) -> u32 {
+    if row_state.is_focused || row_state.is_selected {
+        focused_bg_hex
+    } else if row_state.is_hovered {
+        hovered_bg_hex
+    } else {
+        0x00000000
+    }
+}
+
 pub(super) fn extract_choice_icon_hint(description: Option<&str>) -> Option<&str> {
     description.and_then(|raw| {
         raw.split(['•', '|', '\n'])
@@ -128,13 +142,14 @@
         // VIBRANCY: Optional background override when a vibrancy surface is available.
         let vibrancy_bg = get_vibrancy_background(&self.theme);
 
-        let (_main_bg, text_color, muted_color, border_color) =
+        let (_main_bg, text_color, muted_color, border_color, border_color_hex) =
             if self.design_variant == DesignVariant::Default {
                 (
                     rgb(self.theme.colors.background.main),
                     rgb(self.theme.colors.text.secondary),
                     rgb(self.theme.colors.text.muted),
                     rgb(self.theme.colors.ui.border),
+                    self.theme.colors.ui.border,
                 )
             } else {
                 (
@@ -142,6 +157,7 @@
                     rgb(colors.text_secondary),
                     rgb(colors.text_muted),
                     rgb(colors.border),
+                    colors.border,
                 )
             };
         let search_box_bg = rgb(resolve_search_box_bg_hex(
@@ -154,8 +170,9 @@
         } else {
             colors.accent
         };
-        let focused_row_bg = rgba((row_accent_color << 8) | ROW_FOCUSED_BG_ALPHA);
-        let hovered_row_bg = rgba((row_accent_color << 8) | ROW_HOVER_BG_ALPHA);
+        let focused_row_bg_hex = (row_accent_color << 8) | ROW_FOCUSED_BG_ALPHA;
+        let hovered_row_bg_hex = (row_accent_color << 8) | ROW_HOVER_BG_ALPHA;
+        let hovered_row_bg = rgba(hovered_row_bg_hex);
 
         let placeholder = self
             .placeholder
@@ -278,13 +295,11 @@
                                                     ))
                                                 },
                                             );
-                                        let row_bg = if is_focused {
-                                            focused_row_bg
-                                        } else if is_hovered {
-                                            hovered_row_bg
-                                        } else {
-                                            rgba(0x00000000)
-                                        };
+                                        let row_bg = rgba(resolve_row_bg_hex(
+                                            row_state,
+                                            focused_row_bg_hex,
+                                            hovered_row_bg_hex,
+                                        ));
                                         let hover_handler = cx.listener(
                                             move |this: &mut SelectPrompt,
                                                   hovered: &bool,
@@ -327,7 +342,7 @@
                                                 .colors(item_colors),
                                             );
 
-                                        if !is_focused {
+                                        if !is_focused && !is_selected {
                                             row = row.hover(move |s| s.bg(hovered_row_bg));
                                         }
 
@@ -367,7 +382,7 @@
             .rounded(px(12.0))
             .overflow_hidden()
             .border_1()
-            .border_color(border_color.opacity(0.25))
+            .border_color(rgba((border_color_hex << 8) | 0x40))
             .text_color(text_color)
             .key_context("select_prompt")
             .track_focus(&self.focus_handle)
@@ -376,3 +391,42 @@
             .child(choices_container)
     }
 }
+
+#[cfg(test)]
+mod tests {
+    use super::{resolve_row_bg_hex, SelectRowState};
+
+    #[test]
+    fn test_resolve_row_bg_hex_uses_focused_accent_for_selected_row() {
+        let focused_bg_hex = 0x55AAFF3A;
+        let hovered_bg_hex = 0x55AAFF26;
+
+        let selected_row = SelectRowState {
+            is_focused: false,
+            is_selected: true,
+            is_hovered: false,
+        };
+
+        assert_eq!(
+            resolve_row_bg_hex(selected_row, focused_bg_hex, hovered_bg_hex),
+            focused_bg_hex
+        );
+    }
+
+    #[test]
+    fn test_resolve_row_bg_hex_uses_hover_color_for_unselected_hovered_row() {
+        let focused_bg_hex = 0x55AAFF3A;
+        let hovered_bg_hex = 0x55AAFF26;
+
+        let hovered_row = SelectRowState {
+            is_focused: false,
+            is_selected: false,
+            is_hovered: true,
+        };
+
+        assert_eq!(
+            resolve_row_bg_hex(hovered_row, focused_bg_hex, hovered_bg_hex),
+            hovered_bg_hex
+        );
+    }
+}


thinking
**Notifying about potential delay**
codex
Build is currently waiting on the shared Cargo target lock from another agent process. I’m continuing to poll and will resume clippy/tests immediately once the lock clears.
file update:
diff --git a/src/prompts/select/render.rs b/src/prompts/select/render.rs
index d0e0a5485f10066de9a287b70a4c3ae891e5cd99..c26ba855b7e69a16a4d3e1b048889d3588ac5525
--- a/src/prompts/select/render.rs
+++ b/src/prompts/select/render.rs
@@ -24,6 +24,20 @@
     }
 }
 
+pub(super) fn resolve_row_bg_hex(
+    row_state: SelectRowState,
+    focused_bg_hex: u32,
+    hovered_bg_hex: u32,
+) -> u32 {
+    if row_state.is_focused || row_state.is_selected {
+        focused_bg_hex
+    } else if row_state.is_hovered {
+        hovered_bg_hex
+    } else {
+        0x00000000
+    }
+}
+
 pub(super) fn extract_choice_icon_hint(description: Option<&str>) -> Option<&str> {
     description.and_then(|raw| {
         raw.split(['•', '|', '\n'])
@@ -128,13 +142,14 @@
         // VIBRANCY: Optional background override when a vibrancy surface is available.
         let vibrancy_bg = get_vibrancy_background(&self.theme);
 
-        let (_main_bg, text_color, muted_color, border_color) =
+        let (_main_bg, text_color, muted_color, border_color, border_color_hex) =
             if self.design_variant == DesignVariant::Default {
                 (
                     rgb(self.theme.colors.background.main),
                     rgb(self.theme.colors.text.secondary),
                     rgb(self.theme.colors.text.muted),
                     rgb(self.theme.colors.ui.border),
+                    self.theme.colors.ui.border,
                 )
             } else {
                 (
@@ -142,6 +157,7 @@
                     rgb(colors.text_secondary),
                     rgb(colors.text_muted),
                     rgb(colors.border),
+                    colors.border,
                 )
             };
         let search_box_bg = rgb(resolve_search_box_bg_hex(
@@ -154,8 +170,9 @@
         } else {
             colors.accent
         };
-        let focused_row_bg = rgba((row_accent_color << 8) | ROW_FOCUSED_BG_ALPHA);
-        let hovered_row_bg = rgba((row_accent_color << 8) | ROW_HOVER_BG_ALPHA);
+        let focused_row_bg_hex = (row_accent_color << 8) | ROW_FOCUSED_BG_ALPHA;
+        let hovered_row_bg_hex = (row_accent_color << 8) | ROW_HOVER_BG_ALPHA;
+        let hovered_row_bg = rgba(hovered_row_bg_hex);
 
         let placeholder = self
             .placeholder
@@ -278,13 +295,11 @@
                                                     ))
                                                 },
                                             );
-                                        let row_bg = if is_focused {
-                                            focused_row_bg
-                                        } else if is_hovered {
-                                            hovered_row_bg
-                                        } else {
-                                            rgba(0x00000000)
-                                        };
+                                        let row_bg = rgba(resolve_row_bg_hex(
+                                            row_state,
+                                            focused_row_bg_hex,
+                                            hovered_row_bg_hex,
+                                        ));
                                         let hover_handler = cx.listener(
                                             move |this: &mut SelectPrompt,
                                                   hovered: &bool,
@@ -327,7 +342,7 @@
                                                 .colors(item_colors),
                                             );
 
-                                        if !is_focused {
+                                        if !is_focused && !is_selected {
                                             row = row.hover(move |s| s.bg(hovered_row_bg));
                                         }
 
@@ -367,7 +382,7 @@
             .rounded(px(12.0))
             .overflow_hidden()
             .border_1()
-            .border_color(border_color.opacity(0.25))
+            .border_color(rgba((border_color_hex << 8) | 0x40))
             .text_color(text_color)
             .key_context("select_prompt")
             .track_focus(&self.focus_handle)
@@ -376,3 +391,42 @@
             .child(choices_container)
     }
 }
+
+#[cfg(test)]
+mod tests {
+    use super::{resolve_row_bg_hex, SelectRowState};
+
+    #[test]
+    fn test_resolve_row_bg_hex_uses_focused_accent_for_selected_row() {
+        let focused_bg_hex = 0x55AAFF3A;
+        let hovered_bg_hex = 0x55AAFF26;
+
+        let selected_row = SelectRowState {
+            is_focused: false,
+            is_selected: true,
+            is_hovered: false,
+        };
+
+        assert_eq!(
+            resolve_row_bg_hex(selected_row, focused_bg_hex, hovered_bg_hex),
+            focused_bg_hex
+        );
+    }
+
+    #[test]
+    fn test_resolve_row_bg_hex_uses_hover_color_for_unselected_hovered_row() {
+        let focused_bg_hex = 0x55AAFF3A;
+        let hovered_bg_hex = 0x55AAFF26;
+
+        let hovered_row = SelectRowState {
+            is_focused: false,
+            is_selected: false,
+            is_hovered: true,
+        };
+
+        assert_eq!(
+            resolve_row_bg_hex(hovered_row, focused_bg_hex, hovered_bg_hex),
+            hovered_bg_hex
+        );
+    }
+}


thinking
**Evaluating build process status**
file update:
diff --git a/src/prompts/select/render.rs b/src/prompts/select/render.rs
index d0e0a5485f10066de9a287b70a4c3ae891e5cd99..c26ba855b7e69a16a4d3e1b048889d3588ac5525
--- a/src/prompts/select/render.rs
+++ b/src/prompts/select/render.rs
@@ -24,6 +24,20 @@
     }
 }
 
+pub(super) fn resolve_row_bg_hex(
+    row_state: SelectRowState,
+    focused_bg_hex: u32,
+    hovered_bg_hex: u32,
+) -> u32 {
+    if row_state.is_focused || row_state.is_selected {
+        focused_bg_hex
+    } else if row_state.is_hovered {
+        hovered_bg_hex
+    } else {
+        0x00000000
+    }
+}
+
 pub(super) fn extract_choice_icon_hint(description: Option<&str>) -> Option<&str> {
     description.and_then(|raw| {
         raw.split(['•', '|', '\n'])
@@ -128,13 +142,14 @@
         // VIBRANCY: Optional background override when a vibrancy surface is available.
         let vibrancy_bg = get_vibrancy_background(&self.theme);
 
-        let (_main_bg, text_color, muted_color, border_color) =
+        let (_main_bg, text_color, muted_color, border_color, border_color_hex) =
             if self.design_variant == DesignVariant::Default {
                 (
                     rgb(self.theme.colors.background.main),
                     rgb(self.theme.colors.text.secondary),
                     rgb(self.theme.colors.text.muted),
                     rgb(self.theme.colors.ui.border),
+                    self.theme.colors.ui.border,
                 )
             } else {
                 (
@@ -142,6 +157,7 @@
                     rgb(colors.text_secondary),
                     rgb(colors.text_muted),
                     rgb(colors.border),
+                    colors.border,
                 )
             };
         let search_box_bg = rgb(resolve_search_box_bg_hex(
@@ -154,8 +170,9 @@
         } else {
             colors.accent
         };
-        let focused_row_bg = rgba((row_accent_color << 8) | ROW_FOCUSED_BG_ALPHA);
-        let hovered_row_bg = rgba((row_accent_color << 8) | ROW_HOVER_BG_ALPHA);
+        let focused_row_bg_hex = (row_accent_color << 8) | ROW_FOCUSED_BG_ALPHA;
+        let hovered_row_bg_hex = (row_accent_color << 8) | ROW_HOVER_BG_ALPHA;
+        let hovered_row_bg = rgba(hovered_row_bg_hex);
 
         let placeholder = self
             .placeholder
@@ -278,13 +295,11 @@
                                                     ))
                                                 },
                                             );
-                                        let row_bg = if is_focused {
-                                            focused_row_bg
-                                        } else if is_hovered {
-                                            hovered_row_bg
-                                        } else {
-                                            rgba(0x00000000)
-                                        };
+                                        let row_bg = rgba(resolve_row_bg_hex(
+                                            row_state,
+                                            focused_row_bg_hex,
+                                            hovered_row_bg_hex,
+                                        ));
                                         let hover_handler = cx.listener(
                                             move |this: &mut SelectPrompt,
                                                   hovered: &bool,
@@ -327,7 +342,7 @@
                                                 .colors(item_colors),
                                             );
 
-                                        if !is_focused {
+                                        if !is_focused && !is_selected {
                                             row = row.hover(move |s| s.bg(hovered_row_bg));
                                         }
 
@@ -367,7 +382,7 @@
             .rounded(px(12.0))
             .overflow_hidden()
             .border_1()
-            .border_color(border_color.opacity(0.25))
+            .border_color(rgba((border_color_hex << 8) | 0x40))
             .text_color(text_color)
             .key_context("select_prompt")
             .track_focus(&self.focus_handle)
@@ -376,3 +391,42 @@
             .child(choices_container)
     }
 }
+
+#[cfg(test)]
+mod tests {
+    use super::{resolve_row_bg_hex, SelectRowState};
+
+    #[test]
+    fn test_resolve_row_bg_hex_uses_focused_accent_for_selected_row() {
+        let focused_bg_hex = 0x55AAFF3A;
+        let hovered_bg_hex = 0x55AAFF26;
+
+        let selected_row = SelectRowState {
+            is_focused: false,
+            is_selected: true,
+            is_hovered: false,
+        };
+
+        assert_eq!(
+            resolve_row_bg_hex(selected_row, focused_bg_hex, hovered_bg_hex),
+            focused_bg_hex
+        );
+    }
+
+    #[test]
+    fn test_resolve_row_bg_hex_uses_hover_color_for_unselected_hovered_row() {
+        let focused_bg_hex = 0x55AAFF3A;
+        let hovered_bg_hex = 0x55AAFF26;
+
+        let hovered_row = SelectRowState {
+            is_focused: false,
+            is_selected: false,
+            is_hovered: true,
+        };
+
+        assert_eq!(
+            resolve_row_bg_hex(hovered_row, focused_bg_hex, hovered_bg_hex),
+            hovered_bg_hex
+        );
+    }
+}

file update:
diff --git a/src/prompts/select/render.rs b/src/prompts/select/render.rs
index d0e0a5485f10066de9a287b70a4c3ae891e5cd99..c26ba855b7e69a16a4d3e1b048889d3588ac5525
--- a/src/prompts/select/render.rs
+++ b/src/prompts/select/render.rs
@@ -24,6 +24,20 @@
     }
 }
 
+pub(super) fn resolve_row_bg_hex(
+    row_state: SelectRowState,
+    focused_bg_hex: u32,
+    hovered_bg_hex: u32,
+) -> u32 {
+    if row_state.is_focused || row_state.is_selected {
+        focused_bg_hex
+    } else if row_state.is_hovered {
+        hovered_bg_hex
+    } else {
+        0x00000000
+    }
+}
+
 pub(super) fn extract_choice_icon_hint(description: Option<&str>) -> Option<&str> {
     description.and_then(|raw| {
         raw.split(['•', '|', '\n'])
@@ -128,13 +142,14 @@
         // VIBRANCY: Optional background override when a vibrancy surface is available.
         let vibrancy_bg = get_vibrancy_background(&self.theme);
 
-        let (_main_bg, text_color, muted_color, border_color) =
+        let (_main_bg, text_color, muted_color, border_color, border_color_hex) =
             if self.design_variant == DesignVariant::Default {
                 (
                     rgb(self.theme.colors.background.main),
                     rgb(self.theme.colors.text.secondary),
                     rgb(self.theme.colors.text.muted),
                     rgb(self.theme.colors.ui.border),
+                    self.theme.colors.ui.border,
                 )
             } else {
                 (
@@ -142,6 +157,7 @@
                     rgb(colors.text_secondary),
                     rgb(colors.text_muted),
                     rgb(colors.border),
+                    colors.border,
                 )
             };
         let search_box_bg = rgb(resolve_search_box_bg_hex(
@@ -154,8 +170,9 @@
         } else {
             colors.accent
         };
-        let focused_row_bg = rgba((row_accent_color << 8) | ROW_FOCUSED_BG_ALPHA);
-        let hovered_row_bg = rgba((row_accent_color << 8) | ROW_HOVER_BG_ALPHA);
+        let focused_row_bg_hex = (row_accent_color << 8) | ROW_FOCUSED_BG_ALPHA;
+        let hovered_row_bg_hex = (row_accent_color << 8) | ROW_HOVER_BG_ALPHA;
+        let hovered_row_bg = rgba(hovered_row_bg_hex);
 
         let placeholder = self
             .placeholder
@@ -278,13 +295,11 @@
                                                     ))
                                                 },
                                             );
-                                        let row_bg = if is_focused {
-                                            focused_row_bg
-                                        } else if is_hovered {
-                                            hovered_row_bg
-                                        } else {
-                                            rgba(0x00000000)
-                                        };
+                                        let row_bg = rgba(resolve_row_bg_hex(
+                                            row_state,
+                                            focused_row_bg_hex,
+                                            hovered_row_bg_hex,
+                                        ));
                                         let hover_handler = cx.listener(
                                             move |this: &mut SelectPrompt,
                                                   hovered: &bool,
@@ -327,7 +342,7 @@
                                                 .colors(item_colors),
                                             );
 
-                                        if !is_focused {
+                                        if !is_focused && !is_selected {
                                             row = row.hover(move |s| s.bg(hovered_row_bg));
                                         }
 
@@ -367,7 +382,7 @@
             .rounded(px(12.0))
             .overflow_hidden()
             .border_1()
-            .border_color(border_color.opacity(0.25))
+            .border_color(rgba((border_color_hex << 8) | 0x40))
             .text_color(text_color)
             .key_context("select_prompt")
             .track_focus(&self.focus_handle)
@@ -376,3 +391,42 @@
             .child(choices_container)
     }
 }
+
+#[cfg(test)]
+mod tests {
+    use super::{resolve_row_bg_hex, SelectRowState};
+
+    #[test]
+    fn test_resolve_row_bg_hex_uses_focused_accent_for_selected_row() {
+        let focused_bg_hex = 0x55AAFF3A;
+        let hovered_bg_hex = 0x55AAFF26;
+
+        let selected_row = SelectRowState {
+            is_focused: false,
+            is_selected: true,
+            is_hovered: false,
+        };
+
+        assert_eq!(
+            resolve_row_bg_hex(selected_row, focused_bg_hex, hovered_bg_hex),
+            focused_bg_hex
+        );
+    }
+
+    #[test]
+    fn test_resolve_row_bg_hex_uses_hover_color_for_unselected_hovered_row() {
+        let focused_bg_hex = 0x55AAFF3A;
+        let hovered_bg_hex = 0x55AAFF26;
+
+        let hovered_row = SelectRowState {
+            is_focused: false,
+            is_selected: false,
+            is_hovered: true,
+        };
+
+        assert_eq!(
+            resolve_row_bg_hex(hovered_row, focused_bg_hex, hovered_bg_hex),
+            hovered_bg_hex
+        );
+    }
+}


thinking
**Extending polling timeout**
file update:
diff --git a/src/prompts/select/render.rs b/src/prompts/select/render.rs
index d0e0a5485f10066de9a287b70a4c3ae891e5cd99..c26ba855b7e69a16a4d3e1b048889d3588ac5525
--- a/src/prompts/select/render.rs
+++ b/src/prompts/select/render.rs
@@ -24,6 +24,20 @@
     }
 }
 
+pub(super) fn resolve_row_bg_hex(
+    row_state: SelectRowState,
+    focused_bg_hex: u32,
+    hovered_bg_hex: u32,
+) -> u32 {
+    if row_state.is_focused || row_state.is_selected {
+        focused_bg_hex
+    } else if row_state.is_hovered {
+        hovered_bg_hex
+    } else {
+        0x00000000
+    }
+}
+
 pub(super) fn extract_choice_icon_hint(description: Option<&str>) -> Option<&str> {
     description.and_then(|raw| {
         raw.split(['•', '|', '\n'])
@@ -128,13 +142,14 @@
         // VIBRANCY: Optional background override when a vibrancy surface is available.
         let vibrancy_bg = get_vibrancy_background(&self.theme);
 
-        let (_main_bg, text_color, muted_color, border_color) =
+        let (_main_bg, text_color, muted_color, border_color, border_color_hex) =
             if self.design_variant == DesignVariant::Default {
                 (
                     rgb(self.theme.colors.background.main),
                     rgb(self.theme.colors.text.secondary),
                     rgb(self.theme.colors.text.muted),
                     rgb(self.theme.colors.ui.border),
+                    self.theme.colors.ui.border,
                 )
             } else {
                 (
@@ -142,6 +157,7 @@
                     rgb(colors.text_secondary),
                     rgb(colors.text_muted),
                     rgb(colors.border),
+                    colors.border,
                 )
             };
         let search_box_bg = rgb(resolve_search_box_bg_hex(
@@ -154,8 +170,9 @@
         } else {
             colors.accent
         };
-        let focused_row_bg = rgba((row_accent_color << 8) | ROW_FOCUSED_BG_ALPHA);
-        let hovered_row_bg = rgba((row_accent_color << 8) | ROW_HOVER_BG_ALPHA);
+        let focused_row_bg_hex = (row_accent_color << 8) | ROW_FOCUSED_BG_ALPHA;
+        let hovered_row_bg_hex = (row_accent_color << 8) | ROW_HOVER_BG_ALPHA;
+        let hovered_row_bg = rgba(hovered_row_bg_hex);
 
         let placeholder = self
             .placeholder
@@ -278,13 +295,11 @@
                                                     ))
                                                 },
                                             );
-                                        let row_bg = if is_focused {
-                                            focused_row_bg
-                                        } else if is_hovered {
-                                            hovered_row_bg
-                                        } else {
-                                            rgba(0x00000000)
-                                        };
+                                        let row_bg = rgba(resolve_row_bg_hex(
+                                            row_state,
+                                            focused_row_bg_hex,
+                                            hovered_row_bg_hex,
+                                        ));
                                         let hover_handler = cx.listener(
                                             move |this: &mut SelectPrompt,
                                                   hovered: &bool,
@@ -327,7 +342,7 @@
                                                 .colors(item_colors),
                                             );
 
-                                        if !is_focused {
+                                        if !is_focused && !is_selected {
                                             row = row.hover(move |s| s.bg(hovered_row_bg));
                                         }
 
@@ -367,7 +382,7 @@
             .rounded(px(12.0))
             .overflow_hidden()
             .border_1()
-            .border_color(border_color.opacity(0.25))
+            .border_color(rgba((border_color_hex << 8) | 0x40))
             .text_color(text_color)
             .key_context("select_prompt")
             .track_focus(&self.focus_handle)
@@ -376,3 +391,42 @@
             .child(choices_container)
     }
 }
+
+#[cfg(test)]
+mod tests {
+    use super::{resolve_row_bg_hex, SelectRowState};
+
+    #[test]
+    fn test_resolve_row_bg_hex_uses_focused_accent_for_selected_row() {
+        let focused_bg_hex = 0x55AAFF3A;
+        let hovered_bg_hex = 0x55AAFF26;
+
+        let selected_row = SelectRowState {
+            is_focused: false,
+            is_selected: true,
+            is_hovered: false,
+        };
+
+        assert_eq!(
+            resolve_row_bg_hex(selected_row, focused_bg_hex, hovered_bg_hex),
+            focused_bg_hex
+        );
+    }
+
+    #[test]
+    fn test_resolve_row_bg_hex_uses_hover_color_for_unselected_hovered_row() {
+        let focused_bg_hex = 0x55AAFF3A;
+        let hovered_bg_hex = 0x55AAFF26;
+
+        let hovered_row = SelectRowState {
+            is_focused: false,
+            is_selected: false,
+            is_hovered: true,
+        };
+
+        assert_eq!(
+            resolve_row_bg_hex(hovered_row, focused_bg_hex, hovered_bg_hex),
+            hovered_bg_hex
+        );
+    }
+}


thinking
**Suspecting indefinite lock causing hang**
codex
Cargo is still blocked by shared build activity; once this check exits I’ll run the remaining verification chain in sequence and report exact outcomes.

thinking
**Avoiding build lock with unique target dir**
file update:
diff --git a/src/prompts/select/render.rs b/src/prompts/select/render.rs
index d0e0a5485f10066de9a287b70a4c3ae891e5cd99..c26ba855b7e69a16a4d3e1b048889d3588ac5525
--- a/src/prompts/select/render.rs
+++ b/src/prompts/select/render.rs
@@ -24,6 +24,20 @@
     }
 }
 
+pub(super) fn resolve_row_bg_hex(
+    row_state: SelectRowState,
+    focused_bg_hex: u32,
+    hovered_bg_hex: u32,
+) -> u32 {
+    if row_state.is_focused || row_state.is_selected {
+        focused_bg_hex
+    } else if row_state.is_hovered {
+        hovered_bg_hex
+    } else {
+        0x00000000
+    }
+}
+
 pub(super) fn extract_choice_icon_hint(description: Option<&str>) -> Option<&str> {
     description.and_then(|raw| {
         raw.split(['•', '|', '\n'])
@@ -128,13 +142,14 @@
         // VIBRANCY: Optional background override when a vibrancy surface is available.
         let vibrancy_bg = get_vibrancy_background(&self.theme);
 
-        let (_main_bg, text_color, muted_color, border_color) =
+        let (_main_bg, text_color, muted_color, border_color, border_color_hex) =
             if self.design_variant == DesignVariant::Default {
                 (
                     rgb(self.theme.colors.background.main),
                     rgb(self.theme.colors.text.secondary),
                     rgb(self.theme.colors.text.muted),
                     rgb(self.theme.colors.ui.border),
+                    self.theme.colors.ui.border,
                 )
             } else {
                 (
@@ -142,6 +157,7 @@
                     rgb(colors.text_secondary),
                     rgb(colors.text_muted),
                     rgb(colors.border),
+                    colors.border,
                 )
             };
         let search_box_bg = rgb(resolve_search_box_bg_hex(
@@ -154,8 +170,9 @@
         } else {
             colors.accent
         };
-        let focused_row_bg = rgba((row_accent_color << 8) | ROW_FOCUSED_BG_ALPHA);
-        let hovered_row_bg = rgba((row_accent_color << 8) | ROW_HOVER_BG_ALPHA);
+        let focused_row_bg_hex = (row_accent_color << 8) | ROW_FOCUSED_BG_ALPHA;
+        let hovered_row_bg_hex = (row_accent_color << 8) | ROW_HOVER_BG_ALPHA;
+        let hovered_row_bg = rgba(hovered_row_bg_hex);
 
         let placeholder = self
             .placeholder
@@ -278,13 +295,11 @@
                                                     ))
                                                 },
                                             );
-                                        let row_bg = if is_focused {
-                                            focused_row_bg
-                                        } else if is_hovered {
-                                            hovered_row_bg
-                                        } else {
-                                            rgba(0x00000000)
-                                        };
+                                        let row_bg = rgba(resolve_row_bg_hex(
+                                            row_state,
+                                            focused_row_bg_hex,
+                                            hovered_row_bg_hex,
+                                        ));
                                         let hover_handler = cx.listener(
                                             move |this: &mut SelectPrompt,
                                                   hovered: &bool,
@@ -327,7 +342,7 @@
                                                 .colors(item_colors),
                                             );
 
-                                        if !is_focused {
+                                        if !is_focused && !is_selected {
                                             row = row.hover(move |s| s.bg(hovered_row_bg));
                                         }
 
@@ -367,7 +382,7 @@
             .rounded(px(12.0))
             .overflow_hidden()
             .border_1()
-            .border_color(border_color.opacity(0.25))
+            .border_color(rgba((border_color_hex << 8) | 0x40))
             .text_color(text_color)
             .key_context("select_prompt")
             .track_focus(&self.focus_handle)
@@ -376,3 +391,42 @@
             .child(choices_container)
     }
 }
+
+#[cfg(test)]
+mod tests {
+    use super::{resolve_row_bg_hex, SelectRowState};
+
+    #[test]
+    fn test_resolve_row_bg_hex_uses_focused_accent_for_selected_row() {
+        let focused_bg_hex = 0x55AAFF3A;
+        let hovered_bg_hex = 0x55AAFF26;
+
+        let selected_row = SelectRowState {
+            is_focused: false,
+            is_selected: true,
+            is_hovered: false,
+        };
+
+        assert_eq!(
+            resolve_row_bg_hex(selected_row, focused_bg_hex, hovered_bg_hex),
+            focused_bg_hex
+        );
+    }
+
+    #[test]
+    fn test_resolve_row_bg_hex_uses_hover_color_for_unselected_hovered_row() {
+        let focused_bg_hex = 0x55AAFF3A;
+        let hovered_bg_hex = 0x55AAFF26;
+
+        let hovered_row = SelectRowState {
+            is_focused: false,
+            is_selected: false,
+            is_hovered: true,
+        };
+
+        assert_eq!(
+            resolve_row_bg_hex(hovered_row, focused_bg_hex, hovered_bg_hex),
+            hovered_bg_hex
+        );
+    }
+}


thinking
**Isolating build to avoid lock**
codex
To avoid shared target-lock contention, I’m switching verification to an isolated target dir for this agent (`CARGO_TARGET_DIR=target/codex-list-polish-split-1`) and continuing check/clippy/tests there.
exec
/bin/zsh -lc 'CARGO_TARGET_DIR=target/codex-list-polish-split-1 cargo check -p script-kit-gpui' in /Users/johnlindquist/dev/script-kit-gpuifile update:
diff --git a/src/prompts/select/render.rs b/src/prompts/select/render.rs
index d0e0a5485f10066de9a287b70a4c3ae891e5cd99..c26ba855b7e69a16a4d3e1b048889d3588ac5525
--- a/src/prompts/select/render.rs
+++ b/src/prompts/select/render.rs
@@ -24,6 +24,20 @@
     }
 }
 
+pub(super) fn resolve_row_bg_hex(
+    row_state: SelectRowState,
+    focused_bg_hex: u32,
+    hovered_bg_hex: u32,
+) -> u32 {
+    if row_state.is_focused || row_state.is_selected {
+        focused_bg_hex
+    } else if row_state.is_hovered {
+        hovered_bg_hex
+    } else {
+        0x00000000
+    }
+}
+
 pub(super) fn extract_choice_icon_hint(description: Option<&str>) -> Option<&str> {
     description.and_then(|raw| {
         raw.split(['•', '|', '\n'])
@@ -128,13 +142,14 @@
         // VIBRANCY: Optional background override when a vibrancy surface is available.
         let vibrancy_bg = get_vibrancy_background(&self.theme);
 
-        let (_main_bg, text_color, muted_color, border_color) =
+        let (_main_bg, text_color, muted_color, border_color, border_color_hex) =
             if self.design_variant == DesignVariant::Default {
                 (
                     rgb(self.theme.colors.background.main),
                     rgb(self.theme.colors.text.secondary),
                     rgb(self.theme.colors.text.muted),
                     rgb(self.theme.colors.ui.border),
+                    self.theme.colors.ui.border,
                 )
             } else {
                 (
@@ -142,6 +157,7 @@
                     rgb(colors.text_secondary),
                     rgb(colors.text_muted),
                     rgb(colors.border),
+                    colors.border,
                 )
             };
         let search_box_bg = rgb(resolve_search_box_bg_hex(
@@ -154,8 +170,9 @@
         } else {
             colors.accent
         };
-        let focused_row_bg = rgba((row_accent_color << 8) | ROW_FOCUSED_BG_ALPHA);
-        let hovered_row_bg = rgba((row_accent_color << 8) | ROW_HOVER_BG_ALPHA);
+        let focused_row_bg_hex = (row_accent_color << 8) | ROW_FOCUSED_BG_ALPHA;
+        let hovered_row_bg_hex = (row_accent_color << 8) | ROW_HOVER_BG_ALPHA;
+        let hovered_row_bg = rgba(hovered_row_bg_hex);
 
         let placeholder = self
             .placeholder
@@ -278,13 +295,11 @@
                                                     ))
                                                 },
                                             );
-                                        let row_bg = if is_focused {
-                                            focused_row_bg
-                                        } else if is_hovered {
-                                            hovered_row_bg
-                                        } else {
-                                            rgba(0x00000000)
-                                        };
+                                        let row_bg = rgba(resolve_row_bg_hex(
+                                            row_state,
+                                            focused_row_bg_hex,
+                                            hovered_row_bg_hex,
+                                        ));
                                         let hover_handler = cx.listener(
                                             move |this: &mut SelectPrompt,
                                                   hovered: &bool,
@@ -327,7 +342,7 @@
                                                 .colors(item_colors),
                                             );
 
-                                        if !is_focused {
+                                        if !is_focused && !is_selected {
                                             row = row.hover(move |s| s.bg(hovered_row_bg));
                                         }
 
@@ -367,7 +382,7 @@
             .rounded(px(12.0))
             .overflow_hidden()
             .border_1()
-            .border_color(border_color.opacity(0.25))
+            .border_color(rgba((border_color_hex << 8) | 0x40))
             .text_color(text_color)
             .key_context("select_prompt")
             .track_focus(&self.focus_handle)
@@ -376,3 +391,42 @@
             .child(choices_container)
     }
 }
+
+#[cfg(test)]
+mod tests {
+    use super::{resolve_row_bg_hex, SelectRowState};
+
+    #[test]
+    fn test_resolve_row_bg_hex_uses_focused_accent_for_selected_row() {
+        let focused_bg_hex = 0x55AAFF3A;
+        let hovered_bg_hex = 0x55AAFF26;
+
+        let selected_row = SelectRowState {
+            is_focused: false,
+            is_selected: true,
+            is_hovered: false,
+        };
+
+        assert_eq!(
+            resolve_row_bg_hex(selected_row, focused_bg_hex, hovered_bg_hex),
+            focused_bg_hex
+        );
+    }
+
+    #[test]
+    fn test_resolve_row_bg_hex_uses_hover_color_for_unselected_hovered_row() {
+        let focused_bg_hex = 0x55AAFF3A;
+        let hovered_bg_hex = 0x55AAFF26;
+
+        let hovered_row = SelectRowState {
+            is_focused: false,
+            is_selected: false,
+            is_hovered: true,
+        };
+
+        assert_eq!(
+            resolve_row_bg_hex(hovered_row, focused_bg_hex, hovered_bg_hex),
+            hovered_bg_hex
+        );
+    }
+}


thinking
**Waiting on compilation**
file update:
diff --git a/src/prompts/select/render.rs b/src/prompts/select/render.rs
index d0e0a5485f10066de9a287b70a4c3ae891e5cd99..c26ba855b7e69a16a4d3e1b048889d3588ac5525
--- a/src/prompts/select/render.rs
+++ b/src/prompts/select/render.rs
@@ -24,6 +24,20 @@
     }
 }
 
+pub(super) fn resolve_row_bg_hex(
+    row_state: SelectRowState,
+    focused_bg_hex: u32,
+    hovered_bg_hex: u32,
+) -> u32 {
+    if row_state.is_focused || row_state.is_selected {
+        focused_bg_hex
+    } else if row_state.is_hovered {
+        hovered_bg_hex
+    } else {
+        0x00000000
+    }
+}
+
 pub(super) fn extract_choice_icon_hint(description: Option<&str>) -> Option<&str> {
     description.and_then(|raw| {
         raw.split(['•', '|', '\n'])
@@ -128,13 +142,14 @@
         // VIBRANCY: Optional background override when a vibrancy surface is available.
         let vibrancy_bg = get_vibrancy_background(&self.theme);
 
-        let (_main_bg, text_color, muted_color, border_color) =
+        let (_main_bg, text_color, muted_color, border_color, border_color_hex) =
             if self.design_variant == DesignVariant::Default {
                 (
                     rgb(self.theme.colors.background.main),
                     rgb(self.theme.colors.text.secondary),
                     rgb(self.theme.colors.text.muted),
                     rgb(self.theme.colors.ui.border),
+                    self.theme.colors.ui.border,
                 )
             } else {
                 (
@@ -142,6 +157,7 @@
                     rgb(colors.text_secondary),
                     rgb(colors.text_muted),
                     rgb(colors.border),
+                    colors.border,
                 )
             };
         let search_box_bg = rgb(resolve_search_box_bg_hex(
@@ -154,8 +170,9 @@
         } else {
             colors.accent
         };
-        let focused_row_bg = rgba((row_accent_color << 8) | ROW_FOCUSED_BG_ALPHA);
-        let hovered_row_bg = rgba((row_accent_color << 8) | ROW_HOVER_BG_ALPHA);
+        let focused_row_bg_hex = (row_accent_color << 8) | ROW_FOCUSED_BG_ALPHA;
+        let hovered_row_bg_hex = (row_accent_color << 8) | ROW_HOVER_BG_ALPHA;
+        let hovered_row_bg = rgba(hovered_row_bg_hex);
 
         let placeholder = self
             .placeholder
@@ -278,13 +295,11 @@
                                                     ))
                                                 },
                                             );
-                                        let row_bg = if is_focused {
-                                            focused_row_bg
-                                        } else if is_hovered {
-                                            hovered_row_bg
-                                        } else {
-                                            rgba(0x00000000)
-                                        };
+                                        let row_bg = rgba(resolve_row_bg_hex(
+                                            row_state,
+                                            focused_row_bg_hex,
+                                            hovered_row_bg_hex,
+                                        ));
                                         let hover_handler = cx.listener(
                                             move |this: &mut SelectPrompt,
                                                   hovered: &bool,
@@ -327,7 +342,7 @@
                                                 .colors(item_colors),
                                             );
 
-                                        if !is_focused {
+                                        if !is_focused && !is_selected {
                                             row = row.hover(move |s| s.bg(hovered_row_bg));
                                         }
 
@@ -367,7 +382,7 @@
             .rounded(px(12.0))
             .overflow_hidden()
             .border_1()
-            .border_color(border_color.opacity(0.25))
+            .border_color(rgba((border_color_hex << 8) | 0x40))
             .text_color(text_color)
             .key_context("select_prompt")
             .track_focus(&self.focus_handle)
@@ -376,3 +391,42 @@
             .child(choices_container)
     }
 }
+
+#[cfg(test)]
+mod tests {
+    use super::{resolve_row_bg_hex, SelectRowState};
+
+    #[test]
+    fn test_resolve_row_bg_hex_uses_focused_accent_for_selected_row() {
+        let focused_bg_hex = 0x55AAFF3A;
+        let hovered_bg_hex = 0x55AAFF26;
+
+        let selected_row = SelectRowState {
+            is_focused: false,
+            is_selected: true,
+            is_hovered: false,
+        };
+
+        assert_eq!(
+            resolve_row_bg_hex(selected_row, focused_bg_hex, hovered_bg_hex),
+            focused_bg_hex
+        );
+    }
+
+    #[test]
+    fn test_resolve_row_bg_hex_uses_hover_color_for_unselected_hovered_row() {
+        let focused_bg_hex = 0x55AAFF3A;
+        let hovered_bg_hex = 0x55AAFF26;
+
+        let hovered_row = SelectRowState {
+            is_focused: false,
+            is_selected: false,
+            is_hovered: true,
+        };
+
+        assert_eq!(
+            resolve_row_bg_hex(hovered_row, focused_bg_hex, hovered_bg_hex),
+            hovered_bg_hex
+        );
+    }
+}


thinking
**Assessing silent compilation output**
file update:
diff --git a/src/prompts/select/render.rs b/src/prompts/select/render.rs
index d0e0a5485f10066de9a287b70a4c3ae891e5cd99..c26ba855b7e69a16a4d3e1b048889d3588ac5525
--- a/src/prompts/select/render.rs
+++ b/src/prompts/select/render.rs
@@ -24,6 +24,20 @@
     }
 }
 
+pub(super) fn resolve_row_bg_hex(
+    row_state: SelectRowState,
+    focused_bg_hex: u32,
+    hovered_bg_hex: u32,
+) -> u32 {
+    if row_state.is_focused || row_state.is_selected {
+        focused_bg_hex
+    } else if row_state.is_hovered {
+        hovered_bg_hex
+    } else {
+        0x00000000
+    }
+}
+
 pub(super) fn extract_choice_icon_hint(description: Option<&str>) -> Option<&str> {
     description.and_then(|raw| {
         raw.split(['•', '|', '\n'])
@@ -128,13 +142,14 @@
         // VIBRANCY: Optional background override when a vibrancy surface is available.
         let vibrancy_bg = get_vibrancy_background(&self.theme);
 
-        let (_main_bg, text_color, muted_color, border_color) =
+        let (_main_bg, text_color, muted_color, border_color, border_color_hex) =
             if self.design_variant == DesignVariant::Default {
                 (
                     rgb(self.theme.colors.background.main),
                     rgb(self.theme.colors.text.secondary),
                     rgb(self.theme.colors.text.muted),
                     rgb(self.theme.colors.ui.border),
+                    self.theme.colors.ui.border,
                 )
             } else {
                 (
@@ -142,6 +157,7 @@
                     rgb(colors.text_secondary),
                     rgb(colors.text_muted),
                     rgb(colors.border),
+                    colors.border,
                 )
             };
         let search_box_bg = rgb(resolve_search_box_bg_hex(
@@ -154,8 +170,9 @@
         } else {
             colors.accent
         };
-        let focused_row_bg = rgba((row_accent_color << 8) | ROW_FOCUSED_BG_ALPHA);
-        let hovered_row_bg = rgba((row_accent_color << 8) | ROW_HOVER_BG_ALPHA);
+        let focused_row_bg_hex = (row_accent_color << 8) | ROW_FOCUSED_BG_ALPHA;
+        let hovered_row_bg_hex = (row_accent_color << 8) | ROW_HOVER_BG_ALPHA;
+        let hovered_row_bg = rgba(hovered_row_bg_hex);
 
         let placeholder = self
             .placeholder
@@ -278,13 +295,11 @@
                                                     ))
                                                 },
                                             );
-                                        let row_bg = if is_focused {
-                                            focused_row_bg
-                                        } else if is_hovered {
-                                            hovered_row_bg
-                                        } else {
-                                            rgba(0x00000000)
-                                        };
+                                        let row_bg = rgba(resolve_row_bg_hex(
+                                            row_state,
+                                            focused_row_bg_hex,
+                                            hovered_row_bg_hex,
+                                        ));
                                         let hover_handler = cx.listener(
                                             move |this: &mut SelectPrompt,
                                                   hovered: &bool,
@@ -327,7 +342,7 @@
                                                 .colors(item_colors),
                                             );
 
-                                        if !is_focused {
+                                        if !is_focused && !is_selected {
                                             row = row.hover(move |s| s.bg(hovered_row_bg));
                                         }
 
@@ -367,7 +382,7 @@
             .rounded(px(12.0))
             .overflow_hidden()
             .border_1()
-            .border_color(border_color.opacity(0.25))
+            .border_color(rgba((border_color_hex << 8) | 0x40))
             .text_color(text_color)
             .key_context("select_prompt")
             .track_focus(&self.focus_handle)
@@ -376,3 +391,42 @@
             .child(choices_container)
     }
 }
+
+#[cfg(test)]
+mod tests {
+    use super::{resolve_row_bg_hex, SelectRowState};
+
+    #[test]
+    fn test_resolve_row_bg_hex_uses_focused_accent_for_selected_row() {
+        let focused_bg_hex = 0x55AAFF3A;
+        let hovered_bg_hex = 0x55AAFF26;
+
+        let selected_row = SelectRowState {
+            is_focused: false,
+            is_selected: true,
+            is_hovered: false,
+        };
+
+        assert_eq!(
+            resolve_row_bg_hex(selected_row, focused_bg_hex, hovered_bg_hex),
+            focused_bg_hex
+        );
+    }
+
+    #[test]
+    fn test_resolve_row_bg_hex_uses_hover_color_for_unselected_hovered_row() {
+        let focused_bg_hex = 0x55AAFF3A;
+        let hovered_bg_hex = 0x55AAFF26;
+
+        let hovered_row = SelectRowState {
+            is_focused: false,
+            is_selected: false,
+            is_hovered: true,
+        };
+
+        assert_eq!(
+            resolve_row_bg_hex(hovered_row, focused_bg_hex, hovered_bg_hex),
+            hovered_bg_hex
+        );
+    }
+}


thinking
**Waiting for compile completion**
file update:
diff --git a/src/prompts/select/render.rs b/src/prompts/select/render.rs
index d0e0a5485f10066de9a287b70a4c3ae891e5cd99..c26ba855b7e69a16a4d3e1b048889d3588ac5525
--- a/src/prompts/select/render.rs
+++ b/src/prompts/select/render.rs
@@ -24,6 +24,20 @@
     }
 }
 
+pub(super) fn resolve_row_bg_hex(
+    row_state: SelectRowState,
+    focused_bg_hex: u32,
+    hovered_bg_hex: u32,
+) -> u32 {
+    if row_state.is_focused || row_state.is_selected {
+        focused_bg_hex
+    } else if row_state.is_hovered {
+        hovered_bg_hex
+    } else {
+        0x00000000
+    }
+}
+
 pub(super) fn extract_choice_icon_hint(description: Option<&str>) -> Option<&str> {
     description.and_then(|raw| {
         raw.split(['•', '|', '\n'])
@@ -128,13 +142,14 @@
         // VIBRANCY: Optional background override when a vibrancy surface is available.
         let vibrancy_bg = get_vibrancy_background(&self.theme);
 
-        let (_main_bg, text_color, muted_color, border_color) =
+        let (_main_bg, text_color, muted_color, border_color, border_color_hex) =
             if self.design_variant == DesignVariant::Default {
                 (
                     rgb(self.theme.colors.background.main),
                     rgb(self.theme.colors.text.secondary),
                     rgb(self.theme.colors.text.muted),
                     rgb(self.theme.colors.ui.border),
+                    self.theme.colors.ui.border,
                 )
             } else {
                 (
@@ -142,6 +157,7 @@
                     rgb(colors.text_secondary),
                     rgb(colors.text_muted),
                     rgb(colors.border),
+                    colors.border,
                 )
             };
         let search_box_bg = rgb(resolve_search_box_bg_hex(
@@ -154,8 +170,9 @@
         } else {
             colors.accent
         };
-        let focused_row_bg = rgba((row_accent_color << 8) | ROW_FOCUSED_BG_ALPHA);
-        let hovered_row_bg = rgba((row_accent_color << 8) | ROW_HOVER_BG_ALPHA);
+        let focused_row_bg_hex = (row_accent_color << 8) | ROW_FOCUSED_BG_ALPHA;
+        let hovered_row_bg_hex = (row_accent_color << 8) | ROW_HOVER_BG_ALPHA;
+        let hovered_row_bg = rgba(hovered_row_bg_hex);
 
         let placeholder = self
             .placeholder
@@ -278,13 +295,11 @@
                                                     ))
                                                 },
                                             );
-                                        let row_bg = if is_focused {
-                                            focused_row_bg
-                                        } else if is_hovered {
-                                            hovered_row_bg
-                                        } else {
-                                            rgba(0x00000000)
-                                        };
+                                        let row_bg = rgba(resolve_row_bg_hex(
+                                            row_state,
+                                            focused_row_bg_hex,
+                                            hovered_row_bg_hex,
+                                        ));
                                         let hover_handler = cx.listener(
                                             move |this: &mut SelectPrompt,
                                                   hovered: &bool,
@@ -327,7 +342,7 @@
                                                 .colors(item_colors),
                                             );
 
-                                        if !is_focused {
+                                        if !is_focused && !is_selected {
                                             row = row.hover(move |s| s.bg(hovered_row_bg));
                                         }
 
@@ -367,7 +382,7 @@
             .rounded(px(12.0))
             .overflow_hidden()
             .border_1()
-            .border_color(border_color.opacity(0.25))
+            .border_color(rgba((border_color_hex << 8) | 0x40))
             .text_color(text_color)
             .key_context("select_prompt")
             .track_focus(&self.focus_handle)
@@ -376,3 +391,42 @@
             .child(choices_container)
     }
 }
+
+#[cfg(test)]
+mod tests {
+    use super::{resolve_row_bg_hex, SelectRowState};
+
+    #[test]
+    fn test_resolve_row_bg_hex_uses_focused_accent_for_selected_row() {
+        let focused_bg_hex = 0x55AAFF3A;
+        let hovered_bg_hex = 0x55AAFF26;
+
+        let selected_row = SelectRowState {
+            is_focused: false,
+            is_selected: true,
+            is_hovered: false,
+        };
+
+        assert_eq!(
+            resolve_row_bg_hex(selected_row, focused_bg_hex, hovered_bg_hex),
+            focused_bg_hex
+        );
+    }
+
+    #[test]
+    fn test_resolve_row_bg_hex_uses_hover_color_for_unselected_hovered_row() {
+        let focused_bg_hex = 0x55AAFF3A;
+        let hovered_bg_hex = 0x55AAFF26;
+
+        let hovered_row = SelectRowState {
+            is_focused: false,
+            is_selected: false,
+            is_hovered: true,
+        };
+
+        assert_eq!(
+            resolve_row_bg_hex(hovered_row, focused_bg_hex, hovered_bg_hex),
+            hovered_bg_hex
+        );
+    }
+}

 exited 101 in 1m 52s:
    Blocking waiting for file lock on build directory
    Checking script-kit-gpui v0.1.0 (/Users/johnlindquist/dev/script-kit-gpui)
error[E0425]: cannot find value `theme` in this scope
   --> src/components/prompt_footer.rs:163:6
    |
163 |     (theme.get_fonts().ui_size - PROMPT_FOOTER_BUTTON_FONT_DELTA_PX)
    |      ^^^^^ not found in this scope

error[E0425]: cannot find function `footer_button_font_size_px` in module `crate::components::prompt_footer`
  --> src/prompts/chat/render_core.rs:39:47
   |
39 |             crate::components::prompt_footer::footer_button_font_size_px(&self.theme);
   |                                               ^^^^^^^^^^^^^^^^^^^^^^^^^^ not found in `crate::components::prompt_footer`

error[E0603]: function `footer_button_hover_rgba` is private
   --> src/prompts/chat/render_core.rs:40:63
    |
 40 |         let hover_bg = rgba(crate::components::prompt_footer::footer_button_hover_rgba(
    |                                                               ^^^^^^^^^^^^^^^^^^^^^^^^ private function
    |
file update:
diff --git a/src/prompts/select/render.rs b/src/prompts/select/render.rs
index d0e0a5485f10066de9a287b70a4c3ae891e5cd99..c26ba855b7e69a16a4d3e1b048889d3588ac5525
--- a/src/prompts/select/render.rs
+++ b/src/prompts/select/render.rs
@@ -24,6 +24,20 @@
     }
 }
 
+pub(super) fn resolve_row_bg_hex(
+    row_state: SelectRowState,
+    focused_bg_hex: u32,
+    hovered_bg_hex: u32,
+) -> u32 {
+    if row_state.is_focused || row_state.is_selected {
+        focused_bg_hex
+    } else if row_state.is_hovered {
+        hovered_bg_hex
+    } else {
+        0x00000000
+    }
+}
+
 pub(super) fn extract_choice_icon_hint(description: Option<&str>) -> Option<&str> {
     description.and_then(|raw| {
         raw.split(['•', '|', '\n'])
@@ -128,13 +142,14 @@
         // VIBRANCY: Optional background override when a vibrancy surface is available.
         let vibrancy_bg = get_vibrancy_background(&self.theme);
 
-        let (_main_bg, text_color, muted_color, border_color) =
+        let (_main_bg, text_color, muted_color, border_color, border_color_hex) =
             if self.design_variant == DesignVariant::Default {
                 (
                     rgb(self.theme.colors.background.main),
                     rgb(self.theme.colors.text.secondary),
                     rgb(self.theme.colors.text.muted),
                     rgb(self.theme.colors.ui.border),
+                    self.theme.colors.ui.border,
                 )
             } else {
                 (
@@ -142,6 +157,7 @@
                     rgb(colors.text_secondary),
                     rgb(colors.text_muted),
                     rgb(colors.border),
+                    colors.border,
                 )
             };
         let search_box_bg = rgb(resolve_search_box_bg_hex(
@@ -154,8 +170,9 @@
         } else {
             colors.accent
         };
-        let focused_row_bg = rgba((row_accent_color << 8) | ROW_FOCUSED_BG_ALPHA);
-        let hovered_row_bg = rgba((row_accent_color << 8) | ROW_HOVER_BG_ALPHA);
+        let focused_row_bg_hex = (row_accent_color << 8) | ROW_FOCUSED_BG_ALPHA;
+        let hovered_row_bg_hex = (row_accent_color << 8) | ROW_HOVER_BG_ALPHA;
+        let hovered_row_bg = rgba(hovered_row_bg_hex);
 
         let placeholder = self
             .placeholder
@@ -278,13 +295,11 @@
                                                     ))
                                                 },
                                             );
-                                        let row_bg = if is_focused {
-                                            focused_row_bg
-                                        } else if is_hovered {
-                                            hovered_row_bg
-                                        } else {
-                                            rgba(0x00000000)
-                                        };
+                                        let row_bg = rgba(resolve_row_bg_hex(
+                                            row_state,
+                                            focused_row_bg_hex,
+                                            hovered_row_bg_hex,
+                                        ));
                                         let hover_handler = cx.listener(
                                             move |this: &mut SelectPrompt,
                                                   hovered: &bool,
@@ -327,7 +342,7 @@
                                                 .colors(item_colors),
                                             );
 
-                                        if !is_focused {
+                                        if !is_focused && !is_selected {
                                             row = row.hover(move |s| s.bg(hovered_row_bg));
                                         }
 
@@ -367,7 +382,7 @@
             .rounded(px(12.0))
             .overflow_hidden()
             .border_1()
-            .border_color(border_color.opacity(0.25))
+            .border_color(rgba((border_color_hex << 8) | 0x40))
             .text_color(text_color)
             .key_context("select_prompt")
             .track_focus(&self.focus_handle)
@@ -376,3 +391,42 @@
             .child(choices_container)
     }
 }
+
+#[cfg(test)]
+mod tests {
+    use super::{resolve_row_bg_hex, SelectRowState};
+
+    #[test]
+    fn test_resolve_row_bg_hex_uses_focused_accent_for_selected_row() {
+        let focused_bg_hex = 0x55AAFF3A;
+        let hovered_bg_hex = 0x55AAFF26;
+
+        let selected_row = SelectRowState {
+            is_focused: false,
+            is_selected: true,
+            is_hovered: false,
+        };
+
+        assert_eq!(
+            resolve_row_bg_hex(selected_row, focused_bg_hex, hovered_bg_hex),
+            focused_bg_hex
+        );
+    }
+
+    #[test]
+    fn test_resolve_row_bg_hex_uses_hover_color_for_unselected_hovered_row() {
+        let focused_bg_hex = 0x55AAFF3A;
+        let hovered_bg_hex = 0x55AAFF26;
+
+        let hovered_row = SelectRowState {
+            is_focused: false,
+            is_selected: false,
+            is_hovered: true,
+        };
+
+        assert_eq!(
+            resolve_row_bg_hex(hovered_row, focused_bg_hex, hovered_bg_hex),
+            hovered_bg_hex
+        );
+    }
+}

file update:
diff --git a/src/prompts/select/render.rs b/src/prompts/select/render.rs
index d0e0a5485f10066de9a287b70a4c3ae891e5cd99..c26ba855b7e69a16a4d3e1b048889d3588ac5525
--- a/src/prompts/select/render.rs
+++ b/src/prompts/select/render.rs
@@ -24,6 +24,20 @@
     }
 }
 
+pub(super) fn resolve_row_bg_hex(
+    row_state: SelectRowState,
+    focused_bg_hex: u32,
+    hovered_bg_hex: u32,
+) -> u32 {
+    if row_state.is_focused || row_state.is_selected {
+        focused_bg_hex
+    } else if row_state.is_hovered {
+        hovered_bg_hex
+    } else {
+        0x00000000
+    }
+}
+
 pub(super) fn extract_choice_icon_hint(description: Option<&str>) -> Option<&str> {
     description.and_then(|raw| {
         raw.split(['•', '|', '\n'])
@@ -128,13 +142,14 @@
         // VIBRANCY: Optional background override when a vibrancy surface is available.
         let vibrancy_bg = get_vibrancy_background(&self.theme);
 
-        let (_main_bg, text_color, muted_color, border_color) =
+        let (_main_bg, text_color, muted_color, border_color, border_color_hex) =
             if self.design_variant == DesignVariant::Default {
                 (
                     rgb(self.theme.colors.background.main),
                     rgb(self.theme.colors.text.secondary),
                     rgb(self.theme.colors.text.muted),
                     rgb(self.theme.colors.ui.border),
+                    self.theme.colors.ui.border,
                 )
             } else {
                 (
@@ -142,6 +157,7 @@
                     rgb(colors.text_secondary),
                     rgb(colors.text_muted),
                     rgb(colors.border),
+                    colors.border,
                 )
             };
         let search_box_bg = rgb(resolve_search_box_bg_hex(
@@ -154,8 +170,9 @@
         } else {
             colors.accent
         };
-        let focused_row_bg = rgba((row_accent_color << 8) | ROW_FOCUSED_BG_ALPHA);
-        let hovered_row_bg = rgba((row_accent_color << 8) | ROW_HOVER_BG_ALPHA);
+        let focused_row_bg_hex = (row_accent_color << 8) | ROW_FOCUSED_BG_ALPHA;
+        let hovered_row_bg_hex = (row_accent_color << 8) | ROW_HOVER_BG_ALPHA;
+        let hovered_row_bg = rgba(hovered_row_bg_hex);
 
         let placeholder = self
             .placeholder
@@ -278,13 +295,11 @@
                                                     ))
                                                 },
                                             );
-                                        let row_bg = if is_focused {
-                                            focused_row_bg
-                                        } else if is_hovered {
-                                            hovered_row_bg
-                                        } else {
-                                            rgba(0x00000000)
-                                        };
+                                        let row_bg = rgba(resolve_row_bg_hex(
+                                            row_state,
+                                            focused_row_bg_hex,
+                                            hovered_row_bg_hex,
+                                        ));
                                         let hover_handler = cx.listener(
                                             move |this: &mut SelectPrompt,
                                                   hovered: &bool,
@@ -327,7 +342,7 @@
                                                 .colors(item_colors),
                                             );
 
-                                        if !is_focused {
+                                        if !is_focused && !is_selected {
                                             row = row.hover(move |s| s.bg(hovered_row_bg));
                                         }
 
@@ -367,7 +382,7 @@
             .rounded(px(12.0))
             .overflow_hidden()
             .border_1()
-            .border_color(border_color.opacity(0.25))
+            .border_color(rgba((border_color_hex << 8) | 0x40))
             .text_color(text_color)
             .key_context("select_prompt")
             .track_focus(&self.focus_handle)
@@ -376,3 +391,42 @@
             .child(choices_container)
     }
 }
+
+#[cfg(test)]
+mod tests {
+    use super::{resolve_row_bg_hex, SelectRowState};
+
+    #[test]
+    fn test_resolve_row_bg_hex_uses_focused_accent_for_selected_row() {
+        let focused_bg_hex = 0x55AAFF3A;
+        let hovered_bg_hex = 0x55AAFF26;
+
+        let selected_row = SelectRowState {
+            is_focused: false,
+            is_selected: true,
+            is_hovered: false,
+        };
+
+        assert_eq!(
+            resolve_row_bg_hex(selected_row, focused_bg_hex, hovered_bg_hex),
+            focused_bg_hex
+        );
+    }
+
+    #[test]
+    fn test_resolve_row_bg_hex_uses_hover_color_for_unselected_hovered_row() {
+        let focused_bg_hex = 0x55AAFF3A;
+        let hovered_bg_hex = 0x55AAFF26;
+
+        let hovered_row = SelectRowState {
+            is_focused: false,
+            is_selected: false,
+            is_hovered: true,
+        };
+
+        assert_eq!(
+            resolve_row_bg_hex(hovered_row, focused_bg_hex, hovered_bg_hex),
+            hovered_bg_hex
+        );
+    }
+}

 exited 101 in 50.69s:
   Compiling proc-macro2 v1.0.103
   Compiling unicode-ident v1.0.22
   Compiling quote v1.0.42
   Compiling libc v0.2.178
   Compiling serde_core v1.0.228
    Checking cfg-if v1.0.4
   Compiling typeid v1.0.3
   Compiling erased-serde v0.4.9
    Checking memchr v2.7.6
   Compiling autocfg v1.5.0
   Compiling libm v0.2.15
   Compiling crossbeam-utils v0.8.21
   Compiling version_check v0.9.5
   Compiling shlex v1.3.0
   Compiling serde v1.0.228
    Checking smallvec v1.15.1
   Compiling typenum v1.19.0
   Compiling generic-array v0.14.7
   Compiling objc2 v0.6.3
    Checking stable_deref_trait v1.2.1

thinking
**Assessing scoped compile challenges**
exec
/bin/zsh -lc "sed -n '1,260p' src/lib.rs" in /Users/johnlindquist/dev/script-kit-gpuiexec
/bin/zsh -lc "rg -n \"mod chat|prompts::chat|prompt_footer|cfg\\(feature\" src/lib.rs src/prompts/mod.rs src/prompts/chat -g '*.rs'" in /Users/johnlindquist/dev/script-kit-gpui succeeded in 51ms:
#![allow(unexpected_cfgs)]
#![recursion_limit = "2048"]

//! Script Kit GPUI - A GPUI-based launcher for Script Kit
//!
//! This library provides the core functionality for executing scripts
//! with bidirectional JSONL communication.

// Actions - Reusable action dialog component
// Provides ActionsDialog with configurable layout for script actions, AI command bar, etc.
pub mod actions;

// App Shell - Unified frame and chrome for all prompts
// Provides ShellSpec, HeaderSpec, FooterSpec, ChromeSpec for consistent prompt layout
pub mod app_shell;

#[cfg(target_os = "macos")]
pub mod camera;
pub mod components;
pub mod config;
 succeeded in 51ms:
src/prompts/mod.rs:19:pub mod chat;
src/lib.rs:176:#[cfg(feature = "ocr")]
src/prompts/chat/tests.rs:472:pub(crate) mod chat_tests {
src/prompts/chat/render_core.rs:39:            crate::components::prompt_footer::footer_button_font_size_px(&self.theme);
src/prompts/chat/render_core.rs:40:        let hover_bg = rgba(crate::components::prompt_footer::footer_button_hover_rgba(
src/prompts/chat/render_core.rs:43:        let active_bg = rgba(crate::components::prompt_footer::footer_button_active_rgba(
src/prompts/chat/render_core.rs:81:        let footer_bg = rgba(crate::components::prompt_footer::footer_surface_rgba(
src/prompts/chat/mod.rs:10:use crate::components::prompt_footer::PromptFooterColors;
file update:
diff --git a/src/prompts/select/render.rs b/src/prompts/select/render.rs
index d0e0a5485f10066de9a287b70a4c3ae891e5cd99..c26ba855b7e69a16a4d3e1b048889d3588ac5525
--- a/src/prompts/select/render.rs
+++ b/src/prompts/select/render.rs
@@ -24,6 +24,20 @@
     }
 }
 
+pub(super) fn resolve_row_bg_hex(
+    row_state: SelectRowState,
+    focused_bg_hex: u32,
+    hovered_bg_hex: u32,
+) -> u32 {
+    if row_state.is_focused || row_state.is_selected {
+        focused_bg_hex
+    } else if row_state.is_hovered {
+        hovered_bg_hex
+    } else {
+        0x00000000
+    }
+}
+
 pub(super) fn extract_choice_icon_hint(description: Option<&str>) -> Option<&str> {
     description.and_then(|raw| {
         raw.split(['•', '|', '\n'])
@@ -128,13 +142,14 @@
         // VIBRANCY: Optional background override when a vibrancy surface is available.
         let vibrancy_bg = get_vibrancy_background(&self.theme);
 
-        let (_main_bg, text_color, muted_color, border_color) =
+        let (_main_bg, text_color, muted_color, border_color, border_color_hex) =
             if self.design_variant == DesignVariant::Default {
                 (
                     rgb(self.theme.colors.background.main),
                     rgb(self.theme.colors.text.secondary),
                     rgb(self.theme.colors.text.muted),
                     rgb(self.theme.colors.ui.border),
+                    self.theme.colors.ui.border,
                 )
             } else {
                 (
@@ -142,6 +157,7 @@
                     rgb(colors.text_secondary),
                     rgb(colors.text_muted),
                     rgb(colors.border),
+                    colors.border,
                 )
             };
         let search_box_bg = rgb(resolve_search_box_bg_hex(
@@ -154,8 +170,9 @@
         } else {
             colors.accent
         };
-        let focused_row_bg = rgba((row_accent_color << 8) | ROW_FOCUSED_BG_ALPHA);
-        let hovered_row_bg = rgba((row_accent_color << 8) | ROW_HOVER_BG_ALPHA);
+        let focused_row_bg_hex = (row_accent_color << 8) | ROW_FOCUSED_BG_ALPHA;
+        let hovered_row_bg_hex = (row_accent_color << 8) | ROW_HOVER_BG_ALPHA;
+        let hovered_row_bg = rgba(hovered_row_bg_hex);
 
         let placeholder = self
             .placeholder
@@ -278,13 +295,11 @@
                                                     ))
                                                 },
                                             );
-                                        let row_bg = if is_focused {
-                                            focused_row_bg
-                                        } else if is_hovered {
-                                            hovered_row_bg
-                                        } else {
-                                            rgba(0x00000000)
-                                        };
+                                        let row_bg = rgba(resolve_row_bg_hex(
+                                            row_state,
+                                            focused_row_bg_hex,
+                                            hovered_row_bg_hex,
+                                        ));
                                         let hover_handler = cx.listener(
                                             move |this: &mut SelectPrompt,
                                                   hovered: &bool,
@@ -327,7 +342,7 @@
                                                 .colors(item_colors),
                                             );
 
-                                        if !is_focused {
+                                        if !is_focused && !is_selected {
                                             row = row.hover(move |s| s.bg(hovered_row_bg));
                                         }
 
@@ -367,7 +382,7 @@
             .rounded(px(12.0))
             .overflow_hidden()
             .border_1()
-            .border_color(border_color.opacity(0.25))
+            .border_color(rgba((border_color_hex << 8) | 0x40))
             .text_color(text_color)
             .key_context("select_prompt")
             .track_focus(&self.focus_handle)
@@ -376,3 +391,42 @@
             .child(choices_container)
     }
 }
+
+#[cfg(test)]
+mod tests {
+    use super::{resolve_row_bg_hex, SelectRowState};
+
+    #[test]
+    fn test_resolve_row_bg_hex_uses_focused_accent_for_selected_row() {
+        let focused_bg_hex = 0x55AAFF3A;
+        let hovered_bg_hex = 0x55AAFF26;
+
+        let selected_row = SelectRowState {
+            is_focused: false,
+            is_selected: true,
+            is_hovered: false,
+        };
+
+        assert_eq!(
+            resolve_row_bg_hex(selected_row, focused_bg_hex, hovered_bg_hex),
+            focused_bg_hex
+        );
+    }
+
+    #[test]
+    fn test_resolve_row_bg_hex_uses_hover_color_for_unselected_hovered_row() {
+        let focused_bg_hex = 0x55AAFF3A;
+        let hovered_bg_hex = 0x55AAFF26;
+
+        let hovered_row = SelectRowState {
+            is_focused: false,
+            is_selected: false,
+            is_hovered: true,
+        };
+
+        assert_eq!(
+            resolve_row_bg_hex(hovered_row, focused_bg_hex, hovered_bg_hex),
+            hovered_bg_hex
+        );
+    }
+}


thinking
**Assessing test run and session cleanup**
exec
/bin/zsh -lc 'ps -Ao pid,command | rg "cargo check -p script-kit-gpui"' in /Users/johnlindquist/dev/script-kit-gpui succeeded in 51ms:
39954 /Users/johnlindquist/.rustup/toolchains/stable-aarch64-apple-darwin/bin/cargo check -p script-kit-gpui
40139 /bin/zsh -lc ps -Ao pid,command | rg "cargo check -p script-kit-gpui"
40144 rg cargo check -p script-kit-gpui
file update:
diff --git a/src/prompts/select/render.rs b/src/prompts/select/render.rs
index d0e0a5485f10066de9a287b70a4c3ae891e5cd99..c26ba855b7e69a16a4d3e1b048889d3588ac5525
--- a/src/prompts/select/render.rs
+++ b/src/prompts/select/render.rs
@@ -24,6 +24,20 @@
     }
 }
 
+pub(super) fn resolve_row_bg_hex(
+    row_state: SelectRowState,
+    focused_bg_hex: u32,
+    hovered_bg_hex: u32,
+) -> u32 {
+    if row_state.is_focused || row_state.is_selected {
+        focused_bg_hex
+    } else if row_state.is_hovered {
+        hovered_bg_hex
+    } else {
+        0x00000000
+    }
+}
+
 pub(super) fn extract_choice_icon_hint(description: Option<&str>) -> Option<&str> {
     description.and_then(|raw| {
         raw.split(['•', '|', '\n'])
@@ -128,13 +142,14 @@
         // VIBRANCY: Optional background override when a vibrancy surface is available.
         let vibrancy_bg = get_vibrancy_background(&self.theme);
 
-        let (_main_bg, text_color, muted_color, border_color) =
+        let (_main_bg, text_color, muted_color, border_color, border_color_hex) =
             if self.design_variant == DesignVariant::Default {
                 (
                     rgb(self.theme.colors.background.main),
                     rgb(self.theme.colors.text.secondary),
                     rgb(self.theme.colors.text.muted),
                     rgb(self.theme.colors.ui.border),
+                    self.theme.colors.ui.border,
                 )
             } else {
                 (
@@ -142,6 +157,7 @@
                     rgb(colors.text_secondary),
                     rgb(colors.text_muted),
                     rgb(colors.border),
+                    colors.border,
                 )
             };
         let search_box_bg = rgb(resolve_search_box_bg_hex(
@@ -154,8 +170,9 @@
         } else {
             colors.accent
         };
-        let focused_row_bg = rgba((row_accent_color << 8) | ROW_FOCUSED_BG_ALPHA);
-        let hovered_row_bg = rgba((row_accent_color << 8) | ROW_HOVER_BG_ALPHA);
+        let focused_row_bg_hex = (row_accent_color << 8) | ROW_FOCUSED_BG_ALPHA;
+        let hovered_row_bg_hex = (row_accent_color << 8) | ROW_HOVER_BG_ALPHA;
+        let hovered_row_bg = rgba(hovered_row_bg_hex);
 
         let placeholder = self
             .placeholder
@@ -278,13 +295,11 @@
                                                     ))
                                                 },
                                             );
-                                        let row_bg = if is_focused {
-                                            focused_row_bg
-                                        } else if is_hovered {
-                                            hovered_row_bg
-                                        } else {
-                                            rgba(0x00000000)
-                                        };
+                                        let row_bg = rgba(resolve_row_bg_hex(
+                                            row_state,
+                                            focused_row_bg_hex,
+                                            hovered_row_bg_hex,
+                                        ));
                                         let hover_handler = cx.listener(
                                             move |this: &mut SelectPrompt,
                                                   hovered: &bool,
@@ -327,7 +342,7 @@
                                                 .colors(item_colors),
                                             );
 
-                                        if !is_focused {
+                                        if !is_focused && !is_selected {
                                             row = row.hover(move |s| s.bg(hovered_row_bg));
                                         }
 
@@ -367,7 +382,7 @@
             .rounded(px(12.0))
             .overflow_hidden()
             .border_1()
-            .border_color(border_color.opacity(0.25))
+            .border_color(rgba((border_color_hex << 8) | 0x40))
             .text_color(text_color)
             .key_context("select_prompt")
             .track_focus(&self.focus_handle)
@@ -376,3 +391,42 @@
             .child(choices_container)
     }
 }
+
+#[cfg(test)]
+mod tests {
+    use super::{resolve_row_bg_hex, SelectRowState};
+
+    #[test]
+    fn test_resolve_row_bg_hex_uses_focused_accent_for_selected_row() {
+        let focused_bg_hex = 0x55AAFF3A;
+        let hovered_bg_hex = 0x55AAFF26;
+
+        let selected_row = SelectRowState {
+            is_focused: false,
+            is_selected: true,
+            is_hovered: false,
+        };
+
+        assert_eq!(
+            resolve_row_bg_hex(selected_row, focused_bg_hex, hovered_bg_hex),
+            focused_bg_hex
+        );
+    }
+
+    #[test]
+    fn test_resolve_row_bg_hex_uses_hover_color_for_unselected_hovered_row() {
+        let focused_bg_hex = 0x55AAFF3A;
+        let hovered_bg_hex = 0x55AAFF26;
+
+        let hovered_row = SelectRowState {
+            is_focused: false,
+            is_selected: false,
+            is_hovered: true,
+        };
+
+        assert_eq!(
+            resolve_row_bg_hex(hovered_row, focused_bg_hex, hovered_bg_hex),
+            hovered_bg_hex
+        );
+    }
+}


thinking
**Killing stale cargo process**
exec
/bin/zsh -lc 'kill 39954' in /Users/johnlindquist/dev/script-kit-gpui succeeded in 51ms:

file update:
diff --git a/src/prompts/select/render.rs b/src/prompts/select/render.rs
index d0e0a5485f10066de9a287b70a4c3ae891e5cd99..c26ba855b7e69a16a4d3e1b048889d3588ac5525
--- a/src/prompts/select/render.rs
+++ b/src/prompts/select/render.rs
@@ -24,6 +24,20 @@
     }
 }
 
+pub(super) fn resolve_row_bg_hex(
+    row_state: SelectRowState,
+    focused_bg_hex: u32,
+    hovered_bg_hex: u32,
+) -> u32 {
+    if row_state.is_focused || row_state.is_selected {
+        focused_bg_hex
+    } else if row_state.is_hovered {
+        hovered_bg_hex
+    } else {
+        0x00000000
+    }
+}
+
 pub(super) fn extract_choice_icon_hint(description: Option<&str>) -> Option<&str> {
     description.and_then(|raw| {
         raw.split(['•', '|', '\n'])
@@ -128,13 +142,14 @@
         // VIBRANCY: Optional background override when a vibrancy surface is available.
         let vibrancy_bg = get_vibrancy_background(&self.theme);
 
-        let (_main_bg, text_color, muted_color, border_color) =
+        let (_main_bg, text_color, muted_color, border_color, border_color_hex) =
             if self.design_variant == DesignVariant::Default {
                 (
                     rgb(self.theme.colors.background.main),
                     rgb(self.theme.colors.text.secondary),
                     rgb(self.theme.colors.text.muted),
                     rgb(self.theme.colors.ui.border),
+                    self.theme.colors.ui.border,
                 )
             } else {
                 (
@@ -142,6 +157,7 @@
                     rgb(colors.text_secondary),
                     rgb(colors.text_muted),
                     rgb(colors.border),
+                    colors.border,
                 )
             };
         let search_box_bg = rgb(resolve_search_box_bg_hex(
@@ -154,8 +170,9 @@
         } else {
             colors.accent
         };
-        let focused_row_bg = rgba((row_accent_color << 8) | ROW_FOCUSED_BG_ALPHA);
-        let hovered_row_bg = rgba((row_accent_color << 8) | ROW_HOVER_BG_ALPHA);
+        let focused_row_bg_hex = (row_accent_color << 8) | ROW_FOCUSED_BG_ALPHA;
+        let hovered_row_bg_hex = (row_accent_color << 8) | ROW_HOVER_BG_ALPHA;
+        let hovered_row_bg = rgba(hovered_row_bg_hex);
 
         let placeholder = self
             .placeholder
@@ -278,13 +295,11 @@
                                                     ))
                                                 },
                                             );
-                                        let row_bg = if is_focused {
-                                            focused_row_bg
-                                        } else if is_hovered {
-                                            hovered_row_bg
-                                        } else {
-                                            rgba(0x00000000)
-                                        };
+                                        let row_bg = rgba(resolve_row_bg_hex(
+                                            row_state,
+                                            focused_row_bg_hex,
+                                            hovered_row_bg_hex,
+                                        ));
                                         let hover_handler = cx.listener(
                                             move |this: &mut SelectPrompt,
                                                   hovered: &bool,
@@ -327,7 +342,7 @@
                                                 .colors(item_colors),
                                             );
 
-                                        if !is_focused {
+                                        if !is_focused && !is_selected {
                                             row = row.hover(move |s| s.bg(hovered_row_bg));
                                         }
 
@@ -367,7 +382,7 @@
             .rounded(px(12.0))
             .overflow_hidden()
             .border_1()
-            .border_color(border_color.opacity(0.25))
+            .border_color(rgba((border_color_hex << 8) | 0x40))
             .text_color(text_color)
             .key_context("select_prompt")
             .track_focus(&self.focus_handle)
@@ -376,3 +391,42 @@
             .child(choices_container)
     }
 }
+
+#[cfg(test)]
+mod tests {
+    use super::{resolve_row_bg_hex, SelectRowState};
+
+    #[test]
+    fn test_resolve_row_bg_hex_uses_focused_accent_for_selected_row() {
+        let focused_bg_hex = 0x55AAFF3A;
+        let hovered_bg_hex = 0x55AAFF26;
+
+        let selected_row = SelectRowState {
+            is_focused: false,
+            is_selected: true,
+            is_hovered: false,
+        };
+
+        assert_eq!(
+            resolve_row_bg_hex(selected_row, focused_bg_hex, hovered_bg_hex),
+            focused_bg_hex
+        );
+    }
+
+    #[test]
+    fn test_resolve_row_bg_hex_uses_hover_color_for_unselected_hovered_row() {
+        let focused_bg_hex = 0x55AAFF3A;
+        let hovered_bg_hex = 0x55AAFF26;
+
+        let hovered_row = SelectRowState {
+            is_focused: false,
+            is_selected: false,
+            is_hovered: true,
+        };
+
+        assert_eq!(
+            resolve_row_bg_hex(hovered_row, focused_bg_hex, hovered_bg_hex),
+            hovered_bg_hex
+        );
+    }
+}


thinking
**Running code checks despite potential errors**
codex
`cargo check` in isolated target compiled far enough to reveal unrelated chat/footer errors outside this file. I’m still running the requested clippy and scoped select tests to capture complete verification status for this change.

thinking
**Running clippy in isolated target**
exec
/bin/zsh -lc 'CARGO_TARGET_DIR=target/codex-list-polish-split-1 cargo clippy -p script-kit-gpui --all-targets -- -D warnings' in /Users/johnlindquist/dev/script-kit-gpuifile update:
diff --git a/src/prompts/select/render.rs b/src/prompts/select/render.rs
index d0e0a5485f10066de9a287b70a4c3ae891e5cd99..c26ba855b7e69a16a4d3e1b048889d3588ac5525
--- a/src/prompts/select/render.rs
+++ b/src/prompts/select/render.rs
@@ -24,6 +24,20 @@
     }
 }
 
+pub(super) fn resolve_row_bg_hex(
+    row_state: SelectRowState,
+    focused_bg_hex: u32,
+    hovered_bg_hex: u32,
+) -> u32 {
+    if row_state.is_focused || row_state.is_selected {
+        focused_bg_hex
+    } else if row_state.is_hovered {
+        hovered_bg_hex
+    } else {
+        0x00000000
+    }
+}
+
 pub(super) fn extract_choice_icon_hint(description: Option<&str>) -> Option<&str> {
     description.and_then(|raw| {
         raw.split(['•', '|', '\n'])
@@ -128,13 +142,14 @@
         // VIBRANCY: Optional background override when a vibrancy surface is available.
         let vibrancy_bg = get_vibrancy_background(&self.theme);
 
-        let (_main_bg, text_color, muted_color, border_color) =
+        let (_main_bg, text_color, muted_color, border_color, border_color_hex) =
             if self.design_variant == DesignVariant::Default {
                 (
                     rgb(self.theme.colors.background.main),
                     rgb(self.theme.colors.text.secondary),
                     rgb(self.theme.colors.text.muted),
                     rgb(self.theme.colors.ui.border),
+                    self.theme.colors.ui.border,
                 )
             } else {
                 (
@@ -142,6 +157,7 @@
                     rgb(colors.text_secondary),
                     rgb(colors.text_muted),
                     rgb(colors.border),
+                    colors.border,
                 )
             };
         let search_box_bg = rgb(resolve_search_box_bg_hex(
@@ -154,8 +170,9 @@
         } else {
             colors.accent
         };
-        let focused_row_bg = rgba((row_accent_color << 8) | ROW_FOCUSED_BG_ALPHA);
-        let hovered_row_bg = rgba((row_accent_color << 8) | ROW_HOVER_BG_ALPHA);
+        let focused_row_bg_hex = (row_accent_color << 8) | ROW_FOCUSED_BG_ALPHA;
+        let hovered_row_bg_hex = (row_accent_color << 8) | ROW_HOVER_BG_ALPHA;
+        let hovered_row_bg = rgba(hovered_row_bg_hex);
 
         let placeholder = self
             .placeholder
@@ -278,13 +295,11 @@
                                                     ))
                                                 },
                                             );
-                                        let row_bg = if is_focused {
-                                            focused_row_bg
-                                        } else if is_hovered {
-                                            hovered_row_bg
-                                        } else {
-                                            rgba(0x00000000)
-                                        };
+                                        let row_bg = rgba(resolve_row_bg_hex(
+                                            row_state,
+                                            focused_row_bg_hex,
+                                            hovered_row_bg_hex,
+                                        ));
                                         let hover_handler = cx.listener(
                                             move |this: &mut SelectPrompt,
                                                   hovered: &bool,
@@ -327,7 +342,7 @@
                                                 .colors(item_colors),
                                             );
 
-                                        if !is_focused {
+                                        if !is_focused && !is_selected {
                                             row = row.hover(move |s| s.bg(hovered_row_bg));
                                         }
 
@@ -367,7 +382,7 @@
             .rounded(px(12.0))
             .overflow_hidden()
             .border_1()
-            .border_color(border_color.opacity(0.25))
+            .border_color(rgba((border_color_hex << 8) | 0x40))
             .text_color(text_color)
             .key_context("select_prompt")
             .track_focus(&self.focus_handle)
@@ -376,3 +391,42 @@
             .child(choices_container)
     }
 }
+
+#[cfg(test)]
+mod tests {
+    use super::{resolve_row_bg_hex, SelectRowState};
+
+    #[test]
+    fn test_resolve_row_bg_hex_uses_focused_accent_for_selected_row() {
+        let focused_bg_hex = 0x55AAFF3A;
+        let hovered_bg_hex = 0x55AAFF26;
+
+        let selected_row = SelectRowState {
+            is_focused: false,
+            is_selected: true,
+            is_hovered: false,
+        };
+
+        assert_eq!(
+            resolve_row_bg_hex(selected_row, focused_bg_hex, hovered_bg_hex),
+            focused_bg_hex
+        );
+    }
+
+    #[test]
+    fn test_resolve_row_bg_hex_uses_hover_color_for_unselected_hovered_row() {
+        let focused_bg_hex = 0x55AAFF3A;
+        let hovered_bg_hex = 0x55AAFF26;
+
+        let hovered_row = SelectRowState {
+            is_focused: false,
+            is_selected: false,
+            is_hovered: true,
+        };
+
+        assert_eq!(
+            resolve_row_bg_hex(hovered_row, focused_bg_hex, hovered_bg_hex),
+            hovered_bg_hex
+        );
+    }
+}

file update:
diff --git a/src/prompts/select/render.rs b/src/prompts/select/render.rs
index d0e0a5485f10066de9a287b70a4c3ae891e5cd99..c26ba855b7e69a16a4d3e1b048889d3588ac5525
--- a/src/prompts/select/render.rs
+++ b/src/prompts/select/render.rs
@@ -24,6 +24,20 @@
     }
 }
 
+pub(super) fn resolve_row_bg_hex(
+    row_state: SelectRowState,
+    focused_bg_hex: u32,
+    hovered_bg_hex: u32,
+) -> u32 {
+    if row_state.is_focused || row_state.is_selected {
+        focused_bg_hex
+    } else if row_state.is_hovered {
+        hovered_bg_hex
+    } else {
+        0x00000000
+    }
+}
+
 pub(super) fn extract_choice_icon_hint(description: Option<&str>) -> Option<&str> {
     description.and_then(|raw| {
         raw.split(['•', '|', '\n'])
@@ -128,13 +142,14 @@
         // VIBRANCY: Optional background override when a vibrancy surface is available.
         let vibrancy_bg = get_vibrancy_background(&self.theme);
 
-        let (_main_bg, text_color, muted_color, border_color) =
+        let (_main_bg, text_color, muted_color, border_color, border_color_hex) =
             if self.design_variant == DesignVariant::Default {
                 (
                     rgb(self.theme.colors.background.main),
                     rgb(self.theme.colors.text.secondary),
                     rgb(self.theme.colors.text.muted),
                     rgb(self.theme.colors.ui.border),
+                    self.theme.colors.ui.border,
                 )
             } else {
                 (
@@ -142,6 +157,7 @@
                     rgb(colors.text_secondary),
                     rgb(colors.text_muted),
                     rgb(colors.border),
+                    colors.border,
                 )
             };
         let search_box_bg = rgb(resolve_search_box_bg_hex(
@@ -154,8 +170,9 @@
         } else {
             colors.accent
         };
-        let focused_row_bg = rgba((row_accent_color << 8) | ROW_FOCUSED_BG_ALPHA);
-        let hovered_row_bg = rgba((row_accent_color << 8) | ROW_HOVER_BG_ALPHA);
+        let focused_row_bg_hex = (row_accent_color << 8) | ROW_FOCUSED_BG_ALPHA;
+        let hovered_row_bg_hex = (row_accent_color << 8) | ROW_HOVER_BG_ALPHA;
+        let hovered_row_bg = rgba(hovered_row_bg_hex);
 
         let placeholder = self
             .placeholder
@@ -278,13 +295,11 @@
                                                     ))
                                                 },
                                             );
-                                        let row_bg = if is_focused {
-                                            focused_row_bg
-                                        } else if is_hovered {
-                                            hovered_row_bg
-                                        } else {
-                                            rgba(0x00000000)
-                                        };
+                                        let row_bg = rgba(resolve_row_bg_hex(
+                                            row_state,
+                                            focused_row_bg_hex,
+                                            hovered_row_bg_hex,
+                                        ));
                                         let hover_handler = cx.listener(
                                             move |this: &mut SelectPrompt,
                                                   hovered: &bool,
@@ -327,7 +342,7 @@
                                                 .colors(item_colors),
                                             );
 
-                                        if !is_focused {
+                                        if !is_focused && !is_selected {
                                             row = row.hover(move |s| s.bg(hovered_row_bg));
                                         }
 
@@ -367,7 +382,7 @@
             .rounded(px(12.0))
             .overflow_hidden()
             .border_1()
-            .border_color(border_color.opacity(0.25))
+            .border_color(rgba((border_color_hex << 8) | 0x40))
             .text_color(text_color)
             .key_context("select_prompt")
             .track_focus(&self.focus_handle)
@@ -376,3 +391,42 @@
             .child(choices_container)
     }
 }
+
+#[cfg(test)]
+mod tests {
+    use super::{resolve_row_bg_hex, SelectRowState};
+
+    #[test]
+    fn test_resolve_row_bg_hex_uses_focused_accent_for_selected_row() {
+        let focused_bg_hex = 0x55AAFF3A;
+        let hovered_bg_hex = 0x55AAFF26;
+
+        let selected_row = SelectRowState {
+            is_focused: false,
+            is_selected: true,
+            is_hovered: false,
+        };
+
+        assert_eq!(
+            resolve_row_bg_hex(selected_row, focused_bg_hex, hovered_bg_hex),
+            focused_bg_hex
+        );
+    }
+
+    #[test]
+    fn test_resolve_row_bg_hex_uses_hover_color_for_unselected_hovered_row() {
+        let focused_bg_hex = 0x55AAFF3A;
+        let hovered_bg_hex = 0x55AAFF26;
+
+        let hovered_row = SelectRowState {
+            is_focused: false,
+            is_selected: false,
+            is_hovered: true,
+        };
+
+        assert_eq!(
+            resolve_row_bg_hex(hovered_row, focused_bg_hex, hovered_bg_hex),
+            hovered_bg_hex
+        );
+    }
+}


thinking
**Running targeted test subset**
exec
/bin/zsh -lc 'CARGO_TARGET_DIR=target/codex-list-polish-split-1 cargo test -p script-kit-gpui --lib prompts::select::render::tests::' in /Users/johnlindquist/dev/script-kit-gpuifile update:
diff --git a/src/prompts/select/render.rs b/src/prompts/select/render.rs
index d0e0a5485f10066de9a287b70a4c3ae891e5cd99..c26ba855b7e69a16a4d3e1b048889d3588ac5525
--- a/src/prompts/select/render.rs
+++ b/src/prompts/select/render.rs
@@ -24,6 +24,20 @@
     }
 }
 
+pub(super) fn resolve_row_bg_hex(
+    row_state: SelectRowState,
+    focused_bg_hex: u32,
+    hovered_bg_hex: u32,
+) -> u32 {
+    if row_state.is_focused || row_state.is_selected {
+        focused_bg_hex
+    } else if row_state.is_hovered {
+        hovered_bg_hex
+    } else {
+        0x00000000
+    }
+}
+
 pub(super) fn extract_choice_icon_hint(description: Option<&str>) -> Option<&str> {
     description.and_then(|raw| {
         raw.split(['•', '|', '\n'])
@@ -128,13 +142,14 @@
         // VIBRANCY: Optional background override when a vibrancy surface is available.
         let vibrancy_bg = get_vibrancy_background(&self.theme);
 
-        let (_main_bg, text_color, muted_color, border_color) =
+        let (_main_bg, text_color, muted_color, border_color, border_color_hex) =
             if self.design_variant == DesignVariant::Default {
                 (
                     rgb(self.theme.colors.background.main),
                     rgb(self.theme.colors.text.secondary),
                     rgb(self.theme.colors.text.muted),
                     rgb(self.theme.colors.ui.border),
+                    self.theme.colors.ui.border,
                 )
             } else {
                 (
@@ -142,6 +157,7 @@
                     rgb(colors.text_secondary),
                     rgb(colors.text_muted),
                     rgb(colors.border),
+                    colors.border,
                 )
             };
         let search_box_bg = rgb(resolve_search_box_bg_hex(
@@ -154,8 +170,9 @@
         } else {
             colors.accent
         };
-        let focused_row_bg = rgba((row_accent_color << 8) | ROW_FOCUSED_BG_ALPHA);
-        let hovered_row_bg = rgba((row_accent_color << 8) | ROW_HOVER_BG_ALPHA);
+        let focused_row_bg_hex = (row_accent_color << 8) | ROW_FOCUSED_BG_ALPHA;
+        let hovered_row_bg_hex = (row_accent_color << 8) | ROW_HOVER_BG_ALPHA;
+        let hovered_row_bg = rgba(hovered_row_bg_hex);
 
         let placeholder = self
             .placeholder
@@ -278,13 +295,11 @@
                                                     ))
                                                 },
                                             );
-                                        let row_bg = if is_focused {
-                                            focused_row_bg
-                                        } else if is_hovered {
-                                            hovered_row_bg
-                                        } else {
-                                            rgba(0x00000000)
-                                        };
+                                        let row_bg = rgba(resolve_row_bg_hex(
+                                            row_state,
+                                            focused_row_bg_hex,
+                                            hovered_row_bg_hex,
+                                        ));
                                         let hover_handler = cx.listener(
                                             move |this: &mut SelectPrompt,
                                                   hovered: &bool,
@@ -327,7 +342,7 @@
                                                 .colors(item_colors),
                                             );
 
-                                        if !is_focused {
+                                        if !is_focused && !is_selected {
                                             row = row.hover(move |s| s.bg(hovered_row_bg));
                                         }
 
@@ -367,7 +382,7 @@
             .rounded(px(12.0))
             .overflow_hidden()
             .border_1()
-            .border_color(border_color.opacity(0.25))
+            .border_color(rgba((border_color_hex << 8) | 0x40))
             .text_color(text_color)
             .key_context("select_prompt")
             .track_focus(&self.focus_handle)
@@ -376,3 +391,42 @@
             .child(choices_container)
     }
 }
+
+#[cfg(test)]
+mod tests {
+    use super::{resolve_row_bg_hex, SelectRowState};
+
+    #[test]
+    fn test_resolve_row_bg_hex_uses_focused_accent_for_selected_row() {
+        let focused_bg_hex = 0x55AAFF3A;
+        let hovered_bg_hex = 0x55AAFF26;
+
+        let selected_row = SelectRowState {
+            is_focused: false,
+            is_selected: true,
+            is_hovered: false,
+        };
+
+        assert_eq!(
+            resolve_row_bg_hex(selected_row, focused_bg_hex, hovered_bg_hex),
+            focused_bg_hex
+        );
+    }
+
+    #[test]
+    fn test_resolve_row_bg_hex_uses_hover_color_for_unselected_hovered_row() {
+        let focused_bg_hex = 0x55AAFF3A;
+        let hovered_bg_hex = 0x55AAFF26;
+
+        let hovered_row = SelectRowState {
+            is_focused: false,
+            is_selected: false,
+            is_hovered: true,
+        };
+
+        assert_eq!(
+            resolve_row_bg_hex(hovered_row, focused_bg_hex, hovered_bg_hex),
+            hovered_bg_hex
+        );
+    }
+}


thinking
**Waiting for lock release**
file update:
diff --git a/src/prompts/select/render.rs b/src/prompts/select/render.rs
index d0e0a5485f10066de9a287b70a4c3ae891e5cd99..c26ba855b7e69a16a4d3e1b048889d3588ac5525
--- a/src/prompts/select/render.rs
+++ b/src/prompts/select/render.rs
@@ -24,6 +24,20 @@
     }
 }
 
+pub(super) fn resolve_row_bg_hex(
+    row_state: SelectRowState,
+    focused_bg_hex: u32,
+    hovered_bg_hex: u32,
+) -> u32 {
+    if row_state.is_focused || row_state.is_selected {
+        focused_bg_hex
+    } else if row_state.is_hovered {
+        hovered_bg_hex
+    } else {
+        0x00000000
+    }
+}
+
 pub(super) fn extract_choice_icon_hint(description: Option<&str>) -> Option<&str> {
     description.and_then(|raw| {
         raw.split(['•', '|', '\n'])
@@ -128,13 +142,14 @@
         // VIBRANCY: Optional background override when a vibrancy surface is available.
         let vibrancy_bg = get_vibrancy_background(&self.theme);
 
-        let (_main_bg, text_color, muted_color, border_color) =
+        let (_main_bg, text_color, muted_color, border_color, border_color_hex) =
             if self.design_variant == DesignVariant::Default {
                 (
                     rgb(self.theme.colors.background.main),
                     rgb(self.theme.colors.text.secondary),
                     rgb(self.theme.colors.text.muted),
                     rgb(self.theme.colors.ui.border),
+                    self.theme.colors.ui.border,
                 )
             } else {
                 (
@@ -142,6 +157,7 @@
                     rgb(colors.text_secondary),
                     rgb(colors.text_muted),
                     rgb(colors.border),
+                    colors.border,
                 )
             };
         let search_box_bg = rgb(resolve_search_box_bg_hex(
@@ -154,8 +170,9 @@
         } else {
             colors.accent
         };
-        let focused_row_bg = rgba((row_accent_color << 8) | ROW_FOCUSED_BG_ALPHA);
-        let hovered_row_bg = rgba((row_accent_color << 8) | ROW_HOVER_BG_ALPHA);
+        let focused_row_bg_hex = (row_accent_color << 8) | ROW_FOCUSED_BG_ALPHA;
+        let hovered_row_bg_hex = (row_accent_color << 8) | ROW_HOVER_BG_ALPHA;
+        let hovered_row_bg = rgba(hovered_row_bg_hex);
 
         let placeholder = self
             .placeholder
@@ -278,13 +295,11 @@
                                                     ))
                                                 },
                                             );
-                                        let row_bg = if is_focused {
-                                            focused_row_bg
-                                        } else if is_hovered {
-                                            hovered_row_bg
-                                        } else {
-                                            rgba(0x00000000)
-                                        };
+                                        let row_bg = rgba(resolve_row_bg_hex(
+                                            row_state,
+                                            focused_row_bg_hex,
+                                            hovered_row_bg_hex,
+                                        ));
                                         let hover_handler = cx.listener(
                                             move |this: &mut SelectPrompt,
                                                   hovered: &bool,
@@ -327,7 +342,7 @@
                                                 .colors(item_colors),
                                             );
 
-                                        if !is_focused {
+                                        if !is_focused && !is_selected {
                                             row = row.hover(move |s| s.bg(hovered_row_bg));
                                         }
 
@@ -367,7 +382,7 @@
             .rounded(px(12.0))
             .overflow_hidden()
             .border_1()
-            .border_color(border_color.opacity(0.25))
+            .border_color(rgba((border_color_hex << 8) | 0x40))
             .text_color(text_color)
             .key_context("select_prompt")
             .track_focus(&self.focus_handle)
@@ -376,3 +391,42 @@
             .child(choices_container)
     }
 }
+
+#[cfg(test)]
+mod tests {
+    use super::{resolve_row_bg_hex, SelectRowState};
+
+    #[test]
+    fn test_resolve_row_bg_hex_uses_focused_accent_for_selected_row() {
+        let focused_bg_hex = 0x55AAFF3A;
+        let hovered_bg_hex = 0x55AAFF26;
+
+        let selected_row = SelectRowState {
+            is_focused: false,
+            is_selected: true,
+            is_hovered: false,
+        };
+
+        assert_eq!(
+            resolve_row_bg_hex(selected_row, focused_bg_hex, hovered_bg_hex),
+            focused_bg_hex
+        );
+    }
+
+    #[test]
+    fn test_resolve_row_bg_hex_uses_hover_color_for_unselected_hovered_row() {
+        let focused_bg_hex = 0x55AAFF3A;
+        let hovered_bg_hex = 0x55AAFF26;
+
+        let hovered_row = SelectRowState {
+            is_focused: false,
+            is_selected: false,
+            is_hovered: true,
+        };
+
+        assert_eq!(
+            resolve_row_bg_hex(hovered_row, focused_bg_hex, hovered_bg_hex),
+            hovered_bg_hex
+        );
+    }
+}


thinking
**Checking for active cargo processes**
exec
/bin/zsh -lc 'ps -Ao pid,command | rg "cargo (clippy|test|check) -p script-kit-gpui"' in /Users/johnlindquist/dev/script-kit-gpui succeeded in 52ms:
40337 /Users/johnlindquist/.rustup/toolchains/stable-aarch64-apple-darwin/bin/cargo check -p script-kit-gpui --all-targets
40588 /Users/johnlindquist/.rustup/toolchains/stable-aarch64-apple-darwin/bin/cargo check -p script-kit-gpui --all-targets
40823 /Users/johnlindquist/.rustup/toolchains/stable-aarch64-apple-darwin/bin/cargo test -p script-kit-gpui prompt_header::tests:: -- --nocapture
41036 /Users/johnlindquist/.rustup/toolchains/stable-aarch64-apple-darwin/bin/cargo test -p script-kit-gpui --lib prompts::select::render::tests::
file update:
diff --git a/src/prompts/select/render.rs b/src/prompts/select/render.rs
index d0e0a5485f10066de9a287b70a4c3ae891e5cd99..c26ba855b7e69a16a4d3e1b048889d3588ac5525
--- a/src/prompts/select/render.rs
+++ b/src/prompts/select/render.rs
@@ -24,6 +24,20 @@
     }
 }
 
+pub(super) fn resolve_row_bg_hex(
+    row_state: SelectRowState,
+    focused_bg_hex: u32,
+    hovered_bg_hex: u32,
+) -> u32 {
+    if row_state.is_focused || row_state.is_selected {
+        focused_bg_hex
+    } else if row_state.is_hovered {
+        hovered_bg_hex
+    } else {
+        0x00000000
+    }
+}
+
 pub(super) fn extract_choice_icon_hint(description: Option<&str>) -> Option<&str> {
     description.and_then(|raw| {
         raw.split(['•', '|', '\n'])
@@ -128,13 +142,14 @@
         // VIBRANCY: Optional background override when a vibrancy surface is available.
         let vibrancy_bg = get_vibrancy_background(&self.theme);
 
-        let (_main_bg, text_color, muted_color, border_color) =
+        let (_main_bg, text_color, muted_color, border_color, border_color_hex) =
             if self.design_variant == DesignVariant::Default {
                 (
                     rgb(self.theme.colors.background.main),
                     rgb(self.theme.colors.text.secondary),
                     rgb(self.theme.colors.text.muted),
                     rgb(self.theme.colors.ui.border),
+                    self.theme.colors.ui.border,
                 )
             } else {
                 (
@@ -142,6 +157,7 @@
                     rgb(colors.text_secondary),
                     rgb(colors.text_muted),
                     rgb(colors.border),
+                    colors.border,
                 )
             };
         let search_box_bg = rgb(resolve_search_box_bg_hex(
@@ -154,8 +170,9 @@
         } else {
             colors.accent
         };
-        let focused_row_bg = rgba((row_accent_color << 8) | ROW_FOCUSED_BG_ALPHA);
-        let hovered_row_bg = rgba((row_accent_color << 8) | ROW_HOVER_BG_ALPHA);
+        let focused_row_bg_hex = (row_accent_color << 8) | ROW_FOCUSED_BG_ALPHA;
+        let hovered_row_bg_hex = (row_accent_color << 8) | ROW_HOVER_BG_ALPHA;
+        let hovered_row_bg = rgba(hovered_row_bg_hex);
 
         let placeholder = self
             .placeholder
@@ -278,13 +295,11 @@
                                                     ))
                                                 },
                                             );
-                                        let row_bg = if is_focused {
-                                            focused_row_bg
-                                        } else if is_hovered {
-                                            hovered_row_bg
-                                        } else {
-                                            rgba(0x00000000)
-                                        };
+                                        let row_bg = rgba(resolve_row_bg_hex(
+                                            row_state,
+                                            focused_row_bg_hex,
+                                            hovered_row_bg_hex,
+                                        ));
                                         let hover_handler = cx.listener(
                                             move |this: &mut SelectPrompt,
                                                   hovered: &bool,
@@ -327,7 +342,7 @@
                                                 .colors(item_colors),
                                             );
 
-                                        if !is_focused {
+                                        if !is_focused && !is_selected {
                                             row = row.hover(move |s| s.bg(hovered_row_bg));
                                         }
 
@@ -367,7 +382,7 @@
             .rounded(px(12.0))
             .overflow_hidden()
             .border_1()
-            .border_color(border_color.opacity(0.25))
+            .border_color(rgba((border_color_hex << 8) | 0x40))
             .text_color(text_color)
             .key_context("select_prompt")
             .track_focus(&self.focus_handle)
@@ -376,3 +391,42 @@
             .child(choices_container)
     }
 }
+
+#[cfg(test)]
+mod tests {
+    use super::{resolve_row_bg_hex, SelectRowState};
+
+    #[test]
+    fn test_resolve_row_bg_hex_uses_focused_accent_for_selected_row() {
+        let focused_bg_hex = 0x55AAFF3A;
+        let hovered_bg_hex = 0x55AAFF26;
+
+        let selected_row = SelectRowState {
+            is_focused: false,
+            is_selected: true,
+            is_hovered: false,
+        };
+
+        assert_eq!(
+            resolve_row_bg_hex(selected_row, focused_bg_hex, hovered_bg_hex),
+            focused_bg_hex
+        );
+    }
+
+    #[test]
+    fn test_resolve_row_bg_hex_uses_hover_color_for_unselected_hovered_row() {
+        let focused_bg_hex = 0x55AAFF3A;
+        let hovered_bg_hex = 0x55AAFF26;
+
+        let hovered_row = SelectRowState {
+            is_focused: false,
+            is_selected: false,
+            is_hovered: true,
+        };
+
+        assert_eq!(
+            resolve_row_bg_hex(hovered_row, focused_bg_hex, hovered_bg_hex),
+            hovered_bg_hex
+        );
+    }
+}


thinking
**Polling for lingering lock sessions**
file update:
diff --git a/src/prompts/select/render.rs b/src/prompts/select/render.rs
index d0e0a5485f10066de9a287b70a4c3ae891e5cd99..c26ba855b7e69a16a4d3e1b048889d3588ac5525
--- a/src/prompts/select/render.rs
+++ b/src/prompts/select/render.rs
@@ -24,6 +24,20 @@
     }
 }
 
+pub(super) fn resolve_row_bg_hex(
+    row_state: SelectRowState,
+    focused_bg_hex: u32,
+    hovered_bg_hex: u32,
+) -> u32 {
+    if row_state.is_focused || row_state.is_selected {
+        focused_bg_hex
+    } else if row_state.is_hovered {
+        hovered_bg_hex
+    } else {
+        0x00000000
+    }
+}
+
 pub(super) fn extract_choice_icon_hint(description: Option<&str>) -> Option<&str> {
     description.and_then(|raw| {
         raw.split(['•', '|', '\n'])
@@ -128,13 +142,14 @@
         // VIBRANCY: Optional background override when a vibrancy surface is available.
         let vibrancy_bg = get_vibrancy_background(&self.theme);
 
-        let (_main_bg, text_color, muted_color, border_color) =
+        let (_main_bg, text_color, muted_color, border_color, border_color_hex) =
             if self.design_variant == DesignVariant::Default {
                 (
                     rgb(self.theme.colors.background.main),
                     rgb(self.theme.colors.text.secondary),
                     rgb(self.theme.colors.text.muted),
                     rgb(self.theme.colors.ui.border),
+                    self.theme.colors.ui.border,
                 )
             } else {
                 (
@@ -142,6 +157,7 @@
                     rgb(colors.text_secondary),
                     rgb(colors.text_muted),
                     rgb(colors.border),
+                    colors.border,
                 )
             };
         let search_box_bg = rgb(resolve_search_box_bg_hex(
@@ -154,8 +170,9 @@
         } else {
             colors.accent
         };
-        let focused_row_bg = rgba((row_accent_color << 8) | ROW_FOCUSED_BG_ALPHA);
-        let hovered_row_bg = rgba((row_accent_color << 8) | ROW_HOVER_BG_ALPHA);
+        let focused_row_bg_hex = (row_accent_color << 8) | ROW_FOCUSED_BG_ALPHA;
+        let hovered_row_bg_hex = (row_accent_color << 8) | ROW_HOVER_BG_ALPHA;
+        let hovered_row_bg = rgba(hovered_row_bg_hex);
 
         let placeholder = self
             .placeholder
@@ -278,13 +295,11 @@
                                                     ))
                                                 },
                                             );
-                                        let row_bg = if is_focused {
-                                            focused_row_bg
-                                        } else if is_hovered {
-                                            hovered_row_bg
-                                        } else {
-                                            rgba(0x00000000)
-                                        };
+                                        let row_bg = rgba(resolve_row_bg_hex(
+                                            row_state,
+                                            focused_row_bg_hex,
+                                            hovered_row_bg_hex,
+                                        ));
                                         let hover_handler = cx.listener(
                                             move |this: &mut SelectPrompt,
                                                   hovered: &bool,
@@ -327,7 +342,7 @@
                                                 .colors(item_colors),
                                             );
 
-                                        if !is_focused {
+                                        if !is_focused && !is_selected {
                                             row = row.hover(move |s| s.bg(hovered_row_bg));
                                         }
 
@@ -367,7 +382,7 @@
             .rounded(px(12.0))
             .overflow_hidden()
             .border_1()
-            .border_color(border_color.opacity(0.25))
+            .border_color(rgba((border_color_hex << 8) | 0x40))
             .text_color(text_color)
             .key_context("select_prompt")
             .track_focus(&self.focus_handle)
@@ -376,3 +391,42 @@
             .child(choices_container)
     }
 }
+
+#[cfg(test)]
+mod tests {
+    use super::{resolve_row_bg_hex, SelectRowState};
+
+    #[test]
+    fn test_resolve_row_bg_hex_uses_focused_accent_for_selected_row() {
+        let focused_bg_hex = 0x55AAFF3A;
+        let hovered_bg_hex = 0x55AAFF26;
+
+        let selected_row = SelectRowState {
+            is_focused: false,
+            is_selected: true,
+            is_hovered: false,
+        };
+
+        assert_eq!(
+            resolve_row_bg_hex(selected_row, focused_bg_hex, hovered_bg_hex),
+            focused_bg_hex
+        );
+    }
+
+    #[test]
+    fn test_resolve_row_bg_hex_uses_hover_color_for_unselected_hovered_row() {
+        let focused_bg_hex = 0x55AAFF3A;
+        let hovered_bg_hex = 0x55AAFF26;
+
+        let hovered_row = SelectRowState {
+            is_focused: false,
+            is_selected: false,
+            is_hovered: true,
+        };
+
+        assert_eq!(
+            resolve_row_bg_hex(hovered_row, focused_bg_hex, hovered_bg_hex),
+            hovered_bg_hex
+        );
+    }
+}


thinking
**Polling for session completion**
file update:
diff --git a/src/prompts/select/render.rs b/src/prompts/select/render.rs
index d0e0a5485f10066de9a287b70a4c3ae891e5cd99..c26ba855b7e69a16a4d3e1b048889d3588ac5525
--- a/src/prompts/select/render.rs
+++ b/src/prompts/select/render.rs
@@ -24,6 +24,20 @@
     }
 }
 
+pub(super) fn resolve_row_bg_hex(
+    row_state: SelectRowState,
+    focused_bg_hex: u32,
+    hovered_bg_hex: u32,
+) -> u32 {
+    if row_state.is_focused || row_state.is_selected {
+        focused_bg_hex
+    } else if row_state.is_hovered {
+        hovered_bg_hex
+    } else {
+        0x00000000
+    }
+}
+
 pub(super) fn extract_choice_icon_hint(description: Option<&str>) -> Option<&str> {
     description.and_then(|raw| {
         raw.split(['•', '|', '\n'])
@@ -128,13 +142,14 @@
         // VIBRANCY: Optional background override when a vibrancy surface is available.
         let vibrancy_bg = get_vibrancy_background(&self.theme);
 
-        let (_main_bg, text_color, muted_color, border_color) =
+        let (_main_bg, text_color, muted_color, border_color, border_color_hex) =
             if self.design_variant == DesignVariant::Default {
                 (
                     rgb(self.theme.colors.background.main),
                     rgb(self.theme.colors.text.secondary),
                     rgb(self.theme.colors.text.muted),
                     rgb(self.theme.colors.ui.border),
+                    self.theme.colors.ui.border,
                 )
             } else {
                 (
@@ -142,6 +157,7 @@
                     rgb(colors.text_secondary),
                     rgb(colors.text_muted),
                     rgb(colors.border),
+                    colors.border,
                 )
             };
         let search_box_bg = rgb(resolve_search_box_bg_hex(
@@ -154,8 +170,9 @@
         } else {
             colors.accent
         };
-        let focused_row_bg = rgba((row_accent_color << 8) | ROW_FOCUSED_BG_ALPHA);
-        let hovered_row_bg = rgba((row_accent_color << 8) | ROW_HOVER_BG_ALPHA);
+        let focused_row_bg_hex = (row_accent_color << 8) | ROW_FOCUSED_BG_ALPHA;
+        let hovered_row_bg_hex = (row_accent_color << 8) | ROW_HOVER_BG_ALPHA;
+        let hovered_row_bg = rgba(hovered_row_bg_hex);
 
         let placeholder = self
             .placeholder
@@ -278,13 +295,11 @@
                                                     ))
                                                 },
                                             );
-                                        let row_bg = if is_focused {
-                                            focused_row_bg
-                                        } else if is_hovered {
-                                            hovered_row_bg
-                                        } else {
-                                            rgba(0x00000000)
-                                        };
+                                        let row_bg = rgba(resolve_row_bg_hex(
+                                            row_state,
+                                            focused_row_bg_hex,
+                                            hovered_row_bg_hex,
+                                        ));
                                         let hover_handler = cx.listener(
                                             move |this: &mut SelectPrompt,
                                                   hovered: &bool,
@@ -327,7 +342,7 @@
                                                 .colors(item_colors),
                                             );
 
-                                        if !is_focused {
+                                        if !is_focused && !is_selected {
                                             row = row.hover(move |s| s.bg(hovered_row_bg));
                                         }
 
@@ -367,7 +382,7 @@
             .rounded(px(12.0))
             .overflow_hidden()
             .border_1()
-            .border_color(border_color.opacity(0.25))
+            .border_color(rgba((border_color_hex << 8) | 0x40))
             .text_color(text_color)
             .key_context("select_prompt")
             .track_focus(&self.focus_handle)
@@ -376,3 +391,42 @@
             .child(choices_container)
     }
 }
+
+#[cfg(test)]
+mod tests {
+    use super::{resolve_row_bg_hex, SelectRowState};
+
+    #[test]
+    fn test_resolve_row_bg_hex_uses_focused_accent_for_selected_row() {
+        let focused_bg_hex = 0x55AAFF3A;
+        let hovered_bg_hex = 0x55AAFF26;
+
+        let selected_row = SelectRowState {
+            is_focused: false,
+            is_selected: true,
+            is_hovered: false,
+        };
+
+        assert_eq!(
+            resolve_row_bg_hex(selected_row, focused_bg_hex, hovered_bg_hex),
+            focused_bg_hex
+        );
+    }
+
+    #[test]
+    fn test_resolve_row_bg_hex_uses_hover_color_for_unselected_hovered_row() {
+        let focused_bg_hex = 0x55AAFF3A;
+        let hovered_bg_hex = 0x55AAFF26;
+
+        let hovered_row = SelectRowState {
+            is_focused: false,
+            is_selected: false,
+            is_hovered: true,
+        };
+
+        assert_eq!(
+            resolve_row_bg_hex(hovered_row, focused_bg_hex, hovered_bg_hex),
+            hovered_bg_hex
+        );
+    }
+}

file update:
diff --git a/src/prompts/select/render.rs b/src/prompts/select/render.rs
index d0e0a5485f10066de9a287b70a4c3ae891e5cd99..c26ba855b7e69a16a4d3e1b048889d3588ac5525
--- a/src/prompts/select/render.rs
+++ b/src/prompts/select/render.rs
@@ -24,6 +24,20 @@
     }
 }
 
+pub(super) fn resolve_row_bg_hex(
+    row_state: SelectRowState,
+    focused_bg_hex: u32,
+    hovered_bg_hex: u32,
+) -> u32 {
+    if row_state.is_focused || row_state.is_selected {
+        focused_bg_hex
+    } else if row_state.is_hovered {
+        hovered_bg_hex
+    } else {
+        0x00000000
+    }
+}
+
 pub(super) fn extract_choice_icon_hint(description: Option<&str>) -> Option<&str> {
     description.and_then(|raw| {
         raw.split(['•', '|', '\n'])
@@ -128,13 +142,14 @@
         // VIBRANCY: Optional background override when a vibrancy surface is available.
         let vibrancy_bg = get_vibrancy_background(&self.theme);
 
-        let (_main_bg, text_color, muted_color, border_color) =
+        let (_main_bg, text_color, muted_color, border_color, border_color_hex) =
             if self.design_variant == DesignVariant::Default {
                 (
                     rgb(self.theme.colors.background.main),
                     rgb(self.theme.colors.text.secondary),
                     rgb(self.theme.colors.text.muted),
                     rgb(self.theme.colors.ui.border),
+                    self.theme.colors.ui.border,
                 )
             } else {
                 (
@@ -142,6 +157,7 @@
                     rgb(colors.text_secondary),
                     rgb(colors.text_muted),
                     rgb(colors.border),
+                    colors.border,
                 )
             };
         let search_box_bg = rgb(resolve_search_box_bg_hex(
@@ -154,8 +170,9 @@
         } else {
             colors.accent
         };
-        let focused_row_bg = rgba((row_accent_color << 8) | ROW_FOCUSED_BG_ALPHA);
-        let hovered_row_bg = rgba((row_accent_color << 8) | ROW_HOVER_BG_ALPHA);
+        let focused_row_bg_hex = (row_accent_color << 8) | ROW_FOCUSED_BG_ALPHA;
+        let hovered_row_bg_hex = (row_accent_color << 8) | ROW_HOVER_BG_ALPHA;
+        let hovered_row_bg = rgba(hovered_row_bg_hex);
 
         let placeholder = self
             .placeholder
@@ -278,13 +295,11 @@
                                                     ))
                                                 },
                                             );
-                                        let row_bg = if is_focused {
-                                            focused_row_bg
-                                        } else if is_hovered {
-                                            hovered_row_bg
-                                        } else {
-                                            rgba(0x00000000)
-                                        };
+                                        let row_bg = rgba(resolve_row_bg_hex(
+                                            row_state,
+                                            focused_row_bg_hex,
+                                            hovered_row_bg_hex,
+                                        ));
                                         let hover_handler = cx.listener(
                                             move |this: &mut SelectPrompt,
                                                   hovered: &bool,
@@ -327,7 +342,7 @@
                                                 .colors(item_colors),
                                             );
 
-                                        if !is_focused {
+                                        if !is_focused && !is_selected {
                                             row = row.hover(move |s| s.bg(hovered_row_bg));
                                         }
 
@@ -367,7 +382,7 @@
             .rounded(px(12.0))
             .overflow_hidden()
             .border_1()
-            .border_color(border_color.opacity(0.25))
+            .border_color(rgba((border_color_hex << 8) | 0x40))
             .text_color(text_color)
             .key_context("select_prompt")
             .track_focus(&self.focus_handle)
@@ -376,3 +391,42 @@
             .child(choices_container)
     }
 }
+
+#[cfg(test)]
+mod tests {
+    use super::{resolve_row_bg_hex, SelectRowState};
+
+    #[test]
+    fn test_resolve_row_bg_hex_uses_focused_accent_for_selected_row() {
+        let focused_bg_hex = 0x55AAFF3A;
+        let hovered_bg_hex = 0x55AAFF26;
+
+        let selected_row = SelectRowState {
+            is_focused: false,
+            is_selected: true,
+            is_hovered: false,
+        };
+
+        assert_eq!(
+            resolve_row_bg_hex(selected_row, focused_bg_hex, hovered_bg_hex),
+            focused_bg_hex
+        );
+    }
+
+    #[test]
+    fn test_resolve_row_bg_hex_uses_hover_color_for_unselected_hovered_row() {
+        let focused_bg_hex = 0x55AAFF3A;
+        let hovered_bg_hex = 0x55AAFF26;
+
+        let hovered_row = SelectRowState {
+            is_focused: false,
+            is_selected: false,
+            is_hovered: true,
+        };
+
+        assert_eq!(
+            resolve_row_bg_hex(hovered_row, focused_bg_hex, hovered_bg_hex),
+            hovered_bg_hex
+        );
+    }
+}

 exited 101 in 46.22s:
   Compiling script-kit-gpui v0.1.0 (/Users/johnlindquist/dev/script-kit-gpui)
    Checking tree-sitter-highlight v0.25.10
error[E0761]: file for module `tests` found at both "src/protocol/message/tests.rs" and "src/protocol/message/tests/mod.rs"
  --> src/protocol/message/mod.rs:87:1
   |
87 | mod tests;
   | ^^^^^^^^^^
   |
   = help: delete or rename one of them to remove the ambiguity

error[E0761]: file for module `tests` found at both "src/designs/core/tests.rs" and "src/designs/core/tests/mod.rs"
 --> src/designs/core/part_04.rs:2:1
  |
2 | mod tests;
  | ^^^^^^^^^^
  |
  = help: delete or rename one of them to remove the ambiguity

error[E0432]: unresolved imports `self::search::fuzzy_search_unified_with_builtins`, `self::search::fuzzy_search_unified_with_windows`
  --> src/scripts/mod.rs:54:5

thinking
**Monitoring test session lock**
file update:
diff --git a/src/prompts/select/render.rs b/src/prompts/select/render.rs
index d0e0a5485f10066de9a287b70a4c3ae891e5cd99..c26ba855b7e69a16a4d3e1b048889d3588ac5525
--- a/src/prompts/select/render.rs
+++ b/src/prompts/select/render.rs
@@ -24,6 +24,20 @@
     }
 }
 
+pub(super) fn resolve_row_bg_hex(
+    row_state: SelectRowState,
+    focused_bg_hex: u32,
+    hovered_bg_hex: u32,
+) -> u32 {
+    if row_state.is_focused || row_state.is_selected {
+        focused_bg_hex
+    } else if row_state.is_hovered {
+        hovered_bg_hex
+    } else {
+        0x00000000
+    }
+}
+
 pub(super) fn extract_choice_icon_hint(description: Option<&str>) -> Option<&str> {
     description.and_then(|raw| {
         raw.split(['•', '|', '\n'])
@@ -128,13 +142,14 @@
         // VIBRANCY: Optional background override when a vibrancy surface is available.
         let vibrancy_bg = get_vibrancy_background(&self.theme);
 
-        let (_main_bg, text_color, muted_color, border_color) =
+        let (_main_bg, text_color, muted_color, border_color, border_color_hex) =
             if self.design_variant == DesignVariant::Default {
                 (
                     rgb(self.theme.colors.background.main),
                     rgb(self.theme.colors.text.secondary),
                     rgb(self.theme.colors.text.muted),
                     rgb(self.theme.colors.ui.border),
+                    self.theme.colors.ui.border,
                 )
             } else {
                 (
@@ -142,6 +157,7 @@
                     rgb(colors.text_secondary),
                     rgb(colors.text_muted),
                     rgb(colors.border),
+                    colors.border,
                 )
             };
         let search_box_bg = rgb(resolve_search_box_bg_hex(
@@ -154,8 +170,9 @@
         } else {
             colors.accent
         };
-        let focused_row_bg = rgba((row_accent_color << 8) | ROW_FOCUSED_BG_ALPHA);
-        let hovered_row_bg = rgba((row_accent_color << 8) | ROW_HOVER_BG_ALPHA);
+        let focused_row_bg_hex = (row_accent_color << 8) | ROW_FOCUSED_BG_ALPHA;
+        let hovered_row_bg_hex = (row_accent_color << 8) | ROW_HOVER_BG_ALPHA;
+        let hovered_row_bg = rgba(hovered_row_bg_hex);
 
         let placeholder = self
             .placeholder
@@ -278,13 +295,11 @@
                                                     ))
                                                 },
                                             );
-                                        let row_bg = if is_focused {
-                                            focused_row_bg
-                                        } else if is_hovered {
-                                            hovered_row_bg
-                                        } else {
-                                            rgba(0x00000000)
-                                        };
+                                        let row_bg = rgba(resolve_row_bg_hex(
+                                            row_state,
+                                            focused_row_bg_hex,
+                                            hovered_row_bg_hex,
+                                        ));
                                         let hover_handler = cx.listener(
                                             move |this: &mut SelectPrompt,
                                                   hovered: &bool,
@@ -327,7 +342,7 @@
                                                 .colors(item_colors),
                                             );
 
-                                        if !is_focused {
+                                        if !is_focused && !is_selected {
                                             row = row.hover(move |s| s.bg(hovered_row_bg));
                                         }
 
@@ -367,7 +382,7 @@
             .rounded(px(12.0))
             .overflow_hidden()
             .border_1()
-            .border_color(border_color.opacity(0.25))
+            .border_color(rgba((border_color_hex << 8) | 0x40))
             .text_color(text_color)
             .key_context("select_prompt")
             .track_focus(&self.focus_handle)
@@ -376,3 +391,42 @@
             .child(choices_container)
     }
 }
+
+#[cfg(test)]
+mod tests {
+    use super::{resolve_row_bg_hex, SelectRowState};
+
+    #[test]
+    fn test_resolve_row_bg_hex_uses_focused_accent_for_selected_row() {
+        let focused_bg_hex = 0x55AAFF3A;
+        let hovered_bg_hex = 0x55AAFF26;
+
+        let selected_row = SelectRowState {
+            is_focused: false,
+            is_selected: true,
+            is_hovered: false,
+        };
+
+        assert_eq!(
+            resolve_row_bg_hex(selected_row, focused_bg_hex, hovered_bg_hex),
+            focused_bg_hex
+        );
+    }
+
+    #[test]
+    fn test_resolve_row_bg_hex_uses_hover_color_for_unselected_hovered_row() {
+        let focused_bg_hex = 0x55AAFF3A;
+        let hovered_bg_hex = 0x55AAFF26;
+
+        let hovered_row = SelectRowState {
+            is_focused: false,
+            is_selected: false,
+            is_hovered: true,
+        };
+
+        assert_eq!(
+            resolve_row_bg_hex(hovered_row, focused_bg_hex, hovered_bg_hex),
+            hovered_bg_hex
+        );
+    }
+}


thinking
**Waiting for compilation completion**
file update:
diff --git a/src/prompts/select/render.rs b/src/prompts/select/render.rs
index d0e0a5485f10066de9a287b70a4c3ae891e5cd99..c26ba855b7e69a16a4d3e1b048889d3588ac5525
--- a/src/prompts/select/render.rs
+++ b/src/prompts/select/render.rs
@@ -24,6 +24,20 @@
     }
 }
 
+pub(super) fn resolve_row_bg_hex(
+    row_state: SelectRowState,
+    focused_bg_hex: u32,
+    hovered_bg_hex: u32,
+) -> u32 {
+    if row_state.is_focused || row_state.is_selected {
+        focused_bg_hex
+    } else if row_state.is_hovered {
+        hovered_bg_hex
+    } else {
+        0x00000000
+    }
+}
+
 pub(super) fn extract_choice_icon_hint(description: Option<&str>) -> Option<&str> {
     description.and_then(|raw| {
         raw.split(['•', '|', '\n'])
@@ -128,13 +142,14 @@
         // VIBRANCY: Optional background override when a vibrancy surface is available.
         let vibrancy_bg = get_vibrancy_background(&self.theme);
 
-        let (_main_bg, text_color, muted_color, border_color) =
+        let (_main_bg, text_color, muted_color, border_color, border_color_hex) =
             if self.design_variant == DesignVariant::Default {
                 (
                     rgb(self.theme.colors.background.main),
                     rgb(self.theme.colors.text.secondary),
                     rgb(self.theme.colors.text.muted),
                     rgb(self.theme.colors.ui.border),
+                    self.theme.colors.ui.border,
                 )
             } else {
                 (
@@ -142,6 +157,7 @@
                     rgb(colors.text_secondary),
                     rgb(colors.text_muted),
                     rgb(colors.border),
+                    colors.border,
                 )
             };
         let search_box_bg = rgb(resolve_search_box_bg_hex(
@@ -154,8 +170,9 @@
         } else {
             colors.accent
         };
-        let focused_row_bg = rgba((row_accent_color << 8) | ROW_FOCUSED_BG_ALPHA);
-        let hovered_row_bg = rgba((row_accent_color << 8) | ROW_HOVER_BG_ALPHA);
+        let focused_row_bg_hex = (row_accent_color << 8) | ROW_FOCUSED_BG_ALPHA;
+        let hovered_row_bg_hex = (row_accent_color << 8) | ROW_HOVER_BG_ALPHA;
+        let hovered_row_bg = rgba(hovered_row_bg_hex);
 
         let placeholder = self
             .placeholder
@@ -278,13 +295,11 @@
                                                     ))
                                                 },
                                             );
-                                        let row_bg = if is_focused {
-                                            focused_row_bg
-                                        } else if is_hovered {
-                                            hovered_row_bg
-                                        } else {
-                                            rgba(0x00000000)
-                                        };
+                                        let row_bg = rgba(resolve_row_bg_hex(
+                                            row_state,
+                                            focused_row_bg_hex,
+                                            hovered_row_bg_hex,
+                                        ));
                                         let hover_handler = cx.listener(
                                             move |this: &mut SelectPrompt,
                                                   hovered: &bool,
@@ -327,7 +342,7 @@
                                                 .colors(item_colors),
                                             );
 
-                                        if !is_focused {
+                                        if !is_focused && !is_selected {
                                             row = row.hover(move |s| s.bg(hovered_row_bg));
                                         }
 
@@ -367,7 +382,7 @@
             .rounded(px(12.0))
             .overflow_hidden()
             .border_1()
-            .border_color(border_color.opacity(0.25))
+            .border_color(rgba((border_color_hex << 8) | 0x40))
             .text_color(text_color)
             .key_context("select_prompt")
             .track_focus(&self.focus_handle)
@@ -376,3 +391,42 @@
             .child(choices_container)
     }
 }
+
+#[cfg(test)]
+mod tests {
+    use super::{resolve_row_bg_hex, SelectRowState};
+
+    #[test]
+    fn test_resolve_row_bg_hex_uses_focused_accent_for_selected_row() {
+        let focused_bg_hex = 0x55AAFF3A;
+        let hovered_bg_hex = 0x55AAFF26;
+
+        let selected_row = SelectRowState {
+            is_focused: false,
+            is_selected: true,
+            is_hovered: false,
+        };
+
+        assert_eq!(
+            resolve_row_bg_hex(selected_row, focused_bg_hex, hovered_bg_hex),
+            focused_bg_hex
+        );
+    }
+
+    #[test]
+    fn test_resolve_row_bg_hex_uses_hover_color_for_unselected_hovered_row() {
+        let focused_bg_hex = 0x55AAFF3A;
+        let hovered_bg_hex = 0x55AAFF26;
+
+        let hovered_row = SelectRowState {
+            is_focused: false,
+            is_selected: false,
+            is_hovered: true,
+        };
+
+        assert_eq!(
+            resolve_row_bg_hex(hovered_row, focused_bg_hex, hovered_bg_hex),
+            hovered_bg_hex
+        );
+    }
+}

codex
I’m still waiting on the scoped `prompts::select` test command; it’s compiling through dependencies and I’ll report the exact pass/fail once it exits.

thinking
**Adjusting polling interval**
file update:
diff --git a/src/prompts/select/render.rs b/src/prompts/select/render.rs
index d0e0a5485f10066de9a287b70a4c3ae891e5cd99..c26ba855b7e69a16a4d3e1b048889d3588ac5525
--- a/src/prompts/select/render.rs
+++ b/src/prompts/select/render.rs
@@ -24,6 +24,20 @@
     }
 }
 
+pub(super) fn resolve_row_bg_hex(
+    row_state: SelectRowState,
+    focused_bg_hex: u32,
+    hovered_bg_hex: u32,
+) -> u32 {
+    if row_state.is_focused || row_state.is_selected {
+        focused_bg_hex
+    } else if row_state.is_hovered {
+        hovered_bg_hex
+    } else {
+        0x00000000
+    }
+}
+
 pub(super) fn extract_choice_icon_hint(description: Option<&str>) -> Option<&str> {
     description.and_then(|raw| {
         raw.split(['•', '|', '\n'])
@@ -128,13 +142,14 @@
         // VIBRANCY: Optional background override when a vibrancy surface is available.
         let vibrancy_bg = get_vibrancy_background(&self.theme);
 
-        let (_main_bg, text_color, muted_color, border_color) =
+        let (_main_bg, text_color, muted_color, border_color, border_color_hex) =
             if self.design_variant == DesignVariant::Default {
                 (
                     rgb(self.theme.colors.background.main),
                     rgb(self.theme.colors.text.secondary),
                     rgb(self.theme.colors.text.muted),
                     rgb(self.theme.colors.ui.border),
+                    self.theme.colors.ui.border,
                 )
             } else {
                 (
@@ -142,6 +157,7 @@
                     rgb(colors.text_secondary),
                     rgb(colors.text_muted),
                     rgb(colors.border),
+                    colors.border,
                 )
             };
         let search_box_bg = rgb(resolve_search_box_bg_hex(
@@ -154,8 +170,9 @@
         } else {
             colors.accent
         };
-        let focused_row_bg = rgba((row_accent_color << 8) | ROW_FOCUSED_BG_ALPHA);
-        let hovered_row_bg = rgba((row_accent_color << 8) | ROW_HOVER_BG_ALPHA);
+        let focused_row_bg_hex = (row_accent_color << 8) | ROW_FOCUSED_BG_ALPHA;
+        let hovered_row_bg_hex = (row_accent_color << 8) | ROW_HOVER_BG_ALPHA;
+        let hovered_row_bg = rgba(hovered_row_bg_hex);
 
         let placeholder = self
             .placeholder
@@ -278,13 +295,11 @@
                                                     ))
                                                 },
                                             );
-                                        let row_bg = if is_focused {
-                                            focused_row_bg
-                                        } else if is_hovered {
-                                            hovered_row_bg
-                                        } else {
-                                            rgba(0x00000000)
-                                        };
+                                        let row_bg = rgba(resolve_row_bg_hex(
+                                            row_state,
+                                            focused_row_bg_hex,
+                                            hovered_row_bg_hex,
+                                        ));
                                         let hover_handler = cx.listener(
                                             move |this: &mut SelectPrompt,
                                                   hovered: &bool,
@@ -327,7 +342,7 @@
                                                 .colors(item_colors),
                                             );
 
-                                        if !is_focused {
+                                        if !is_focused && !is_selected {
                                             row = row.hover(move |s| s.bg(hovered_row_bg));
                                         }
 
@@ -367,7 +382,7 @@
             .rounded(px(12.0))
             .overflow_hidden()
             .border_1()
-            .border_color(border_color.opacity(0.25))
+            .border_color(rgba((border_color_hex << 8) | 0x40))
             .text_color(text_color)
             .key_context("select_prompt")
             .track_focus(&self.focus_handle)
@@ -376,3 +391,42 @@
             .child(choices_container)
     }
 }
+
+#[cfg(test)]
+mod tests {
+    use super::{resolve_row_bg_hex, SelectRowState};
+
+    #[test]
+    fn test_resolve_row_bg_hex_uses_focused_accent_for_selected_row() {
+        let focused_bg_hex = 0x55AAFF3A;
+        let hovered_bg_hex = 0x55AAFF26;
+
+        let selected_row = SelectRowState {
+            is_focused: false,
+            is_selected: true,
+            is_hovered: false,
+        };
+
+        assert_eq!(
+            resolve_row_bg_hex(selected_row, focused_bg_hex, hovered_bg_hex),
+            focused_bg_hex
+        );
+    }
+
+    #[test]
+    fn test_resolve_row_bg_hex_uses_hover_color_for_unselected_hovered_row() {
+        let focused_bg_hex = 0x55AAFF3A;
+        let hovered_bg_hex = 0x55AAFF26;
+
+        let hovered_row = SelectRowState {
+            is_focused: false,
+            is_selected: false,
+            is_hovered: true,
+        };
+
+        assert_eq!(
+            resolve_row_bg_hex(hovered_row, focused_bg_hex, hovered_bg_hex),
+            hovered_bg_hex
+        );
+    }
+}


thinking
**Monitoring long compilation process**
file update:
diff --git a/src/prompts/select/render.rs b/src/prompts/select/render.rs
index d0e0a5485f10066de9a287b70a4c3ae891e5cd99..c26ba855b7e69a16a4d3e1b048889d3588ac5525
--- a/src/prompts/select/render.rs
+++ b/src/prompts/select/render.rs
@@ -24,6 +24,20 @@
     }
 }
 
+pub(super) fn resolve_row_bg_hex(
+    row_state: SelectRowState,
+    focused_bg_hex: u32,
+    hovered_bg_hex: u32,
+) -> u32 {
+    if row_state.is_focused || row_state.is_selected {
+        focused_bg_hex
+    } else if row_state.is_hovered {
+        hovered_bg_hex
+    } else {
+        0x00000000
+    }
+}
+
 pub(super) fn extract_choice_icon_hint(description: Option<&str>) -> Option<&str> {
     description.and_then(|raw| {
         raw.split(['•', '|', '\n'])
@@ -128,13 +142,14 @@
         // VIBRANCY: Optional background override when a vibrancy surface is available.
         let vibrancy_bg = get_vibrancy_background(&self.theme);
 
-        let (_main_bg, text_color, muted_color, border_color) =
+        let (_main_bg, text_color, muted_color, border_color, border_color_hex) =
             if self.design_variant == DesignVariant::Default {
                 (
                     rgb(self.theme.colors.background.main),
                     rgb(self.theme.colors.text.secondary),
                     rgb(self.theme.colors.text.muted),
                     rgb(self.theme.colors.ui.border),
+                    self.theme.colors.ui.border,
                 )
             } else {
                 (
@@ -142,6 +157,7 @@
                     rgb(colors.text_secondary),
                     rgb(colors.text_muted),
                     rgb(colors.border),
+                    colors.border,
                 )
             };
         let search_box_bg = rgb(resolve_search_box_bg_hex(
@@ -154,8 +170,9 @@
         } else {
             colors.accent
         };
-        let focused_row_bg = rgba((row_accent_color << 8) | ROW_FOCUSED_BG_ALPHA);
-        let hovered_row_bg = rgba((row_accent_color << 8) | ROW_HOVER_BG_ALPHA);
+        let focused_row_bg_hex = (row_accent_color << 8) | ROW_FOCUSED_BG_ALPHA;
+        let hovered_row_bg_hex = (row_accent_color << 8) | ROW_HOVER_BG_ALPHA;
+        let hovered_row_bg = rgba(hovered_row_bg_hex);
 
         let placeholder = self
             .placeholder
@@ -278,13 +295,11 @@
                                                     ))
                                                 },
                                             );
-                                        let row_bg = if is_focused {
-                                            focused_row_bg
-                                        } else if is_hovered {
-                                            hovered_row_bg
-                                        } else {
-                                            rgba(0x00000000)
-                                        };
+                                        let row_bg = rgba(resolve_row_bg_hex(
+                                            row_state,
+                                            focused_row_bg_hex,
+                                            hovered_row_bg_hex,
+                                        ));
                                         let hover_handler = cx.listener(
                                             move |this: &mut SelectPrompt,
                                                   hovered: &bool,
@@ -327,7 +342,7 @@
                                                 .colors(item_colors),
                                             );
 
-                                        if !is_focused {
+                                        if !is_focused && !is_selected {
                                             row = row.hover(move |s| s.bg(hovered_row_bg));
                                         }
 
@@ -367,7 +382,7 @@
             .rounded(px(12.0))
             .overflow_hidden()
             .border_1()
-            .border_color(border_color.opacity(0.25))
+            .border_color(rgba((border_color_hex << 8) | 0x40))
             .text_color(text_color)
             .key_context("select_prompt")
             .track_focus(&self.focus_handle)
@@ -376,3 +391,42 @@
             .child(choices_container)
     }
 }
+
+#[cfg(test)]
+mod tests {
+    use super::{resolve_row_bg_hex, SelectRowState};
+
+    #[test]
+    fn test_resolve_row_bg_hex_uses_focused_accent_for_selected_row() {
+        let focused_bg_hex = 0x55AAFF3A;
+        let hovered_bg_hex = 0x55AAFF26;
+
+        let selected_row = SelectRowState {
+            is_focused: false,
+            is_selected: true,
+            is_hovered: false,
+        };
+
+        assert_eq!(
+            resolve_row_bg_hex(selected_row, focused_bg_hex, hovered_bg_hex),
+            focused_bg_hex
+        );
+    }
+
+    #[test]
+    fn test_resolve_row_bg_hex_uses_hover_color_for_unselected_hovered_row() {
+        let focused_bg_hex = 0x55AAFF3A;
+        let hovered_bg_hex = 0x55AAFF26;
+
+        let hovered_row = SelectRowState {
+            is_focused: false,
+            is_selected: false,
+            is_hovered: true,
+        };
+
+        assert_eq!(
+            resolve_row_bg_hex(hovered_row, focused_bg_hex, hovered_bg_hex),
+            hovered_bg_hex
+        );
+    }
+}


thinking
**Preparing to compile script-kit**
file update:
diff --git a/src/prompts/select/render.rs b/src/prompts/select/render.rs
index d0e0a5485f10066de9a287b70a4c3ae891e5cd99..c26ba855b7e69a16a4d3e1b048889d3588ac5525
--- a/src/prompts/select/render.rs
+++ b/src/prompts/select/render.rs
@@ -24,6 +24,20 @@
     }
 }
 
+pub(super) fn resolve_row_bg_hex(
+    row_state: SelectRowState,
+    focused_bg_hex: u32,
+    hovered_bg_hex: u32,
+) -> u32 {
+    if row_state.is_focused || row_state.is_selected {
+        focused_bg_hex
+    } else if row_state.is_hovered {
+        hovered_bg_hex
+    } else {
+        0x00000000
+    }
+}
+
 pub(super) fn extract_choice_icon_hint(description: Option<&str>) -> Option<&str> {
     description.and_then(|raw| {
         raw.split(['•', '|', '\n'])
@@ -128,13 +142,14 @@
         // VIBRANCY: Optional background override when a vibrancy surface is available.
         let vibrancy_bg = get_vibrancy_background(&self.theme);
 
-        let (_main_bg, text_color, muted_color, border_color) =
+        let (_main_bg, text_color, muted_color, border_color, border_color_hex) =
             if self.design_variant == DesignVariant::Default {
                 (
                     rgb(self.theme.colors.background.main),
                     rgb(self.theme.colors.text.secondary),
                     rgb(self.theme.colors.text.muted),
                     rgb(self.theme.colors.ui.border),
+                    self.theme.colors.ui.border,
                 )
             } else {
                 (
@@ -142,6 +157,7 @@
                     rgb(colors.text_secondary),
                     rgb(colors.text_muted),
                     rgb(colors.border),
+                    colors.border,
                 )
             };
         let search_box_bg = rgb(resolve_search_box_bg_hex(
@@ -154,8 +170,9 @@
         } else {
             colors.accent
         };
-        let focused_row_bg = rgba((row_accent_color << 8) | ROW_FOCUSED_BG_ALPHA);
-        let hovered_row_bg = rgba((row_accent_color << 8) | ROW_HOVER_BG_ALPHA);
+        let focused_row_bg_hex = (row_accent_color << 8) | ROW_FOCUSED_BG_ALPHA;
+        let hovered_row_bg_hex = (row_accent_color << 8) | ROW_HOVER_BG_ALPHA;
+        let hovered_row_bg = rgba(hovered_row_bg_hex);
 
         let placeholder = self
             .placeholder
@@ -278,13 +295,11 @@
                                                     ))
                                                 },
                                             );
-                                        let row_bg = if is_focused {
-                                            focused_row_bg
-                                        } else if is_hovered {
-                                            hovered_row_bg
-                                        } else {
-                                            rgba(0x00000000)
-                                        };
+                                        let row_bg = rgba(resolve_row_bg_hex(
+                                            row_state,
+                                            focused_row_bg_hex,
+                                            hovered_row_bg_hex,
+                                        ));
                                         let hover_handler = cx.listener(
                                             move |this: &mut SelectPrompt,
                                                   hovered: &bool,
@@ -327,7 +342,7 @@
                                                 .colors(item_colors),
                                             );
 
-                                        if !is_focused {
+                                        if !is_focused && !is_selected {
                                             row = row.hover(move |s| s.bg(hovered_row_bg));
                                         }
 
@@ -367,7 +382,7 @@
             .rounded(px(12.0))
             .overflow_hidden()
             .border_1()
-            .border_color(border_color.opacity(0.25))
+            .border_color(rgba((border_color_hex << 8) | 0x40))
             .text_color(text_color)
             .key_context("select_prompt")
             .track_focus(&self.focus_handle)
@@ -376,3 +391,42 @@
             .child(choices_container)
     }
 }
+
+#[cfg(test)]
+mod tests {
+    use super::{resolve_row_bg_hex, SelectRowState};
+
+    #[test]
+    fn test_resolve_row_bg_hex_uses_focused_accent_for_selected_row() {
+        let focused_bg_hex = 0x55AAFF3A;
+        let hovered_bg_hex = 0x55AAFF26;
+
+        let selected_row = SelectRowState {
+            is_focused: false,
+            is_selected: true,
+            is_hovered: false,
+        };
+
+        assert_eq!(
+            resolve_row_bg_hex(selected_row, focused_bg_hex, hovered_bg_hex),
+            focused_bg_hex
+        );
+    }
+
+    #[test]
+    fn test_resolve_row_bg_hex_uses_hover_color_for_unselected_hovered_row() {
+        let focused_bg_hex = 0x55AAFF3A;
+        let hovered_bg_hex = 0x55AAFF26;
+
+        let hovered_row = SelectRowState {
+            is_focused: false,
+            is_selected: false,
+            is_hovered: true,
+        };
+
+        assert_eq!(
+            resolve_row_bg_hex(hovered_row, focused_bg_hex, hovered_bg_hex),
+            hovered_bg_hex
+        );
+    }
+}


thinking
**Preparing to compile script-kit**
codex
The scoped test build is almost finished; once this last stage exits I’ll summarize the exact failure set and whether it touches `select/render.rs`.
file update:
diff --git a/src/prompts/select/render.rs b/src/prompts/select/render.rs
index d0e0a5485f10066de9a287b70a4c3ae891e5cd99..c26ba855b7e69a16a4d3e1b048889d3588ac5525
--- a/src/prompts/select/render.rs
+++ b/src/prompts/select/render.rs
@@ -24,6 +24,20 @@
     }
 }
 
+pub(super) fn resolve_row_bg_hex(
+    row_state: SelectRowState,
+    focused_bg_hex: u32,
+    hovered_bg_hex: u32,
+) -> u32 {
+    if row_state.is_focused || row_state.is_selected {
+        focused_bg_hex
+    } else if row_state.is_hovered {
+        hovered_bg_hex
+    } else {
+        0x00000000
+    }
+}
+
 pub(super) fn extract_choice_icon_hint(description: Option<&str>) -> Option<&str> {
     description.and_then(|raw| {
         raw.split(['•', '|', '\n'])
@@ -128,13 +142,14 @@
         // VIBRANCY: Optional background override when a vibrancy surface is available.
         let vibrancy_bg = get_vibrancy_background(&self.theme);
 
-        let (_main_bg, text_color, muted_color, border_color) =
+        let (_main_bg, text_color, muted_color, border_color, border_color_hex) =
             if self.design_variant == DesignVariant::Default {
                 (
                     rgb(self.theme.colors.background.main),
                     rgb(self.theme.colors.text.secondary),
                     rgb(self.theme.colors.text.muted),
                     rgb(self.theme.colors.ui.border),
+                    self.theme.colors.ui.border,
                 )
             } else {
                 (
@@ -142,6 +157,7 @@
                     rgb(colors.text_secondary),
                     rgb(colors.text_muted),
                     rgb(colors.border),
+                    colors.border,
                 )
             };
         let search_box_bg = rgb(resolve_search_box_bg_hex(
@@ -154,8 +170,9 @@
         } else {
             colors.accent
         };
-        let focused_row_bg = rgba((row_accent_color << 8) | ROW_FOCUSED_BG_ALPHA);
-        let hovered_row_bg = rgba((row_accent_color << 8) | ROW_HOVER_BG_ALPHA);
+        let focused_row_bg_hex = (row_accent_color << 8) | ROW_FOCUSED_BG_ALPHA;
+        let hovered_row_bg_hex = (row_accent_color << 8) | ROW_HOVER_BG_ALPHA;
+        let hovered_row_bg = rgba(hovered_row_bg_hex);
 
         let placeholder = self
             .placeholder
@@ -278,13 +295,11 @@
                                                     ))
                                                 },
                                             );
-                                        let row_bg = if is_focused {
-                                            focused_row_bg
-                                        } else if is_hovered {
-                                            hovered_row_bg
-                                        } else {
-                                            rgba(0x00000000)
-                                        };
+                                        let row_bg = rgba(resolve_row_bg_hex(
+                                            row_state,
+                                            focused_row_bg_hex,
+                                            hovered_row_bg_hex,
+                                        ));
                                         let hover_handler = cx.listener(
                                             move |this: &mut SelectPrompt,
                                                   hovered: &bool,
@@ -327,7 +342,7 @@
                                                 .colors(item_colors),
                                             );
 
-                                        if !is_focused {
+                                        if !is_focused && !is_selected {
                                             row = row.hover(move |s| s.bg(hovered_row_bg));
                                         }
 
@@ -367,7 +382,7 @@
             .rounded(px(12.0))
             .overflow_hidden()
             .border_1()
-            .border_color(border_color.opacity(0.25))
+            .border_color(rgba((border_color_hex << 8) | 0x40))
             .text_color(text_color)
             .key_context("select_prompt")
             .track_focus(&self.focus_handle)
@@ -376,3 +391,42 @@
             .child(choices_container)
     }
 }
+
+#[cfg(test)]
+mod tests {
+    use super::{resolve_row_bg_hex, SelectRowState};
+
+    #[test]
+    fn test_resolve_row_bg_hex_uses_focused_accent_for_selected_row() {
+        let focused_bg_hex = 0x55AAFF3A;
+        let hovered_bg_hex = 0x55AAFF26;
+
+        let selected_row = SelectRowState {
+            is_focused: false,
+            is_selected: true,
+            is_hovered: false,
+        };
+
+        assert_eq!(
+            resolve_row_bg_hex(selected_row, focused_bg_hex, hovered_bg_hex),
+            focused_bg_hex
+        );
+    }
+
+    #[test]
+    fn test_resolve_row_bg_hex_uses_hover_color_for_unselected_hovered_row() {
+        let focused_bg_hex = 0x55AAFF3A;
+        let hovered_bg_hex = 0x55AAFF26;
+
+        let hovered_row = SelectRowState {
+            is_focused: false,
+            is_selected: false,
+            is_hovered: true,
+        };
+
+        assert_eq!(
+            resolve_row_bg_hex(hovered_row, focused_bg_hex, hovered_bg_hex),
+            hovered_bg_hex
+        );
+    }
+}

file update:
diff --git a/src/prompts/select/render.rs b/src/prompts/select/render.rs
index d0e0a5485f10066de9a287b70a4c3ae891e5cd99..c26ba855b7e69a16a4d3e1b048889d3588ac5525
--- a/src/prompts/select/render.rs
+++ b/src/prompts/select/render.rs
@@ -24,6 +24,20 @@
     }
 }
 
+pub(super) fn resolve_row_bg_hex(
+    row_state: SelectRowState,
+    focused_bg_hex: u32,
+    hovered_bg_hex: u32,
+) -> u32 {
+    if row_state.is_focused || row_state.is_selected {
+        focused_bg_hex
+    } else if row_state.is_hovered {
+        hovered_bg_hex
+    } else {
+        0x00000000
+    }
+}
+
 pub(super) fn extract_choice_icon_hint(description: Option<&str>) -> Option<&str> {
     description.and_then(|raw| {
         raw.split(['•', '|', '\n'])
@@ -128,13 +142,14 @@
         // VIBRANCY: Optional background override when a vibrancy surface is available.
         let vibrancy_bg = get_vibrancy_background(&self.theme);
 
-        let (_main_bg, text_color, muted_color, border_color) =
+        let (_main_bg, text_color, muted_color, border_color, border_color_hex) =
             if self.design_variant == DesignVariant::Default {
                 (
                     rgb(self.theme.colors.background.main),
                     rgb(self.theme.colors.text.secondary),
                     rgb(self.theme.colors.text.muted),
                     rgb(self.theme.colors.ui.border),
+                    self.theme.colors.ui.border,
                 )
             } else {
                 (
@@ -142,6 +157,7 @@
                     rgb(colors.text_secondary),
                     rgb(colors.text_muted),
                     rgb(colors.border),
+                    colors.border,
                 )
             };
         let search_box_bg = rgb(resolve_search_box_bg_hex(
@@ -154,8 +170,9 @@
         } else {
             colors.accent
         };
-        let focused_row_bg = rgba((row_accent_color << 8) | ROW_FOCUSED_BG_ALPHA);
-        let hovered_row_bg = rgba((row_accent_color << 8) | ROW_HOVER_BG_ALPHA);
+        let focused_row_bg_hex = (row_accent_color << 8) | ROW_FOCUSED_BG_ALPHA;
+        let hovered_row_bg_hex = (row_accent_color << 8) | ROW_HOVER_BG_ALPHA;
+        let hovered_row_bg = rgba(hovered_row_bg_hex);
 
         let placeholder = self
             .placeholder
@@ -278,13 +295,11 @@
                                                     ))
                                                 },
                                             );
-                                        let row_bg = if is_focused {
-                                            focused_row_bg
-                                        } else if is_hovered {
-                                            hovered_row_bg
-                                        } else {
-                                            rgba(0x00000000)
-                                        };
+                                        let row_bg = rgba(resolve_row_bg_hex(
+                                            row_state,
+                                            focused_row_bg_hex,
+                                            hovered_row_bg_hex,
+                                        ));
                                         let hover_handler = cx.listener(
                                             move |this: &mut SelectPrompt,
                                                   hovered: &bool,
@@ -327,7 +342,7 @@
                                                 .colors(item_colors),
                                             );
 
-                                        if !is_focused {
+                                        if !is_focused && !is_selected {
                                             row = row.hover(move |s| s.bg(hovered_row_bg));
                                         }
 
@@ -367,7 +382,7 @@
             .rounded(px(12.0))
             .overflow_hidden()
             .border_1()
-            .border_color(border_color.opacity(0.25))
+            .border_color(rgba((border_color_hex << 8) | 0x40))
             .text_color(text_color)
             .key_context("select_prompt")
             .track_focus(&self.focus_handle)
@@ -376,3 +391,42 @@
             .child(choices_container)
     }
 }
+
+#[cfg(test)]
+mod tests {
+    use super::{resolve_row_bg_hex, SelectRowState};
+
+    #[test]
+    fn test_resolve_row_bg_hex_uses_focused_accent_for_selected_row() {
+        let focused_bg_hex = 0x55AAFF3A;
+        let hovered_bg_hex = 0x55AAFF26;
+
+        let selected_row = SelectRowState {
+            is_focused: false,
+            is_selected: true,
+            is_hovered: false,
+        };
+
+        assert_eq!(
+            resolve_row_bg_hex(selected_row, focused_bg_hex, hovered_bg_hex),
+            focused_bg_hex
+        );
+    }
+
+    #[test]
+    fn test_resolve_row_bg_hex_uses_hover_color_for_unselected_hovered_row() {
+        let focused_bg_hex = 0x55AAFF3A;
+        let hovered_bg_hex = 0x55AAFF26;
+
+        let hovered_row = SelectRowState {
+            is_focused: false,
+            is_selected: false,
+            is_hovered: true,
+        };
+
+        assert_eq!(
+            resolve_row_bg_hex(hovered_row, focused_bg_hex, hovered_bg_hex),
+            hovered_bg_hex
+        );
+    }
+}

 exited 101 in 2m 01s:
    Blocking waiting for file lock on build directory
   Compiling cfg-if v1.0.4
   Compiling memchr v2.7.6
   Compiling smallvec v1.15.1
   Compiling stable_deref_trait v1.2.1
   Compiling serde_core v1.0.228
   Compiling libc v0.2.178
   Compiling typeid v1.0.3
   Compiling crossbeam-utils v0.8.21
   Compiling libm v0.2.15
   Compiling objc2-encode v4.1.0
   Compiling pin-project-lite v0.2.16
   Compiling arrayvec v0.7.6
   Compiling core-foundation-sys v0.8.7
   Compiling futures-core v0.3.31
   Compiling equivalent v1.0.2
   Compiling futures-io v0.3.31
   Compiling once_cell v1.21.3
   Compiling typenum v1.19.0
   Compiling regex-syntax v0.8.8

thinking
**Polling for completion**
file update:
diff --git a/src/prompts/select/render.rs b/src/prompts/select/render.rs
index d0e0a5485f10066de9a287b70a4c3ae891e5cd99..c26ba855b7e69a16a4d3e1b048889d3588ac5525
--- a/src/prompts/select/render.rs
+++ b/src/prompts/select/render.rs
@@ -24,6 +24,20 @@
     }
 }
 
+pub(super) fn resolve_row_bg_hex(
+    row_state: SelectRowState,
+    focused_bg_hex: u32,
+    hovered_bg_hex: u32,
+) -> u32 {
+    if row_state.is_focused || row_state.is_selected {
+        focused_bg_hex
+    } else if row_state.is_hovered {
+        hovered_bg_hex
+    } else {
+        0x00000000
+    }
+}
+
 pub(super) fn extract_choice_icon_hint(description: Option<&str>) -> Option<&str> {
     description.and_then(|raw| {
         raw.split(['•', '|', '\n'])
@@ -128,13 +142,14 @@
         // VIBRANCY: Optional background override when a vibrancy surface is available.
         let vibrancy_bg = get_vibrancy_background(&self.theme);
 
-        let (_main_bg, text_color, muted_color, border_color) =
+        let (_main_bg, text_color, muted_color, border_color, border_color_hex) =
             if self.design_variant == DesignVariant::Default {
                 (
                     rgb(self.theme.colors.background.main),
                     rgb(self.theme.colors.text.secondary),
                     rgb(self.theme.colors.text.muted),
                     rgb(self.theme.colors.ui.border),
+                    self.theme.colors.ui.border,
                 )
             } else {
                 (
@@ -142,6 +157,7 @@
                     rgb(colors.text_secondary),
                     rgb(colors.text_muted),
                     rgb(colors.border),
+                    colors.border,
                 )
             };
         let search_box_bg = rgb(resolve_search_box_bg_hex(
@@ -154,8 +170,9 @@
         } else {
             colors.accent
         };
-        let focused_row_bg = rgba((row_accent_color << 8) | ROW_FOCUSED_BG_ALPHA);
-        let hovered_row_bg = rgba((row_accent_color << 8) | ROW_HOVER_BG_ALPHA);
+        let focused_row_bg_hex = (row_accent_color << 8) | ROW_FOCUSED_BG_ALPHA;
+        let hovered_row_bg_hex = (row_accent_color << 8) | ROW_HOVER_BG_ALPHA;
+        let hovered_row_bg = rgba(hovered_row_bg_hex);
 
         let placeholder = self
             .placeholder
@@ -278,13 +295,11 @@
                                                     ))
                                                 },
                                             );
-                                        let row_bg = if is_focused {
-                                            focused_row_bg
-                                        } else if is_hovered {
-                                            hovered_row_bg
-                                        } else {
-                                            rgba(0x00000000)
-                                        };
+                                        let row_bg = rgba(resolve_row_bg_hex(
+                                            row_state,
+                                            focused_row_bg_hex,
+                                            hovered_row_bg_hex,
+                                        ));
                                         let hover_handler = cx.listener(
                                             move |this: &mut SelectPrompt,
                                                   hovered: &bool,
@@ -327,7 +342,7 @@
                                                 .colors(item_colors),
                                             );
 
-                                        if !is_focused {
+                                        if !is_focused && !is_selected {
                                             row = row.hover(move |s| s.bg(hovered_row_bg));
                                         }
 
@@ -367,7 +382,7 @@
             .rounded(px(12.0))
             .overflow_hidden()
             .border_1()
-            .border_color(border_color.opacity(0.25))
+            .border_color(rgba((border_color_hex << 8) | 0x40))
             .text_color(text_color)
             .key_context("select_prompt")
             .track_focus(&self.focus_handle)
@@ -376,3 +391,42 @@
             .child(choices_container)
     }
 }
+
+#[cfg(test)]
+mod tests {
+    use super::{resolve_row_bg_hex, SelectRowState};
+
+    #[test]
+    fn test_resolve_row_bg_hex_uses_focused_accent_for_selected_row() {
+        let focused_bg_hex = 0x55AAFF3A;
+        let hovered_bg_hex = 0x55AAFF26;
+
+        let selected_row = SelectRowState {
+            is_focused: false,
+            is_selected: true,
+            is_hovered: false,
+        };
+
+        assert_eq!(
+            resolve_row_bg_hex(selected_row, focused_bg_hex, hovered_bg_hex),
+            focused_bg_hex
+        );
+    }
+
+    #[test]
+    fn test_resolve_row_bg_hex_uses_hover_color_for_unselected_hovered_row() {
+        let focused_bg_hex = 0x55AAFF3A;
+        let hovered_bg_hex = 0x55AAFF26;
+
+        let hovered_row = SelectRowState {
+            is_focused: false,
+            is_selected: false,
+            is_hovered: true,
+        };
+
+        assert_eq!(
+            resolve_row_bg_hex(hovered_row, focused_bg_hex, hovered_bg_hex),
+            hovered_bg_hex
+        );
+    }
+}


thinking
**Planning targeted test and code inspection**
exec
/bin/zsh -lc "rg -n \"border_b_1|choices_container|rounded\\(px\\(8\\.0\\)\\)|resolve_row_bg_hex|is_focused && "'!is_selected|is_focused '"\\|\\| row_state\\.is_selected\" src/prompts/select/render.rs" in /Users/johnlindquist/dev/script-kit-gpui succeeded in 51ms:
27:pub(super) fn resolve_row_bg_hex(
32:    if row_state.is_focused || row_state.is_selected {
196:            .border_b_1()
298:                                        let row_bg = rgba(resolve_row_bg_hex(
324:                                            .rounded(px(8.0))
345:                                        if !is_focused && !is_selected {
365:        let choices_container = div()
391:            .child(choices_container)
397:    use super::{resolve_row_bg_hex, SelectRowState};
400:    fn test_resolve_row_bg_hex_uses_focused_accent_for_selected_row() {
411:            resolve_row_bg_hex(selected_row, focused_bg_hex, hovered_bg_hex),
417:    fn test_resolve_row_bg_hex_uses_hover_color_for_unselected_hovered_row() {
428:            resolve_row_bg_hex(hovered_row, focused_bg_hex, hovered_bg_hex),
file update:
diff --git a/src/prompts/select/render.rs b/src/prompts/select/render.rs
index d0e0a5485f10066de9a287b70a4c3ae891e5cd99..c26ba855b7e69a16a4d3e1b048889d3588ac5525
--- a/src/prompts/select/render.rs
+++ b/src/prompts/select/render.rs
@@ -24,6 +24,20 @@
     }
 }
 
+pub(super) fn resolve_row_bg_hex(
+    row_state: SelectRowState,
+    focused_bg_hex: u32,
+    hovered_bg_hex: u32,
+) -> u32 {
+    if row_state.is_focused || row_state.is_selected {
+        focused_bg_hex
+    } else if row_state.is_hovered {
+        hovered_bg_hex
+    } else {
+        0x00000000
+    }
+}
+
 pub(super) fn extract_choice_icon_hint(description: Option<&str>) -> Option<&str> {
     description.and_then(|raw| {
         raw.split(['•', '|', '\n'])
@@ -128,13 +142,14 @@
         // VIBRANCY: Optional background override when a vibrancy surface is available.
         let vibrancy_bg = get_vibrancy_background(&self.theme);
 
-        let (_main_bg, text_color, muted_color, border_color) =
+        let (_main_bg, text_color, muted_color, border_color, border_color_hex) =
             if self.design_variant == DesignVariant::Default {
                 (
                     rgb(self.theme.colors.background.main),
                     rgb(self.theme.colors.text.secondary),
                     rgb(self.theme.colors.text.muted),
                     rgb(self.theme.colors.ui.border),
+                    self.theme.colors.ui.border,
                 )
             } else {
                 (
@@ -142,6 +157,7 @@
                     rgb(colors.text_secondary),
                     rgb(colors.text_muted),
                     rgb(colors.border),
+                    colors.border,
                 )
             };
         let search_box_bg = rgb(resolve_search_box_bg_hex(
@@ -154,8 +170,9 @@
         } else {
             colors.accent
         };
-        let focused_row_bg = rgba((row_accent_color << 8) | ROW_FOCUSED_BG_ALPHA);
-        let hovered_row_bg = rgba((row_accent_color << 8) | ROW_HOVER_BG_ALPHA);
+        let focused_row_bg_hex = (row_accent_color << 8) | ROW_FOCUSED_BG_ALPHA;
+        let hovered_row_bg_hex = (row_accent_color << 8) | ROW_HOVER_BG_ALPHA;
+        let hovered_row_bg = rgba(hovered_row_bg_hex);
 
         let placeholder = self
             .placeholder
@@ -278,13 +295,11 @@
                                                     ))
                                                 },
                                             );
-                                        let row_bg = if is_focused {
-                                            focused_row_bg
-                                        } else if is_hovered {
-                                            hovered_row_bg
-                                        } else {
-                                            rgba(0x00000000)
-                                        };
+                                        let row_bg = rgba(resolve_row_bg_hex(
+                                            row_state,
+                                            focused_row_bg_hex,
+                                            hovered_row_bg_hex,
+                                        ));
                                         let hover_handler = cx.listener(
                                             move |this: &mut SelectPrompt,
                                                   hovered: &bool,
@@ -327,7 +342,7 @@
                                                 .colors(item_colors),
                                             );
 
-                                        if !is_focused {
+                                        if !is_focused && !is_selected {
                                             row = row.hover(move |s| s.bg(hovered_row_bg));
                                         }
 
@@ -367,7 +382,7 @@
             .rounded(px(12.0))
             .overflow_hidden()
             .border_1()
-            .border_color(border_color.opacity(0.25))
+            .border_color(rgba((border_color_hex << 8) | 0x40))
             .text_color(text_color)
             .key_context("select_prompt")
             .track_focus(&self.focus_handle)
@@ -376,3 +391,42 @@
             .child(choices_container)
     }
 }
+
+#[cfg(test)]
+mod tests {
+    use super::{resolve_row_bg_hex, SelectRowState};
+
+    #[test]
+    fn test_resolve_row_bg_hex_uses_focused_accent_for_selected_row() {
+        let focused_bg_hex = 0x55AAFF3A;
+        let hovered_bg_hex = 0x55AAFF26;
+
+        let selected_row = SelectRowState {
+            is_focused: false,
+            is_selected: true,
+            is_hovered: false,
+        };
+
+        assert_eq!(
+            resolve_row_bg_hex(selected_row, focused_bg_hex, hovered_bg_hex),
+            focused_bg_hex
+        );
+    }
+
+    #[test]
+    fn test_resolve_row_bg_hex_uses_hover_color_for_unselected_hovered_row() {
+        let focused_bg_hex = 0x55AAFF3A;
+        let hovered_bg_hex = 0x55AAFF26;
+
+        let hovered_row = SelectRowState {
+            is_focused: false,
+            is_selected: false,
+            is_hovered: true,
+        };
+
+        assert_eq!(
+            resolve_row_bg_hex(hovered_row, focused_bg_hex, hovered_bg_hex),
+            hovered_bg_hex
+        );
+    }
+}


thinking
**Preparing precise diff references**
exec
/bin/zsh -lc "nl -ba src/prompts/select/render.rs | sed -n '1,120p'" in /Users/johnlindquist/dev/script-kit-gpui succeeded in 52ms:
     1	use super::*;
     2	
     3	const ROW_FOCUSED_BG_ALPHA: u32 = 0x3A;
     4	const ROW_HOVER_BG_ALPHA: u32 = 0x26;
     5	
     6	#[derive(Clone, Copy, Debug, PartialEq, Eq)]
     7	pub(super) struct SelectRowState {
     8	    pub is_focused: bool,
     9	    pub is_selected: bool,
    10	    pub is_hovered: bool,
    11	}
    12	
    13	pub(super) fn compute_row_state(
    14	    display_idx: usize,
    15	    focused_index: usize,
    16	    choice_idx: usize,
    17	    selected: &HashSet<usize>,
    18	    hovered_index: Option<usize>,
    19	) -> SelectRowState {
    20	    SelectRowState {
file update:
diff --git a/src/prompts/select/render.rs b/src/prompts/select/render.rs
index d0e0a5485f10066de9a287b70a4c3ae891e5cd99..c26ba855b7e69a16a4d3e1b048889d3588ac5525
--- a/src/prompts/select/render.rs
+++ b/src/prompts/select/render.rs
@@ -24,6 +24,20 @@
     }
 }
 
+pub(super) fn resolve_row_bg_hex(
+    row_state: SelectRowState,
+    focused_bg_hex: u32,
+    hovered_bg_hex: u32,
+) -> u32 {
+    if row_state.is_focused || row_state.is_selected {
+        focused_bg_hex
+    } else if row_state.is_hovered {
+        hovered_bg_hex
+    } else {
+        0x00000000
+    }
+}
+
 pub(super) fn extract_choice_icon_hint(description: Option<&str>) -> Option<&str> {
     description.and_then(|raw| {
         raw.split(['•', '|', '\n'])
@@ -128,13 +142,14 @@
         // VIBRANCY: Optional background override when a vibrancy surface is available.
         let vibrancy_bg = get_vibrancy_background(&self.theme);
 
-        let (_main_bg, text_color, muted_color, border_color) =
+        let (_main_bg, text_color, muted_color, border_color, border_color_hex) =
             if self.design_variant == DesignVariant::Default {
                 (
                     rgb(self.theme.colors.background.main),
                     rgb(self.theme.colors.text.secondary),
                     rgb(self.theme.colors.text.muted),
                     rgb(self.theme.colors.ui.border),
+                    self.theme.colors.ui.border,
                 )
             } else {
                 (
@@ -142,6 +157,7 @@
                     rgb(colors.text_secondary),
                     rgb(colors.text_muted),
                     rgb(colors.border),
+                    colors.border,
                 )
             };
         let search_box_bg = rgb(resolve_search_box_bg_hex(
@@ -154,8 +170,9 @@
         } else {
             colors.accent
         };
-        let focused_row_bg = rgba((row_accent_color << 8) | ROW_FOCUSED_BG_ALPHA);
-        let hovered_row_bg = rgba((row_accent_color << 8) | ROW_HOVER_BG_ALPHA);
+        let focused_row_bg_hex = (row_accent_color << 8) | ROW_FOCUSED_BG_ALPHA;
+        let hovered_row_bg_hex = (row_accent_color << 8) | ROW_HOVER_BG_ALPHA;
+        let hovered_row_bg = rgba(hovered_row_bg_hex);
 
         let placeholder = self
             .placeholder
@@ -278,13 +295,11 @@
                                                     ))
                                                 },
                                             );
-                                        let row_bg = if is_focused {
-                                            focused_row_bg
-                                        } else if is_hovered {
-                                            hovered_row_bg
-                                        } else {
-                                            rgba(0x00000000)
-                                        };
+                                        let row_bg = rgba(resolve_row_bg_hex(
+                                            row_state,
+                                            focused_row_bg_hex,
+                                            hovered_row_bg_hex,
+                                        ));
                                         let hover_handler = cx.listener(
                                             move |this: &mut SelectPrompt,
                                                   hovered: &bool,
@@ -327,7 +342,7 @@
                                                 .colors(item_colors),
                                             );
 
-                                        if !is_focused {
+                                        if !is_focused && !is_selected {
                                             row = row.hover(move |s| s.bg(hovered_row_bg));
                                         }
 
@@ -367,7 +382,7 @@
             .rounded(px(12.0))
             .overflow_hidden()
             .border_1()
-            .border_color(border_color.opacity(0.25))
+            .border_color(rgba((border_color_hex << 8) | 0x40))
             .text_color(text_color)
             .key_context("select_prompt")
             .track_focus(&self.focus_handle)
@@ -376,3 +391,42 @@
             .child(choices_container)
     }
 }
+
+#[cfg(test)]
+mod tests {
+    use super::{resolve_row_bg_hex, SelectRowState};
+
+    #[test]
+    fn test_resolve_row_bg_hex_uses_focused_accent_for_selected_row() {
+        let focused_bg_hex = 0x55AAFF3A;
+        let hovered_bg_hex = 0x55AAFF26;
+
+        let selected_row = SelectRowState {
+            is_focused: false,
+            is_selected: true,
+            is_hovered: false,
+        };
+
+        assert_eq!(
+            resolve_row_bg_hex(selected_row, focused_bg_hex, hovered_bg_hex),
+            focused_bg_hex
+        );
+    }
+
+    #[test]
+    fn test_resolve_row_bg_hex_uses_hover_color_for_unselected_hovered_row() {
+        let focused_bg_hex = 0x55AAFF3A;
+        let hovered_bg_hex = 0x55AAFF26;
+
+        let hovered_row = SelectRowState {
+            is_focused: false,
+            is_selected: false,
+            is_hovered: true,
+        };
+
+        assert_eq!(
+            resolve_row_bg_hex(hovered_row, focused_bg_hex, hovered_bg_hex),
+            hovered_bg_hex
+        );
+    }
+}


thinking
**Identifying UI styling and structure code**
exec
/bin/zsh -lc "nl -ba src/prompts/select/render.rs | sed -n '140,240p'" in /Users/johnlindquist/dev/script-kit-gpuiexec
/bin/zsh -lc "nl -ba src/prompts/select/render.rs | sed -n '260,440p'" in /Users/johnlindquist/dev/script-kit-gpui succeeded in 50ms:
   140	        );
   141	
   142	        // VIBRANCY: Optional background override when a vibrancy surface is available.
   143	        let vibrancy_bg = get_vibrancy_background(&self.theme);
   144	
   145	        let (_main_bg, text_color, muted_color, border_color, border_color_hex) =
   146	            if self.design_variant == DesignVariant::Default {
   147	                (
   148	                    rgb(self.theme.colors.background.main),
   149	                    rgb(self.theme.colors.text.secondary),
   150	                    rgb(self.theme.colors.text.muted),
   151	                    rgb(self.theme.colors.ui.border),
   152	                    self.theme.colors.ui.border,
   153	                )
   154	            } else {
   155	                (
   156	                    rgb(colors.background),
   157	                    rgb(colors.text_secondary),
   158	                    rgb(colors.text_muted),
   159	                    rgb(colors.border),
 succeeded in 52ms:
   260	                                            this.focused_index,
   261	                                            choice_idx,
   262	                                            &this.selected,
   263	                                            this.hovered_index,
   264	                                        );
   265	                                        let is_focused = row_state.is_focused;
   266	                                        let is_selected = row_state.is_selected;
   267	                                        let is_hovered = row_state.is_hovered;
   268	                                        let semantic_id =
   269	                                            choice.semantic_id.clone().unwrap_or_else(|| {
   270	                                                indexed_choice.stable_semantic_id.clone()
   271	                                            });
   272	                                        let leading = if this.multiple {
   273	                                            Some(LeadingContent::Emoji(
   274	                                                choice_selection_indicator(true, is_selected)
   275	                                                    .into(),
   276	                                            ))
   277	                                        } else {
   278	                                            Some(leading_content_from_icon_kind(
   279	                                                icon_kind_from_choice(choice),
file update:
diff --git a/src/prompts/select/render.rs b/src/prompts/select/render.rs
index d0e0a5485f10066de9a287b70a4c3ae891e5cd99..c26ba855b7e69a16a4d3e1b048889d3588ac5525
--- a/src/prompts/select/render.rs
+++ b/src/prompts/select/render.rs
@@ -24,6 +24,20 @@
     }
 }
 
+pub(super) fn resolve_row_bg_hex(
+    row_state: SelectRowState,
+    focused_bg_hex: u32,
+    hovered_bg_hex: u32,
+) -> u32 {
+    if row_state.is_focused || row_state.is_selected {
+        focused_bg_hex
+    } else if row_state.is_hovered {
+        hovered_bg_hex
+    } else {
+        0x00000000
+    }
+}
+
 pub(super) fn extract_choice_icon_hint(description: Option<&str>) -> Option<&str> {
     description.and_then(|raw| {
         raw.split(['•', '|', '\n'])
@@ -128,13 +142,14 @@
         // VIBRANCY: Optional background override when a vibrancy surface is available.
         let vibrancy_bg = get_vibrancy_background(&self.theme);
 
-        let (_main_bg, text_color, muted_color, border_color) =
+        let (_main_bg, text_color, muted_color, border_color, border_color_hex) =
             if self.design_variant == DesignVariant::Default {
                 (
                     rgb(self.theme.colors.background.main),
                     rgb(self.theme.colors.text.secondary),
                     rgb(self.theme.colors.text.muted),
                     rgb(self.theme.colors.ui.border),
+                    self.theme.colors.ui.border,
                 )
             } else {
                 (
@@ -142,6 +157,7 @@
                     rgb(colors.text_secondary),
                     rgb(colors.text_muted),
                     rgb(colors.border),
+                    colors.border,
                 )
             };
         let search_box_bg = rgb(resolve_search_box_bg_hex(
@@ -154,8 +170,9 @@
         } else {
             colors.accent
         };
-        let focused_row_bg = rgba((row_accent_color << 8) | ROW_FOCUSED_BG_ALPHA);
-        let hovered_row_bg = rgba((row_accent_color << 8) | ROW_HOVER_BG_ALPHA);
+        let focused_row_bg_hex = (row_accent_color << 8) | ROW_FOCUSED_BG_ALPHA;
+        let hovered_row_bg_hex = (row_accent_color << 8) | ROW_HOVER_BG_ALPHA;
+        let hovered_row_bg = rgba(hovered_row_bg_hex);
 
         let placeholder = self
             .placeholder
@@ -278,13 +295,11 @@
                                                     ))
                                                 },
                                             );
-                                        let row_bg = if is_focused {
-                                            focused_row_bg
-                                        } else if is_hovered {
-                                            hovered_row_bg
-                                        } else {
-                                            rgba(0x00000000)
-                                        };
+                                        let row_bg = rgba(resolve_row_bg_hex(
+                                            row_state,
+                                            focused_row_bg_hex,
+                                            hovered_row_bg_hex,
+                                        ));
                                         let hover_handler = cx.listener(
                                             move |this: &mut SelectPrompt,
                                                   hovered: &bool,
@@ -327,7 +342,7 @@
                                                 .colors(item_colors),
                                             );
 
-                                        if !is_focused {
+                                        if !is_focused && !is_selected {
                                             row = row.hover(move |s| s.bg(hovered_row_bg));
                                         }
 
@@ -367,7 +382,7 @@
             .rounded(px(12.0))
             .overflow_hidden()
             .border_1()
-            .border_color(border_color.opacity(0.25))
+            .border_color(rgba((border_color_hex << 8) | 0x40))
             .text_color(text_color)
             .key_context("select_prompt")
             .track_focus(&self.focus_handle)
@@ -376,3 +391,42 @@
             .child(choices_container)
     }
 }
+
+#[cfg(test)]
+mod tests {
+    use super::{resolve_row_bg_hex, SelectRowState};
+
+    #[test]
+    fn test_resolve_row_bg_hex_uses_focused_accent_for_selected_row() {
+        let focused_bg_hex = 0x55AAFF3A;
+        let hovered_bg_hex = 0x55AAFF26;
+
+        let selected_row = SelectRowState {
+            is_focused: false,
+            is_selected: true,
+            is_hovered: false,
+        };
+
+        assert_eq!(
+            resolve_row_bg_hex(selected_row, focused_bg_hex, hovered_bg_hex),
+            focused_bg_hex
+        );
+    }
+
+    #[test]
+    fn test_resolve_row_bg_hex_uses_hover_color_for_unselected_hovered_row() {
+        let focused_bg_hex = 0x55AAFF3A;
+        let hovered_bg_hex = 0x55AAFF26;
+
+        let hovered_row = SelectRowState {
+            is_focused: false,
+            is_selected: false,
+            is_hovered: true,
+        };
+
+        assert_eq!(
+            resolve_row_bg_hex(hovered_row, focused_bg_hex, hovered_bg_hex),
+            hovered_bg_hex
+        );
+    }
+}


thinking
**Choosing not to commit due to verification**
codex
I’m wrapping up: the target styling update is in place, and verification attempts are blocked by unrelated compile/test breakage in other modules. I’ll release the claim and post a concise handoff with exact commands and failures.
exec
/bin/zsh -lc '~/.claude/bin/swarm.ts update --id codex-list-polish-split-1 --status done --notes "Updated select row background logic for focused/selected states + tests in render.rs; verification commands blocked by unrelated workspace compile failures (actions/scripts/protocol/designs modules)" && ~/.claude/bin/swarm.ts release --id codex-list-polish-split-1 src/prompts/select/render.rs' in /Users/johnlindquist/dev/script-kit-gpui succeeded in 51ms:
Updated: codex-list-polish-split-1
Released for codex-list-polish-split-1: src/prompts/select/render.rs
file update:
diff --git a/src/prompts/select/render.rs b/src/prompts/select/render.rs
index d0e0a5485f10066de9a287b70a4c3ae891e5cd99..c26ba855b7e69a16a4d3e1b048889d3588ac5525
--- a/src/prompts/select/render.rs
+++ b/src/prompts/select/render.rs
@@ -24,6 +24,20 @@
     }
 }
 
+pub(super) fn resolve_row_bg_hex(
+    row_state: SelectRowState,
+    focused_bg_hex: u32,
+    hovered_bg_hex: u32,
+) -> u32 {
+    if row_state.is_focused || row_state.is_selected {
+        focused_bg_hex
+    } else if row_state.is_hovered {
+        hovered_bg_hex
+    } else {
+        0x00000000
+    }
+}
+
 pub(super) fn extract_choice_icon_hint(description: Option<&str>) -> Option<&str> {
     description.and_then(|raw| {
         raw.split(['•', '|', '\n'])
@@ -128,13 +142,14 @@
         // VIBRANCY: Optional background override when a vibrancy surface is available.
         let vibrancy_bg = get_vibrancy_background(&self.theme);
 
-        let (_main_bg, text_color, muted_color, border_color) =
+        let (_main_bg, text_color, muted_color, border_color, border_color_hex) =
             if self.design_variant == DesignVariant::Default {
                 (
                     rgb(self.theme.colors.background.main),
                     rgb(self.theme.colors.text.secondary),
                     rgb(self.theme.colors.text.muted),
                     rgb(self.theme.colors.ui.border),
+                    self.theme.colors.ui.border,
                 )
             } else {
                 (
@@ -142,6 +157,7 @@
                     rgb(colors.text_secondary),
                     rgb(colors.text_muted),
                     rgb(colors.border),
+                    colors.border,
                 )
             };
         let search_box_bg = rgb(resolve_search_box_bg_hex(
@@ -154,8 +170,9 @@
         } else {
             colors.accent
         };
-        let focused_row_bg = rgba((row_accent_color << 8) | ROW_FOCUSED_BG_ALPHA);
-        let hovered_row_bg = rgba((row_accent_color << 8) | ROW_HOVER_BG_ALPHA);
+        let focused_row_bg_hex = (row_accent_color << 8) | ROW_FOCUSED_BG_ALPHA;
+        let hovered_row_bg_hex = (row_accent_color << 8) | ROW_HOVER_BG_ALPHA;
+        let hovered_row_bg = rgba(hovered_row_bg_hex);
 
         let placeholder = self
             .placeholder
@@ -278,13 +295,11 @@
                                                     ))
                                                 },
                                             );
-                                        let row_bg = if is_focused {
-                                            focused_row_bg
-                                        } else if is_hovered {
-                                            hovered_row_bg
-                                        } else {
-                                            rgba(0x00000000)
-                                        };
+                                        let row_bg = rgba(resolve_row_bg_hex(
+                                            row_state,
+                                            focused_row_bg_hex,
+                                            hovered_row_bg_hex,
+                                        ));
                                         let hover_handler = cx.listener(
                                             move |this: &mut SelectPrompt,
                                                   hovered: &bool,
@@ -327,7 +342,7 @@
                                                 .colors(item_colors),
                                             );
 
-                                        if !is_focused {
+                                        if !is_focused && !is_selected {
                                             row = row.hover(move |s| s.bg(hovered_row_bg));
                                         }
 
@@ -367,7 +382,7 @@
             .rounded(px(12.0))
             .overflow_hidden()
             .border_1()
-            .border_color(border_color.opacity(0.25))
+            .border_color(rgba((border_color_hex << 8) | 0x40))
             .text_color(text_color)
             .key_context("select_prompt")
             .track_focus(&self.focus_handle)
@@ -376,3 +391,42 @@
             .child(choices_container)
     }
 }
+
+#[cfg(test)]
+mod tests {
+    use super::{resolve_row_bg_hex, SelectRowState};
+
+    #[test]
+    fn test_resolve_row_bg_hex_uses_focused_accent_for_selected_row() {
+        let focused_bg_hex = 0x55AAFF3A;
+        let hovered_bg_hex = 0x55AAFF26;
+
+        let selected_row = SelectRowState {
+            is_focused: false,
+            is_selected: true,
+            is_hovered: false,
+        };
+
+        assert_eq!(
+            resolve_row_bg_hex(selected_row, focused_bg_hex, hovered_bg_hex),
+            focused_bg_hex
+        );
+    }
+
+    #[test]
+    fn test_resolve_row_bg_hex_uses_hover_color_for_unselected_hovered_row() {
+        let focused_bg_hex = 0x55AAFF3A;
+        let hovered_bg_hex = 0x55AAFF26;
+
+        let hovered_row = SelectRowState {
+            is_focused: false,
+            is_selected: false,
+            is_hovered: true,
+        };
+
+        assert_eq!(
+            resolve_row_bg_hex(hovered_row, focused_bg_hex, hovered_bg_hex),
+            hovered_bg_hex
+        );
+    }
+}


thinking
**Summarizing changes and verification**
codex
Changed files:
- `src/prompts/select/render.rs:27` added `resolve_row_bg_hex(...)` so focused OR selected rows use the accent background (`alpha 0x3A`), hovered-only rows use hover alpha.
- `src/prompts/select/render.rs:298` row background now uses that resolver; selected rows now get the same pill highlight as focused rows.
- `src/prompts/select/render.rs:345` hover override now skips both focused and selected rows so selected rows keep the stronger highlight.
- `src/prompts/select/render.rs:324` row wrapper remains `.rounded(px(8.0))` and has no per-row `.border_b_1()` calls.
- `src/prompts/select/render.rs:371` choices list container has `.px(px(8.0))`.
- `src/prompts/select/render.rs:385` replaced invalid `Rgba::opacity(...)` call with explicit RGBA alpha composition to keep this file compiling.
- `src/prompts/select/render.rs:395` added tests for focused/selected/hover background resolution.

How to test:
1. Run:
   - `cargo check && cargo clippy --all-targets -- -D warnings && cargo test`
2. If shared target locking is noisy in parallel runs, isolate target dir:
   - `CARGO_TARGET_DIR=target/codex-list-polish-split-1 cargo check -p script-kit-gpui`
   - `CARGO_TARGET_DIR=target/codex-list-polish-split-1 cargo clippy -p script-kit-gpui --all-targets -- -D warnings`
   - `CARGO_TARGET_DIR=target/codex-list-polish-split-1 cargo test -p script-kit-gpui --lib prompts::select::render::tests::`

Risks / known gaps:
- Full verification is currently blocked by unrelated workspace errors outside this file (examples: `src/protocol/message/mod.rs`, `src/designs/core/part_04.rs`, `src/scripts/mod.rs`, many `src/actions/tests/*` files).
- Because of those unrelated failures, I could not produce a clean green run of the full gate in this shared tree.

Commits:
- None.
file update:
diff --git a/src/prompts/select/render.rs b/src/prompts/select/render.rs
index d0e0a5485f10066de9a287b70a4c3ae891e5cd99..c26ba855b7e69a16a4d3e1b048889d3588ac5525
--- a/src/prompts/select/render.rs
+++ b/src/prompts/select/render.rs
@@ -24,6 +24,20 @@
     }
 }
 
+pub(super) fn resolve_row_bg_hex(
+    row_state: SelectRowState,
+    focused_bg_hex: u32,
+    hovered_bg_hex: u32,
+) -> u32 {
+    if row_state.is_focused || row_state.is_selected {
+        focused_bg_hex
+    } else if row_state.is_hovered {
+        hovered_bg_hex
+    } else {
+        0x00000000
+    }
+}
+
 pub(super) fn extract_choice_icon_hint(description: Option<&str>) -> Option<&str> {
     description.and_then(|raw| {
         raw.split(['•', '|', '\n'])
@@ -128,13 +142,14 @@
         // VIBRANCY: Optional background override when a vibrancy surface is available.
         let vibrancy_bg = get_vibrancy_background(&self.theme);
 
-        let (_main_bg, text_color, muted_color, border_color) =
+        let (_main_bg, text_color, muted_color, border_color, border_color_hex) =
             if self.design_variant == DesignVariant::Default {
                 (
                     rgb(self.theme.colors.background.main),
                     rgb(self.theme.colors.text.secondary),
                     rgb(self.theme.colors.text.muted),
                     rgb(self.theme.colors.ui.border),
+                    self.theme.colors.ui.border,
                 )
             } else {
                 (
@@ -142,6 +157,7 @@
                     rgb(colors.text_secondary),
                     rgb(colors.text_muted),
                     rgb(colors.border),
+                    colors.border,
                 )
             };
         let search_box_bg = rgb(resolve_search_box_bg_hex(
@@ -154,8 +170,9 @@
         } else {
             colors.accent
         };
-        let focused_row_bg = rgba((row_accent_color << 8) | ROW_FOCUSED_BG_ALPHA);
-        let hovered_row_bg = rgba((row_accent_color << 8) | ROW_HOVER_BG_ALPHA);
+        let focused_row_bg_hex = (row_accent_color << 8) | ROW_FOCUSED_BG_ALPHA;
+        let hovered_row_bg_hex = (row_accent_color << 8) | ROW_HOVER_BG_ALPHA;
+        let hovered_row_bg = rgba(hovered_row_bg_hex);
 
         let placeholder = self
             .placeholder
@@ -278,13 +295,11 @@
                                                     ))
                                                 },
                                             );
-                                        let row_bg = if is_focused {
-                                            focused_row_bg
-                                        } else if is_hovered {
-                                            hovered_row_bg
-                                        } else {
-                                            rgba(0x00000000)
-                                        };
+                                        let row_bg = rgba(resolve_row_bg_hex(
+                                            row_state,
+                                            focused_row_bg_hex,
+                                            hovered_row_bg_hex,
+                                        ));
                                         let hover_handler = cx.listener(
                                             move |this: &mut SelectPrompt,
                                                   hovered: &bool,
@@ -327,7 +342,7 @@
                                                 .colors(item_colors),
                                             );
 
-                                        if !is_focused {
+                                        if !is_focused && !is_selected {
                                             row = row.hover(move |s| s.bg(hovered_row_bg));
                                         }
 
@@ -367,7 +382,7 @@
             .rounded(px(12.0))
             .overflow_hidden()
             .border_1()
-            .border_color(border_color.opacity(0.25))
+            .border_color(rgba((border_color_hex << 8) | 0x40))
             .text_color(text_color)
             .key_context("select_prompt")
             .track_focus(&self.focus_handle)
@@ -376,3 +391,42 @@
             .child(choices_container)
     }
 }
+
+#[cfg(test)]
+mod tests {
+    use super::{resolve_row_bg_hex, SelectRowState};
+
+    #[test]
+    fn test_resolve_row_bg_hex_uses_focused_accent_for_selected_row() {
+        let focused_bg_hex = 0x55AAFF3A;
+        let hovered_bg_hex = 0x55AAFF26;
+
+        let selected_row = SelectRowState {
+            is_focused: false,
+            is_selected: true,
+            is_hovered: false,
+        };
+
+        assert_eq!(
+            resolve_row_bg_hex(selected_row, focused_bg_hex, hovered_bg_hex),
+            focused_bg_hex
+        );
+    }
+
+    #[test]
+    fn test_resolve_row_bg_hex_uses_hover_color_for_unselected_hovered_row() {
+        let focused_bg_hex = 0x55AAFF3A;
+        let hovered_bg_hex = 0x55AAFF26;
+
+        let hovered_row = SelectRowState {
+            is_focused: false,
+            is_selected: false,
+            is_hovered: true,
+        };
+
+        assert_eq!(
+            resolve_row_bg_hex(hovered_row, focused_bg_hex, hovered_bg_hex),
+            hovered_bg_hex
+        );
+    }
+}

tokens used
174,779
Changed files:
- `src/prompts/select/render.rs:27` added `resolve_row_bg_hex(...)` so focused OR selected rows use the accent background (`alpha 0x3A`), hovered-only rows use hover alpha.
- `src/prompts/select/render.rs:298` row background now uses that resolver; selected rows now get the same pill highlight as focused rows.
- `src/prompts/select/render.rs:345` hover override now skips both focused and selected rows so selected rows keep the stronger highlight.
- `src/prompts/select/render.rs:324` row wrapper remains `.rounded(px(8.0))` and has no per-row `.border_b_1()` calls.
- `src/prompts/select/render.rs:371` choices list container has `.px(px(8.0))`.
- `src/prompts/select/render.rs:385` replaced invalid `Rgba::opacity(...)` call with explicit RGBA alpha composition to keep this file compiling.
- `src/prompts/select/render.rs:395` added tests for focused/selected/hover background resolution.

How to test:
1. Run:
   - `cargo check && cargo clippy --all-targets -- -D warnings && cargo test`
2. If shared target locking is noisy in parallel runs, isolate target dir:
   - `CARGO_TARGET_DIR=target/codex-list-polish-split-1 cargo check -p script-kit-gpui`
   - `CARGO_TARGET_DIR=target/codex-list-polish-split-1 cargo clippy -p script-kit-gpui --all-targets -- -D warnings`
   - `CARGO_TARGET_DIR=target/codex-list-polish-split-1 cargo test -p script-kit-gpui --lib prompts::select::render::tests::`

Risks / known gaps:
- Full verification is currently blocked by unrelated workspace errors outside this file (examples: `src/protocol/message/mod.rs`, `src/designs/core/part_04.rs`, `src/scripts/mod.rs`, many `src/actions/tests/*` files).
- Because of those unrelated failures, I could not produce a clean green run of the full gate in this shared tree.

Commits:
- None.
[swarm-commit-gate] author=swarm:codex-list-polish-split-1 start_sha=7a6c0cb31c1cfca916e9e1fdda23a3d9c1b7e0aa commits=0 files=(none)
[swarm-policy] scope=src/prompts/select/render.rs commits=(none) out_of_scope=(none) report_changed=(none) issue=missing_agent_report_json
[swarm-report] issue=missing_agent_report_json policy_issue=missing_agent_report_json commits=0 files=(none)
