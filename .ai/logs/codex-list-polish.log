==== spawn @ 2026-02-10T05:19:46.236Z ====
cmd: codex "exec" "--cd" "/Users/johnlindquist/dev/script-kit-gpui" "--model" "gpt-5.3-codex" "-c" "model_reasoning_effort=\"xhigh\"" "-c" "model_auto_compact_token_limit=120000" "-c" "developer_instructions=\"You are Codex implementer agent \\\"codex-list-polish\\\".\\n\\n## Coordination\\nThis repo runs parallel agents in ONE working tree. Before editing any file, you MUST claim it.\\nCommands (run via shell):\\n  - View roster: ~/.claude/bin/swarm.ts status\\n  - Claim files (blocks until free): ~/.claude/bin/swarm.ts claim --wait --id codex-list-polish path/to/file\\n  - Release: ~/.claude/bin/swarm.ts release --id codex-list-polish path/to/file\\n  - Update status/notes: ~/.claude/bin/swarm.ts update --id codex-list-polish --status in_progress --notes \\\"...\\\"\\nRules:\\n  - Never edit a file you haven't claimed.\\n  - Keep claims tight (claim only what you're actively changing).\\n  - If blocked, set status=blocked and say what you're waiting on.\\n  - When finished, set status=done and release claims.\\n\\n## Development practices (this code is maintained by AI agents)\\n  - Log state transitions with enough context to diagnose failures from logs alone.\\n  - Structured errors: include what was attempted, what failed, and current state.\\n  - Name things for grepability ‚Äî unique identifiers agents can find on the first search.\\n  - Every behavior change gets a test. Untested code is invisible to the next agent.\\n  - Test names describe the scenario: test_X_does_Y_when_Z.\\n  - Keep functions small and single-purpose. 500-line functions burn agent context.\\n  - Use types to encode constraints (enums > strings for errors).\\n\\n## CRITICAL: Parallel-safe verification\\n  - Other agents are modifying other files RIGHT NOW. Full test suites WILL show their failures.\\n  - ONLY run tests that cover YOUR changed files. Scope every test/check command:\\n    Rust: cargo test -p your-crate -- module::test_name | JS: npx jest your/file.test.ts\\n  - Do NOT run: cargo test (unscoped), cargo check (whole workspace), npm test (unscoped).\\n  - If a scoped test fails, it's YOUR bug ‚Äî fix it. If tests outside your scope fail, ignore them.\\n\\n## Git commit discipline\\n  - NEVER commit unverified work. Run tests/lints/type-checks FIRST. If it fails, fix it before committing.\\n  - A commit is a declaration: \\\"this works and here's the proof.\\\"\\n  - Commit FREQUENTLY ‚Äî after each meaningful unit of VERIFIED work, not just at the end.\\n  - A \\\"unit\\\" = one logical change that passes verification (new function, bug fix, refactor, test added).\\n  - NEVER batch an entire task into one giant commit. Small commits are searchable; big ones aren't.\\n  - Commit message format:\\n      Line 1: <type>(<scope>): <what changed> (imperative, max 72 chars)\\n      Line 3+: WHY this change was made, WHAT was verified, and HOW to test it.\\n    Types: feat, fix, refactor, test, docs, chore\\n    Example:\\n      feat(auth): add refresh token rotation\\n      \\n      Tokens now rotate on each refresh call to prevent replay attacks.\\n      The old token is invalidated immediately on rotation.\\n      \\n      Verified: cargo test --lib -- auth::refresh (4 tests pass)\\n      Verified: manual smoke test via curl ‚Äî token rotates, old token returns 401\\n  - The \\\"Verified:\\\" lines are REQUIRED. Future agents will read git log to understand\\n    what was tested and how to re-verify. This is the most valuable part of the message.\\n  - In your final message, list all commits you made with their hashes.\\n\\n## Time budget\\nYou have approximately 10 minutes. If your task is too broad to complete in time:\\n(1) Commit any verified progress.\\n(2) Run: ~/.claude/bin/swarm.ts update --id YOUR_ID --status needs_split --notes 'suggest: 1) sub-task-desc scope:files 2) sub-task-desc scope:files'.\\n(3) Exit cleanly. The dispatcher will read your suggestions and spawn narrower workers.\"" "--output-last-message" "/Users/johnlindquist/dev/script-kit-gpui/.ai/logs/codex-list-polish.final.md" "--yolo" "You are agent codex-list-polish.\n\nCurrent parallel-agent roster (read this first):\n```\nSWARM SNAPSHOT @ 2026-02-10T05:19:46.228Z\n- codex-list-polish [starting] scope=src/prompts/select/render.rs,src/prompts/select/mod.rs,src/list_item/part_000.rs,src/list_item/part_001.rs task=Polish the main menu list items in the select prompt for a Raycast-quality feel. Make these 4 changes:\n\n1. REAL ICONS: ‚Ä¶\n```\n\nYour assignment:\n- Task: Polish the main menu list items in the select prompt for a Raycast-quality feel. Make these 4 changes:\n\n1. REAL ICONS: In select/render.rs, stop using choice_selection_indicator() as the leading content for single-select mode (\\!this.multiple). Instead, use the item's actual icon (from choice metadata / IconKind / icon_name_from_str pipeline) as LeadingContent. Only show checkmarks when this.multiple is true.\n\n2. ROUNDED FOCUS HIGHLIGHT: Remove per-row .border_b_1().border_color(border_color) separators from rows in select/render.rs. Add .px(px(8.0)) to the choices_container so rows are inset from window edges. Wrap each UnifiedListItem row in .rounded(px(8.0)). For the focused row, use a translucent accent background (accent color with alpha ~0x3A). For hover, use alpha ~0x26.\n\n3. FIX FOCUSED VS SELECTED: In select/render.rs row builder, currently is_selected is set to is_focused. Fix this: compute is_focused and is_selected separately. Focus drives the background highlight; selection drives the checkmark indicator. Pass both correctly to ItemState.\n\n4. HOVER STATES: Add .cursor_pointer() and .hover(|s| s.bg(...)) with a subtle tint on each row wrapper in select/render.rs. Track hovered_index on SelectPrompt state and pass is_hovered to ItemState instead of hardcoding false.\n\nIMPORTANT: Run cargo check && cargo clippy --all-targets -- -D warnings && cargo test after changes. Use theme.colors tokens, never hardcode rgb values.\n- Scope: src/prompts/select/render.rs,src/prompts/select/mod.rs,src/list_item/part_000.rs,src/list_item/part_001.rs\n\nOperating constraints:\n- Single working tree (no worktrees, no patches).\n- You MUST claim files before editing (~/.claude/bin/swarm.ts claim --wait ...).\n\nDeliverables:\n- Make the code changes required by the task.\n- Run the most relevant tests/linters.\n- In your FINAL message, include: changed files, how to test, and any risks/known gaps."

OpenAI Codex v0.98.0 (research preview)
--------
workdir: /Users/johnlindquist/dev/script-kit-gpui
model: gpt-5.3-codex
provider: openai
approval: never
sandbox: danger-full-access
reasoning effort: xhigh
reasoning summaries: auto
session id: 019c45fd-cc9b-7c11-81ef-a7aae9043925
--------
user
You are agent codex-list-polish.

Current parallel-agent roster (read this first):
```
SWARM SNAPSHOT @ 2026-02-10T05:19:46.228Z
- codex-list-polish [starting] scope=src/prompts/select/render.rs,src/prompts/select/mod.rs,src/list_item/part_000.rs,src/list_item/part_001.rs task=Polish the main menu list items in the select prompt for a Raycast-quality feel. Make these 4 changes:

1. REAL ICONS: ‚Ä¶
```

Your assignment:
- Task: Polish the main menu list items in the select prompt for a Raycast-quality feel. Make these 4 changes:

1. REAL ICONS: In select/render.rs, stop using choice_selection_indicator() as the leading content for single-select mode (\!this.multiple). Instead, use the item's actual icon (from choice metadata / IconKind / icon_name_from_str pipeline) as LeadingContent. Only show checkmarks when this.multiple is true.

2. ROUNDED FOCUS HIGHLIGHT: Remove per-row .border_b_1().border_color(border_color) separators from rows in select/render.rs. Add .px(px(8.0)) to the choices_container so rows are inset from window edges. Wrap each UnifiedListItem row in .rounded(px(8.0)). For the focused row, use a translucent accent background (accent color with alpha ~0x3A). For hover, use alpha ~0x26.

3. FIX FOCUSED VS SELECTED: In select/render.rs row builder, currently is_selected is set to is_focused. Fix this: compute is_focused and is_selected separately. Focus drives the background highlight; selection drives the checkmark indicator. Pass both correctly to ItemState.

4. HOVER STATES: Add .cursor_pointer() and .hover(|s| s.bg(...)) with a subtle tint on each row wrapper in select/render.rs. Track hovered_index on SelectPrompt state and pass is_hovered to ItemState instead of hardcoding false.

IMPORTANT: Run cargo check && cargo clippy --all-targets -- -D warnings && cargo test after changes. Use theme.colors tokens, never hardcode rgb values.
- Scope: src/prompts/select/render.rs,src/prompts/select/mod.rs,src/list_item/part_000.rs,src/list_item/part_001.rs

Operating constraints:
- Single working tree (no worktrees, no patches).
- You MUST claim files before editing (~/.claude/bin/swarm.ts claim --wait ...).

Deliverables:
- Make the code changes required by the task.
- Run the most relevant tests/linters.
- In your FINAL message, include: changed files, how to test, and any risks/known gaps.
warning: Under-development features enabled: responses_websockets. Under-development features are incomplete and may behave unpredictably. To suppress this warning, set `suppress_unstable_features_warning = true` in /Users/johnlindquist/.codex/config.toml.
mcp: deepwiki starting
mcp: deepwiki ready
mcp startup: ready: deepwiki

thinking
**Resolving test command conflicts**
codex
I‚Äôm taking the `codex-list-polish` task and will first sync swarm status, then inspect the four scoped files to implement the icon, focus/selection, and hover-state changes safely.

thinking
**Choosing sequential update flow**
exec
/bin/zsh -lc '~/.claude/bin/swarm.ts status && ~/.claude/bin/swarm.ts update --id codex-list-polish --status in_progress --notes "Implementing select list polish: icons, rounded focus/hover, focused-vs-selected, hovered_index wiring"' in /Users/johnlindquist/dev/script-kit-gpui succeeded in 51ms:
Repo: /Users/johnlindquist/dev/script-kit-gpui
Updated: 2026-02-10T05:19:58.696Z

Active agents (1):
codex-list-polish [in_progress] codex/gpt-5.3-codex/exec
  task: Polish the main menu list items in the select prompt for a Raycast-quality feel. Make these 4 changes:

1. REAL ICONS: ‚Ä¶
  scope: src/prompts/select/render.rs,src/prompts/select/mod.rs,src/list_item/part_000.rs,src/list_item/part_001.rs
  claims: (none)
  notes: spawned codex (exec)

Inactive agents (277):
- codex-accessibility [done] done. exit=0. final=.ai/logs/codex-accessibility.final.md. See final message file.
- codex-action-labels [failed] failed. exit=1. final=.ai/logs/codex-action-labels.final.md.
- codex-actions-audit [failed] failed. exit=1. final=.ai/logs/codex-actions-audit.final.md. See final message file.
- codex-actions-consistency [failed] failed. exit=1. final=.ai/logs/codex-actions-consistency.final.md.
- codex-actions-dialog [done] done. exit=0. final=.ai/logs/codex-actions-dialog.final.md. See final message file.
- codex-actions-feedback [failed] failed. exit=1. final=.ai/logs/codex-actions-feedback.final.md.
- codex-actions-feedback-v2 [done] done. exit=0. final=.ai/logs/codex-actions-feedback-v2.final.md. See final message file.

thinking
**Preparing to claim files**
codex
Next I‚Äôm claiming the four scoped files, then I‚Äôll read current select/list-item rendering to map exact state and icon flow before editing.
exec
/bin/zsh -lc '~/.claude/bin/swarm.ts claim --wait --id codex-list-polish src/prompts/select/render.rs && ~/.claude/bin/swarm.ts claim --wait --id codex-list-polish src/prompts/select/mod.rs && ~/.claude/bin/swarm.ts claim --wait --id codex-list-polish src/list_item/part_000.rs && ~/.claude/bin/swarm.ts claim --wait --id codex-list-polish src/list_item/part_001.rs' in /Users/johnlindquist/dev/script-kit-gpui succeeded in 51ms:
Claimed for codex-list-polish: src/prompts/select/render.rs
Claimed for codex-list-polish: src/prompts/select/mod.rs
Claimed for codex-list-polish: src/list_item/part_000.rs
Claimed for codex-list-polish: src/list_item/part_001.rs

thinking
**Planning parallel file scanning**
codex
I‚Äôve secured the claims. I‚Äôm now scanning for `choice_selection_indicator`, `ItemState` wiring, and hover/focus state handling so the changes stay minimal and targeted.
exec
/bin/zsh -lc "sed -n '1,260p' src/prompts/select/render.rs" in /Users/johnlindquist/dev/script-kit-gpuiexec
/bin/zsh -lc "rg -n \"choice_selection_indicator|is_selected|is_focused|hovered_index|ItemState|choices_container|border_b_1|cursor_pointer|hover\\(\" src/prompts/select/render.rs src/prompts/select/mod.rs src/list_item/part_000.rs src/list_item/part_001.rs" in /Users/johnlindquist/dev/script-kit-gpuiexec
/bin/zsh -lc "sed -n '1,260p' src/prompts/select/mod.rs" in /Users/johnlindquist/dev/script-kit-gpui succeeded in 51ms:
use super::*;

impl Focusable for SelectPrompt {
    fn focus_handle(&self, _cx: &gpui::App) -> FocusHandle {
        self.focus_handle.clone()
    }
}

impl Render for SelectPrompt {
    fn render(&mut self, _window: &mut Window, cx: &mut Context<Self>) -> impl IntoElement {
        let tokens = get_tokens(self.design_variant);
        let colors = tokens.colors();
        let spacing = tokens.spacing();

        let handle_key = cx.listener(
            |this: &mut Self,
             event: &gpui::KeyDownEvent,
             _window: &mut Window,
             cx: &mut Context<Self>| {
                let key_str = event.keystroke.key.to_lowercase();
 succeeded in 51ms:
src/list_item/part_001.rs:175:    /// Whether to enable instant hover effects (via GPUI .hover() pseudo-class)
src/list_item/part_001.rs:176:    /// When false, the .hover() modifier is not applied, preventing visual feedback
src/list_item/part_001.rs:234:    /// Enable or disable instant hover effects (GPUI .hover() pseudo-class)
src/list_item/part_001.rs:250:    pub fn on_hover(mut self, callback: OnHoverCallback) -> Self {
src/prompts/select/render.rs:99:            .border_b_1()
src/prompts/select/render.rs:157:                                        let is_focused = display_idx == this.focused_index;
src/prompts/select/render.rs:158:                                        let is_selected = this.selected.contains(&choice_idx);
src/prompts/select/render.rs:159:                                        let is_selected_for_ui = if this.multiple {
src/prompts/select/render.rs:160:                                            is_selected
src/prompts/select/render.rs:162:                                            is_focused
src/prompts/select/render.rs:168:                                        let indicator = choice_selection_indicator(
src/prompts/select/render.rs:170:                                            is_selected_for_ui,
src/prompts/select/render.rs:194:                                                .border_b_1()
src/prompts/select/render.rs:206:                                                    .state(ItemState {
src/prompts/select/render.rs:207:                                                        is_selected: is_focused,
src/prompts/select/render.rs:213:                                                    .with_accent_bar(is_selected_for_ui),
src/prompts/select/render.rs:231:        let choices_container = div()
src/prompts/select/render.rs:251:            .child(choices_container)
src/prompts/select/mod.rs:18:    Density, ItemState, LeadingContent, TextContent, TrailingContent, UnifiedListItem,
 succeeded in 52ms:
//! SelectPrompt - Multi-select from choices
//!
//! Features:
//! - Select multiple items from a list
//! - Toggle selection with Cmd/Ctrl+Space
//! - Filter choices by typing
//! - Submit selected items

use gpui::{
    div, prelude::*, px, rgb, uniform_list, AnyElement, Context, FocusHandle, Focusable, Render,
    ScrollStrategy, SharedString, UniformListScrollHandle, Window,
};
use std::collections::HashSet;
use std::ops::Range;
use std::sync::Arc;

use crate::components::{
    Density, ItemState, LeadingContent, TextContent, TrailingContent, UnifiedListItem,
    UnifiedListItemColors,
};

thinking
**Inspecting list item components**
exec
/bin/zsh -lc "sed -n '1,280p' src/list_item/part_000.rs" in /Users/johnlindquist/dev/script-kit-gpuiexec
/bin/zsh -lc "sed -n '1,360p' src/list_item/part_001.rs" in /Users/johnlindquist/dev/script-kit-gpui succeeded in 51ms:
use crate::designs::icon_variations::{icon_name_from_str, IconName};
use crate::logging;
use crate::ui_foundation::HexColorExt;
use gpui::*;
use std::collections::HashSet;
use std::sync::Arc;
/// Icon type for list items - supports emoji strings, SVG icons, and pre-decoded images
#[derive(Clone)]
pub enum IconKind {
    /// Text/emoji icon (e.g., "üìú", "‚ö°")
    Emoji(String),
    /// Pre-decoded render image (for app icons) - MUST be pre-decoded, not raw PNG bytes
    Image(Arc<RenderImage>),
    /// SVG icon by name (e.g., "File", "Terminal", "Code")
    /// Maps to IconName from designs::icon_variations
    Svg(String),
}
/// Fixed height for list items used in uniform-height virtualized lists.
///
/// IMPORTANT: When using GPUI `uniform_list`, the item closure must render
 succeeded in 50ms:
impl ListItemColors {
    /// Create from theme reference
    pub fn from_theme(theme: &crate::theme::Theme) -> Self {
        let opacity = theme.get_opacity();
        Self {
            text_primary: theme.colors.text.primary,
            text_secondary: theme.colors.text.secondary,
            text_muted: theme.colors.text.muted,
            text_dimmed: theme.colors.text.dimmed,
            accent_selected: theme.colors.accent.selected,
            accent_selected_subtle: theme.colors.accent.selected_subtle,
            background: theme.colors.background.main,
            background_selected: theme.colors.accent.selected_subtle,
            selected_opacity: opacity.selected,
            hover_opacity: opacity.hover,
            warning_bg: theme.colors.ui.warning,
            // White text provides good contrast on warning/accent backgrounds in dark themes
            text_on_accent: theme.colors.text.primary,
        }
    }

thinking
**Searching for struct definitions**
exec
/bin/zsh -lc "rg -n \"struct ItemState|is_hovered|with_accent_bar|LeadingContent|choice_selection_indicator|IconKind|icon_name_from_str|UnifiedListItem\" src/components src/list_item src/prompts/select -g'*.rs'" in /Users/johnlindquist/dev/script-kit-gpui succeeded in 51ms:
src/list_item/part_000.rs:1:use crate::designs::icon_variations::{icon_name_from_str, IconName};
src/list_item/part_000.rs:9:pub enum IconKind {
src/list_item/part_001.rs:162:    icon: Option<IconKind>,
src/list_item/part_001.rs:229:    pub fn with_accent_bar(mut self, show: bool) -> Self {
src/list_item/part_001.rs:249:    /// The callback receives (index, is_hovered) where is_hovered is true when entering.
src/list_item/part_001.rs:294:        self.icon = Some(IconKind::Emoji(i.into()));
src/list_item/part_001.rs:300:        self.icon = i.map(IconKind::Emoji);
src/list_item/part_001.rs:306:        self.icon = Some(IconKind::Image(image));
src/list_item/part_001.rs:312:        self.icon = image.map(IconKind::Image);
src/list_item/part_001.rs:316:    /// Set icon from IconKind enum (for mixed icon types)
src/list_item/part_001.rs:317:    pub fn icon_kind(mut self, kind: IconKind) -> Self {
src/list_item/part_001.rs:322:    /// Set an optional icon from IconKind
src/list_item/part_001.rs:323:    pub fn icon_kind_opt(mut self, kind: Option<IconKind>) -> Self {
src/prompts/select/search.rs:152:pub(super) fn choice_selection_indicator(is_multiple: bool, is_selected: bool) -> &'static str {
src/list_item/part_003.rs:34:/// Create an IconKind from PNG bytes by pre-decoding them
src/list_item/part_003.rs:38:pub fn icon_from_png(png_data: &[u8]) -> Option<IconKind> {
src/list_item/part_003.rs:41:        .map(IconKind::Image)
src/list_item/part_003.rs:99:        if let Some(icon_name) = icon_name_from_str(name) {
src/components/mod.rs:93:    Density, ItemState, LeadingContent, ListItemLayout, SectionHeader, TextContent,
src/components/mod.rs:94:    TrailingContent, UnifiedListItem, UnifiedListItemColors, SECTION_HEADER_HEIGHT,

thinking
**Inspecting selection state definitions**
exec
/bin/zsh -lc "sed -n '1,280p' src/prompts/select/types.rs" in /Users/johnlindquist/dev/script-kit-gpuiexec
/bin/zsh -lc "sed -n '1,260p' src/prompts/select/search.rs" in /Users/johnlindquist/dev/script-kit-gpuiexec
/bin/zsh -lc "sed -n '1,260p' src/components/unified_list_item/types.rs" in /Users/johnlindquist/dev/script-kit-gpuiexec
/bin/zsh -lc "sed -n '1,260p' src/components/unified_list_item/render.rs" in /Users/johnlindquist/dev/script-kit-gpui succeeded in 50ms:
use super::*;

#[derive(Debug, Clone, Default, PartialEq, Eq)]
pub(super) struct ChoiceDisplayMetadata {
    pub(super) description: Option<String>,
    pub(super) item_type: Option<String>,
    pub(super) shortcut: Option<String>,
    pub(super) last_run: Option<String>,
}

#[derive(Debug, Clone)]
pub(super) struct SelectChoiceIndex {
    pub(super) metadata: ChoiceDisplayMetadata,
    pub(super) name_lower: String,
    pub(super) description_lower: String,
    pub(super) value_lower: String,
    pub(super) item_type_lower: String,
    pub(super) last_run_lower: String,
    pub(super) shortcut_lower: String,
    pub(super) stable_semantic_id: String,
 succeeded in 51ms:
//! Type definitions for UnifiedListItem.

// Allow dead_code - this is new code not yet integrated into the main app
#![allow(dead_code)]

use gpui::*;
use std::ops::Range;
use std::sync::Arc;

/// A precomputed text segment for highlighted content rendering.
#[derive(Clone, Debug, PartialEq, Eq)]
pub struct HighlightFragment {
    pub text: SharedString,
    pub is_highlighted: bool,
}

// =============================================================================
// TextContent - Title/Subtitle with optional highlight ranges
// =============================================================================

 succeeded in 51ms:
use super::*;

fn score_field(
    nucleo: &mut scripts::NucleoCtx,
    haystack: &str,
    haystack_lower: &str,
    query_lower: &str,
    field_boost: u32,
) -> Option<u32> {
    if haystack.is_empty() {
        return None;
    }

    let mut score = nucleo.score(haystack)?;

    if haystack_lower == query_lower {
        score += 600;
    } else if haystack_lower.starts_with(query_lower) {
        score += 320;
    } else if haystack_lower.contains(query_lower) {
 succeeded in 51ms:
//! Render implementation for UnifiedListItem.

// Allow dead_code - this is new code not yet integrated into the main app
#![allow(dead_code)]

use gpui::prelude::FluentBuilder;
use gpui::*;

use crate::designs::icon_variations::{icon_name_from_str, IconName};

use super::types::*;

// =============================================================================
// UnifiedListItem - The main component
// =============================================================================

/// A unified, presentational list item component.
#[derive(IntoElement)]
pub struct UnifiedListItem {
    id: ElementId,

thinking
**Reviewing icon mapping logic**
exec
/bin/zsh -lc "rg -n \"pub struct Choice|icon|icon_name|img|emoji|has_preview|\" src/protocol -g'*.rs'" in /Users/johnlindquist/dev/script-kit-gpui succeeded in 52ms:
Total output lines: 6682

src/protocol/semantic_id.rs:1://! Semantic ID generation for AI-driven UX targeting
src/protocol/semantic_id.rs:2://!
src/protocol/semantic_id.rs:3://! Provides functions to generate semantic IDs for UI elements that can be
src/protocol/semantic_id.rs:4://! used by AI agents to target specific elements in the interface.
src/protocol/semantic_id.rs:5:
src/protocol/semantic_id.rs:6:/// Generate a semantic ID for an element.
src/protocol/semantic_id.rs:7:///
src/protocol/semantic_id.rs:8:/// Format: {type}:{index}:{value_slug}
src/protocol/semantic_id.rs:9:///
src/protocol/semantic_id.rs:10:/// # Arguments
src/protocol/semantic_id.rs:11:/// * `element_type` - The element type (e.g., "choice", "button", "input")
src/protocol/semantic_id.rs:12:/// * `index` - The numeric index of the element
src/protocol/semantic_id.rs:13:/// * `value` - The value to convert to a slug
src/protocol/semantic_id.rs:14:///
src/protocol/semantic_id.rs:15:/// # Returns
src/protocol/semantic_id.rs:16:/// A semantic ID string in the format: type:index:slug
src/protocol/semantic_id.rs:17:pub fn generate_semantic_id(element_type: &str, index: usize, value: &str) -> String {
src/protocol/semantic_id.rs:18:    let slug = value_to_slug(value);

thinking
**Refining search scope**
codex
I found the key render hotspots. I‚Äôm now narrowing into `Choice`/icon fields and existing icon conversion helpers so single-select rows can use real metadata icons instead of radio glyphs.
exec
/bin/zsh -lc "rg -n \"struct Choice\" src/protocol -g'*.rs'" in /Users/johnlindquist/dev/script-kit-gpuiexec
/bin/zsh -lc "rg -n \"enum Icon|icon:\" src/protocol -g'*.rs'" in /Users/johnlindquist/dev/script-kit-gpuiexec
/bin/zsh -lc "rg -n \"icon_name_from_str|IconKind::Svg|LeadingContent::Icon|leading\\(\" src/prompts src/list_item src/components -g'*.rs'" in /Users/johnlindquist/dev/script-kit-gpui succeeded in 50ms:
src/protocol/types/primitives.rs:116:pub struct Choice {
 succeeded in 52ms:
src/protocol/message/constructors/general.rs:277:    pub fn menu(icon: Option<String>, scripts: Option<Vec<String>>) -> Self {
src/protocol/message/variants/system_control.rs:12:        icon: Option<String>,
 succeeded in 51ms:
src/list_item/part_000.rs:1:use crate::designs::icon_variations::{icon_name_from_str, IconName};
src/list_item/part_002.rs:54:            Some(IconKind::Svg(name)) => {
src/list_item/part_002.rs:57:                if let Some(icon_name) = icon_name_from_str(name) {
src/list_item/part_003.rs:99:        if let Some(icon_name) = icon_name_from_str(name) {
src/components/unified_list_item/render.rs:9:use crate::designs::icon_variations::{icon_name_from_str, IconName};
src/components/unified_list_item/render.rs:61:    pub fn leading(mut self, leading: LeadingContent) -> Self {
src/components/unified_list_item/render.rs:140:        let leading_element = render_leading(&self.leading, &layout, &colors, state.is_selected);
src/components/unified_list_item/render.rs:223:fn render_leading(
src/components/unified_list_item/render.rs:248:        Some(LeadingContent::Icon { name, color }) => {
src/components/unified_list_item/render.rs:250:            let svg_path = icon_name_from_str(name)
src/prompts/select/render.rs:202:                                                    .leading(LeadingContent::Emoji(
exec
/bin/zsh -lc "sed -n '80,220p' src/protocol/types/primitives.rs" in /Users/johnlindquist/dev/script-kit-gpui succeeded in 52ms:
}

impl From<String> for SubmitValue {
    fn from(s: String) -> Self {
        SubmitValue::Text(s)
    }
}

impl From<&str> for SubmitValue {
    fn from(s: &str) -> Self {
        SubmitValue::Text(s.to_string())
    }
}

impl From<serde_json::Value> for SubmitValue {
    fn from(v: serde_json::Value) -> Self {
        // If it's a string JSON value, convert to Text for consistency
        if let serde_json::Value::String(s) = v {
            SubmitValue::Text(s)
        } else {

thinking
**Investigating icon retrieval for choices**
exec
/bin/zsh -lc "rg -n \"Choice.*icon|icon.*Choice|choice.*IconKind|metadata.*icon|icon_kind\" src -g'*.rs'" in /Users/johnlindquist/dev/script-kit-gpuiexec
/bin/zsh -lc "rg -n \"IconKind::|icon_name_from_str\\(|leading_content|leading\\(\" src/prompts -g'*.rs'" in /Users/johnlindquist/dev/script-kit-gpui succeeded in 51ms:
src/prompts/select/render.rs:202:                                                    .leading(LeadingContent::Emoji(
src/prompts/path/render.rs:98:                            IconKind::Emoji("üìÅ".to_string())
src/prompts/path/render.rs:100:                            IconKind::Emoji("üìÑ".to_string())
 succeeded in 52ms:
src/scriptlet_metadata/part_000.rs:218:            "icon" => metadata.icon = Some(value),
src/scriptlet_metadata/tests/part_000.rs:90:        assert_eq!(metadata.icon, Some("CheckSquare".to_string()));
src/prompts/path/render.rs:109:                            .icon_kind(icon)
src/scriptlet_tests/chunk_07.rs:125:    let metadata = ScriptletMetadata::default(); // No icon in metadata
src/scriptlet_tests/chunk_07.rs:132:    // Frontmatter should be used when no metadata icon
src/scripts/loader.rs:103:                                                icon: script_metadata.icon,
src/list_item/part_001.rs:317:    pub fn icon_kind(mut self, kind: IconKind) -> Self {
src/list_item/part_001.rs:323:    pub fn icon_kind_opt(mut self, kind: Option<IconKind>) -> Self {
src/designs/core/part_02.rs:68:            let (name, description, shortcut, icon_kind) = match result {
src/designs/core/part_02.rs:221:                .icon_kind_opt(icon_kind)
src/scripts/tests/chunk_05.rs:141:    assert_eq!(metadata.icon, Some("Terminal".to_string()));
src/scripts/metadata.rs:73:                    if metadata.icon.is_none() && !value.is_empty() {
src/scripts/metadata.rs:74:                        metadata.icon = Some(value);
src/scriptlets/part_000.rs:117:/// 1. Scriptlet-level metadata icon
src/scriptlets/part_000.rs:127:    if let Some(icon) = metadata.extra.get("icon") {
src/scriptlets/tests/chunk_07.rs:125:    let metadata = ScriptletMetadata::default(); // No icon in metadata
src/scriptlets/tests/chunk_07.rs:132:    // Frontmatter should be used when no metadata icon
src/scripts_tests/chunk_05.rs:141:    assert_eq!(metadata.icon, Some("Terminal".to_string()));
src/render_builtins/app_launcher.rs:280:                                            .icon_kind(icon)
src/stories/run_button_exploration/split/part_02.rs:233:                        "41. Choice: check icon",

thinking
**Inspecting icon pipeline source**
exec
/bin/zsh -lc "sed -n '1,240p' src/prompts/path/render.rs" in /Users/johnlindquist/dev/script-kit-gpui succeeded in 50ms:
use super::*;

impl Focusable for PathPrompt {
    fn focus_handle(&self, _cx: &gpui::App) -> FocusHandle {
        self.focus_handle.clone()
    }
}

impl EventEmitter<PathPromptEvent> for PathPrompt {}

impl Render for PathPrompt {
    fn render(&mut self, _window: &mut Window, cx: &mut Context<Self>) -> impl IntoElement {
        let handle_key = cx.listener(
            |this: &mut Self,
             event: &gpui::KeyDownEvent,
             _window: &mut Window,
             cx: &mut Context<Self>| {
                let key_str = event.keystroke.key.to_lowercase();
                let has_cmd = event.keystroke.modifiers.platform;


thinking
**Inspecting prompt choice metadata**
exec
/bin/zsh -lc "sed -n '1,340p' src/prompts/select/prompt.rs" in /Users/johnlindquist/dev/script-kit-gpuiexec
/bin/zsh -lc "sed -n '340,760p' src/prompts/select/prompt.rs" in /Users/johnlindquist/dev/script-kit-gpui succeeded in 51ms:
use super::*;

/// SelectPrompt - Multi-select from choices
///
/// Allows selecting multiple items from a list of choices.
/// Use Cmd/Ctrl+Space to toggle selection, Enter to submit selected items.
pub struct SelectPrompt {
    /// Unique ID for this prompt instance
    pub id: String,
    /// Placeholder text for the search input
    pub placeholder: Option<String>,
    /// Available choices
    pub choices: Vec<Choice>,
    /// Cached searchable/indexed choice data to reduce refilter work
    pub(super) choice_index: Vec<SelectChoiceIndex>,
    /// Indices of selected choices
    pub selected: HashSet<usize>,
    /// Filtered choice indices (for display)
    pub filtered_choices: Vec<usize>,
    /// Currently focused index in filtered list
 succeeded in 51ms:


thinking
**Investigating icon metadata parsing**
exec
/bin/zsh -lc "sed -n '1,220p' src/list_item/part_003.rs" in /Users/johnlindquist/dev/script-kit-gpui succeeded in 51ms:
fn decode_png_to_render_image_internal(
    png_data: &[u8],
    convert_to_bgra: bool,
) -> Result<Arc<RenderImage>, image::ImageError> {
    use image::GenericImageView;
    use smallvec::SmallVec;

    // Decode PNG
    let img = image::load_from_memory(png_data)?;

    // Convert to RGBA8
    let mut rgba = img.to_rgba8();
    let (width, height) = img.dimensions();

    // Convert RGBA to BGRA for Metal/GPUI rendering
    // GPUI's internal image loading does this swap (see gpui/src/platform.rs)
    // We must do the same when creating RenderImage directly from image::Frame
    if convert_to_bgra {
        for pixel in rgba.chunks_exact_mut(4) {
            pixel.swap(0, 2); // Swap R and B: RGBA -> BGRA

thinking
**Inspecting icon rendering logic**
exec
/bin/zsh -lc "sed -n '1,220p' src/list_item/part_002.rs" in /Users/johnlindquist/dev/script-kit-gpui succeeded in 51ms:
impl RenderOnce for ListItem {
    fn render(self, _window: &mut Window, _cx: &mut App) -> impl IntoElement {
        let colors = self.colors;
        let index = self.index;
        let on_hover_callback = self.on_hover;
        let semantic_id = self.semantic_id;

        // Selection colors with alpha from theme opacity settings
        // This allows vibrancy blur to show through selected/hovered items
        // Use rgba8() helper (same pattern as footer) to ensure consistent Hsla conversion
        let selected_alpha = (colors.selected_opacity * 255.0) as u8;
        let hover_alpha = (colors.hover_opacity * 255.0) as u8;
        let selected_bg = colors.accent_selected_subtle.rgba8(selected_alpha);
        let hover_bg = colors.accent_selected_subtle.rgba8(hover_alpha);

        // Icon element (if present) - displayed on the left
        // Supports both emoji strings and PNG image data
        // Icons use slightly muted color to maintain text hierarchy
        let icon_text_color = if self.selected {
            rgb(colors.text_primary)

thinking
**Analyzing icon handling in selection rendering**
codex
I confirmed `Choice` currently has no direct icon field in protocol primitives, so I‚Äôm checking existing metadata parsing/inference helpers to derive icons through the existing `IconKind` + icon-name pipeline for select rows.
exec
/bin/zsh -lc "sed -n '1,340p' src/designs/core/part_02.rs" in /Users/johnlindquist/dev/script-kit-gpuiexec
/bin/zsh -lc "sed -n '1,260p' src/scripts/metadata.rs" in /Users/johnlindquist/dev/script-kit-gpuiexec
/bin/zsh -lc "sed -n '1,260p' src/prompts/select/tests.rs" in /Users/johnlindquist/dev/script-kit-gpui succeeded in 52ms:
///
/// # Arguments
/// * `variant` - The design variant to render
/// * `result` - The search result to render
/// * `index` - The item index (for element ID and alternating styles)
/// * `is_selected` - Whether this item is currently selected (full focus styling)
/// * `is_hovered` - Whether this item is currently hovered (subtle visual feedback)
/// * `list_colors` - Pre-computed theme colors for the default design
/// * `enable_hover_effect` - Whether to enable instant hover effects (false during keyboard navigation)
/// * `filter_text` - Current search filter text (empty when not filtering; used for fuzzy match highlighting)
///
/// # Returns
/// An `AnyElement` containing the rendered item
#[allow(clippy::too_many_arguments)]
pub fn render_design_item(
    variant: DesignVariant,
    result: &SearchResult,
    index: usize,
    is_selected: bool,
    is_hovered: bool,
 succeeded in 51ms:
//! Script metadata extraction
//!
//! This module provides functions for extracting metadata from script files,
//! including both comment-based metadata (// Name:, // Description:) and
//! typed metadata from `metadata = {...}` declarations.

use std::fs;
use std::path::PathBuf;
use tracing::debug;

use crate::metadata_parser::{extract_typed_metadata, TypedMetadata};
use crate::schema_parser::{extract_schema, Schema};

use super::types::{ScheduleMetadata, ScriptMetadata};

/// Parse a single metadata line with lenient matching
/// Supports patterns like:
/// - "//Name:Value"
/// - "//Name: Value"
/// - "// Name:Value"
 succeeded in 51ms:
use super::*;

fn choice(name: &str, value: &str, description: Option<&str>) -> Choice {
    let mut choice = Choice::new(name.to_string(), value.to_string());
    choice.description = description.map(str::to_string);
    choice
}

#[test]
fn metadata_parses_shortcut_type_and_last_run() {
    let choice = choice(
        "Deploy API",
        "/Users/me/.scriptkit/scripts/deploy.ts",
        Some("Shortcut: cmd+shift+d ‚Ä¢ script ‚Ä¢ Last run 2h ago"),
    );

    let metadata = ChoiceDisplayMetadata::from_choice(&choice);

    assert_eq!(metadata.shortcut.as_deref(), Some("‚åò‚áßD"));
    assert_eq!(metadata.item_type.as_deref(), Some("Script"));

thinking
**Planning test additions and imports**
exec
/bin/zsh -lc "sed -n '1,220p' src/list_item/mod.rs" in /Users/johnlindquist/dev/script-kit-gpui succeeded in 52ms:
//! Shared ListItem component for script list and arg prompt choice list
//!
//! This module provides a reusable, theme-aware list item component that can be
//! used in both the main script list and arg prompt choice lists.

#![allow(dead_code)]

include!("part_000.rs");
include!("part_001.rs");
include!("part_002.rs");
include!("part_003.rs");

thinking
**Clarifying focus vs selection handling**
exec
/bin/zsh -lc "rg -n \"on_mouse_enter|on_mouse_leave|on_hover|hover\\(|cursor_pointer\\(|on_mouse_move|on_mouse_down|on_click\" src -g'*.rs'" in /Users/johnlindquist/dev/script-kit-gpui succeeded in 52ms:
Total output lines: 747

src/app_actions/tests/actions_button_visibility.rs:58:    fn test_ask_ai_hint_is_non_clickable_visual_hint() {
src/app_actions/tests/actions_button_visibility.rs:73:            !ask_ai_section.contains(".cursor_pointer()"),
src/editor/part_001_impl/methods_002.rs:152:                        .cursor_pointer()
src/list_item/part_001.rs:170:    on_hover: Option<OnHoverCallback>,
src/list_item/part_001.rs:175:    /// Whether to enable instant hover effects (via GPUI .hover() pseudo-class)
src/list_item/part_001.rs:176:    /// When false, the .hover() modifier is not applied, preventing visual feedback
src/list_item/part_001.rs:216:            on_hover: None,
src/list_item/part_001.rs:234:    /// Enable or disable instant hover effects (GPUI .hover() pseudo-class)
src/list_item/part_001.rs:250:    pub fn on_hover(mut self, callback: OnHoverCallback) -> Self {
src/list_item/part_001.rs:251:        self.on_hover = Some(callback);
src/list_item/part_002.rs:5:        let on_hover_callback = self.on_hover;
src/list_item/part_002.rs:288:        // Note: For non-selected items, we ALSO apply GPUI's .hover() modifier for instant feedback
src/list_item/part_002.rs:300:        // HOVER TRANSITIONS: We use GPUI's built-in .hover() modifier for instant visual
src/list_item/part_002.rs:313:            .cursor_pointer()
src/list_item/part_002.rs:382:            inner_content = inner_content.hover(move |s| s.bg(hover_bg));
src/list_item/part_002.rs:425:        if let (Some(idx), Some(callback)) = (index, on_hover_callback) {
src/list_item/part_002.rs:429:            container = container.on_hover(move |hovered: &bool, _window, _cx| {
src/warning_banner.rs:83:    on_click: Option<Rc<OnClickCallback>>,

thinking
**Inspecting on_hover usage**
exec
/bin/zsh -lc "sed -n '330,450p' src/render_script_list/part_000.rs" in /Users/johnlindquist/dev/script-kit-gpui succeeded in 51ms:
                                                {
                                                    if mouse_event.down.click_count == 2 {
                                                        logging::log(
                                                            "UI",
                                                            &format!(
                                                                "Double-click on item {}, executing",
                                                                ix
                                                            ),
                                                        );
                                                        this.execute_selected(cx);
                                                    }
                                                }
                                            },
                                        );

                                        // Dispatch to design-specific item renderer
                                        // Note: Confirmation for dangerous builtins is now handled
                                        // via modal dialog, not inline overlay
                                        let design_render_start = std::time::Instant::now();
                                        // Enable hover effects only when in Mouse mode

thinking
**Investigating hover handler usage**
exec
/bin/zsh -lc "sed -n '250,350p' src/render_script_list/part_000.rs" in /Users/johnlindquist/dev/script-kit-gpui succeeded in 52ms:
            let filter_for_closure = self.filter_text.clone();
            let filter_for_highlight = self.filter_text.clone();

            let variable_height_list =
                list(self.main_list_state.clone(), move |ix, _window, cx| {
                    let _item_render_start = std::time::Instant::now();

                    // Access entity state inside the closure
                    entity.update(cx, |this, cx| {
                        let current_selected = this.selected_index;
                        let current_hovered = this.hovered_index;
                        let current_input_mode = this.input_mode;

                        if let Some(grouped_item) = grouped_items_clone.get(ix) {
                            match grouped_item {
                                GroupedListItem::SectionHeader(label, icon) => {
                                    // Section header at 32px height (8px grid) for clear visual separation
                                    div()
                                        .id(ElementId::NamedInteger(
                                            "section-header".into(),

thinking
**Planning hover state and icon parsing**
exec
/bin/zsh -lc "rg -n \"SelectPrompt::new|type\\\":\\\"select\\\"|Prompt::Select|multiple\" src -g'*.rs'" in /Users/johnlindquist/dev/script-kit-gpui succeeded in 51ms:
Total output lines: 426

src/menu_cache/part_000.rs:29:/// This function is idempotent - it's safe to call multiple times.
src/scriptlet_metadata/tests/part_000.rs:162:    fn test_simple_format_multiple_fields() {
src/scriptlet_metadata/tests/part_000.rs:242:    fn test_multiple_code_blocks_first_wins() {
src/scriptlet_metadata/tests/part_001.rs:116:    fn test_multiple_errors_collected() {
src/app_actions/handle_action.rs:212:    /// focus fields (`pending_focus`) in multiple places.
src/app_actions/handle_action.rs:1575:            "clipboard_delete_multiple" => {
src/syntax.rs:300:        // Should produce multiple spans with different colors
src/syntax.rs:420:            "Expected syntax highlighting to produce multiple colors"
src/app_actions/handle_action/main_actions_04.rs:1:            "clipboard_delete_multiple" => {
src/frontmost_app_tracker/part_000.rs:62:/// Safe to call multiple times - subsequent calls are no-ops.
src/app_actions/tests/clipboard_actions.rs:10:fn clipboard_delete_multiple_requires_confirmation_before_delete() {
src/app_actions/tests/clipboard_actions.rs:14:        content.contains("\"clipboard_delete_multiple\""),
src/app_actions/tests/clipboard_actions.rs:15:        "Expected app_actions.rs to handle clipboard_delete_multiple"
src/app_actions/tests/clipboard_actions.rs:20:        "Expected clipboard_delete_multiple to show a count-aware confirmation message"
src/app_actions/tests/clipboard_actions.rs:24:        "Expected clipboard_delete_multiple to use confirmation modal via open_confirm_window"
src/logging/part_001.rs:257:/// so callers cannot accidentally drop it. Safe to call multiple times (subsequent
src/notification/mod.rs:3://! Centralized notification system supporting multiple delivery channels
src/editor/part_000.rs:82:/// Shown when a tabstop has multiple choices (${1|opt1,opt2,opt3|})

thinking
**Inspecting prompt choice construction**
exec
/bin/zsh -lc "rg -n \"SelectPrompt::new\\(|PromptData::Select|choices\" src/execute_script -g'*.rs'" in /Users/johnlindquist/dev/script-kit-gpui succeeded in 50ms:
src/execute_script/part_001_body/ok_some_005.rs:5:                                        choices,
src/execute_script/part_001_body/ok_some_005.rs:10:                                        choices,
src/execute_script/part_001_body/ok_some_005.rs:91:                                        choices,
src/execute_script/part_001_body/ok_some_005.rs:96:                                        choices,
src/execute_script/part_001_body/execute_interactive_merged.rs:1157:                                        choices,
src/execute_script/part_001_body/execute_interactive_merged.rs:1162:                                        choices,
src/execute_script/part_001_body/execute_interactive_merged.rs:1243:                                        choices,
src/execute_script/part_001_body/execute_interactive_merged.rs:1248:                                        choices,
exec
/bin/zsh -lc "sed -n '1120,1215p' src/execute_script/part_001_body/execute_interactive_merged.rs" in /Users/johnlindquist/dev/script-kit-gpui succeeded in 52ms:
                                                hi_dpi = hi_dpi_mode,
                                                data_len = base64_data.len(),
                                                "Screenshot captured successfully"
                                            );
                                            Message::screenshot_result(
                                                request_id.clone(),
                                                base64_data,
                                                width,
                                                height,
                                            )
                                        }
                                        Err(e) => {
                                            tracing::error!(
                                                request_id = %request_id,
                                                error = %e,
                                                "Screenshot capture failed"
                                            );
                                            // Send empty result on error
                                            Message::screenshot_result(
                                                request_id.clone(),
exec
/bin/zsh -lc "sed -n '1215,1290p' src/execute_script/part_001_body/execute_interactive_merged.rs" in /Users/johnlindquist/dev/script-kit-gpui succeeded in 51ms:
                                    Message::Path {
                                        id,
                                        start_path,
                                        hint,
                                    } => Some(PromptMessage::ShowPath {
                                        id,
                                        start_path,
                                        hint,
                                    }),
                                    Message::Env { id, key, secret } => {
                                        Some(PromptMessage::ShowEnv {
                                            id,
                                            key,
                                            prompt: None,
                                            secret: secret.unwrap_or(false),
                                        })
                                    }
                                    Message::Drop { id } => Some(PromptMessage::ShowDrop {
                                        id,
                                        placeholder: None,

thinking
**Planning icon extraction from metadata**
exec
/bin/zsh -lc "sed -n '120,260p' src/stories/select_prompt_stories/split/part_01.rs" in /Users/johnlindquist/dev/script-kit-gpui succeeded in 51ms:
    div()
        .w_full()
        .px_3()
        .py_2()
        .bg(rgb(BG_SEARCH))
        .border_b_1()
        .border_color(rgb(BORDER_COLOR))
        .flex()
        .flex_row()
        .gap_2()
        .items_center()
        .child(div().text_color(rgb(TEXT_MUTED)).child("üîç"))
        .child(
            div()
                .flex_1()
                .text_color(if filter.is_empty() {
                    rgb(TEXT_MUTED)
                } else {
                    rgb(TEXT_PRIMARY)
                })

thinking
**Inspecting choice icon metadata**
exec
/bin/zsh -lc "rg -n \"select|choices|icon\" docs -g'*.md'" in /Users/johnlindquist/dev/script-kit-gpui succeeded in 51ms:
Total output lines: 975

docs/PROTOCOL.md:14:   - [Selection Prompts](#selection-prompts)
docs/PROTOCOL.md:23:   - [Selected Text Operations](#selected-text-operations)
docs/PROTOCOL.md:95:    choices: vec![
docs/PROTOCOL.md:188:App ‚Üí Script:   {"type": "selectedText", "text": "Hello", "requestId": "req-123"}
docs/PROTOCOL.md:194:Script ‚Üí App:   {"type": "arg", "id": "1", "placeholder": "Pick", "choices": [...]}
docs/PROTOCOL.md:195:User selects...
docs/PROTOCOL.md:207:Display a prompt with selectable choices.
docs/PROTOCOL.md:215:  "choices": [
docs/PROTOCOL.md:267:{"type": "submit", "id": "prompt-1", "value": "selected_value"}
docs/PROTOCOL.md:335:  "choices": [{"name": "A", "value": "a"}]
docs/PROTOCOL.md:349:  "choices": []
docs/PROTOCOL.md:357:#### `select` - Multiple Selection
docs/PROTOCOL.md:359:Select from choices with optional multi-select.
docs/PROTOCOL.md:364:  "type": "select",
docs/PROTOCOL.md:365:  "id": "select-1",
docs/PROTOCOL.md:367:  "choices": [
docs/PROTOCOL.md:378:{"type": "submit", "id": "select-1", "value": "[\"red\",\"blue\"]"}
docs/PROTOCOL.md:383:const colors = await select("Select colors", ["red", "blue", "green"], {multiple: true});

thinking
**Inspecting protocol prompt fields**
exec
/bin/zsh -lc "sed -n '330,410p' docs/PROTOCOL.md" in /Users/johnlindquist/dev/script-kit-gpui succeeded in 52ms:
```json
{
  "type": "mini",
  "id": "mini-1",
  "placeholder": "Quick pick",
  "choices": [{"name": "A", "value": "a"}]
}
```

#### `micro` - Tiny Prompt

Even smaller than mini.

**Request:**
```json
{
  "type": "micro",
  "id": "micro-1",
  "placeholder": "Tiny",
  "choices": []

thinking
**Inspecting icon usage in choices**
exec
/bin/zsh -lc 'rg -n "Choice::with_description|choices: vec!'"\\[|\\\"icon\\\"|Icon:\" src/stories src/tests src/prompts -g'*.rs'" in /Users/johnlindquist/dev/script-kit-gpui exited 2 in 52ms:
rg: src/tests: No such file or directory (os error 2)
src/prompts/template/prompt.rs:167:            "icon" => "Icon".to_string(),
src/prompts/template/prompt.rs:195:            "icon" => "wrench".to_string(),
src/prompts/template/prompt.rs:209:            || normalized.contains("icon")
src/stories/button_stories.rs:116:                name: "icon".into(),

thinking
**Inspecting story file structure**
exec
/bin/zsh -lc "sed -n '1,120p' src/stories/select_prompt_stories/split/part_01.rs" in /Users/johnlindquist/dev/script-kit-gpui succeeded in 51ms:
pub struct SelectPromptStory;

impl Story for SelectPromptStory {
    fn id(&self) -> &'static str {
        "select-prompt"
    }

    fn name(&self) -> &'static str {
        "Select Prompt"
    }

    fn category(&self) -> &'static str {
        "Prompts"
    }

    fn render(&self) -> AnyElement {
        story_container()
            .child(
                story_section("Single Select")
                    .child(render_single_select_basic())

thinking
**Inspecting icon handling in list item tests**
exec
/bin/zsh -lc "rg -n \"icon_name_from_str|IconKind|icon|emoji\" src/list_item* src/*list_item* -g'*.rs'" in /Users/johnlindquist/dev/script-kit-gpui succeeded in 50ms:
src/list_item/part_000.rs:1:use crate::designs::icon_variations::{icon_name_from_str, IconName};
src/list_item/part_000.rs:7:/// Icon type for list items - supports emoji strings, SVG icons, and pre-decoded images
src/list_item/part_000.rs:9:pub enum IconKind {
src/list_item/part_000.rs:10:    /// Text/emoji icon (e.g., "üìú", "‚ö°")
src/list_item/part_000.rs:12:    /// Pre-decoded render image (for app icons) - MUST be pre-decoded, not raw PNG bytes
src/list_item/part_000.rs:14:    /// SVG icon by name (e.g., "File", "Terminal", "Code")
src/list_item/part_000.rs:15:    /// Maps to IconName from designs::icon_variations
src/list_item/part_000.rs:43:/// Gap between icon and text content
src/list_item/part_000.rs:55:/// SVG icon render size (inside the container)
src/list_item/part_000.rs:81:/// Section header icon size
src/list_item/part_000.rs:115:/// Gap between header elements (icon, label, count)
src/list_item/part_000.rs:128:/// 50% opacity ‚Äî used for non-selected item icons
src/list_item/part_000.rs:129:/// Low enough that icons don't compete for attention; selected items restore full color
src/list_item/part_000.rs:133:/// 75% opacity ‚Äî used for header icon, tool badge text
src/list_item/part_000.rs:175:/// Gap between empty state icon and text elements
src/list_item/part_000.rs:177:/// Empty state icon size (Code / MagnifyingGlass)
src/list_item/part_000.rs:186:/// 28% opacity ‚Äî empty state icon tint
src/list_item/part_000.rs:1:use crate::designs::icon_variations::{icon_name_from_str, IconName};
src/list_item/part_000.rs:7:/// Icon type for list items - supports emoji strings, SVG icons, and pre-decoded images
src/list_item/part_000.rs:9:pub enum IconKind {

thinking
**Designing icon parsing helper**
exec
/bin/zsh -lc "rg -n \"type:\\s*['\\\"]select['\\\"]|select\\(\" --glob '"'!target/**'"'" in /Users/johnlindquist/dev/script-kit-gpui succeeded in 4.43s:
docs/PROTOCOL.md:383:const colors = await select("Select colors", ["red", "blue", "green"], {multiple: true});
docs/ux/PROMPT_TYPES.md:23:| `select()` | ‚ö†Ô∏è Protocol only | 40% | P1 |
docs/ux/PROMPT_TYPES.md:313:## 7. SelectPrompt (select())
scripts/generate-api-tests.ts:429:// select() tests
scripts/generate-api-tests.ts:433:  const result = await select('Select multiple', ['One', 'Two', 'Three']);
scripts/test-explain-flow.sh:61:tail -200 ~/.scriptkit/logs/script-kit-gpui.jsonl | jq -r 'select(.message | test("NEEDS_RESET|HideWindow|ShowChat|initial_response|Force-killing|Built-in AI"; "i")) | "\(.timestamp) \(.message)"' 2>/dev/null | tail -20 || tail -50 /tmp/test-output.txt
docs/archive/AI_DRIVEN_UX_TESTING.md:401:| `select()` | test-core-prompts.ts | Tested | select-multi |
docs/archive/AI_DRIVEN_UX_PATTERNS.md:179:grep '"duration_ms":' ~/.scriptkit/logs/script-kit-gpui.jsonl | jq 'select(.fields.duration_ms > 100)'
docs/archive/2025-12/UX_AUDIT.md:124:- Partial: `form()`, `fields()`, `select()`  
docs/archive/2025-12/UX_AUDIT.md:219:   - Complete fields() and select() prompts
docs/archive/AUTONOMOUS_APP_TESTING.md:225:| `select()` | `gpui-select.ts` | ‚ùå None | ‚úÖ Supported | Multi-select |
docs/archive/AUTONOMOUS_APP_TESTING.md:362:const selections = await select('Pick multiple', ['One', 'Two', 'Three']);
scripts/kit-sdk.ts:1638:  type: 'select';
scripts/kit-sdk.ts:2856:  function select(placeholder: string, choices: (string | Choice)[]): Promise<string[]>;
scripts/kit-sdk.ts:4218:globalThis.select = async function select(
scripts/kit-sdk.ts:4253:      type: 'select',
docs/research/raycast-ux-patterns.md:385:        handle_quick_select(idx);
target-codex-audit-act-dialog-part05/debug/build/clang-sys-aa4a8c7c040379c2/out/common.rs:134:pub fn run_xcode_select(arguments: &[&str]) -> Option<String> {
target-codex-audit-act-dialog-part05/debug/build/clang-sys-aa4a8c7c040379c2/out/common.rs:297:        if let Some(output) = run_xcode_select(&["--print-path"]) {
kit-init/GUIDE.md:437:const selected = await select("Pick multiple", ["A", "B", "C", "D"]);

thinking
**Inspecting choice type details**
codex
I found the SDK side may carry richer `Choice` objects, so I‚Äôm checking that shape now to confirm where icon metadata is expected and how we should decode it in Rust.
exec
/bin/zsh -lc "rg -n \"type Choice|interface Choice|icon\\??:\\s*\" scripts/kit-sdk.ts" in /Users/johnlindquist/dev/script-kit-gpuiexec
/bin/zsh -lc "sed -n '4180,4295p' scripts/kit-sdk.ts" in /Users/johnlindquist/dev/script-kit-gpuiexec
/bin/zsh -lc "sed -n '1560,1725p' scripts/kit-sdk.ts" in /Users/johnlindquist/dev/script-kit-gpuiexec
/bin/zsh -lc "sed -n '2800,2895p' scripts/kit-sdk.ts" in /Users/johnlindquist/dev/script-kit-gpui succeeded in 51ms:
75:export interface Choice {
1436: *   icon: 'Terminal',
1464:  icon?: string;
1528:export type ChoicesFunction = 
1535:export type ChoicesInput = (string | Choice)[] | ChoicesFunction;
1729:  icon: string;
2968:  function menu(icon: string, scripts?: string[]): Promise<void>;
4684:globalThis.menu = async function menu(icon: string, scripts?: string[]): Promise<void> {
 succeeded in 52ms:
}

export interface Position {
  x: number;
  y: number;
}

export interface ClipboardAPI {
  readText(): Promise<string>;
  writeText(text: string): Promise<void>;
  readImage(): Promise<Buffer>;
  writeImage(buffer: Buffer): Promise<void>;
}

export interface KeyboardAPI {
  type(text: string): Promise<void>;
  tap(...keys: string[]): Promise<void>;
}

export interface MouseAPI {
 succeeded in 52ms:
  placeholder: string,
  choices: (string | Choice)[]
): Promise<string> {
  console.warn('[SDK] micro() is not yet implemented in the GPUI app - use arg() instead');
  const id = nextId();

  const normalizedChoices: Choice[] = choices.map((c) => {
    if (typeof c === 'string') {
      return { name: c, value: c };
    }
    return c;
  });

  // Auto-submit value: first choice or empty
  const autoSubmitValue = normalizedChoices.length > 0
    ? { value: normalizedChoices[0].value }
    : { value: '' };

  return new Promise((resolve) => {
    addPending(id, (msg: SubmitMessage) => {
 succeeded in 52ms:
   *
   * @example
   * // With custom button text
   * const proceed = await confirm({
   *   message: "Overwrite existing file?",
   *   confirmText: "Overwrite",
   *   cancelText: "Keep Original"
   * });
   *
   * @example
   * // Shorthand with custom buttons
   * const yes = await confirm("Continue?", "Yes", "No");
   */
  // Note: confirm is assigned via (globalThis as any).confirm to avoid conflict with DOM's confirm()
  // The actual function signature is:
  // confirm(): Promise<boolean>;
  // confirm(message: string): Promise<boolean>;
  // confirm(message: string, confirmText: string, cancelText: string): Promise<boolean>;
  // confirm(config: ConfirmConfig): Promise<boolean>;


thinking
**Identifying Choice interface location**
exec
/bin/zsh -lc "sed -n '40,140p' scripts/kit-sdk.ts" in /Users/johnlindquist/dev/script-kit-gpui succeeded in 51ms:
 *    - AI integration: aiIsOpen, aiStartChat, aiSendMessage, aiListChats, etc.
 *    - File/menu: fileSearch, getMenuBar, executeMenuAction
 *    - Pure utilities: home, skPath, uuid, compile, memoryMap
 *
 * ‚ö†Ô∏è  NOT YET IMPLEMENTED (~18 methods):
 *    These functions send messages but the GPUI app doesn't handle them yet.
 *    They log warnings and may auto-submit in test mode.
 *
 *    - Notifications: beep(), say(), notify(), setStatus()
 *    - Automation: keyboard.type(), keyboard.tap(), mouse.move(), mouse.click()
 *    - UI updates: setPanel(), setPreview(), setPrompt()
 *    - Compact prompts: mini(), micro()
 *    - Advanced: hotkey(), widget(), menu()
 *
 * ‚ùå NOT FEASIBLE (removed):
 *    These don't fit the message-passing architecture and throw errors:
 *
 *    - webcam(), mic() - Media streaming requires real-time bidirectional
 *      communication beyond the JSONL protocol
 *    - eyeDropper() - Could work with screen capture but not yet implemented

thinking
**Inspecting option interfaces**
exec
/bin/zsh -lc "sed -n '1400,1495p' scripts/kit-sdk.ts" in /Users/johnlindquist/dev/script-kit-gpui succeeded in 50ms:
 *   },
 *   output: {
 *     path: { type: 'string', description: 'Path to created file' },
 *     wordCount: { type: 'number' }
 *   }
 * }
 * ```
 */
export interface ScriptSchema {
  /** Input fields - what the script expects to receive */
  input?: Record<string, SchemaFieldDef>;
  /** Output fields - what the script will produce */
  output?: Record<string, SchemaFieldDef>;
}

/**
 * Typed metadata for scripts (replaces comment-based metadata).
 * Provides rich metadata for script discovery, documentation, and AI agents.
 * 
 * @example Basic metadata

thinking
**Assessing icon metadata handling**
exec
/bin/zsh -lc "rg -n \"IconKind.*LeadingContent|LeadingContent.*IconKind|to_leading|from_icon_kind\" src -g'*.rs'" in /Users/johnlindquist/dev/script-kit-gpui exited 1 in 51ms:


thinking
**Assessing module dependency constraints**
exec
/bin/zsh -lc "rg -n \"pub fn icon_name_from_str\" src/designs/icon_variations.rs && sed -n '1,220p' src/designs/icon_variations.rs" in /Users/johnlindquist/dev/script-kit-gpui exited 1 in 51ms:


thinking
**Searching for icon variations path**
exec
/bin/zsh -lc "rg -n \"icon_name_from_str\" src/designs -g'*.rs'" in /Users/johnlindquist/dev/script-kit-gpui succeeded in 51ms:
src/designs/icon_variations/part_02.rs:88:pub fn icon_name_from_str(name: &str) -> Option<IconName> {
src/designs/icon_variations/part_02.rs:186:    fn test_icon_name_from_str() {
src/designs/icon_variations/part_02.rs:188:        assert_eq!(icon_name_from_str("File"), Some(IconName::File));
src/designs/icon_variations/part_02.rs:189:        assert_eq!(icon_name_from_str("Terminal"), Some(IconName::Terminal));
src/designs/icon_variations/part_02.rs:192:        assert_eq!(icon_name_from_str("file"), Some(IconName::File));
src/designs/icon_variations/part_02.rs:193:        assert_eq!(icon_name_from_str("code"), Some(IconName::Code));
src/designs/icon_variations/part_02.rs:196:        assert_eq!(icon_name_from_str("file code"), Some(IconName::FileCode));
src/designs/icon_variations/part_02.rs:198:            icon_name_from_str("folder open"),
src/designs/icon_variations/part_02.rs:203:        assert_eq!(icon_name_from_str("file-code"), Some(IconName::FileCode));
src/designs/icon_variations/part_02.rs:205:            icon_name_from_str("bolt-filled"),
src/designs/icon_variations/part_02.rs:210:        assert_eq!(icon_name_from_str("file_code"), Some(IconName::FileCode));
src/designs/icon_variations/part_02.rs:212:            icon_name_from_str("magnifying_glass"),
src/designs/icon_variations/part_02.rs:218:            icon_name_from_str("search"),
src/designs/icon_variations/part_02.rs:221:        assert_eq!(icon_name_from_str("add"), Some(IconName::Plus));
src/designs/icon_variations/part_02.rs:222:        assert_eq!(icon_name_from_str("delete"), Some(IconName::Trash));
src/designs/icon_variations/part_02.rs:223:        assert_eq!(icon_name_from_str("gear"), Some(IconName::Settings));
src/designs/icon_variations/part_02.rs:224:        assert_eq!(icon_name_from_str("lightning"), Some(IconName::BoltFilled));
src/designs/icon_variations/part_02.rs:225:        assert_eq!(icon_name_from_str("run"), Some(IconName::PlayFilled));
src/designs/icon_variations/part_02.rs:228:        assert_eq!(icon_name_from_str("unknown"), None);
src/designs/icon_variations/part_02.rs:229:        assert_eq!(icon_name_from_str(""), None);
exec
/bin/zsh -lc "sed -n '60,170p' src/designs/icon_variations/part_02.rs" in /Users/johnlindquist/dev/script-kit-gpui succeeded in 50ms:
            background,
        }
    }
}

// Legacy compatibility - keep old types for existing code
pub use IconName as ScriptIcon;
pub use IconName as ScriptletIcon;
pub use IconName as BuiltInIcon;
pub use IconName as AppIcon;
pub use IconName as WindowIcon;
pub use IconName as FolderIcon;

/// Legacy function for compatibility
pub fn total_icon_count() -> usize {
    IconName::count()
}

/// Convert a string icon name to IconName enum
///

thinking
**Checking theme color tokens**
exec
/bin/zsh -lc "rg -n \"struct .*Accent|pub struct ThemeColors|accent\" src/theme -g'*.rs'" in /Users/johnlindquist/dev/script-kit-gpui succeeded in 51ms:
src/theme/presets/part_01.rs:34:    pub accent: u32,
src/theme/presets/part_01.rs:47:            description: "Default dark theme with yellow accent",
src/theme/presets/part_01.rs:153:            description: "Default light theme with blue accent",
src/theme/presets/part_01.rs:182:/// Matches on (background.main, accent.selected) which is unique per preset.
src/theme/presets/part_01.rs:185:    let current_accent = theme.colors.accent.selected;
src/theme/presets/part_01.rs:191:            t.colors.background.main == current_bg && t.colors.accent.selected == current_accent
src/theme/presets/part_01.rs:211:                accent: t.colors.accent.selected,
src/theme/presets/part_01.rs:273:            on_accent: 0xffffff,
src/theme/presets/part_01.rs:275:        accent: AccentColors {
src/theme/presets/part_02.rs:15:            on_accent: 0x282a36,
src/theme/presets/part_02.rs:17:        accent: AccentColors {
src/theme/presets/part_02.rs:63:            on_accent: 0x2e3440,
src/theme/presets/part_02.rs:65:        accent: AccentColors {
src/theme/presets/part_02.rs:111:            on_accent: 0x1e1e2e,
src/theme/presets/part_02.rs:113:        accent: AccentColors {
src/theme/presets/part_02.rs:159:            on_accent: 0xeff1f5,
src/theme/presets/part_02.rs:161:        accent: AccentColors {
src/theme/presets/part_02.rs:207:            on_accent: 0x282c34,
src/theme/presets/part_02.rs:209:        accent: AccentColors {
src/theme/presets/part_02.rs:255:            on_accent: 0x1a1b26,

thinking
**Planning select highlight styling**
exec
/bin/zsh -lc "rg -n \"SelectPrompt\\s*\\{\" src/prompts/select -g'*.rs'" in /Users/johnlindquist/dev/script-kit-gpui succeeded in 51ms:
src/prompts/select/prompt.rs:7:pub struct SelectPrompt {
src/prompts/select/prompt.rs:37:impl SelectPrompt {
src/prompts/select/prompt.rs:63:        SelectPrompt {
src/prompts/select/render.rs:3:impl Focusable for SelectPrompt {
src/prompts/select/render.rs:9:impl Render for SelectPrompt {

thinking
**Scoping icon parsing changes**
exec
/bin/zsh -lc "sed -n '260,380p' src/components/unified_list_item/types.rs" in /Users/johnlindquist/dev/script-kit-gpui succeeded in 51ms:
                height: canonical_height,
                padding_x: 8.0,
                padding_y: 4.0,
                gap: 6.0,
                leading_size: 16.0,
                radius: 4.0,
            },
        }
    }
}

// =============================================================================
// UnifiedListItemColors - Pre-computed colors
// =============================================================================

/// Pre-computed colors for UnifiedListItem rendering.
#[derive(Clone, Copy)]
pub struct UnifiedListItemColors {
    pub text_primary: u32,
    pub text_secondary: u32,

thinking
**Refining selection and icon rendering**
exec
/bin/zsh -lc "rg -n \"choice_selection_indicator\\(\" src/prompts/select -g'*.rs'" in /Users/johnlindquist/dev/script-kit-gpui succeeded in 51ms:
src/prompts/select/search.rs:152:pub(super) fn choice_selection_indicator(is_multiple: bool, is_selected: bool) -> &'static str {
src/prompts/select/render.rs:168:                                        let indicator = choice_selection_indicator(

thinking
**Planning icon integration and hover state**
codex
I‚Äôve mapped the implementation points and there‚Äôs one necessary scope adjustment: `hovered_index` lives on `SelectPrompt` in `src/prompts/select/prompt.rs`, so I need to claim/edit that file to satisfy requirement #4.  
Plan:
1. Add `hovered_index: Option<usize>` to `SelectPrompt`, initialize/reset it in prompt state paths where list shape/focus changes.
2. Add icon-hint decoding on `IconKind` (SVG-name via `icon_name_from_str`, emoji fallback) in `src/list_item/part_000.rs`.
3. Rework `select/render.rs` row building:
   - single-select leading content uses resolved item icon, multi-select uses checkbox indicator only
   - separate `is_focused`, `is_selected`, `is_hovered`
   - remove separators, add inset container padding, rounded row wrappers, focus/hover accent tints, pointer cursor, hover handler updating `hovered_index`
   - pass correct `ItemState` values and remove focus/selection conflation.
4. Run scoped verification commands for touched modules and report results.

thinking
**Claiming prompt.rs file**
exec
/bin/zsh -lc '~/.claude/bin/swarm.ts claim --wait --id codex-list-polish src/prompts/select/prompt.rs' in /Users/johnlindquist/dev/script-kit-gpui succeeded in 51ms:
Claimed for codex-list-polish: src/prompts/select/prompt.rs

thinking
**Planning helper implementation**
exec
/bin/zsh -lc "sed -n '1,120p' src/list_item/part_000.rs" in /Users/johnlindquist/dev/script-kit-gpui succeeded in 51ms:
use crate::designs::icon_variations::{icon_name_from_str, IconName};
use crate::logging;
use crate::ui_foundation::HexColorExt;
use gpui::*;
use std::collections::HashSet;
use std::sync::Arc;
/// Icon type for list items - supports emoji strings, SVG icons, and pre-decoded images
#[derive(Clone)]
pub enum IconKind {
    /// Text/emoji icon (e.g., "üìú", "‚ö°")
    Emoji(String),
    /// Pre-decoded render image (for app icons) - MUST be pre-decoded, not raw PNG bytes
    Image(Arc<RenderImage>),
    /// SVG icon by name (e.g., "File", "Terminal", "Code")
    /// Maps to IconName from designs::icon_variations
    Svg(String),
}
/// Fixed height for list items used in uniform-height virtualized lists.
///
/// IMPORTANT: When using GPUI `uniform_list`, the item closure must render

thinking
**Planning method and test placement**
exec
/bin/zsh -lc 'tail -n 120 src/list_item/part_000.rs' in /Users/johnlindquist/dev/script-kit-gpui succeeded in 51ms:
    pub total_items: usize,
    /// Index of first selectable item (skips leading header)
    pub first_selectable: usize,
}
impl GroupedListState {
    /// Create from a list of (group_name, item_count) pairs
    ///
    /// Each group gets a header at the start, followed by its items.
    /// Empty groups are skipped (no header for empty groups).
    pub fn from_groups(groups: &[(&str, usize)]) -> Self {
        let mut header_indices = std::collections::HashSet::new();
        let mut idx = 0;

        for (_, count) in groups {
            if *count > 0 {
                header_indices.insert(idx); // Header position
                idx += 1 + count; // Header + items
            }
        }


thinking
**Verifying file tail lines**
exec
/bin/zsh -lc "wc -l src/list_item/part_000.rs && sed -n '520,620p' src/list_item/part_000.rs" in /Users/johnlindquist/dev/script-kit-gpui succeeded in 51ms:
     439 src/list_item/part_000.rs

thinking
**Planning test placement across parts**
codex
I‚Äôm starting code edits now: first adding a reusable icon-hint parser on `IconKind` so select prompt rows can convert metadata icon strings through the existing SVG-name pipeline with emoji fallback.
file update
M /Users/johnlindquist/dev/script-kit-gpui/src/list_item/part_000.rs
@@ -17,2 +17,33 @@
 }
+
+impl IconKind {
+    /// Resolve icon metadata into an IconKind for list rendering.
+    ///
+    /// Supports:
+    /// - Known SVG names/aliases via `icon_name_from_str` (e.g., "Terminal", "file-code")
+    /// - Emoji/symbol glyphs (e.g., "üìÑ", "‚ö°")
+    pub fn from_icon_hint(icon_hint: &str) -> Option<Self> {
+        let trimmed = icon_hint.trim();
+        if trimmed.is_empty() {
+            return None;
+        }
+
+        if icon_name_from_str(trimmed).is_some() {
+            return Some(Self::Svg(trimmed.to_string()));
+        }
+
+        if looks_like_symbol_icon_hint(trimmed) {
+            return Some(Self::Emoji(trimmed.to_string()));
+        }
+
+        None
+    }
+}
+
+fn looks_like_symbol_icon_hint(icon_hint: &str) -> bool {
+    let has_ascii_alnum = icon_hint.chars().any(|ch| ch.is_ascii_alphanumeric());
+    let char_count = icon_hint.chars().count();
+
+    !has_ascii_alnum && char_count <= 4
+}
 /// Fixed height for list items used in uniform-height virtualized lists.
@@ -439 +470,27 @@
 }
+
+#[cfg(test)]
+mod icon_kind_tests {
+    use super::IconKind;
+
+    #[test]
+    fn test_icon_kind_from_icon_hint_returns_svg_when_known_icon_name() {
+        match IconKind::from_icon_hint("terminal") {
+            Some(IconKind::Svg(name)) => assert_eq!(name, "terminal"),
+            _ => panic!("expected SVG icon from known icon hint"),
+        }
+    }
+
+    #[test]
+    fn test_icon_kind_from_icon_hint_returns_emoji_when_symbol_glyph() {
+        match IconKind::from_icon_hint("üìÑ") {
+            Some(IconKind::Emoji(emoji)) => assert_eq!(emoji, "üìÑ"),
+            _ => panic!("expected emoji icon for symbol glyph"),
+        }
+    }
+
+    #[test]
+    fn test_icon_kind_from_icon_hint_returns_none_for_unknown_ascii_word() {
+        assert!(IconKind::from_icon_hint("unknown-icon-name").is_none());
+    }
+}
apply_patch(auto_approved=true) exited 0 in 12ms:
Success. Updated the following files:
M src/list_item/part_000.rs
file update:
diff --git a/src/list_item/part_000.rs b/src/list_item/part_000.rs
index 733d4ac2aa5b1b27b29a5999310e6f3f45cc54c3..283b2263d56a92c73c22d44443db7b40971d26ce
--- a/src/list_item/part_000.rs
+++ b/src/list_item/part_000.rs
@@ -15,6 +15,37 @@
     /// Maps to IconName from designs::icon_variations
     Svg(String),
 }
+
+impl IconKind {
+    /// Resolve icon metadata into an IconKind for list rendering.
+    ///
+    /// Supports:
+    /// - Known SVG names/aliases via `icon_name_from_str` (e.g., "Terminal", "file-code")
+    /// - Emoji/symbol glyphs (e.g., "üìÑ", "‚ö°")
+    pub fn from_icon_hint(icon_hint: &str) -> Option<Self> {
+        let trimmed = icon_hint.trim();
+        if trimmed.is_empty() {
+            return None;
+        }
+
+        if icon_name_from_str(trimmed).is_some() {
+            return Some(Self::Svg(trimmed.to_string()));
+        }
+
+        if looks_like_symbol_icon_hint(trimmed) {
+            return Some(Self::Emoji(trimmed.to_string()));
+        }
+
+        None
+    }
+}
+
+fn looks_like_symbol_icon_hint(icon_hint: &str) -> bool {
+    let has_ascii_alnum = icon_hint.chars().any(|ch| ch.is_ascii_alphanumeric());
+    let char_count = icon_hint.chars().count();
+
+    !has_ascii_alnum && char_count <= 4
+}
 /// Fixed height for list items used in uniform-height virtualized lists.
 ///
 /// IMPORTANT: When using GPUI `uniform_list`, the item closure must render
@@ -437,3 +468,29 @@
     /// Text color for content displayed on accent/warning backgrounds
     pub text_on_accent: u32,
 }
+
+#[cfg(test)]
+mod icon_kind_tests {
+    use super::IconKind;
+
+    #[test]
+    fn test_icon_kind_from_icon_hint_returns_svg_when_known_icon_name() {
+        match IconKind::from_icon_hint("terminal") {
+            Some(IconKind::Svg(name)) => assert_eq!(name, "terminal"),
+            _ => panic!("expected SVG icon from known icon hint"),
+        }
+    }
+
+    #[test]
+    fn test_icon_kind_from_icon_hint_returns_emoji_when_symbol_glyph() {
+        match IconKind::from_icon_hint("üìÑ") {
+            Some(IconKind::Emoji(emoji)) => assert_eq!(emoji, "üìÑ"),
+            _ => panic!("expected emoji icon for symbol glyph"),
+        }
+    }
+
+    #[test]
+    fn test_icon_kind_from_icon_hint_returns_none_for_unknown_ascii_word() {
+        assert!(IconKind::from_icon_hint("unknown-icon-name").is_none());
+    }
+}

file update:
diff --git a/src/list_item/part_000.rs b/src/list_item/part_000.rs
index 733d4ac2aa5b1b27b29a5999310e6f3f45cc54c3..283b2263d56a92c73c22d44443db7b40971d26ce
--- a/src/list_item/part_000.rs
+++ b/src/list_item/part_000.rs
@@ -15,6 +15,37 @@
     /// Maps to IconName from designs::icon_variations
     Svg(String),
 }
+
+impl IconKind {
+    /// Resolve icon metadata into an IconKind for list rendering.
+    ///
+    /// Supports:
+    /// - Known SVG names/aliases via `icon_name_from_str` (e.g., "Terminal", "file-code")
+    /// - Emoji/symbol glyphs (e.g., "üìÑ", "‚ö°")
+    pub fn from_icon_hint(icon_hint: &str) -> Option<Self> {
+        let trimmed = icon_hint.trim();
+        if trimmed.is_empty() {
+            return None;
+        }
+
+        if icon_name_from_str(trimmed).is_some() {
+            return Some(Self::Svg(trimmed.to_string()));
+        }
+
+        if looks_like_symbol_icon_hint(trimmed) {
+            return Some(Self::Emoji(trimmed.to_string()));
+        }
+
+        None
+    }
+}
+
+fn looks_like_symbol_icon_hint(icon_hint: &str) -> bool {
+    let has_ascii_alnum = icon_hint.chars().any(|ch| ch.is_ascii_alphanumeric());
+    let char_count = icon_hint.chars().count();
+
+    !has_ascii_alnum && char_count <= 4
+}
 /// Fixed height for list items used in uniform-height virtualized lists.
 ///
 /// IMPORTANT: When using GPUI `uniform_list`, the item closure must render
@@ -437,3 +468,29 @@
     /// Text color for content displayed on accent/warning backgrounds
     pub text_on_accent: u32,
 }
+
+#[cfg(test)]
+mod icon_kind_tests {
+    use super::IconKind;
+
+    #[test]
+    fn test_icon_kind_from_icon_hint_returns_svg_when_known_icon_name() {
+        match IconKind::from_icon_hint("terminal") {
+            Some(IconKind::Svg(name)) => assert_eq!(name, "terminal"),
+            _ => panic!("expected SVG icon from known icon hint"),
+        }
+    }
+
+    #[test]
+    fn test_icon_kind_from_icon_hint_returns_emoji_when_symbol_glyph() {
+        match IconKind::from_icon_hint("üìÑ") {
+            Some(IconKind::Emoji(emoji)) => assert_eq!(emoji, "üìÑ"),
+            _ => panic!("expected emoji icon for symbol glyph"),
+        }
+    }
+
+    #[test]
+    fn test_icon_kind_from_icon_hint_returns_none_for_unknown_ascii_word() {
+        assert!(IconKind::from_icon_hint("unknown-icon-name").is_none());
+    }
+}


thinking
**Updating module imports**
file update
M /Users/johnlindquist/dev/script-kit-gpui/src/prompts/select/mod.rs
@@ -21,3 +21,3 @@
 use crate::designs::{get_tokens, DesignColors, DesignVariant};
-use crate::list_item::LIST_ITEM_HEIGHT;
+use crate::list_item::{IconKind, LIST_ITEM_HEIGHT};
 use crate::logging;
apply_patch(auto_approved=true) exited 0 in 16ms:
Success. Updated the following files:
M src/prompts/select/mod.rs
file update:
diff --git a/src/list_item/part_000.rs b/src/list_item/part_000.rs
index 733d4ac2aa5b1b27b29a5999310e6f3f45cc54c3..283b2263d56a92c73c22d44443db7b40971d26ce
--- a/src/list_item/part_000.rs
+++ b/src/list_item/part_000.rs
@@ -15,6 +15,37 @@
     /// Maps to IconName from designs::icon_variations
     Svg(String),
 }
+
+impl IconKind {
+    /// Resolve icon metadata into an IconKind for list rendering.
+    ///
+    /// Supports:
+    /// - Known SVG names/aliases via `icon_name_from_str` (e.g., "Terminal", "file-code")
+    /// - Emoji/symbol glyphs (e.g., "üìÑ", "‚ö°")
+    pub fn from_icon_hint(icon_hint: &str) -> Option<Self> {
+        let trimmed = icon_hint.trim();
+        if trimmed.is_empty() {
+            return None;
+        }
+
+        if icon_name_from_str(trimmed).is_some() {
+            return Some(Self::Svg(trimmed.to_string()));
+        }
+
+        if looks_like_symbol_icon_hint(trimmed) {
+            return Some(Self::Emoji(trimmed.to_string()));
+        }
+
+        None
+    }
+}
+
+fn looks_like_symbol_icon_hint(icon_hint: &str) -> bool {
+    let has_ascii_alnum = icon_hint.chars().any(|ch| ch.is_ascii_alphanumeric());
+    let char_count = icon_hint.chars().count();
+
+    !has_ascii_alnum && char_count <= 4
+}
 /// Fixed height for list items used in uniform-height virtualized lists.
 ///
 /// IMPORTANT: When using GPUI `uniform_list`, the item closure must render
@@ -437,3 +468,29 @@
     /// Text color for content displayed on accent/warning backgrounds
     pub text_on_accent: u32,
 }
+
+#[cfg(test)]
+mod icon_kind_tests {
+    use super::IconKind;
+
+    #[test]
+    fn test_icon_kind_from_icon_hint_returns_svg_when_known_icon_name() {
+        match IconKind::from_icon_hint("terminal") {
+            Some(IconKind::Svg(name)) => assert_eq!(name, "terminal"),
+            _ => panic!("expected SVG icon from known icon hint"),
+        }
+    }
+
+    #[test]
+    fn test_icon_kind_from_icon_hint_returns_emoji_when_symbol_glyph() {
+        match IconKind::from_icon_hint("üìÑ") {
+            Some(IconKind::Emoji(emoji)) => assert_eq!(emoji, "üìÑ"),
+            _ => panic!("expected emoji icon for symbol glyph"),
+        }
+    }
+
+    #[test]
+    fn test_icon_kind_from_icon_hint_returns_none_for_unknown_ascii_word() {
+        assert!(IconKind::from_icon_hint("unknown-icon-name").is_none());
+    }
+}
diff --git a/src/prompts/select/mod.rs b/src/prompts/select/mod.rs
index b6366dabfb14f3fae09f854f9de824fa629e0a3b..4ff3662b0b553a2aa8b9d8c752504d9db09a20da
--- a/src/prompts/select/mod.rs
+++ b/src/prompts/select/mod.rs
@@ -19,7 +19,7 @@
     UnifiedListItemColors,
 };
 use crate::designs::{get_tokens, DesignColors, DesignVariant};
-use crate::list_item::LIST_ITEM_HEIGHT;
+use crate::list_item::{IconKind, LIST_ITEM_HEIGHT};
 use crate::logging;
 use crate::panel::PROMPT_INPUT_FIELD_HEIGHT;
 use crate::protocol::{generate_semantic_id, Choice};

file update:
diff --git a/src/list_item/part_000.rs b/src/list_item/part_000.rs
index 733d4ac2aa5b1b27b29a5999310e6f3f45cc54c3..283b2263d56a92c73c22d44443db7b40971d26ce
--- a/src/list_item/part_000.rs
+++ b/src/list_item/part_000.rs
@@ -15,6 +15,37 @@
     /// Maps to IconName from designs::icon_variations
     Svg(String),
 }
+
+impl IconKind {
+    /// Resolve icon metadata into an IconKind for list rendering.
+    ///
+    /// Supports:
+    /// - Known SVG names/aliases via `icon_name_from_str` (e.g., "Terminal", "file-code")
+    /// - Emoji/symbol glyphs (e.g., "üìÑ", "‚ö°")
+    pub fn from_icon_hint(icon_hint: &str) -> Option<Self> {
+        let trimmed = icon_hint.trim();
+        if trimmed.is_empty() {
+            return None;
+        }
+
+        if icon_name_from_str(trimmed).is_some() {
+            return Some(Self::Svg(trimmed.to_string()));
+        }
+
+        if looks_like_symbol_icon_hint(trimmed) {
+            return Some(Self::Emoji(trimmed.to_string()));
+        }
+
+        None
+    }
+}
+
+fn looks_like_symbol_icon_hint(icon_hint: &str) -> bool {
+    let has_ascii_alnum = icon_hint.chars().any(|ch| ch.is_ascii_alphanumeric());
+    let char_count = icon_hint.chars().count();
+
+    !has_ascii_alnum && char_count <= 4
+}
 /// Fixed height for list items used in uniform-height virtualized lists.
 ///
 /// IMPORTANT: When using GPUI `uniform_list`, the item closure must render
@@ -437,3 +468,29 @@
     /// Text color for content displayed on accent/warning backgrounds
     pub text_on_accent: u32,
 }
+
+#[cfg(test)]
+mod icon_kind_tests {
+    use super::IconKind;
+
+    #[test]
+    fn test_icon_kind_from_icon_hint_returns_svg_when_known_icon_name() {
+        match IconKind::from_icon_hint("terminal") {
+            Some(IconKind::Svg(name)) => assert_eq!(name, "terminal"),
+            _ => panic!("expected SVG icon from known icon hint"),
+        }
+    }
+
+    #[test]
+    fn test_icon_kind_from_icon_hint_returns_emoji_when_symbol_glyph() {
+        match IconKind::from_icon_hint("üìÑ") {
+            Some(IconKind::Emoji(emoji)) => assert_eq!(emoji, "üìÑ"),
+            _ => panic!("expected emoji icon for symbol glyph"),
+        }
+    }
+
+    #[test]
+    fn test_icon_kind_from_icon_hint_returns_none_for_unknown_ascii_word() {
+        assert!(IconKind::from_icon_hint("unknown-icon-name").is_none());
+    }
+}
diff --git a/src/prompts/select/mod.rs b/src/prompts/select/mod.rs
index b6366dabfb14f3fae09f854f9de824fa629e0a3b..4ff3662b0b553a2aa8b9d8c752504d9db09a20da
--- a/src/prompts/select/mod.rs
+++ b/src/prompts/select/mod.rs
@@ -19,7 +19,7 @@
     UnifiedListItemColors,
 };
 use crate::designs::{get_tokens, DesignColors, DesignVariant};
-use crate::list_item::LIST_ITEM_HEIGHT;
+use crate::list_item::{IconKind, LIST_ITEM_HEIGHT};
 use crate::logging;
 use crate::panel::PROMPT_INPUT_FIELD_HEIGHT;
 use crate::protocol::{generate_semantic_id, Choice};


thinking
**Adding hovered index state**
file update
M /Users/johnlindquist/dev/script-kit-gpui/src/prompts/select/prompt.rs
@@ -21,2 +21,4 @@
     pub focused_index: usize,
+    /// Currently hovered index in filtered list
+    pub hovered_index: Option<usize>,
     /// Filter text
@@ -70,2 +72,3 @@
             focused_index: 0,
+            hovered_index: None,
             filter_text: String::new(),
@@ -86,2 +89,3 @@
             self.focused_index = 0;
+            self.hovered_index = None;
             return;
@@ -111,2 +115,3 @@
         self.focused_index = 0;
+        self.hovered_index = None;
     }
@@ -170,2 +175,3 @@
             self.focused_index -= 1;
+            self.hovered_index = None;
             self.list_scroll_handle
@@ -180,2 +186,3 @@
             self.focused_index += 1;
+            self.hovered_index = None;
             self.list_scroll_handle
apply_patch(auto_approved=true) exited 0 in 21ms:
Success. Updated the following files:
M src/prompts/select/prompt.rs
file update:
diff --git a/src/list_item/part_000.rs b/src/list_item/part_000.rs
index 733d4ac2aa5b1b27b29a5999310e6f3f45cc54c3..283b2263d56a92c73c22d44443db7b40971d26ce
--- a/src/list_item/part_000.rs
+++ b/src/list_item/part_000.rs
@@ -15,6 +15,37 @@
     /// Maps to IconName from designs::icon_variations
     Svg(String),
 }
+
+impl IconKind {
+    /// Resolve icon metadata into an IconKind for list rendering.
+    ///
+    /// Supports:
+    /// - Known SVG names/aliases via `icon_name_from_str` (e.g., "Terminal", "file-code")
+    /// - Emoji/symbol glyphs (e.g., "üìÑ", "‚ö°")
+    pub fn from_icon_hint(icon_hint: &str) -> Option<Self> {
+        let trimmed = icon_hint.trim();
+        if trimmed.is_empty() {
+            return None;
+        }
+
+        if icon_name_from_str(trimmed).is_some() {
+            return Some(Self::Svg(trimmed.to_string()));
+        }
+
+        if looks_like_symbol_icon_hint(trimmed) {
+            return Some(Self::Emoji(trimmed.to_string()));
+        }
+
+        None
+    }
+}
+
+fn looks_like_symbol_icon_hint(icon_hint: &str) -> bool {
+    let has_ascii_alnum = icon_hint.chars().any(|ch| ch.is_ascii_alphanumeric());
+    let char_count = icon_hint.chars().count();
+
+    !has_ascii_alnum && char_count <= 4
+}
 /// Fixed height for list items used in uniform-height virtualized lists.
 ///
 /// IMPORTANT: When using GPUI `uniform_list`, the item closure must render
@@ -437,3 +468,29 @@
     /// Text color for content displayed on accent/warning backgrounds
     pub text_on_accent: u32,
 }
+
+#[cfg(test)]
+mod icon_kind_tests {
+    use super::IconKind;
+
+    #[test]
+    fn test_icon_kind_from_icon_hint_returns_svg_when_known_icon_name() {
+        match IconKind::from_icon_hint("terminal") {
+            Some(IconKind::Svg(name)) => assert_eq!(name, "terminal"),
+            _ => panic!("expected SVG icon from known icon hint"),
+        }
+    }
+
+    #[test]
+    fn test_icon_kind_from_icon_hint_returns_emoji_when_symbol_glyph() {
+        match IconKind::from_icon_hint("üìÑ") {
+            Some(IconKind::Emoji(emoji)) => assert_eq!(emoji, "üìÑ"),
+            _ => panic!("expected emoji icon for symbol glyph"),
+        }
+    }
+
+    #[test]
+    fn test_icon_kind_from_icon_hint_returns_none_for_unknown_ascii_word() {
+        assert!(IconKind::from_icon_hint("unknown-icon-name").is_none());
+    }
+}
diff --git a/src/prompts/select/mod.rs b/src/prompts/select/mod.rs
index b6366dabfb14f3fae09f854f9de824fa629e0a3b..4ff3662b0b553a2aa8b9d8c752504d9db09a20da
--- a/src/prompts/select/mod.rs
+++ b/src/prompts/select/mod.rs
@@ -19,7 +19,7 @@
     UnifiedListItemColors,
 };
 use crate::designs::{get_tokens, DesignColors, DesignVariant};
-use crate::list_item::LIST_ITEM_HEIGHT;
+use crate::list_item::{IconKind, LIST_ITEM_HEIGHT};
 use crate::logging;
 use crate::panel::PROMPT_INPUT_FIELD_HEIGHT;
 use crate::protocol::{generate_semantic_id, Choice};
diff --git a/src/prompts/select/prompt.rs b/src/prompts/select/prompt.rs
index c5f98f5318f5b520e9223811f735e866ee06e7fb..5ba2de479b2f5680a73db72642377f68d26ee54e
--- a/src/prompts/select/prompt.rs
+++ b/src/prompts/select/prompt.rs
@@ -19,6 +19,8 @@
     pub filtered_choices: Vec<usize>,
     /// Currently focused index in filtered list
     pub focused_index: usize,
+    /// Currently hovered index in filtered list
+    pub hovered_index: Option<usize>,
     /// Filter text
     pub filter_text: String,
     /// Whether multiple selection is allowed
@@ -68,6 +70,7 @@
             selected: HashSet::new(),
             filtered_choices,
             focused_index: 0,
+            hovered_index: None,
             filter_text: String::new(),
             multiple,
             focus_handle,
@@ -84,6 +87,7 @@
         if trimmed_filter.is_empty() {
             self.filtered_choices = (0..self.choices.len()).collect();
             self.focused_index = 0;
+            self.hovered_index = None;
             return;
         }
 
@@ -109,6 +113,7 @@
 
         self.filtered_choices = scored_matches.into_iter().map(|(idx, _)| idx).collect();
         self.focused_index = 0;
+        self.hovered_index = None;
     }
 
     /// Set the filter text programmatically
@@ -168,6 +173,7 @@
     pub(super) fn move_up(&mut self, cx: &mut Context<Self>) {
         if self.focused_index > 0 {
             self.focused_index -= 1;
+            self.hovered_index = None;
             self.list_scroll_handle
                 .scroll_to_item(self.focused_index, ScrollStrategy::Nearest);
             cx.notify();
@@ -178,6 +184,7 @@
     pub(super) fn move_down(&mut self, cx: &mut Context<Self>) {
         if self.focused_index < self.filtered_choices.len().saturating_sub(1) {
             self.focused_index += 1;
+            self.hovered_index = None;
             self.list_scroll_handle
                 .scroll_to_item(self.focused_index, ScrollStrategy::Nearest);
             cx.notify();

file update:
diff --git a/src/list_item/part_000.rs b/src/list_item/part_000.rs
index 733d4ac2aa5b1b27b29a5999310e6f3f45cc54c3..283b2263d56a92c73c22d44443db7b40971d26ce
--- a/src/list_item/part_000.rs
+++ b/src/list_item/part_000.rs
@@ -15,6 +15,37 @@
     /// Maps to IconName from designs::icon_variations
     Svg(String),
 }
+
+impl IconKind {
+    /// Resolve icon metadata into an IconKind for list rendering.
+    ///
+    /// Supports:
+    /// - Known SVG names/aliases via `icon_name_from_str` (e.g., "Terminal", "file-code")
+    /// - Emoji/symbol glyphs (e.g., "üìÑ", "‚ö°")
+    pub fn from_icon_hint(icon_hint: &str) -> Option<Self> {
+        let trimmed = icon_hint.trim();
+        if trimmed.is_empty() {
+            return None;
+        }
+
+        if icon_name_from_str(trimmed).is_some() {
+            return Some(Self::Svg(trimmed.to_string()));
+        }
+
+        if looks_like_symbol_icon_hint(trimmed) {
+            return Some(Self::Emoji(trimmed.to_string()));
+        }
+
+        None
+    }
+}
+
+fn looks_like_symbol_icon_hint(icon_hint: &str) -> bool {
+    let has_ascii_alnum = icon_hint.chars().any(|ch| ch.is_ascii_alphanumeric());
+    let char_count = icon_hint.chars().count();
+
+    !has_ascii_alnum && char_count <= 4
+}
 /// Fixed height for list items used in uniform-height virtualized lists.
 ///
 /// IMPORTANT: When using GPUI `uniform_list`, the item closure must render
@@ -437,3 +468,29 @@
     /// Text color for content displayed on accent/warning backgrounds
     pub text_on_accent: u32,
 }
+
+#[cfg(test)]
+mod icon_kind_tests {
+    use super::IconKind;
+
+    #[test]
+    fn test_icon_kind_from_icon_hint_returns_svg_when_known_icon_name() {
+        match IconKind::from_icon_hint("terminal") {
+            Some(IconKind::Svg(name)) => assert_eq!(name, "terminal"),
+            _ => panic!("expected SVG icon from known icon hint"),
+        }
+    }
+
+    #[test]
+    fn test_icon_kind_from_icon_hint_returns_emoji_when_symbol_glyph() {
+        match IconKind::from_icon_hint("üìÑ") {
+            Some(IconKind::Emoji(emoji)) => assert_eq!(emoji, "üìÑ"),
+            _ => panic!("expected emoji icon for symbol glyph"),
+        }
+    }
+
+    #[test]
+    fn test_icon_kind_from_icon_hint_returns_none_for_unknown_ascii_word() {
+        assert!(IconKind::from_icon_hint("unknown-icon-name").is_none());
+    }
+}
diff --git a/src/prompts/select/mod.rs b/src/prompts/select/mod.rs
index b6366dabfb14f3fae09f854f9de824fa629e0a3b..4ff3662b0b553a2aa8b9d8c752504d9db09a20da
--- a/src/prompts/select/mod.rs
+++ b/src/prompts/select/mod.rs
@@ -19,7 +19,7 @@
     UnifiedListItemColors,
 };
 use crate::designs::{get_tokens, DesignColors, DesignVariant};
-use crate::list_item::LIST_ITEM_HEIGHT;
+use crate::list_item::{IconKind, LIST_ITEM_HEIGHT};
 use crate::logging;
 use crate::panel::PROMPT_INPUT_FIELD_HEIGHT;
 use crate::protocol::{generate_semantic_id, Choice};
diff --git a/src/prompts/select/prompt.rs b/src/prompts/select/prompt.rs
index c5f98f5318f5b520e9223811f735e866ee06e7fb..5ba2de479b2f5680a73db72642377f68d26ee54e
--- a/src/prompts/select/prompt.rs
+++ b/src/prompts/select/prompt.rs
@@ -19,6 +19,8 @@
     pub filtered_choices: Vec<usize>,
     /// Currently focused index in filtered list
     pub focused_index: usize,
+    /// Currently hovered index in filtered list
+    pub hovered_index: Option<usize>,
     /// Filter text
     pub filter_text: String,
     /// Whether multiple selection is allowed
@@ -68,6 +70,7 @@
             selected: HashSet::new(),
             filtered_choices,
             focused_index: 0,
+            hovered_index: None,
             filter_text: String::new(),
             multiple,
             focus_handle,
@@ -84,6 +87,7 @@
         if trimmed_filter.is_empty() {
             self.filtered_choices = (0..self.choices.len()).collect();
             self.focused_index = 0;
+            self.hovered_index = None;
             return;
         }
 
@@ -109,6 +113,7 @@
 
         self.filtered_choices = scored_matches.into_iter().map(|(idx, _)| idx).collect();
         self.focused_index = 0;
+        self.hovered_index = None;
     }
 
     /// Set the filter text programmatically
@@ -168,6 +173,7 @@
     pub(super) fn move_up(&mut self, cx: &mut Context<Self>) {
         if self.focused_index > 0 {
             self.focused_index -= 1;
+            self.hovered_index = None;
             self.list_scroll_handle
                 .scroll_to_item(self.focused_index, ScrollStrategy::Nearest);
             cx.notify();
@@ -178,6 +184,7 @@
     pub(super) fn move_down(&mut self, cx: &mut Context<Self>) {
         if self.focused_index < self.filtered_choices.len().saturating_sub(1) {
             self.focused_index += 1;
+            self.hovered_index = None;
             self.list_scroll_handle
                 .scroll_to_item(self.focused_index, ScrollStrategy::Nearest);
             cx.notify();


thinking
**Preparing detailed render inspection**
codex
I‚Äôve added `hovered_index` state in `SelectPrompt`; next I‚Äôm refactoring `select/render.rs` to wire real leading icons, rounded focus/hover wrappers, and correct focused vs selected state handling.
exec
/bin/zsh -lc "nl -ba src/prompts/select/render.rs | sed -n '1,320p'" in /Users/johnlindquist/dev/script-kit-gpui succeeded in 52ms:
     1	use super::*;
     2	
     3	impl Focusable for SelectPrompt {
     4	    fn focus_handle(&self, _cx: &gpui::App) -> FocusHandle {
     5	        self.focus_handle.clone()
     6	    }
     7	}
     8	
     9	impl Render for SelectPrompt {
    10	    fn render(&mut self, _window: &mut Window, cx: &mut Context<Self>) -> impl IntoElement {
    11	        let tokens = get_tokens(self.design_variant);
    12	        let colors = tokens.colors();
    13	        let spacing = tokens.spacing();
    14	
    15	        let handle_key = cx.listener(
    16	            |this: &mut Self,
    17	             event: &gpui::KeyDownEvent,
    18	             _window: &mut Window,
    19	             cx: &mut Context<Self>| {
    20	                let key_str = event.keystroke.key.to_lowercase();
file update:
diff --git a/src/list_item/part_000.rs b/src/list_item/part_000.rs
index 733d4ac2aa5b1b27b29a5999310e6f3f45cc54c3..283b2263d56a92c73c22d44443db7b40971d26ce
--- a/src/list_item/part_000.rs
+++ b/src/list_item/part_000.rs
@@ -15,6 +15,37 @@
     /// Maps to IconName from designs::icon_variations
     Svg(String),
 }
+
+impl IconKind {
+    /// Resolve icon metadata into an IconKind for list rendering.
+    ///
+    /// Supports:
+    /// - Known SVG names/aliases via `icon_name_from_str` (e.g., "Terminal", "file-code")
+    /// - Emoji/symbol glyphs (e.g., "üìÑ", "‚ö°")
+    pub fn from_icon_hint(icon_hint: &str) -> Option<Self> {
+        let trimmed = icon_hint.trim();
+        if trimmed.is_empty() {
+            return None;
+        }
+
+        if icon_name_from_str(trimmed).is_some() {
+            return Some(Self::Svg(trimmed.to_string()));
+        }
+
+        if looks_like_symbol_icon_hint(trimmed) {
+            return Some(Self::Emoji(trimmed.to_string()));
+        }
+
+        None
+    }
+}
+
+fn looks_like_symbol_icon_hint(icon_hint: &str) -> bool {
+    let has_ascii_alnum = icon_hint.chars().any(|ch| ch.is_ascii_alphanumeric());
+    let char_count = icon_hint.chars().count();
+
+    !has_ascii_alnum && char_count <= 4
+}
 /// Fixed height for list items used in uniform-height virtualized lists.
 ///
 /// IMPORTANT: When using GPUI `uniform_list`, the item closure must render
@@ -437,3 +468,29 @@
     /// Text color for content displayed on accent/warning backgrounds
     pub text_on_accent: u32,
 }
+
+#[cfg(test)]
+mod icon_kind_tests {
+    use super::IconKind;
+
+    #[test]
+    fn test_icon_kind_from_icon_hint_returns_svg_when_known_icon_name() {
+        match IconKind::from_icon_hint("terminal") {
+            Some(IconKind::Svg(name)) => assert_eq!(name, "terminal"),
+            _ => panic!("expected SVG icon from known icon hint"),
+        }
+    }
+
+    #[test]
+    fn test_icon_kind_from_icon_hint_returns_emoji_when_symbol_glyph() {
+        match IconKind::from_icon_hint("üìÑ") {
+            Some(IconKind::Emoji(emoji)) => assert_eq!(emoji, "üìÑ"),
+            _ => panic!("expected emoji icon for symbol glyph"),
+        }
+    }
+
+    #[test]
+    fn test_icon_kind_from_icon_hint_returns_none_for_unknown_ascii_word() {
+        assert!(IconKind::from_icon_hint("unknown-icon-name").is_none());
+    }
+}
diff --git a/src/prompts/select/mod.rs b/src/prompts/select/mod.rs
index b6366dabfb14f3fae09f854f9de824fa629e0a3b..4ff3662b0b553a2aa8b9d8c752504d9db09a20da
--- a/src/prompts/select/mod.rs
+++ b/src/prompts/select/mod.rs
@@ -19,7 +19,7 @@
     UnifiedListItemColors,
 };
 use crate::designs::{get_tokens, DesignColors, DesignVariant};
-use crate::list_item::LIST_ITEM_HEIGHT;
+use crate::list_item::{IconKind, LIST_ITEM_HEIGHT};
 use crate::logging;
 use crate::panel::PROMPT_INPUT_FIELD_HEIGHT;
 use crate::protocol::{generate_semantic_id, Choice};
diff --git a/src/prompts/select/prompt.rs b/src/prompts/select/prompt.rs
index c5f98f5318f5b520e9223811f735e866ee06e7fb..5ba2de479b2f5680a73db72642377f68d26ee54e
--- a/src/prompts/select/prompt.rs
+++ b/src/prompts/select/prompt.rs
@@ -19,6 +19,8 @@
     pub filtered_choices: Vec<usize>,
     /// Currently focused index in filtered list
     pub focused_index: usize,
+    /// Currently hovered index in filtered list
+    pub hovered_index: Option<usize>,
     /// Filter text
     pub filter_text: String,
     /// Whether multiple selection is allowed
@@ -68,6 +70,7 @@
             selected: HashSet::new(),
             filtered_choices,
             focused_index: 0,
+            hovered_index: None,
             filter_text: String::new(),
             multiple,
             focus_handle,
@@ -84,6 +87,7 @@
         if trimmed_filter.is_empty() {
             self.filtered_choices = (0..self.choices.len()).collect();
             self.focused_index = 0;
+            self.hovered_index = None;
             return;
         }
 
@@ -109,6 +113,7 @@
 
         self.filtered_choices = scored_matches.into_iter().map(|(idx, _)| idx).collect();
         self.focused_index = 0;
+        self.hovered_index = None;
     }
 
     /// Set the filter text programmatically
@@ -168,6 +173,7 @@
     pub(super) fn move_up(&mut self, cx: &mut Context<Self>) {
         if self.focused_index > 0 {
             self.focused_index -= 1;
+            self.hovered_index = None;
             self.list_scroll_handle
                 .scroll_to_item(self.focused_index, ScrollStrategy::Nearest);
             cx.notify();
@@ -178,6 +184,7 @@
     pub(super) fn move_down(&mut self, cx: &mut Context<Self>) {
         if self.focused_index < self.filtered_choices.len().saturating_sub(1) {
             self.focused_index += 1;
+            self.hovered_index = None;
             self.list_scroll_handle
                 .scroll_to_item(self.focused_index, ScrollStrategy::Nearest);
             cx.notify();


thinking
**Designing icon and hover helpers**
file update
M /Users/johnlindquist/dev/script-kit-gpui/src/prompts/select/render.rs
@@ -2,2 +2,54 @@
 
+const ROW_FOCUSED_BG_ALPHA: u32 = 0x3A;
+const ROW_HOVER_BG_ALPHA: u32 = 0x26;
+
+fn extract_choice_icon_hint(description: Option<&str>) -> Option<&str> {
+    description.and_then(|raw| {
+        raw.split(['‚Ä¢', '|', '\n'])
+            .map(str::trim)
+            .find_map(|token| {
+                let token_lower = token.to_ascii_lowercase();
+                if token_lower == "icon"
+                    || token_lower.starts_with("icon:")
+                    || token_lower.starts_with("icon=")
+                    || token_lower.starts_with("icon ")
+                {
+                    token
+                        .split_once(':')
+                        .or_else(|| token.split_once('='))
+                        .map(|(_, value)| value.trim())
+                        .or_else(|| token.split_whitespace().nth(1))
+                } else {
+                    None
+                }
+            })
+            .filter(|value| !value.is_empty())
+    })
+}
+
+fn icon_kind_from_choice(choice: &Choice) -> IconKind {
+    let metadata_icon = extract_choice_icon_hint(choice.description.as_deref())
+        .and_then(IconKind::from_icon_hint);
+    let name_prefix_icon = choice
+        .name
+        .split_whitespace()
+        .next()
+        .and_then(IconKind::from_icon_hint);
+
+    metadata_icon
+        .or(name_prefix_icon)
+        .unwrap_or_else(|| IconKind::Svg("Code".to_string()))
+}
+
+fn leading_content_from_icon_kind(icon_kind: IconKind) -> LeadingContent {
+    match icon_kind {
+        IconKind::Emoji(emoji) => LeadingContent::Emoji(emoji.into()),
+        IconKind::Image(render_image) => LeadingContent::AppIcon(render_image),
+        IconKind::Svg(name) => LeadingContent::Icon {
+            name: SharedString::from(name),
+            color: None,
+        },
+    }
+}
+
 impl Focusable for SelectPrompt {
@@ -78,2 +130,9 @@
         ));
+        let row_accent_color = if self.design_variant == DesignVariant::Default {
+            self.theme.colors.accent.selected
+        } else {
+            colors.accent
+        };
+        let focused_row_bg = rgba((row_accent_color << 8) | ROW_FOCUSED_BG_ALPHA);
+        let hovered_row_bg = rgba((row_accent_color << 8) | ROW_HOVER_BG_ALPHA);
 
@@ -147,4 +206,8 @@
                           _window,
-                          _cx| {
-                        let row_colors = UnifiedListItemColors::from_theme(&this.theme);
+                          cx| {
+                        let item_colors = UnifiedListItemColors {
+                            selected_opacity: 0.0,
+                            hover_opacity: 0.0,
+                            ..UnifiedListItemColors::from_theme(&this.theme)
+                        };
                         let mut rows = Vec::with_capacity(visible_range.len());
@@ -158,7 +221,3 @@
                                         let is_selected = this.selected.contains(&choice_idx);
-                                        let is_selected_for_ui = if this.multiple {
-                                            is_selected
-                                        } else {
-                                            is_focused
-                                        };
+                                        let is_hovered = this.hovered_index == Some(display_idx);
                                         let semantic_id =
@@ -167,6 +226,12 @@
                                             });
-                                        let indicator = choice_selection_indicator(
-                                            this.multiple,
-                                            is_selected_for_ui,
-                                        );
+                                        let leading = if this.multiple {
+                                            Some(LeadingContent::Emoji(
+                                                choice_selection_indicator(true, is_selected)
+                                                    .into(),
+                                            ))
+                                        } else {
+                                            Some(leading_content_from_icon_kind(
+                                                icon_kind_from_choice(choice),
+                                            ))
+                                        };
                                         let subtitle = indexed_choice
@@ -187,30 +252,57 @@
                                             );
+                                        let row_bg = if is_focused {
+                                            focused_row_bg
+                                        } else if is_hovered {
+                                            hovered_row_bg
+                                        } else {
+                                            rgba(0x00000000)
+                                        };
+                                        let hover_handler = cx.listener(
+                                            move |this: &mut SelectPrompt,
+                                                  hovered: &bool,
+                                                  _window,
+                                                  cx| {
+                                                if *hovered {
+                                                    if this.hovered_index != Some(display_idx) {
+                                                        this.hovered_index = Some(display_idx);
+                                                        cx.notify();
+                                                    }
+                                                } else if this.hovered_index == Some(display_idx)
+                                                {
+                                                    this.hovered_index = None;
+                                                    cx.notify();
+                                                }
+                                            },
+                                        );
+
+                                        let mut row = div()
+                                            .id(display_idx)
+                                            .w_full()
+                                            .h(px(LIST_ITEM_HEIGHT))
+                                            .rounded(px(8.0))
+                                            .bg(row_bg)
+                                            .cursor_pointer()
+                                            .on_hover(hover_handler)
+                                            .child(
+                                                UnifiedListItem::new(
+                                                    gpui::ElementId::Name(semantic_id.into()),
+                                                    title,
+                                                )
+                                                .subtitle_opt(subtitle)
+                                                .leading_opt(leading)
+                                                .trailing_opt(trailing)
+                                                .state(ItemState {
+                                                    is_selected,
+                                                    is_hovered,
+                                                    is_disabled: false,
+                                                })
+                                                .density(Density::Comfortable)
+                                                .colors(item_colors),
+                                            );
 
-                                        rows.push(
-                                            div()
-                                                .id(display_idx)
-                                                .w_full()
-                                                .h(px(LIST_ITEM_HEIGHT))
-                                                .border_b_1()
-                                                .border_color(border_color)
-                                                .child(
-                                                    UnifiedListItem::new(
-                                                        gpui::ElementId::Name(semantic_id.into()),
-                                                        title,
-                                                    )
-                                                    .subtitle_opt(subtitle)
-                                                    .leading(LeadingContent::Emoji(
-                                                        indicator.into(),
-                                                    ))
-                                                    .trailing_opt(trailing)
-                                                    .state(ItemState {
-                                                        is_selected: is_focused,
-                                                        is_hovered: false,
-                                                        is_disabled: false,
-                                                    })
-                                                    .density(Density::Comfortable)
-                                                    .colors(row_colors)
-                                                    .with_accent_bar(is_selected_for_ui),
-                                                ),
-                                        );
+                                        if !is_focused {
+                                            row = row.hover(move |s| s.bg(hovered_row_bg));
+                                        }
+
+                                        rows.push(row);
                                     }
@@ -236,2 +328,3 @@
             .w_full()
+            .px(px(8.0))
             .child(choices_content);
apply_patch(auto_approved=true) exited 0 in 26ms:
Success. Updated the following files:
M src/prompts/select/render.rs
file update:
diff --git a/src/list_item/part_000.rs b/src/list_item/part_000.rs
index 733d4ac2aa5b1b27b29a5999310e6f3f45cc54c3..283b2263d56a92c73c22d44443db7b40971d26ce
--- a/src/list_item/part_000.rs
+++ b/src/list_item/part_000.rs
@@ -15,6 +15,37 @@
     /// Maps to IconName from designs::icon_variations
     Svg(String),
 }
+
+impl IconKind {
+    /// Resolve icon metadata into an IconKind for list rendering.
+    ///
+    /// Supports:
+    /// - Known SVG names/aliases via `icon_name_from_str` (e.g., "Terminal", "file-code")
+    /// - Emoji/symbol glyphs (e.g., "üìÑ", "‚ö°")
+    pub fn from_icon_hint(icon_hint: &str) -> Option<Self> {
+        let trimmed = icon_hint.trim();
+        if trimmed.is_empty() {
+            return None;
+        }
+
+        if icon_name_from_str(trimmed).is_some() {
+            return Some(Self::Svg(trimmed.to_string()));
+        }
+
+        if looks_like_symbol_icon_hint(trimmed) {
+            return Some(Self::Emoji(trimmed.to_string()));
+        }
+
+        None
+    }
+}
+
+fn looks_like_symbol_icon_hint(icon_hint: &str) -> bool {
+    let has_ascii_alnum = icon_hint.chars().any(|ch| ch.is_ascii_alphanumeric());
+    let char_count = icon_hint.chars().count();
+
+    !has_ascii_alnum && char_count <= 4
+}
 /// Fixed height for list items used in uniform-height virtualized lists.
 ///
 /// IMPORTANT: When using GPUI `uniform_list`, the item closure must render
@@ -437,3 +468,29 @@
     /// Text color for content displayed on accent/warning backgrounds
     pub text_on_accent: u32,
 }
+
+#[cfg(test)]
+mod icon_kind_tests {
+    use super::IconKind;
+
+    #[test]
+    fn test_icon_kind_from_icon_hint_returns_svg_when_known_icon_name() {
+        match IconKind::from_icon_hint("terminal") {
+            Some(IconKind::Svg(name)) => assert_eq!(name, "terminal"),
+            _ => panic!("expected SVG icon from known icon hint"),
+        }
+    }
+
+    #[test]
+    fn test_icon_kind_from_icon_hint_returns_emoji_when_symbol_glyph() {
+        match IconKind::from_icon_hint("üìÑ") {
+            Some(IconKind::Emoji(emoji)) => assert_eq!(emoji, "üìÑ"),
+            _ => panic!("expected emoji icon for symbol glyph"),
+        }
+    }
+
+    #[test]
+    fn test_icon_kind_from_icon_hint_returns_none_for_unknown_ascii_word() {
+        assert!(IconKind::from_icon_hint("unknown-icon-name").is_none());
+    }
+}
diff --git a/src/prompts/select/mod.rs b/src/prompts/select/mod.rs
index b6366dabfb14f3fae09f854f9de824fa629e0a3b..4ff3662b0b553a2aa8b9d8c752504d9db09a20da
--- a/src/prompts/select/mod.rs
+++ b/src/prompts/select/mod.rs
@@ -19,7 +19,7 @@
     UnifiedListItemColors,
 };
 use crate::designs::{get_tokens, DesignColors, DesignVariant};
-use crate::list_item::LIST_ITEM_HEIGHT;
+use crate::list_item::{IconKind, LIST_ITEM_HEIGHT};
 use crate::logging;
 use crate::panel::PROMPT_INPUT_FIELD_HEIGHT;
 use crate::protocol::{generate_semantic_id, Choice};
diff --git a/src/prompts/select/prompt.rs b/src/prompts/select/prompt.rs
index c5f98f5318f5b520e9223811f735e866ee06e7fb..5ba2de479b2f5680a73db72642377f68d26ee54e
--- a/src/prompts/select/prompt.rs
+++ b/src/prompts/select/prompt.rs
@@ -19,6 +19,8 @@
     pub filtered_choices: Vec<usize>,
     /// Currently focused index in filtered list
     pub focused_index: usize,
+    /// Currently hovered index in filtered list
+    pub hovered_index: Option<usize>,
     /// Filter text
     pub filter_text: String,
     /// Whether multiple selection is allowed
@@ -68,6 +70,7 @@
             selected: HashSet::new(),
             filtered_choices,
             focused_index: 0,
+            hovered_index: None,
             filter_text: String::new(),
             multiple,
             focus_handle,
@@ -84,6 +87,7 @@
         if trimmed_filter.is_empty() {
             self.filtered_choices = (0..self.choices.len()).collect();
             self.focused_index = 0;
+            self.hovered_index = None;
             return;
         }
 
@@ -109,6 +113,7 @@
 
         self.filtered_choices = scored_matches.into_iter().map(|(idx, _)| idx).collect();
         self.focused_index = 0;
+        self.hovered_index = None;
     }
 
     /// Set the filter text programmatically
@@ -168,6 +173,7 @@
     pub(super) fn move_up(&mut self, cx: &mut Context<Self>) {
         if self.focused_index > 0 {
             self.focused_index -= 1;
+            self.hovered_index = None;
             self.list_scroll_handle
                 .scroll_to_item(self.focused_index, ScrollStrategy::Nearest);
             cx.notify();
@@ -178,6 +184,7 @@
     pub(super) fn move_down(&mut self, cx: &mut Context<Self>) {
         if self.focused_index < self.filtered_choices.len().saturating_sub(1) {
             self.focused_index += 1;
+            self.hovered_index = None;
             self.list_scroll_handle
                 .scroll_to_item(self.focused_index, ScrollStrategy::Nearest);
             cx.notify();
diff --git a/src/prompts/select/render.rs b/src/prompts/select/render.rs
index 62109896c9c14b1b2fbf5b4d25d5d94e4388e4aa..8c67aba367edf1587ee80ac17707f23ad35c2ce1
--- a/src/prompts/select/render.rs
+++ b/src/prompts/select/render.rs
@@ -1,5 +1,57 @@
 use super::*;
 
+const ROW_FOCUSED_BG_ALPHA: u32 = 0x3A;
+const ROW_HOVER_BG_ALPHA: u32 = 0x26;
+
+fn extract_choice_icon_hint(description: Option<&str>) -> Option<&str> {
+    description.and_then(|raw| {
+        raw.split(['‚Ä¢', '|', '\n'])
+            .map(str::trim)
+            .find_map(|token| {
+                let token_lower = token.to_ascii_lowercase();
+                if token_lower == "icon"
+                    || token_lower.starts_with("icon:")
+                    || token_lower.starts_with("icon=")
+                    || token_lower.starts_with("icon ")
+                {
+                    token
+                        .split_once(':')
+                        .or_else(|| token.split_once('='))
+                        .map(|(_, value)| value.trim())
+                        .or_else(|| token.split_whitespace().nth(1))
+                } else {
+                    None
+                }
+            })
+            .filter(|value| !value.is_empty())
+    })
+}
+
+fn icon_kind_from_choice(choice: &Choice) -> IconKind {
+    let metadata_icon = extract_choice_icon_hint(choice.description.as_deref())
+        .and_then(IconKind::from_icon_hint);
+    let name_prefix_icon = choice
+        .name
+        .split_whitespace()
+        .next()
+        .and_then(IconKind::from_icon_hint);
+
+    metadata_icon
+        .or(name_prefix_icon)
+        .unwrap_or_else(|| IconKind::Svg("Code".to_string()))
+}
+
+fn leading_content_from_icon_kind(icon_kind: IconKind) -> LeadingContent {
+    match icon_kind {
+        IconKind::Emoji(emoji) => LeadingContent::Emoji(emoji.into()),
+        IconKind::Image(render_image) => LeadingContent::AppIcon(render_image),
+        IconKind::Svg(name) => LeadingContent::Icon {
+            name: SharedString::from(name),
+            color: None,
+        },
+    }
+}
+
 impl Focusable for SelectPrompt {
     fn focus_handle(&self, _cx: &gpui::App) -> FocusHandle {
         self.focus_handle.clone()
@@ -76,6 +128,13 @@
             self.design_variant,
             &colors,
         ));
+        let row_accent_color = if self.design_variant == DesignVariant::Default {
+            self.theme.colors.accent.selected
+        } else {
+            colors.accent
+        };
+        let focused_row_bg = rgba((row_accent_color << 8) | ROW_FOCUSED_BG_ALPHA);
+        let hovered_row_bg = rgba((row_accent_color << 8) | ROW_HOVER_BG_ALPHA);
 
         let placeholder = self
             .placeholder
@@ -145,8 +204,12 @@
                     move |this: &mut SelectPrompt,
                           visible_range: std::ops::Range<usize>,
                           _window,
-                          _cx| {
-                        let row_colors = UnifiedListItemColors::from_theme(&this.theme);
+                          cx| {
+                        let item_colors = UnifiedListItemColors {
+                            selected_opacity: 0.0,
+                            hover_opacity: 0.0,
+                            ..UnifiedListItemColors::from_theme(&this.theme)
+                        };
                         let mut rows = Vec::with_capacity(visible_range.len());
 
                         for display_idx in visible_range {
@@ -156,19 +219,21 @@
                                     {
                                         let is_focused = display_idx == this.focused_index;
                                         let is_selected = this.selected.contains(&choice_idx);
-                                        let is_selected_for_ui = if this.multiple {
-                                            is_selected
-                                        } else {
-                                            is_focused
-                                        };
+                                        let is_hovered = this.hovered_index == Some(display_idx);
                                         let semantic_id =
                                             choice.semantic_id.clone().unwrap_or_else(|| {
                                                 indexed_choice.stable_semantic_id.clone()
                                             });
-                                        let indicator = choice_selection_indicator(
-                                            this.multiple,
-                                            is_selected_for_ui,
-                                        );
+                                        let leading = if this.multiple {
+                                            Some(LeadingContent::Emoji(
+                                                choice_selection_indicator(true, is_selected)
+                                                    .into(),
+                                            ))
+                                        } else {
+                                            Some(leading_content_from_icon_kind(
+                                                icon_kind_from_choice(choice),
+                                            ))
+                                        };
                                         let subtitle = indexed_choice
                                             .metadata
                                             .subtitle_text()
@@ -185,34 +250,61 @@
                                                     ))
                                                 },
                                             );
+                                        let row_bg = if is_focused {
+                                            focused_row_bg
+                                        } else if is_hovered {
+                                            hovered_row_bg
+                                        } else {
+                                            rgba(0x00000000)
+                                        };
+                                        let hover_handler = cx.listener(
+                                            move |this: &mut SelectPrompt,
+                                                  hovered: &bool,
+                                                  _window,
+                                                  cx| {
+                                                if *hovered {
+                                                    if this.hovered_index != Some(display_idx) {
+                                                        this.hovered_index = Some(display_idx);
+                                                        cx.notify();
+                                                    }
+                                                } else if this.hovered_index == Some(display_idx)
+                                                {
+                                                    this.hovered_index = None;
+                                                    cx.notify();
+                                                }
+                                            },
+                                        );
+
+                                        let mut row = div()
+                                            .id(display_idx)
+                                            .w_full()
+                                            .h(px(LIST_ITEM_HEIGHT))
+                                            .rounded(px(8.0))
+                                            .bg(row_bg)
+                                            .cursor_pointer()
+                                            .on_hover(hover_handler)
+                                            .child(
+                                                UnifiedListItem::new(
+                                                    gpui::ElementId::Name(semantic_id.into()),
+                                                    title,
+                                                )
+                                                .subtitle_opt(subtitle)
+                                                .leading_opt(leading)
+                                                .trailing_opt(trailing)
+                                                .state(ItemState {
+                                                    is_selected,
+                                                    is_hovered,
+                                                    is_disabled: false,
+                                                })
+                                                .density(Density::Comfortable)
+                                                .colors(item_colors),
+                                            );
 
-                                        rows.push(
-                                            div()
-                                                .id(display_idx)
-                                                .w_full()
-                                                .h(px(LIST_ITEM_HEIGHT))
-                                                .border_b_1()
-                                                .border_color(border_color)
-                                                .child(
-                                                    UnifiedListItem::new(
-                                                        gpui::ElementId::Name(semantic_id.into()),
-                                                        title,
-                                                    )
-                                                    .subtitle_opt(subtitle)
-                                                    .leading(LeadingContent::Emoji(
-                                                        indicator.into(),
-                                                    ))
-                                                    .trailing_opt(trailing)
-                                                    .state(ItemState {
-                                                        is_selected: is_focused,
-                                                        is_hovered: false,
-                                                        is_disabled: false,
-                                                    })
-                                                    .density(Density::Comfortable)
-                                                    .colors(row_colors)
-                                                    .with_accent_bar(is_selected_for_ui),
-                                                ),
-                                        );
+                                        if !is_focused {
+                                            row = row.hover(move |s| s.bg(hovered_row_bg));
+                                        }
+
+                                        rows.push(row);
                                     }
                                 }
                             }
@@ -234,6 +326,7 @@
             .flex_col()
             .flex_1()
             .w_full()
+            .px(px(8.0))
             .child(choices_content);
 
         div()

file update:
diff --git a/src/list_item/part_000.rs b/src/list_item/part_000.rs
index 733d4ac2aa5b1b27b29a5999310e6f3f45cc54c3..283b2263d56a92c73c22d44443db7b40971d26ce
--- a/src/list_item/part_000.rs
+++ b/src/list_item/part_000.rs
@@ -15,6 +15,37 @@
     /// Maps to IconName from designs::icon_variations
     Svg(String),
 }
+
+impl IconKind {
+    /// Resolve icon metadata into an IconKind for list rendering.
+    ///
+    /// Supports:
+    /// - Known SVG names/aliases via `icon_name_from_str` (e.g., "Terminal", "file-code")
+    /// - Emoji/symbol glyphs (e.g., "üìÑ", "‚ö°")
+    pub fn from_icon_hint(icon_hint: &str) -> Option<Self> {
+        let trimmed = icon_hint.trim();
+        if trimmed.is_empty() {
+            return None;
+        }
+
+        if icon_name_from_str(trimmed).is_some() {
+            return Some(Self::Svg(trimmed.to_string()));
+        }
+
+        if looks_like_symbol_icon_hint(trimmed) {
+            return Some(Self::Emoji(trimmed.to_string()));
+        }
+
+        None
+    }
+}
+
+fn looks_like_symbol_icon_hint(icon_hint: &str) -> bool {
+    let has_ascii_alnum = icon_hint.chars().any(|ch| ch.is_ascii_alphanumeric());
+    let char_count = icon_hint.chars().count();
+
+    !has_ascii_alnum && char_count <= 4
+}
 /// Fixed height for list items used in uniform-height virtualized lists.
 ///
 /// IMPORTANT: When using GPUI `uniform_list`, the item closure must render
@@ -437,3 +468,29 @@
     /// Text color for content displayed on accent/warning backgrounds
     pub text_on_accent: u32,
 }
+
+#[cfg(test)]
+mod icon_kind_tests {
+    use super::IconKind;
+
+    #[test]
+    fn test_icon_kind_from_icon_hint_returns_svg_when_known_icon_name() {
+        match IconKind::from_icon_hint("terminal") {
+            Some(IconKind::Svg(name)) => assert_eq!(name, "terminal"),
+            _ => panic!("expected SVG icon from known icon hint"),
+        }
+    }
+
+    #[test]
+    fn test_icon_kind_from_icon_hint_returns_emoji_when_symbol_glyph() {
+        match IconKind::from_icon_hint("üìÑ") {
+            Some(IconKind::Emoji(emoji)) => assert_eq!(emoji, "üìÑ"),
+            _ => panic!("expected emoji icon for symbol glyph"),
+        }
+    }
+
+    #[test]
+    fn test_icon_kind_from_icon_hint_returns_none_for_unknown_ascii_word() {
+        assert!(IconKind::from_icon_hint("unknown-icon-name").is_none());
+    }
+}
diff --git a/src/prompts/select/mod.rs b/src/prompts/select/mod.rs
index b6366dabfb14f3fae09f854f9de824fa629e0a3b..4ff3662b0b553a2aa8b9d8c752504d9db09a20da
--- a/src/prompts/select/mod.rs
+++ b/src/prompts/select/mod.rs
@@ -19,7 +19,7 @@
     UnifiedListItemColors,
 };
 use crate::designs::{get_tokens, DesignColors, DesignVariant};
-use crate::list_item::LIST_ITEM_HEIGHT;
+use crate::list_item::{IconKind, LIST_ITEM_HEIGHT};
 use crate::logging;
 use crate::panel::PROMPT_INPUT_FIELD_HEIGHT;
 use crate::protocol::{generate_semantic_id, Choice};
diff --git a/src/prompts/select/prompt.rs b/src/prompts/select/prompt.rs
index c5f98f5318f5b520e9223811f735e866ee06e7fb..5ba2de479b2f5680a73db72642377f68d26ee54e
--- a/src/prompts/select/prompt.rs
+++ b/src/prompts/select/prompt.rs
@@ -19,6 +19,8 @@
     pub filtered_choices: Vec<usize>,
     /// Currently focused index in filtered list
     pub focused_index: usize,
+    /// Currently hovered index in filtered list
+    pub hovered_index: Option<usize>,
     /// Filter text
     pub filter_text: String,
     /// Whether multiple selection is allowed
@@ -68,6 +70,7 @@
             selected: HashSet::new(),
             filtered_choices,
             focused_index: 0,
+            hovered_index: None,
             filter_text: String::new(),
             multiple,
             focus_handle,
@@ -84,6 +87,7 @@
         if trimmed_filter.is_empty() {
             self.filtered_choices = (0..self.choices.len()).collect();
             self.focused_index = 0;
+            self.hovered_index = None;
             return;
         }
 
@@ -109,6 +113,7 @@
 
         self.filtered_choices = scored_matches.into_iter().map(|(idx, _)| idx).collect();
         self.focused_index = 0;
+        self.hovered_index = None;
     }
 
     /// Set the filter text programmatically
@@ -168,6 +173,7 @@
     pub(super) fn move_up(&mut self, cx: &mut Context<Self>) {
         if self.focused_index > 0 {
             self.focused_index -= 1;
+            self.hovered_index = None;
             self.list_scroll_handle
                 .scroll_to_item(self.focused_index, ScrollStrategy::Nearest);
             cx.notify();
@@ -178,6 +184,7 @@
     pub(super) fn move_down(&mut self, cx: &mut Context<Self>) {
         if self.focused_index < self.filtered_choices.len().saturating_sub(1) {
             self.focused_index += 1;
+            self.hovered_index = None;
             self.list_scroll_handle
                 .scroll_to_item(self.focused_index, ScrollStrategy::Nearest);
             cx.notify();
diff --git a/src/prompts/select/render.rs b/src/prompts/select/render.rs
index 62109896c9c14b1b2fbf5b4d25d5d94e4388e4aa..8c67aba367edf1587ee80ac17707f23ad35c2ce1
--- a/src/prompts/select/render.rs
+++ b/src/prompts/select/render.rs
@@ -1,5 +1,57 @@
 use super::*;
 
+const ROW_FOCUSED_BG_ALPHA: u32 = 0x3A;
+const ROW_HOVER_BG_ALPHA: u32 = 0x26;
+
+fn extract_choice_icon_hint(description: Option<&str>) -> Option<&str> {
+    description.and_then(|raw| {
+        raw.split(['‚Ä¢', '|', '\n'])
+            .map(str::trim)
+            .find_map(|token| {
+                let token_lower = token.to_ascii_lowercase();
+                if token_lower == "icon"
+                    || token_lower.starts_with("icon:")
+                    || token_lower.starts_with("icon=")
+                    || token_lower.starts_with("icon ")
+                {
+                    token
+                        .split_once(':')
+                        .or_else(|| token.split_once('='))
+                        .map(|(_, value)| value.trim())
+                        .or_else(|| token.split_whitespace().nth(1))
+                } else {
+                    None
+                }
+            })
+            .filter(|value| !value.is_empty())
+    })
+}
+
+fn icon_kind_from_choice(choice: &Choice) -> IconKind {
+    let metadata_icon = extract_choice_icon_hint(choice.description.as_deref())
+        .and_then(IconKind::from_icon_hint);
+    let name_prefix_icon = choice
+        .name
+        .split_whitespace()
+        .next()
+        .and_then(IconKind::from_icon_hint);
+
+    metadata_icon
+        .or(name_prefix_icon)
+        .unwrap_or_else(|| IconKind::Svg("Code".to_string()))
+}
+
+fn leading_content_from_icon_kind(icon_kind: IconKind) -> LeadingContent {
+    match icon_kind {
+        IconKind::Emoji(emoji) => LeadingContent::Emoji(emoji.into()),
+        IconKind::Image(render_image) => LeadingContent::AppIcon(render_image),
+        IconKind::Svg(name) => LeadingContent::Icon {
+            name: SharedString::from(name),
+            color: None,
+        },
+    }
+}
+
 impl Focusable for SelectPrompt {
     fn focus_handle(&self, _cx: &gpui::App) -> FocusHandle {
         self.focus_handle.clone()
@@ -76,6 +128,13 @@
             self.design_variant,
             &colors,
         ));
+        let row_accent_color = if self.design_variant == DesignVariant::Default {
+            self.theme.colors.accent.selected
+        } else {
+            colors.accent
+        };
+        let focused_row_bg = rgba((row_accent_color << 8) | ROW_FOCUSED_BG_ALPHA);
+        let hovered_row_bg = rgba((row_accent_color << 8) | ROW_HOVER_BG_ALPHA);
 
         let placeholder = self
             .placeholder
@@ -145,8 +204,12 @@
                     move |this: &mut SelectPrompt,
                           visible_range: std::ops::Range<usize>,
                           _window,
-                          _cx| {
-                        let row_colors = UnifiedListItemColors::from_theme(&this.theme);
+                          cx| {
+                        let item_colors = UnifiedListItemColors {
+                            selected_opacity: 0.0,
+                            hover_opacity: 0.0,
+                            ..UnifiedListItemColors::from_theme(&this.theme)
+                        };
                         let mut rows = Vec::with_capacity(visible_range.len());
 
                         for display_idx in visible_range {
@@ -156,19 +219,21 @@
                                     {
                                         let is_focused = display_idx == this.focused_index;
                                         let is_selected = this.selected.contains(&choice_idx);
-                                        let is_selected_for_ui = if this.multiple {
-                                            is_selected
-                                        } else {
-                                            is_focused
-                                        };
+                                        let is_hovered = this.hovered_index == Some(display_idx);
                                         let semantic_id =
                                             choice.semantic_id.clone().unwrap_or_else(|| {
                                                 indexed_choice.stable_semantic_id.clone()
                                             });
-                                        let indicator = choice_selection_indicator(
-                                            this.multiple,
-                                            is_selected_for_ui,
-                                        );
+                                        let leading = if this.multiple {
+                                            Some(LeadingContent::Emoji(
+                                                choice_selection_indicator(true, is_selected)
+                                                    .into(),
+                                            ))
+                                        } else {
+                                            Some(leading_content_from_icon_kind(
+                                                icon_kind_from_choice(choice),
+                                            ))
+                                        };
                                         let subtitle = indexed_choice
                                             .metadata
                                             .subtitle_text()
@@ -185,34 +250,61 @@
                                                     ))
                                                 },
                                             );
+                                        let row_bg = if is_focused {
+                                            focused_row_bg
+                                        } else if is_hovered {
+                                            hovered_row_bg
+                                        } else {
+                                            rgba(0x00000000)
+                                        };
+                                        let hover_handler = cx.listener(
+                                            move |this: &mut SelectPrompt,
+                                                  hovered: &bool,
+                                                  _window,
+                                                  cx| {
+                                                if *hovered {
+                                                    if this.hovered_index != Some(display_idx) {
+                                                        this.hovered_index = Some(display_idx);
+                                                        cx.notify();
+                                                    }
+                                                } else if this.hovered_index == Some(display_idx)
+                                                {
+                                                    this.hovered_index = None;
+                                                    cx.notify();
+                                                }
+                                            },
+                                        );
+
+                                        let mut row = div()
+                                            .id(display_idx)
+                                            .w_full()
+                                            .h(px(LIST_ITEM_HEIGHT))
+                                            .rounded(px(8.0))
+                                            .bg(row_bg)
+                                            .cursor_pointer()
+                                            .on_hover(hover_handler)
+                                            .child(
+                                                UnifiedListItem::new(
+                                                    gpui::ElementId::Name(semantic_id.into()),
+                                                    title,
+                                                )
+                                                .subtitle_opt(subtitle)
+                                                .leading_opt(leading)
+                                                .trailing_opt(trailing)
+                                                .state(ItemState {
+                                                    is_selected,
+                                                    is_hovered,
+                                                    is_disabled: false,
+                                                })
+                                                .density(Density::Comfortable)
+                                                .colors(item_colors),
+                                            );
 
-                                        rows.push(
-                                            div()
-                                                .id(display_idx)
-                                                .w_full()
-                                                .h(px(LIST_ITEM_HEIGHT))
-                                                .border_b_1()
-                                                .border_color(border_color)
-                                                .child(
-                                                    UnifiedListItem::new(
-                                                        gpui::ElementId::Name(semantic_id.into()),
-                                                        title,
-                                                    )
-                                                    .subtitle_opt(subtitle)
-                                                    .leading(LeadingContent::Emoji(
-                                                        indicator.into(),
-                                                    ))
-                                                    .trailing_opt(trailing)
-                                                    .state(ItemState {
-                                                        is_selected: is_focused,
-                                                        is_hovered: false,
-                                                        is_disabled: false,
-                                                    })
-                                                    .density(Density::Comfortable)
-                                                    .colors(row_colors)
-                                                    .with_accent_bar(is_selected_for_ui),
-                                                ),
-                                        );
+                                        if !is_focused {
+                                            row = row.hover(move |s| s.bg(hovered_row_bg));
+                                        }
+
+                                        rows.push(row);
                                     }
                                 }
                             }
@@ -234,6 +326,7 @@
             .flex_col()
             .flex_1()
             .w_full()
+            .px(px(8.0))
             .child(choices_content);
 
         div()


thinking
**Analyzing helper return type**
exec
/bin/zsh -lc "sed -n '1,140p' src/prompts/select/render.rs" in /Users/johnlindquist/dev/script-kit-gpui succeeded in 51ms:
use super::*;

const ROW_FOCUSED_BG_ALPHA: u32 = 0x3A;
const ROW_HOVER_BG_ALPHA: u32 = 0x26;

fn extract_choice_icon_hint(description: Option<&str>) -> Option<&str> {
    description.and_then(|raw| {
        raw.split(['‚Ä¢', '|', '\n'])
            .map(str::trim)
            .find_map(|token| {
                let token_lower = token.to_ascii_lowercase();
                if token_lower == "icon"
                    || token_lower.starts_with("icon:")
                    || token_lower.starts_with("icon=")
                    || token_lower.starts_with("icon ")
                {
                    token
                        .split_once(':')
                        .or_else(|| token.split_once('='))
                        .map(|(_, value)| value.trim())
file update:
diff --git a/src/list_item/part_000.rs b/src/list_item/part_000.rs
index 733d4ac2aa5b1b27b29a5999310e6f3f45cc54c3..283b2263d56a92c73c22d44443db7b40971d26ce
--- a/src/list_item/part_000.rs
+++ b/src/list_item/part_000.rs
@@ -15,6 +15,37 @@
     /// Maps to IconName from designs::icon_variations
     Svg(String),
 }
+
+impl IconKind {
+    /// Resolve icon metadata into an IconKind for list rendering.
+    ///
+    /// Supports:
+    /// - Known SVG names/aliases via `icon_name_from_str` (e.g., "Terminal", "file-code")
+    /// - Emoji/symbol glyphs (e.g., "üìÑ", "‚ö°")
+    pub fn from_icon_hint(icon_hint: &str) -> Option<Self> {
+        let trimmed = icon_hint.trim();
+        if trimmed.is_empty() {
+            return None;
+        }
+
+        if icon_name_from_str(trimmed).is_some() {
+            return Some(Self::Svg(trimmed.to_string()));
+        }
+
+        if looks_like_symbol_icon_hint(trimmed) {
+            return Some(Self::Emoji(trimmed.to_string()));
+        }
+
+        None
+    }
+}
+
+fn looks_like_symbol_icon_hint(icon_hint: &str) -> bool {
+    let has_ascii_alnum = icon_hint.chars().any(|ch| ch.is_ascii_alphanumeric());
+    let char_count = icon_hint.chars().count();
+
+    !has_ascii_alnum && char_count <= 4
+}
 /// Fixed height for list items used in uniform-height virtualized lists.
 ///
 /// IMPORTANT: When using GPUI `uniform_list`, the item closure must render
@@ -437,3 +468,29 @@
     /// Text color for content displayed on accent/warning backgrounds
     pub text_on_accent: u32,
 }
+
+#[cfg(test)]
+mod icon_kind_tests {
+    use super::IconKind;
+
+    #[test]
+    fn test_icon_kind_from_icon_hint_returns_svg_when_known_icon_name() {
+        match IconKind::from_icon_hint("terminal") {
+            Some(IconKind::Svg(name)) => assert_eq!(name, "terminal"),
+            _ => panic!("expected SVG icon from known icon hint"),
+        }
+    }
+
+    #[test]
+    fn test_icon_kind_from_icon_hint_returns_emoji_when_symbol_glyph() {
+        match IconKind::from_icon_hint("üìÑ") {
+            Some(IconKind::Emoji(emoji)) => assert_eq!(emoji, "üìÑ"),
+            _ => panic!("expected emoji icon for symbol glyph"),
+        }
+    }
+
+    #[test]
+    fn test_icon_kind_from_icon_hint_returns_none_for_unknown_ascii_word() {
+        assert!(IconKind::from_icon_hint("unknown-icon-name").is_none());
+    }
+}
diff --git a/src/prompts/select/mod.rs b/src/prompts/select/mod.rs
index b6366dabfb14f3fae09f854f9de824fa629e0a3b..4ff3662b0b553a2aa8b9d8c752504d9db09a20da
--- a/src/prompts/select/mod.rs
+++ b/src/prompts/select/mod.rs
@@ -19,7 +19,7 @@
     UnifiedListItemColors,
 };
 use crate::designs::{get_tokens, DesignColors, DesignVariant};
-use crate::list_item::LIST_ITEM_HEIGHT;
+use crate::list_item::{IconKind, LIST_ITEM_HEIGHT};
 use crate::logging;
 use crate::panel::PROMPT_INPUT_FIELD_HEIGHT;
 use crate::protocol::{generate_semantic_id, Choice};
diff --git a/src/prompts/select/prompt.rs b/src/prompts/select/prompt.rs
index c5f98f5318f5b520e9223811f735e866ee06e7fb..5ba2de479b2f5680a73db72642377f68d26ee54e
--- a/src/prompts/select/prompt.rs
+++ b/src/prompts/select/prompt.rs
@@ -19,6 +19,8 @@
     pub filtered_choices: Vec<usize>,
     /// Currently focused index in filtered list
     pub focused_index: usize,
+    /// Currently hovered index in filtered list
+    pub hovered_index: Option<usize>,
     /// Filter text
     pub filter_text: String,
     /// Whether multiple selection is allowed
@@ -68,6 +70,7 @@
             selected: HashSet::new(),
             filtered_choices,
             focused_index: 0,
+            hovered_index: None,
             filter_text: String::new(),
             multiple,
             focus_handle,
@@ -84,6 +87,7 @@
         if trimmed_filter.is_empty() {
             self.filtered_choices = (0..self.choices.len()).collect();
             self.focused_index = 0;
+            self.hovered_index = None;
             return;
         }
 
@@ -109,6 +113,7 @@
 
         self.filtered_choices = scored_matches.into_iter().map(|(idx, _)| idx).collect();
         self.focused_index = 0;
+        self.hovered_index = None;
     }
 
     /// Set the filter text programmatically
@@ -168,6 +173,7 @@
     pub(super) fn move_up(&mut self, cx: &mut Context<Self>) {
         if self.focused_index > 0 {
             self.focused_index -= 1;
+            self.hovered_index = None;
             self.list_scroll_handle
                 .scroll_to_item(self.focused_index, ScrollStrategy::Nearest);
             cx.notify();
@@ -178,6 +184,7 @@
     pub(super) fn move_down(&mut self, cx: &mut Context<Self>) {
         if self.focused_index < self.filtered_choices.len().saturating_sub(1) {
             self.focused_index += 1;
+            self.hovered_index = None;
             self.list_scroll_handle
                 .scroll_to_item(self.focused_index, ScrollStrategy::Nearest);
             cx.notify();
diff --git a/src/prompts/select/render.rs b/src/prompts/select/render.rs
index 62109896c9c14b1b2fbf5b4d25d5d94e4388e4aa..8c67aba367edf1587ee80ac17707f23ad35c2ce1
--- a/src/prompts/select/render.rs
+++ b/src/prompts/select/render.rs
@@ -1,5 +1,57 @@
 use super::*;
 
+const ROW_FOCUSED_BG_ALPHA: u32 = 0x3A;
+const ROW_HOVER_BG_ALPHA: u32 = 0x26;
+
+fn extract_choice_icon_hint(description: Option<&str>) -> Option<&str> {
+    description.and_then(|raw| {
+        raw.split(['‚Ä¢', '|', '\n'])
+            .map(str::trim)
+            .find_map(|token| {
+                let token_lower = token.to_ascii_lowercase();
+                if token_lower == "icon"
+                    || token_lower.starts_with("icon:")
+                    || token_lower.starts_with("icon=")
+                    || token_lower.starts_with("icon ")
+                {
+                    token
+                        .split_once(':')
+                        .or_else(|| token.split_once('='))
+                        .map(|(_, value)| value.trim())
+                        .or_else(|| token.split_whitespace().nth(1))
+                } else {
+                    None
+                }
+            })
+            .filter(|value| !value.is_empty())
+    })
+}
+
+fn icon_kind_from_choice(choice: &Choice) -> IconKind {
+    let metadata_icon = extract_choice_icon_hint(choice.description.as_deref())
+        .and_then(IconKind::from_icon_hint);
+    let name_prefix_icon = choice
+        .name
+        .split_whitespace()
+        .next()
+        .and_then(IconKind::from_icon_hint);
+
+    metadata_icon
+        .or(name_prefix_icon)
+        .unwrap_or_else(|| IconKind::Svg("Code".to_string()))
+}
+
+fn leading_content_from_icon_kind(icon_kind: IconKind) -> LeadingContent {
+    match icon_kind {
+        IconKind::Emoji(emoji) => LeadingContent::Emoji(emoji.into()),
+        IconKind::Image(render_image) => LeadingContent::AppIcon(render_image),
+        IconKind::Svg(name) => LeadingContent::Icon {
+            name: SharedString::from(name),
+            color: None,
+        },
+    }
+}
+
 impl Focusable for SelectPrompt {
     fn focus_handle(&self, _cx: &gpui::App) -> FocusHandle {
         self.focus_handle.clone()
@@ -76,6 +128,13 @@
             self.design_variant,
             &colors,
         ));
+        let row_accent_color = if self.design_variant == DesignVariant::Default {
+            self.theme.colors.accent.selected
+        } else {
+            colors.accent
+        };
+        let focused_row_bg = rgba((row_accent_color << 8) | ROW_FOCUSED_BG_ALPHA);
+        let hovered_row_bg = rgba((row_accent_color << 8) | ROW_HOVER_BG_ALPHA);
 
         let placeholder = self
             .placeholder
@@ -145,8 +204,12 @@
                     move |this: &mut SelectPrompt,
                           visible_range: std::ops::Range<usize>,
                           _window,
-                          _cx| {
-                        let row_colors = UnifiedListItemColors::from_theme(&this.theme);
+                          cx| {
+                        let item_colors = UnifiedListItemColors {
+                            selected_opacity: 0.0,
+                            hover_opacity: 0.0,
+                            ..UnifiedListItemColors::from_theme(&this.theme)
+                        };
                         let mut rows = Vec::with_capacity(visible_range.len());
 
                         for display_idx in visible_range {
@@ -156,19 +219,21 @@
                                     {
                                         let is_focused = display_idx == this.focused_index;
                                         let is_selected = this.selected.contains(&choice_idx);
-                                        let is_selected_for_ui = if this.multiple {
-                                            is_selected
-                                        } else {
-                                            is_focused
-                                        };
+                                        let is_hovered = this.hovered_index == Some(display_idx);
                                         let semantic_id =
                                             choice.semantic_id.clone().unwrap_or_else(|| {
                                                 indexed_choice.stable_semantic_id.clone()
                                             });
-                                        let indicator = choice_selection_indicator(
-                                            this.multiple,
-                                            is_selected_for_ui,
-                                        );
+                                        let leading = if this.multiple {
+                                            Some(LeadingContent::Emoji(
+                                                choice_selection_indicator(true, is_selected)
+                                                    .into(),
+                                            ))
+                                        } else {
+                                            Some(leading_content_from_icon_kind(
+                                                icon_kind_from_choice(choice),
+                                            ))
+                                        };
                                         let subtitle = indexed_choice
                                             .metadata
                                             .subtitle_text()
@@ -185,34 +250,61 @@
                                                     ))
                                                 },
                                             );
+                                        let row_bg = if is_focused {
+                                            focused_row_bg
+                                        } else if is_hovered {
+                                            hovered_row_bg
+                                        } else {
+                                            rgba(0x00000000)
+                                        };
+                                        let hover_handler = cx.listener(
+                                            move |this: &mut SelectPrompt,
+                                                  hovered: &bool,
+                                                  _window,
+                                                  cx| {
+                                                if *hovered {
+                                                    if this.hovered_index != Some(display_idx) {
+                                                        this.hovered_index = Some(display_idx);
+                                                        cx.notify();
+                                                    }
+                                                } else if this.hovered_index == Some(display_idx)
+                                                {
+                                                    this.hovered_index = None;
+                                                    cx.notify();
+                                                }
+                                            },
+                                        );
+
+                                        let mut row = div()
+                                            .id(display_idx)
+                                            .w_full()
+                                            .h(px(LIST_ITEM_HEIGHT))
+                                            .rounded(px(8.0))
+                                            .bg(row_bg)
+                                            .cursor_pointer()
+                                            .on_hover(hover_handler)
+                                            .child(
+                                                UnifiedListItem::new(
+                                                    gpui::ElementId::Name(semantic_id.into()),
+                                                    title,
+                                                )
+                                                .subtitle_opt(subtitle)
+                                                .leading_opt(leading)
+                                                .trailing_opt(trailing)
+                                                .state(ItemState {
+                                                    is_selected,
+                                                    is_hovered,
+                                                    is_disabled: false,
+                                                })
+                                                .density(Density::Comfortable)
+                                                .colors(item_colors),
+                                            );
 
-                                        rows.push(
-                                            div()
-                                                .id(display_idx)
-                                                .w_full()
-                                                .h(px(LIST_ITEM_HEIGHT))
-                                                .border_b_1()
-                                                .border_color(border_color)
-                                                .child(
-                                                    UnifiedListItem::new(
-                                                        gpui::ElementId::Name(semantic_id.into()),
-                                                        title,
-                                                    )
-                                                    .subtitle_opt(subtitle)
-                                                    .leading(LeadingContent::Emoji(
-                                                        indicator.into(),
-                                                    ))
-                                                    .trailing_opt(trailing)
-                                                    .state(ItemState {
-                                                        is_selected: is_focused,
-                                                        is_hovered: false,
-                                                        is_disabled: false,
-                                                    })
-                                                    .density(Density::Comfortable)
-                                                    .colors(row_colors)
-                                                    .with_accent_bar(is_selected_for_ui),
-                                                ),
-                                        );
+                                        if !is_focused {
+                                            row = row.hover(move |s| s.bg(hovered_row_bg));
+                                        }
+
+                                        rows.push(row);
                                     }
                                 }
                             }
@@ -234,6 +326,7 @@
             .flex_col()
             .flex_1()
             .w_full()
+            .px(px(8.0))
             .child(choices_content);
 
         div()


thinking
**Reviewing code around row creation and closure**
exec
/bin/zsh -lc "sed -n '140,300p' src/prompts/select/render.rs" in /Users/johnlindquist/dev/script-kit-gpui succeeded in 50ms:
            .placeholder
            .clone()
            .unwrap_or_else(|| "Search...".to_string());

        let input_display = if self.filter_text.is_empty() {
            SharedString::from(placeholder)
        } else {
            SharedString::from(self.filter_text.clone())
        };

        // Search input
        let input_container = div()
            .id(gpui::ElementId::Name("input:select-filter".into()))
            .w_full()
            .min_h(px(PROMPT_INPUT_FIELD_HEIGHT))
            .px(px(spacing.item_padding_x))
            .py(px(spacing.padding_md))
            .bg(search_box_bg)
            .border_b_1()
            .border_color(border_color)
file update:
diff --git a/src/list_item/part_000.rs b/src/list_item/part_000.rs
index 733d4ac2aa5b1b27b29a5999310e6f3f45cc54c3..283b2263d56a92c73c22d44443db7b40971d26ce
--- a/src/list_item/part_000.rs
+++ b/src/list_item/part_000.rs
@@ -15,6 +15,37 @@
     /// Maps to IconName from designs::icon_variations
     Svg(String),
 }
+
+impl IconKind {
+    /// Resolve icon metadata into an IconKind for list rendering.
+    ///
+    /// Supports:
+    /// - Known SVG names/aliases via `icon_name_from_str` (e.g., "Terminal", "file-code")
+    /// - Emoji/symbol glyphs (e.g., "üìÑ", "‚ö°")
+    pub fn from_icon_hint(icon_hint: &str) -> Option<Self> {
+        let trimmed = icon_hint.trim();
+        if trimmed.is_empty() {
+            return None;
+        }
+
+        if icon_name_from_str(trimmed).is_some() {
+            return Some(Self::Svg(trimmed.to_string()));
+        }
+
+        if looks_like_symbol_icon_hint(trimmed) {
+            return Some(Self::Emoji(trimmed.to_string()));
+        }
+
+        None
+    }
+}
+
+fn looks_like_symbol_icon_hint(icon_hint: &str) -> bool {
+    let has_ascii_alnum = icon_hint.chars().any(|ch| ch.is_ascii_alphanumeric());
+    let char_count = icon_hint.chars().count();
+
+    !has_ascii_alnum && char_count <= 4
+}
 /// Fixed height for list items used in uniform-height virtualized lists.
 ///
 /// IMPORTANT: When using GPUI `uniform_list`, the item closure must render
@@ -437,3 +468,29 @@
     /// Text color for content displayed on accent/warning backgrounds
     pub text_on_accent: u32,
 }
+
+#[cfg(test)]
+mod icon_kind_tests {
+    use super::IconKind;
+
+    #[test]
+    fn test_icon_kind_from_icon_hint_returns_svg_when_known_icon_name() {
+        match IconKind::from_icon_hint("terminal") {
+            Some(IconKind::Svg(name)) => assert_eq!(name, "terminal"),
+            _ => panic!("expected SVG icon from known icon hint"),
+        }
+    }
+
+    #[test]
+    fn test_icon_kind_from_icon_hint_returns_emoji_when_symbol_glyph() {
+        match IconKind::from_icon_hint("üìÑ") {
+            Some(IconKind::Emoji(emoji)) => assert_eq!(emoji, "üìÑ"),
+            _ => panic!("expected emoji icon for symbol glyph"),
+        }
+    }
+
+    #[test]
+    fn test_icon_kind_from_icon_hint_returns_none_for_unknown_ascii_word() {
+        assert!(IconKind::from_icon_hint("unknown-icon-name").is_none());
+    }
+}
diff --git a/src/prompts/select/mod.rs b/src/prompts/select/mod.rs
index b6366dabfb14f3fae09f854f9de824fa629e0a3b..4ff3662b0b553a2aa8b9d8c752504d9db09a20da
--- a/src/prompts/select/mod.rs
+++ b/src/prompts/select/mod.rs
@@ -19,7 +19,7 @@
     UnifiedListItemColors,
 };
 use crate::designs::{get_tokens, DesignColors, DesignVariant};
-use crate::list_item::LIST_ITEM_HEIGHT;
+use crate::list_item::{IconKind, LIST_ITEM_HEIGHT};
 use crate::logging;
 use crate::panel::PROMPT_INPUT_FIELD_HEIGHT;
 use crate::protocol::{generate_semantic_id, Choice};
diff --git a/src/prompts/select/prompt.rs b/src/prompts/select/prompt.rs
index c5f98f5318f5b520e9223811f735e866ee06e7fb..5ba2de479b2f5680a73db72642377f68d26ee54e
--- a/src/prompts/select/prompt.rs
+++ b/src/prompts/select/prompt.rs
@@ -19,6 +19,8 @@
     pub filtered_choices: Vec<usize>,
     /// Currently focused index in filtered list
     pub focused_index: usize,
+    /// Currently hovered index in filtered list
+    pub hovered_index: Option<usize>,
     /// Filter text
     pub filter_text: String,
     /// Whether multiple selection is allowed
@@ -68,6 +70,7 @@
             selected: HashSet::new(),
             filtered_choices,
             focused_index: 0,
+            hovered_index: None,
             filter_text: String::new(),
             multiple,
             focus_handle,
@@ -84,6 +87,7 @@
         if trimmed_filter.is_empty() {
             self.filtered_choices = (0..self.choices.len()).collect();
             self.focused_index = 0;
+            self.hovered_index = None;
             return;
         }
 
@@ -109,6 +113,7 @@
 
         self.filtered_choices = scored_matches.into_iter().map(|(idx, _)| idx).collect();
         self.focused_index = 0;
+        self.hovered_index = None;
     }
 
     /// Set the filter text programmatically
@@ -168,6 +173,7 @@
     pub(super) fn move_up(&mut self, cx: &mut Context<Self>) {
         if self.focused_index > 0 {
             self.focused_index -= 1;
+            self.hovered_index = None;
             self.list_scroll_handle
                 .scroll_to_item(self.focused_index, ScrollStrategy::Nearest);
             cx.notify();
@@ -178,6 +184,7 @@
     pub(super) fn move_down(&mut self, cx: &mut Context<Self>) {
         if self.focused_index < self.filtered_choices.len().saturating_sub(1) {
             self.focused_index += 1;
+            self.hovered_index = None;
             self.list_scroll_handle
                 .scroll_to_item(self.focused_index, ScrollStrategy::Nearest);
             cx.notify();
diff --git a/src/prompts/select/render.rs b/src/prompts/select/render.rs
index 62109896c9c14b1b2fbf5b4d25d5d94e4388e4aa..8c67aba367edf1587ee80ac17707f23ad35c2ce1
--- a/src/prompts/select/render.rs
+++ b/src/prompts/select/render.rs
@@ -1,5 +1,57 @@
 use super::*;
 
+const ROW_FOCUSED_BG_ALPHA: u32 = 0x3A;
+const ROW_HOVER_BG_ALPHA: u32 = 0x26;
+
+fn extract_choice_icon_hint(description: Option<&str>) -> Option<&str> {
+    description.and_then(|raw| {
+        raw.split(['‚Ä¢', '|', '\n'])
+            .map(str::trim)
+            .find_map(|token| {
+                let token_lower = token.to_ascii_lowercase();
+                if token_lower == "icon"
+                    || token_lower.starts_with("icon:")
+                    || token_lower.starts_with("icon=")
+                    || token_lower.starts_with("icon ")
+                {
+                    token
+                        .split_once(':')
+                        .or_else(|| token.split_once('='))
+                        .map(|(_, value)| value.trim())
+                        .or_else(|| token.split_whitespace().nth(1))
+                } else {
+                    None
+                }
+            })
+            .filter(|value| !value.is_empty())
+    })
+}
+
+fn icon_kind_from_choice(choice: &Choice) -> IconKind {
+    let metadata_icon = extract_choice_icon_hint(choice.description.as_deref())
+        .and_then(IconKind::from_icon_hint);
+    let name_prefix_icon = choice
+        .name
+        .split_whitespace()
+        .next()
+        .and_then(IconKind::from_icon_hint);
+
+    metadata_icon
+        .or(name_prefix_icon)
+        .unwrap_or_else(|| IconKind::Svg("Code".to_string()))
+}
+
+fn leading_content_from_icon_kind(icon_kind: IconKind) -> LeadingContent {
+    match icon_kind {
+        IconKind::Emoji(emoji) => LeadingContent::Emoji(emoji.into()),
+        IconKind::Image(render_image) => LeadingContent::AppIcon(render_image),
+        IconKind::Svg(name) => LeadingContent::Icon {
+            name: SharedString::from(name),
+            color: None,
+        },
+    }
+}
+
 impl Focusable for SelectPrompt {
     fn focus_handle(&self, _cx: &gpui::App) -> FocusHandle {
         self.focus_handle.clone()
@@ -76,6 +128,13 @@
             self.design_variant,
             &colors,
         ));
+        let row_accent_color = if self.design_variant == DesignVariant::Default {
+            self.theme.colors.accent.selected
+        } else {
+            colors.accent
+        };
+        let focused_row_bg = rgba((row_accent_color << 8) | ROW_FOCUSED_BG_ALPHA);
+        let hovered_row_bg = rgba((row_accent_color << 8) | ROW_HOVER_BG_ALPHA);
 
         let placeholder = self
             .placeholder
@@ -145,8 +204,12 @@
                     move |this: &mut SelectPrompt,
                           visible_range: std::ops::Range<usize>,
                           _window,
-                          _cx| {
-                        let row_colors = UnifiedListItemColors::from_theme(&this.theme);
+                          cx| {
+                        let item_colors = UnifiedListItemColors {
+                            selected_opacity: 0.0,
+                            hover_opacity: 0.0,
+                            ..UnifiedListItemColors::from_theme(&this.theme)
+                        };
                         let mut rows = Vec::with_capacity(visible_range.len());
 
                         for display_idx in visible_range {
@@ -156,19 +219,21 @@
                                     {
                                         let is_focused = display_idx == this.focused_index;
                                         let is_selected = this.selected.contains(&choice_idx);
-                                        let is_selected_for_ui = if this.multiple {
-                                            is_selected
-                                        } else {
-                                            is_focused
-                                        };
+                                        let is_hovered = this.hovered_index == Some(display_idx);
                                         let semantic_id =
                                             choice.semantic_id.clone().unwrap_or_else(|| {
                                                 indexed_choice.stable_semantic_id.clone()
                                             });
-                                        let indicator = choice_selection_indicator(
-                                            this.multiple,
-                                            is_selected_for_ui,
-                                        );
+                                        let leading = if this.multiple {
+                                            Some(LeadingContent::Emoji(
+                                                choice_selection_indicator(true, is_selected)
+                                                    .into(),
+                                            ))
+                                        } else {
+                                            Some(leading_content_from_icon_kind(
+                                                icon_kind_from_choice(choice),
+                                            ))
+                                        };
                                         let subtitle = indexed_choice
                                             .metadata
                                             .subtitle_text()
@@ -185,34 +250,61 @@
                                                     ))
                                                 },
                                             );
+                                        let row_bg = if is_focused {
+                                            focused_row_bg
+                                        } else if is_hovered {
+                                            hovered_row_bg
+                                        } else {
+                                            rgba(0x00000000)
+                                        };
+                                        let hover_handler = cx.listener(
+                                            move |this: &mut SelectPrompt,
+                                                  hovered: &bool,
+                                                  _window,
+                                                  cx| {
+                                                if *hovered {
+                                                    if this.hovered_index != Some(display_idx) {
+                                                        this.hovered_index = Some(display_idx);
+                                                        cx.notify();
+                                                    }
+                                                } else if this.hovered_index == Some(display_idx)
+                                                {
+                                                    this.hovered_index = None;
+                                                    cx.notify();
+                                                }
+                                            },
+                                        );
+
+                                        let mut row = div()
+                                            .id(display_idx)
+                                            .w_full()
+                                            .h(px(LIST_ITEM_HEIGHT))
+                                            .rounded(px(8.0))
+                                            .bg(row_bg)
+                                            .cursor_pointer()
+                                            .on_hover(hover_handler)
+                                            .child(
+                                                UnifiedListItem::new(
+                                                    gpui::ElementId::Name(semantic_id.into()),
+                                                    title,
+                                                )
+                                                .subtitle_opt(subtitle)
+                                                .leading_opt(leading)
+                                                .trailing_opt(trailing)
+                                                .state(ItemState {
+                                                    is_selected,
+                                                    is_hovered,
+                                                    is_disabled: false,
+                                                })
+                                                .density(Density::Comfortable)
+                                                .colors(item_colors),
+                                            );
 
-                                        rows.push(
-                                            div()
-                                                .id(display_idx)
-                                                .w_full()
-                                                .h(px(LIST_ITEM_HEIGHT))
-                                                .border_b_1()
-                                                .border_color(border_color)
-                                                .child(
-                                                    UnifiedListItem::new(
-                                                        gpui::ElementId::Name(semantic_id.into()),
-                                                        title,
-                                                    )
-                                                    .subtitle_opt(subtitle)
-                                                    .leading(LeadingContent::Emoji(
-                                                        indicator.into(),
-                                                    ))
-                                                    .trailing_opt(trailing)
-                                                    .state(ItemState {
-                                                        is_selected: is_focused,
-                                                        is_hovered: false,
-                                                        is_disabled: false,
-                                                    })
-                                                    .density(Density::Comfortable)
-                                                    .colors(row_colors)
-                                                    .with_accent_bar(is_selected_for_ui),
-                                                ),
-                                        );
+                                        if !is_focused {
+                                            row = row.hover(move |s| s.bg(hovered_row_bg));
+                                        }
+
+                                        rows.push(row);
                                     }
                                 }
                             }
@@ -234,6 +326,7 @@
             .flex_col()
             .flex_1()
             .w_full()
+            .px(px(8.0))
             .child(choices_content);
 
         div()

exec
/bin/zsh -lc "sed -n '300,360p' src/prompts/select/render.rs" in /Users/johnlindquist/dev/script-kit-gpui succeeded in 50ms:
                                                .colors(item_colors),
                                            );

                                        if !is_focused {
                                            row = row.hover(move |s| s.bg(hovered_row_bg));
                                        }

                                        rows.push(row);
                                    }
                                }
                            }
                        }

                        rows
                    },
                ),
            )
            .h_full()
            .w_full()
            .track_scroll(&self.list_scroll_handle)
file update:
diff --git a/src/list_item/part_000.rs b/src/list_item/part_000.rs
index 733d4ac2aa5b1b27b29a5999310e6f3f45cc54c3..283b2263d56a92c73c22d44443db7b40971d26ce
--- a/src/list_item/part_000.rs
+++ b/src/list_item/part_000.rs
@@ -15,6 +15,37 @@
     /// Maps to IconName from designs::icon_variations
     Svg(String),
 }
+
+impl IconKind {
+    /// Resolve icon metadata into an IconKind for list rendering.
+    ///
+    /// Supports:
+    /// - Known SVG names/aliases via `icon_name_from_str` (e.g., "Terminal", "file-code")
+    /// - Emoji/symbol glyphs (e.g., "üìÑ", "‚ö°")
+    pub fn from_icon_hint(icon_hint: &str) -> Option<Self> {
+        let trimmed = icon_hint.trim();
+        if trimmed.is_empty() {
+            return None;
+        }
+
+        if icon_name_from_str(trimmed).is_some() {
+            return Some(Self::Svg(trimmed.to_string()));
+        }
+
+        if looks_like_symbol_icon_hint(trimmed) {
+            return Some(Self::Emoji(trimmed.to_string()));
+        }
+
+        None
+    }
+}
+
+fn looks_like_symbol_icon_hint(icon_hint: &str) -> bool {
+    let has_ascii_alnum = icon_hint.chars().any(|ch| ch.is_ascii_alphanumeric());
+    let char_count = icon_hint.chars().count();
+
+    !has_ascii_alnum && char_count <= 4
+}
 /// Fixed height for list items used in uniform-height virtualized lists.
 ///
 /// IMPORTANT: When using GPUI `uniform_list`, the item closure must render
@@ -437,3 +468,29 @@
     /// Text color for content displayed on accent/warning backgrounds
     pub text_on_accent: u32,
 }
+
+#[cfg(test)]
+mod icon_kind_tests {
+    use super::IconKind;
+
+    #[test]
+    fn test_icon_kind_from_icon_hint_returns_svg_when_known_icon_name() {
+        match IconKind::from_icon_hint("terminal") {
+            Some(IconKind::Svg(name)) => assert_eq!(name, "terminal"),
+            _ => panic!("expected SVG icon from known icon hint"),
+        }
+    }
+
+    #[test]
+    fn test_icon_kind_from_icon_hint_returns_emoji_when_symbol_glyph() {
+        match IconKind::from_icon_hint("üìÑ") {
+            Some(IconKind::Emoji(emoji)) => assert_eq!(emoji, "üìÑ"),
+            _ => panic!("expected emoji icon for symbol glyph"),
+        }
+    }
+
+    #[test]
+    fn test_icon_kind_from_icon_hint_returns_none_for_unknown_ascii_word() {
+        assert!(IconKind::from_icon_hint("unknown-icon-name").is_none());
+    }
+}
diff --git a/src/prompts/select/mod.rs b/src/prompts/select/mod.rs
index b6366dabfb14f3fae09f854f9de824fa629e0a3b..4ff3662b0b553a2aa8b9d8c752504d9db09a20da
--- a/src/prompts/select/mod.rs
+++ b/src/prompts/select/mod.rs
@@ -19,7 +19,7 @@
     UnifiedListItemColors,
 };
 use crate::designs::{get_tokens, DesignColors, DesignVariant};
-use crate::list_item::LIST_ITEM_HEIGHT;
+use crate::list_item::{IconKind, LIST_ITEM_HEIGHT};
 use crate::logging;
 use crate::panel::PROMPT_INPUT_FIELD_HEIGHT;
 use crate::protocol::{generate_semantic_id, Choice};
diff --git a/src/prompts/select/prompt.rs b/src/prompts/select/prompt.rs
index c5f98f5318f5b520e9223811f735e866ee06e7fb..5ba2de479b2f5680a73db72642377f68d26ee54e
--- a/src/prompts/select/prompt.rs
+++ b/src/prompts/select/prompt.rs
@@ -19,6 +19,8 @@
     pub filtered_choices: Vec<usize>,
     /// Currently focused index in filtered list
     pub focused_index: usize,
+    /// Currently hovered index in filtered list
+    pub hovered_index: Option<usize>,
     /// Filter text
     pub filter_text: String,
     /// Whether multiple selection is allowed
@@ -68,6 +70,7 @@
             selected: HashSet::new(),
             filtered_choices,
             focused_index: 0,
+            hovered_index: None,
             filter_text: String::new(),
             multiple,
             focus_handle,
@@ -84,6 +87,7 @@
         if trimmed_filter.is_empty() {
             self.filtered_choices = (0..self.choices.len()).collect();
             self.focused_index = 0;
+            self.hovered_index = None;
             return;
         }
 
@@ -109,6 +113,7 @@
 
         self.filtered_choices = scored_matches.into_iter().map(|(idx, _)| idx).collect();
         self.focused_index = 0;
+        self.hovered_index = None;
     }
 
     /// Set the filter text programmatically
@@ -168,6 +173,7 @@
     pub(super) fn move_up(&mut self, cx: &mut Context<Self>) {
         if self.focused_index > 0 {
             self.focused_index -= 1;
+            self.hovered_index = None;
             self.list_scroll_handle
                 .scroll_to_item(self.focused_index, ScrollStrategy::Nearest);
             cx.notify();
@@ -178,6 +184,7 @@
     pub(super) fn move_down(&mut self, cx: &mut Context<Self>) {
         if self.focused_index < self.filtered_choices.len().saturating_sub(1) {
             self.focused_index += 1;
+            self.hovered_index = None;
             self.list_scroll_handle
                 .scroll_to_item(self.focused_index, ScrollStrategy::Nearest);
             cx.notify();
diff --git a/src/prompts/select/render.rs b/src/prompts/select/render.rs
index 62109896c9c14b1b2fbf5b4d25d5d94e4388e4aa..8c67aba367edf1587ee80ac17707f23ad35c2ce1
--- a/src/prompts/select/render.rs
+++ b/src/prompts/select/render.rs
@@ -1,5 +1,57 @@
 use super::*;
 
+const ROW_FOCUSED_BG_ALPHA: u32 = 0x3A;
+const ROW_HOVER_BG_ALPHA: u32 = 0x26;
+
+fn extract_choice_icon_hint(description: Option<&str>) -> Option<&str> {
+    description.and_then(|raw| {
+        raw.split(['‚Ä¢', '|', '\n'])
+            .map(str::trim)
+            .find_map(|token| {
+                let token_lower = token.to_ascii_lowercase();
+                if token_lower == "icon"
+                    || token_lower.starts_with("icon:")
+                    || token_lower.starts_with("icon=")
+                    || token_lower.starts_with("icon ")
+                {
+                    token
+                        .split_once(':')
+                        .or_else(|| token.split_once('='))
+                        .map(|(_, value)| value.trim())
+                        .or_else(|| token.split_whitespace().nth(1))
+                } else {
+                    None
+                }
+            })
+            .filter(|value| !value.is_empty())
+    })
+}
+
+fn icon_kind_from_choice(choice: &Choice) -> IconKind {
+    let metadata_icon = extract_choice_icon_hint(choice.description.as_deref())
+        .and_then(IconKind::from_icon_hint);
+    let name_prefix_icon = choice
+        .name
+        .split_whitespace()
+        .next()
+        .and_then(IconKind::from_icon_hint);
+
+    metadata_icon
+        .or(name_prefix_icon)
+        .unwrap_or_else(|| IconKind::Svg("Code".to_string()))
+}
+
+fn leading_content_from_icon_kind(icon_kind: IconKind) -> LeadingContent {
+    match icon_kind {
+        IconKind::Emoji(emoji) => LeadingContent::Emoji(emoji.into()),
+        IconKind::Image(render_image) => LeadingContent::AppIcon(render_image),
+        IconKind::Svg(name) => LeadingContent::Icon {
+            name: SharedString::from(name),
+            color: None,
+        },
+    }
+}
+
 impl Focusable for SelectPrompt {
     fn focus_handle(&self, _cx: &gpui::App) -> FocusHandle {
         self.focus_handle.clone()
@@ -76,6 +128,13 @@
             self.design_variant,
             &colors,
         ));
+        let row_accent_color = if self.design_variant == DesignVariant::Default {
+            self.theme.colors.accent.selected
+        } else {
+            colors.accent
+        };
+        let focused_row_bg = rgba((row_accent_color << 8) | ROW_FOCUSED_BG_ALPHA);
+        let hovered_row_bg = rgba((row_accent_color << 8) | ROW_HOVER_BG_ALPHA);
 
         let placeholder = self
             .placeholder
@@ -145,8 +204,12 @@
                     move |this: &mut SelectPrompt,
                           visible_range: std::ops::Range<usize>,
                           _window,
-                          _cx| {
-                        let row_colors = UnifiedListItemColors::from_theme(&this.theme);
+                          cx| {
+                        let item_colors = UnifiedListItemColors {
+                            selected_opacity: 0.0,
+                            hover_opacity: 0.0,
+                            ..UnifiedListItemColors::from_theme(&this.theme)
+                        };
                         let mut rows = Vec::with_capacity(visible_range.len());
 
                         for display_idx in visible_range {
@@ -156,19 +219,21 @@
                                     {
                                         let is_focused = display_idx == this.focused_index;
                                         let is_selected = this.selected.contains(&choice_idx);
-                                        let is_selected_for_ui = if this.multiple {
-                                            is_selected
-                                        } else {
-                                            is_focused
-                                        };
+                                        let is_hovered = this.hovered_index == Some(display_idx);
                                         let semantic_id =
                                             choice.semantic_id.clone().unwrap_or_else(|| {
                                                 indexed_choice.stable_semantic_id.clone()
                                             });
-                                        let indicator = choice_selection_indicator(
-                                            this.multiple,
-                                            is_selected_for_ui,
-                                        );
+                                        let leading = if this.multiple {
+                                            Some(LeadingContent::Emoji(
+                                                choice_selection_indicator(true, is_selected)
+                                                    .into(),
+                                            ))
+                                        } else {
+                                            Some(leading_content_from_icon_kind(
+                                                icon_kind_from_choice(choice),
+                                            ))
+                                        };
                                         let subtitle = indexed_choice
                                             .metadata
                                             .subtitle_text()
@@ -185,34 +250,61 @@
                                                     ))
                                                 },
                                             );
+                                        let row_bg = if is_focused {
+                                            focused_row_bg
+                                        } else if is_hovered {
+                                            hovered_row_bg
+                                        } else {
+                                            rgba(0x00000000)
+                                        };
+                                        let hover_handler = cx.listener(
+                                            move |this: &mut SelectPrompt,
+                                                  hovered: &bool,
+                                                  _window,
+                                                  cx| {
+                                                if *hovered {
+                                                    if this.hovered_index != Some(display_idx) {
+                                                        this.hovered_index = Some(display_idx);
+                                                        cx.notify();
+                                                    }
+                                                } else if this.hovered_index == Some(display_idx)
+                                                {
+                                                    this.hovered_index = None;
+                                                    cx.notify();
+                                                }
+                                            },
+                                        );
+
+                                        let mut row = div()
+                                            .id(display_idx)
+                                            .w_full()
+                                            .h(px(LIST_ITEM_HEIGHT))
+                                            .rounded(px(8.0))
+                                            .bg(row_bg)
+                                            .cursor_pointer()
+                                            .on_hover(hover_handler)
+                                            .child(
+                                                UnifiedListItem::new(
+                                                    gpui::ElementId::Name(semantic_id.into()),
+                                                    title,
+                                                )
+                                                .subtitle_opt(subtitle)
+                                                .leading_opt(leading)
+                                                .trailing_opt(trailing)
+                                                .state(ItemState {
+                                                    is_selected,
+                                                    is_hovered,
+                                                    is_disabled: false,
+                                                })
+                                                .density(Density::Comfortable)
+                                                .colors(item_colors),
+                                            );
 
-                                        rows.push(
-                                            div()
-                                                .id(display_idx)
-                                                .w_full()
-                                                .h(px(LIST_ITEM_HEIGHT))
-                                                .border_b_1()
-                                                .border_color(border_color)
-                                                .child(
-                                                    UnifiedListItem::new(
-                                                        gpui::ElementId::Name(semantic_id.into()),
-                                                        title,
-                                                    )
-                                                    .subtitle_opt(subtitle)
-                                                    .leading(LeadingContent::Emoji(
-                                                        indicator.into(),
-                                                    ))
-                                                    .trailing_opt(trailing)
-                                                    .state(ItemState {
-                                                        is_selected: is_focused,
-                                                        is_hovered: false,
-                                                        is_disabled: false,
-                                                    })
-                                                    .density(Density::Comfortable)
-                                                    .colors(row_colors)
-                                                    .with_accent_bar(is_selected_for_ui),
-                                                ),
-                                        );
+                                        if !is_focused {
+                                            row = row.hover(move |s| s.bg(hovered_row_bg));
+                                        }
+
+                                        rows.push(row);
                                     }
                                 }
                             }
@@ -234,6 +326,7 @@
             .flex_col()
             .flex_1()
             .w_full()
+            .px(px(8.0))
             .child(choices_content);
 
         div()


thinking
**Confirming borrow safety and imports**
exec
/bin/zsh -lc 'git status --short' in /Users/johnlindquist/dev/script-kit-gpui succeeded in 51ms:
 M .ai/logs/codex-audit-act-description-quality-v2.final.md
 M .ai/logs/codex-audit-act-execution-builtin.final.md
 M .ai/logs/codex-audit-act-execution-scripts.final.md
 M .ai/logs/codex-audit-act-keyboard-nav.final.md
 M .ai/logs/codex-audit-act-section-grouping.final.md
 M .ai/logs/codex-audit-act-theme-dialog-render.final.md
 M .ai/roster.json
 M src/actions/builders.rs
 M src/actions/builders/chat.rs
 M src/actions/builders/clipboard.rs
 M src/actions/builders/file_path.rs
 M src/actions/builders/notes.rs
 M src/actions/builders/script_context.rs
 M src/actions/builders/scriptlet.rs
 M src/actions/builders/shared.rs
 M src/actions/command_bar/part_01.rs
 M src/actions/command_bar/part_02.rs
 M src/actions/constants.rs
 M src/actions/dialog/part_01.rs
 M src/actions/dialog/part_02/part_01.rs
file update:
diff --git a/src/list_item/part_000.rs b/src/list_item/part_000.rs
index 733d4ac2aa5b1b27b29a5999310e6f3f45cc54c3..283b2263d56a92c73c22d44443db7b40971d26ce
--- a/src/list_item/part_000.rs
+++ b/src/list_item/part_000.rs
@@ -15,6 +15,37 @@
     /// Maps to IconName from designs::icon_variations
     Svg(String),
 }
+
+impl IconKind {
+    /// Resolve icon metadata into an IconKind for list rendering.
+    ///
+    /// Supports:
+    /// - Known SVG names/aliases via `icon_name_from_str` (e.g., "Terminal", "file-code")
+    /// - Emoji/symbol glyphs (e.g., "üìÑ", "‚ö°")
+    pub fn from_icon_hint(icon_hint: &str) -> Option<Self> {
+        let trimmed = icon_hint.trim();
+        if trimmed.is_empty() {
+            return None;
+        }
+
+        if icon_name_from_str(trimmed).is_some() {
+            return Some(Self::Svg(trimmed.to_string()));
+        }
+
+        if looks_like_symbol_icon_hint(trimmed) {
+            return Some(Self::Emoji(trimmed.to_string()));
+        }
+
+        None
+    }
+}
+
+fn looks_like_symbol_icon_hint(icon_hint: &str) -> bool {
+    let has_ascii_alnum = icon_hint.chars().any(|ch| ch.is_ascii_alphanumeric());
+    let char_count = icon_hint.chars().count();
+
+    !has_ascii_alnum && char_count <= 4
+}
 /// Fixed height for list items used in uniform-height virtualized lists.
 ///
 /// IMPORTANT: When using GPUI `uniform_list`, the item closure must render
@@ -437,3 +468,29 @@
     /// Text color for content displayed on accent/warning backgrounds
     pub text_on_accent: u32,
 }
+
+#[cfg(test)]
+mod icon_kind_tests {
+    use super::IconKind;
+
+    #[test]
+    fn test_icon_kind_from_icon_hint_returns_svg_when_known_icon_name() {
+        match IconKind::from_icon_hint("terminal") {
+            Some(IconKind::Svg(name)) => assert_eq!(name, "terminal"),
+            _ => panic!("expected SVG icon from known icon hint"),
+        }
+    }
+
+    #[test]
+    fn test_icon_kind_from_icon_hint_returns_emoji_when_symbol_glyph() {
+        match IconKind::from_icon_hint("üìÑ") {
+            Some(IconKind::Emoji(emoji)) => assert_eq!(emoji, "üìÑ"),
+            _ => panic!("expected emoji icon for symbol glyph"),
+        }
+    }
+
+    #[test]
+    fn test_icon_kind_from_icon_hint_returns_none_for_unknown_ascii_word() {
+        assert!(IconKind::from_icon_hint("unknown-icon-name").is_none());
+    }
+}
diff --git a/src/prompts/select/mod.rs b/src/prompts/select/mod.rs
index b6366dabfb14f3fae09f854f9de824fa629e0a3b..4ff3662b0b553a2aa8b9d8c752504d9db09a20da
--- a/src/prompts/select/mod.rs
+++ b/src/prompts/select/mod.rs
@@ -19,7 +19,7 @@
     UnifiedListItemColors,
 };
 use crate::designs::{get_tokens, DesignColors, DesignVariant};
-use crate::list_item::LIST_ITEM_HEIGHT;
+use crate::list_item::{IconKind, LIST_ITEM_HEIGHT};
 use crate::logging;
 use crate::panel::PROMPT_INPUT_FIELD_HEIGHT;
 use crate::protocol::{generate_semantic_id, Choice};
diff --git a/src/prompts/select/prompt.rs b/src/prompts/select/prompt.rs
index c5f98f5318f5b520e9223811f735e866ee06e7fb..5ba2de479b2f5680a73db72642377f68d26ee54e
--- a/src/prompts/select/prompt.rs
+++ b/src/prompts/select/prompt.rs
@@ -19,6 +19,8 @@
     pub filtered_choices: Vec<usize>,
     /// Currently focused index in filtered list
     pub focused_index: usize,
+    /// Currently hovered index in filtered list
+    pub hovered_index: Option<usize>,
     /// Filter text
     pub filter_text: String,
     /// Whether multiple selection is allowed
@@ -68,6 +70,7 @@
             selected: HashSet::new(),
             filtered_choices,
             focused_index: 0,
+            hovered_index: None,
             filter_text: String::new(),
             multiple,
             focus_handle,
@@ -84,6 +87,7 @@
         if trimmed_filter.is_empty() {
             self.filtered_choices = (0..self.choices.len()).collect();
             self.focused_index = 0;
+            self.hovered_index = None;
             return;
         }
 
@@ -109,6 +113,7 @@
 
         self.filtered_choices = scored_matches.into_iter().map(|(idx, _)| idx).collect();
         self.focused_index = 0;
+        self.hovered_index = None;
     }
 
     /// Set the filter text programmatically
@@ -168,6 +173,7 @@
     pub(super) fn move_up(&mut self, cx: &mut Context<Self>) {
         if self.focused_index > 0 {
             self.focused_index -= 1;
+            self.hovered_index = None;
             self.list_scroll_handle
                 .scroll_to_item(self.focused_index, ScrollStrategy::Nearest);
             cx.notify();
@@ -178,6 +184,7 @@
     pub(super) fn move_down(&mut self, cx: &mut Context<Self>) {
         if self.focused_index < self.filtered_choices.len().saturating_sub(1) {
             self.focused_index += 1;
+            self.hovered_index = None;
             self.list_scroll_handle
                 .scroll_to_item(self.focused_index, ScrollStrategy::Nearest);
             cx.notify();
diff --git a/src/prompts/select/render.rs b/src/prompts/select/render.rs
index 62109896c9c14b1b2fbf5b4d25d5d94e4388e4aa..8c67aba367edf1587ee80ac17707f23ad35c2ce1
--- a/src/prompts/select/render.rs
+++ b/src/prompts/select/render.rs
@@ -1,5 +1,57 @@
 use super::*;
 
+const ROW_FOCUSED_BG_ALPHA: u32 = 0x3A;
+const ROW_HOVER_BG_ALPHA: u32 = 0x26;
+
+fn extract_choice_icon_hint(description: Option<&str>) -> Option<&str> {
+    description.and_then(|raw| {
+        raw.split(['‚Ä¢', '|', '\n'])
+            .map(str::trim)
+            .find_map(|token| {
+                let token_lower = token.to_ascii_lowercase();
+                if token_lower == "icon"
+                    || token_lower.starts_with("icon:")
+                    || token_lower.starts_with("icon=")
+                    || token_lower.starts_with("icon ")
+                {
+                    token
+                        .split_once(':')
+                        .or_else(|| token.split_once('='))
+                        .map(|(_, value)| value.trim())
+                        .or_else(|| token.split_whitespace().nth(1))
+                } else {
+                    None
+                }
+            })
+            .filter(|value| !value.is_empty())
+    })
+}
+
+fn icon_kind_from_choice(choice: &Choice) -> IconKind {
+    let metadata_icon = extract_choice_icon_hint(choice.description.as_deref())
+        .and_then(IconKind::from_icon_hint);
+    let name_prefix_icon = choice
+        .name
+        .split_whitespace()
+        .next()
+        .and_then(IconKind::from_icon_hint);
+
+    metadata_icon
+        .or(name_prefix_icon)
+        .unwrap_or_else(|| IconKind::Svg("Code".to_string()))
+}
+
+fn leading_content_from_icon_kind(icon_kind: IconKind) -> LeadingContent {
+    match icon_kind {
+        IconKind::Emoji(emoji) => LeadingContent::Emoji(emoji.into()),
+        IconKind::Image(render_image) => LeadingContent::AppIcon(render_image),
+        IconKind::Svg(name) => LeadingContent::Icon {
+            name: SharedString::from(name),
+            color: None,
+        },
+    }
+}
+
 impl Focusable for SelectPrompt {
     fn focus_handle(&self, _cx: &gpui::App) -> FocusHandle {
         self.focus_handle.clone()
@@ -76,6 +128,13 @@
             self.design_variant,
             &colors,
         ));
+        let row_accent_color = if self.design_variant == DesignVariant::Default {
+            self.theme.colors.accent.selected
+        } else {
+            colors.accent
+        };
+        let focused_row_bg = rgba((row_accent_color << 8) | ROW_FOCUSED_BG_ALPHA);
+        let hovered_row_bg = rgba((row_accent_color << 8) | ROW_HOVER_BG_ALPHA);
 
         let placeholder = self
             .placeholder
@@ -145,8 +204,12 @@
                     move |this: &mut SelectPrompt,
                           visible_range: std::ops::Range<usize>,
                           _window,
-                          _cx| {
-                        let row_colors = UnifiedListItemColors::from_theme(&this.theme);
+                          cx| {
+                        let item_colors = UnifiedListItemColors {
+                            selected_opacity: 0.0,
+                            hover_opacity: 0.0,
+                            ..UnifiedListItemColors::from_theme(&this.theme)
+                        };
                         let mut rows = Vec::with_capacity(visible_range.len());
 
                         for display_idx in visible_range {
@@ -156,19 +219,21 @@
                                     {
                                         let is_focused = display_idx == this.focused_index;
                                         let is_selected = this.selected.contains(&choice_idx);
-                                        let is_selected_for_ui = if this.multiple {
-                                            is_selected
-                                        } else {
-                                            is_focused
-                                        };
+                                        let is_hovered = this.hovered_index == Some(display_idx);
                                         let semantic_id =
                                             choice.semantic_id.clone().unwrap_or_else(|| {
                                                 indexed_choice.stable_semantic_id.clone()
                                             });
-                                        let indicator = choice_selection_indicator(
-                                            this.multiple,
-                                            is_selected_for_ui,
-                                        );
+                                        let leading = if this.multiple {
+                                            Some(LeadingContent::Emoji(
+                                                choice_selection_indicator(true, is_selected)
+                                                    .into(),
+                                            ))
+                                        } else {
+                                            Some(leading_content_from_icon_kind(
+                                                icon_kind_from_choice(choice),
+                                            ))
+                                        };
                                         let subtitle = indexed_choice
                                             .metadata
                                             .subtitle_text()
@@ -185,34 +250,61 @@
                                                     ))
                                                 },
                                             );
+                                        let row_bg = if is_focused {
+                                            focused_row_bg
+                                        } else if is_hovered {
+                                            hovered_row_bg
+                                        } else {
+                                            rgba(0x00000000)
+                                        };
+                                        let hover_handler = cx.listener(
+                                            move |this: &mut SelectPrompt,
+                                                  hovered: &bool,
+                                                  _window,
+                                                  cx| {
+                                                if *hovered {
+                                                    if this.hovered_index != Some(display_idx) {
+                                                        this.hovered_index = Some(display_idx);
+                                                        cx.notify();
+                                                    }
+                                                } else if this.hovered_index == Some(display_idx)
+                                                {
+                                                    this.hovered_index = None;
+                                                    cx.notify();
+                                                }
+                                            },
+                                        );
+
+                                        let mut row = div()
+                                            .id(display_idx)
+                                            .w_full()
+                                            .h(px(LIST_ITEM_HEIGHT))
+                                            .rounded(px(8.0))
+                                            .bg(row_bg)
+                                            .cursor_pointer()
+                                            .on_hover(hover_handler)
+                                            .child(
+                                                UnifiedListItem::new(
+                                                    gpui::ElementId::Name(semantic_id.into()),
+                                                    title,
+                                                )
+                                                .subtitle_opt(subtitle)
+                                                .leading_opt(leading)
+                                                .trailing_opt(trailing)
+                                                .state(ItemState {
+                                                    is_selected,
+                                                    is_hovered,
+                                                    is_disabled: false,
+                                                })
+                                                .density(Density::Comfortable)
+                                                .colors(item_colors),
+                                            );
 
-                                        rows.push(
-                                            div()
-                                                .id(display_idx)
-                                                .w_full()
-                                                .h(px(LIST_ITEM_HEIGHT))
-                                                .border_b_1()
-                                                .border_color(border_color)
-                                                .child(
-                                                    UnifiedListItem::new(
-                                                        gpui::ElementId::Name(semantic_id.into()),
-                                                        title,
-                                                    )
-                                                    .subtitle_opt(subtitle)
-                                                    .leading(LeadingContent::Emoji(
-                                                        indicator.into(),
-                                                    ))
-                                                    .trailing_opt(trailing)
-                                                    .state(ItemState {
-                                                        is_selected: is_focused,
-                                                        is_hovered: false,
-                                                        is_disabled: false,
-                                                    })
-                                                    .density(Density::Comfortable)
-                                                    .colors(row_colors)
-                                                    .with_accent_bar(is_selected_for_ui),
-                                                ),
-                                        );
+                                        if !is_focused {
+                                            row = row.hover(move |s| s.bg(hovered_row_bg));
+                                        }
+
+                                        rows.push(row);
                                     }
                                 }
                             }
@@ -234,6 +326,7 @@
             .flex_col()
             .flex_1()
             .w_full()
+            .px(px(8.0))
             .child(choices_content);
 
         div()


thinking
**Focusing tests on changed files only**
exec
/bin/zsh -lc 'git diff -- src/list_item/part_000.rs src/prompts/select/mod.rs src/prompts/select/prompt.rs src/prompts/select/render.rs' in /Users/johnlindquist/dev/script-kit-gpuiexec
/bin/zsh -lc "rg -n \"hovered_index|from_icon_hint|ROW_FOCUSED_BG_ALPHA|choice_selection_indicator\\(true|leading_opt\\(\" src/prompts/select src/list_item/part_000.rs" in /Users/johnlindquist/dev/script-kit-gpui succeeded in 51ms:
diff --git a/src/list_item/part_000.rs b/src/list_item/part_000.rs
index 733d4ac..283b226 100644
--- a/src/list_item/part_000.rs
+++ b/src/list_item/part_000.rs
@@ -15,6 +15,37 @@ pub enum IconKind {
     /// Maps to IconName from designs::icon_variations
     Svg(String),
 }
+
+impl IconKind {
+    /// Resolve icon metadata into an IconKind for list rendering.
+    ///
+    /// Supports:
+    /// - Known SVG names/aliases via `icon_name_from_str` (e.g., "Terminal", "file-code")
+    /// - Emoji/symbol glyphs (e.g., "üìÑ", "‚ö°")
+    pub fn from_icon_hint(icon_hint: &str) -> Option<Self> {
+        let trimmed = icon_hint.trim();
+        if trimmed.is_empty() {
+            return None;
+        }
 succeeded in 51ms:
src/list_item/part_000.rs:25:    pub fn from_icon_hint(icon_hint: &str) -> Option<Self> {
src/list_item/part_000.rs:477:    fn test_icon_kind_from_icon_hint_returns_svg_when_known_icon_name() {
src/list_item/part_000.rs:478:        match IconKind::from_icon_hint("terminal") {
src/list_item/part_000.rs:485:    fn test_icon_kind_from_icon_hint_returns_emoji_when_symbol_glyph() {
src/list_item/part_000.rs:486:        match IconKind::from_icon_hint("üìÑ") {
src/list_item/part_000.rs:493:    fn test_icon_kind_from_icon_hint_returns_none_for_unknown_ascii_word() {
src/list_item/part_000.rs:494:        assert!(IconKind::from_icon_hint("unknown-icon-name").is_none());
src/prompts/select/prompt.rs:23:    pub hovered_index: Option<usize>,
src/prompts/select/prompt.rs:73:            hovered_index: None,
src/prompts/select/prompt.rs:90:            self.hovered_index = None;
src/prompts/select/prompt.rs:116:        self.hovered_index = None;
src/prompts/select/prompt.rs:176:            self.hovered_index = None;
src/prompts/select/prompt.rs:187:            self.hovered_index = None;
src/prompts/select/render.rs:3:const ROW_FOCUSED_BG_ALPHA: u32 = 0x3A;
src/prompts/select/render.rs:32:        .and_then(IconKind::from_icon_hint);
src/prompts/select/render.rs:37:        .and_then(IconKind::from_icon_hint);
src/prompts/select/render.rs:136:        let focused_row_bg = rgba((row_accent_color << 8) | ROW_FOCUSED_BG_ALPHA);
src/prompts/select/render.rs:222:                                        let is_hovered = this.hovered_index == Some(display_idx);
src/prompts/select/render.rs:229:                                                choice_selection_indicator(true, is_selected)
src/prompts/select/render.rs:266:                                                    if this.hovered_index != Some(display_idx) {
file update:
diff --git a/src/list_item/part_000.rs b/src/list_item/part_000.rs
index 733d4ac2aa5b1b27b29a5999310e6f3f45cc54c3..283b2263d56a92c73c22d44443db7b40971d26ce
--- a/src/list_item/part_000.rs
+++ b/src/list_item/part_000.rs
@@ -15,6 +15,37 @@
     /// Maps to IconName from designs::icon_variations
     Svg(String),
 }
+
+impl IconKind {
+    /// Resolve icon metadata into an IconKind for list rendering.
+    ///
+    /// Supports:
+    /// - Known SVG names/aliases via `icon_name_from_str` (e.g., "Terminal", "file-code")
+    /// - Emoji/symbol glyphs (e.g., "üìÑ", "‚ö°")
+    pub fn from_icon_hint(icon_hint: &str) -> Option<Self> {
+        let trimmed = icon_hint.trim();
+        if trimmed.is_empty() {
+            return None;
+        }
+
+        if icon_name_from_str(trimmed).is_some() {
+            return Some(Self::Svg(trimmed.to_string()));
+        }
+
+        if looks_like_symbol_icon_hint(trimmed) {
+            return Some(Self::Emoji(trimmed.to_string()));
+        }
+
+        None
+    }
+}
+
+fn looks_like_symbol_icon_hint(icon_hint: &str) -> bool {
+    let has_ascii_alnum = icon_hint.chars().any(|ch| ch.is_ascii_alphanumeric());
+    let char_count = icon_hint.chars().count();
+
+    !has_ascii_alnum && char_count <= 4
+}
 /// Fixed height for list items used in uniform-height virtualized lists.
 ///
 /// IMPORTANT: When using GPUI `uniform_list`, the item closure must render
@@ -437,3 +468,29 @@
     /// Text color for content displayed on accent/warning backgrounds
     pub text_on_accent: u32,
 }
+
+#[cfg(test)]
+mod icon_kind_tests {
+    use super::IconKind;
+
+    #[test]
+    fn test_icon_kind_from_icon_hint_returns_svg_when_known_icon_name() {
+        match IconKind::from_icon_hint("terminal") {
+            Some(IconKind::Svg(name)) => assert_eq!(name, "terminal"),
+            _ => panic!("expected SVG icon from known icon hint"),
+        }
+    }
+
+    #[test]
+    fn test_icon_kind_from_icon_hint_returns_emoji_when_symbol_glyph() {
+        match IconKind::from_icon_hint("üìÑ") {
+            Some(IconKind::Emoji(emoji)) => assert_eq!(emoji, "üìÑ"),
+            _ => panic!("expected emoji icon for symbol glyph"),
+        }
+    }
+
+    #[test]
+    fn test_icon_kind_from_icon_hint_returns_none_for_unknown_ascii_word() {
+        assert!(IconKind::from_icon_hint("unknown-icon-name").is_none());
+    }
+}
diff --git a/src/prompts/select/mod.rs b/src/prompts/select/mod.rs
index b6366dabfb14f3fae09f854f9de824fa629e0a3b..4ff3662b0b553a2aa8b9d8c752504d9db09a20da
--- a/src/prompts/select/mod.rs
+++ b/src/prompts/select/mod.rs
@@ -19,7 +19,7 @@
     UnifiedListItemColors,
 };
 use crate::designs::{get_tokens, DesignColors, DesignVariant};
-use crate::list_item::LIST_ITEM_HEIGHT;
+use crate::list_item::{IconKind, LIST_ITEM_HEIGHT};
 use crate::logging;
 use crate::panel::PROMPT_INPUT_FIELD_HEIGHT;
 use crate::protocol::{generate_semantic_id, Choice};
diff --git a/src/prompts/select/prompt.rs b/src/prompts/select/prompt.rs
index c5f98f5318f5b520e9223811f735e866ee06e7fb..5ba2de479b2f5680a73db72642377f68d26ee54e
--- a/src/prompts/select/prompt.rs
+++ b/src/prompts/select/prompt.rs
@@ -19,6 +19,8 @@
     pub filtered_choices: Vec<usize>,
     /// Currently focused index in filtered list
     pub focused_index: usize,
+    /// Currently hovered index in filtered list
+    pub hovered_index: Option<usize>,
     /// Filter text
     pub filter_text: String,
     /// Whether multiple selection is allowed
@@ -68,6 +70,7 @@
             selected: HashSet::new(),
             filtered_choices,
             focused_index: 0,
+            hovered_index: None,
             filter_text: String::new(),
             multiple,
             focus_handle,
@@ -84,6 +87,7 @@
         if trimmed_filter.is_empty() {
             self.filtered_choices = (0..self.choices.len()).collect();
             self.focused_index = 0;
+            self.hovered_index = None;
             return;
         }
 
@@ -109,6 +113,7 @@
 
         self.filtered_choices = scored_matches.into_iter().map(|(idx, _)| idx).collect();
         self.focused_index = 0;
+        self.hovered_index = None;
     }
 
     /// Set the filter text programmatically
@@ -168,6 +173,7 @@
     pub(super) fn move_up(&mut self, cx: &mut Context<Self>) {
         if self.focused_index > 0 {
             self.focused_index -= 1;
+            self.hovered_index = None;
             self.list_scroll_handle
                 .scroll_to_item(self.focused_index, ScrollStrategy::Nearest);
             cx.notify();
@@ -178,6 +184,7 @@
     pub(super) fn move_down(&mut self, cx: &mut Context<Self>) {
         if self.focused_index < self.filtered_choices.len().saturating_sub(1) {
             self.focused_index += 1;
+            self.hovered_index = None;
             self.list_scroll_handle
                 .scroll_to_item(self.focused_index, ScrollStrategy::Nearest);
             cx.notify();
diff --git a/src/prompts/select/render.rs b/src/prompts/select/render.rs
index 62109896c9c14b1b2fbf5b4d25d5d94e4388e4aa..8c67aba367edf1587ee80ac17707f23ad35c2ce1
--- a/src/prompts/select/render.rs
+++ b/src/prompts/select/render.rs
@@ -1,5 +1,57 @@
 use super::*;
 
+const ROW_FOCUSED_BG_ALPHA: u32 = 0x3A;
+const ROW_HOVER_BG_ALPHA: u32 = 0x26;
+
+fn extract_choice_icon_hint(description: Option<&str>) -> Option<&str> {
+    description.and_then(|raw| {
+        raw.split(['‚Ä¢', '|', '\n'])
+            .map(str::trim)
+            .find_map(|token| {
+                let token_lower = token.to_ascii_lowercase();
+                if token_lower == "icon"
+                    || token_lower.starts_with("icon:")
+                    || token_lower.starts_with("icon=")
+                    || token_lower.starts_with("icon ")
+                {
+                    token
+                        .split_once(':')
+                        .or_else(|| token.split_once('='))
+                        .map(|(_, value)| value.trim())
+                        .or_else(|| token.split_whitespace().nth(1))
+                } else {
+                    None
+                }
+            })
+            .filter(|value| !value.is_empty())
+    })
+}
+
+fn icon_kind_from_choice(choice: &Choice) -> IconKind {
+    let metadata_icon = extract_choice_icon_hint(choice.description.as_deref())
+        .and_then(IconKind::from_icon_hint);
+    let name_prefix_icon = choice
+        .name
+        .split_whitespace()
+        .next()
+        .and_then(IconKind::from_icon_hint);
+
+    metadata_icon
+        .or(name_prefix_icon)
+        .unwrap_or_else(|| IconKind::Svg("Code".to_string()))
+}
+
+fn leading_content_from_icon_kind(icon_kind: IconKind) -> LeadingContent {
+    match icon_kind {
+        IconKind::Emoji(emoji) => LeadingContent::Emoji(emoji.into()),
+        IconKind::Image(render_image) => LeadingContent::AppIcon(render_image),
+        IconKind::Svg(name) => LeadingContent::Icon {
+            name: SharedString::from(name),
+            color: None,
+        },
+    }
+}
+
 impl Focusable for SelectPrompt {
     fn focus_handle(&self, _cx: &gpui::App) -> FocusHandle {
         self.focus_handle.clone()
@@ -76,6 +128,13 @@
             self.design_variant,
             &colors,
         ));
+        let row_accent_color = if self.design_variant == DesignVariant::Default {
+            self.theme.colors.accent.selected
+        } else {
+            colors.accent
+        };
+        let focused_row_bg = rgba((row_accent_color << 8) | ROW_FOCUSED_BG_ALPHA);
+        let hovered_row_bg = rgba((row_accent_color << 8) | ROW_HOVER_BG_ALPHA);
 
         let placeholder = self
             .placeholder
@@ -145,8 +204,12 @@
                     move |this: &mut SelectPrompt,
                           visible_range: std::ops::Range<usize>,
                           _window,
-                          _cx| {
-                        let row_colors = UnifiedListItemColors::from_theme(&this.theme);
+                          cx| {
+                        let item_colors = UnifiedListItemColors {
+                            selected_opacity: 0.0,
+                            hover_opacity: 0.0,
+                            ..UnifiedListItemColors::from_theme(&this.theme)
+                        };
                         let mut rows = Vec::with_capacity(visible_range.len());
 
                         for display_idx in visible_range {
@@ -156,19 +219,21 @@
                                     {
                                         let is_focused = display_idx == this.focused_index;
                                         let is_selected = this.selected.contains(&choice_idx);
-                                        let is_selected_for_ui = if this.multiple {
-                                            is_selected
-                                        } else {
-                                            is_focused
-                                        };
+                                        let is_hovered = this.hovered_index == Some(display_idx);
                                         let semantic_id =
                                             choice.semantic_id.clone().unwrap_or_else(|| {
                                                 indexed_choice.stable_semantic_id.clone()
                                             });
-                                        let indicator = choice_selection_indicator(
-                                            this.multiple,
-                                            is_selected_for_ui,
-                                        );
+                                        let leading = if this.multiple {
+                                            Some(LeadingContent::Emoji(
+                                                choice_selection_indicator(true, is_selected)
+                                                    .into(),
+                                            ))
+                                        } else {
+                                            Some(leading_content_from_icon_kind(
+                                                icon_kind_from_choice(choice),
+                                            ))
+                                        };
                                         let subtitle = indexed_choice
                                             .metadata
                                             .subtitle_text()
@@ -185,34 +250,61 @@
                                                     ))
                                                 },
                                             );
+                                        let row_bg = if is_focused {
+                                            focused_row_bg
+                                        } else if is_hovered {
+                                            hovered_row_bg
+                                        } else {
+                                            rgba(0x00000000)
+                                        };
+                                        let hover_handler = cx.listener(
+                                            move |this: &mut SelectPrompt,
+                                                  hovered: &bool,
+                                                  _window,
+                                                  cx| {
+                                                if *hovered {
+                                                    if this.hovered_index != Some(display_idx) {
+                                                        this.hovered_index = Some(display_idx);
+                                                        cx.notify();
+                                                    }
+                                                } else if this.hovered_index == Some(display_idx)
+                                                {
+                                                    this.hovered_index = None;
+                                                    cx.notify();
+                                                }
+                                            },
+                                        );
+
+                                        let mut row = div()
+                                            .id(display_idx)
+                                            .w_full()
+                                            .h(px(LIST_ITEM_HEIGHT))
+                                            .rounded(px(8.0))
+                                            .bg(row_bg)
+                                            .cursor_pointer()
+                                            .on_hover(hover_handler)
+                                            .child(
+                                                UnifiedListItem::new(
+                                                    gpui::ElementId::Name(semantic_id.into()),
+                                                    title,
+                                                )
+                                                .subtitle_opt(subtitle)
+                                                .leading_opt(leading)
+                                                .trailing_opt(trailing)
+                                                .state(ItemState {
+                                                    is_selected,
+                                                    is_hovered,
+                                                    is_disabled: false,
+                                                })
+                                                .density(Density::Comfortable)
+                                                .colors(item_colors),
+                                            );
 
-                                        rows.push(
-                                            div()
-                                                .id(display_idx)
-                                                .w_full()
-                                                .h(px(LIST_ITEM_HEIGHT))
-                                                .border_b_1()
-                                                .border_color(border_color)
-                                                .child(
-                                                    UnifiedListItem::new(
-                                                        gpui::ElementId::Name(semantic_id.into()),
-                                                        title,
-                                                    )
-                                                    .subtitle_opt(subtitle)
-                                                    .leading(LeadingContent::Emoji(
-                                                        indicator.into(),
-                                                    ))
-                                                    .trailing_opt(trailing)
-                                                    .state(ItemState {
-                                                        is_selected: is_focused,
-                                                        is_hovered: false,
-                                                        is_disabled: false,
-                                                    })
-                                                    .density(Density::Comfortable)
-                                                    .colors(row_colors)
-                                                    .with_accent_bar(is_selected_for_ui),
-                                                ),
-                                        );
+                                        if !is_focused {
+                                            row = row.hover(move |s| s.bg(hovered_row_bg));
+                                        }
+
+                                        rows.push(row);
                                     }
                                 }
                             }
@@ -234,6 +326,7 @@
             .flex_col()
             .flex_1()
             .w_full()
+            .px(px(8.0))
             .child(choices_content);
 
         div()

context compacted
Reconnecting... 1/5 (stream disconnected before completion: An error occurred while processing your request. You can retry your request, or contact us through our help center at help.openai.com if the error persists. Please include the request ID c2201cdb-8e6b-4642-8384-6d4f4cb00ecc in your message.)

thinking
**Clarifying test and check constraints**
codex
I‚Äôm continuing from the in-progress state by first validating the current edits and fixing any residual issues (especially the accidental `mod.rs` visibility change), then I‚Äôll run scoped Rust checks/tests for just this change set and finalize swarm status/claims.
exec
/bin/zsh -lc "cd /Users/johnlindquist/dev/script-kit-gpui && sed -n '1,260p' src/prompts/select/render.rs" in /Users/johnlindquist/dev/script-kit-gpuiexec
/bin/zsh -lc "cd /Users/johnlindquist/dev/script-kit-gpui && sed -n '1,260p' src/prompts/select/prompt.rs" in /Users/johnlindquist/dev/script-kit-gpuiexec
/bin/zsh -lc "cd /Users/johnlindquist/dev/script-kit-gpui && sed -n '1,260p' src/list_item/part_000.rs" in /Users/johnlindquist/dev/script-kit-gpuiexec
/bin/zsh -lc "cd /Users/johnlindquist/dev/script-kit-gpui && rg -n \"pub\\(super\\) use|use search::\\*;|use types::\\*;\" src/prompts/select/mod.rs && sed -n '1,120p' src/prompts/select/mod.rs" in /Users/johnlindquist/dev/script-kit-gpuiexec
/bin/zsh -lc 'cd /Users/johnlindquist/dev/script-kit-gpui && ~/.claude/bin/swarm.ts status' in /Users/johnlindquist/dev/script-kit-gpuiexec
/bin/zsh -lc 'cd /Users/johnlindquist/dev/script-kit-gpui && git status --short' in /Users/johnlindquist/dev/script-kit-gpui succeeded in 50ms:
use super::*;

/// SelectPrompt - Multi-select from choices
///
/// Allows selecting multiple items from a list of choices.
/// Use Cmd/Ctrl+Space to toggle selection, Enter to submit selected items.
pub struct SelectPrompt {
    /// Unique ID for this prompt instance
    pub id: String,
    /// Placeholder text for the search input
    pub placeholder: Option<String>,
    /// Available choices
    pub choices: Vec<Choice>,
    /// Cached searchable/indexed choice data to reduce refilter work
    pub(super) choice_index: Vec<SelectChoiceIndex>,
    /// Indices of selected choices
    pub selected: HashSet<usize>,
    /// Filtered choice indices (for display)
    pub filtered_choices: Vec<usize>,
    /// Currently focused index in filtered list
 succeeded in 50ms:
use super::*;

const ROW_FOCUSED_BG_ALPHA: u32 = 0x3A;
const ROW_HOVER_BG_ALPHA: u32 = 0x26;

fn extract_choice_icon_hint(description: Option<&str>) -> Option<&str> {
    description.and_then(|raw| {
        raw.split(['‚Ä¢', '|', '\n'])
            .map(str::trim)
            .find_map(|token| {
                let token_lower = token.to_ascii_lowercase();
                if token_lower == "icon"
                    || token_lower.starts_with("icon:")
                    || token_lower.starts_with("icon=")
                    || token_lower.starts_with("icon ")
                {
                    token
                        .split_once(':')
                        .or_else(|| token.split_once('='))
                        .map(|(_, value)| value.trim())
 succeeded in 51ms:
use crate::designs::icon_variations::{icon_name_from_str, IconName};
use crate::logging;
use crate::ui_foundation::HexColorExt;
use gpui::*;
use std::collections::HashSet;
use std::sync::Arc;
/// Icon type for list items - supports emoji strings, SVG icons, and pre-decoded images
#[derive(Clone)]
pub enum IconKind {
    /// Text/emoji icon (e.g., "üìú", "‚ö°")
    Emoji(String),
    /// Pre-decoded render image (for app icons) - MUST be pre-decoded, not raw PNG bytes
    Image(Arc<RenderImage>),
    /// SVG icon by name (e.g., "File", "Terminal", "Code")
    /// Maps to IconName from designs::icon_variations
    Svg(String),
}

impl IconKind {
    /// Resolve icon metadata into an IconKind for list rendering.
 succeeded in 51ms:
40:use search::*;
41:use types::*;
//! SelectPrompt - Multi-select from choices
//!
//! Features:
//! - Select multiple items from a list
//! - Toggle selection with Cmd/Ctrl+Space
//! - Filter choices by typing
//! - Submit selected items

use gpui::{
    div, prelude::*, px, rgb, uniform_list, AnyElement, Context, FocusHandle, Focusable, Render,
    ScrollStrategy, SharedString, UniformListScrollHandle, Window,
};
use std::collections::HashSet;
use std::ops::Range;
use std::sync::Arc;

use crate::components::{
    Density, ItemState, LeadingContent, TextContent, TrailingContent, UnifiedListItem,
 succeeded in 51ms:
Repo: /Users/johnlindquist/dev/script-kit-gpui
Updated: 2026-02-10T05:26:52.853Z

Active agents (4):
codex-empty-headers [in_progress] codex/gpt-5.3-codex/exec
  task: Improve empty states and section headers in the select prompt for a Raycast-quality feel. Make these 2 changes:

1. UPG‚Ä¶
  scope: src/prompts/select/render.rs,src/app_render/group_header_item.rs,src/list_item/part_000.rs
  claims(1): src/app_render/group_header_item.rs
  notes: group_header_item.rs updated; waiting for claims on src/prompts/select/render.rs and src/list_item/part_000.rs

codex-list-polish [in_progress] codex/gpt-5.3-codex/exec
  task: Polish the main menu list items in the select prompt for a Raycast-quality feel. Make these 4 changes:

1. REAL ICONS: ‚Ä¶
  scope: src/prompts/select/render.rs,src/prompts/select/mod.rs,src/list_item/part_000.rs,src/list_item/part_001.rs
  claims(5): src/prompts/select/render.rs, src/prompts/select/mod.rs, src/list_item/part_000.rs, src/list_item/part_001.rs, src/prompts/select/prompt.rs
  notes: Implementing select list polish: icons, rounded focus/hover, focused-vs-selected, hovered_index wiring | [claim-wait] codex-search-bar waiting for src/prompts/select/render.rs | [‚Ä¶

 succeeded in 51ms:
 M .ai/logs/codex-audit-act-description-quality-v2.final.md
 M .ai/logs/codex-audit-act-execution-builtin.final.md
 M .ai/logs/codex-audit-act-execution-scripts.final.md
 M .ai/logs/codex-audit-act-keyboard-nav.final.md
 M .ai/logs/codex-audit-act-section-grouping.final.md
 M .ai/logs/codex-audit-act-theme-dialog-render.final.md
 M .ai/roster.json
 M src/actions/builders.rs
 M src/actions/builders/chat.rs
 M src/actions/builders/clipboard.rs
 M src/actions/builders/file_path.rs
 M src/actions/builders/notes.rs
 M src/actions/builders/script_context.rs
 M src/actions/builders/scriptlet.rs
 M src/actions/builders/shared.rs
 M src/actions/command_bar/part_01.rs
 M src/actions/command_bar/part_02.rs
 M src/actions/constants.rs
 M src/actions/dialog/part_01.rs
 M src/actions/dialog/part_02/part_01.rs
file update:
diff --git a/src/list_item/part_000.rs b/src/list_item/part_000.rs
index 733d4ac2aa5b1b27b29a5999310e6f3f45cc54c3..283b2263d56a92c73c22d44443db7b40971d26ce
--- a/src/list_item/part_000.rs
+++ b/src/list_item/part_000.rs
@@ -15,6 +15,37 @@
     /// Maps to IconName from designs::icon_variations
     Svg(String),
 }
+
+impl IconKind {
+    /// Resolve icon metadata into an IconKind for list rendering.
+    ///
+    /// Supports:
+    /// - Known SVG names/aliases via `icon_name_from_str` (e.g., "Terminal", "file-code")
+    /// - Emoji/symbol glyphs (e.g., "üìÑ", "‚ö°")
+    pub fn from_icon_hint(icon_hint: &str) -> Option<Self> {
+        let trimmed = icon_hint.trim();
+        if trimmed.is_empty() {
+            return None;
+        }
+
+        if icon_name_from_str(trimmed).is_some() {
+            return Some(Self::Svg(trimmed.to_string()));
+        }
+
+        if looks_like_symbol_icon_hint(trimmed) {
+            return Some(Self::Emoji(trimmed.to_string()));
+        }
+
+        None
+    }
+}
+
+fn looks_like_symbol_icon_hint(icon_hint: &str) -> bool {
+    let has_ascii_alnum = icon_hint.chars().any(|ch| ch.is_ascii_alphanumeric());
+    let char_count = icon_hint.chars().count();
+
+    !has_ascii_alnum && char_count <= 4
+}
 /// Fixed height for list items used in uniform-height virtualized lists.
 ///
 /// IMPORTANT: When using GPUI `uniform_list`, the item closure must render
@@ -437,3 +468,29 @@
     /// Text color for content displayed on accent/warning backgrounds
     pub text_on_accent: u32,
 }
+
+#[cfg(test)]
+mod icon_kind_tests {
+    use super::IconKind;
+
+    #[test]
+    fn test_icon_kind_from_icon_hint_returns_svg_when_known_icon_name() {
+        match IconKind::from_icon_hint("terminal") {
+            Some(IconKind::Svg(name)) => assert_eq!(name, "terminal"),
+            _ => panic!("expected SVG icon from known icon hint"),
+        }
+    }
+
+    #[test]
+    fn test_icon_kind_from_icon_hint_returns_emoji_when_symbol_glyph() {
+        match IconKind::from_icon_hint("üìÑ") {
+            Some(IconKind::Emoji(emoji)) => assert_eq!(emoji, "üìÑ"),
+            _ => panic!("expected emoji icon for symbol glyph"),
+        }
+    }
+
+    #[test]
+    fn test_icon_kind_from_icon_hint_returns_none_for_unknown_ascii_word() {
+        assert!(IconKind::from_icon_hint("unknown-icon-name").is_none());
+    }
+}
diff --git a/src/prompts/select/mod.rs b/src/prompts/select/mod.rs
index b6366dabfb14f3fae09f854f9de824fa629e0a3b..4ff3662b0b553a2aa8b9d8c752504d9db09a20da
--- a/src/prompts/select/mod.rs
+++ b/src/prompts/select/mod.rs
@@ -19,7 +19,7 @@
     UnifiedListItemColors,
 };
 use crate::designs::{get_tokens, DesignColors, DesignVariant};
-use crate::list_item::LIST_ITEM_HEIGHT;
+use crate::list_item::{IconKind, LIST_ITEM_HEIGHT};
 use crate::logging;
 use crate::panel::PROMPT_INPUT_FIELD_HEIGHT;
 use crate::protocol::{generate_semantic_id, Choice};
diff --git a/src/prompts/select/prompt.rs b/src/prompts/select/prompt.rs
index c5f98f5318f5b520e9223811f735e866ee06e7fb..5ba2de479b2f5680a73db72642377f68d26ee54e
--- a/src/prompts/select/prompt.rs
+++ b/src/prompts/select/prompt.rs
@@ -19,6 +19,8 @@
     pub filtered_choices: Vec<usize>,
     /// Currently focused index in filtered list
     pub focused_index: usize,
+    /// Currently hovered index in filtered list
+    pub hovered_index: Option<usize>,
     /// Filter text
     pub filter_text: String,
     /// Whether multiple selection is allowed
@@ -68,6 +70,7 @@
             selected: HashSet::new(),
             filtered_choices,
             focused_index: 0,
+            hovered_index: None,
             filter_text: String::new(),
             multiple,
             focus_handle,
@@ -84,6 +87,7 @@
         if trimmed_filter.is_empty() {
             self.filtered_choices = (0..self.choices.len()).collect();
             self.focused_index = 0;
+            self.hovered_index = None;
             return;
         }
 
@@ -109,6 +113,7 @@
 
         self.filtered_choices = scored_matches.into_iter().map(|(idx, _)| idx).collect();
         self.focused_index = 0;
+        self.hovered_index = None;
     }
 
     /// Set the filter text programmatically
@@ -168,6 +173,7 @@
     pub(super) fn move_up(&mut self, cx: &mut Context<Self>) {
         if self.focused_index > 0 {
             self.focused_index -= 1;
+            self.hovered_index = None;
             self.list_scroll_handle
                 .scroll_to_item(self.focused_index, ScrollStrategy::Nearest);
             cx.notify();
@@ -178,6 +184,7 @@
     pub(super) fn move_down(&mut self, cx: &mut Context<Self>) {
         if self.focused_index < self.filtered_choices.len().saturating_sub(1) {
             self.focused_index += 1;
+            self.hovered_index = None;
             self.list_scroll_handle
                 .scroll_to_item(self.focused_index, ScrollStrategy::Nearest);
             cx.notify();
diff --git a/src/prompts/select/render.rs b/src/prompts/select/render.rs
index 62109896c9c14b1b2fbf5b4d25d5d94e4388e4aa..8c67aba367edf1587ee80ac17707f23ad35c2ce1
--- a/src/prompts/select/render.rs
+++ b/src/prompts/select/render.rs
@@ -1,5 +1,57 @@
 use super::*;
 
+const ROW_FOCUSED_BG_ALPHA: u32 = 0x3A;
+const ROW_HOVER_BG_ALPHA: u32 = 0x26;
+
+fn extract_choice_icon_hint(description: Option<&str>) -> Option<&str> {
+    description.and_then(|raw| {
+        raw.split(['‚Ä¢', '|', '\n'])
+            .map(str::trim)
+            .find_map(|token| {
+                let token_lower = token.to_ascii_lowercase();
+                if token_lower == "icon"
+                    || token_lower.starts_with("icon:")
+                    || token_lower.starts_with("icon=")
+                    || token_lower.starts_with("icon ")
+                {
+                    token
+                        .split_once(':')
+                        .or_else(|| token.split_once('='))
+                        .map(|(_, value)| value.trim())
+                        .or_else(|| token.split_whitespace().nth(1))
+                } else {
+                    None
+                }
+            })
+            .filter(|value| !value.is_empty())
+    })
+}
+
+fn icon_kind_from_choice(choice: &Choice) -> IconKind {
+    let metadata_icon = extract_choice_icon_hint(choice.description.as_deref())
+        .and_then(IconKind::from_icon_hint);
+    let name_prefix_icon = choice
+        .name
+        .split_whitespace()
+        .next()
+        .and_then(IconKind::from_icon_hint);
+
+    metadata_icon
+        .or(name_prefix_icon)
+        .unwrap_or_else(|| IconKind::Svg("Code".to_string()))
+}
+
+fn leading_content_from_icon_kind(icon_kind: IconKind) -> LeadingContent {
+    match icon_kind {
+        IconKind::Emoji(emoji) => LeadingContent::Emoji(emoji.into()),
+        IconKind::Image(render_image) => LeadingContent::AppIcon(render_image),
+        IconKind::Svg(name) => LeadingContent::Icon {
+            name: SharedString::from(name),
+            color: None,
+        },
+    }
+}
+
 impl Focusable for SelectPrompt {
     fn focus_handle(&self, _cx: &gpui::App) -> FocusHandle {
         self.focus_handle.clone()
@@ -76,6 +128,13 @@
             self.design_variant,
             &colors,
         ));
+        let row_accent_color = if self.design_variant == DesignVariant::Default {
+            self.theme.colors.accent.selected
+        } else {
+            colors.accent
+        };
+        let focused_row_bg = rgba((row_accent_color << 8) | ROW_FOCUSED_BG_ALPHA);
+        let hovered_row_bg = rgba((row_accent_color << 8) | ROW_HOVER_BG_ALPHA);
 
         let placeholder = self
             .placeholder
@@ -145,8 +204,12 @@
                     move |this: &mut SelectPrompt,
                           visible_range: std::ops::Range<usize>,
                           _window,
-                          _cx| {
-                        let row_colors = UnifiedListItemColors::from_theme(&this.theme);
+                          cx| {
+                        let item_colors = UnifiedListItemColors {
+                            selected_opacity: 0.0,
+                            hover_opacity: 0.0,
+                            ..UnifiedListItemColors::from_theme(&this.theme)
+                        };
                         let mut rows = Vec::with_capacity(visible_range.len());
 
                         for display_idx in visible_range {
@@ -156,19 +219,21 @@
                                     {
                                         let is_focused = display_idx == this.focused_index;
                                         let is_selected = this.selected.contains(&choice_idx);
-                                        let is_selected_for_ui = if this.multiple {
-                                            is_selected
-                                        } else {
-                                            is_focused
-                                        };
+                                        let is_hovered = this.hovered_index == Some(display_idx);
                                         let semantic_id =
                                             choice.semantic_id.clone().unwrap_or_else(|| {
                                                 indexed_choice.stable_semantic_id.clone()
                                             });
-                                        let indicator = choice_selection_indicator(
-                                            this.multiple,
-                                            is_selected_for_ui,
-                                        );
+                                        let leading = if this.multiple {
+                                            Some(LeadingContent::Emoji(
+                                                choice_selection_indicator(true, is_selected)
+                                                    .into(),
+                                            ))
+                                        } else {
+                                            Some(leading_content_from_icon_kind(
+                                                icon_kind_from_choice(choice),
+                                            ))
+                                        };
                                         let subtitle = indexed_choice
                                             .metadata
                                             .subtitle_text()
@@ -185,34 +250,61 @@
                                                     ))
                                                 },
                                             );
+                                        let row_bg = if is_focused {
+                                            focused_row_bg
+                                        } else if is_hovered {
+                                            hovered_row_bg
+                                        } else {
+                                            rgba(0x00000000)
+                                        };
+                                        let hover_handler = cx.listener(
+                                            move |this: &mut SelectPrompt,
+                                                  hovered: &bool,
+                                                  _window,
+                                                  cx| {
+                                                if *hovered {
+                                                    if this.hovered_index != Some(display_idx) {
+                                                        this.hovered_index = Some(display_idx);
+                                                        cx.notify();
+                                                    }
+                                                } else if this.hovered_index == Some(display_idx)
+                                                {
+                                                    this.hovered_index = None;
+                                                    cx.notify();
+                                                }
+                                            },
+                                        );
+
+                                        let mut row = div()
+                                            .id(display_idx)
+                                            .w_full()
+                                            .h(px(LIST_ITEM_HEIGHT))
+                                            .rounded(px(8.0))
+                                            .bg(row_bg)
+                                            .cursor_pointer()
+                                            .on_hover(hover_handler)
+                                            .child(
+                                                UnifiedListItem::new(
+                                                    gpui::ElementId::Name(semantic_id.into()),
+                                                    title,
+                                                )
+                                                .subtitle_opt(subtitle)
+                                                .leading_opt(leading)
+                                                .trailing_opt(trailing)
+                                                .state(ItemState {
+                                                    is_selected,
+                                                    is_hovered,
+                                                    is_disabled: false,
+                                                })
+                                                .density(Density::Comfortable)
+                                                .colors(item_colors),
+                                            );
 
-                                        rows.push(
-                                            div()
-                                                .id(display_idx)
-                                                .w_full()
-                                                .h(px(LIST_ITEM_HEIGHT))
-                                                .border_b_1()
-                                                .border_color(border_color)
-                                                .child(
-                                                    UnifiedListItem::new(
-                                                        gpui::ElementId::Name(semantic_id.into()),
-                                                        title,
-                                                    )
-                                                    .subtitle_opt(subtitle)
-                                                    .leading(LeadingContent::Emoji(
-                                                        indicator.into(),
-                                                    ))
-                                                    .trailing_opt(trailing)
-                                                    .state(ItemState {
-                                                        is_selected: is_focused,
-                                                        is_hovered: false,
-                                                        is_disabled: false,
-                                                    })
-                                                    .density(Density::Comfortable)
-                                                    .colors(row_colors)
-                                                    .with_accent_bar(is_selected_for_ui),
-                                                ),
-                                        );
+                                        if !is_focused {
+                                            row = row.hover(move |s| s.bg(hovered_row_bg));
+                                        }
+
+                                        rows.push(row);
                                     }
                                 }
                             }
@@ -234,6 +326,7 @@
             .flex_col()
             .flex_1()
             .w_full()
+            .px(px(8.0))
             .child(choices_content);
 
         div()


thinking
**Expanding render file review**
exec
/bin/zsh -lc "cd /Users/johnlindquist/dev/script-kit-gpui && sed -n '260,520p' src/prompts/select/render.rs" in /Users/johnlindquist/dev/script-kit-gpui succeeded in 51ms:
                                        let hover_handler = cx.listener(
                                            move |this: &mut SelectPrompt,
                                                  hovered: &bool,
                                                  _window,
                                                  cx| {
                                                if *hovered {
                                                    if this.hovered_index != Some(display_idx) {
                                                        this.hovered_index = Some(display_idx);
                                                        cx.notify();
                                                    }
                                                } else if this.hovered_index == Some(display_idx)
                                                {
                                                    this.hovered_index = None;
                                                    cx.notify();
                                                }
                                            },
                                        );

                                        let mut row = div()
                                            .id(display_idx)
file update:
diff --git a/src/list_item/part_000.rs b/src/list_item/part_000.rs
index 733d4ac2aa5b1b27b29a5999310e6f3f45cc54c3..283b2263d56a92c73c22d44443db7b40971d26ce
--- a/src/list_item/part_000.rs
+++ b/src/list_item/part_000.rs
@@ -15,6 +15,37 @@
     /// Maps to IconName from designs::icon_variations
     Svg(String),
 }
+
+impl IconKind {
+    /// Resolve icon metadata into an IconKind for list rendering.
+    ///
+    /// Supports:
+    /// - Known SVG names/aliases via `icon_name_from_str` (e.g., "Terminal", "file-code")
+    /// - Emoji/symbol glyphs (e.g., "üìÑ", "‚ö°")
+    pub fn from_icon_hint(icon_hint: &str) -> Option<Self> {
+        let trimmed = icon_hint.trim();
+        if trimmed.is_empty() {
+            return None;
+        }
+
+        if icon_name_from_str(trimmed).is_some() {
+            return Some(Self::Svg(trimmed.to_string()));
+        }
+
+        if looks_like_symbol_icon_hint(trimmed) {
+            return Some(Self::Emoji(trimmed.to_string()));
+        }
+
+        None
+    }
+}
+
+fn looks_like_symbol_icon_hint(icon_hint: &str) -> bool {
+    let has_ascii_alnum = icon_hint.chars().any(|ch| ch.is_ascii_alphanumeric());
+    let char_count = icon_hint.chars().count();
+
+    !has_ascii_alnum && char_count <= 4
+}
 /// Fixed height for list items used in uniform-height virtualized lists.
 ///
 /// IMPORTANT: When using GPUI `uniform_list`, the item closure must render
@@ -437,3 +468,29 @@
     /// Text color for content displayed on accent/warning backgrounds
     pub text_on_accent: u32,
 }
+
+#[cfg(test)]
+mod icon_kind_tests {
+    use super::IconKind;
+
+    #[test]
+    fn test_icon_kind_from_icon_hint_returns_svg_when_known_icon_name() {
+        match IconKind::from_icon_hint("terminal") {
+            Some(IconKind::Svg(name)) => assert_eq!(name, "terminal"),
+            _ => panic!("expected SVG icon from known icon hint"),
+        }
+    }
+
+    #[test]
+    fn test_icon_kind_from_icon_hint_returns_emoji_when_symbol_glyph() {
+        match IconKind::from_icon_hint("üìÑ") {
+            Some(IconKind::Emoji(emoji)) => assert_eq!(emoji, "üìÑ"),
+            _ => panic!("expected emoji icon for symbol glyph"),
+        }
+    }
+
+    #[test]
+    fn test_icon_kind_from_icon_hint_returns_none_for_unknown_ascii_word() {
+        assert!(IconKind::from_icon_hint("unknown-icon-name").is_none());
+    }
+}
diff --git a/src/prompts/select/mod.rs b/src/prompts/select/mod.rs
index b6366dabfb14f3fae09f854f9de824fa629e0a3b..4ff3662b0b553a2aa8b9d8c752504d9db09a20da
--- a/src/prompts/select/mod.rs
+++ b/src/prompts/select/mod.rs
@@ -19,7 +19,7 @@
     UnifiedListItemColors,
 };
 use crate::designs::{get_tokens, DesignColors, DesignVariant};
-use crate::list_item::LIST_ITEM_HEIGHT;
+use crate::list_item::{IconKind, LIST_ITEM_HEIGHT};
 use crate::logging;
 use crate::panel::PROMPT_INPUT_FIELD_HEIGHT;
 use crate::protocol::{generate_semantic_id, Choice};
diff --git a/src/prompts/select/prompt.rs b/src/prompts/select/prompt.rs
index c5f98f5318f5b520e9223811f735e866ee06e7fb..5ba2de479b2f5680a73db72642377f68d26ee54e
--- a/src/prompts/select/prompt.rs
+++ b/src/prompts/select/prompt.rs
@@ -19,6 +19,8 @@
     pub filtered_choices: Vec<usize>,
     /// Currently focused index in filtered list
     pub focused_index: usize,
+    /// Currently hovered index in filtered list
+    pub hovered_index: Option<usize>,
     /// Filter text
     pub filter_text: String,
     /// Whether multiple selection is allowed
@@ -68,6 +70,7 @@
             selected: HashSet::new(),
             filtered_choices,
             focused_index: 0,
+            hovered_index: None,
             filter_text: String::new(),
             multiple,
             focus_handle,
@@ -84,6 +87,7 @@
         if trimmed_filter.is_empty() {
             self.filtered_choices = (0..self.choices.len()).collect();
             self.focused_index = 0;
+            self.hovered_index = None;
             return;
         }
 
@@ -109,6 +113,7 @@
 
         self.filtered_choices = scored_matches.into_iter().map(|(idx, _)| idx).collect();
         self.focused_index = 0;
+        self.hovered_index = None;
     }
 
     /// Set the filter text programmatically
@@ -168,6 +173,7 @@
     pub(super) fn move_up(&mut self, cx: &mut Context<Self>) {
         if self.focused_index > 0 {
             self.focused_index -= 1;
+            self.hovered_index = None;
             self.list_scroll_handle
                 .scroll_to_item(self.focused_index, ScrollStrategy::Nearest);
             cx.notify();
@@ -178,6 +184,7 @@
     pub(super) fn move_down(&mut self, cx: &mut Context<Self>) {
         if self.focused_index < self.filtered_choices.len().saturating_sub(1) {
             self.focused_index += 1;
+            self.hovered_index = None;
             self.list_scroll_handle
                 .scroll_to_item(self.focused_index, ScrollStrategy::Nearest);
             cx.notify();
diff --git a/src/prompts/select/render.rs b/src/prompts/select/render.rs
index 62109896c9c14b1b2fbf5b4d25d5d94e4388e4aa..8c67aba367edf1587ee80ac17707f23ad35c2ce1
--- a/src/prompts/select/render.rs
+++ b/src/prompts/select/render.rs
@@ -1,5 +1,57 @@
 use super::*;
 
+const ROW_FOCUSED_BG_ALPHA: u32 = 0x3A;
+const ROW_HOVER_BG_ALPHA: u32 = 0x26;
+
+fn extract_choice_icon_hint(description: Option<&str>) -> Option<&str> {
+    description.and_then(|raw| {
+        raw.split(['‚Ä¢', '|', '\n'])
+            .map(str::trim)
+            .find_map(|token| {
+                let token_lower = token.to_ascii_lowercase();
+                if token_lower == "icon"
+                    || token_lower.starts_with("icon:")
+                    || token_lower.starts_with("icon=")
+                    || token_lower.starts_with("icon ")
+                {
+                    token
+                        .split_once(':')
+                        .or_else(|| token.split_once('='))
+                        .map(|(_, value)| value.trim())
+                        .or_else(|| token.split_whitespace().nth(1))
+                } else {
+                    None
+                }
+            })
+            .filter(|value| !value.is_empty())
+    })
+}
+
+fn icon_kind_from_choice(choice: &Choice) -> IconKind {
+    let metadata_icon = extract_choice_icon_hint(choice.description.as_deref())
+        .and_then(IconKind::from_icon_hint);
+    let name_prefix_icon = choice
+        .name
+        .split_whitespace()
+        .next()
+        .and_then(IconKind::from_icon_hint);
+
+    metadata_icon
+        .or(name_prefix_icon)
+        .unwrap_or_else(|| IconKind::Svg("Code".to_string()))
+}
+
+fn leading_content_from_icon_kind(icon_kind: IconKind) -> LeadingContent {
+    match icon_kind {
+        IconKind::Emoji(emoji) => LeadingContent::Emoji(emoji.into()),
+        IconKind::Image(render_image) => LeadingContent::AppIcon(render_image),
+        IconKind::Svg(name) => LeadingContent::Icon {
+            name: SharedString::from(name),
+            color: None,
+        },
+    }
+}
+
 impl Focusable for SelectPrompt {
     fn focus_handle(&self, _cx: &gpui::App) -> FocusHandle {
         self.focus_handle.clone()
@@ -76,6 +128,13 @@
             self.design_variant,
             &colors,
         ));
+        let row_accent_color = if self.design_variant == DesignVariant::Default {
+            self.theme.colors.accent.selected
+        } else {
+            colors.accent
+        };
+        let focused_row_bg = rgba((row_accent_color << 8) | ROW_FOCUSED_BG_ALPHA);
+        let hovered_row_bg = rgba((row_accent_color << 8) | ROW_HOVER_BG_ALPHA);
 
         let placeholder = self
             .placeholder
@@ -145,8 +204,12 @@
                     move |this: &mut SelectPrompt,
                           visible_range: std::ops::Range<usize>,
                           _window,
-                          _cx| {
-                        let row_colors = UnifiedListItemColors::from_theme(&this.theme);
+                          cx| {
+                        let item_colors = UnifiedListItemColors {
+                            selected_opacity: 0.0,
+                            hover_opacity: 0.0,
+                            ..UnifiedListItemColors::from_theme(&this.theme)
+                        };
                         let mut rows = Vec::with_capacity(visible_range.len());
 
                         for display_idx in visible_range {
@@ -156,19 +219,21 @@
                                     {
                                         let is_focused = display_idx == this.focused_index;
                                         let is_selected = this.selected.contains(&choice_idx);
-                                        let is_selected_for_ui = if this.multiple {
-                                            is_selected
-                                        } else {
-                                            is_focused
-                                        };
+                                        let is_hovered = this.hovered_index == Some(display_idx);
                                         let semantic_id =
                                             choice.semantic_id.clone().unwrap_or_else(|| {
                                                 indexed_choice.stable_semantic_id.clone()
                                             });
-                                        let indicator = choice_selection_indicator(
-                                            this.multiple,
-                                            is_selected_for_ui,
-                                        );
+                                        let leading = if this.multiple {
+                                            Some(LeadingContent::Emoji(
+                                                choice_selection_indicator(true, is_selected)
+                                                    .into(),
+                                            ))
+                                        } else {
+                                            Some(leading_content_from_icon_kind(
+                                                icon_kind_from_choice(choice),
+                                            ))
+                                        };
                                         let subtitle = indexed_choice
                                             .metadata
                                             .subtitle_text()
@@ -185,34 +250,61 @@
                                                     ))
                                                 },
                                             );
+                                        let row_bg = if is_focused {
+                                            focused_row_bg
+                                        } else if is_hovered {
+                                            hovered_row_bg
+                                        } else {
+                                            rgba(0x00000000)
+                                        };
+                                        let hover_handler = cx.listener(
+                                            move |this: &mut SelectPrompt,
+                                                  hovered: &bool,
+                                                  _window,
+                                                  cx| {
+                                                if *hovered {
+                                                    if this.hovered_index != Some(display_idx) {
+                                                        this.hovered_index = Some(display_idx);
+                                                        cx.notify();
+                                                    }
+                                                } else if this.hovered_index == Some(display_idx)
+                                                {
+                                                    this.hovered_index = None;
+                                                    cx.notify();
+                                                }
+                                            },
+                                        );
+
+                                        let mut row = div()
+                                            .id(display_idx)
+                                            .w_full()
+                                            .h(px(LIST_ITEM_HEIGHT))
+                                            .rounded(px(8.0))
+                                            .bg(row_bg)
+                                            .cursor_pointer()
+                                            .on_hover(hover_handler)
+                                            .child(
+                                                UnifiedListItem::new(
+                                                    gpui::ElementId::Name(semantic_id.into()),
+                                                    title,
+                                                )
+                                                .subtitle_opt(subtitle)
+                                                .leading_opt(leading)
+                                                .trailing_opt(trailing)
+                                                .state(ItemState {
+                                                    is_selected,
+                                                    is_hovered,
+                                                    is_disabled: false,
+                                                })
+                                                .density(Density::Comfortable)
+                                                .colors(item_colors),
+                                            );
 
-                                        rows.push(
-                                            div()
-                                                .id(display_idx)
-                                                .w_full()
-                                                .h(px(LIST_ITEM_HEIGHT))
-                                                .border_b_1()
-                                                .border_color(border_color)
-                                                .child(
-                                                    UnifiedListItem::new(
-                                                        gpui::ElementId::Name(semantic_id.into()),
-                                                        title,
-                                                    )
-                                                    .subtitle_opt(subtitle)
-                                                    .leading(LeadingContent::Emoji(
-                                                        indicator.into(),
-                                                    ))
-                                                    .trailing_opt(trailing)
-                                                    .state(ItemState {
-                                                        is_selected: is_focused,
-                                                        is_hovered: false,
-                                                        is_disabled: false,
-                                                    })
-                                                    .density(Density::Comfortable)
-                                                    .colors(row_colors)
-                                                    .with_accent_bar(is_selected_for_ui),
-                                                ),
-                                        );
+                                        if !is_focused {
+                                            row = row.hover(move |s| s.bg(hovered_row_bg));
+                                        }
+
+                                        rows.push(row);
                                     }
                                 }
                             }
@@ -234,6 +326,7 @@
             .flex_col()
             .flex_1()
             .w_full()
+            .px(px(8.0))
             .child(choices_content);
 
         div()


thinking
**Inspecting list item relevance**
exec
/bin/zsh -lc "cd /Users/johnlindquist/dev/script-kit-gpui && sed -n '1,260p' src/list_item/part_001.rs" in /Users/johnlindquist/dev/script-kit-gpui succeeded in 51ms:
impl ListItemColors {
    /// Create from theme reference
    pub fn from_theme(theme: &crate::theme::Theme) -> Self {
        let opacity = theme.get_opacity();
        Self {
            text_primary: theme.colors.text.primary,
            text_secondary: theme.colors.text.secondary,
            text_muted: theme.colors.text.muted,
            text_dimmed: theme.colors.text.dimmed,
            accent_selected: theme.colors.accent.selected,
            accent_selected_subtle: theme.colors.accent.selected_subtle,
            background: theme.colors.background.main,
            background_selected: theme.colors.accent.selected_subtle,
            selected_opacity: opacity.selected,
            hover_opacity: opacity.hover,
            warning_bg: theme.colors.ui.warning,
            // White text provides good contrast on warning/accent backgrounds in dark themes
            text_on_accent: theme.colors.text.primary,
        }
    }
file update:
diff --git a/src/list_item/part_000.rs b/src/list_item/part_000.rs
index 733d4ac2aa5b1b27b29a5999310e6f3f45cc54c3..283b2263d56a92c73c22d44443db7b40971d26ce
--- a/src/list_item/part_000.rs
+++ b/src/list_item/part_000.rs
@@ -15,6 +15,37 @@
     /// Maps to IconName from designs::icon_variations
     Svg(String),
 }
+
+impl IconKind {
+    /// Resolve icon metadata into an IconKind for list rendering.
+    ///
+    /// Supports:
+    /// - Known SVG names/aliases via `icon_name_from_str` (e.g., "Terminal", "file-code")
+    /// - Emoji/symbol glyphs (e.g., "üìÑ", "‚ö°")
+    pub fn from_icon_hint(icon_hint: &str) -> Option<Self> {
+        let trimmed = icon_hint.trim();
+        if trimmed.is_empty() {
+            return None;
+        }
+
+        if icon_name_from_str(trimmed).is_some() {
+            return Some(Self::Svg(trimmed.to_string()));
+        }
+
+        if looks_like_symbol_icon_hint(trimmed) {
+            return Some(Self::Emoji(trimmed.to_string()));
+        }
+
+        None
+    }
+}
+
+fn looks_like_symbol_icon_hint(icon_hint: &str) -> bool {
+    let has_ascii_alnum = icon_hint.chars().any(|ch| ch.is_ascii_alphanumeric());
+    let char_count = icon_hint.chars().count();
+
+    !has_ascii_alnum && char_count <= 4
+}
 /// Fixed height for list items used in uniform-height virtualized lists.
 ///
 /// IMPORTANT: When using GPUI `uniform_list`, the item closure must render
@@ -437,3 +468,29 @@
     /// Text color for content displayed on accent/warning backgrounds
     pub text_on_accent: u32,
 }
+
+#[cfg(test)]
+mod icon_kind_tests {
+    use super::IconKind;
+
+    #[test]
+    fn test_icon_kind_from_icon_hint_returns_svg_when_known_icon_name() {
+        match IconKind::from_icon_hint("terminal") {
+            Some(IconKind::Svg(name)) => assert_eq!(name, "terminal"),
+            _ => panic!("expected SVG icon from known icon hint"),
+        }
+    }
+
+    #[test]
+    fn test_icon_kind_from_icon_hint_returns_emoji_when_symbol_glyph() {
+        match IconKind::from_icon_hint("üìÑ") {
+            Some(IconKind::Emoji(emoji)) => assert_eq!(emoji, "üìÑ"),
+            _ => panic!("expected emoji icon for symbol glyph"),
+        }
+    }
+
+    #[test]
+    fn test_icon_kind_from_icon_hint_returns_none_for_unknown_ascii_word() {
+        assert!(IconKind::from_icon_hint("unknown-icon-name").is_none());
+    }
+}
diff --git a/src/prompts/select/mod.rs b/src/prompts/select/mod.rs
index b6366dabfb14f3fae09f854f9de824fa629e0a3b..4ff3662b0b553a2aa8b9d8c752504d9db09a20da
--- a/src/prompts/select/mod.rs
+++ b/src/prompts/select/mod.rs
@@ -19,7 +19,7 @@
     UnifiedListItemColors,
 };
 use crate::designs::{get_tokens, DesignColors, DesignVariant};
-use crate::list_item::LIST_ITEM_HEIGHT;
+use crate::list_item::{IconKind, LIST_ITEM_HEIGHT};
 use crate::logging;
 use crate::panel::PROMPT_INPUT_FIELD_HEIGHT;
 use crate::protocol::{generate_semantic_id, Choice};
diff --git a/src/prompts/select/prompt.rs b/src/prompts/select/prompt.rs
index c5f98f5318f5b520e9223811f735e866ee06e7fb..5ba2de479b2f5680a73db72642377f68d26ee54e
--- a/src/prompts/select/prompt.rs
+++ b/src/prompts/select/prompt.rs
@@ -19,6 +19,8 @@
     pub filtered_choices: Vec<usize>,
     /// Currently focused index in filtered list
     pub focused_index: usize,
+    /// Currently hovered index in filtered list
+    pub hovered_index: Option<usize>,
     /// Filter text
     pub filter_text: String,
     /// Whether multiple selection is allowed
@@ -68,6 +70,7 @@
             selected: HashSet::new(),
             filtered_choices,
             focused_index: 0,
+            hovered_index: None,
             filter_text: String::new(),
             multiple,
             focus_handle,
@@ -84,6 +87,7 @@
         if trimmed_filter.is_empty() {
             self.filtered_choices = (0..self.choices.len()).collect();
             self.focused_index = 0;
+            self.hovered_index = None;
             return;
         }
 
@@ -109,6 +113,7 @@
 
         self.filtered_choices = scored_matches.into_iter().map(|(idx, _)| idx).collect();
         self.focused_index = 0;
+        self.hovered_index = None;
     }
 
     /// Set the filter text programmatically
@@ -168,6 +173,7 @@
     pub(super) fn move_up(&mut self, cx: &mut Context<Self>) {
         if self.focused_index > 0 {
             self.focused_index -= 1;
+            self.hovered_index = None;
             self.list_scroll_handle
                 .scroll_to_item(self.focused_index, ScrollStrategy::Nearest);
             cx.notify();
@@ -178,6 +184,7 @@
     pub(super) fn move_down(&mut self, cx: &mut Context<Self>) {
         if self.focused_index < self.filtered_choices.len().saturating_sub(1) {
             self.focused_index += 1;
+            self.hovered_index = None;
             self.list_scroll_handle
                 .scroll_to_item(self.focused_index, ScrollStrategy::Nearest);
             cx.notify();
diff --git a/src/prompts/select/render.rs b/src/prompts/select/render.rs
index 62109896c9c14b1b2fbf5b4d25d5d94e4388e4aa..8c67aba367edf1587ee80ac17707f23ad35c2ce1
--- a/src/prompts/select/render.rs
+++ b/src/prompts/select/render.rs
@@ -1,5 +1,57 @@
 use super::*;
 
+const ROW_FOCUSED_BG_ALPHA: u32 = 0x3A;
+const ROW_HOVER_BG_ALPHA: u32 = 0x26;
+
+fn extract_choice_icon_hint(description: Option<&str>) -> Option<&str> {
+    description.and_then(|raw| {
+        raw.split(['‚Ä¢', '|', '\n'])
+            .map(str::trim)
+            .find_map(|token| {
+                let token_lower = token.to_ascii_lowercase();
+                if token_lower == "icon"
+                    || token_lower.starts_with("icon:")
+                    || token_lower.starts_with("icon=")
+                    || token_lower.starts_with("icon ")
+                {
+                    token
+                        .split_once(':')
+                        .or_else(|| token.split_once('='))
+                        .map(|(_, value)| value.trim())
+                        .or_else(|| token.split_whitespace().nth(1))
+                } else {
+                    None
+                }
+            })
+            .filter(|value| !value.is_empty())
+    })
+}
+
+fn icon_kind_from_choice(choice: &Choice) -> IconKind {
+    let metadata_icon = extract_choice_icon_hint(choice.description.as_deref())
+        .and_then(IconKind::from_icon_hint);
+    let name_prefix_icon = choice
+        .name
+        .split_whitespace()
+        .next()
+        .and_then(IconKind::from_icon_hint);
+
+    metadata_icon
+        .or(name_prefix_icon)
+        .unwrap_or_else(|| IconKind::Svg("Code".to_string()))
+}
+
+fn leading_content_from_icon_kind(icon_kind: IconKind) -> LeadingContent {
+    match icon_kind {
+        IconKind::Emoji(emoji) => LeadingContent::Emoji(emoji.into()),
+        IconKind::Image(render_image) => LeadingContent::AppIcon(render_image),
+        IconKind::Svg(name) => LeadingContent::Icon {
+            name: SharedString::from(name),
+            color: None,
+        },
+    }
+}
+
 impl Focusable for SelectPrompt {
     fn focus_handle(&self, _cx: &gpui::App) -> FocusHandle {
         self.focus_handle.clone()
@@ -76,6 +128,13 @@
             self.design_variant,
             &colors,
         ));
+        let row_accent_color = if self.design_variant == DesignVariant::Default {
+            self.theme.colors.accent.selected
+        } else {
+            colors.accent
+        };
+        let focused_row_bg = rgba((row_accent_color << 8) | ROW_FOCUSED_BG_ALPHA);
+        let hovered_row_bg = rgba((row_accent_color << 8) | ROW_HOVER_BG_ALPHA);
 
         let placeholder = self
             .placeholder
@@ -145,8 +204,12 @@
                     move |this: &mut SelectPrompt,
                           visible_range: std::ops::Range<usize>,
                           _window,
-                          _cx| {
-                        let row_colors = UnifiedListItemColors::from_theme(&this.theme);
+                          cx| {
+                        let item_colors = UnifiedListItemColors {
+                            selected_opacity: 0.0,
+                            hover_opacity: 0.0,
+                            ..UnifiedListItemColors::from_theme(&this.theme)
+                        };
                         let mut rows = Vec::with_capacity(visible_range.len());
 
                         for display_idx in visible_range {
@@ -156,19 +219,21 @@
                                     {
                                         let is_focused = display_idx == this.focused_index;
                                         let is_selected = this.selected.contains(&choice_idx);
-                                        let is_selected_for_ui = if this.multiple {
-                                            is_selected
-                                        } else {
-                                            is_focused
-                                        };
+                                        let is_hovered = this.hovered_index == Some(display_idx);
                                         let semantic_id =
                                             choice.semantic_id.clone().unwrap_or_else(|| {
                                                 indexed_choice.stable_semantic_id.clone()
                                             });
-                                        let indicator = choice_selection_indicator(
-                                            this.multiple,
-                                            is_selected_for_ui,
-                                        );
+                                        let leading = if this.multiple {
+                                            Some(LeadingContent::Emoji(
+                                                choice_selection_indicator(true, is_selected)
+                                                    .into(),
+                                            ))
+                                        } else {
+                                            Some(leading_content_from_icon_kind(
+                                                icon_kind_from_choice(choice),
+                                            ))
+                                        };
                                         let subtitle = indexed_choice
                                             .metadata
                                             .subtitle_text()
@@ -185,34 +250,61 @@
                                                     ))
                                                 },
                                             );
+                                        let row_bg = if is_focused {
+                                            focused_row_bg
+                                        } else if is_hovered {
+                                            hovered_row_bg
+                                        } else {
+                                            rgba(0x00000000)
+                                        };
+                                        let hover_handler = cx.listener(
+                                            move |this: &mut SelectPrompt,
+                                                  hovered: &bool,
+                                                  _window,
+                                                  cx| {
+                                                if *hovered {
+                                                    if this.hovered_index != Some(display_idx) {
+                                                        this.hovered_index = Some(display_idx);
+                                                        cx.notify();
+                                                    }
+                                                } else if this.hovered_index == Some(display_idx)
+                                                {
+                                                    this.hovered_index = None;
+                                                    cx.notify();
+                                                }
+                                            },
+                                        );
+
+                                        let mut row = div()
+                                            .id(display_idx)
+                                            .w_full()
+                                            .h(px(LIST_ITEM_HEIGHT))
+                                            .rounded(px(8.0))
+                                            .bg(row_bg)
+                                            .cursor_pointer()
+                                            .on_hover(hover_handler)
+                                            .child(
+                                                UnifiedListItem::new(
+                                                    gpui::ElementId::Name(semantic_id.into()),
+                                                    title,
+                                                )
+                                                .subtitle_opt(subtitle)
+                                                .leading_opt(leading)
+                                                .trailing_opt(trailing)
+                                                .state(ItemState {
+                                                    is_selected,
+                                                    is_hovered,
+                                                    is_disabled: false,
+                                                })
+                                                .density(Density::Comfortable)
+                                                .colors(item_colors),
+                                            );
 
-                                        rows.push(
-                                            div()
-                                                .id(display_idx)
-                                                .w_full()
-                                                .h(px(LIST_ITEM_HEIGHT))
-                                                .border_b_1()
-                                                .border_color(border_color)
-                                                .child(
-                                                    UnifiedListItem::new(
-                                                        gpui::ElementId::Name(semantic_id.into()),
-                                                        title,
-                                                    )
-                                                    .subtitle_opt(subtitle)
-                                                    .leading(LeadingContent::Emoji(
-                                                        indicator.into(),
-                                                    ))
-                                                    .trailing_opt(trailing)
-                                                    .state(ItemState {
-                                                        is_selected: is_focused,
-                                                        is_hovered: false,
-                                                        is_disabled: false,
-                                                    })
-                                                    .density(Density::Comfortable)
-                                                    .colors(row_colors)
-                                                    .with_accent_bar(is_selected_for_ui),
-                                                ),
-                                        );
+                                        if !is_focused {
+                                            row = row.hover(move |s| s.bg(hovered_row_bg));
+                                        }
+
+                                        rows.push(row);
                                     }
                                 }
                             }
@@ -234,6 +326,7 @@
             .flex_col()
             .flex_1()
             .w_full()
+            .px(px(8.0))
             .child(choices_content);
 
         div()


thinking
**Planning test inspection**
exec
/bin/zsh -lc 'cd /Users/johnlindquist/dev/script-kit-gpui && rg -n "from_icon_hint|icon_hint|icon_kind_tests" src/list_item/part_000.rs src/list_item/part_001.rs src/list_item/mod.rs' in /Users/johnlindquist/dev/script-kit-gpui succeeded in 51ms:
src/list_item/part_000.rs:25:    pub fn from_icon_hint(icon_hint: &str) -> Option<Self> {
src/list_item/part_000.rs:26:        let trimmed = icon_hint.trim();
src/list_item/part_000.rs:35:        if looks_like_symbol_icon_hint(trimmed) {
src/list_item/part_000.rs:43:fn looks_like_symbol_icon_hint(icon_hint: &str) -> bool {
src/list_item/part_000.rs:44:    let has_ascii_alnum = icon_hint.chars().any(|ch| ch.is_ascii_alphanumeric());
src/list_item/part_000.rs:45:    let char_count = icon_hint.chars().count();
src/list_item/part_000.rs:473:mod icon_kind_tests {
src/list_item/part_000.rs:477:    fn test_icon_kind_from_icon_hint_returns_svg_when_known_icon_name() {
src/list_item/part_000.rs:478:        match IconKind::from_icon_hint("terminal") {
src/list_item/part_000.rs:485:    fn test_icon_kind_from_icon_hint_returns_emoji_when_symbol_glyph() {
src/list_item/part_000.rs:486:        match IconKind::from_icon_hint("üìÑ") {
src/list_item/part_000.rs:493:    fn test_icon_kind_from_icon_hint_returns_none_for_unknown_ascii_word() {
src/list_item/part_000.rs:494:        assert!(IconKind::from_icon_hint("unknown-icon-name").is_none());
file update:
diff --git a/src/list_item/part_000.rs b/src/list_item/part_000.rs
index 733d4ac2aa5b1b27b29a5999310e6f3f45cc54c3..283b2263d56a92c73c22d44443db7b40971d26ce
--- a/src/list_item/part_000.rs
+++ b/src/list_item/part_000.rs
@@ -15,6 +15,37 @@
     /// Maps to IconName from designs::icon_variations
     Svg(String),
 }
+
+impl IconKind {
+    /// Resolve icon metadata into an IconKind for list rendering.
+    ///
+    /// Supports:
+    /// - Known SVG names/aliases via `icon_name_from_str` (e.g., "Terminal", "file-code")
+    /// - Emoji/symbol glyphs (e.g., "üìÑ", "‚ö°")
+    pub fn from_icon_hint(icon_hint: &str) -> Option<Self> {
+        let trimmed = icon_hint.trim();
+        if trimmed.is_empty() {
+            return None;
+        }
+
+        if icon_name_from_str(trimmed).is_some() {
+            return Some(Self::Svg(trimmed.to_string()));
+        }
+
+        if looks_like_symbol_icon_hint(trimmed) {
+            return Some(Self::Emoji(trimmed.to_string()));
+        }
+
+        None
+    }
+}
+
+fn looks_like_symbol_icon_hint(icon_hint: &str) -> bool {
+    let has_ascii_alnum = icon_hint.chars().any(|ch| ch.is_ascii_alphanumeric());
+    let char_count = icon_hint.chars().count();
+
+    !has_ascii_alnum && char_count <= 4
+}
 /// Fixed height for list items used in uniform-height virtualized lists.
 ///
 /// IMPORTANT: When using GPUI `uniform_list`, the item closure must render
@@ -437,3 +468,29 @@
     /// Text color for content displayed on accent/warning backgrounds
     pub text_on_accent: u32,
 }
+
+#[cfg(test)]
+mod icon_kind_tests {
+    use super::IconKind;
+
+    #[test]
+    fn test_icon_kind_from_icon_hint_returns_svg_when_known_icon_name() {
+        match IconKind::from_icon_hint("terminal") {
+            Some(IconKind::Svg(name)) => assert_eq!(name, "terminal"),
+            _ => panic!("expected SVG icon from known icon hint"),
+        }
+    }
+
+    #[test]
+    fn test_icon_kind_from_icon_hint_returns_emoji_when_symbol_glyph() {
+        match IconKind::from_icon_hint("üìÑ") {
+            Some(IconKind::Emoji(emoji)) => assert_eq!(emoji, "üìÑ"),
+            _ => panic!("expected emoji icon for symbol glyph"),
+        }
+    }
+
+    #[test]
+    fn test_icon_kind_from_icon_hint_returns_none_for_unknown_ascii_word() {
+        assert!(IconKind::from_icon_hint("unknown-icon-name").is_none());
+    }
+}
diff --git a/src/prompts/select/mod.rs b/src/prompts/select/mod.rs
index b6366dabfb14f3fae09f854f9de824fa629e0a3b..4ff3662b0b553a2aa8b9d8c752504d9db09a20da
--- a/src/prompts/select/mod.rs
+++ b/src/prompts/select/mod.rs
@@ -19,7 +19,7 @@
     UnifiedListItemColors,
 };
 use crate::designs::{get_tokens, DesignColors, DesignVariant};
-use crate::list_item::LIST_ITEM_HEIGHT;
+use crate::list_item::{IconKind, LIST_ITEM_HEIGHT};
 use crate::logging;
 use crate::panel::PROMPT_INPUT_FIELD_HEIGHT;
 use crate::protocol::{generate_semantic_id, Choice};
diff --git a/src/prompts/select/prompt.rs b/src/prompts/select/prompt.rs
index c5f98f5318f5b520e9223811f735e866ee06e7fb..5ba2de479b2f5680a73db72642377f68d26ee54e
--- a/src/prompts/select/prompt.rs
+++ b/src/prompts/select/prompt.rs
@@ -19,6 +19,8 @@
     pub filtered_choices: Vec<usize>,
     /// Currently focused index in filtered list
     pub focused_index: usize,
+    /// Currently hovered index in filtered list
+    pub hovered_index: Option<usize>,
     /// Filter text
     pub filter_text: String,
     /// Whether multiple selection is allowed
@@ -68,6 +70,7 @@
             selected: HashSet::new(),
             filtered_choices,
             focused_index: 0,
+            hovered_index: None,
             filter_text: String::new(),
             multiple,
             focus_handle,
@@ -84,6 +87,7 @@
         if trimmed_filter.is_empty() {
             self.filtered_choices = (0..self.choices.len()).collect();
             self.focused_index = 0;
+            self.hovered_index = None;
             return;
         }
 
@@ -109,6 +113,7 @@
 
         self.filtered_choices = scored_matches.into_iter().map(|(idx, _)| idx).collect();
         self.focused_index = 0;
+        self.hovered_index = None;
     }
 
     /// Set the filter text programmatically
@@ -168,6 +173,7 @@
     pub(super) fn move_up(&mut self, cx: &mut Context<Self>) {
         if self.focused_index > 0 {
             self.focused_index -= 1;
+            self.hovered_index = None;
             self.list_scroll_handle
                 .scroll_to_item(self.focused_index, ScrollStrategy::Nearest);
             cx.notify();
@@ -178,6 +184,7 @@
     pub(super) fn move_down(&mut self, cx: &mut Context<Self>) {
         if self.focused_index < self.filtered_choices.len().saturating_sub(1) {
             self.focused_index += 1;
+            self.hovered_index = None;
             self.list_scroll_handle
                 .scroll_to_item(self.focused_index, ScrollStrategy::Nearest);
             cx.notify();
diff --git a/src/prompts/select/render.rs b/src/prompts/select/render.rs
index 62109896c9c14b1b2fbf5b4d25d5d94e4388e4aa..8c67aba367edf1587ee80ac17707f23ad35c2ce1
--- a/src/prompts/select/render.rs
+++ b/src/prompts/select/render.rs
@@ -1,5 +1,57 @@
 use super::*;
 
+const ROW_FOCUSED_BG_ALPHA: u32 = 0x3A;
+const ROW_HOVER_BG_ALPHA: u32 = 0x26;
+
+fn extract_choice_icon_hint(description: Option<&str>) -> Option<&str> {
+    description.and_then(|raw| {
+        raw.split(['‚Ä¢', '|', '\n'])
+            .map(str::trim)
+            .find_map(|token| {
+                let token_lower = token.to_ascii_lowercase();
+                if token_lower == "icon"
+                    || token_lower.starts_with("icon:")
+                    || token_lower.starts_with("icon=")
+                    || token_lower.starts_with("icon ")
+                {
+                    token
+                        .split_once(':')
+                        .or_else(|| token.split_once('='))
+                        .map(|(_, value)| value.trim())
+                        .or_else(|| token.split_whitespace().nth(1))
+                } else {
+                    None
+                }
+            })
+            .filter(|value| !value.is_empty())
+    })
+}
+
+fn icon_kind_from_choice(choice: &Choice) -> IconKind {
+    let metadata_icon = extract_choice_icon_hint(choice.description.as_deref())
+        .and_then(IconKind::from_icon_hint);
+    let name_prefix_icon = choice
+        .name
+        .split_whitespace()
+        .next()
+        .and_then(IconKind::from_icon_hint);
+
+    metadata_icon
+        .or(name_prefix_icon)
+        .unwrap_or_else(|| IconKind::Svg("Code".to_string()))
+}
+
+fn leading_content_from_icon_kind(icon_kind: IconKind) -> LeadingContent {
+    match icon_kind {
+        IconKind::Emoji(emoji) => LeadingContent::Emoji(emoji.into()),
+        IconKind::Image(render_image) => LeadingContent::AppIcon(render_image),
+        IconKind::Svg(name) => LeadingContent::Icon {
+            name: SharedString::from(name),
+            color: None,
+        },
+    }
+}
+
 impl Focusable for SelectPrompt {
     fn focus_handle(&self, _cx: &gpui::App) -> FocusHandle {
         self.focus_handle.clone()
@@ -76,6 +128,13 @@
             self.design_variant,
             &colors,
         ));
+        let row_accent_color = if self.design_variant == DesignVariant::Default {
+            self.theme.colors.accent.selected
+        } else {
+            colors.accent
+        };
+        let focused_row_bg = rgba((row_accent_color << 8) | ROW_FOCUSED_BG_ALPHA);
+        let hovered_row_bg = rgba((row_accent_color << 8) | ROW_HOVER_BG_ALPHA);
 
         let placeholder = self
             .placeholder
@@ -145,8 +204,12 @@
                     move |this: &mut SelectPrompt,
                           visible_range: std::ops::Range<usize>,
                           _window,
-                          _cx| {
-                        let row_colors = UnifiedListItemColors::from_theme(&this.theme);
+                          cx| {
+                        let item_colors = UnifiedListItemColors {
+                            selected_opacity: 0.0,
+                            hover_opacity: 0.0,
+                            ..UnifiedListItemColors::from_theme(&this.theme)
+                        };
                         let mut rows = Vec::with_capacity(visible_range.len());
 
                         for display_idx in visible_range {
@@ -156,19 +219,21 @@
                                     {
                                         let is_focused = display_idx == this.focused_index;
                                         let is_selected = this.selected.contains(&choice_idx);
-                                        let is_selected_for_ui = if this.multiple {
-                                            is_selected
-                                        } else {
-                                            is_focused
-                                        };
+                                        let is_hovered = this.hovered_index == Some(display_idx);
                                         let semantic_id =
                                             choice.semantic_id.clone().unwrap_or_else(|| {
                                                 indexed_choice.stable_semantic_id.clone()
                                             });
-                                        let indicator = choice_selection_indicator(
-                                            this.multiple,
-                                            is_selected_for_ui,
-                                        );
+                                        let leading = if this.multiple {
+                                            Some(LeadingContent::Emoji(
+                                                choice_selection_indicator(true, is_selected)
+                                                    .into(),
+                                            ))
+                                        } else {
+                                            Some(leading_content_from_icon_kind(
+                                                icon_kind_from_choice(choice),
+                                            ))
+                                        };
                                         let subtitle = indexed_choice
                                             .metadata
                                             .subtitle_text()
@@ -185,34 +250,61 @@
                                                     ))
                                                 },
                                             );
+                                        let row_bg = if is_focused {
+                                            focused_row_bg
+                                        } else if is_hovered {
+                                            hovered_row_bg
+                                        } else {
+                                            rgba(0x00000000)
+                                        };
+                                        let hover_handler = cx.listener(
+                                            move |this: &mut SelectPrompt,
+                                                  hovered: &bool,
+                                                  _window,
+                                                  cx| {
+                                                if *hovered {
+                                                    if this.hovered_index != Some(display_idx) {
+                                                        this.hovered_index = Some(display_idx);
+                                                        cx.notify();
+                                                    }
+                                                } else if this.hovered_index == Some(display_idx)
+                                                {
+                                                    this.hovered_index = None;
+                                                    cx.notify();
+                                                }
+                                            },
+                                        );
+
+                                        let mut row = div()
+                                            .id(display_idx)
+                                            .w_full()
+                                            .h(px(LIST_ITEM_HEIGHT))
+                                            .rounded(px(8.0))
+                                            .bg(row_bg)
+                                            .cursor_pointer()
+                                            .on_hover(hover_handler)
+                                            .child(
+                                                UnifiedListItem::new(
+                                                    gpui::ElementId::Name(semantic_id.into()),
+                                                    title,
+                                                )
+                                                .subtitle_opt(subtitle)
+                                                .leading_opt(leading)
+                                                .trailing_opt(trailing)
+                                                .state(ItemState {
+                                                    is_selected,
+                                                    is_hovered,
+                                                    is_disabled: false,
+                                                })
+                                                .density(Density::Comfortable)
+                                                .colors(item_colors),
+                                            );
 
-                                        rows.push(
-                                            div()
-                                                .id(display_idx)
-                                                .w_full()
-                                                .h(px(LIST_ITEM_HEIGHT))
-                                                .border_b_1()
-                                                .border_color(border_color)
-                                                .child(
-                                                    UnifiedListItem::new(
-                                                        gpui::ElementId::Name(semantic_id.into()),
-                                                        title,
-                                                    )
-                                                    .subtitle_opt(subtitle)
-                                                    .leading(LeadingContent::Emoji(
-                                                        indicator.into(),
-                                                    ))
-                                                    .trailing_opt(trailing)
-                                                    .state(ItemState {
-                                                        is_selected: is_focused,
-                                                        is_hovered: false,
-                                                        is_disabled: false,
-                                                    })
-                                                    .density(Density::Comfortable)
-                                                    .colors(row_colors)
-                                                    .with_accent_bar(is_selected_for_ui),
-                                                ),
-                                        );
+                                        if !is_focused {
+                                            row = row.hover(move |s| s.bg(hovered_row_bg));
+                                        }
+
+                                        rows.push(row);
                                     }
                                 }
                             }
@@ -234,6 +326,7 @@
             .flex_col()
             .flex_1()
             .w_full()
+            .px(px(8.0))
             .child(choices_content);
 
         div()


thinking
**Inspecting test imports and setup**
exec
/bin/zsh -lc "cd /Users/johnlindquist/dev/script-kit-gpui && sed -n '440,530p' src/list_item/part_000.rs" in /Users/johnlindquist/dev/script-kit-gpui succeeded in 52ms:
        }
    }

    /// Get number of headers
    pub fn header_count(&self) -> usize {
        self.header_indices.len()
    }
}
/// Pre-computed colors for ListItem rendering
///
/// This struct holds the primitive color values needed for list item rendering,
/// allowing efficient use in closures without cloning the full theme.
#[derive(Clone, Copy)]
pub struct ListItemColors {
    pub text_primary: u32,
    pub text_secondary: u32,
    pub text_muted: u32,
    pub text_dimmed: u32,
    pub accent_selected: u32,
    pub accent_selected_subtle: u32,
file update:
diff --git a/src/list_item/part_000.rs b/src/list_item/part_000.rs
index 733d4ac2aa5b1b27b29a5999310e6f3f45cc54c3..283b2263d56a92c73c22d44443db7b40971d26ce
--- a/src/list_item/part_000.rs
+++ b/src/list_item/part_000.rs
@@ -15,6 +15,37 @@
     /// Maps to IconName from designs::icon_variations
     Svg(String),
 }
+
+impl IconKind {
+    /// Resolve icon metadata into an IconKind for list rendering.
+    ///
+    /// Supports:
+    /// - Known SVG names/aliases via `icon_name_from_str` (e.g., "Terminal", "file-code")
+    /// - Emoji/symbol glyphs (e.g., "üìÑ", "‚ö°")
+    pub fn from_icon_hint(icon_hint: &str) -> Option<Self> {
+        let trimmed = icon_hint.trim();
+        if trimmed.is_empty() {
+            return None;
+        }
+
+        if icon_name_from_str(trimmed).is_some() {
+            return Some(Self::Svg(trimmed.to_string()));
+        }
+
+        if looks_like_symbol_icon_hint(trimmed) {
+            return Some(Self::Emoji(trimmed.to_string()));
+        }
+
+        None
+    }
+}
+
+fn looks_like_symbol_icon_hint(icon_hint: &str) -> bool {
+    let has_ascii_alnum = icon_hint.chars().any(|ch| ch.is_ascii_alphanumeric());
+    let char_count = icon_hint.chars().count();
+
+    !has_ascii_alnum && char_count <= 4
+}
 /// Fixed height for list items used in uniform-height virtualized lists.
 ///
 /// IMPORTANT: When using GPUI `uniform_list`, the item closure must render
@@ -437,3 +468,29 @@
     /// Text color for content displayed on accent/warning backgrounds
     pub text_on_accent: u32,
 }
+
+#[cfg(test)]
+mod icon_kind_tests {
+    use super::IconKind;
+
+    #[test]
+    fn test_icon_kind_from_icon_hint_returns_svg_when_known_icon_name() {
+        match IconKind::from_icon_hint("terminal") {
+            Some(IconKind::Svg(name)) => assert_eq!(name, "terminal"),
+            _ => panic!("expected SVG icon from known icon hint"),
+        }
+    }
+
+    #[test]
+    fn test_icon_kind_from_icon_hint_returns_emoji_when_symbol_glyph() {
+        match IconKind::from_icon_hint("üìÑ") {
+            Some(IconKind::Emoji(emoji)) => assert_eq!(emoji, "üìÑ"),
+            _ => panic!("expected emoji icon for symbol glyph"),
+        }
+    }
+
+    #[test]
+    fn test_icon_kind_from_icon_hint_returns_none_for_unknown_ascii_word() {
+        assert!(IconKind::from_icon_hint("unknown-icon-name").is_none());
+    }
+}
diff --git a/src/prompts/select/mod.rs b/src/prompts/select/mod.rs
index b6366dabfb14f3fae09f854f9de824fa629e0a3b..4ff3662b0b553a2aa8b9d8c752504d9db09a20da
--- a/src/prompts/select/mod.rs
+++ b/src/prompts/select/mod.rs
@@ -19,7 +19,7 @@
     UnifiedListItemColors,
 };
 use crate::designs::{get_tokens, DesignColors, DesignVariant};
-use crate::list_item::LIST_ITEM_HEIGHT;
+use crate::list_item::{IconKind, LIST_ITEM_HEIGHT};
 use crate::logging;
 use crate::panel::PROMPT_INPUT_FIELD_HEIGHT;
 use crate::protocol::{generate_semantic_id, Choice};
diff --git a/src/prompts/select/prompt.rs b/src/prompts/select/prompt.rs
index c5f98f5318f5b520e9223811f735e866ee06e7fb..5ba2de479b2f5680a73db72642377f68d26ee54e
--- a/src/prompts/select/prompt.rs
+++ b/src/prompts/select/prompt.rs
@@ -19,6 +19,8 @@
     pub filtered_choices: Vec<usize>,
     /// Currently focused index in filtered list
     pub focused_index: usize,
+    /// Currently hovered index in filtered list
+    pub hovered_index: Option<usize>,
     /// Filter text
     pub filter_text: String,
     /// Whether multiple selection is allowed
@@ -68,6 +70,7 @@
             selected: HashSet::new(),
             filtered_choices,
             focused_index: 0,
+            hovered_index: None,
             filter_text: String::new(),
             multiple,
             focus_handle,
@@ -84,6 +87,7 @@
         if trimmed_filter.is_empty() {
             self.filtered_choices = (0..self.choices.len()).collect();
             self.focused_index = 0;
+            self.hovered_index = None;
             return;
         }
 
@@ -109,6 +113,7 @@
 
         self.filtered_choices = scored_matches.into_iter().map(|(idx, _)| idx).collect();
         self.focused_index = 0;
+        self.hovered_index = None;
     }
 
     /// Set the filter text programmatically
@@ -168,6 +173,7 @@
     pub(super) fn move_up(&mut self, cx: &mut Context<Self>) {
         if self.focused_index > 0 {
             self.focused_index -= 1;
+            self.hovered_index = None;
             self.list_scroll_handle
                 .scroll_to_item(self.focused_index, ScrollStrategy::Nearest);
             cx.notify();
@@ -178,6 +184,7 @@
     pub(super) fn move_down(&mut self, cx: &mut Context<Self>) {
         if self.focused_index < self.filtered_choices.len().saturating_sub(1) {
             self.focused_index += 1;
+            self.hovered_index = None;
             self.list_scroll_handle
                 .scroll_to_item(self.focused_index, ScrollStrategy::Nearest);
             cx.notify();
diff --git a/src/prompts/select/render.rs b/src/prompts/select/render.rs
index 62109896c9c14b1b2fbf5b4d25d5d94e4388e4aa..8c67aba367edf1587ee80ac17707f23ad35c2ce1
--- a/src/prompts/select/render.rs
+++ b/src/prompts/select/render.rs
@@ -1,5 +1,57 @@
 use super::*;
 
+const ROW_FOCUSED_BG_ALPHA: u32 = 0x3A;
+const ROW_HOVER_BG_ALPHA: u32 = 0x26;
+
+fn extract_choice_icon_hint(description: Option<&str>) -> Option<&str> {
+    description.and_then(|raw| {
+        raw.split(['‚Ä¢', '|', '\n'])
+            .map(str::trim)
+            .find_map(|token| {
+                let token_lower = token.to_ascii_lowercase();
+                if token_lower == "icon"
+                    || token_lower.starts_with("icon:")
+                    || token_lower.starts_with("icon=")
+                    || token_lower.starts_with("icon ")
+                {
+                    token
+                        .split_once(':')
+                        .or_else(|| token.split_once('='))
+                        .map(|(_, value)| value.trim())
+                        .or_else(|| token.split_whitespace().nth(1))
+                } else {
+                    None
+                }
+            })
+            .filter(|value| !value.is_empty())
+    })
+}
+
+fn icon_kind_from_choice(choice: &Choice) -> IconKind {
+    let metadata_icon = extract_choice_icon_hint(choice.description.as_deref())
+        .and_then(IconKind::from_icon_hint);
+    let name_prefix_icon = choice
+        .name
+        .split_whitespace()
+        .next()
+        .and_then(IconKind::from_icon_hint);
+
+    metadata_icon
+        .or(name_prefix_icon)
+        .unwrap_or_else(|| IconKind::Svg("Code".to_string()))
+}
+
+fn leading_content_from_icon_kind(icon_kind: IconKind) -> LeadingContent {
+    match icon_kind {
+        IconKind::Emoji(emoji) => LeadingContent::Emoji(emoji.into()),
+        IconKind::Image(render_image) => LeadingContent::AppIcon(render_image),
+        IconKind::Svg(name) => LeadingContent::Icon {
+            name: SharedString::from(name),
+            color: None,
+        },
+    }
+}
+
 impl Focusable for SelectPrompt {
     fn focus_handle(&self, _cx: &gpui::App) -> FocusHandle {
         self.focus_handle.clone()
@@ -76,6 +128,13 @@
             self.design_variant,
             &colors,
         ));
+        let row_accent_color = if self.design_variant == DesignVariant::Default {
+            self.theme.colors.accent.selected
+        } else {
+            colors.accent
+        };
+        let focused_row_bg = rgba((row_accent_color << 8) | ROW_FOCUSED_BG_ALPHA);
+        let hovered_row_bg = rgba((row_accent_color << 8) | ROW_HOVER_BG_ALPHA);
 
         let placeholder = self
             .placeholder
@@ -145,8 +204,12 @@
                     move |this: &mut SelectPrompt,
                           visible_range: std::ops::Range<usize>,
                           _window,
-                          _cx| {
-                        let row_colors = UnifiedListItemColors::from_theme(&this.theme);
+                          cx| {
+                        let item_colors = UnifiedListItemColors {
+                            selected_opacity: 0.0,
+                            hover_opacity: 0.0,
+                            ..UnifiedListItemColors::from_theme(&this.theme)
+                        };
                         let mut rows = Vec::with_capacity(visible_range.len());
 
                         for display_idx in visible_range {
@@ -156,19 +219,21 @@
                                     {
                                         let is_focused = display_idx == this.focused_index;
                                         let is_selected = this.selected.contains(&choice_idx);
-                                        let is_selected_for_ui = if this.multiple {
-                                            is_selected
-                                        } else {
-                                            is_focused
-                                        };
+                                        let is_hovered = this.hovered_index == Some(display_idx);
                                         let semantic_id =
                                             choice.semantic_id.clone().unwrap_or_else(|| {
                                                 indexed_choice.stable_semantic_id.clone()
                                             });
-                                        let indicator = choice_selection_indicator(
-                                            this.multiple,
-                                            is_selected_for_ui,
-                                        );
+                                        let leading = if this.multiple {
+                                            Some(LeadingContent::Emoji(
+                                                choice_selection_indicator(true, is_selected)
+                                                    .into(),
+                                            ))
+                                        } else {
+                                            Some(leading_content_from_icon_kind(
+                                                icon_kind_from_choice(choice),
+                                            ))
+                                        };
                                         let subtitle = indexed_choice
                                             .metadata
                                             .subtitle_text()
@@ -185,34 +250,61 @@
                                                     ))
                                                 },
                                             );
+                                        let row_bg = if is_focused {
+                                            focused_row_bg
+                                        } else if is_hovered {
+                                            hovered_row_bg
+                                        } else {
+                                            rgba(0x00000000)
+                                        };
+                                        let hover_handler = cx.listener(
+                                            move |this: &mut SelectPrompt,
+                                                  hovered: &bool,
+                                                  _window,
+                                                  cx| {
+                                                if *hovered {
+                                                    if this.hovered_index != Some(display_idx) {
+                                                        this.hovered_index = Some(display_idx);
+                                                        cx.notify();
+                                                    }
+                                                } else if this.hovered_index == Some(display_idx)
+                                                {
+                                                    this.hovered_index = None;
+                                                    cx.notify();
+                                                }
+                                            },
+                                        );
+
+                                        let mut row = div()
+                                            .id(display_idx)
+                                            .w_full()
+                                            .h(px(LIST_ITEM_HEIGHT))
+                                            .rounded(px(8.0))
+                                            .bg(row_bg)
+                                            .cursor_pointer()
+                                            .on_hover(hover_handler)
+                                            .child(
+                                                UnifiedListItem::new(
+                                                    gpui::ElementId::Name(semantic_id.into()),
+                                                    title,
+                                                )
+                                                .subtitle_opt(subtitle)
+                                                .leading_opt(leading)
+                                                .trailing_opt(trailing)
+                                                .state(ItemState {
+                                                    is_selected,
+                                                    is_hovered,
+                                                    is_disabled: false,
+                                                })
+                                                .density(Density::Comfortable)
+                                                .colors(item_colors),
+                                            );
 
-                                        rows.push(
-                                            div()
-                                                .id(display_idx)
-                                                .w_full()
-                                                .h(px(LIST_ITEM_HEIGHT))
-                                                .border_b_1()
-                                                .border_color(border_color)
-                                                .child(
-                                                    UnifiedListItem::new(
-                                                        gpui::ElementId::Name(semantic_id.into()),
-                                                        title,
-                                                    )
-                                                    .subtitle_opt(subtitle)
-                                                    .leading(LeadingContent::Emoji(
-                                                        indicator.into(),
-                                                    ))
-                                                    .trailing_opt(trailing)
-                                                    .state(ItemState {
-                                                        is_selected: is_focused,
-                                                        is_hovered: false,
-                                                        is_disabled: false,
-                                                    })
-                                                    .density(Density::Comfortable)
-                                                    .colors(row_colors)
-                                                    .with_accent_bar(is_selected_for_ui),
-                                                ),
-                                        );
+                                        if !is_focused {
+                                            row = row.hover(move |s| s.bg(hovered_row_bg));
+                                        }
+
+                                        rows.push(row);
                                     }
                                 }
                             }
@@ -234,6 +326,7 @@
             .flex_col()
             .flex_1()
             .w_full()
+            .px(px(8.0))
             .child(choices_content);
 
         div()


thinking
**Reviewing UI state and styling updates**
codex
I confirmed the core behavior changes are in place; next I‚Äôm fixing the `mod.rs` visibility regression and then checking for any `SelectPrompt { ... }` initializers that now need `hovered_index` to compile cleanly before running scoped verification.
exec
/bin/zsh -lc "cd /Users/johnlindquist/dev/script-kit-gpui && rg -n \"SelectPrompt\\s*\\{\" src/prompts/select -g'*.rs'" in /Users/johnlindquist/dev/script-kit-gpuiexec
/bin/zsh -lc "cd /Users/johnlindquist/dev/script-kit-gpui && rg -n \"hovered_index\" src/prompts/select -g'*.rs'" in /Users/johnlindquist/dev/script-kit-gpui succeeded in 51ms:
src/prompts/select/prompt.rs:7:pub struct SelectPrompt {
src/prompts/select/prompt.rs:39:impl SelectPrompt {
src/prompts/select/prompt.rs:65:        SelectPrompt {
src/prompts/select/render.rs:55:impl Focusable for SelectPrompt {
src/prompts/select/render.rs:61:impl Render for SelectPrompt {
 succeeded in 51ms:
src/prompts/select/prompt.rs:23:    pub hovered_index: Option<usize>,
src/prompts/select/prompt.rs:73:            hovered_index: None,
src/prompts/select/prompt.rs:90:            self.hovered_index = None;
src/prompts/select/prompt.rs:116:        self.hovered_index = None;
src/prompts/select/prompt.rs:176:            self.hovered_index = None;
src/prompts/select/prompt.rs:187:            self.hovered_index = None;
src/prompts/select/render.rs:222:                                        let is_hovered = this.hovered_index == Some(display_idx);
src/prompts/select/render.rs:266:                                                    if this.hovered_index != Some(display_idx) {
src/prompts/select/render.rs:267:                                                        this.hovered_index = Some(display_idx);
src/prompts/select/render.rs:270:                                                } else if this.hovered_index == Some(display_idx)
src/prompts/select/render.rs:272:                                                    this.hovered_index = None;
file update:
diff --git a/src/list_item/part_000.rs b/src/list_item/part_000.rs
index 733d4ac2aa5b1b27b29a5999310e6f3f45cc54c3..283b2263d56a92c73c22d44443db7b40971d26ce
--- a/src/list_item/part_000.rs
+++ b/src/list_item/part_000.rs
@@ -15,6 +15,37 @@
     /// Maps to IconName from designs::icon_variations
     Svg(String),
 }
+
+impl IconKind {
+    /// Resolve icon metadata into an IconKind for list rendering.
+    ///
+    /// Supports:
+    /// - Known SVG names/aliases via `icon_name_from_str` (e.g., "Terminal", "file-code")
+    /// - Emoji/symbol glyphs (e.g., "üìÑ", "‚ö°")
+    pub fn from_icon_hint(icon_hint: &str) -> Option<Self> {
+        let trimmed = icon_hint.trim();
+        if trimmed.is_empty() {
+            return None;
+        }
+
+        if icon_name_from_str(trimmed).is_some() {
+            return Some(Self::Svg(trimmed.to_string()));
+        }
+
+        if looks_like_symbol_icon_hint(trimmed) {
+            return Some(Self::Emoji(trimmed.to_string()));
+        }
+
+        None
+    }
+}
+
+fn looks_like_symbol_icon_hint(icon_hint: &str) -> bool {
+    let has_ascii_alnum = icon_hint.chars().any(|ch| ch.is_ascii_alphanumeric());
+    let char_count = icon_hint.chars().count();
+
+    !has_ascii_alnum && char_count <= 4
+}
 /// Fixed height for list items used in uniform-height virtualized lists.
 ///
 /// IMPORTANT: When using GPUI `uniform_list`, the item closure must render
@@ -437,3 +468,29 @@
     /// Text color for content displayed on accent/warning backgrounds
     pub text_on_accent: u32,
 }
+
+#[cfg(test)]
+mod icon_kind_tests {
+    use super::IconKind;
+
+    #[test]
+    fn test_icon_kind_from_icon_hint_returns_svg_when_known_icon_name() {
+        match IconKind::from_icon_hint("terminal") {
+            Some(IconKind::Svg(name)) => assert_eq!(name, "terminal"),
+            _ => panic!("expected SVG icon from known icon hint"),
+        }
+    }
+
+    #[test]
+    fn test_icon_kind_from_icon_hint_returns_emoji_when_symbol_glyph() {
+        match IconKind::from_icon_hint("üìÑ") {
+            Some(IconKind::Emoji(emoji)) => assert_eq!(emoji, "üìÑ"),
+            _ => panic!("expected emoji icon for symbol glyph"),
+        }
+    }
+
+    #[test]
+    fn test_icon_kind_from_icon_hint_returns_none_for_unknown_ascii_word() {
+        assert!(IconKind::from_icon_hint("unknown-icon-name").is_none());
+    }
+}
diff --git a/src/prompts/select/mod.rs b/src/prompts/select/mod.rs
index b6366dabfb14f3fae09f854f9de824fa629e0a3b..4ff3662b0b553a2aa8b9d8c752504d9db09a20da
--- a/src/prompts/select/mod.rs
+++ b/src/prompts/select/mod.rs
@@ -19,7 +19,7 @@
     UnifiedListItemColors,
 };
 use crate::designs::{get_tokens, DesignColors, DesignVariant};
-use crate::list_item::LIST_ITEM_HEIGHT;
+use crate::list_item::{IconKind, LIST_ITEM_HEIGHT};
 use crate::logging;
 use crate::panel::PROMPT_INPUT_FIELD_HEIGHT;
 use crate::protocol::{generate_semantic_id, Choice};
diff --git a/src/prompts/select/prompt.rs b/src/prompts/select/prompt.rs
index c5f98f5318f5b520e9223811f735e866ee06e7fb..5ba2de479b2f5680a73db72642377f68d26ee54e
--- a/src/prompts/select/prompt.rs
+++ b/src/prompts/select/prompt.rs
@@ -19,6 +19,8 @@
     pub filtered_choices: Vec<usize>,
     /// Currently focused index in filtered list
     pub focused_index: usize,
+    /// Currently hovered index in filtered list
+    pub hovered_index: Option<usize>,
     /// Filter text
     pub filter_text: String,
     /// Whether multiple selection is allowed
@@ -68,6 +70,7 @@
             selected: HashSet::new(),
             filtered_choices,
             focused_index: 0,
+            hovered_index: None,
             filter_text: String::new(),
             multiple,
             focus_handle,
@@ -84,6 +87,7 @@
         if trimmed_filter.is_empty() {
             self.filtered_choices = (0..self.choices.len()).collect();
             self.focused_index = 0;
+            self.hovered_index = None;
             return;
         }
 
@@ -109,6 +113,7 @@
 
         self.filtered_choices = scored_matches.into_iter().map(|(idx, _)| idx).collect();
         self.focused_index = 0;
+        self.hovered_index = None;
     }
 
     /// Set the filter text programmatically
@@ -168,6 +173,7 @@
     pub(super) fn move_up(&mut self, cx: &mut Context<Self>) {
         if self.focused_index > 0 {
             self.focused_index -= 1;
+            self.hovered_index = None;
             self.list_scroll_handle
                 .scroll_to_item(self.focused_index, ScrollStrategy::Nearest);
             cx.notify();
@@ -178,6 +184,7 @@
     pub(super) fn move_down(&mut self, cx: &mut Context<Self>) {
         if self.focused_index < self.filtered_choices.len().saturating_sub(1) {
             self.focused_index += 1;
+            self.hovered_index = None;
             self.list_scroll_handle
                 .scroll_to_item(self.focused_index, ScrollStrategy::Nearest);
             cx.notify();
diff --git a/src/prompts/select/render.rs b/src/prompts/select/render.rs
index 62109896c9c14b1b2fbf5b4d25d5d94e4388e4aa..8c67aba367edf1587ee80ac17707f23ad35c2ce1
--- a/src/prompts/select/render.rs
+++ b/src/prompts/select/render.rs
@@ -1,5 +1,57 @@
 use super::*;
 
+const ROW_FOCUSED_BG_ALPHA: u32 = 0x3A;
+const ROW_HOVER_BG_ALPHA: u32 = 0x26;
+
+fn extract_choice_icon_hint(description: Option<&str>) -> Option<&str> {
+    description.and_then(|raw| {
+        raw.split(['‚Ä¢', '|', '\n'])
+            .map(str::trim)
+            .find_map(|token| {
+                let token_lower = token.to_ascii_lowercase();
+                if token_lower == "icon"
+                    || token_lower.starts_with("icon:")
+                    || token_lower.starts_with("icon=")
+                    || token_lower.starts_with("icon ")
+                {
+                    token
+                        .split_once(':')
+                        .or_else(|| token.split_once('='))
+                        .map(|(_, value)| value.trim())
+                        .or_else(|| token.split_whitespace().nth(1))
+                } else {
+                    None
+                }
+            })
+            .filter(|value| !value.is_empty())
+    })
+}
+
+fn icon_kind_from_choice(choice: &Choice) -> IconKind {
+    let metadata_icon = extract_choice_icon_hint(choice.description.as_deref())
+        .and_then(IconKind::from_icon_hint);
+    let name_prefix_icon = choice
+        .name
+        .split_whitespace()
+        .next()
+        .and_then(IconKind::from_icon_hint);
+
+    metadata_icon
+        .or(name_prefix_icon)
+        .unwrap_or_else(|| IconKind::Svg("Code".to_string()))
+}
+
+fn leading_content_from_icon_kind(icon_kind: IconKind) -> LeadingContent {
+    match icon_kind {
+        IconKind::Emoji(emoji) => LeadingContent::Emoji(emoji.into()),
+        IconKind::Image(render_image) => LeadingContent::AppIcon(render_image),
+        IconKind::Svg(name) => LeadingContent::Icon {
+            name: SharedString::from(name),
+            color: None,
+        },
+    }
+}
+
 impl Focusable for SelectPrompt {
     fn focus_handle(&self, _cx: &gpui::App) -> FocusHandle {
         self.focus_handle.clone()
@@ -76,6 +128,13 @@
             self.design_variant,
             &colors,
         ));
+        let row_accent_color = if self.design_variant == DesignVariant::Default {
+            self.theme.colors.accent.selected
+        } else {
+            colors.accent
+        };
+        let focused_row_bg = rgba((row_accent_color << 8) | ROW_FOCUSED_BG_ALPHA);
+        let hovered_row_bg = rgba((row_accent_color << 8) | ROW_HOVER_BG_ALPHA);
 
         let placeholder = self
             .placeholder
@@ -145,8 +204,12 @@
                     move |this: &mut SelectPrompt,
                           visible_range: std::ops::Range<usize>,
                           _window,
-                          _cx| {
-                        let row_colors = UnifiedListItemColors::from_theme(&this.theme);
+                          cx| {
+                        let item_colors = UnifiedListItemColors {
+                            selected_opacity: 0.0,
+                            hover_opacity: 0.0,
+                            ..UnifiedListItemColors::from_theme(&this.theme)
+                        };
                         let mut rows = Vec::with_capacity(visible_range.len());
 
                         for display_idx in visible_range {
@@ -156,19 +219,21 @@
                                     {
                                         let is_focused = display_idx == this.focused_index;
                                         let is_selected = this.selected.contains(&choice_idx);
-                                        let is_selected_for_ui = if this.multiple {
-                                            is_selected
-                                        } else {
-                                            is_focused
-                                        };
+                                        let is_hovered = this.hovered_index == Some(display_idx);
                                         let semantic_id =
                                             choice.semantic_id.clone().unwrap_or_else(|| {
                                                 indexed_choice.stable_semantic_id.clone()
                                             });
-                                        let indicator = choice_selection_indicator(
-                                            this.multiple,
-                                            is_selected_for_ui,
-                                        );
+                                        let leading = if this.multiple {
+                                            Some(LeadingContent::Emoji(
+                                                choice_selection_indicator(true, is_selected)
+                                                    .into(),
+                                            ))
+                                        } else {
+                                            Some(leading_content_from_icon_kind(
+                                                icon_kind_from_choice(choice),
+                                            ))
+                                        };
                                         let subtitle = indexed_choice
                                             .metadata
                                             .subtitle_text()
@@ -185,34 +250,61 @@
                                                     ))
                                                 },
                                             );
+                                        let row_bg = if is_focused {
+                                            focused_row_bg
+                                        } else if is_hovered {
+                                            hovered_row_bg
+                                        } else {
+                                            rgba(0x00000000)
+                                        };
+                                        let hover_handler = cx.listener(
+                                            move |this: &mut SelectPrompt,
+                                                  hovered: &bool,
+                                                  _window,
+                                                  cx| {
+                                                if *hovered {
+                                                    if this.hovered_index != Some(display_idx) {
+                                                        this.hovered_index = Some(display_idx);
+                                                        cx.notify();
+                                                    }
+                                                } else if this.hovered_index == Some(display_idx)
+                                                {
+                                                    this.hovered_index = None;
+                                                    cx.notify();
+                                                }
+                                            },
+                                        );
+
+                                        let mut row = div()
+                                            .id(display_idx)
+                                            .w_full()
+                                            .h(px(LIST_ITEM_HEIGHT))
+                                            .rounded(px(8.0))
+                                            .bg(row_bg)
+                                            .cursor_pointer()
+                                            .on_hover(hover_handler)
+                                            .child(
+                                                UnifiedListItem::new(
+                                                    gpui::ElementId::Name(semantic_id.into()),
+                                                    title,
+                                                )
+                                                .subtitle_opt(subtitle)
+                                                .leading_opt(leading)
+                                                .trailing_opt(trailing)
+                                                .state(ItemState {
+                                                    is_selected,
+                                                    is_hovered,
+                                                    is_disabled: false,
+                                                })
+                                                .density(Density::Comfortable)
+                                                .colors(item_colors),
+                                            );
 
-                                        rows.push(
-                                            div()
-                                                .id(display_idx)
-                                                .w_full()
-                                                .h(px(LIST_ITEM_HEIGHT))
-                                                .border_b_1()
-                                                .border_color(border_color)
-                                                .child(
-                                                    UnifiedListItem::new(
-                                                        gpui::ElementId::Name(semantic_id.into()),
-                                                        title,
-                                                    )
-                                                    .subtitle_opt(subtitle)
-                                                    .leading(LeadingContent::Emoji(
-                                                        indicator.into(),
-                                                    ))
-                                                    .trailing_opt(trailing)
-                                                    .state(ItemState {
-                                                        is_selected: is_focused,
-                                                        is_hovered: false,
-                                                        is_disabled: false,
-                                                    })
-                                                    .density(Density::Comfortable)
-                                                    .colors(row_colors)
-                                                    .with_accent_bar(is_selected_for_ui),
-                                                ),
-                                        );
+                                        if !is_focused {
+                                            row = row.hover(move |s| s.bg(hovered_row_bg));
+                                        }
+
+                                        rows.push(row);
                                     }
                                 }
                             }
@@ -234,6 +326,7 @@
             .flex_col()
             .flex_1()
             .w_full()
+            .px(px(8.0))
             .child(choices_content);
 
         div()


thinking
**Confirming patch approach**
file update
M /Users/johnlindquist/dev/script-kit-gpui/src/prompts/select/mod.rs
@@ -39,3 +39,3 @@
 pub use prompt::SelectPrompt;
-use search::*;
-use types::*;
+pub(super) use search::*;
+pub(super) use types::*;
apply_patch(auto_approved=true) exited 0 in 26ms:
Success. Updated the following files:
M /Users/johnlindquist/dev/script-kit-gpui/src/prompts/select/mod.rs
file update:
diff --git a/src/list_item/part_000.rs b/src/list_item/part_000.rs
index 733d4ac2aa5b1b27b29a5999310e6f3f45cc54c3..283b2263d56a92c73c22d44443db7b40971d26ce
--- a/src/list_item/part_000.rs
+++ b/src/list_item/part_000.rs
@@ -15,6 +15,37 @@
     /// Maps to IconName from designs::icon_variations
     Svg(String),
 }
+
+impl IconKind {
+    /// Resolve icon metadata into an IconKind for list rendering.
+    ///
+    /// Supports:
+    /// - Known SVG names/aliases via `icon_name_from_str` (e.g., "Terminal", "file-code")
+    /// - Emoji/symbol glyphs (e.g., "üìÑ", "‚ö°")
+    pub fn from_icon_hint(icon_hint: &str) -> Option<Self> {
+        let trimmed = icon_hint.trim();
+        if trimmed.is_empty() {
+            return None;
+        }
+
+        if icon_name_from_str(trimmed).is_some() {
+            return Some(Self::Svg(trimmed.to_string()));
+        }
+
+        if looks_like_symbol_icon_hint(trimmed) {
+            return Some(Self::Emoji(trimmed.to_string()));
+        }
+
+        None
+    }
+}
+
+fn looks_like_symbol_icon_hint(icon_hint: &str) -> bool {
+    let has_ascii_alnum = icon_hint.chars().any(|ch| ch.is_ascii_alphanumeric());
+    let char_count = icon_hint.chars().count();
+
+    !has_ascii_alnum && char_count <= 4
+}
 /// Fixed height for list items used in uniform-height virtualized lists.
 ///
 /// IMPORTANT: When using GPUI `uniform_list`, the item closure must render
@@ -437,3 +468,29 @@
     /// Text color for content displayed on accent/warning backgrounds
     pub text_on_accent: u32,
 }
+
+#[cfg(test)]
+mod icon_kind_tests {
+    use super::IconKind;
+
+    #[test]
+    fn test_icon_kind_from_icon_hint_returns_svg_when_known_icon_name() {
+        match IconKind::from_icon_hint("terminal") {
+            Some(IconKind::Svg(name)) => assert_eq!(name, "terminal"),
+            _ => panic!("expected SVG icon from known icon hint"),
+        }
+    }
+
+    #[test]
+    fn test_icon_kind_from_icon_hint_returns_emoji_when_symbol_glyph() {
+        match IconKind::from_icon_hint("üìÑ") {
+            Some(IconKind::Emoji(emoji)) => assert_eq!(emoji, "üìÑ"),
+            _ => panic!("expected emoji icon for symbol glyph"),
+        }
+    }
+
+    #[test]
+    fn test_icon_kind_from_icon_hint_returns_none_for_unknown_ascii_word() {
+        assert!(IconKind::from_icon_hint("unknown-icon-name").is_none());
+    }
+}
diff --git a/src/prompts/select/mod.rs b/src/prompts/select/mod.rs
index b6366dabfb14f3fae09f854f9de824fa629e0a3b..32ec6dd9fa7ee4b5d29009f3cc5a665713f97a10
--- a/src/prompts/select/mod.rs
+++ b/src/prompts/select/mod.rs
@@ -19,7 +19,7 @@
     UnifiedListItemColors,
 };
 use crate::designs::{get_tokens, DesignColors, DesignVariant};
-use crate::list_item::LIST_ITEM_HEIGHT;
+use crate::list_item::{IconKind, LIST_ITEM_HEIGHT};
 use crate::logging;
 use crate::panel::PROMPT_INPUT_FIELD_HEIGHT;
 use crate::protocol::{generate_semantic_id, Choice};
@@ -37,5 +37,5 @@
 mod types;
 
 pub use prompt::SelectPrompt;
-use search::*;
-use types::*;
+pub(super) use search::*;
+pub(super) use types::*;
diff --git a/src/prompts/select/prompt.rs b/src/prompts/select/prompt.rs
index c5f98f5318f5b520e9223811f735e866ee06e7fb..5ba2de479b2f5680a73db72642377f68d26ee54e
--- a/src/prompts/select/prompt.rs
+++ b/src/prompts/select/prompt.rs
@@ -19,6 +19,8 @@
     pub filtered_choices: Vec<usize>,
     /// Currently focused index in filtered list
     pub focused_index: usize,
+    /// Currently hovered index in filtered list
+    pub hovered_index: Option<usize>,
     /// Filter text
     pub filter_text: String,
     /// Whether multiple selection is allowed
@@ -68,6 +70,7 @@
             selected: HashSet::new(),
             filtered_choices,
             focused_index: 0,
+            hovered_index: None,
             filter_text: String::new(),
             multiple,
             focus_handle,
@@ -84,6 +87,7 @@
         if trimmed_filter.is_empty() {
             self.filtered_choices = (0..self.choices.len()).collect();
             self.focused_index = 0;
+            self.hovered_index = None;
             return;
         }
 
@@ -109,6 +113,7 @@
 
         self.filtered_choices = scored_matches.into_iter().map(|(idx, _)| idx).collect();
         self.focused_index = 0;
+        self.hovered_index = None;
     }
 
     /// Set the filter text programmatically
@@ -168,6 +173,7 @@
     pub(super) fn move_up(&mut self, cx: &mut Context<Self>) {
         if self.focused_index > 0 {
             self.focused_index -= 1;
+            self.hovered_index = None;
             self.list_scroll_handle
                 .scroll_to_item(self.focused_index, ScrollStrategy::Nearest);
             cx.notify();
@@ -178,6 +184,7 @@
     pub(super) fn move_down(&mut self, cx: &mut Context<Self>) {
         if self.focused_index < self.filtered_choices.len().saturating_sub(1) {
             self.focused_index += 1;
+            self.hovered_index = None;
             self.list_scroll_handle
                 .scroll_to_item(self.focused_index, ScrollStrategy::Nearest);
             cx.notify();
diff --git a/src/prompts/select/render.rs b/src/prompts/select/render.rs
index 62109896c9c14b1b2fbf5b4d25d5d94e4388e4aa..8c67aba367edf1587ee80ac17707f23ad35c2ce1
--- a/src/prompts/select/render.rs
+++ b/src/prompts/select/render.rs
@@ -1,5 +1,57 @@
 use super::*;
 
+const ROW_FOCUSED_BG_ALPHA: u32 = 0x3A;
+const ROW_HOVER_BG_ALPHA: u32 = 0x26;
+
+fn extract_choice_icon_hint(description: Option<&str>) -> Option<&str> {
+    description.and_then(|raw| {
+        raw.split(['‚Ä¢', '|', '\n'])
+            .map(str::trim)
+            .find_map(|token| {
+                let token_lower = token.to_ascii_lowercase();
+                if token_lower == "icon"
+                    || token_lower.starts_with("icon:")
+                    || token_lower.starts_with("icon=")
+                    || token_lower.starts_with("icon ")
+                {
+                    token
+                        .split_once(':')
+                        .or_else(|| token.split_once('='))
+                        .map(|(_, value)| value.trim())
+                        .or_else(|| token.split_whitespace().nth(1))
+                } else {
+                    None
+                }
+            })
+            .filter(|value| !value.is_empty())
+    })
+}
+
+fn icon_kind_from_choice(choice: &Choice) -> IconKind {
+    let metadata_icon = extract_choice_icon_hint(choice.description.as_deref())
+        .and_then(IconKind::from_icon_hint);
+    let name_prefix_icon = choice
+        .name
+        .split_whitespace()
+        .next()
+        .and_then(IconKind::from_icon_hint);
+
+    metadata_icon
+        .or(name_prefix_icon)
+        .unwrap_or_else(|| IconKind::Svg("Code".to_string()))
+}
+
+fn leading_content_from_icon_kind(icon_kind: IconKind) -> LeadingContent {
+    match icon_kind {
+        IconKind::Emoji(emoji) => LeadingContent::Emoji(emoji.into()),
+        IconKind::Image(render_image) => LeadingContent::AppIcon(render_image),
+        IconKind::Svg(name) => LeadingContent::Icon {
+            name: SharedString::from(name),
+            color: None,
+        },
+    }
+}
+
 impl Focusable for SelectPrompt {
     fn focus_handle(&self, _cx: &gpui::App) -> FocusHandle {
         self.focus_handle.clone()
@@ -76,6 +128,13 @@
             self.design_variant,
             &colors,
         ));
+        let row_accent_color = if self.design_variant == DesignVariant::Default {
+            self.theme.colors.accent.selected
+        } else {
+            colors.accent
+        };
+        let focused_row_bg = rgba((row_accent_color << 8) | ROW_FOCUSED_BG_ALPHA);
+        let hovered_row_bg = rgba((row_accent_color << 8) | ROW_HOVER_BG_ALPHA);
 
         let placeholder = self
             .placeholder
@@ -145,8 +204,12 @@
                     move |this: &mut SelectPrompt,
                           visible_range: std::ops::Range<usize>,
                           _window,
-                          _cx| {
-                        let row_colors = UnifiedListItemColors::from_theme(&this.theme);
+                          cx| {
+                        let item_colors = UnifiedListItemColors {
+                            selected_opacity: 0.0,
+                            hover_opacity: 0.0,
+                            ..UnifiedListItemColors::from_theme(&this.theme)
+                        };
                         let mut rows = Vec::with_capacity(visible_range.len());
 
                         for display_idx in visible_range {
@@ -156,19 +219,21 @@
                                     {
                                         let is_focused = display_idx == this.focused_index;
                                         let is_selected = this.selected.contains(&choice_idx);
-                                        let is_selected_for_ui = if this.multiple {
-                                            is_selected
-                                        } else {
-                                            is_focused
-                                        };
+                                        let is_hovered = this.hovered_index == Some(display_idx);
                                         let semantic_id =
                                             choice.semantic_id.clone().unwrap_or_else(|| {
                                                 indexed_choice.stable_semantic_id.clone()
                                             });
-                                        let indicator = choice_selection_indicator(
-                                            this.multiple,
-                                            is_selected_for_ui,
-                                        );
+                                        let leading = if this.multiple {
+                                            Some(LeadingContent::Emoji(
+                                                choice_selection_indicator(true, is_selected)
+                                                    .into(),
+                                            ))
+                                        } else {
+                                            Some(leading_content_from_icon_kind(
+                                                icon_kind_from_choice(choice),
+                                            ))
+                                        };
                                         let subtitle = indexed_choice
                                             .metadata
                                             .subtitle_text()
@@ -185,34 +250,61 @@
                                                     ))
                                                 },
                                             );
+                                        let row_bg = if is_focused {
+                                            focused_row_bg
+                                        } else if is_hovered {
+                                            hovered_row_bg
+                                        } else {
+                                            rgba(0x00000000)
+                                        };
+                                        let hover_handler = cx.listener(
+                                            move |this: &mut SelectPrompt,
+                                                  hovered: &bool,
+                                                  _window,
+                                                  cx| {
+                                                if *hovered {
+                                                    if this.hovered_index != Some(display_idx) {
+                                                        this.hovered_index = Some(display_idx);
+                                                        cx.notify();
+                                                    }
+                                                } else if this.hovered_index == Some(display_idx)
+                                                {
+                                                    this.hovered_index = None;
+                                                    cx.notify();
+                                                }
+                                            },
+                                        );
+
+                                        let mut row = div()
+                                            .id(display_idx)
+                                            .w_full()
+                                            .h(px(LIST_ITEM_HEIGHT))
+                                            .rounded(px(8.0))
+                                            .bg(row_bg)
+                                            .cursor_pointer()
+                                            .on_hover(hover_handler)
+                                            .child(
+                                                UnifiedListItem::new(
+                                                    gpui::ElementId::Name(semantic_id.into()),
+                                                    title,
+                                                )
+                                                .subtitle_opt(subtitle)
+                                                .leading_opt(leading)
+                                                .trailing_opt(trailing)
+                                                .state(ItemState {
+                                                    is_selected,
+                                                    is_hovered,
+                                                    is_disabled: false,
+                                                })
+                                                .density(Density::Comfortable)
+                                                .colors(item_colors),
+                                            );
 
-                                        rows.push(
-                                            div()
-                                                .id(display_idx)
-                                                .w_full()
-                                                .h(px(LIST_ITEM_HEIGHT))
-                                                .border_b_1()
-                                                .border_color(border_color)
-                                                .child(
-                                                    UnifiedListItem::new(
-                                                        gpui::ElementId::Name(semantic_id.into()),
-                                                        title,
-                                                    )
-                                                    .subtitle_opt(subtitle)
-                                                    .leading(LeadingContent::Emoji(
-                                                        indicator.into(),
-                                                    ))
-                                                    .trailing_opt(trailing)
-                                                    .state(ItemState {
-                                                        is_selected: is_focused,
-                                                        is_hovered: false,
-                                                        is_disabled: false,
-                                                    })
-                                                    .density(Density::Comfortable)
-                                                    .colors(row_colors)
-                                                    .with_accent_bar(is_selected_for_ui),
-                                                ),
-                                        );
+                                        if !is_focused {
+                                            row = row.hover(move |s| s.bg(hovered_row_bg));
+                                        }
+
+                                        rows.push(row);
                                     }
                                 }
                             }
@@ -234,6 +326,7 @@
             .flex_col()
             .flex_1()
             .w_full()
+            .px(px(8.0))
             .child(choices_content);
 
         div()

file update:
diff --git a/src/list_item/part_000.rs b/src/list_item/part_000.rs
index 733d4ac2aa5b1b27b29a5999310e6f3f45cc54c3..283b2263d56a92c73c22d44443db7b40971d26ce
--- a/src/list_item/part_000.rs
+++ b/src/list_item/part_000.rs
@@ -15,6 +15,37 @@
     /// Maps to IconName from designs::icon_variations
     Svg(String),
 }
+
+impl IconKind {
+    /// Resolve icon metadata into an IconKind for list rendering.
+    ///
+    /// Supports:
+    /// - Known SVG names/aliases via `icon_name_from_str` (e.g., "Terminal", "file-code")
+    /// - Emoji/symbol glyphs (e.g., "üìÑ", "‚ö°")
+    pub fn from_icon_hint(icon_hint: &str) -> Option<Self> {
+        let trimmed = icon_hint.trim();
+        if trimmed.is_empty() {
+            return None;
+        }
+
+        if icon_name_from_str(trimmed).is_some() {
+            return Some(Self::Svg(trimmed.to_string()));
+        }
+
+        if looks_like_symbol_icon_hint(trimmed) {
+            return Some(Self::Emoji(trimmed.to_string()));
+        }
+
+        None
+    }
+}
+
+fn looks_like_symbol_icon_hint(icon_hint: &str) -> bool {
+    let has_ascii_alnum = icon_hint.chars().any(|ch| ch.is_ascii_alphanumeric());
+    let char_count = icon_hint.chars().count();
+
+    !has_ascii_alnum && char_count <= 4
+}
 /// Fixed height for list items used in uniform-height virtualized lists.
 ///
 /// IMPORTANT: When using GPUI `uniform_list`, the item closure must render
@@ -437,3 +468,29 @@
     /// Text color for content displayed on accent/warning backgrounds
     pub text_on_accent: u32,
 }
+
+#[cfg(test)]
+mod icon_kind_tests {
+    use super::IconKind;
+
+    #[test]
+    fn test_icon_kind_from_icon_hint_returns_svg_when_known_icon_name() {
+        match IconKind::from_icon_hint("terminal") {
+            Some(IconKind::Svg(name)) => assert_eq!(name, "terminal"),
+            _ => panic!("expected SVG icon from known icon hint"),
+        }
+    }
+
+    #[test]
+    fn test_icon_kind_from_icon_hint_returns_emoji_when_symbol_glyph() {
+        match IconKind::from_icon_hint("üìÑ") {
+            Some(IconKind::Emoji(emoji)) => assert_eq!(emoji, "üìÑ"),
+            _ => panic!("expected emoji icon for symbol glyph"),
+        }
+    }
+
+    #[test]
+    fn test_icon_kind_from_icon_hint_returns_none_for_unknown_ascii_word() {
+        assert!(IconKind::from_icon_hint("unknown-icon-name").is_none());
+    }
+}
diff --git a/src/prompts/select/mod.rs b/src/prompts/select/mod.rs
index b6366dabfb14f3fae09f854f9de824fa629e0a3b..32ec6dd9fa7ee4b5d29009f3cc5a665713f97a10
--- a/src/prompts/select/mod.rs
+++ b/src/prompts/select/mod.rs
@@ -19,7 +19,7 @@
     UnifiedListItemColors,
 };
 use crate::designs::{get_tokens, DesignColors, DesignVariant};
-use crate::list_item::LIST_ITEM_HEIGHT;
+use crate::list_item::{IconKind, LIST_ITEM_HEIGHT};
 use crate::logging;
 use crate::panel::PROMPT_INPUT_FIELD_HEIGHT;
 use crate::protocol::{generate_semantic_id, Choice};
@@ -37,5 +37,5 @@
 mod types;
 
 pub use prompt::SelectPrompt;
-use search::*;
-use types::*;
+pub(super) use search::*;
+pub(super) use types::*;
diff --git a/src/prompts/select/prompt.rs b/src/prompts/select/prompt.rs
index c5f98f5318f5b520e9223811f735e866ee06e7fb..5ba2de479b2f5680a73db72642377f68d26ee54e
--- a/src/prompts/select/prompt.rs
+++ b/src/prompts/select/prompt.rs
@@ -19,6 +19,8 @@
     pub filtered_choices: Vec<usize>,
     /// Currently focused index in filtered list
     pub focused_index: usize,
+    /// Currently hovered index in filtered list
+    pub hovered_index: Option<usize>,
     /// Filter text
     pub filter_text: String,
     /// Whether multiple selection is allowed
@@ -68,6 +70,7 @@
             selected: HashSet::new(),
             filtered_choices,
             focused_index: 0,
+            hovered_index: None,
             filter_text: String::new(),
             multiple,
             focus_handle,
@@ -84,6 +87,7 @@
         if trimmed_filter.is_empty() {
             self.filtered_choices = (0..self.choices.len()).collect();
             self.focused_index = 0;
+            self.hovered_index = None;
             return;
         }
 
@@ -109,6 +113,7 @@
 
         self.filtered_choices = scored_matches.into_iter().map(|(idx, _)| idx).collect();
         self.focused_index = 0;
+        self.hovered_index = None;
     }
 
     /// Set the filter text programmatically
@@ -168,6 +173,7 @@
     pub(super) fn move_up(&mut self, cx: &mut Context<Self>) {
         if self.focused_index > 0 {
             self.focused_index -= 1;
+            self.hovered_index = None;
             self.list_scroll_handle
                 .scroll_to_item(self.focused_index, ScrollStrategy::Nearest);
             cx.notify();
@@ -178,6 +184,7 @@
     pub(super) fn move_down(&mut self, cx: &mut Context<Self>) {
         if self.focused_index < self.filtered_choices.len().saturating_sub(1) {
             self.focused_index += 1;
+            self.hovered_index = None;
             self.list_scroll_handle
                 .scroll_to_item(self.focused_index, ScrollStrategy::Nearest);
             cx.notify();
diff --git a/src/prompts/select/render.rs b/src/prompts/select/render.rs
index 62109896c9c14b1b2fbf5b4d25d5d94e4388e4aa..8c67aba367edf1587ee80ac17707f23ad35c2ce1
--- a/src/prompts/select/render.rs
+++ b/src/prompts/select/render.rs
@@ -1,5 +1,57 @@
 use super::*;
 
+const ROW_FOCUSED_BG_ALPHA: u32 = 0x3A;
+const ROW_HOVER_BG_ALPHA: u32 = 0x26;
+
+fn extract_choice_icon_hint(description: Option<&str>) -> Option<&str> {
+    description.and_then(|raw| {
+        raw.split(['‚Ä¢', '|', '\n'])
+            .map(str::trim)
+            .find_map(|token| {
+                let token_lower = token.to_ascii_lowercase();
+                if token_lower == "icon"
+                    || token_lower.starts_with("icon:")
+                    || token_lower.starts_with("icon=")
+                    || token_lower.starts_with("icon ")
+                {
+                    token
+                        .split_once(':')
+                        .or_else(|| token.split_once('='))
+                        .map(|(_, value)| value.trim())
+                        .or_else(|| token.split_whitespace().nth(1))
+                } else {
+                    None
+                }
+            })
+            .filter(|value| !value.is_empty())
+    })
+}
+
+fn icon_kind_from_choice(choice: &Choice) -> IconKind {
+    let metadata_icon = extract_choice_icon_hint(choice.description.as_deref())
+        .and_then(IconKind::from_icon_hint);
+    let name_prefix_icon = choice
+        .name
+        .split_whitespace()
+        .next()
+        .and_then(IconKind::from_icon_hint);
+
+    metadata_icon
+        .or(name_prefix_icon)
+        .unwrap_or_else(|| IconKind::Svg("Code".to_string()))
+}
+
+fn leading_content_from_icon_kind(icon_kind: IconKind) -> LeadingContent {
+    match icon_kind {
+        IconKind::Emoji(emoji) => LeadingContent::Emoji(emoji.into()),
+        IconKind::Image(render_image) => LeadingContent::AppIcon(render_image),
+        IconKind::Svg(name) => LeadingContent::Icon {
+            name: SharedString::from(name),
+            color: None,
+        },
+    }
+}
+
 impl Focusable for SelectPrompt {
     fn focus_handle(&self, _cx: &gpui::App) -> FocusHandle {
         self.focus_handle.clone()
@@ -76,6 +128,13 @@
             self.design_variant,
             &colors,
         ));
+        let row_accent_color = if self.design_variant == DesignVariant::Default {
+            self.theme.colors.accent.selected
+        } else {
+            colors.accent
+        };
+        let focused_row_bg = rgba((row_accent_color << 8) | ROW_FOCUSED_BG_ALPHA);
+        let hovered_row_bg = rgba((row_accent_color << 8) | ROW_HOVER_BG_ALPHA);
 
         let placeholder = self
             .placeholder
@@ -145,8 +204,12 @@
                     move |this: &mut SelectPrompt,
                           visible_range: std::ops::Range<usize>,
                           _window,
-                          _cx| {
-                        let row_colors = UnifiedListItemColors::from_theme(&this.theme);
+                          cx| {
+                        let item_colors = UnifiedListItemColors {
+                            selected_opacity: 0.0,
+                            hover_opacity: 0.0,
+                            ..UnifiedListItemColors::from_theme(&this.theme)
+                        };
                         let mut rows = Vec::with_capacity(visible_range.len());
 
                         for display_idx in visible_range {
@@ -156,19 +219,21 @@
                                     {
                                         let is_focused = display_idx == this.focused_index;
                                         let is_selected = this.selected.contains(&choice_idx);
-                                        let is_selected_for_ui = if this.multiple {
-                                            is_selected
-                                        } else {
-                                            is_focused
-                                        };
+                                        let is_hovered = this.hovered_index == Some(display_idx);
                                         let semantic_id =
                                             choice.semantic_id.clone().unwrap_or_else(|| {
                                                 indexed_choice.stable_semantic_id.clone()
                                             });
-                                        let indicator = choice_selection_indicator(
-                                            this.multiple,
-                                            is_selected_for_ui,
-                                        );
+                                        let leading = if this.multiple {
+                                            Some(LeadingContent::Emoji(
+                                                choice_selection_indicator(true, is_selected)
+                                                    .into(),
+                                            ))
+                                        } else {
+                                            Some(leading_content_from_icon_kind(
+                                                icon_kind_from_choice(choice),
+                                            ))
+                                        };
                                         let subtitle = indexed_choice
                                             .metadata
                                             .subtitle_text()
@@ -185,34 +250,61 @@
                                                     ))
                                                 },
                                             );
+                                        let row_bg = if is_focused {
+                                            focused_row_bg
+                                        } else if is_hovered {
+                                            hovered_row_bg
+                                        } else {
+                                            rgba(0x00000000)
+                                        };
+                                        let hover_handler = cx.listener(
+                                            move |this: &mut SelectPrompt,
+                                                  hovered: &bool,
+                                                  _window,
+                                                  cx| {
+                                                if *hovered {
+                                                    if this.hovered_index != Some(display_idx) {
+                                                        this.hovered_index = Some(display_idx);
+                                                        cx.notify();
+                                                    }
+                                                } else if this.hovered_index == Some(display_idx)
+                                                {
+                                                    this.hovered_index = None;
+                                                    cx.notify();
+                                                }
+                                            },
+                                        );
+
+                                        let mut row = div()
+                                            .id(display_idx)
+                                            .w_full()
+                                            .h(px(LIST_ITEM_HEIGHT))
+                                            .rounded(px(8.0))
+                                            .bg(row_bg)
+                                            .cursor_pointer()
+                                            .on_hover(hover_handler)
+                                            .child(
+                                                UnifiedListItem::new(
+                                                    gpui::ElementId::Name(semantic_id.into()),
+                                                    title,
+                                                )
+                                                .subtitle_opt(subtitle)
+                                                .leading_opt(leading)
+                                                .trailing_opt(trailing)
+                                                .state(ItemState {
+                                                    is_selected,
+                                                    is_hovered,
+                                                    is_disabled: false,
+                                                })
+                                                .density(Density::Comfortable)
+                                                .colors(item_colors),
+                                            );
 
-                                        rows.push(
-                                            div()
-                                                .id(display_idx)
-                                                .w_full()
-                                                .h(px(LIST_ITEM_HEIGHT))
-                                                .border_b_1()
-                                                .border_color(border_color)
-                                                .child(
-                                                    UnifiedListItem::new(
-                                                        gpui::ElementId::Name(semantic_id.into()),
-                                                        title,
-                                                    )
-                                                    .subtitle_opt(subtitle)
-                                                    .leading(LeadingContent::Emoji(
-                                                        indicator.into(),
-                                                    ))
-                                                    .trailing_opt(trailing)
-                                                    .state(ItemState {
-                                                        is_selected: is_focused,
-                                                        is_hovered: false,
-                                                        is_disabled: false,
-                                                    })
-                                                    .density(Density::Comfortable)
-                                                    .colors(row_colors)
-                                                    .with_accent_bar(is_selected_for_ui),
-                                                ),
-                                        );
+                                        if !is_focused {
+                                            row = row.hover(move |s| s.bg(hovered_row_bg));
+                                        }
+
+                                        rows.push(row);
                                     }
                                 }
                             }
@@ -234,6 +326,7 @@
             .flex_col()
             .flex_1()
             .w_full()
+            .px(px(8.0))
             .child(choices_content);
 
         div()


thinking
**Inspecting item state properties**
exec
/bin/zsh -lc "cd /Users/johnlindquist/dev/script-kit-gpui && rg -n \"pub struct ItemState|is_hovered\" src/components -g'*.rs'" in /Users/johnlindquist/dev/script-kit-gpui succeeded in 52ms:
src/components/unified_list_item/render.rs:125:        } else if state.is_hovered {
src/components/unified_list_item/types.rs:156:pub struct ItemState {
src/components/unified_list_item/types.rs:158:    pub is_hovered: bool,
file update:
diff --git a/src/list_item/part_000.rs b/src/list_item/part_000.rs
index 733d4ac2aa5b1b27b29a5999310e6f3f45cc54c3..283b2263d56a92c73c22d44443db7b40971d26ce
--- a/src/list_item/part_000.rs
+++ b/src/list_item/part_000.rs
@@ -15,6 +15,37 @@
     /// Maps to IconName from designs::icon_variations
     Svg(String),
 }
+
+impl IconKind {
+    /// Resolve icon metadata into an IconKind for list rendering.
+    ///
+    /// Supports:
+    /// - Known SVG names/aliases via `icon_name_from_str` (e.g., "Terminal", "file-code")
+    /// - Emoji/symbol glyphs (e.g., "üìÑ", "‚ö°")
+    pub fn from_icon_hint(icon_hint: &str) -> Option<Self> {
+        let trimmed = icon_hint.trim();
+        if trimmed.is_empty() {
+            return None;
+        }
+
+        if icon_name_from_str(trimmed).is_some() {
+            return Some(Self::Svg(trimmed.to_string()));
+        }
+
+        if looks_like_symbol_icon_hint(trimmed) {
+            return Some(Self::Emoji(trimmed.to_string()));
+        }
+
+        None
+    }
+}
+
+fn looks_like_symbol_icon_hint(icon_hint: &str) -> bool {
+    let has_ascii_alnum = icon_hint.chars().any(|ch| ch.is_ascii_alphanumeric());
+    let char_count = icon_hint.chars().count();
+
+    !has_ascii_alnum && char_count <= 4
+}
 /// Fixed height for list items used in uniform-height virtualized lists.
 ///
 /// IMPORTANT: When using GPUI `uniform_list`, the item closure must render
@@ -437,3 +468,29 @@
     /// Text color for content displayed on accent/warning backgrounds
     pub text_on_accent: u32,
 }
+
+#[cfg(test)]
+mod icon_kind_tests {
+    use super::IconKind;
+
+    #[test]
+    fn test_icon_kind_from_icon_hint_returns_svg_when_known_icon_name() {
+        match IconKind::from_icon_hint("terminal") {
+            Some(IconKind::Svg(name)) => assert_eq!(name, "terminal"),
+            _ => panic!("expected SVG icon from known icon hint"),
+        }
+    }
+
+    #[test]
+    fn test_icon_kind_from_icon_hint_returns_emoji_when_symbol_glyph() {
+        match IconKind::from_icon_hint("üìÑ") {
+            Some(IconKind::Emoji(emoji)) => assert_eq!(emoji, "üìÑ"),
+            _ => panic!("expected emoji icon for symbol glyph"),
+        }
+    }
+
+    #[test]
+    fn test_icon_kind_from_icon_hint_returns_none_for_unknown_ascii_word() {
+        assert!(IconKind::from_icon_hint("unknown-icon-name").is_none());
+    }
+}
diff --git a/src/prompts/select/mod.rs b/src/prompts/select/mod.rs
index b6366dabfb14f3fae09f854f9de824fa629e0a3b..32ec6dd9fa7ee4b5d29009f3cc5a665713f97a10
--- a/src/prompts/select/mod.rs
+++ b/src/prompts/select/mod.rs
@@ -19,7 +19,7 @@
     UnifiedListItemColors,
 };
 use crate::designs::{get_tokens, DesignColors, DesignVariant};
-use crate::list_item::LIST_ITEM_HEIGHT;
+use crate::list_item::{IconKind, LIST_ITEM_HEIGHT};
 use crate::logging;
 use crate::panel::PROMPT_INPUT_FIELD_HEIGHT;
 use crate::protocol::{generate_semantic_id, Choice};
@@ -37,5 +37,5 @@
 mod types;
 
 pub use prompt::SelectPrompt;
-use search::*;
-use types::*;
+pub(super) use search::*;
+pub(super) use types::*;
diff --git a/src/prompts/select/prompt.rs b/src/prompts/select/prompt.rs
index c5f98f5318f5b520e9223811f735e866ee06e7fb..5ba2de479b2f5680a73db72642377f68d26ee54e
--- a/src/prompts/select/prompt.rs
+++ b/src/prompts/select/prompt.rs
@@ -19,6 +19,8 @@
     pub filtered_choices: Vec<usize>,
     /// Currently focused index in filtered list
     pub focused_index: usize,
+    /// Currently hovered index in filtered list
+    pub hovered_index: Option<usize>,
     /// Filter text
     pub filter_text: String,
     /// Whether multiple selection is allowed
@@ -68,6 +70,7 @@
             selected: HashSet::new(),
             filtered_choices,
             focused_index: 0,
+            hovered_index: None,
             filter_text: String::new(),
             multiple,
             focus_handle,
@@ -84,6 +87,7 @@
         if trimmed_filter.is_empty() {
             self.filtered_choices = (0..self.choices.len()).collect();
             self.focused_index = 0;
+            self.hovered_index = None;
             return;
         }
 
@@ -109,6 +113,7 @@
 
         self.filtered_choices = scored_matches.into_iter().map(|(idx, _)| idx).collect();
         self.focused_index = 0;
+        self.hovered_index = None;
     }
 
     /// Set the filter text programmatically
@@ -168,6 +173,7 @@
     pub(super) fn move_up(&mut self, cx: &mut Context<Self>) {
         if self.focused_index > 0 {
             self.focused_index -= 1;
+            self.hovered_index = None;
             self.list_scroll_handle
                 .scroll_to_item(self.focused_index, ScrollStrategy::Nearest);
             cx.notify();
@@ -178,6 +184,7 @@
     pub(super) fn move_down(&mut self, cx: &mut Context<Self>) {
         if self.focused_index < self.filtered_choices.len().saturating_sub(1) {
             self.focused_index += 1;
+            self.hovered_index = None;
             self.list_scroll_handle
                 .scroll_to_item(self.focused_index, ScrollStrategy::Nearest);
             cx.notify();
diff --git a/src/prompts/select/render.rs b/src/prompts/select/render.rs
index 62109896c9c14b1b2fbf5b4d25d5d94e4388e4aa..8c67aba367edf1587ee80ac17707f23ad35c2ce1
--- a/src/prompts/select/render.rs
+++ b/src/prompts/select/render.rs
@@ -1,5 +1,57 @@
 use super::*;
 
+const ROW_FOCUSED_BG_ALPHA: u32 = 0x3A;
+const ROW_HOVER_BG_ALPHA: u32 = 0x26;
+
+fn extract_choice_icon_hint(description: Option<&str>) -> Option<&str> {
+    description.and_then(|raw| {
+        raw.split(['‚Ä¢', '|', '\n'])
+            .map(str::trim)
+            .find_map(|token| {
+                let token_lower = token.to_ascii_lowercase();
+                if token_lower == "icon"
+                    || token_lower.starts_with("icon:")
+                    || token_lower.starts_with("icon=")
+                    || token_lower.starts_with("icon ")
+                {
+                    token
+                        .split_once(':')
+                        .or_else(|| token.split_once('='))
+                        .map(|(_, value)| value.trim())
+                        .or_else(|| token.split_whitespace().nth(1))
+                } else {
+                    None
+                }
+            })
+            .filter(|value| !value.is_empty())
+    })
+}
+
+fn icon_kind_from_choice(choice: &Choice) -> IconKind {
+    let metadata_icon = extract_choice_icon_hint(choice.description.as_deref())
+        .and_then(IconKind::from_icon_hint);
+    let name_prefix_icon = choice
+        .name
+        .split_whitespace()
+        .next()
+        .and_then(IconKind::from_icon_hint);
+
+    metadata_icon
+        .or(name_prefix_icon)
+        .unwrap_or_else(|| IconKind::Svg("Code".to_string()))
+}
+
+fn leading_content_from_icon_kind(icon_kind: IconKind) -> LeadingContent {
+    match icon_kind {
+        IconKind::Emoji(emoji) => LeadingContent::Emoji(emoji.into()),
+        IconKind::Image(render_image) => LeadingContent::AppIcon(render_image),
+        IconKind::Svg(name) => LeadingContent::Icon {
+            name: SharedString::from(name),
+            color: None,
+        },
+    }
+}
+
 impl Focusable for SelectPrompt {
     fn focus_handle(&self, _cx: &gpui::App) -> FocusHandle {
         self.focus_handle.clone()
@@ -76,6 +128,13 @@
             self.design_variant,
             &colors,
         ));
+        let row_accent_color = if self.design_variant == DesignVariant::Default {
+            self.theme.colors.accent.selected
+        } else {
+            colors.accent
+        };
+        let focused_row_bg = rgba((row_accent_color << 8) | ROW_FOCUSED_BG_ALPHA);
+        let hovered_row_bg = rgba((row_accent_color << 8) | ROW_HOVER_BG_ALPHA);
 
         let placeholder = self
             .placeholder
@@ -145,8 +204,12 @@
                     move |this: &mut SelectPrompt,
                           visible_range: std::ops::Range<usize>,
                           _window,
-                          _cx| {
-                        let row_colors = UnifiedListItemColors::from_theme(&this.theme);
+                          cx| {
+                        let item_colors = UnifiedListItemColors {
+                            selected_opacity: 0.0,
+                            hover_opacity: 0.0,
+                            ..UnifiedListItemColors::from_theme(&this.theme)
+                        };
                         let mut rows = Vec::with_capacity(visible_range.len());
 
                         for display_idx in visible_range {
@@ -156,19 +219,21 @@
                                     {
                                         let is_focused = display_idx == this.focused_index;
                                         let is_selected = this.selected.contains(&choice_idx);
-                                        let is_selected_for_ui = if this.multiple {
-                                            is_selected
-                                        } else {
-                                            is_focused
-                                        };
+                                        let is_hovered = this.hovered_index == Some(display_idx);
                                         let semantic_id =
                                             choice.semantic_id.clone().unwrap_or_else(|| {
                                                 indexed_choice.stable_semantic_id.clone()
                                             });
-                                        let indicator = choice_selection_indicator(
-                                            this.multiple,
-                                            is_selected_for_ui,
-                                        );
+                                        let leading = if this.multiple {
+                                            Some(LeadingContent::Emoji(
+                                                choice_selection_indicator(true, is_selected)
+                                                    .into(),
+                                            ))
+                                        } else {
+                                            Some(leading_content_from_icon_kind(
+                                                icon_kind_from_choice(choice),
+                                            ))
+                                        };
                                         let subtitle = indexed_choice
                                             .metadata
                                             .subtitle_text()
@@ -185,34 +250,61 @@
                                                     ))
                                                 },
                                             );
+                                        let row_bg = if is_focused {
+                                            focused_row_bg
+                                        } else if is_hovered {
+                                            hovered_row_bg
+                                        } else {
+                                            rgba(0x00000000)
+                                        };
+                                        let hover_handler = cx.listener(
+                                            move |this: &mut SelectPrompt,
+                                                  hovered: &bool,
+                                                  _window,
+                                                  cx| {
+                                                if *hovered {
+                                                    if this.hovered_index != Some(display_idx) {
+                                                        this.hovered_index = Some(display_idx);
+                                                        cx.notify();
+                                                    }
+                                                } else if this.hovered_index == Some(display_idx)
+                                                {
+                                                    this.hovered_index = None;
+                                                    cx.notify();
+                                                }
+                                            },
+                                        );
+
+                                        let mut row = div()
+                                            .id(display_idx)
+                                            .w_full()
+                                            .h(px(LIST_ITEM_HEIGHT))
+                                            .rounded(px(8.0))
+                                            .bg(row_bg)
+                                            .cursor_pointer()
+                                            .on_hover(hover_handler)
+                                            .child(
+                                                UnifiedListItem::new(
+                                                    gpui::ElementId::Name(semantic_id.into()),
+                                                    title,
+                                                )
+                                                .subtitle_opt(subtitle)
+                                                .leading_opt(leading)
+                                                .trailing_opt(trailing)
+                                                .state(ItemState {
+                                                    is_selected,
+                                                    is_hovered,
+                                                    is_disabled: false,
+                                                })
+                                                .density(Density::Comfortable)
+                                                .colors(item_colors),
+                                            );
 
-                                        rows.push(
-                                            div()
-                                                .id(display_idx)
-                                                .w_full()
-                                                .h(px(LIST_ITEM_HEIGHT))
-                                                .border_b_1()
-                                                .border_color(border_color)
-                                                .child(
-                                                    UnifiedListItem::new(
-                                                        gpui::ElementId::Name(semantic_id.into()),
-                                                        title,
-                                                    )
-                                                    .subtitle_opt(subtitle)
-                                                    .leading(LeadingContent::Emoji(
-                                                        indicator.into(),
-                                                    ))
-                                                    .trailing_opt(trailing)
-                                                    .state(ItemState {
-                                                        is_selected: is_focused,
-                                                        is_hovered: false,
-                                                        is_disabled: false,
-                                                    })
-                                                    .density(Density::Comfortable)
-                                                    .colors(row_colors)
-                                                    .with_accent_bar(is_selected_for_ui),
-                                                ),
-                                        );
+                                        if !is_focused {
+                                            row = row.hover(move |s| s.bg(hovered_row_bg));
+                                        }
+
+                                        rows.push(row);
                                     }
                                 }
                             }
@@ -234,6 +326,7 @@
             .flex_col()
             .flex_1()
             .w_full()
+            .px(px(8.0))
             .child(choices_content);
 
         div()


thinking
**Reviewing selection indicator usage**
exec
/bin/zsh -lc "cd /Users/johnlindquist/dev/script-kit-gpui && rg -n \"choice_selection_indicator\\(\" src/prompts/select/render.rs" in /Users/johnlindquist/dev/script-kit-gpui succeeded in 51ms:
229:                                                choice_selection_indicator(true, is_selected)
file update:
diff --git a/src/list_item/part_000.rs b/src/list_item/part_000.rs
index 733d4ac2aa5b1b27b29a5999310e6f3f45cc54c3..283b2263d56a92c73c22d44443db7b40971d26ce
--- a/src/list_item/part_000.rs
+++ b/src/list_item/part_000.rs
@@ -15,6 +15,37 @@
     /// Maps to IconName from designs::icon_variations
     Svg(String),
 }
+
+impl IconKind {
+    /// Resolve icon metadata into an IconKind for list rendering.
+    ///
+    /// Supports:
+    /// - Known SVG names/aliases via `icon_name_from_str` (e.g., "Terminal", "file-code")
+    /// - Emoji/symbol glyphs (e.g., "üìÑ", "‚ö°")
+    pub fn from_icon_hint(icon_hint: &str) -> Option<Self> {
+        let trimmed = icon_hint.trim();
+        if trimmed.is_empty() {
+            return None;
+        }
+
+        if icon_name_from_str(trimmed).is_some() {
+            return Some(Self::Svg(trimmed.to_string()));
+        }
+
+        if looks_like_symbol_icon_hint(trimmed) {
+            return Some(Self::Emoji(trimmed.to_string()));
+        }
+
+        None
+    }
+}
+
+fn looks_like_symbol_icon_hint(icon_hint: &str) -> bool {
+    let has_ascii_alnum = icon_hint.chars().any(|ch| ch.is_ascii_alphanumeric());
+    let char_count = icon_hint.chars().count();
+
+    !has_ascii_alnum && char_count <= 4
+}
 /// Fixed height for list items used in uniform-height virtualized lists.
 ///
 /// IMPORTANT: When using GPUI `uniform_list`, the item closure must render
@@ -437,3 +468,29 @@
     /// Text color for content displayed on accent/warning backgrounds
     pub text_on_accent: u32,
 }
+
+#[cfg(test)]
+mod icon_kind_tests {
+    use super::IconKind;
+
+    #[test]
+    fn test_icon_kind_from_icon_hint_returns_svg_when_known_icon_name() {
+        match IconKind::from_icon_hint("terminal") {
+            Some(IconKind::Svg(name)) => assert_eq!(name, "terminal"),
+            _ => panic!("expected SVG icon from known icon hint"),
+        }
+    }
+
+    #[test]
+    fn test_icon_kind_from_icon_hint_returns_emoji_when_symbol_glyph() {
+        match IconKind::from_icon_hint("üìÑ") {
+            Some(IconKind::Emoji(emoji)) => assert_eq!(emoji, "üìÑ"),
+            _ => panic!("expected emoji icon for symbol glyph"),
+        }
+    }
+
+    #[test]
+    fn test_icon_kind_from_icon_hint_returns_none_for_unknown_ascii_word() {
+        assert!(IconKind::from_icon_hint("unknown-icon-name").is_none());
+    }
+}
diff --git a/src/prompts/select/mod.rs b/src/prompts/select/mod.rs
index b6366dabfb14f3fae09f854f9de824fa629e0a3b..32ec6dd9fa7ee4b5d29009f3cc5a665713f97a10
--- a/src/prompts/select/mod.rs
+++ b/src/prompts/select/mod.rs
@@ -19,7 +19,7 @@
     UnifiedListItemColors,
 };
 use crate::designs::{get_tokens, DesignColors, DesignVariant};
-use crate::list_item::LIST_ITEM_HEIGHT;
+use crate::list_item::{IconKind, LIST_ITEM_HEIGHT};
 use crate::logging;
 use crate::panel::PROMPT_INPUT_FIELD_HEIGHT;
 use crate::protocol::{generate_semantic_id, Choice};
@@ -37,5 +37,5 @@
 mod types;
 
 pub use prompt::SelectPrompt;
-use search::*;
-use types::*;
+pub(super) use search::*;
+pub(super) use types::*;
diff --git a/src/prompts/select/prompt.rs b/src/prompts/select/prompt.rs
index c5f98f5318f5b520e9223811f735e866ee06e7fb..5ba2de479b2f5680a73db72642377f68d26ee54e
--- a/src/prompts/select/prompt.rs
+++ b/src/prompts/select/prompt.rs
@@ -19,6 +19,8 @@
     pub filtered_choices: Vec<usize>,
     /// Currently focused index in filtered list
     pub focused_index: usize,
+    /// Currently hovered index in filtered list
+    pub hovered_index: Option<usize>,
     /// Filter text
     pub filter_text: String,
     /// Whether multiple selection is allowed
@@ -68,6 +70,7 @@
             selected: HashSet::new(),
             filtered_choices,
             focused_index: 0,
+            hovered_index: None,
             filter_text: String::new(),
             multiple,
             focus_handle,
@@ -84,6 +87,7 @@
         if trimmed_filter.is_empty() {
             self.filtered_choices = (0..self.choices.len()).collect();
             self.focused_index = 0;
+            self.hovered_index = None;
             return;
         }
 
@@ -109,6 +113,7 @@
 
         self.filtered_choices = scored_matches.into_iter().map(|(idx, _)| idx).collect();
         self.focused_index = 0;
+        self.hovered_index = None;
     }
 
     /// Set the filter text programmatically
@@ -168,6 +173,7 @@
     pub(super) fn move_up(&mut self, cx: &mut Context<Self>) {
         if self.focused_index > 0 {
             self.focused_index -= 1;
+            self.hovered_index = None;
             self.list_scroll_handle
                 .scroll_to_item(self.focused_index, ScrollStrategy::Nearest);
             cx.notify();
@@ -178,6 +184,7 @@
     pub(super) fn move_down(&mut self, cx: &mut Context<Self>) {
         if self.focused_index < self.filtered_choices.len().saturating_sub(1) {
             self.focused_index += 1;
+            self.hovered_index = None;
             self.list_scroll_handle
                 .scroll_to_item(self.focused_index, ScrollStrategy::Nearest);
             cx.notify();
diff --git a/src/prompts/select/render.rs b/src/prompts/select/render.rs
index 62109896c9c14b1b2fbf5b4d25d5d94e4388e4aa..8c67aba367edf1587ee80ac17707f23ad35c2ce1
--- a/src/prompts/select/render.rs
+++ b/src/prompts/select/render.rs
@@ -1,5 +1,57 @@
 use super::*;
 
+const ROW_FOCUSED_BG_ALPHA: u32 = 0x3A;
+const ROW_HOVER_BG_ALPHA: u32 = 0x26;
+
+fn extract_choice_icon_hint(description: Option<&str>) -> Option<&str> {
+    description.and_then(|raw| {
+        raw.split(['‚Ä¢', '|', '\n'])
+            .map(str::trim)
+            .find_map(|token| {
+                let token_lower = token.to_ascii_lowercase();
+                if token_lower == "icon"
+                    || token_lower.starts_with("icon:")
+                    || token_lower.starts_with("icon=")
+                    || token_lower.starts_with("icon ")
+                {
+                    token
+                        .split_once(':')
+                        .or_else(|| token.split_once('='))
+                        .map(|(_, value)| value.trim())
+                        .or_else(|| token.split_whitespace().nth(1))
+                } else {
+                    None
+                }
+            })
+            .filter(|value| !value.is_empty())
+    })
+}
+
+fn icon_kind_from_choice(choice: &Choice) -> IconKind {
+    let metadata_icon = extract_choice_icon_hint(choice.description.as_deref())
+        .and_then(IconKind::from_icon_hint);
+    let name_prefix_icon = choice
+        .name
+        .split_whitespace()
+        .next()
+        .and_then(IconKind::from_icon_hint);
+
+    metadata_icon
+        .or(name_prefix_icon)
+        .unwrap_or_else(|| IconKind::Svg("Code".to_string()))
+}
+
+fn leading_content_from_icon_kind(icon_kind: IconKind) -> LeadingContent {
+    match icon_kind {
+        IconKind::Emoji(emoji) => LeadingContent::Emoji(emoji.into()),
+        IconKind::Image(render_image) => LeadingContent::AppIcon(render_image),
+        IconKind::Svg(name) => LeadingContent::Icon {
+            name: SharedString::from(name),
+            color: None,
+        },
+    }
+}
+
 impl Focusable for SelectPrompt {
     fn focus_handle(&self, _cx: &gpui::App) -> FocusHandle {
         self.focus_handle.clone()
@@ -76,6 +128,13 @@
             self.design_variant,
             &colors,
         ));
+        let row_accent_color = if self.design_variant == DesignVariant::Default {
+            self.theme.colors.accent.selected
+        } else {
+            colors.accent
+        };
+        let focused_row_bg = rgba((row_accent_color << 8) | ROW_FOCUSED_BG_ALPHA);
+        let hovered_row_bg = rgba((row_accent_color << 8) | ROW_HOVER_BG_ALPHA);
 
         let placeholder = self
             .placeholder
@@ -145,8 +204,12 @@
                     move |this: &mut SelectPrompt,
                           visible_range: std::ops::Range<usize>,
                           _window,
-                          _cx| {
-                        let row_colors = UnifiedListItemColors::from_theme(&this.theme);
+                          cx| {
+                        let item_colors = UnifiedListItemColors {
+                            selected_opacity: 0.0,
+                            hover_opacity: 0.0,
+                            ..UnifiedListItemColors::from_theme(&this.theme)
+                        };
                         let mut rows = Vec::with_capacity(visible_range.len());
 
                         for display_idx in visible_range {
@@ -156,19 +219,21 @@
                                     {
                                         let is_focused = display_idx == this.focused_index;
                                         let is_selected = this.selected.contains(&choice_idx);
-                                        let is_selected_for_ui = if this.multiple {
-                                            is_selected
-                                        } else {
-                                            is_focused
-                                        };
+                                        let is_hovered = this.hovered_index == Some(display_idx);
                                         let semantic_id =
                                             choice.semantic_id.clone().unwrap_or_else(|| {
                                                 indexed_choice.stable_semantic_id.clone()
                                             });
-                                        let indicator = choice_selection_indicator(
-                                            this.multiple,
-                                            is_selected_for_ui,
-                                        );
+                                        let leading = if this.multiple {
+                                            Some(LeadingContent::Emoji(
+                                                choice_selection_indicator(true, is_selected)
+                                                    .into(),
+                                            ))
+                                        } else {
+                                            Some(leading_content_from_icon_kind(
+                                                icon_kind_from_choice(choice),
+                                            ))
+                                        };
                                         let subtitle = indexed_choice
                                             .metadata
                                             .subtitle_text()
@@ -185,34 +250,61 @@
                                                     ))
                                                 },
                                             );
+                                        let row_bg = if is_focused {
+                                            focused_row_bg
+                                        } else if is_hovered {
+                                            hovered_row_bg
+                                        } else {
+                                            rgba(0x00000000)
+                                        };
+                                        let hover_handler = cx.listener(
+                                            move |this: &mut SelectPrompt,
+                                                  hovered: &bool,
+                                                  _window,
+                                                  cx| {
+                                                if *hovered {
+                                                    if this.hovered_index != Some(display_idx) {
+                                                        this.hovered_index = Some(display_idx);
+                                                        cx.notify();
+                                                    }
+                                                } else if this.hovered_index == Some(display_idx)
+                                                {
+                                                    this.hovered_index = None;
+                                                    cx.notify();
+                                                }
+                                            },
+                                        );
+
+                                        let mut row = div()
+                                            .id(display_idx)
+                                            .w_full()
+                                            .h(px(LIST_ITEM_HEIGHT))
+                                            .rounded(px(8.0))
+                                            .bg(row_bg)
+                                            .cursor_pointer()
+                                            .on_hover(hover_handler)
+                                            .child(
+                                                UnifiedListItem::new(
+                                                    gpui::ElementId::Name(semantic_id.into()),
+                                                    title,
+                                                )
+                                                .subtitle_opt(subtitle)
+                                                .leading_opt(leading)
+                                                .trailing_opt(trailing)
+                                                .state(ItemState {
+                                                    is_selected,
+                                                    is_hovered,
+                                                    is_disabled: false,
+                                                })
+                                                .density(Density::Comfortable)
+                                                .colors(item_colors),
+                                            );
 
-                                        rows.push(
-                                            div()
-                                                .id(display_idx)
-                                                .w_full()
-                                                .h(px(LIST_ITEM_HEIGHT))
-                                                .border_b_1()
-                                                .border_color(border_color)
-                                                .child(
-                                                    UnifiedListItem::new(
-                                                        gpui::ElementId::Name(semantic_id.into()),
-                                                        title,
-                                                    )
-                                                    .subtitle_opt(subtitle)
-                                                    .leading(LeadingContent::Emoji(
-                                                        indicator.into(),
-                                                    ))
-                                                    .trailing_opt(trailing)
-                                                    .state(ItemState {
-                                                        is_selected: is_focused,
-                                                        is_hovered: false,
-                                                        is_disabled: false,
-                                                    })
-                                                    .density(Density::Comfortable)
-                                                    .colors(row_colors)
-                                                    .with_accent_bar(is_selected_for_ui),
-                                                ),
-                                        );
+                                        if !is_focused {
+                                            row = row.hover(move |s| s.bg(hovered_row_bg));
+                                        }
+
+                                        rows.push(row);
                                     }
                                 }
                             }
@@ -234,6 +326,7 @@
             .flex_col()
             .flex_1()
             .w_full()
+            .px(px(8.0))
             .child(choices_content);
 
         div()


thinking
**Verifying import and compile status**
exec
/bin/zsh -lc 'cd /Users/johnlindquist/dev/script-kit-gpui && rg -n "''^'"\\s*#\\[test\\]|fn test_\" src/prompts/select/tests.rs src/list_item/part_000.rs" in /Users/johnlindquist/dev/script-kit-gpui succeeded in 51ms:
src/list_item/part_000.rs:476:    #[test]
src/list_item/part_000.rs:477:    fn test_icon_kind_from_icon_hint_returns_svg_when_known_icon_name() {
src/list_item/part_000.rs:484:    #[test]
src/list_item/part_000.rs:485:    fn test_icon_kind_from_icon_hint_returns_emoji_when_symbol_glyph() {
src/list_item/part_000.rs:492:    #[test]
src/list_item/part_000.rs:493:    fn test_icon_kind_from_icon_hint_returns_none_for_unknown_ascii_word() {
src/prompts/select/tests.rs:9:#[test]
src/prompts/select/tests.rs:25:#[test]
src/prompts/select/tests.rs:53:#[test]
src/prompts/select/tests.rs:84:#[test]
src/prompts/select/tests.rs:92:#[test]
src/prompts/select/tests.rs:93:fn test_select_prompt_accepts_space_and_rejects_control_chars_in_filter_query() {
src/prompts/select/tests.rs:100:#[test]
src/prompts/select/tests.rs:101:fn test_select_prompt_submit_uses_focused_item_in_single_mode_when_none_toggled() {
src/prompts/select/tests.rs:107:#[test]
src/prompts/select/tests.rs:108:fn test_select_prompt_submit_prefers_focused_item_in_single_mode_when_selection_exists() {
src/prompts/select/tests.rs:114:#[test]
src/prompts/select/tests.rs:115:fn test_select_prompt_submit_uses_explicit_selection_in_multiple_mode() {
src/prompts/select/tests.rs:121:#[test]
src/prompts/select/tests.rs:122:fn test_select_prompt_cmd_a_toggles_only_when_all_filtered_items_are_selected() {
file update:
diff --git a/src/list_item/part_000.rs b/src/list_item/part_000.rs
index 733d4ac2aa5b1b27b29a5999310e6f3f45cc54c3..283b2263d56a92c73c22d44443db7b40971d26ce
--- a/src/list_item/part_000.rs
+++ b/src/list_item/part_000.rs
@@ -15,6 +15,37 @@
     /// Maps to IconName from designs::icon_variations
     Svg(String),
 }
+
+impl IconKind {
+    /// Resolve icon metadata into an IconKind for list rendering.
+    ///
+    /// Supports:
+    /// - Known SVG names/aliases via `icon_name_from_str` (e.g., "Terminal", "file-code")
+    /// - Emoji/symbol glyphs (e.g., "üìÑ", "‚ö°")
+    pub fn from_icon_hint(icon_hint: &str) -> Option<Self> {
+        let trimmed = icon_hint.trim();
+        if trimmed.is_empty() {
+            return None;
+        }
+
+        if icon_name_from_str(trimmed).is_some() {
+            return Some(Self::Svg(trimmed.to_string()));
+        }
+
+        if looks_like_symbol_icon_hint(trimmed) {
+            return Some(Self::Emoji(trimmed.to_string()));
+        }
+
+        None
+    }
+}
+
+fn looks_like_symbol_icon_hint(icon_hint: &str) -> bool {
+    let has_ascii_alnum = icon_hint.chars().any(|ch| ch.is_ascii_alphanumeric());
+    let char_count = icon_hint.chars().count();
+
+    !has_ascii_alnum && char_count <= 4
+}
 /// Fixed height for list items used in uniform-height virtualized lists.
 ///
 /// IMPORTANT: When using GPUI `uniform_list`, the item closure must render
@@ -437,3 +468,29 @@
     /// Text color for content displayed on accent/warning backgrounds
     pub text_on_accent: u32,
 }
+
+#[cfg(test)]
+mod icon_kind_tests {
+    use super::IconKind;
+
+    #[test]
+    fn test_icon_kind_from_icon_hint_returns_svg_when_known_icon_name() {
+        match IconKind::from_icon_hint("terminal") {
+            Some(IconKind::Svg(name)) => assert_eq!(name, "terminal"),
+            _ => panic!("expected SVG icon from known icon hint"),
+        }
+    }
+
+    #[test]
+    fn test_icon_kind_from_icon_hint_returns_emoji_when_symbol_glyph() {
+        match IconKind::from_icon_hint("üìÑ") {
+            Some(IconKind::Emoji(emoji)) => assert_eq!(emoji, "üìÑ"),
+            _ => panic!("expected emoji icon for symbol glyph"),
+        }
+    }
+
+    #[test]
+    fn test_icon_kind_from_icon_hint_returns_none_for_unknown_ascii_word() {
+        assert!(IconKind::from_icon_hint("unknown-icon-name").is_none());
+    }
+}
diff --git a/src/prompts/select/mod.rs b/src/prompts/select/mod.rs
index b6366dabfb14f3fae09f854f9de824fa629e0a3b..32ec6dd9fa7ee4b5d29009f3cc5a665713f97a10
--- a/src/prompts/select/mod.rs
+++ b/src/prompts/select/mod.rs
@@ -19,7 +19,7 @@
     UnifiedListItemColors,
 };
 use crate::designs::{get_tokens, DesignColors, DesignVariant};
-use crate::list_item::LIST_ITEM_HEIGHT;
+use crate::list_item::{IconKind, LIST_ITEM_HEIGHT};
 use crate::logging;
 use crate::panel::PROMPT_INPUT_FIELD_HEIGHT;
 use crate::protocol::{generate_semantic_id, Choice};
@@ -37,5 +37,5 @@
 mod types;
 
 pub use prompt::SelectPrompt;
-use search::*;
-use types::*;
+pub(super) use search::*;
+pub(super) use types::*;
diff --git a/src/prompts/select/prompt.rs b/src/prompts/select/prompt.rs
index c5f98f5318f5b520e9223811f735e866ee06e7fb..5ba2de479b2f5680a73db72642377f68d26ee54e
--- a/src/prompts/select/prompt.rs
+++ b/src/prompts/select/prompt.rs
@@ -19,6 +19,8 @@
     pub filtered_choices: Vec<usize>,
     /// Currently focused index in filtered list
     pub focused_index: usize,
+    /// Currently hovered index in filtered list
+    pub hovered_index: Option<usize>,
     /// Filter text
     pub filter_text: String,
     /// Whether multiple selection is allowed
@@ -68,6 +70,7 @@
             selected: HashSet::new(),
             filtered_choices,
             focused_index: 0,
+            hovered_index: None,
             filter_text: String::new(),
             multiple,
             focus_handle,
@@ -84,6 +87,7 @@
         if trimmed_filter.is_empty() {
             self.filtered_choices = (0..self.choices.len()).collect();
             self.focused_index = 0;
+            self.hovered_index = None;
             return;
         }
 
@@ -109,6 +113,7 @@
 
         self.filtered_choices = scored_matches.into_iter().map(|(idx, _)| idx).collect();
         self.focused_index = 0;
+        self.hovered_index = None;
     }
 
     /// Set the filter text programmatically
@@ -168,6 +173,7 @@
     pub(super) fn move_up(&mut self, cx: &mut Context<Self>) {
         if self.focused_index > 0 {
             self.focused_index -= 1;
+            self.hovered_index = None;
             self.list_scroll_handle
                 .scroll_to_item(self.focused_index, ScrollStrategy::Nearest);
             cx.notify();
@@ -178,6 +184,7 @@
     pub(super) fn move_down(&mut self, cx: &mut Context<Self>) {
         if self.focused_index < self.filtered_choices.len().saturating_sub(1) {
             self.focused_index += 1;
+            self.hovered_index = None;
             self.list_scroll_handle
                 .scroll_to_item(self.focused_index, ScrollStrategy::Nearest);
             cx.notify();
diff --git a/src/prompts/select/render.rs b/src/prompts/select/render.rs
index 62109896c9c14b1b2fbf5b4d25d5d94e4388e4aa..8c67aba367edf1587ee80ac17707f23ad35c2ce1
--- a/src/prompts/select/render.rs
+++ b/src/prompts/select/render.rs
@@ -1,5 +1,57 @@
 use super::*;
 
+const ROW_FOCUSED_BG_ALPHA: u32 = 0x3A;
+const ROW_HOVER_BG_ALPHA: u32 = 0x26;
+
+fn extract_choice_icon_hint(description: Option<&str>) -> Option<&str> {
+    description.and_then(|raw| {
+        raw.split(['‚Ä¢', '|', '\n'])
+            .map(str::trim)
+            .find_map(|token| {
+                let token_lower = token.to_ascii_lowercase();
+                if token_lower == "icon"
+                    || token_lower.starts_with("icon:")
+                    || token_lower.starts_with("icon=")
+                    || token_lower.starts_with("icon ")
+                {
+                    token
+                        .split_once(':')
+                        .or_else(|| token.split_once('='))
+                        .map(|(_, value)| value.trim())
+                        .or_else(|| token.split_whitespace().nth(1))
+                } else {
+                    None
+                }
+            })
+            .filter(|value| !value.is_empty())
+    })
+}
+
+fn icon_kind_from_choice(choice: &Choice) -> IconKind {
+    let metadata_icon = extract_choice_icon_hint(choice.description.as_deref())
+        .and_then(IconKind::from_icon_hint);
+    let name_prefix_icon = choice
+        .name
+        .split_whitespace()
+        .next()
+        .and_then(IconKind::from_icon_hint);
+
+    metadata_icon
+        .or(name_prefix_icon)
+        .unwrap_or_else(|| IconKind::Svg("Code".to_string()))
+}
+
+fn leading_content_from_icon_kind(icon_kind: IconKind) -> LeadingContent {
+    match icon_kind {
+        IconKind::Emoji(emoji) => LeadingContent::Emoji(emoji.into()),
+        IconKind::Image(render_image) => LeadingContent::AppIcon(render_image),
+        IconKind::Svg(name) => LeadingContent::Icon {
+            name: SharedString::from(name),
+            color: None,
+        },
+    }
+}
+
 impl Focusable for SelectPrompt {
     fn focus_handle(&self, _cx: &gpui::App) -> FocusHandle {
         self.focus_handle.clone()
@@ -76,6 +128,13 @@
             self.design_variant,
             &colors,
         ));
+        let row_accent_color = if self.design_variant == DesignVariant::Default {
+            self.theme.colors.accent.selected
+        } else {
+            colors.accent
+        };
+        let focused_row_bg = rgba((row_accent_color << 8) | ROW_FOCUSED_BG_ALPHA);
+        let hovered_row_bg = rgba((row_accent_color << 8) | ROW_HOVER_BG_ALPHA);
 
         let placeholder = self
             .placeholder
@@ -145,8 +204,12 @@
                     move |this: &mut SelectPrompt,
                           visible_range: std::ops::Range<usize>,
                           _window,
-                          _cx| {
-                        let row_colors = UnifiedListItemColors::from_theme(&this.theme);
+                          cx| {
+                        let item_colors = UnifiedListItemColors {
+                            selected_opacity: 0.0,
+                            hover_opacity: 0.0,
+                            ..UnifiedListItemColors::from_theme(&this.theme)
+                        };
                         let mut rows = Vec::with_capacity(visible_range.len());
 
                         for display_idx in visible_range {
@@ -156,19 +219,21 @@
                                     {
                                         let is_focused = display_idx == this.focused_index;
                                         let is_selected = this.selected.contains(&choice_idx);
-                                        let is_selected_for_ui = if this.multiple {
-                                            is_selected
-                                        } else {
-                                            is_focused
-                                        };
+                                        let is_hovered = this.hovered_index == Some(display_idx);
                                         let semantic_id =
                                             choice.semantic_id.clone().unwrap_or_else(|| {
                                                 indexed_choice.stable_semantic_id.clone()
                                             });
-                                        let indicator = choice_selection_indicator(
-                                            this.multiple,
-                                            is_selected_for_ui,
-                                        );
+                                        let leading = if this.multiple {
+                                            Some(LeadingContent::Emoji(
+                                                choice_selection_indicator(true, is_selected)
+                                                    .into(),
+                                            ))
+                                        } else {
+                                            Some(leading_content_from_icon_kind(
+                                                icon_kind_from_choice(choice),
+                                            ))
+                                        };
                                         let subtitle = indexed_choice
                                             .metadata
                                             .subtitle_text()
@@ -185,34 +250,61 @@
                                                     ))
                                                 },
                                             );
+                                        let row_bg = if is_focused {
+                                            focused_row_bg
+                                        } else if is_hovered {
+                                            hovered_row_bg
+                                        } else {
+                                            rgba(0x00000000)
+                                        };
+                                        let hover_handler = cx.listener(
+                                            move |this: &mut SelectPrompt,
+                                                  hovered: &bool,
+                                                  _window,
+                                                  cx| {
+                                                if *hovered {
+                                                    if this.hovered_index != Some(display_idx) {
+                                                        this.hovered_index = Some(display_idx);
+                                                        cx.notify();
+                                                    }
+                                                } else if this.hovered_index == Some(display_idx)
+                                                {
+                                                    this.hovered_index = None;
+                                                    cx.notify();
+                                                }
+                                            },
+                                        );
+
+                                        let mut row = div()
+                                            .id(display_idx)
+                                            .w_full()
+                                            .h(px(LIST_ITEM_HEIGHT))
+                                            .rounded(px(8.0))
+                                            .bg(row_bg)
+                                            .cursor_pointer()
+                                            .on_hover(hover_handler)
+                                            .child(
+                                                UnifiedListItem::new(
+                                                    gpui::ElementId::Name(semantic_id.into()),
+                                                    title,
+                                                )
+                                                .subtitle_opt(subtitle)
+                                                .leading_opt(leading)
+                                                .trailing_opt(trailing)
+                                                .state(ItemState {
+                                                    is_selected,
+                                                    is_hovered,
+                                                    is_disabled: false,
+                                                })
+                                                .density(Density::Comfortable)
+                                                .colors(item_colors),
+                                            );
 
-                                        rows.push(
-                                            div()
-                                                .id(display_idx)
-                                                .w_full()
-                                                .h(px(LIST_ITEM_HEIGHT))
-                                                .border_b_1()
-                                                .border_color(border_color)
-                                                .child(
-                                                    UnifiedListItem::new(
-                                                        gpui::ElementId::Name(semantic_id.into()),
-                                                        title,
-                                                    )
-                                                    .subtitle_opt(subtitle)
-                                                    .leading(LeadingContent::Emoji(
-                                                        indicator.into(),
-                                                    ))
-                                                    .trailing_opt(trailing)
-                                                    .state(ItemState {
-                                                        is_selected: is_focused,
-                                                        is_hovered: false,
-                                                        is_disabled: false,
-                                                    })
-                                                    .density(Density::Comfortable)
-                                                    .colors(row_colors)
-                                                    .with_accent_bar(is_selected_for_ui),
-                                                ),
-                                        );
+                                        if !is_focused {
+                                            row = row.hover(move |s| s.bg(hovered_row_bg));
+                                        }
+
+                                        rows.push(row);
                                     }
                                 }
                             }
@@ -234,6 +326,7 @@
             .flex_col()
             .flex_1()
             .w_full()
+            .px(px(8.0))
             .child(choices_content);
 
         div()


thinking
**Evaluating test additions for behavior changes**
exec
/bin/zsh -lc "cd /Users/johnlindquist/dev/script-kit-gpui && sed -n '1,260p' src/prompts/select/tests.rs" in /Users/johnlindquist/dev/script-kit-gpui succeeded in 52ms:
use super::*;

fn choice(name: &str, value: &str, description: Option<&str>) -> Choice {
    let mut choice = Choice::new(name.to_string(), value.to_string());
    choice.description = description.map(str::to_string);
    choice
}

#[test]
fn metadata_parses_shortcut_type_and_last_run() {
    let choice = choice(
        "Deploy API",
        "/Users/me/.scriptkit/scripts/deploy.ts",
        Some("Shortcut: cmd+shift+d ‚Ä¢ script ‚Ä¢ Last run 2h ago"),
    );

    let metadata = ChoiceDisplayMetadata::from_choice(&choice);

    assert_eq!(metadata.shortcut.as_deref(), Some("‚åò‚áßD"));
    assert_eq!(metadata.item_type.as_deref(), Some("Script"));
file update:
diff --git a/src/list_item/part_000.rs b/src/list_item/part_000.rs
index 733d4ac2aa5b1b27b29a5999310e6f3f45cc54c3..283b2263d56a92c73c22d44443db7b40971d26ce
--- a/src/list_item/part_000.rs
+++ b/src/list_item/part_000.rs
@@ -15,6 +15,37 @@
     /// Maps to IconName from designs::icon_variations
     Svg(String),
 }
+
+impl IconKind {
+    /// Resolve icon metadata into an IconKind for list rendering.
+    ///
+    /// Supports:
+    /// - Known SVG names/aliases via `icon_name_from_str` (e.g., "Terminal", "file-code")
+    /// - Emoji/symbol glyphs (e.g., "üìÑ", "‚ö°")
+    pub fn from_icon_hint(icon_hint: &str) -> Option<Self> {
+        let trimmed = icon_hint.trim();
+        if trimmed.is_empty() {
+            return None;
+        }
+
+        if icon_name_from_str(trimmed).is_some() {
+            return Some(Self::Svg(trimmed.to_string()));
+        }
+
+        if looks_like_symbol_icon_hint(trimmed) {
+            return Some(Self::Emoji(trimmed.to_string()));
+        }
+
+        None
+    }
+}
+
+fn looks_like_symbol_icon_hint(icon_hint: &str) -> bool {
+    let has_ascii_alnum = icon_hint.chars().any(|ch| ch.is_ascii_alphanumeric());
+    let char_count = icon_hint.chars().count();
+
+    !has_ascii_alnum && char_count <= 4
+}
 /// Fixed height for list items used in uniform-height virtualized lists.
 ///
 /// IMPORTANT: When using GPUI `uniform_list`, the item closure must render
@@ -437,3 +468,29 @@
     /// Text color for content displayed on accent/warning backgrounds
     pub text_on_accent: u32,
 }
+
+#[cfg(test)]
+mod icon_kind_tests {
+    use super::IconKind;
+
+    #[test]
+    fn test_icon_kind_from_icon_hint_returns_svg_when_known_icon_name() {
+        match IconKind::from_icon_hint("terminal") {
+            Some(IconKind::Svg(name)) => assert_eq!(name, "terminal"),
+            _ => panic!("expected SVG icon from known icon hint"),
+        }
+    }
+
+    #[test]
+    fn test_icon_kind_from_icon_hint_returns_emoji_when_symbol_glyph() {
+        match IconKind::from_icon_hint("üìÑ") {
+            Some(IconKind::Emoji(emoji)) => assert_eq!(emoji, "üìÑ"),
+            _ => panic!("expected emoji icon for symbol glyph"),
+        }
+    }
+
+    #[test]
+    fn test_icon_kind_from_icon_hint_returns_none_for_unknown_ascii_word() {
+        assert!(IconKind::from_icon_hint("unknown-icon-name").is_none());
+    }
+}
diff --git a/src/prompts/select/mod.rs b/src/prompts/select/mod.rs
index b6366dabfb14f3fae09f854f9de824fa629e0a3b..32ec6dd9fa7ee4b5d29009f3cc5a665713f97a10
--- a/src/prompts/select/mod.rs
+++ b/src/prompts/select/mod.rs
@@ -19,7 +19,7 @@
     UnifiedListItemColors,
 };
 use crate::designs::{get_tokens, DesignColors, DesignVariant};
-use crate::list_item::LIST_ITEM_HEIGHT;
+use crate::list_item::{IconKind, LIST_ITEM_HEIGHT};
 use crate::logging;
 use crate::panel::PROMPT_INPUT_FIELD_HEIGHT;
 use crate::protocol::{generate_semantic_id, Choice};
@@ -37,5 +37,5 @@
 mod types;
 
 pub use prompt::SelectPrompt;
-use search::*;
-use types::*;
+pub(super) use search::*;
+pub(super) use types::*;
diff --git a/src/prompts/select/prompt.rs b/src/prompts/select/prompt.rs
index c5f98f5318f5b520e9223811f735e866ee06e7fb..5ba2de479b2f5680a73db72642377f68d26ee54e
--- a/src/prompts/select/prompt.rs
+++ b/src/prompts/select/prompt.rs
@@ -19,6 +19,8 @@
     pub filtered_choices: Vec<usize>,
     /// Currently focused index in filtered list
     pub focused_index: usize,
+    /// Currently hovered index in filtered list
+    pub hovered_index: Option<usize>,
     /// Filter text
     pub filter_text: String,
     /// Whether multiple selection is allowed
@@ -68,6 +70,7 @@
             selected: HashSet::new(),
             filtered_choices,
             focused_index: 0,
+            hovered_index: None,
             filter_text: String::new(),
             multiple,
             focus_handle,
@@ -84,6 +87,7 @@
         if trimmed_filter.is_empty() {
             self.filtered_choices = (0..self.choices.len()).collect();
             self.focused_index = 0;
+            self.hovered_index = None;
             return;
         }
 
@@ -109,6 +113,7 @@
 
         self.filtered_choices = scored_matches.into_iter().map(|(idx, _)| idx).collect();
         self.focused_index = 0;
+        self.hovered_index = None;
     }
 
     /// Set the filter text programmatically
@@ -168,6 +173,7 @@
     pub(super) fn move_up(&mut self, cx: &mut Context<Self>) {
         if self.focused_index > 0 {
             self.focused_index -= 1;
+            self.hovered_index = None;
             self.list_scroll_handle
                 .scroll_to_item(self.focused_index, ScrollStrategy::Nearest);
             cx.notify();
@@ -178,6 +184,7 @@
     pub(super) fn move_down(&mut self, cx: &mut Context<Self>) {
         if self.focused_index < self.filtered_choices.len().saturating_sub(1) {
             self.focused_index += 1;
+            self.hovered_index = None;
             self.list_scroll_handle
                 .scroll_to_item(self.focused_index, ScrollStrategy::Nearest);
             cx.notify();
diff --git a/src/prompts/select/render.rs b/src/prompts/select/render.rs
index 62109896c9c14b1b2fbf5b4d25d5d94e4388e4aa..8c67aba367edf1587ee80ac17707f23ad35c2ce1
--- a/src/prompts/select/render.rs
+++ b/src/prompts/select/render.rs
@@ -1,5 +1,57 @@
 use super::*;
 
+const ROW_FOCUSED_BG_ALPHA: u32 = 0x3A;
+const ROW_HOVER_BG_ALPHA: u32 = 0x26;
+
+fn extract_choice_icon_hint(description: Option<&str>) -> Option<&str> {
+    description.and_then(|raw| {
+        raw.split(['‚Ä¢', '|', '\n'])
+            .map(str::trim)
+            .find_map(|token| {
+                let token_lower = token.to_ascii_lowercase();
+                if token_lower == "icon"
+                    || token_lower.starts_with("icon:")
+                    || token_lower.starts_with("icon=")
+                    || token_lower.starts_with("icon ")
+                {
+                    token
+                        .split_once(':')
+                        .or_else(|| token.split_once('='))
+                        .map(|(_, value)| value.trim())
+                        .or_else(|| token.split_whitespace().nth(1))
+                } else {
+                    None
+                }
+            })
+            .filter(|value| !value.is_empty())
+    })
+}
+
+fn icon_kind_from_choice(choice: &Choice) -> IconKind {
+    let metadata_icon = extract_choice_icon_hint(choice.description.as_deref())
+        .and_then(IconKind::from_icon_hint);
+    let name_prefix_icon = choice
+        .name
+        .split_whitespace()
+        .next()
+        .and_then(IconKind::from_icon_hint);
+
+    metadata_icon
+        .or(name_prefix_icon)
+        .unwrap_or_else(|| IconKind::Svg("Code".to_string()))
+}
+
+fn leading_content_from_icon_kind(icon_kind: IconKind) -> LeadingContent {
+    match icon_kind {
+        IconKind::Emoji(emoji) => LeadingContent::Emoji(emoji.into()),
+        IconKind::Image(render_image) => LeadingContent::AppIcon(render_image),
+        IconKind::Svg(name) => LeadingContent::Icon {
+            name: SharedString::from(name),
+            color: None,
+        },
+    }
+}
+
 impl Focusable for SelectPrompt {
     fn focus_handle(&self, _cx: &gpui::App) -> FocusHandle {
         self.focus_handle.clone()
@@ -76,6 +128,13 @@
             self.design_variant,
             &colors,
         ));
+        let row_accent_color = if self.design_variant == DesignVariant::Default {
+            self.theme.colors.accent.selected
+        } else {
+            colors.accent
+        };
+        let focused_row_bg = rgba((row_accent_color << 8) | ROW_FOCUSED_BG_ALPHA);
+        let hovered_row_bg = rgba((row_accent_color << 8) | ROW_HOVER_BG_ALPHA);
 
         let placeholder = self
             .placeholder
@@ -145,8 +204,12 @@
                     move |this: &mut SelectPrompt,
                           visible_range: std::ops::Range<usize>,
                           _window,
-                          _cx| {
-                        let row_colors = UnifiedListItemColors::from_theme(&this.theme);
+                          cx| {
+                        let item_colors = UnifiedListItemColors {
+                            selected_opacity: 0.0,
+                            hover_opacity: 0.0,
+                            ..UnifiedListItemColors::from_theme(&this.theme)
+                        };
                         let mut rows = Vec::with_capacity(visible_range.len());
 
                         for display_idx in visible_range {
@@ -156,19 +219,21 @@
                                     {
                                         let is_focused = display_idx == this.focused_index;
                                         let is_selected = this.selected.contains(&choice_idx);
-                                        let is_selected_for_ui = if this.multiple {
-                                            is_selected
-                                        } else {
-                                            is_focused
-                                        };
+                                        let is_hovered = this.hovered_index == Some(display_idx);
                                         let semantic_id =
                                             choice.semantic_id.clone().unwrap_or_else(|| {
                                                 indexed_choice.stable_semantic_id.clone()
                                             });
-                                        let indicator = choice_selection_indicator(
-                                            this.multiple,
-                                            is_selected_for_ui,
-                                        );
+                                        let leading = if this.multiple {
+                                            Some(LeadingContent::Emoji(
+                                                choice_selection_indicator(true, is_selected)
+                                                    .into(),
+                                            ))
+                                        } else {
+                                            Some(leading_content_from_icon_kind(
+                                                icon_kind_from_choice(choice),
+                                            ))
+                                        };
                                         let subtitle = indexed_choice
                                             .metadata
                                             .subtitle_text()
@@ -185,34 +250,61 @@
                                                     ))
                                                 },
                                             );
+                                        let row_bg = if is_focused {
+                                            focused_row_bg
+                                        } else if is_hovered {
+                                            hovered_row_bg
+                                        } else {
+                                            rgba(0x00000000)
+                                        };
+                                        let hover_handler = cx.listener(
+                                            move |this: &mut SelectPrompt,
+                                                  hovered: &bool,
+                                                  _window,
+                                                  cx| {
+                                                if *hovered {
+                                                    if this.hovered_index != Some(display_idx) {
+                                                        this.hovered_index = Some(display_idx);
+                                                        cx.notify();
+                                                    }
+                                                } else if this.hovered_index == Some(display_idx)
+                                                {
+                                                    this.hovered_index = None;
+                                                    cx.notify();
+                                                }
+                                            },
+                                        );
+
+                                        let mut row = div()
+                                            .id(display_idx)
+                                            .w_full()
+                                            .h(px(LIST_ITEM_HEIGHT))
+                                            .rounded(px(8.0))
+                                            .bg(row_bg)
+                                            .cursor_pointer()
+                                            .on_hover(hover_handler)
+                                            .child(
+                                                UnifiedListItem::new(
+                                                    gpui::ElementId::Name(semantic_id.into()),
+                                                    title,
+                                                )
+                                                .subtitle_opt(subtitle)
+                                                .leading_opt(leading)
+                                                .trailing_opt(trailing)
+                                                .state(ItemState {
+                                                    is_selected,
+                                                    is_hovered,
+                                                    is_disabled: false,
+                                                })
+                                                .density(Density::Comfortable)
+                                                .colors(item_colors),
+                                            );
 
-                                        rows.push(
-                                            div()
-                                                .id(display_idx)
-                                                .w_full()
-                                                .h(px(LIST_ITEM_HEIGHT))
-                                                .border_b_1()
-                                                .border_color(border_color)
-                                                .child(
-                                                    UnifiedListItem::new(
-                                                        gpui::ElementId::Name(semantic_id.into()),
-                                                        title,
-                                                    )
-                                                    .subtitle_opt(subtitle)
-                                                    .leading(LeadingContent::Emoji(
-                                                        indicator.into(),
-                                                    ))
-                                                    .trailing_opt(trailing)
-                                                    .state(ItemState {
-                                                        is_selected: is_focused,
-                                                        is_hovered: false,
-                                                        is_disabled: false,
-                                                    })
-                                                    .density(Density::Comfortable)
-                                                    .colors(row_colors)
-                                                    .with_accent_bar(is_selected_for_ui),
-                                                ),
-                                        );
+                                        if !is_focused {
+                                            row = row.hover(move |s| s.bg(hovered_row_bg));
+                                        }
+
+                                        rows.push(row);
                                     }
                                 }
                             }
@@ -234,6 +326,7 @@
             .flex_col()
             .flex_1()
             .w_full()
+            .px(px(8.0))
             .child(choices_content);
 
         div()


thinking
**Planning helper function tests**
codex
I found one more quality gap: current tests don‚Äôt cover the new focused-vs-selected split and icon extraction path, so I‚Äôm adding scoped unit tests for those behaviors and lightly exposing helper functions for testability.
exec
/bin/zsh -lc 'cd /Users/johnlindquist/dev/script-kit-gpui && ~/.claude/bin/swarm.ts update --id codex-list-polish --status in_progress --notes "Adding select tests for icon extraction and focused-vs-selected row state; then scoped verification"' in /Users/johnlindquist/dev/script-kit-gpui succeeded in 52ms:
Updated: codex-list-polish
exec
/bin/zsh -lc 'cd /Users/johnlindquist/dev/script-kit-gpui && ~/.claude/bin/swarm.ts claim --wait --id codex-list-polish src/prompts/select/tests.rs' in /Users/johnlindquist/dev/script-kit-gpui succeeded in 142ms:
Claimed for codex-list-polish: src/prompts/select/tests.rs
file update:
diff --git a/src/list_item/part_000.rs b/src/list_item/part_000.rs
index 733d4ac2aa5b1b27b29a5999310e6f3f45cc54c3..283b2263d56a92c73c22d44443db7b40971d26ce
--- a/src/list_item/part_000.rs
+++ b/src/list_item/part_000.rs
@@ -15,6 +15,37 @@
     /// Maps to IconName from designs::icon_variations
     Svg(String),
 }
+
+impl IconKind {
+    /// Resolve icon metadata into an IconKind for list rendering.
+    ///
+    /// Supports:
+    /// - Known SVG names/aliases via `icon_name_from_str` (e.g., "Terminal", "file-code")
+    /// - Emoji/symbol glyphs (e.g., "üìÑ", "‚ö°")
+    pub fn from_icon_hint(icon_hint: &str) -> Option<Self> {
+        let trimmed = icon_hint.trim();
+        if trimmed.is_empty() {
+            return None;
+        }
+
+        if icon_name_from_str(trimmed).is_some() {
+            return Some(Self::Svg(trimmed.to_string()));
+        }
+
+        if looks_like_symbol_icon_hint(trimmed) {
+            return Some(Self::Emoji(trimmed.to_string()));
+        }
+
+        None
+    }
+}
+
+fn looks_like_symbol_icon_hint(icon_hint: &str) -> bool {
+    let has_ascii_alnum = icon_hint.chars().any(|ch| ch.is_ascii_alphanumeric());
+    let char_count = icon_hint.chars().count();
+
+    !has_ascii_alnum && char_count <= 4
+}
 /// Fixed height for list items used in uniform-height virtualized lists.
 ///
 /// IMPORTANT: When using GPUI `uniform_list`, the item closure must render
@@ -437,3 +468,29 @@
     /// Text color for content displayed on accent/warning backgrounds
     pub text_on_accent: u32,
 }
+
+#[cfg(test)]
+mod icon_kind_tests {
+    use super::IconKind;
+
+    #[test]
+    fn test_icon_kind_from_icon_hint_returns_svg_when_known_icon_name() {
+        match IconKind::from_icon_hint("terminal") {
+            Some(IconKind::Svg(name)) => assert_eq!(name, "terminal"),
+            _ => panic!("expected SVG icon from known icon hint"),
+        }
+    }
+
+    #[test]
+    fn test_icon_kind_from_icon_hint_returns_emoji_when_symbol_glyph() {
+        match IconKind::from_icon_hint("üìÑ") {
+            Some(IconKind::Emoji(emoji)) => assert_eq!(emoji, "üìÑ"),
+            _ => panic!("expected emoji icon for symbol glyph"),
+        }
+    }
+
+    #[test]
+    fn test_icon_kind_from_icon_hint_returns_none_for_unknown_ascii_word() {
+        assert!(IconKind::from_icon_hint("unknown-icon-name").is_none());
+    }
+}
diff --git a/src/prompts/select/mod.rs b/src/prompts/select/mod.rs
index b6366dabfb14f3fae09f854f9de824fa629e0a3b..32ec6dd9fa7ee4b5d29009f3cc5a665713f97a10
--- a/src/prompts/select/mod.rs
+++ b/src/prompts/select/mod.rs
@@ -19,7 +19,7 @@
     UnifiedListItemColors,
 };
 use crate::designs::{get_tokens, DesignColors, DesignVariant};
-use crate::list_item::LIST_ITEM_HEIGHT;
+use crate::list_item::{IconKind, LIST_ITEM_HEIGHT};
 use crate::logging;
 use crate::panel::PROMPT_INPUT_FIELD_HEIGHT;
 use crate::protocol::{generate_semantic_id, Choice};
@@ -37,5 +37,5 @@
 mod types;
 
 pub use prompt::SelectPrompt;
-use search::*;
-use types::*;
+pub(super) use search::*;
+pub(super) use types::*;
diff --git a/src/prompts/select/prompt.rs b/src/prompts/select/prompt.rs
index c5f98f5318f5b520e9223811f735e866ee06e7fb..5ba2de479b2f5680a73db72642377f68d26ee54e
--- a/src/prompts/select/prompt.rs
+++ b/src/prompts/select/prompt.rs
@@ -19,6 +19,8 @@
     pub filtered_choices: Vec<usize>,
     /// Currently focused index in filtered list
     pub focused_index: usize,
+    /// Currently hovered index in filtered list
+    pub hovered_index: Option<usize>,
     /// Filter text
     pub filter_text: String,
     /// Whether multiple selection is allowed
@@ -68,6 +70,7 @@
             selected: HashSet::new(),
             filtered_choices,
             focused_index: 0,
+            hovered_index: None,
             filter_text: String::new(),
             multiple,
             focus_handle,
@@ -84,6 +87,7 @@
         if trimmed_filter.is_empty() {
             self.filtered_choices = (0..self.choices.len()).collect();
             self.focused_index = 0;
+            self.hovered_index = None;
             return;
         }
 
@@ -109,6 +113,7 @@
 
         self.filtered_choices = scored_matches.into_iter().map(|(idx, _)| idx).collect();
         self.focused_index = 0;
+        self.hovered_index = None;
     }
 
     /// Set the filter text programmatically
@@ -168,6 +173,7 @@
     pub(super) fn move_up(&mut self, cx: &mut Context<Self>) {
         if self.focused_index > 0 {
             self.focused_index -= 1;
+            self.hovered_index = None;
             self.list_scroll_handle
                 .scroll_to_item(self.focused_index, ScrollStrategy::Nearest);
             cx.notify();
@@ -178,6 +184,7 @@
     pub(super) fn move_down(&mut self, cx: &mut Context<Self>) {
         if self.focused_index < self.filtered_choices.len().saturating_sub(1) {
             self.focused_index += 1;
+            self.hovered_index = None;
             self.list_scroll_handle
                 .scroll_to_item(self.focused_index, ScrollStrategy::Nearest);
             cx.notify();
diff --git a/src/prompts/select/render.rs b/src/prompts/select/render.rs
index 62109896c9c14b1b2fbf5b4d25d5d94e4388e4aa..8c67aba367edf1587ee80ac17707f23ad35c2ce1
--- a/src/prompts/select/render.rs
+++ b/src/prompts/select/render.rs
@@ -1,5 +1,57 @@
 use super::*;
 
+const ROW_FOCUSED_BG_ALPHA: u32 = 0x3A;
+const ROW_HOVER_BG_ALPHA: u32 = 0x26;
+
+fn extract_choice_icon_hint(description: Option<&str>) -> Option<&str> {
+    description.and_then(|raw| {
+        raw.split(['‚Ä¢', '|', '\n'])
+            .map(str::trim)
+            .find_map(|token| {
+                let token_lower = token.to_ascii_lowercase();
+                if token_lower == "icon"
+                    || token_lower.starts_with("icon:")
+                    || token_lower.starts_with("icon=")
+                    || token_lower.starts_with("icon ")
+                {
+                    token
+                        .split_once(':')
+                        .or_else(|| token.split_once('='))
+                        .map(|(_, value)| value.trim())
+                        .or_else(|| token.split_whitespace().nth(1))
+                } else {
+                    None
+                }
+            })
+            .filter(|value| !value.is_empty())
+    })
+}
+
+fn icon_kind_from_choice(choice: &Choice) -> IconKind {
+    let metadata_icon = extract_choice_icon_hint(choice.description.as_deref())
+        .and_then(IconKind::from_icon_hint);
+    let name_prefix_icon = choice
+        .name
+        .split_whitespace()
+        .next()
+        .and_then(IconKind::from_icon_hint);
+
+    metadata_icon
+        .or(name_prefix_icon)
+        .unwrap_or_else(|| IconKind::Svg("Code".to_string()))
+}
+
+fn leading_content_from_icon_kind(icon_kind: IconKind) -> LeadingContent {
+    match icon_kind {
+        IconKind::Emoji(emoji) => LeadingContent::Emoji(emoji.into()),
+        IconKind::Image(render_image) => LeadingContent::AppIcon(render_image),
+        IconKind::Svg(name) => LeadingContent::Icon {
+            name: SharedString::from(name),
+            color: None,
+        },
+    }
+}
+
 impl Focusable for SelectPrompt {
     fn focus_handle(&self, _cx: &gpui::App) -> FocusHandle {
         self.focus_handle.clone()
@@ -76,6 +128,13 @@
             self.design_variant,
             &colors,
         ));
+        let row_accent_color = if self.design_variant == DesignVariant::Default {
+            self.theme.colors.accent.selected
+        } else {
+            colors.accent
+        };
+        let focused_row_bg = rgba((row_accent_color << 8) | ROW_FOCUSED_BG_ALPHA);
+        let hovered_row_bg = rgba((row_accent_color << 8) | ROW_HOVER_BG_ALPHA);
 
         let placeholder = self
             .placeholder
@@ -145,8 +204,12 @@
                     move |this: &mut SelectPrompt,
                           visible_range: std::ops::Range<usize>,
                           _window,
-                          _cx| {
-                        let row_colors = UnifiedListItemColors::from_theme(&this.theme);
+                          cx| {
+                        let item_colors = UnifiedListItemColors {
+                            selected_opacity: 0.0,
+                            hover_opacity: 0.0,
+                            ..UnifiedListItemColors::from_theme(&this.theme)
+                        };
                         let mut rows = Vec::with_capacity(visible_range.len());
 
                         for display_idx in visible_range {
@@ -156,19 +219,21 @@
                                     {
                                         let is_focused = display_idx == this.focused_index;
                                         let is_selected = this.selected.contains(&choice_idx);
-                                        let is_selected_for_ui = if this.multiple {
-                                            is_selected
-                                        } else {
-                                            is_focused
-                                        };
+                                        let is_hovered = this.hovered_index == Some(display_idx);
                                         let semantic_id =
                                             choice.semantic_id.clone().unwrap_or_else(|| {
                                                 indexed_choice.stable_semantic_id.clone()
                                             });
-                                        let indicator = choice_selection_indicator(
-                                            this.multiple,
-                                            is_selected_for_ui,
-                                        );
+                                        let leading = if this.multiple {
+                                            Some(LeadingContent::Emoji(
+                                                choice_selection_indicator(true, is_selected)
+                                                    .into(),
+                                            ))
+                                        } else {
+                                            Some(leading_content_from_icon_kind(
+                                                icon_kind_from_choice(choice),
+                                            ))
+                                        };
                                         let subtitle = indexed_choice
                                             .metadata
                                             .subtitle_text()
@@ -185,34 +250,61 @@
                                                     ))
                                                 },
                                             );
+                                        let row_bg = if is_focused {
+                                            focused_row_bg
+                                        } else if is_hovered {
+                                            hovered_row_bg
+                                        } else {
+                                            rgba(0x00000000)
+                                        };
+                                        let hover_handler = cx.listener(
+                                            move |this: &mut SelectPrompt,
+                                                  hovered: &bool,
+                                                  _window,
+                                                  cx| {
+                                                if *hovered {
+                                                    if this.hovered_index != Some(display_idx) {
+                                                        this.hovered_index = Some(display_idx);
+                                                        cx.notify();
+                                                    }
+                                                } else if this.hovered_index == Some(display_idx)
+                                                {
+                                                    this.hovered_index = None;
+                                                    cx.notify();
+                                                }
+                                            },
+                                        );
+
+                                        let mut row = div()
+                                            .id(display_idx)
+                                            .w_full()
+                                            .h(px(LIST_ITEM_HEIGHT))
+                                            .rounded(px(8.0))
+                                            .bg(row_bg)
+                                            .cursor_pointer()
+                                            .on_hover(hover_handler)
+                                            .child(
+                                                UnifiedListItem::new(
+                                                    gpui::ElementId::Name(semantic_id.into()),
+                                                    title,
+                                                )
+                                                .subtitle_opt(subtitle)
+                                                .leading_opt(leading)
+                                                .trailing_opt(trailing)
+                                                .state(ItemState {
+                                                    is_selected,
+                                                    is_hovered,
+                                                    is_disabled: false,
+                                                })
+                                                .density(Density::Comfortable)
+                                                .colors(item_colors),
+                                            );
 
-                                        rows.push(
-                                            div()
-                                                .id(display_idx)
-                                                .w_full()
-                                                .h(px(LIST_ITEM_HEIGHT))
-                                                .border_b_1()
-                                                .border_color(border_color)
-                                                .child(
-                                                    UnifiedListItem::new(
-                                                        gpui::ElementId::Name(semantic_id.into()),
-                                                        title,
-                                                    )
-                                                    .subtitle_opt(subtitle)
-                                                    .leading(LeadingContent::Emoji(
-                                                        indicator.into(),
-                                                    ))
-                                                    .trailing_opt(trailing)
-                                                    .state(ItemState {
-                                                        is_selected: is_focused,
-                                                        is_hovered: false,
-                                                        is_disabled: false,
-                                                    })
-                                                    .density(Density::Comfortable)
-                                                    .colors(row_colors)
-                                                    .with_accent_bar(is_selected_for_ui),
-                                                ),
-                                        );
+                                        if !is_focused {
+                                            row = row.hover(move |s| s.bg(hovered_row_bg));
+                                        }
+
+                                        rows.push(row);
                                     }
                                 }
                             }
@@ -234,6 +326,7 @@
             .flex_col()
             .flex_1()
             .w_full()
+            .px(px(8.0))
             .child(choices_content);
 
         div()


thinking
**Preparing precise patch for rendering**
exec
/bin/zsh -lc "cd /Users/johnlindquist/dev/script-kit-gpui && sed -n '1,140p' src/prompts/select/render.rs" in /Users/johnlindquist/dev/script-kit-gpui succeeded in 52ms:
use super::*;

const ROW_FOCUSED_BG_ALPHA: u32 = 0x3A;
const ROW_HOVER_BG_ALPHA: u32 = 0x26;

fn extract_choice_icon_hint(description: Option<&str>) -> Option<&str> {
    description.and_then(|raw| {
        raw.split(['‚Ä¢', '|', '\n'])
            .map(str::trim)
            .find_map(|token| {
                let token_lower = token.to_ascii_lowercase();
                if token_lower == "icon"
                    || token_lower.starts_with("icon:")
                    || token_lower.starts_with("icon=")
                    || token_lower.starts_with("icon ")
                {
                    token
                        .split_once(':')
                        .or_else(|| token.split_once('='))
                        .map(|(_, value)| value.trim())
file update:
diff --git a/src/list_item/part_000.rs b/src/list_item/part_000.rs
index 733d4ac2aa5b1b27b29a5999310e6f3f45cc54c3..283b2263d56a92c73c22d44443db7b40971d26ce
--- a/src/list_item/part_000.rs
+++ b/src/list_item/part_000.rs
@@ -15,6 +15,37 @@
     /// Maps to IconName from designs::icon_variations
     Svg(String),
 }
+
+impl IconKind {
+    /// Resolve icon metadata into an IconKind for list rendering.
+    ///
+    /// Supports:
+    /// - Known SVG names/aliases via `icon_name_from_str` (e.g., "Terminal", "file-code")
+    /// - Emoji/symbol glyphs (e.g., "üìÑ", "‚ö°")
+    pub fn from_icon_hint(icon_hint: &str) -> Option<Self> {
+        let trimmed = icon_hint.trim();
+        if trimmed.is_empty() {
+            return None;
+        }
+
+        if icon_name_from_str(trimmed).is_some() {
+            return Some(Self::Svg(trimmed.to_string()));
+        }
+
+        if looks_like_symbol_icon_hint(trimmed) {
+            return Some(Self::Emoji(trimmed.to_string()));
+        }
+
+        None
+    }
+}
+
+fn looks_like_symbol_icon_hint(icon_hint: &str) -> bool {
+    let has_ascii_alnum = icon_hint.chars().any(|ch| ch.is_ascii_alphanumeric());
+    let char_count = icon_hint.chars().count();
+
+    !has_ascii_alnum && char_count <= 4
+}
 /// Fixed height for list items used in uniform-height virtualized lists.
 ///
 /// IMPORTANT: When using GPUI `uniform_list`, the item closure must render
@@ -437,3 +468,29 @@
     /// Text color for content displayed on accent/warning backgrounds
     pub text_on_accent: u32,
 }
+
+#[cfg(test)]
+mod icon_kind_tests {
+    use super::IconKind;
+
+    #[test]
+    fn test_icon_kind_from_icon_hint_returns_svg_when_known_icon_name() {
+        match IconKind::from_icon_hint("terminal") {
+            Some(IconKind::Svg(name)) => assert_eq!(name, "terminal"),
+            _ => panic!("expected SVG icon from known icon hint"),
+        }
+    }
+
+    #[test]
+    fn test_icon_kind_from_icon_hint_returns_emoji_when_symbol_glyph() {
+        match IconKind::from_icon_hint("üìÑ") {
+            Some(IconKind::Emoji(emoji)) => assert_eq!(emoji, "üìÑ"),
+            _ => panic!("expected emoji icon for symbol glyph"),
+        }
+    }
+
+    #[test]
+    fn test_icon_kind_from_icon_hint_returns_none_for_unknown_ascii_word() {
+        assert!(IconKind::from_icon_hint("unknown-icon-name").is_none());
+    }
+}
diff --git a/src/prompts/select/mod.rs b/src/prompts/select/mod.rs
index b6366dabfb14f3fae09f854f9de824fa629e0a3b..32ec6dd9fa7ee4b5d29009f3cc5a665713f97a10
--- a/src/prompts/select/mod.rs
+++ b/src/prompts/select/mod.rs
@@ -19,7 +19,7 @@
     UnifiedListItemColors,
 };
 use crate::designs::{get_tokens, DesignColors, DesignVariant};
-use crate::list_item::LIST_ITEM_HEIGHT;
+use crate::list_item::{IconKind, LIST_ITEM_HEIGHT};
 use crate::logging;
 use crate::panel::PROMPT_INPUT_FIELD_HEIGHT;
 use crate::protocol::{generate_semantic_id, Choice};
@@ -37,5 +37,5 @@
 mod types;
 
 pub use prompt::SelectPrompt;
-use search::*;
-use types::*;
+pub(super) use search::*;
+pub(super) use types::*;
diff --git a/src/prompts/select/prompt.rs b/src/prompts/select/prompt.rs
index c5f98f5318f5b520e9223811f735e866ee06e7fb..5ba2de479b2f5680a73db72642377f68d26ee54e
--- a/src/prompts/select/prompt.rs
+++ b/src/prompts/select/prompt.rs
@@ -19,6 +19,8 @@
     pub filtered_choices: Vec<usize>,
     /// Currently focused index in filtered list
     pub focused_index: usize,
+    /// Currently hovered index in filtered list
+    pub hovered_index: Option<usize>,
     /// Filter text
     pub filter_text: String,
     /// Whether multiple selection is allowed
@@ -68,6 +70,7 @@
             selected: HashSet::new(),
             filtered_choices,
             focused_index: 0,
+            hovered_index: None,
             filter_text: String::new(),
             multiple,
             focus_handle,
@@ -84,6 +87,7 @@
         if trimmed_filter.is_empty() {
             self.filtered_choices = (0..self.choices.len()).collect();
             self.focused_index = 0;
+            self.hovered_index = None;
             return;
         }
 
@@ -109,6 +113,7 @@
 
         self.filtered_choices = scored_matches.into_iter().map(|(idx, _)| idx).collect();
         self.focused_index = 0;
+        self.hovered_index = None;
     }
 
     /// Set the filter text programmatically
@@ -168,6 +173,7 @@
     pub(super) fn move_up(&mut self, cx: &mut Context<Self>) {
         if self.focused_index > 0 {
             self.focused_index -= 1;
+            self.hovered_index = None;
             self.list_scroll_handle
                 .scroll_to_item(self.focused_index, ScrollStrategy::Nearest);
             cx.notify();
@@ -178,6 +184,7 @@
     pub(super) fn move_down(&mut self, cx: &mut Context<Self>) {
         if self.focused_index < self.filtered_choices.len().saturating_sub(1) {
             self.focused_index += 1;
+            self.hovered_index = None;
             self.list_scroll_handle
                 .scroll_to_item(self.focused_index, ScrollStrategy::Nearest);
             cx.notify();
diff --git a/src/prompts/select/render.rs b/src/prompts/select/render.rs
index 62109896c9c14b1b2fbf5b4d25d5d94e4388e4aa..8c67aba367edf1587ee80ac17707f23ad35c2ce1
--- a/src/prompts/select/render.rs
+++ b/src/prompts/select/render.rs
@@ -1,5 +1,57 @@
 use super::*;
 
+const ROW_FOCUSED_BG_ALPHA: u32 = 0x3A;
+const ROW_HOVER_BG_ALPHA: u32 = 0x26;
+
+fn extract_choice_icon_hint(description: Option<&str>) -> Option<&str> {
+    description.and_then(|raw| {
+        raw.split(['‚Ä¢', '|', '\n'])
+            .map(str::trim)
+            .find_map(|token| {
+                let token_lower = token.to_ascii_lowercase();
+                if token_lower == "icon"
+                    || token_lower.starts_with("icon:")
+                    || token_lower.starts_with("icon=")
+                    || token_lower.starts_with("icon ")
+                {
+                    token
+                        .split_once(':')
+                        .or_else(|| token.split_once('='))
+                        .map(|(_, value)| value.trim())
+                        .or_else(|| token.split_whitespace().nth(1))
+                } else {
+                    None
+                }
+            })
+            .filter(|value| !value.is_empty())
+    })
+}
+
+fn icon_kind_from_choice(choice: &Choice) -> IconKind {
+    let metadata_icon = extract_choice_icon_hint(choice.description.as_deref())
+        .and_then(IconKind::from_icon_hint);
+    let name_prefix_icon = choice
+        .name
+        .split_whitespace()
+        .next()
+        .and_then(IconKind::from_icon_hint);
+
+    metadata_icon
+        .or(name_prefix_icon)
+        .unwrap_or_else(|| IconKind::Svg("Code".to_string()))
+}
+
+fn leading_content_from_icon_kind(icon_kind: IconKind) -> LeadingContent {
+    match icon_kind {
+        IconKind::Emoji(emoji) => LeadingContent::Emoji(emoji.into()),
+        IconKind::Image(render_image) => LeadingContent::AppIcon(render_image),
+        IconKind::Svg(name) => LeadingContent::Icon {
+            name: SharedString::from(name),
+            color: None,
+        },
+    }
+}
+
 impl Focusable for SelectPrompt {
     fn focus_handle(&self, _cx: &gpui::App) -> FocusHandle {
         self.focus_handle.clone()
@@ -76,6 +128,13 @@
             self.design_variant,
             &colors,
         ));
+        let row_accent_color = if self.design_variant == DesignVariant::Default {
+            self.theme.colors.accent.selected
+        } else {
+            colors.accent
+        };
+        let focused_row_bg = rgba((row_accent_color << 8) | ROW_FOCUSED_BG_ALPHA);
+        let hovered_row_bg = rgba((row_accent_color << 8) | ROW_HOVER_BG_ALPHA);
 
         let placeholder = self
             .placeholder
@@ -145,8 +204,12 @@
                     move |this: &mut SelectPrompt,
                           visible_range: std::ops::Range<usize>,
                           _window,
-                          _cx| {
-                        let row_colors = UnifiedListItemColors::from_theme(&this.theme);
+                          cx| {
+                        let item_colors = UnifiedListItemColors {
+                            selected_opacity: 0.0,
+                            hover_opacity: 0.0,
+                            ..UnifiedListItemColors::from_theme(&this.theme)
+                        };
                         let mut rows = Vec::with_capacity(visible_range.len());
 
                         for display_idx in visible_range {
@@ -156,19 +219,21 @@
                                     {
                                         let is_focused = display_idx == this.focused_index;
                                         let is_selected = this.selected.contains(&choice_idx);
-                                        let is_selected_for_ui = if this.multiple {
-                                            is_selected
-                                        } else {
-                                            is_focused
-                                        };
+                                        let is_hovered = this.hovered_index == Some(display_idx);
                                         let semantic_id =
                                             choice.semantic_id.clone().unwrap_or_else(|| {
                                                 indexed_choice.stable_semantic_id.clone()
                                             });
-                                        let indicator = choice_selection_indicator(
-                                            this.multiple,
-                                            is_selected_for_ui,
-                                        );
+                                        let leading = if this.multiple {
+                                            Some(LeadingContent::Emoji(
+                                                choice_selection_indicator(true, is_selected)
+                                                    .into(),
+                                            ))
+                                        } else {
+                                            Some(leading_content_from_icon_kind(
+                                                icon_kind_from_choice(choice),
+                                            ))
+                                        };
                                         let subtitle = indexed_choice
                                             .metadata
                                             .subtitle_text()
@@ -185,34 +250,61 @@
                                                     ))
                                                 },
                                             );
+                                        let row_bg = if is_focused {
+                                            focused_row_bg
+                                        } else if is_hovered {
+                                            hovered_row_bg
+                                        } else {
+                                            rgba(0x00000000)
+                                        };
+                                        let hover_handler = cx.listener(
+                                            move |this: &mut SelectPrompt,
+                                                  hovered: &bool,
+                                                  _window,
+                                                  cx| {
+                                                if *hovered {
+                                                    if this.hovered_index != Some(display_idx) {
+                                                        this.hovered_index = Some(display_idx);
+                                                        cx.notify();
+                                                    }
+                                                } else if this.hovered_index == Some(display_idx)
+                                                {
+                                                    this.hovered_index = None;
+                                                    cx.notify();
+                                                }
+                                            },
+                                        );
+
+                                        let mut row = div()
+                                            .id(display_idx)
+                                            .w_full()
+                                            .h(px(LIST_ITEM_HEIGHT))
+                                            .rounded(px(8.0))
+                                            .bg(row_bg)
+                                            .cursor_pointer()
+                                            .on_hover(hover_handler)
+                                            .child(
+                                                UnifiedListItem::new(
+                                                    gpui::ElementId::Name(semantic_id.into()),
+                                                    title,
+                                                )
+                                                .subtitle_opt(subtitle)
+                                                .leading_opt(leading)
+                                                .trailing_opt(trailing)
+                                                .state(ItemState {
+                                                    is_selected,
+                                                    is_hovered,
+                                                    is_disabled: false,
+                                                })
+                                                .density(Density::Comfortable)
+                                                .colors(item_colors),
+                                            );
 
-                                        rows.push(
-                                            div()
-                                                .id(display_idx)
-                                                .w_full()
-                                                .h(px(LIST_ITEM_HEIGHT))
-                                                .border_b_1()
-                                                .border_color(border_color)
-                                                .child(
-                                                    UnifiedListItem::new(
-                                                        gpui::ElementId::Name(semantic_id.into()),
-                                                        title,
-                                                    )
-                                                    .subtitle_opt(subtitle)
-                                                    .leading(LeadingContent::Emoji(
-                                                        indicator.into(),
-                                                    ))
-                                                    .trailing_opt(trailing)
-                                                    .state(ItemState {
-                                                        is_selected: is_focused,
-                                                        is_hovered: false,
-                                                        is_disabled: false,
-                                                    })
-                                                    .density(Density::Comfortable)
-                                                    .colors(row_colors)
-                                                    .with_accent_bar(is_selected_for_ui),
-                                                ),
-                                        );
+                                        if !is_focused {
+                                            row = row.hover(move |s| s.bg(hovered_row_bg));
+                                        }
+
+                                        rows.push(row);
                                     }
                                 }
                             }
@@ -234,6 +326,7 @@
             .flex_col()
             .flex_1()
             .w_full()
+            .px(px(8.0))
             .child(choices_content);
 
         div()


thinking
**Preparing state struct and visibility changes**
file update
M /Users/johnlindquist/dev/script-kit-gpui/src/prompts/select/render.rs
@@ -5,3 +5,24 @@
 
-fn extract_choice_icon_hint(description: Option<&str>) -> Option<&str> {
+#[derive(Clone, Copy, Debug, PartialEq, Eq)]
+pub(super) struct SelectRowState {
+    pub is_focused: bool,
+    pub is_selected: bool,
+    pub is_hovered: bool,
+}
+
+pub(super) fn compute_row_state(
+    display_idx: usize,
+    focused_index: usize,
+    choice_idx: usize,
+    selected: &HashSet<usize>,
+    hovered_index: Option<usize>,
+) -> SelectRowState {
+    SelectRowState {
+        is_focused: display_idx == focused_index,
+        is_selected: selected.contains(&choice_idx),
+        is_hovered: hovered_index == Some(display_idx),
+    }
+}
+
+pub(super) fn extract_choice_icon_hint(description: Option<&str>) -> Option<&str> {
     description.and_then(|raw| {
@@ -29,3 +50,3 @@
 
-fn icon_kind_from_choice(choice: &Choice) -> IconKind {
+pub(super) fn icon_kind_from_choice(choice: &Choice) -> IconKind {
     let metadata_icon = extract_choice_icon_hint(choice.description.as_deref())
apply_patch(auto_approved=true) exited 0 in 25ms:
Success. Updated the following files:
M /Users/johnlindquist/dev/script-kit-gpui/src/prompts/select/render.rs
file update:
diff --git a/src/list_item/part_000.rs b/src/list_item/part_000.rs
index 733d4ac2aa5b1b27b29a5999310e6f3f45cc54c3..283b2263d56a92c73c22d44443db7b40971d26ce
--- a/src/list_item/part_000.rs
+++ b/src/list_item/part_000.rs
@@ -15,6 +15,37 @@
     /// Maps to IconName from designs::icon_variations
     Svg(String),
 }
+
+impl IconKind {
+    /// Resolve icon metadata into an IconKind for list rendering.
+    ///
+    /// Supports:
+    /// - Known SVG names/aliases via `icon_name_from_str` (e.g., "Terminal", "file-code")
+    /// - Emoji/symbol glyphs (e.g., "üìÑ", "‚ö°")
+    pub fn from_icon_hint(icon_hint: &str) -> Option<Self> {
+        let trimmed = icon_hint.trim();
+        if trimmed.is_empty() {
+            return None;
+        }
+
+        if icon_name_from_str(trimmed).is_some() {
+            return Some(Self::Svg(trimmed.to_string()));
+        }
+
+        if looks_like_symbol_icon_hint(trimmed) {
+            return Some(Self::Emoji(trimmed.to_string()));
+        }
+
+        None
+    }
+}
+
+fn looks_like_symbol_icon_hint(icon_hint: &str) -> bool {
+    let has_ascii_alnum = icon_hint.chars().any(|ch| ch.is_ascii_alphanumeric());
+    let char_count = icon_hint.chars().count();
+
+    !has_ascii_alnum && char_count <= 4
+}
 /// Fixed height for list items used in uniform-height virtualized lists.
 ///
 /// IMPORTANT: When using GPUI `uniform_list`, the item closure must render
@@ -437,3 +468,29 @@
     /// Text color for content displayed on accent/warning backgrounds
     pub text_on_accent: u32,
 }
+
+#[cfg(test)]
+mod icon_kind_tests {
+    use super::IconKind;
+
+    #[test]
+    fn test_icon_kind_from_icon_hint_returns_svg_when_known_icon_name() {
+        match IconKind::from_icon_hint("terminal") {
+            Some(IconKind::Svg(name)) => assert_eq!(name, "terminal"),
+            _ => panic!("expected SVG icon from known icon hint"),
+        }
+    }
+
+    #[test]
+    fn test_icon_kind_from_icon_hint_returns_emoji_when_symbol_glyph() {
+        match IconKind::from_icon_hint("üìÑ") {
+            Some(IconKind::Emoji(emoji)) => assert_eq!(emoji, "üìÑ"),
+            _ => panic!("expected emoji icon for symbol glyph"),
+        }
+    }
+
+    #[test]
+    fn test_icon_kind_from_icon_hint_returns_none_for_unknown_ascii_word() {
+        assert!(IconKind::from_icon_hint("unknown-icon-name").is_none());
+    }
+}
diff --git a/src/prompts/select/mod.rs b/src/prompts/select/mod.rs
index b6366dabfb14f3fae09f854f9de824fa629e0a3b..32ec6dd9fa7ee4b5d29009f3cc5a665713f97a10
--- a/src/prompts/select/mod.rs
+++ b/src/prompts/select/mod.rs
@@ -19,7 +19,7 @@
     UnifiedListItemColors,
 };
 use crate::designs::{get_tokens, DesignColors, DesignVariant};
-use crate::list_item::LIST_ITEM_HEIGHT;
+use crate::list_item::{IconKind, LIST_ITEM_HEIGHT};
 use crate::logging;
 use crate::panel::PROMPT_INPUT_FIELD_HEIGHT;
 use crate::protocol::{generate_semantic_id, Choice};
@@ -37,5 +37,5 @@
 mod types;
 
 pub use prompt::SelectPrompt;
-use search::*;
-use types::*;
+pub(super) use search::*;
+pub(super) use types::*;
diff --git a/src/prompts/select/prompt.rs b/src/prompts/select/prompt.rs
index c5f98f5318f5b520e9223811f735e866ee06e7fb..5ba2de479b2f5680a73db72642377f68d26ee54e
--- a/src/prompts/select/prompt.rs
+++ b/src/prompts/select/prompt.rs
@@ -19,6 +19,8 @@
     pub filtered_choices: Vec<usize>,
     /// Currently focused index in filtered list
     pub focused_index: usize,
+    /// Currently hovered index in filtered list
+    pub hovered_index: Option<usize>,
     /// Filter text
     pub filter_text: String,
     /// Whether multiple selection is allowed
@@ -68,6 +70,7 @@
             selected: HashSet::new(),
             filtered_choices,
             focused_index: 0,
+            hovered_index: None,
             filter_text: String::new(),
             multiple,
             focus_handle,
@@ -84,6 +87,7 @@
         if trimmed_filter.is_empty() {
             self.filtered_choices = (0..self.choices.len()).collect();
             self.focused_index = 0;
+            self.hovered_index = None;
             return;
         }
 
@@ -109,6 +113,7 @@
 
         self.filtered_choices = scored_matches.into_iter().map(|(idx, _)| idx).collect();
         self.focused_index = 0;
+        self.hovered_index = None;
     }
 
     /// Set the filter text programmatically
@@ -168,6 +173,7 @@
     pub(super) fn move_up(&mut self, cx: &mut Context<Self>) {
         if self.focused_index > 0 {
             self.focused_index -= 1;
+            self.hovered_index = None;
             self.list_scroll_handle
                 .scroll_to_item(self.focused_index, ScrollStrategy::Nearest);
             cx.notify();
@@ -178,6 +184,7 @@
     pub(super) fn move_down(&mut self, cx: &mut Context<Self>) {
         if self.focused_index < self.filtered_choices.len().saturating_sub(1) {
             self.focused_index += 1;
+            self.hovered_index = None;
             self.list_scroll_handle
                 .scroll_to_item(self.focused_index, ScrollStrategy::Nearest);
             cx.notify();
diff --git a/src/prompts/select/render.rs b/src/prompts/select/render.rs
index 62109896c9c14b1b2fbf5b4d25d5d94e4388e4aa..51f373592c3f39e1d2ec79e3dbeb9e3827e9bf28
--- a/src/prompts/select/render.rs
+++ b/src/prompts/select/render.rs
@@ -1,5 +1,78 @@
 use super::*;
 
+const ROW_FOCUSED_BG_ALPHA: u32 = 0x3A;
+const ROW_HOVER_BG_ALPHA: u32 = 0x26;
+
+#[derive(Clone, Copy, Debug, PartialEq, Eq)]
+pub(super) struct SelectRowState {
+    pub is_focused: bool,
+    pub is_selected: bool,
+    pub is_hovered: bool,
+}
+
+pub(super) fn compute_row_state(
+    display_idx: usize,
+    focused_index: usize,
+    choice_idx: usize,
+    selected: &HashSet<usize>,
+    hovered_index: Option<usize>,
+) -> SelectRowState {
+    SelectRowState {
+        is_focused: display_idx == focused_index,
+        is_selected: selected.contains(&choice_idx),
+        is_hovered: hovered_index == Some(display_idx),
+    }
+}
+
+pub(super) fn extract_choice_icon_hint(description: Option<&str>) -> Option<&str> {
+    description.and_then(|raw| {
+        raw.split(['‚Ä¢', '|', '\n'])
+            .map(str::trim)
+            .find_map(|token| {
+                let token_lower = token.to_ascii_lowercase();
+                if token_lower == "icon"
+                    || token_lower.starts_with("icon:")
+                    || token_lower.starts_with("icon=")
+                    || token_lower.starts_with("icon ")
+                {
+                    token
+                        .split_once(':')
+                        .or_else(|| token.split_once('='))
+                        .map(|(_, value)| value.trim())
+                        .or_else(|| token.split_whitespace().nth(1))
+                } else {
+                    None
+                }
+            })
+            .filter(|value| !value.is_empty())
+    })
+}
+
+pub(super) fn icon_kind_from_choice(choice: &Choice) -> IconKind {
+    let metadata_icon = extract_choice_icon_hint(choice.description.as_deref())
+        .and_then(IconKind::from_icon_hint);
+    let name_prefix_icon = choice
+        .name
+        .split_whitespace()
+        .next()
+        .and_then(IconKind::from_icon_hint);
+
+    metadata_icon
+        .or(name_prefix_icon)
+        .unwrap_or_else(|| IconKind::Svg("Code".to_string()))
+}
+
+fn leading_content_from_icon_kind(icon_kind: IconKind) -> LeadingContent {
+    match icon_kind {
+        IconKind::Emoji(emoji) => LeadingContent::Emoji(emoji.into()),
+        IconKind::Image(render_image) => LeadingContent::AppIcon(render_image),
+        IconKind::Svg(name) => LeadingContent::Icon {
+            name: SharedString::from(name),
+            color: None,
+        },
+    }
+}
+
 impl Focusable for SelectPrompt {
     fn focus_handle(&self, _cx: &gpui::App) -> FocusHandle {
         self.focus_handle.clone()
@@ -76,6 +149,13 @@
             self.design_variant,
             &colors,
         ));
+        let row_accent_color = if self.design_variant == DesignVariant::Default {
+            self.theme.colors.accent.selected
+        } else {
+            colors.accent
+        };
+        let focused_row_bg = rgba((row_accent_color << 8) | ROW_FOCUSED_BG_ALPHA);
+        let hovered_row_bg = rgba((row_accent_color << 8) | ROW_HOVER_BG_ALPHA);
 
         let placeholder = self
             .placeholder
@@ -145,8 +225,12 @@
                     move |this: &mut SelectPrompt,
                           visible_range: std::ops::Range<usize>,
                           _window,
-                          _cx| {
-                        let row_colors = UnifiedListItemColors::from_theme(&this.theme);
+                          cx| {
+                        let item_colors = UnifiedListItemColors {
+                            selected_opacity: 0.0,
+                            hover_opacity: 0.0,
+                            ..UnifiedListItemColors::from_theme(&this.theme)
+                        };
                         let mut rows = Vec::with_capacity(visible_range.len());
 
                         for display_idx in visible_range {
@@ -156,19 +240,21 @@
                                     {
                                         let is_focused = display_idx == this.focused_index;
                                         let is_selected = this.selected.contains(&choice_idx);
-                                        let is_selected_for_ui = if this.multiple {
-                                            is_selected
-                                        } else {
-                                            is_focused
-                                        };
+                                        let is_hovered = this.hovered_index == Some(display_idx);
                                         let semantic_id =
                                             choice.semantic_id.clone().unwrap_or_else(|| {
                                                 indexed_choice.stable_semantic_id.clone()
                                             });
-                                        let indicator = choice_selection_indicator(
-                                            this.multiple,
-                                            is_selected_for_ui,
-                                        );
+                                        let leading = if this.multiple {
+                                            Some(LeadingContent::Emoji(
+                                                choice_selection_indicator(true, is_selected)
+                                                    .into(),
+                                            ))
+                                        } else {
+                                            Some(leading_content_from_icon_kind(
+                                                icon_kind_from_choice(choice),
+                                            ))
+                                        };
                                         let subtitle = indexed_choice
                                             .metadata
                                             .subtitle_text()
@@ -185,34 +271,61 @@
                                                     ))
                                                 },
                                             );
-
-                                        rows.push(
-                                            div()
-                                                .id(display_idx)
-                                                .w_full()
-                                                .h(px(LIST_ITEM_HEIGHT))
-                                                .border_b_1()
-                                                .border_color(border_color)
-                                                .child(
-                                                    UnifiedListItem::new(
-                                                        gpui::ElementId::Name(semantic_id.into()),
-                                                        title,
-                                                    )
-                                                    .subtitle_opt(subtitle)
-                                                    .leading(LeadingContent::Emoji(
-                                                        indicator.into(),
-                                                    ))
-                                                    .trailing_opt(trailing)
-                                                    .state(ItemState {
-                                                        is_selected: is_focused,
-                                                        is_hovered: false,
-                                                        is_disabled: false,
-                                                    })
-                                                    .density(Density::Comfortable)
-                                                    .colors(row_colors)
-                                                    .with_accent_bar(is_selected_for_ui),
-                                                ),
+                                        let row_bg = if is_focused {
+                                            focused_row_bg
+                                        } else if is_hovered {
+                                            hovered_row_bg
+                                        } else {
+                                            rgba(0x00000000)
+                                        };
+                                        let hover_handler = cx.listener(
+                                            move |this: &mut SelectPrompt,
+                                                  hovered: &bool,
+                                                  _window,
+                                                  cx| {
+                                                if *hovered {
+                                                    if this.hovered_index != Some(display_idx) {
+                                                        this.hovered_index = Some(display_idx);
+                                                        cx.notify();
+                                                    }
+                                                } else if this.hovered_index == Some(display_idx)
+                                                {
+                                                    this.hovered_index = None;
+                                                    cx.notify();
+                                                }
+                                            },
                                         );
+
+                                        let mut row = div()
+                                            .id(display_idx)
+                                            .w_full()
+                                            .h(px(LIST_ITEM_HEIGHT))
+                                            .rounded(px(8.0))
+                                            .bg(row_bg)
+                                            .cursor_pointer()
+                                            .on_hover(hover_handler)
+                                            .child(
+                                                UnifiedListItem::new(
+                                                    gpui::ElementId::Name(semantic_id.into()),
+                                                    title,
+                                                )
+                                                .subtitle_opt(subtitle)
+                                                .leading_opt(leading)
+                                                .trailing_opt(trailing)
+                                                .state(ItemState {
+                                                    is_selected,
+                                                    is_hovered,
+                                                    is_disabled: false,
+                                                })
+                                                .density(Density::Comfortable)
+                                                .colors(item_colors),
+                                            );
+
+                                        if !is_focused {
+                                            row = row.hover(move |s| s.bg(hovered_row_bg));
+                                        }
+
+                                        rows.push(row);
                                     }
                                 }
                             }
@@ -234,6 +347,7 @@
             .flex_col()
             .flex_1()
             .w_full()
+            .px(px(8.0))
             .child(choices_content);
 
         div()

file update:
diff --git a/src/list_item/part_000.rs b/src/list_item/part_000.rs
index 733d4ac2aa5b1b27b29a5999310e6f3f45cc54c3..283b2263d56a92c73c22d44443db7b40971d26ce
--- a/src/list_item/part_000.rs
+++ b/src/list_item/part_000.rs
@@ -15,6 +15,37 @@
     /// Maps to IconName from designs::icon_variations
     Svg(String),
 }
+
+impl IconKind {
+    /// Resolve icon metadata into an IconKind for list rendering.
+    ///
+    /// Supports:
+    /// - Known SVG names/aliases via `icon_name_from_str` (e.g., "Terminal", "file-code")
+    /// - Emoji/symbol glyphs (e.g., "üìÑ", "‚ö°")
+    pub fn from_icon_hint(icon_hint: &str) -> Option<Self> {
+        let trimmed = icon_hint.trim();
+        if trimmed.is_empty() {
+            return None;
+        }
+
+        if icon_name_from_str(trimmed).is_some() {
+            return Some(Self::Svg(trimmed.to_string()));
+        }
+
+        if looks_like_symbol_icon_hint(trimmed) {
+            return Some(Self::Emoji(trimmed.to_string()));
+        }
+
+        None
+    }
+}
+
+fn looks_like_symbol_icon_hint(icon_hint: &str) -> bool {
+    let has_ascii_alnum = icon_hint.chars().any(|ch| ch.is_ascii_alphanumeric());
+    let char_count = icon_hint.chars().count();
+
+    !has_ascii_alnum && char_count <= 4
+}
 /// Fixed height for list items used in uniform-height virtualized lists.
 ///
 /// IMPORTANT: When using GPUI `uniform_list`, the item closure must render
@@ -437,3 +468,29 @@
     /// Text color for content displayed on accent/warning backgrounds
     pub text_on_accent: u32,
 }
+
+#[cfg(test)]
+mod icon_kind_tests {
+    use super::IconKind;
+
+    #[test]
+    fn test_icon_kind_from_icon_hint_returns_svg_when_known_icon_name() {
+        match IconKind::from_icon_hint("terminal") {
+            Some(IconKind::Svg(name)) => assert_eq!(name, "terminal"),
+            _ => panic!("expected SVG icon from known icon hint"),
+        }
+    }
+
+    #[test]
+    fn test_icon_kind_from_icon_hint_returns_emoji_when_symbol_glyph() {
+        match IconKind::from_icon_hint("üìÑ") {
+            Some(IconKind::Emoji(emoji)) => assert_eq!(emoji, "üìÑ"),
+            _ => panic!("expected emoji icon for symbol glyph"),
+        }
+    }
+
+    #[test]
+    fn test_icon_kind_from_icon_hint_returns_none_for_unknown_ascii_word() {
+        assert!(IconKind::from_icon_hint("unknown-icon-name").is_none());
+    }
+}
diff --git a/src/prompts/select/mod.rs b/src/prompts/select/mod.rs
index b6366dabfb14f3fae09f854f9de824fa629e0a3b..32ec6dd9fa7ee4b5d29009f3cc5a665713f97a10
--- a/src/prompts/select/mod.rs
+++ b/src/prompts/select/mod.rs
@@ -19,7 +19,7 @@
     UnifiedListItemColors,
 };
 use crate::designs::{get_tokens, DesignColors, DesignVariant};
-use crate::list_item::LIST_ITEM_HEIGHT;
+use crate::list_item::{IconKind, LIST_ITEM_HEIGHT};
 use crate::logging;
 use crate::panel::PROMPT_INPUT_FIELD_HEIGHT;
 use crate::protocol::{generate_semantic_id, Choice};
@@ -37,5 +37,5 @@
 mod types;
 
 pub use prompt::SelectPrompt;
-use search::*;
-use types::*;
+pub(super) use search::*;
+pub(super) use types::*;
diff --git a/src/prompts/select/prompt.rs b/src/prompts/select/prompt.rs
index c5f98f5318f5b520e9223811f735e866ee06e7fb..5ba2de479b2f5680a73db72642377f68d26ee54e
--- a/src/prompts/select/prompt.rs
+++ b/src/prompts/select/prompt.rs
@@ -19,6 +19,8 @@
     pub filtered_choices: Vec<usize>,
     /// Currently focused index in filtered list
     pub focused_index: usize,
+    /// Currently hovered index in filtered list
+    pub hovered_index: Option<usize>,
     /// Filter text
     pub filter_text: String,
     /// Whether multiple selection is allowed
@@ -68,6 +70,7 @@
             selected: HashSet::new(),
             filtered_choices,
             focused_index: 0,
+            hovered_index: None,
             filter_text: String::new(),
             multiple,
             focus_handle,
@@ -84,6 +87,7 @@
         if trimmed_filter.is_empty() {
             self.filtered_choices = (0..self.choices.len()).collect();
             self.focused_index = 0;
+            self.hovered_index = None;
             return;
         }
 
@@ -109,6 +113,7 @@
 
         self.filtered_choices = scored_matches.into_iter().map(|(idx, _)| idx).collect();
         self.focused_index = 0;
+        self.hovered_index = None;
     }
 
     /// Set the filter text programmatically
@@ -168,6 +173,7 @@
     pub(super) fn move_up(&mut self, cx: &mut Context<Self>) {
         if self.focused_index > 0 {
             self.focused_index -= 1;
+            self.hovered_index = None;
             self.list_scroll_handle
                 .scroll_to_item(self.focused_index, ScrollStrategy::Nearest);
             cx.notify();
@@ -178,6 +184,7 @@
     pub(super) fn move_down(&mut self, cx: &mut Context<Self>) {
         if self.focused_index < self.filtered_choices.len().saturating_sub(1) {
             self.focused_index += 1;
+            self.hovered_index = None;
             self.list_scroll_handle
                 .scroll_to_item(self.focused_index, ScrollStrategy::Nearest);
             cx.notify();
diff --git a/src/prompts/select/render.rs b/src/prompts/select/render.rs
index 62109896c9c14b1b2fbf5b4d25d5d94e4388e4aa..51f373592c3f39e1d2ec79e3dbeb9e3827e9bf28
--- a/src/prompts/select/render.rs
+++ b/src/prompts/select/render.rs
@@ -1,5 +1,78 @@
 use super::*;
 
+const ROW_FOCUSED_BG_ALPHA: u32 = 0x3A;
+const ROW_HOVER_BG_ALPHA: u32 = 0x26;
+
+#[derive(Clone, Copy, Debug, PartialEq, Eq)]
+pub(super) struct SelectRowState {
+    pub is_focused: bool,
+    pub is_selected: bool,
+    pub is_hovered: bool,
+}
+
+pub(super) fn compute_row_state(
+    display_idx: usize,
+    focused_index: usize,
+    choice_idx: usize,
+    selected: &HashSet<usize>,
+    hovered_index: Option<usize>,
+) -> SelectRowState {
+    SelectRowState {
+        is_focused: display_idx == focused_index,
+        is_selected: selected.contains(&choice_idx),
+        is_hovered: hovered_index == Some(display_idx),
+    }
+}
+
+pub(super) fn extract_choice_icon_hint(description: Option<&str>) -> Option<&str> {
+    description.and_then(|raw| {
+        raw.split(['‚Ä¢', '|', '\n'])
+            .map(str::trim)
+            .find_map(|token| {
+                let token_lower = token.to_ascii_lowercase();
+                if token_lower == "icon"
+                    || token_lower.starts_with("icon:")
+                    || token_lower.starts_with("icon=")
+                    || token_lower.starts_with("icon ")
+                {
+                    token
+                        .split_once(':')
+                        .or_else(|| token.split_once('='))
+                        .map(|(_, value)| value.trim())
+                        .or_else(|| token.split_whitespace().nth(1))
+                } else {
+                    None
+                }
+            })
+            .filter(|value| !value.is_empty())
+    })
+}
+
+pub(super) fn icon_kind_from_choice(choice: &Choice) -> IconKind {
+    let metadata_icon = extract_choice_icon_hint(choice.description.as_deref())
+        .and_then(IconKind::from_icon_hint);
+    let name_prefix_icon = choice
+        .name
+        .split_whitespace()
+        .next()
+        .and_then(IconKind::from_icon_hint);
+
+    metadata_icon
+        .or(name_prefix_icon)
+        .unwrap_or_else(|| IconKind::Svg("Code".to_string()))
+}
+
+fn leading_content_from_icon_kind(icon_kind: IconKind) -> LeadingContent {
+    match icon_kind {
+        IconKind::Emoji(emoji) => LeadingContent::Emoji(emoji.into()),
+        IconKind::Image(render_image) => LeadingContent::AppIcon(render_image),
+        IconKind::Svg(name) => LeadingContent::Icon {
+            name: SharedString::from(name),
+            color: None,
+        },
+    }
+}
+
 impl Focusable for SelectPrompt {
     fn focus_handle(&self, _cx: &gpui::App) -> FocusHandle {
         self.focus_handle.clone()
@@ -76,6 +149,13 @@
             self.design_variant,
             &colors,
         ));
+        let row_accent_color = if self.design_variant == DesignVariant::Default {
+            self.theme.colors.accent.selected
+        } else {
+            colors.accent
+        };
+        let focused_row_bg = rgba((row_accent_color << 8) | ROW_FOCUSED_BG_ALPHA);
+        let hovered_row_bg = rgba((row_accent_color << 8) | ROW_HOVER_BG_ALPHA);
 
         let placeholder = self
             .placeholder
@@ -145,8 +225,12 @@
                     move |this: &mut SelectPrompt,
                           visible_range: std::ops::Range<usize>,
                           _window,
-                          _cx| {
-                        let row_colors = UnifiedListItemColors::from_theme(&this.theme);
+                          cx| {
+                        let item_colors = UnifiedListItemColors {
+                            selected_opacity: 0.0,
+                            hover_opacity: 0.0,
+                            ..UnifiedListItemColors::from_theme(&this.theme)
+                        };
                         let mut rows = Vec::with_capacity(visible_range.len());
 
                         for display_idx in visible_range {
@@ -156,19 +240,21 @@
                                     {
                                         let is_focused = display_idx == this.focused_index;
                                         let is_selected = this.selected.contains(&choice_idx);
-                                        let is_selected_for_ui = if this.multiple {
-                                            is_selected
-                                        } else {
-                                            is_focused
-                                        };
+                                        let is_hovered = this.hovered_index == Some(display_idx);
                                         let semantic_id =
                                             choice.semantic_id.clone().unwrap_or_else(|| {
                                                 indexed_choice.stable_semantic_id.clone()
                                             });
-                                        let indicator = choice_selection_indicator(
-                                            this.multiple,
-                                            is_selected_for_ui,
-                                        );
+                                        let leading = if this.multiple {
+                                            Some(LeadingContent::Emoji(
+                                                choice_selection_indicator(true, is_selected)
+                                                    .into(),
+                                            ))
+                                        } else {
+                                            Some(leading_content_from_icon_kind(
+                                                icon_kind_from_choice(choice),
+                                            ))
+                                        };
                                         let subtitle = indexed_choice
                                             .metadata
                                             .subtitle_text()
@@ -185,34 +271,61 @@
                                                     ))
                                                 },
                                             );
-
-                                        rows.push(
-                                            div()
-                                                .id(display_idx)
-                                                .w_full()
-                                                .h(px(LIST_ITEM_HEIGHT))
-                                                .border_b_1()
-                                                .border_color(border_color)
-                                                .child(
-                                                    UnifiedListItem::new(
-                                                        gpui::ElementId::Name(semantic_id.into()),
-                                                        title,
-                                                    )
-                                                    .subtitle_opt(subtitle)
-                                                    .leading(LeadingContent::Emoji(
-                                                        indicator.into(),
-                                                    ))
-                                                    .trailing_opt(trailing)
-                                                    .state(ItemState {
-                                                        is_selected: is_focused,
-                                                        is_hovered: false,
-                                                        is_disabled: false,
-                                                    })
-                                                    .density(Density::Comfortable)
-                                                    .colors(row_colors)
-                                                    .with_accent_bar(is_selected_for_ui),
-                                                ),
+                                        let row_bg = if is_focused {
+                                            focused_row_bg
+                                        } else if is_hovered {
+                                            hovered_row_bg
+                                        } else {
+                                            rgba(0x00000000)
+                                        };
+                                        let hover_handler = cx.listener(
+                                            move |this: &mut SelectPrompt,
+                                                  hovered: &bool,
+                                                  _window,
+                                                  cx| {
+                                                if *hovered {
+                                                    if this.hovered_index != Some(display_idx) {
+                                                        this.hovered_index = Some(display_idx);
+                                                        cx.notify();
+                                                    }
+                                                } else if this.hovered_index == Some(display_idx)
+                                                {
+                                                    this.hovered_index = None;
+                                                    cx.notify();
+                                                }
+                                            },
                                         );
+
+                                        let mut row = div()
+                                            .id(display_idx)
+                                            .w_full()
+                                            .h(px(LIST_ITEM_HEIGHT))
+                                            .rounded(px(8.0))
+                                            .bg(row_bg)
+                                            .cursor_pointer()
+                                            .on_hover(hover_handler)
+                                            .child(
+                                                UnifiedListItem::new(
+                                                    gpui::ElementId::Name(semantic_id.into()),
+                                                    title,
+                                                )
+                                                .subtitle_opt(subtitle)
+                                                .leading_opt(leading)
+                                                .trailing_opt(trailing)
+                                                .state(ItemState {
+                                                    is_selected,
+                                                    is_hovered,
+                                                    is_disabled: false,
+                                                })
+                                                .density(Density::Comfortable)
+                                                .colors(item_colors),
+                                            );
+
+                                        if !is_focused {
+                                            row = row.hover(move |s| s.bg(hovered_row_bg));
+                                        }
+
+                                        rows.push(row);
                                     }
                                 }
                             }
@@ -234,6 +347,7 @@
             .flex_col()
             .flex_1()
             .w_full()
+            .px(px(8.0))
             .child(choices_content);
 
         div()


thinking
**Updating state computation loop**
file update
M /Users/johnlindquist/dev/script-kit-gpui/src/prompts/select/render.rs
@@ -240,5 +240,12 @@
                                     {
-                                        let is_focused = display_idx == this.focused_index;
-                                        let is_selected = this.selected.contains(&choice_idx);
-                                        let is_hovered = this.hovered_index == Some(display_idx);
+                                        let row_state = compute_row_state(
+                                            display_idx,
+                                            this.focused_index,
+                                            choice_idx,
+                                            &this.selected,
+                                            this.hovered_index,
+                                        );
+                                        let is_focused = row_state.is_focused;
+                                        let is_selected = row_state.is_selected;
+                                        let is_hovered = row_state.is_hovered;
                                         let semantic_id =
apply_patch(auto_approved=true) exited 0 in 26ms:
Success. Updated the following files:
M /Users/johnlindquist/dev/script-kit-gpui/src/prompts/select/render.rs
file update:
diff --git a/src/list_item/part_000.rs b/src/list_item/part_000.rs
index 733d4ac2aa5b1b27b29a5999310e6f3f45cc54c3..283b2263d56a92c73c22d44443db7b40971d26ce
--- a/src/list_item/part_000.rs
+++ b/src/list_item/part_000.rs
@@ -15,6 +15,37 @@
     /// Maps to IconName from designs::icon_variations
     Svg(String),
 }
+
+impl IconKind {
+    /// Resolve icon metadata into an IconKind for list rendering.
+    ///
+    /// Supports:
+    /// - Known SVG names/aliases via `icon_name_from_str` (e.g., "Terminal", "file-code")
+    /// - Emoji/symbol glyphs (e.g., "üìÑ", "‚ö°")
+    pub fn from_icon_hint(icon_hint: &str) -> Option<Self> {
+        let trimmed = icon_hint.trim();
+        if trimmed.is_empty() {
+            return None;
+        }
+
+        if icon_name_from_str(trimmed).is_some() {
+            return Some(Self::Svg(trimmed.to_string()));
+        }
+
+        if looks_like_symbol_icon_hint(trimmed) {
+            return Some(Self::Emoji(trimmed.to_string()));
+        }
+
+        None
+    }
+}
+
+fn looks_like_symbol_icon_hint(icon_hint: &str) -> bool {
+    let has_ascii_alnum = icon_hint.chars().any(|ch| ch.is_ascii_alphanumeric());
+    let char_count = icon_hint.chars().count();
+
+    !has_ascii_alnum && char_count <= 4
+}
 /// Fixed height for list items used in uniform-height virtualized lists.
 ///
 /// IMPORTANT: When using GPUI `uniform_list`, the item closure must render
@@ -437,3 +468,29 @@
     /// Text color for content displayed on accent/warning backgrounds
     pub text_on_accent: u32,
 }
+
+#[cfg(test)]
+mod icon_kind_tests {
+    use super::IconKind;
+
+    #[test]
+    fn test_icon_kind_from_icon_hint_returns_svg_when_known_icon_name() {
+        match IconKind::from_icon_hint("terminal") {
+            Some(IconKind::Svg(name)) => assert_eq!(name, "terminal"),
+            _ => panic!("expected SVG icon from known icon hint"),
+        }
+    }
+
+    #[test]
+    fn test_icon_kind_from_icon_hint_returns_emoji_when_symbol_glyph() {
+        match IconKind::from_icon_hint("üìÑ") {
+            Some(IconKind::Emoji(emoji)) => assert_eq!(emoji, "üìÑ"),
+            _ => panic!("expected emoji icon for symbol glyph"),
+        }
+    }
+
+    #[test]
+    fn test_icon_kind_from_icon_hint_returns_none_for_unknown_ascii_word() {
+        assert!(IconKind::from_icon_hint("unknown-icon-name").is_none());
+    }
+}
diff --git a/src/prompts/select/mod.rs b/src/prompts/select/mod.rs
index b6366dabfb14f3fae09f854f9de824fa629e0a3b..32ec6dd9fa7ee4b5d29009f3cc5a665713f97a10
--- a/src/prompts/select/mod.rs
+++ b/src/prompts/select/mod.rs
@@ -19,7 +19,7 @@
     UnifiedListItemColors,
 };
 use crate::designs::{get_tokens, DesignColors, DesignVariant};
-use crate::list_item::LIST_ITEM_HEIGHT;
+use crate::list_item::{IconKind, LIST_ITEM_HEIGHT};
 use crate::logging;
 use crate::panel::PROMPT_INPUT_FIELD_HEIGHT;
 use crate::protocol::{generate_semantic_id, Choice};
@@ -37,5 +37,5 @@
 mod types;
 
 pub use prompt::SelectPrompt;
-use search::*;
-use types::*;
+pub(super) use search::*;
+pub(super) use types::*;
diff --git a/src/prompts/select/prompt.rs b/src/prompts/select/prompt.rs
index c5f98f5318f5b520e9223811f735e866ee06e7fb..5ba2de479b2f5680a73db72642377f68d26ee54e
--- a/src/prompts/select/prompt.rs
+++ b/src/prompts/select/prompt.rs
@@ -19,6 +19,8 @@
     pub filtered_choices: Vec<usize>,
     /// Currently focused index in filtered list
     pub focused_index: usize,
+    /// Currently hovered index in filtered list
+    pub hovered_index: Option<usize>,
     /// Filter text
     pub filter_text: String,
     /// Whether multiple selection is allowed
@@ -68,6 +70,7 @@
             selected: HashSet::new(),
             filtered_choices,
             focused_index: 0,
+            hovered_index: None,
             filter_text: String::new(),
             multiple,
             focus_handle,
@@ -84,6 +87,7 @@
         if trimmed_filter.is_empty() {
             self.filtered_choices = (0..self.choices.len()).collect();
             self.focused_index = 0;
+            self.hovered_index = None;
             return;
         }
 
@@ -109,6 +113,7 @@
 
         self.filtered_choices = scored_matches.into_iter().map(|(idx, _)| idx).collect();
         self.focused_index = 0;
+        self.hovered_index = None;
     }
 
     /// Set the filter text programmatically
@@ -168,6 +173,7 @@
     pub(super) fn move_up(&mut self, cx: &mut Context<Self>) {
         if self.focused_index > 0 {
             self.focused_index -= 1;
+            self.hovered_index = None;
             self.list_scroll_handle
                 .scroll_to_item(self.focused_index, ScrollStrategy::Nearest);
             cx.notify();
@@ -178,6 +184,7 @@
     pub(super) fn move_down(&mut self, cx: &mut Context<Self>) {
         if self.focused_index < self.filtered_choices.len().saturating_sub(1) {
             self.focused_index += 1;
+            self.hovered_index = None;
             self.list_scroll_handle
                 .scroll_to_item(self.focused_index, ScrollStrategy::Nearest);
             cx.notify();
diff --git a/src/prompts/select/render.rs b/src/prompts/select/render.rs
index 62109896c9c14b1b2fbf5b4d25d5d94e4388e4aa..3c832dcfad01f574b54ee23e3c0881d24b57a6b2
--- a/src/prompts/select/render.rs
+++ b/src/prompts/select/render.rs
@@ -1,5 +1,78 @@
 use super::*;
 
+const ROW_FOCUSED_BG_ALPHA: u32 = 0x3A;
+const ROW_HOVER_BG_ALPHA: u32 = 0x26;
+
+#[derive(Clone, Copy, Debug, PartialEq, Eq)]
+pub(super) struct SelectRowState {
+    pub is_focused: bool,
+    pub is_selected: bool,
+    pub is_hovered: bool,
+}
+
+pub(super) fn compute_row_state(
+    display_idx: usize,
+    focused_index: usize,
+    choice_idx: usize,
+    selected: &HashSet<usize>,
+    hovered_index: Option<usize>,
+) -> SelectRowState {
+    SelectRowState {
+        is_focused: display_idx == focused_index,
+        is_selected: selected.contains(&choice_idx),
+        is_hovered: hovered_index == Some(display_idx),
+    }
+}
+
+pub(super) fn extract_choice_icon_hint(description: Option<&str>) -> Option<&str> {
+    description.and_then(|raw| {
+        raw.split(['‚Ä¢', '|', '\n'])
+            .map(str::trim)
+            .find_map(|token| {
+                let token_lower = token.to_ascii_lowercase();
+                if token_lower == "icon"
+                    || token_lower.starts_with("icon:")
+                    || token_lower.starts_with("icon=")
+                    || token_lower.starts_with("icon ")
+                {
+                    token
+                        .split_once(':')
+                        .or_else(|| token.split_once('='))
+                        .map(|(_, value)| value.trim())
+                        .or_else(|| token.split_whitespace().nth(1))
+                } else {
+                    None
+                }
+            })
+            .filter(|value| !value.is_empty())
+    })
+}
+
+pub(super) fn icon_kind_from_choice(choice: &Choice) -> IconKind {
+    let metadata_icon = extract_choice_icon_hint(choice.description.as_deref())
+        .and_then(IconKind::from_icon_hint);
+    let name_prefix_icon = choice
+        .name
+        .split_whitespace()
+        .next()
+        .and_then(IconKind::from_icon_hint);
+
+    metadata_icon
+        .or(name_prefix_icon)
+        .unwrap_or_else(|| IconKind::Svg("Code".to_string()))
+}
+
+fn leading_content_from_icon_kind(icon_kind: IconKind) -> LeadingContent {
+    match icon_kind {
+        IconKind::Emoji(emoji) => LeadingContent::Emoji(emoji.into()),
+        IconKind::Image(render_image) => LeadingContent::AppIcon(render_image),
+        IconKind::Svg(name) => LeadingContent::Icon {
+            name: SharedString::from(name),
+            color: None,
+        },
+    }
+}
+
 impl Focusable for SelectPrompt {
     fn focus_handle(&self, _cx: &gpui::App) -> FocusHandle {
         self.focus_handle.clone()
@@ -76,6 +149,13 @@
             self.design_variant,
             &colors,
         ));
+        let row_accent_color = if self.design_variant == DesignVariant::Default {
+            self.theme.colors.accent.selected
+        } else {
+            colors.accent
+        };
+        let focused_row_bg = rgba((row_accent_color << 8) | ROW_FOCUSED_BG_ALPHA);
+        let hovered_row_bg = rgba((row_accent_color << 8) | ROW_HOVER_BG_ALPHA);
 
         let placeholder = self
             .placeholder
@@ -145,8 +225,12 @@
                     move |this: &mut SelectPrompt,
                           visible_range: std::ops::Range<usize>,
                           _window,
-                          _cx| {
-                        let row_colors = UnifiedListItemColors::from_theme(&this.theme);
+                          cx| {
+                        let item_colors = UnifiedListItemColors {
+                            selected_opacity: 0.0,
+                            hover_opacity: 0.0,
+                            ..UnifiedListItemColors::from_theme(&this.theme)
+                        };
                         let mut rows = Vec::with_capacity(visible_range.len());
 
                         for display_idx in visible_range {
@@ -154,21 +238,30 @@
                                 if let Some(choice) = this.choices.get(choice_idx) {
                                     if let Some(indexed_choice) = this.choice_index.get(choice_idx)
                                     {
-                                        let is_focused = display_idx == this.focused_index;
-                                        let is_selected = this.selected.contains(&choice_idx);
-                                        let is_selected_for_ui = if this.multiple {
-                                            is_selected
-                                        } else {
-                                            is_focused
-                                        };
+                                        let row_state = compute_row_state(
+                                            display_idx,
+                                            this.focused_index,
+                                            choice_idx,
+                                            &this.selected,
+                                            this.hovered_index,
+                                        );
+                                        let is_focused = row_state.is_focused;
+                                        let is_selected = row_state.is_selected;
+                                        let is_hovered = row_state.is_hovered;
                                         let semantic_id =
                                             choice.semantic_id.clone().unwrap_or_else(|| {
                                                 indexed_choice.stable_semantic_id.clone()
                                             });
-                                        let indicator = choice_selection_indicator(
-                                            this.multiple,
-                                            is_selected_for_ui,
-                                        );
+                                        let leading = if this.multiple {
+                                            Some(LeadingContent::Emoji(
+                                                choice_selection_indicator(true, is_selected)
+                                                    .into(),
+                                            ))
+                                        } else {
+                                            Some(leading_content_from_icon_kind(
+                                                icon_kind_from_choice(choice),
+                                            ))
+                                        };
                                         let subtitle = indexed_choice
                                             .metadata
                                             .subtitle_text()
@@ -185,34 +278,61 @@
                                                     ))
                                                 },
                                             );
+                                        let row_bg = if is_focused {
+                                            focused_row_bg
+                                        } else if is_hovered {
+                                            hovered_row_bg
+                                        } else {
+                                            rgba(0x00000000)
+                                        };
+                                        let hover_handler = cx.listener(
+                                            move |this: &mut SelectPrompt,
+                                                  hovered: &bool,
+                                                  _window,
+                                                  cx| {
+                                                if *hovered {
+                                                    if this.hovered_index != Some(display_idx) {
+                                                        this.hovered_index = Some(display_idx);
+                                                        cx.notify();
+                                                    }
+                                                } else if this.hovered_index == Some(display_idx)
+                                                {
+                                                    this.hovered_index = None;
+                                                    cx.notify();
+                                                }
+                                            },
+                                        );
+
+                                        let mut row = div()
+                                            .id(display_idx)
+                                            .w_full()
+                                            .h(px(LIST_ITEM_HEIGHT))
+                                            .rounded(px(8.0))
+                                            .bg(row_bg)
+                                            .cursor_pointer()
+                                            .on_hover(hover_handler)
+                                            .child(
+                                                UnifiedListItem::new(
+                                                    gpui::ElementId::Name(semantic_id.into()),
+                                                    title,
+                                                )
+                                                .subtitle_opt(subtitle)
+                                                .leading_opt(leading)
+                                                .trailing_opt(trailing)
+                                                .state(ItemState {
+                                                    is_selected,
+                                                    is_hovered,
+                                                    is_disabled: false,
+                                                })
+                                                .density(Density::Comfortable)
+                                                .colors(item_colors),
+                                            );
+
+                                        if !is_focused {
+                                            row = row.hover(move |s| s.bg(hovered_row_bg));
+                                        }
 
-                                        rows.push(
-                                            div()
-                                                .id(display_idx)
-                                                .w_full()
-                                                .h(px(LIST_ITEM_HEIGHT))
-                                                .border_b_1()
-                                                .border_color(border_color)
-                                                .child(
-                                                    UnifiedListItem::new(
-                                                        gpui::ElementId::Name(semantic_id.into()),
-                                                        title,
-                                                    )
-                                                    .subtitle_opt(subtitle)
-                                                    .leading(LeadingContent::Emoji(
-                                                        indicator.into(),
-                                                    ))
-                                                    .trailing_opt(trailing)
-                                                    .state(ItemState {
-                                                        is_selected: is_focused,
-                                                        is_hovered: false,
-                                                        is_disabled: false,
-                                                    })
-                                                    .density(Density::Comfortable)
-                                                    .colors(row_colors)
-                                                    .with_accent_bar(is_selected_for_ui),
-                                                ),
-                                        );
+                                        rows.push(row);
                                     }
                                 }
                             }
@@ -234,6 +354,7 @@
             .flex_col()
             .flex_1()
             .w_full()
+            .px(px(8.0))
             .child(choices_content);
 
         div()

file update:
diff --git a/src/list_item/part_000.rs b/src/list_item/part_000.rs
index 733d4ac2aa5b1b27b29a5999310e6f3f45cc54c3..283b2263d56a92c73c22d44443db7b40971d26ce
--- a/src/list_item/part_000.rs
+++ b/src/list_item/part_000.rs
@@ -15,6 +15,37 @@
     /// Maps to IconName from designs::icon_variations
     Svg(String),
 }
+
+impl IconKind {
+    /// Resolve icon metadata into an IconKind for list rendering.
+    ///
+    /// Supports:
+    /// - Known SVG names/aliases via `icon_name_from_str` (e.g., "Terminal", "file-code")
+    /// - Emoji/symbol glyphs (e.g., "üìÑ", "‚ö°")
+    pub fn from_icon_hint(icon_hint: &str) -> Option<Self> {
+        let trimmed = icon_hint.trim();
+        if trimmed.is_empty() {
+            return None;
+        }
+
+        if icon_name_from_str(trimmed).is_some() {
+            return Some(Self::Svg(trimmed.to_string()));
+        }
+
+        if looks_like_symbol_icon_hint(trimmed) {
+            return Some(Self::Emoji(trimmed.to_string()));
+        }
+
+        None
+    }
+}
+
+fn looks_like_symbol_icon_hint(icon_hint: &str) -> bool {
+    let has_ascii_alnum = icon_hint.chars().any(|ch| ch.is_ascii_alphanumeric());
+    let char_count = icon_hint.chars().count();
+
+    !has_ascii_alnum && char_count <= 4
+}
 /// Fixed height for list items used in uniform-height virtualized lists.
 ///
 /// IMPORTANT: When using GPUI `uniform_list`, the item closure must render
@@ -437,3 +468,29 @@
     /// Text color for content displayed on accent/warning backgrounds
     pub text_on_accent: u32,
 }
+
+#[cfg(test)]
+mod icon_kind_tests {
+    use super::IconKind;
+
+    #[test]
+    fn test_icon_kind_from_icon_hint_returns_svg_when_known_icon_name() {
+        match IconKind::from_icon_hint("terminal") {
+            Some(IconKind::Svg(name)) => assert_eq!(name, "terminal"),
+            _ => panic!("expected SVG icon from known icon hint"),
+        }
+    }
+
+    #[test]
+    fn test_icon_kind_from_icon_hint_returns_emoji_when_symbol_glyph() {
+        match IconKind::from_icon_hint("üìÑ") {
+            Some(IconKind::Emoji(emoji)) => assert_eq!(emoji, "üìÑ"),
+            _ => panic!("expected emoji icon for symbol glyph"),
+        }
+    }
+
+    #[test]
+    fn test_icon_kind_from_icon_hint_returns_none_for_unknown_ascii_word() {
+        assert!(IconKind::from_icon_hint("unknown-icon-name").is_none());
+    }
+}
diff --git a/src/prompts/select/mod.rs b/src/prompts/select/mod.rs
index b6366dabfb14f3fae09f854f9de824fa629e0a3b..32ec6dd9fa7ee4b5d29009f3cc5a665713f97a10
--- a/src/prompts/select/mod.rs
+++ b/src/prompts/select/mod.rs
@@ -19,7 +19,7 @@
     UnifiedListItemColors,
 };
 use crate::designs::{get_tokens, DesignColors, DesignVariant};
-use crate::list_item::LIST_ITEM_HEIGHT;
+use crate::list_item::{IconKind, LIST_ITEM_HEIGHT};
 use crate::logging;
 use crate::panel::PROMPT_INPUT_FIELD_HEIGHT;
 use crate::protocol::{generate_semantic_id, Choice};
@@ -37,5 +37,5 @@
 mod types;
 
 pub use prompt::SelectPrompt;
-use search::*;
-use types::*;
+pub(super) use search::*;
+pub(super) use types::*;
diff --git a/src/prompts/select/prompt.rs b/src/prompts/select/prompt.rs
index c5f98f5318f5b520e9223811f735e866ee06e7fb..5ba2de479b2f5680a73db72642377f68d26ee54e
--- a/src/prompts/select/prompt.rs
+++ b/src/prompts/select/prompt.rs
@@ -19,6 +19,8 @@
     pub filtered_choices: Vec<usize>,
     /// Currently focused index in filtered list
     pub focused_index: usize,
+    /// Currently hovered index in filtered list
+    pub hovered_index: Option<usize>,
     /// Filter text
     pub filter_text: String,
     /// Whether multiple selection is allowed
@@ -68,6 +70,7 @@
             selected: HashSet::new(),
             filtered_choices,
             focused_index: 0,
+            hovered_index: None,
             filter_text: String::new(),
             multiple,
             focus_handle,
@@ -84,6 +87,7 @@
         if trimmed_filter.is_empty() {
             self.filtered_choices = (0..self.choices.len()).collect();
             self.focused_index = 0;
+            self.hovered_index = None;
             return;
         }
 
@@ -109,6 +113,7 @@
 
         self.filtered_choices = scored_matches.into_iter().map(|(idx, _)| idx).collect();
         self.focused_index = 0;
+        self.hovered_index = None;
     }
 
     /// Set the filter text programmatically
@@ -168,6 +173,7 @@
     pub(super) fn move_up(&mut self, cx: &mut Context<Self>) {
         if self.focused_index > 0 {
             self.focused_index -= 1;
+            self.hovered_index = None;
             self.list_scroll_handle
                 .scroll_to_item(self.focused_index, ScrollStrategy::Nearest);
             cx.notify();
@@ -178,6 +184,7 @@
     pub(super) fn move_down(&mut self, cx: &mut Context<Self>) {
         if self.focused_index < self.filtered_choices.len().saturating_sub(1) {
             self.focused_index += 1;
+            self.hovered_index = None;
             self.list_scroll_handle
                 .scroll_to_item(self.focused_index, ScrollStrategy::Nearest);
             cx.notify();
diff --git a/src/prompts/select/render.rs b/src/prompts/select/render.rs
index 62109896c9c14b1b2fbf5b4d25d5d94e4388e4aa..3c832dcfad01f574b54ee23e3c0881d24b57a6b2
--- a/src/prompts/select/render.rs
+++ b/src/prompts/select/render.rs
@@ -1,5 +1,78 @@
 use super::*;
 
+const ROW_FOCUSED_BG_ALPHA: u32 = 0x3A;
+const ROW_HOVER_BG_ALPHA: u32 = 0x26;
+
+#[derive(Clone, Copy, Debug, PartialEq, Eq)]
+pub(super) struct SelectRowState {
+    pub is_focused: bool,
+    pub is_selected: bool,
+    pub is_hovered: bool,
+}
+
+pub(super) fn compute_row_state(
+    display_idx: usize,
+    focused_index: usize,
+    choice_idx: usize,
+    selected: &HashSet<usize>,
+    hovered_index: Option<usize>,
+) -> SelectRowState {
+    SelectRowState {
+        is_focused: display_idx == focused_index,
+        is_selected: selected.contains(&choice_idx),
+        is_hovered: hovered_index == Some(display_idx),
+    }
+}
+
+pub(super) fn extract_choice_icon_hint(description: Option<&str>) -> Option<&str> {
+    description.and_then(|raw| {
+        raw.split(['‚Ä¢', '|', '\n'])
+            .map(str::trim)
+            .find_map(|token| {
+                let token_lower = token.to_ascii_lowercase();
+                if token_lower == "icon"
+                    || token_lower.starts_with("icon:")
+                    || token_lower.starts_with("icon=")
+                    || token_lower.starts_with("icon ")
+                {
+                    token
+                        .split_once(':')
+                        .or_else(|| token.split_once('='))
+                        .map(|(_, value)| value.trim())
+                        .or_else(|| token.split_whitespace().nth(1))
+                } else {
+                    None
+                }
+            })
+            .filter(|value| !value.is_empty())
+    })
+}
+
+pub(super) fn icon_kind_from_choice(choice: &Choice) -> IconKind {
+    let metadata_icon = extract_choice_icon_hint(choice.description.as_deref())
+        .and_then(IconKind::from_icon_hint);
+    let name_prefix_icon = choice
+        .name
+        .split_whitespace()
+        .next()
+        .and_then(IconKind::from_icon_hint);
+
+    metadata_icon
+        .or(name_prefix_icon)
+        .unwrap_or_else(|| IconKind::Svg("Code".to_string()))
+}
+
+fn leading_content_from_icon_kind(icon_kind: IconKind) -> LeadingContent {
+    match icon_kind {
+        IconKind::Emoji(emoji) => LeadingContent::Emoji(emoji.into()),
+        IconKind::Image(render_image) => LeadingContent::AppIcon(render_image),
+        IconKind::Svg(name) => LeadingContent::Icon {
+            name: SharedString::from(name),
+            color: None,
+        },
+    }
+}
+
 impl Focusable for SelectPrompt {
     fn focus_handle(&self, _cx: &gpui::App) -> FocusHandle {
         self.focus_handle.clone()
@@ -76,6 +149,13 @@
             self.design_variant,
             &colors,
         ));
+        let row_accent_color = if self.design_variant == DesignVariant::Default {
+            self.theme.colors.accent.selected
+        } else {
+            colors.accent
+        };
+        let focused_row_bg = rgba((row_accent_color << 8) | ROW_FOCUSED_BG_ALPHA);
+        let hovered_row_bg = rgba((row_accent_color << 8) | ROW_HOVER_BG_ALPHA);
 
         let placeholder = self
             .placeholder
@@ -145,8 +225,12 @@
                     move |this: &mut SelectPrompt,
                           visible_range: std::ops::Range<usize>,
                           _window,
-                          _cx| {
-                        let row_colors = UnifiedListItemColors::from_theme(&this.theme);
+                          cx| {
+                        let item_colors = UnifiedListItemColors {
+                            selected_opacity: 0.0,
+                            hover_opacity: 0.0,
+                            ..UnifiedListItemColors::from_theme(&this.theme)
+                        };
                         let mut rows = Vec::with_capacity(visible_range.len());
 
                         for display_idx in visible_range {
@@ -154,21 +238,30 @@
                                 if let Some(choice) = this.choices.get(choice_idx) {
                                     if let Some(indexed_choice) = this.choice_index.get(choice_idx)
                                     {
-                                        let is_focused = display_idx == this.focused_index;
-                                        let is_selected = this.selected.contains(&choice_idx);
-                                        let is_selected_for_ui = if this.multiple {
-                                            is_selected
-                                        } else {
-                                            is_focused
-                                        };
+                                        let row_state = compute_row_state(
+                                            display_idx,
+                                            this.focused_index,
+                                            choice_idx,
+                                            &this.selected,
+                                            this.hovered_index,
+                                        );
+                                        let is_focused = row_state.is_focused;
+                                        let is_selected = row_state.is_selected;
+                                        let is_hovered = row_state.is_hovered;
                                         let semantic_id =
                                             choice.semantic_id.clone().unwrap_or_else(|| {
                                                 indexed_choice.stable_semantic_id.clone()
                                             });
-                                        let indicator = choice_selection_indicator(
-                                            this.multiple,
-                                            is_selected_for_ui,
-                                        );
+                                        let leading = if this.multiple {
+                                            Some(LeadingContent::Emoji(
+                                                choice_selection_indicator(true, is_selected)
+                                                    .into(),
+                                            ))
+                                        } else {
+                                            Some(leading_content_from_icon_kind(
+                                                icon_kind_from_choice(choice),
+                                            ))
+                                        };
                                         let subtitle = indexed_choice
                                             .metadata
                                             .subtitle_text()
@@ -185,34 +278,61 @@
                                                     ))
                                                 },
                                             );
+                                        let row_bg = if is_focused {
+                                            focused_row_bg
+                                        } else if is_hovered {
+                                            hovered_row_bg
+                                        } else {
+                                            rgba(0x00000000)
+                                        };
+                                        let hover_handler = cx.listener(
+                                            move |this: &mut SelectPrompt,
+                                                  hovered: &bool,
+                                                  _window,
+                                                  cx| {
+                                                if *hovered {
+                                                    if this.hovered_index != Some(display_idx) {
+                                                        this.hovered_index = Some(display_idx);
+                                                        cx.notify();
+                                                    }
+                                                } else if this.hovered_index == Some(display_idx)
+                                                {
+                                                    this.hovered_index = None;
+                                                    cx.notify();
+                                                }
+                                            },
+                                        );
+
+                                        let mut row = div()
+                                            .id(display_idx)
+                                            .w_full()
+                                            .h(px(LIST_ITEM_HEIGHT))
+                                            .rounded(px(8.0))
+                                            .bg(row_bg)
+                                            .cursor_pointer()
+                                            .on_hover(hover_handler)
+                                            .child(
+                                                UnifiedListItem::new(
+                                                    gpui::ElementId::Name(semantic_id.into()),
+                                                    title,
+                                                )
+                                                .subtitle_opt(subtitle)
+                                                .leading_opt(leading)
+                                                .trailing_opt(trailing)
+                                                .state(ItemState {
+                                                    is_selected,
+                                                    is_hovered,
+                                                    is_disabled: false,
+                                                })
+                                                .density(Density::Comfortable)
+                                                .colors(item_colors),
+                                            );
+
+                                        if !is_focused {
+                                            row = row.hover(move |s| s.bg(hovered_row_bg));
+                                        }
 
-                                        rows.push(
-                                            div()
-                                                .id(display_idx)
-                                                .w_full()
-                                                .h(px(LIST_ITEM_HEIGHT))
-                                                .border_b_1()
-                                                .border_color(border_color)
-                                                .child(
-                                                    UnifiedListItem::new(
-                                                        gpui::ElementId::Name(semantic_id.into()),
-                                                        title,
-                                                    )
-                                                    .subtitle_opt(subtitle)
-                                                    .leading(LeadingContent::Emoji(
-                                                        indicator.into(),
-                                                    ))
-                                                    .trailing_opt(trailing)
-                                                    .state(ItemState {
-                                                        is_selected: is_focused,
-                                                        is_hovered: false,
-                                                        is_disabled: false,
-                                                    })
-                                                    .density(Density::Comfortable)
-                                                    .colors(row_colors)
-                                                    .with_accent_bar(is_selected_for_ui),
-                                                ),
-                                        );
+                                        rows.push(row);
                                     }
                                 }
                             }
@@ -234,6 +354,7 @@
             .flex_col()
             .flex_1()
             .w_full()
+            .px(px(8.0))
             .child(choices_content);
 
         div()


thinking
**Adding tests with existing imports**
file update
M /Users/johnlindquist/dev/script-kit-gpui/src/prompts/select/tests.rs
@@ -186 +186,33 @@
 }
+
+#[test]
+fn test_select_prompt_extracts_icon_hint_from_choice_metadata() {
+    let description = Some("Shortcut: cmd+k ‚Ä¢ icon: terminal ‚Ä¢ script");
+    assert_eq!(render::extract_choice_icon_hint(description), Some("terminal"));
+}
+
+#[test]
+fn test_select_prompt_icon_kind_falls_back_to_code_icon_without_hint() {
+    let choice = choice("Deploy API", "/Users/me/.scriptkit/scripts/deploy.ts", None);
+
+    match render::icon_kind_from_choice(&choice) {
+        IconKind::Svg(name) => assert_eq!(name, "Code"),
+        _ => panic!("expected fallback Code SVG icon"),
+    }
+}
+
+#[test]
+fn test_select_prompt_compute_row_state_keeps_focus_and_selection_independent() {
+    let selected = std::collections::HashSet::from([5]);
+    let focused_but_unselected =
+        render::compute_row_state(2, 2, 1, &selected, Some(1));
+    assert!(focused_but_unselected.is_focused);
+    assert!(!focused_but_unselected.is_selected);
+    assert!(!focused_but_unselected.is_hovered);
+
+    let selected_but_unfocused =
+        render::compute_row_state(1, 2, 5, &selected, Some(1));
+    assert!(!selected_but_unfocused.is_focused);
+    assert!(selected_but_unfocused.is_selected);
+    assert!(selected_but_unfocused.is_hovered);
+}
apply_patch(auto_approved=true) exited 0 in 29ms:
Success. Updated the following files:
M /Users/johnlindquist/dev/script-kit-gpui/src/prompts/select/tests.rs
file update:
diff --git a/src/list_item/part_000.rs b/src/list_item/part_000.rs
index 733d4ac2aa5b1b27b29a5999310e6f3f45cc54c3..283b2263d56a92c73c22d44443db7b40971d26ce
--- a/src/list_item/part_000.rs
+++ b/src/list_item/part_000.rs
@@ -15,6 +15,37 @@
     /// Maps to IconName from designs::icon_variations
     Svg(String),
 }
+
+impl IconKind {
+    /// Resolve icon metadata into an IconKind for list rendering.
+    ///
+    /// Supports:
+    /// - Known SVG names/aliases via `icon_name_from_str` (e.g., "Terminal", "file-code")
+    /// - Emoji/symbol glyphs (e.g., "üìÑ", "‚ö°")
+    pub fn from_icon_hint(icon_hint: &str) -> Option<Self> {
+        let trimmed = icon_hint.trim();
+        if trimmed.is_empty() {
+            return None;
+        }
+
+        if icon_name_from_str(trimmed).is_some() {
+            return Some(Self::Svg(trimmed.to_string()));
+        }
+
+        if looks_like_symbol_icon_hint(trimmed) {
+            return Some(Self::Emoji(trimmed.to_string()));
+        }
+
+        None
+    }
+}
+
+fn looks_like_symbol_icon_hint(icon_hint: &str) -> bool {
+    let has_ascii_alnum = icon_hint.chars().any(|ch| ch.is_ascii_alphanumeric());
+    let char_count = icon_hint.chars().count();
+
+    !has_ascii_alnum && char_count <= 4
+}
 /// Fixed height for list items used in uniform-height virtualized lists.
 ///
 /// IMPORTANT: When using GPUI `uniform_list`, the item closure must render
@@ -437,3 +468,29 @@
     /// Text color for content displayed on accent/warning backgrounds
     pub text_on_accent: u32,
 }
+
+#[cfg(test)]
+mod icon_kind_tests {
+    use super::IconKind;
+
+    #[test]
+    fn test_icon_kind_from_icon_hint_returns_svg_when_known_icon_name() {
+        match IconKind::from_icon_hint("terminal") {
+            Some(IconKind::Svg(name)) => assert_eq!(name, "terminal"),
+            _ => panic!("expected SVG icon from known icon hint"),
+        }
+    }
+
+    #[test]
+    fn test_icon_kind_from_icon_hint_returns_emoji_when_symbol_glyph() {
+        match IconKind::from_icon_hint("üìÑ") {
+            Some(IconKind::Emoji(emoji)) => assert_eq!(emoji, "üìÑ"),
+            _ => panic!("expected emoji icon for symbol glyph"),
+        }
+    }
+
+    #[test]
+    fn test_icon_kind_from_icon_hint_returns_none_for_unknown_ascii_word() {
+        assert!(IconKind::from_icon_hint("unknown-icon-name").is_none());
+    }
+}
diff --git a/src/prompts/select/mod.rs b/src/prompts/select/mod.rs
index b6366dabfb14f3fae09f854f9de824fa629e0a3b..32ec6dd9fa7ee4b5d29009f3cc5a665713f97a10
--- a/src/prompts/select/mod.rs
+++ b/src/prompts/select/mod.rs
@@ -19,7 +19,7 @@
     UnifiedListItemColors,
 };
 use crate::designs::{get_tokens, DesignColors, DesignVariant};
-use crate::list_item::LIST_ITEM_HEIGHT;
+use crate::list_item::{IconKind, LIST_ITEM_HEIGHT};
 use crate::logging;
 use crate::panel::PROMPT_INPUT_FIELD_HEIGHT;
 use crate::protocol::{generate_semantic_id, Choice};
@@ -37,5 +37,5 @@
 mod types;
 
 pub use prompt::SelectPrompt;
-use search::*;
-use types::*;
+pub(super) use search::*;
+pub(super) use types::*;
diff --git a/src/prompts/select/prompt.rs b/src/prompts/select/prompt.rs
index c5f98f5318f5b520e9223811f735e866ee06e7fb..5ba2de479b2f5680a73db72642377f68d26ee54e
--- a/src/prompts/select/prompt.rs
+++ b/src/prompts/select/prompt.rs
@@ -19,6 +19,8 @@
     pub filtered_choices: Vec<usize>,
     /// Currently focused index in filtered list
     pub focused_index: usize,
+    /// Currently hovered index in filtered list
+    pub hovered_index: Option<usize>,
     /// Filter text
     pub filter_text: String,
     /// Whether multiple selection is allowed
@@ -68,6 +70,7 @@
             selected: HashSet::new(),
             filtered_choices,
             focused_index: 0,
+            hovered_index: None,
             filter_text: String::new(),
             multiple,
             focus_handle,
@@ -84,6 +87,7 @@
         if trimmed_filter.is_empty() {
             self.filtered_choices = (0..self.choices.len()).collect();
             self.focused_index = 0;
+            self.hovered_index = None;
             return;
         }
 
@@ -109,6 +113,7 @@
 
         self.filtered_choices = scored_matches.into_iter().map(|(idx, _)| idx).collect();
         self.focused_index = 0;
+        self.hovered_index = None;
     }
 
     /// Set the filter text programmatically
@@ -168,6 +173,7 @@
     pub(super) fn move_up(&mut self, cx: &mut Context<Self>) {
         if self.focused_index > 0 {
             self.focused_index -= 1;
+            self.hovered_index = None;
             self.list_scroll_handle
                 .scroll_to_item(self.focused_index, ScrollStrategy::Nearest);
             cx.notify();
@@ -178,6 +184,7 @@
     pub(super) fn move_down(&mut self, cx: &mut Context<Self>) {
         if self.focused_index < self.filtered_choices.len().saturating_sub(1) {
             self.focused_index += 1;
+            self.hovered_index = None;
             self.list_scroll_handle
                 .scroll_to_item(self.focused_index, ScrollStrategy::Nearest);
             cx.notify();
diff --git a/src/prompts/select/render.rs b/src/prompts/select/render.rs
index 62109896c9c14b1b2fbf5b4d25d5d94e4388e4aa..3c832dcfad01f574b54ee23e3c0881d24b57a6b2
--- a/src/prompts/select/render.rs
+++ b/src/prompts/select/render.rs
@@ -1,5 +1,78 @@
 use super::*;
 
+const ROW_FOCUSED_BG_ALPHA: u32 = 0x3A;
+const ROW_HOVER_BG_ALPHA: u32 = 0x26;
+
+#[derive(Clone, Copy, Debug, PartialEq, Eq)]
+pub(super) struct SelectRowState {
+    pub is_focused: bool,
+    pub is_selected: bool,
+    pub is_hovered: bool,
+}
+
+pub(super) fn compute_row_state(
+    display_idx: usize,
+    focused_index: usize,
+    choice_idx: usize,
+    selected: &HashSet<usize>,
+    hovered_index: Option<usize>,
+) -> SelectRowState {
+    SelectRowState {
+        is_focused: display_idx == focused_index,
+        is_selected: selected.contains(&choice_idx),
+        is_hovered: hovered_index == Some(display_idx),
+    }
+}
+
+pub(super) fn extract_choice_icon_hint(description: Option<&str>) -> Option<&str> {
+    description.and_then(|raw| {
+        raw.split(['‚Ä¢', '|', '\n'])
+            .map(str::trim)
+            .find_map(|token| {
+                let token_lower = token.to_ascii_lowercase();
+                if token_lower == "icon"
+                    || token_lower.starts_with("icon:")
+                    || token_lower.starts_with("icon=")
+                    || token_lower.starts_with("icon ")
+                {
+                    token
+                        .split_once(':')
+                        .or_else(|| token.split_once('='))
+                        .map(|(_, value)| value.trim())
+                        .or_else(|| token.split_whitespace().nth(1))
+                } else {
+                    None
+                }
+            })
+            .filter(|value| !value.is_empty())
+    })
+}
+
+pub(super) fn icon_kind_from_choice(choice: &Choice) -> IconKind {
+    let metadata_icon = extract_choice_icon_hint(choice.description.as_deref())
+        .and_then(IconKind::from_icon_hint);
+    let name_prefix_icon = choice
+        .name
+        .split_whitespace()
+        .next()
+        .and_then(IconKind::from_icon_hint);
+
+    metadata_icon
+        .or(name_prefix_icon)
+        .unwrap_or_else(|| IconKind::Svg("Code".to_string()))
+}
+
+fn leading_content_from_icon_kind(icon_kind: IconKind) -> LeadingContent {
+    match icon_kind {
+        IconKind::Emoji(emoji) => LeadingContent::Emoji(emoji.into()),
+        IconKind::Image(render_image) => LeadingContent::AppIcon(render_image),
+        IconKind::Svg(name) => LeadingContent::Icon {
+            name: SharedString::from(name),
+            color: None,
+        },
+    }
+}
+
 impl Focusable for SelectPrompt {
     fn focus_handle(&self, _cx: &gpui::App) -> FocusHandle {
         self.focus_handle.clone()
@@ -76,6 +149,13 @@
             self.design_variant,
             &colors,
         ));
+        let row_accent_color = if self.design_variant == DesignVariant::Default {
+            self.theme.colors.accent.selected
+        } else {
+            colors.accent
+        };
+        let focused_row_bg = rgba((row_accent_color << 8) | ROW_FOCUSED_BG_ALPHA);
+        let hovered_row_bg = rgba((row_accent_color << 8) | ROW_HOVER_BG_ALPHA);
 
         let placeholder = self
             .placeholder
@@ -145,8 +225,12 @@
                     move |this: &mut SelectPrompt,
                           visible_range: std::ops::Range<usize>,
                           _window,
-                          _cx| {
-                        let row_colors = UnifiedListItemColors::from_theme(&this.theme);
+                          cx| {
+                        let item_colors = UnifiedListItemColors {
+                            selected_opacity: 0.0,
+                            hover_opacity: 0.0,
+                            ..UnifiedListItemColors::from_theme(&this.theme)
+                        };
                         let mut rows = Vec::with_capacity(visible_range.len());
 
                         for display_idx in visible_range {
@@ -154,21 +238,30 @@
                                 if let Some(choice) = this.choices.get(choice_idx) {
                                     if let Some(indexed_choice) = this.choice_index.get(choice_idx)
                                     {
-                                        let is_focused = display_idx == this.focused_index;
-                                        let is_selected = this.selected.contains(&choice_idx);
-                                        let is_selected_for_ui = if this.multiple {
-                                            is_selected
-                                        } else {
-                                            is_focused
-                                        };
+                                        let row_state = compute_row_state(
+                                            display_idx,
+                                            this.focused_index,
+                                            choice_idx,
+                                            &this.selected,
+                                            this.hovered_index,
+                                        );
+                                        let is_focused = row_state.is_focused;
+                                        let is_selected = row_state.is_selected;
+                                        let is_hovered = row_state.is_hovered;
                                         let semantic_id =
                                             choice.semantic_id.clone().unwrap_or_else(|| {
                                                 indexed_choice.stable_semantic_id.clone()
                                             });
-                                        let indicator = choice_selection_indicator(
-                                            this.multiple,
-                                            is_selected_for_ui,
-                                        );
+                                        let leading = if this.multiple {
+                                            Some(LeadingContent::Emoji(
+                                                choice_selection_indicator(true, is_selected)
+                                                    .into(),
+                                            ))
+                                        } else {
+                                            Some(leading_content_from_icon_kind(
+                                                icon_kind_from_choice(choice),
+                                            ))
+                                        };
                                         let subtitle = indexed_choice
                                             .metadata
                                             .subtitle_text()
@@ -185,34 +278,61 @@
                                                     ))
                                                 },
                                             );
+                                        let row_bg = if is_focused {
+                                            focused_row_bg
+                                        } else if is_hovered {
+                                            hovered_row_bg
+                                        } else {
+                                            rgba(0x00000000)
+                                        };
+                                        let hover_handler = cx.listener(
+                                            move |this: &mut SelectPrompt,
+                                                  hovered: &bool,
+                                                  _window,
+                                                  cx| {
+                                                if *hovered {
+                                                    if this.hovered_index != Some(display_idx) {
+                                                        this.hovered_index = Some(display_idx);
+                                                        cx.notify();
+                                                    }
+                                                } else if this.hovered_index == Some(display_idx)
+                                                {
+                                                    this.hovered_index = None;
+                                                    cx.notify();
+                                                }
+                                            },
+                                        );
+
+                                        let mut row = div()
+                                            .id(display_idx)
+                                            .w_full()
+                                            .h(px(LIST_ITEM_HEIGHT))
+                                            .rounded(px(8.0))
+                                            .bg(row_bg)
+                                            .cursor_pointer()
+                                            .on_hover(hover_handler)
+                                            .child(
+                                                UnifiedListItem::new(
+                                                    gpui::ElementId::Name(semantic_id.into()),
+                                                    title,
+                                                )
+                                                .subtitle_opt(subtitle)
+                                                .leading_opt(leading)
+                                                .trailing_opt(trailing)
+                                                .state(ItemState {
+                                                    is_selected,
+                                                    is_hovered,
+                                                    is_disabled: false,
+                                                })
+                                                .density(Density::Comfortable)
+                                                .colors(item_colors),
+                                            );
+
+                                        if !is_focused {
+                                            row = row.hover(move |s| s.bg(hovered_row_bg));
+                                        }
 
-                                        rows.push(
-                                            div()
-                                                .id(display_idx)
-                                                .w_full()
-                                                .h(px(LIST_ITEM_HEIGHT))
-                                                .border_b_1()
-                                                .border_color(border_color)
-                                                .child(
-                                                    UnifiedListItem::new(
-                                                        gpui::ElementId::Name(semantic_id.into()),
-                                                        title,
-                                                    )
-                                                    .subtitle_opt(subtitle)
-                                                    .leading(LeadingContent::Emoji(
-                                                        indicator.into(),
-                                                    ))
-                                                    .trailing_opt(trailing)
-                                                    .state(ItemState {
-                                                        is_selected: is_focused,
-                                                        is_hovered: false,
-                                                        is_disabled: false,
-                                                    })
-                                                    .density(Density::Comfortable)
-                                                    .colors(row_colors)
-                                                    .with_accent_bar(is_selected_for_ui),
-                                                ),
-                                        );
+                                        rows.push(row);
                                     }
                                 }
                             }
@@ -234,6 +354,7 @@
             .flex_col()
             .flex_1()
             .w_full()
+            .px(px(8.0))
             .child(choices_content);
 
         div()
diff --git a/src/prompts/select/tests.rs b/src/prompts/select/tests.rs
index 250ec9d63282ad81dd952efa12855f784330232c..948502e17306b114996263c50fbec58a051fa7b4
--- a/src/prompts/select/tests.rs
+++ b/src/prompts/select/tests.rs
@@ -184,3 +184,35 @@
         0x445566
     );
 }
+
+#[test]
+fn test_select_prompt_extracts_icon_hint_from_choice_metadata() {
+    let description = Some("Shortcut: cmd+k ‚Ä¢ icon: terminal ‚Ä¢ script");
+    assert_eq!(render::extract_choice_icon_hint(description), Some("terminal"));
+}
+
+#[test]
+fn test_select_prompt_icon_kind_falls_back_to_code_icon_without_hint() {
+    let choice = choice("Deploy API", "/Users/me/.scriptkit/scripts/deploy.ts", None);
+
+    match render::icon_kind_from_choice(&choice) {
+        IconKind::Svg(name) => assert_eq!(name, "Code"),
+        _ => panic!("expected fallback Code SVG icon"),
+    }
+}
+
+#[test]
+fn test_select_prompt_compute_row_state_keeps_focus_and_selection_independent() {
+    let selected = std::collections::HashSet::from([5]);
+    let focused_but_unselected =
+        render::compute_row_state(2, 2, 1, &selected, Some(1));
+    assert!(focused_but_unselected.is_focused);
+    assert!(!focused_but_unselected.is_selected);
+    assert!(!focused_but_unselected.is_hovered);
+
+    let selected_but_unfocused =
+        render::compute_row_state(1, 2, 5, &selected, Some(1));
+    assert!(!selected_but_unfocused.is_focused);
+    assert!(selected_but_unfocused.is_selected);
+    assert!(selected_but_unfocused.is_hovered);
+}

file update:
diff --git a/src/list_item/part_000.rs b/src/list_item/part_000.rs
index 733d4ac2aa5b1b27b29a5999310e6f3f45cc54c3..283b2263d56a92c73c22d44443db7b40971d26ce
--- a/src/list_item/part_000.rs
+++ b/src/list_item/part_000.rs
@@ -15,6 +15,37 @@
     /// Maps to IconName from designs::icon_variations
     Svg(String),
 }
+
+impl IconKind {
+    /// Resolve icon metadata into an IconKind for list rendering.
+    ///
+    /// Supports:
+    /// - Known SVG names/aliases via `icon_name_from_str` (e.g., "Terminal", "file-code")
+    /// - Emoji/symbol glyphs (e.g., "üìÑ", "‚ö°")
+    pub fn from_icon_hint(icon_hint: &str) -> Option<Self> {
+        let trimmed = icon_hint.trim();
+        if trimmed.is_empty() {
+            return None;
+        }
+
+        if icon_name_from_str(trimmed).is_some() {
+            return Some(Self::Svg(trimmed.to_string()));
+        }
+
+        if looks_like_symbol_icon_hint(trimmed) {
+            return Some(Self::Emoji(trimmed.to_string()));
+        }
+
+        None
+    }
+}
+
+fn looks_like_symbol_icon_hint(icon_hint: &str) -> bool {
+    let has_ascii_alnum = icon_hint.chars().any(|ch| ch.is_ascii_alphanumeric());
+    let char_count = icon_hint.chars().count();
+
+    !has_ascii_alnum && char_count <= 4
+}
 /// Fixed height for list items used in uniform-height virtualized lists.
 ///
 /// IMPORTANT: When using GPUI `uniform_list`, the item closure must render
@@ -437,3 +468,29 @@
     /// Text color for content displayed on accent/warning backgrounds
     pub text_on_accent: u32,
 }
+
+#[cfg(test)]
+mod icon_kind_tests {
+    use super::IconKind;
+
+    #[test]
+    fn test_icon_kind_from_icon_hint_returns_svg_when_known_icon_name() {
+        match IconKind::from_icon_hint("terminal") {
+            Some(IconKind::Svg(name)) => assert_eq!(name, "terminal"),
+            _ => panic!("expected SVG icon from known icon hint"),
+        }
+    }
+
+    #[test]
+    fn test_icon_kind_from_icon_hint_returns_emoji_when_symbol_glyph() {
+        match IconKind::from_icon_hint("üìÑ") {
+            Some(IconKind::Emoji(emoji)) => assert_eq!(emoji, "üìÑ"),
+            _ => panic!("expected emoji icon for symbol glyph"),
+        }
+    }
+
+    #[test]
+    fn test_icon_kind_from_icon_hint_returns_none_for_unknown_ascii_word() {
+        assert!(IconKind::from_icon_hint("unknown-icon-name").is_none());
+    }
+}
diff --git a/src/prompts/select/mod.rs b/src/prompts/select/mod.rs
index b6366dabfb14f3fae09f854f9de824fa629e0a3b..32ec6dd9fa7ee4b5d29009f3cc5a665713f97a10
--- a/src/prompts/select/mod.rs
+++ b/src/prompts/select/mod.rs
@@ -19,7 +19,7 @@
     UnifiedListItemColors,
 };
 use crate::designs::{get_tokens, DesignColors, DesignVariant};
-use crate::list_item::LIST_ITEM_HEIGHT;
+use crate::list_item::{IconKind, LIST_ITEM_HEIGHT};
 use crate::logging;
 use crate::panel::PROMPT_INPUT_FIELD_HEIGHT;
 use crate::protocol::{generate_semantic_id, Choice};
@@ -37,5 +37,5 @@
 mod types;
 
 pub use prompt::SelectPrompt;
-use search::*;
-use types::*;
+pub(super) use search::*;
+pub(super) use types::*;
diff --git a/src/prompts/select/prompt.rs b/src/prompts/select/prompt.rs
index c5f98f5318f5b520e9223811f735e866ee06e7fb..5ba2de479b2f5680a73db72642377f68d26ee54e
--- a/src/prompts/select/prompt.rs
+++ b/src/prompts/select/prompt.rs
@@ -19,6 +19,8 @@
     pub filtered_choices: Vec<usize>,
     /// Currently focused index in filtered list
     pub focused_index: usize,
+    /// Currently hovered index in filtered list
+    pub hovered_index: Option<usize>,
     /// Filter text
     pub filter_text: String,
     /// Whether multiple selection is allowed
@@ -68,6 +70,7 @@
             selected: HashSet::new(),
             filtered_choices,
             focused_index: 0,
+            hovered_index: None,
             filter_text: String::new(),
             multiple,
             focus_handle,
@@ -84,6 +87,7 @@
         if trimmed_filter.is_empty() {
             self.filtered_choices = (0..self.choices.len()).collect();
             self.focused_index = 0;
+            self.hovered_index = None;
             return;
         }
 
@@ -109,6 +113,7 @@
 
         self.filtered_choices = scored_matches.into_iter().map(|(idx, _)| idx).collect();
         self.focused_index = 0;
+        self.hovered_index = None;
     }
 
     /// Set the filter text programmatically
@@ -168,6 +173,7 @@
     pub(super) fn move_up(&mut self, cx: &mut Context<Self>) {
         if self.focused_index > 0 {
             self.focused_index -= 1;
+            self.hovered_index = None;
             self.list_scroll_handle
                 .scroll_to_item(self.focused_index, ScrollStrategy::Nearest);
             cx.notify();
@@ -178,6 +184,7 @@
     pub(super) fn move_down(&mut self, cx: &mut Context<Self>) {
         if self.focused_index < self.filtered_choices.len().saturating_sub(1) {
             self.focused_index += 1;
+            self.hovered_index = None;
             self.list_scroll_handle
                 .scroll_to_item(self.focused_index, ScrollStrategy::Nearest);
             cx.notify();
diff --git a/src/prompts/select/render.rs b/src/prompts/select/render.rs
index 62109896c9c14b1b2fbf5b4d25d5d94e4388e4aa..3c832dcfad01f574b54ee23e3c0881d24b57a6b2
--- a/src/prompts/select/render.rs
+++ b/src/prompts/select/render.rs
@@ -1,5 +1,78 @@
 use super::*;
 
+const ROW_FOCUSED_BG_ALPHA: u32 = 0x3A;
+const ROW_HOVER_BG_ALPHA: u32 = 0x26;
+
+#[derive(Clone, Copy, Debug, PartialEq, Eq)]
+pub(super) struct SelectRowState {
+    pub is_focused: bool,
+    pub is_selected: bool,
+    pub is_hovered: bool,
+}
+
+pub(super) fn compute_row_state(
+    display_idx: usize,
+    focused_index: usize,
+    choice_idx: usize,
+    selected: &HashSet<usize>,
+    hovered_index: Option<usize>,
+) -> SelectRowState {
+    SelectRowState {
+        is_focused: display_idx == focused_index,
+        is_selected: selected.contains(&choice_idx),
+        is_hovered: hovered_index == Some(display_idx),
+    }
+}
+
+pub(super) fn extract_choice_icon_hint(description: Option<&str>) -> Option<&str> {
+    description.and_then(|raw| {
+        raw.split(['‚Ä¢', '|', '\n'])
+            .map(str::trim)
+            .find_map(|token| {
+                let token_lower = token.to_ascii_lowercase();
+                if token_lower == "icon"
+                    || token_lower.starts_with("icon:")
+                    || token_lower.starts_with("icon=")
+                    || token_lower.starts_with("icon ")
+                {
+                    token
+                        .split_once(':')
+                        .or_else(|| token.split_once('='))
+                        .map(|(_, value)| value.trim())
+                        .or_else(|| token.split_whitespace().nth(1))
+                } else {
+                    None
+                }
+            })
+            .filter(|value| !value.is_empty())
+    })
+}
+
+pub(super) fn icon_kind_from_choice(choice: &Choice) -> IconKind {
+    let metadata_icon = extract_choice_icon_hint(choice.description.as_deref())
+        .and_then(IconKind::from_icon_hint);
+    let name_prefix_icon = choice
+        .name
+        .split_whitespace()
+        .next()
+        .and_then(IconKind::from_icon_hint);
+
+    metadata_icon
+        .or(name_prefix_icon)
+        .unwrap_or_else(|| IconKind::Svg("Code".to_string()))
+}
+
+fn leading_content_from_icon_kind(icon_kind: IconKind) -> LeadingContent {
+    match icon_kind {
+        IconKind::Emoji(emoji) => LeadingContent::Emoji(emoji.into()),
+        IconKind::Image(render_image) => LeadingContent::AppIcon(render_image),
+        IconKind::Svg(name) => LeadingContent::Icon {
+            name: SharedString::from(name),
+            color: None,
+        },
+    }
+}
+
 impl Focusable for SelectPrompt {
     fn focus_handle(&self, _cx: &gpui::App) -> FocusHandle {
         self.focus_handle.clone()
@@ -76,6 +149,13 @@
             self.design_variant,
             &colors,
         ));
+        let row_accent_color = if self.design_variant == DesignVariant::Default {
+            self.theme.colors.accent.selected
+        } else {
+            colors.accent
+        };
+        let focused_row_bg = rgba((row_accent_color << 8) | ROW_FOCUSED_BG_ALPHA);
+        let hovered_row_bg = rgba((row_accent_color << 8) | ROW_HOVER_BG_ALPHA);
 
         let placeholder = self
             .placeholder
@@ -145,8 +225,12 @@
                     move |this: &mut SelectPrompt,
                           visible_range: std::ops::Range<usize>,
                           _window,
-                          _cx| {
-                        let row_colors = UnifiedListItemColors::from_theme(&this.theme);
+                          cx| {
+                        let item_colors = UnifiedListItemColors {
+                            selected_opacity: 0.0,
+                            hover_opacity: 0.0,
+                            ..UnifiedListItemColors::from_theme(&this.theme)
+                        };
                         let mut rows = Vec::with_capacity(visible_range.len());
 
                         for display_idx in visible_range {
@@ -154,21 +238,30 @@
                                 if let Some(choice) = this.choices.get(choice_idx) {
                                     if let Some(indexed_choice) = this.choice_index.get(choice_idx)
                                     {
-                                        let is_focused = display_idx == this.focused_index;
-                                        let is_selected = this.selected.contains(&choice_idx);
-                                        let is_selected_for_ui = if this.multiple {
-                                            is_selected
-                                        } else {
-                                            is_focused
-                                        };
+                                        let row_state = compute_row_state(
+                                            display_idx,
+                                            this.focused_index,
+                                            choice_idx,
+                                            &this.selected,
+                                            this.hovered_index,
+                                        );
+                                        let is_focused = row_state.is_focused;
+                                        let is_selected = row_state.is_selected;
+                                        let is_hovered = row_state.is_hovered;
                                         let semantic_id =
                                             choice.semantic_id.clone().unwrap_or_else(|| {
                                                 indexed_choice.stable_semantic_id.clone()
                                             });
-                                        let indicator = choice_selection_indicator(
-                                            this.multiple,
-                                            is_selected_for_ui,
-                                        );
+                                        let leading = if this.multiple {
+                                            Some(LeadingContent::Emoji(
+                                                choice_selection_indicator(true, is_selected)
+                                                    .into(),
+                                            ))
+                                        } else {
+                                            Some(leading_content_from_icon_kind(
+                                                icon_kind_from_choice(choice),
+                                            ))
+                                        };
                                         let subtitle = indexed_choice
                                             .metadata
                                             .subtitle_text()
@@ -185,34 +278,61 @@
                                                     ))
                                                 },
                                             );
+                                        let row_bg = if is_focused {
+                                            focused_row_bg
+                                        } else if is_hovered {
+                                            hovered_row_bg
+                                        } else {
+                                            rgba(0x00000000)
+                                        };
+                                        let hover_handler = cx.listener(
+                                            move |this: &mut SelectPrompt,
+                                                  hovered: &bool,
+                                                  _window,
+                                                  cx| {
+                                                if *hovered {
+                                                    if this.hovered_index != Some(display_idx) {
+                                                        this.hovered_index = Some(display_idx);
+                                                        cx.notify();
+                                                    }
+                                                } else if this.hovered_index == Some(display_idx)
+                                                {
+                                                    this.hovered_index = None;
+                                                    cx.notify();
+                                                }
+                                            },
+                                        );
+
+                                        let mut row = div()
+                                            .id(display_idx)
+                                            .w_full()
+                                            .h(px(LIST_ITEM_HEIGHT))
+                                            .rounded(px(8.0))
+                                            .bg(row_bg)
+                                            .cursor_pointer()
+                                            .on_hover(hover_handler)
+                                            .child(
+                                                UnifiedListItem::new(
+                                                    gpui::ElementId::Name(semantic_id.into()),
+                                                    title,
+                                                )
+                                                .subtitle_opt(subtitle)
+                                                .leading_opt(leading)
+                                                .trailing_opt(trailing)
+                                                .state(ItemState {
+                                                    is_selected,
+                                                    is_hovered,
+                                                    is_disabled: false,
+                                                })
+                                                .density(Density::Comfortable)
+                                                .colors(item_colors),
+                                            );
+
+                                        if !is_focused {
+                                            row = row.hover(move |s| s.bg(hovered_row_bg));
+                                        }
 
-                                        rows.push(
-                                            div()
-                                                .id(display_idx)
-                                                .w_full()
-                                                .h(px(LIST_ITEM_HEIGHT))
-                                                .border_b_1()
-                                                .border_color(border_color)
-                                                .child(
-                                                    UnifiedListItem::new(
-                                                        gpui::ElementId::Name(semantic_id.into()),
-                                                        title,
-                                                    )
-                                                    .subtitle_opt(subtitle)
-                                                    .leading(LeadingContent::Emoji(
-                                                        indicator.into(),
-                                                    ))
-                                                    .trailing_opt(trailing)
-                                                    .state(ItemState {
-                                                        is_selected: is_focused,
-                                                        is_hovered: false,
-                                                        is_disabled: false,
-                                                    })
-                                                    .density(Density::Comfortable)
-                                                    .colors(row_colors)
-                                                    .with_accent_bar(is_selected_for_ui),
-                                                ),
-                                        );
+                                        rows.push(row);
                                     }
                                 }
                             }
@@ -234,6 +354,7 @@
             .flex_col()
             .flex_1()
             .w_full()
+            .px(px(8.0))
             .child(choices_content);
 
         div()
diff --git a/src/prompts/select/tests.rs b/src/prompts/select/tests.rs
index 250ec9d63282ad81dd952efa12855f784330232c..948502e17306b114996263c50fbec58a051fa7b4
--- a/src/prompts/select/tests.rs
+++ b/src/prompts/select/tests.rs
@@ -184,3 +184,35 @@
         0x445566
     );
 }
+
+#[test]
+fn test_select_prompt_extracts_icon_hint_from_choice_metadata() {
+    let description = Some("Shortcut: cmd+k ‚Ä¢ icon: terminal ‚Ä¢ script");
+    assert_eq!(render::extract_choice_icon_hint(description), Some("terminal"));
+}
+
+#[test]
+fn test_select_prompt_icon_kind_falls_back_to_code_icon_without_hint() {
+    let choice = choice("Deploy API", "/Users/me/.scriptkit/scripts/deploy.ts", None);
+
+    match render::icon_kind_from_choice(&choice) {
+        IconKind::Svg(name) => assert_eq!(name, "Code"),
+        _ => panic!("expected fallback Code SVG icon"),
+    }
+}
+
+#[test]
+fn test_select_prompt_compute_row_state_keeps_focus_and_selection_independent() {
+    let selected = std::collections::HashSet::from([5]);
+    let focused_but_unselected =
+        render::compute_row_state(2, 2, 1, &selected, Some(1));
+    assert!(focused_but_unselected.is_focused);
+    assert!(!focused_but_unselected.is_selected);
+    assert!(!focused_but_unselected.is_hovered);
+
+    let selected_but_unfocused =
+        render::compute_row_state(1, 2, 5, &selected, Some(1));
+    assert!(!selected_but_unfocused.is_focused);
+    assert!(selected_but_unfocused.is_selected);
+    assert!(selected_but_unfocused.is_hovered);
+}


thinking
**Confirming module import visibility and planning targeted formatting**
exec
/bin/zsh -lc 'cd /Users/johnlindquist/dev/script-kit-gpui && cargo fmt -- src/prompts/select/render.rs src/prompts/select/tests.rs src/prompts/select/mod.rs src/prompts/select/prompt.rs src/list_item/part_000.rs' in /Users/johnlindquist/dev/script-kit-gpui exited 1 in 128ms:
Error writing files: failed to resolve mod `tests`: file for module found at both "/Users/johnlindquist/dev/script-kit-gpui/src/protocol/message/tests.rs" and "/Users/johnlindquist/dev/script-kit-gpui/src/protocol/message/tests/mod.rs"
file update:
diff --git a/src/list_item/part_000.rs b/src/list_item/part_000.rs
index 733d4ac2aa5b1b27b29a5999310e6f3f45cc54c3..283b2263d56a92c73c22d44443db7b40971d26ce
--- a/src/list_item/part_000.rs
+++ b/src/list_item/part_000.rs
@@ -15,6 +15,37 @@
     /// Maps to IconName from designs::icon_variations
     Svg(String),
 }
+
+impl IconKind {
+    /// Resolve icon metadata into an IconKind for list rendering.
+    ///
+    /// Supports:
+    /// - Known SVG names/aliases via `icon_name_from_str` (e.g., "Terminal", "file-code")
+    /// - Emoji/symbol glyphs (e.g., "üìÑ", "‚ö°")
+    pub fn from_icon_hint(icon_hint: &str) -> Option<Self> {
+        let trimmed = icon_hint.trim();
+        if trimmed.is_empty() {
+            return None;
+        }
+
+        if icon_name_from_str(trimmed).is_some() {
+            return Some(Self::Svg(trimmed.to_string()));
+        }
+
+        if looks_like_symbol_icon_hint(trimmed) {
+            return Some(Self::Emoji(trimmed.to_string()));
+        }
+
+        None
+    }
+}
+
+fn looks_like_symbol_icon_hint(icon_hint: &str) -> bool {
+    let has_ascii_alnum = icon_hint.chars().any(|ch| ch.is_ascii_alphanumeric());
+    let char_count = icon_hint.chars().count();
+
+    !has_ascii_alnum && char_count <= 4
+}
 /// Fixed height for list items used in uniform-height virtualized lists.
 ///
 /// IMPORTANT: When using GPUI `uniform_list`, the item closure must render
@@ -437,3 +468,29 @@
     /// Text color for content displayed on accent/warning backgrounds
     pub text_on_accent: u32,
 }
+
+#[cfg(test)]
+mod icon_kind_tests {
+    use super::IconKind;
+
+    #[test]
+    fn test_icon_kind_from_icon_hint_returns_svg_when_known_icon_name() {
+        match IconKind::from_icon_hint("terminal") {
+            Some(IconKind::Svg(name)) => assert_eq!(name, "terminal"),
+            _ => panic!("expected SVG icon from known icon hint"),
+        }
+    }
+
+    #[test]
+    fn test_icon_kind_from_icon_hint_returns_emoji_when_symbol_glyph() {
+        match IconKind::from_icon_hint("üìÑ") {
+            Some(IconKind::Emoji(emoji)) => assert_eq!(emoji, "üìÑ"),
+            _ => panic!("expected emoji icon for symbol glyph"),
+        }
+    }
+
+    #[test]
+    fn test_icon_kind_from_icon_hint_returns_none_for_unknown_ascii_word() {
+        assert!(IconKind::from_icon_hint("unknown-icon-name").is_none());
+    }
+}
diff --git a/src/prompts/select/mod.rs b/src/prompts/select/mod.rs
index b6366dabfb14f3fae09f854f9de824fa629e0a3b..32ec6dd9fa7ee4b5d29009f3cc5a665713f97a10
--- a/src/prompts/select/mod.rs
+++ b/src/prompts/select/mod.rs
@@ -19,7 +19,7 @@
     UnifiedListItemColors,
 };
 use crate::designs::{get_tokens, DesignColors, DesignVariant};
-use crate::list_item::LIST_ITEM_HEIGHT;
+use crate::list_item::{IconKind, LIST_ITEM_HEIGHT};
 use crate::logging;
 use crate::panel::PROMPT_INPUT_FIELD_HEIGHT;
 use crate::protocol::{generate_semantic_id, Choice};
@@ -37,5 +37,5 @@
 mod types;
 
 pub use prompt::SelectPrompt;
-use search::*;
-use types::*;
+pub(super) use search::*;
+pub(super) use types::*;
diff --git a/src/prompts/select/prompt.rs b/src/prompts/select/prompt.rs
index c5f98f5318f5b520e9223811f735e866ee06e7fb..5ba2de479b2f5680a73db72642377f68d26ee54e
--- a/src/prompts/select/prompt.rs
+++ b/src/prompts/select/prompt.rs
@@ -19,6 +19,8 @@
     pub filtered_choices: Vec<usize>,
     /// Currently focused index in filtered list
     pub focused_index: usize,
+    /// Currently hovered index in filtered list
+    pub hovered_index: Option<usize>,
     /// Filter text
     pub filter_text: String,
     /// Whether multiple selection is allowed
@@ -68,6 +70,7 @@
             selected: HashSet::new(),
             filtered_choices,
             focused_index: 0,
+            hovered_index: None,
             filter_text: String::new(),
             multiple,
             focus_handle,
@@ -84,6 +87,7 @@
         if trimmed_filter.is_empty() {
             self.filtered_choices = (0..self.choices.len()).collect();
             self.focused_index = 0;
+            self.hovered_index = None;
             return;
         }
 
@@ -109,6 +113,7 @@
 
         self.filtered_choices = scored_matches.into_iter().map(|(idx, _)| idx).collect();
         self.focused_index = 0;
+        self.hovered_index = None;
     }
 
     /// Set the filter text programmatically
@@ -168,6 +173,7 @@
     pub(super) fn move_up(&mut self, cx: &mut Context<Self>) {
         if self.focused_index > 0 {
             self.focused_index -= 1;
+            self.hovered_index = None;
             self.list_scroll_handle
                 .scroll_to_item(self.focused_index, ScrollStrategy::Nearest);
             cx.notify();
@@ -178,6 +184,7 @@
     pub(super) fn move_down(&mut self, cx: &mut Context<Self>) {
         if self.focused_index < self.filtered_choices.len().saturating_sub(1) {
             self.focused_index += 1;
+            self.hovered_index = None;
             self.list_scroll_handle
                 .scroll_to_item(self.focused_index, ScrollStrategy::Nearest);
             cx.notify();
diff --git a/src/prompts/select/render.rs b/src/prompts/select/render.rs
index 62109896c9c14b1b2fbf5b4d25d5d94e4388e4aa..e224ca641be966e7357474d1892f16fb9d59f392
--- a/src/prompts/select/render.rs
+++ b/src/prompts/select/render.rs
@@ -1,5 +1,78 @@
 use super::*;
 
+const ROW_FOCUSED_BG_ALPHA: u32 = 0x3A;
+const ROW_HOVER_BG_ALPHA: u32 = 0x26;
+
+#[derive(Clone, Copy, Debug, PartialEq, Eq)]
+pub(super) struct SelectRowState {
+    pub is_focused: bool,
+    pub is_selected: bool,
+    pub is_hovered: bool,
+}
+
+pub(super) fn compute_row_state(
+    display_idx: usize,
+    focused_index: usize,
+    choice_idx: usize,
+    selected: &HashSet<usize>,
+    hovered_index: Option<usize>,
+) -> SelectRowState {
+    SelectRowState {
+        is_focused: display_idx == focused_index,
+        is_selected: selected.contains(&choice_idx),
+        is_hovered: hovered_index == Some(display_idx),
+    }
+}
+
+pub(super) fn extract_choice_icon_hint(description: Option<&str>) -> Option<&str> {
+    description.and_then(|raw| {
+        raw.split(['‚Ä¢', '|', '\n'])
+            .map(str::trim)
+            .find_map(|token| {
+                let token_lower = token.to_ascii_lowercase();
+                if token_lower == "icon"
+                    || token_lower.starts_with("icon:")
+                    || token_lower.starts_with("icon=")
+                    || token_lower.starts_with("icon ")
+                {
+                    token
+                        .split_once(':')
+                        .or_else(|| token.split_once('='))
+                        .map(|(_, value)| value.trim())
+                        .or_else(|| token.split_whitespace().nth(1))
+                } else {
+                    None
+                }
+            })
+            .filter(|value| !value.is_empty())
+    })
+}
+
+pub(super) fn icon_kind_from_choice(choice: &Choice) -> IconKind {
+    let metadata_icon =
+        extract_choice_icon_hint(choice.description.as_deref()).and_then(IconKind::from_icon_hint);
+    let name_prefix_icon = choice
+        .name
+        .split_whitespace()
+        .next()
+        .and_then(IconKind::from_icon_hint);
+
+    metadata_icon
+        .or(name_prefix_icon)
+        .unwrap_or_else(|| IconKind::Svg("Code".to_string()))
+}
+
+fn leading_content_from_icon_kind(icon_kind: IconKind) -> LeadingContent {
+    match icon_kind {
+        IconKind::Emoji(emoji) => LeadingContent::Emoji(emoji.into()),
+        IconKind::Image(render_image) => LeadingContent::AppIcon(render_image),
+        IconKind::Svg(name) => LeadingContent::Icon {
+            name: SharedString::from(name),
+            color: None,
+        },
+    }
+}
+
 impl Focusable for SelectPrompt {
     fn focus_handle(&self, _cx: &gpui::App) -> FocusHandle {
         self.focus_handle.clone()
@@ -76,6 +149,13 @@
             self.design_variant,
             &colors,
         ));
+        let row_accent_color = if self.design_variant == DesignVariant::Default {
+            self.theme.colors.accent.selected
+        } else {
+            colors.accent
+        };
+        let focused_row_bg = rgba((row_accent_color << 8) | ROW_FOCUSED_BG_ALPHA);
+        let hovered_row_bg = rgba((row_accent_color << 8) | ROW_HOVER_BG_ALPHA);
 
         let placeholder = self
             .placeholder
@@ -145,8 +225,12 @@
                     move |this: &mut SelectPrompt,
                           visible_range: std::ops::Range<usize>,
                           _window,
-                          _cx| {
-                        let row_colors = UnifiedListItemColors::from_theme(&this.theme);
+                          cx| {
+                        let item_colors = UnifiedListItemColors {
+                            selected_opacity: 0.0,
+                            hover_opacity: 0.0,
+                            ..UnifiedListItemColors::from_theme(&this.theme)
+                        };
                         let mut rows = Vec::with_capacity(visible_range.len());
 
                         for display_idx in visible_range {
@@ -154,21 +238,30 @@
                                 if let Some(choice) = this.choices.get(choice_idx) {
                                     if let Some(indexed_choice) = this.choice_index.get(choice_idx)
                                     {
-                                        let is_focused = display_idx == this.focused_index;
-                                        let is_selected = this.selected.contains(&choice_idx);
-                                        let is_selected_for_ui = if this.multiple {
-                                            is_selected
-                                        } else {
-                                            is_focused
-                                        };
+                                        let row_state = compute_row_state(
+                                            display_idx,
+                                            this.focused_index,
+                                            choice_idx,
+                                            &this.selected,
+                                            this.hovered_index,
+                                        );
+                                        let is_focused = row_state.is_focused;
+                                        let is_selected = row_state.is_selected;
+                                        let is_hovered = row_state.is_hovered;
                                         let semantic_id =
                                             choice.semantic_id.clone().unwrap_or_else(|| {
                                                 indexed_choice.stable_semantic_id.clone()
                                             });
-                                        let indicator = choice_selection_indicator(
-                                            this.multiple,
-                                            is_selected_for_ui,
-                                        );
+                                        let leading = if this.multiple {
+                                            Some(LeadingContent::Emoji(
+                                                choice_selection_indicator(true, is_selected)
+                                                    .into(),
+                                            ))
+                                        } else {
+                                            Some(leading_content_from_icon_kind(
+                                                icon_kind_from_choice(choice),
+                                            ))
+                                        };
                                         let subtitle = indexed_choice
                                             .metadata
                                             .subtitle_text()
@@ -185,34 +278,60 @@
                                                     ))
                                                 },
                                             );
+                                        let row_bg = if is_focused {
+                                            focused_row_bg
+                                        } else if is_hovered {
+                                            hovered_row_bg
+                                        } else {
+                                            rgba(0x00000000)
+                                        };
+                                        let hover_handler = cx.listener(
+                                            move |this: &mut SelectPrompt,
+                                                  hovered: &bool,
+                                                  _window,
+                                                  cx| {
+                                                if *hovered {
+                                                    if this.hovered_index != Some(display_idx) {
+                                                        this.hovered_index = Some(display_idx);
+                                                        cx.notify();
+                                                    }
+                                                } else if this.hovered_index == Some(display_idx) {
+                                                    this.hovered_index = None;
+                                                    cx.notify();
+                                                }
+                                            },
+                                        );
+
+                                        let mut row = div()
+                                            .id(display_idx)
+                                            .w_full()
+                                            .h(px(LIST_ITEM_HEIGHT))
+                                            .rounded(px(8.0))
+                                            .bg(row_bg)
+                                            .cursor_pointer()
+                                            .on_hover(hover_handler)
+                                            .child(
+                                                UnifiedListItem::new(
+                                                    gpui::ElementId::Name(semantic_id.into()),
+                                                    title,
+                                                )
+                                                .subtitle_opt(subtitle)
+                                                .leading_opt(leading)
+                                                .trailing_opt(trailing)
+                                                .state(ItemState {
+                                                    is_selected,
+                                                    is_hovered,
+                                                    is_disabled: false,
+                                                })
+                                                .density(Density::Comfortable)
+                                                .colors(item_colors),
+                                            );
+
+                                        if !is_focused {
+                                            row = row.hover(move |s| s.bg(hovered_row_bg));
+                                        }
 
-                                        rows.push(
-                                            div()
-                                                .id(display_idx)
-                                                .w_full()
-                                                .h(px(LIST_ITEM_HEIGHT))
-                                                .border_b_1()
-                                                .border_color(border_color)
-                                                .child(
-                                                    UnifiedListItem::new(
-                                                        gpui::ElementId::Name(semantic_id.into()),
-                                                        title,
-                                                    )
-                                                    .subtitle_opt(subtitle)
-                                                    .leading(LeadingContent::Emoji(
-                                                        indicator.into(),
-                                                    ))
-                                                    .trailing_opt(trailing)
-                                                    .state(ItemState {
-                                                        is_selected: is_focused,
-                                                        is_hovered: false,
-                                                        is_disabled: false,
-                                                    })
-                                                    .density(Density::Comfortable)
-                                                    .colors(row_colors)
-                                                    .with_accent_bar(is_selected_for_ui),
-                                                ),
-                                        );
+                                        rows.push(row);
                                     }
                                 }
                             }
@@ -234,6 +353,7 @@
             .flex_col()
             .flex_1()
             .w_full()
+            .px(px(8.0))
             .child(choices_content);
 
         div()
diff --git a/src/prompts/select/tests.rs b/src/prompts/select/tests.rs
index 250ec9d63282ad81dd952efa12855f784330232c..2b048753d5f168dcbc59ccb0e399e4604bc39167
--- a/src/prompts/select/tests.rs
+++ b/src/prompts/select/tests.rs
@@ -184,3 +184,36 @@
         0x445566
     );
 }
+
+#[test]
+fn test_select_prompt_extracts_icon_hint_from_choice_metadata() {
+    let description = Some("Shortcut: cmd+k ‚Ä¢ icon: terminal ‚Ä¢ script");
+    assert_eq!(
+        render::extract_choice_icon_hint(description),
+        Some("terminal")
+    );
+}
+
+#[test]
+fn test_select_prompt_icon_kind_falls_back_to_code_icon_without_hint() {
+    let choice = choice("Deploy API", "/Users/me/.scriptkit/scripts/deploy.ts", None);
+
+    match render::icon_kind_from_choice(&choice) {
+        IconKind::Svg(name) => assert_eq!(name, "Code"),
+        _ => panic!("expected fallback Code SVG icon"),
+    }
+}
+
+#[test]
+fn test_select_prompt_compute_row_state_keeps_focus_and_selection_independent() {
+    let selected = std::collections::HashSet::from([5]);
+    let focused_but_unselected = render::compute_row_state(2, 2, 1, &selected, Some(1));
+    assert!(focused_but_unselected.is_focused);
+    assert!(!focused_but_unselected.is_selected);
+    assert!(!focused_but_unselected.is_hovered);
+
+    let selected_but_unfocused = render::compute_row_state(1, 2, 5, &selected, Some(1));
+    assert!(!selected_but_unfocused.is_focused);
+    assert!(selected_but_unfocused.is_selected);
+    assert!(selected_but_unfocused.is_hovered);
+}


thinking
**Deciding rustfmt invocation method**
exec
/bin/zsh -lc 'cd /Users/johnlindquist/dev/script-kit-gpui && rustfmt src/prompts/select/render.rs src/prompts/select/tests.rs src/prompts/select/mod.rs src/prompts/select/prompt.rs src/list_item/part_000.rs' in /Users/johnlindquist/dev/script-kit-gpui succeeded in 51ms:

file update:
diff --git a/src/list_item/part_000.rs b/src/list_item/part_000.rs
index 733d4ac2aa5b1b27b29a5999310e6f3f45cc54c3..283b2263d56a92c73c22d44443db7b40971d26ce
--- a/src/list_item/part_000.rs
+++ b/src/list_item/part_000.rs
@@ -15,6 +15,37 @@
     /// Maps to IconName from designs::icon_variations
     Svg(String),
 }
+
+impl IconKind {
+    /// Resolve icon metadata into an IconKind for list rendering.
+    ///
+    /// Supports:
+    /// - Known SVG names/aliases via `icon_name_from_str` (e.g., "Terminal", "file-code")
+    /// - Emoji/symbol glyphs (e.g., "üìÑ", "‚ö°")
+    pub fn from_icon_hint(icon_hint: &str) -> Option<Self> {
+        let trimmed = icon_hint.trim();
+        if trimmed.is_empty() {
+            return None;
+        }
+
+        if icon_name_from_str(trimmed).is_some() {
+            return Some(Self::Svg(trimmed.to_string()));
+        }
+
+        if looks_like_symbol_icon_hint(trimmed) {
+            return Some(Self::Emoji(trimmed.to_string()));
+        }
+
+        None
+    }
+}
+
+fn looks_like_symbol_icon_hint(icon_hint: &str) -> bool {
+    let has_ascii_alnum = icon_hint.chars().any(|ch| ch.is_ascii_alphanumeric());
+    let char_count = icon_hint.chars().count();
+
+    !has_ascii_alnum && char_count <= 4
+}
 /// Fixed height for list items used in uniform-height virtualized lists.
 ///
 /// IMPORTANT: When using GPUI `uniform_list`, the item closure must render
@@ -437,3 +468,29 @@
     /// Text color for content displayed on accent/warning backgrounds
     pub text_on_accent: u32,
 }
+
+#[cfg(test)]
+mod icon_kind_tests {
+    use super::IconKind;
+
+    #[test]
+    fn test_icon_kind_from_icon_hint_returns_svg_when_known_icon_name() {
+        match IconKind::from_icon_hint("terminal") {
+            Some(IconKind::Svg(name)) => assert_eq!(name, "terminal"),
+            _ => panic!("expected SVG icon from known icon hint"),
+        }
+    }
+
+    #[test]
+    fn test_icon_kind_from_icon_hint_returns_emoji_when_symbol_glyph() {
+        match IconKind::from_icon_hint("üìÑ") {
+            Some(IconKind::Emoji(emoji)) => assert_eq!(emoji, "üìÑ"),
+            _ => panic!("expected emoji icon for symbol glyph"),
+        }
+    }
+
+    #[test]
+    fn test_icon_kind_from_icon_hint_returns_none_for_unknown_ascii_word() {
+        assert!(IconKind::from_icon_hint("unknown-icon-name").is_none());
+    }
+}
diff --git a/src/prompts/select/mod.rs b/src/prompts/select/mod.rs
index b6366dabfb14f3fae09f854f9de824fa629e0a3b..32ec6dd9fa7ee4b5d29009f3cc5a665713f97a10
--- a/src/prompts/select/mod.rs
+++ b/src/prompts/select/mod.rs
@@ -19,7 +19,7 @@
     UnifiedListItemColors,
 };
 use crate::designs::{get_tokens, DesignColors, DesignVariant};
-use crate::list_item::LIST_ITEM_HEIGHT;
+use crate::list_item::{IconKind, LIST_ITEM_HEIGHT};
 use crate::logging;
 use crate::panel::PROMPT_INPUT_FIELD_HEIGHT;
 use crate::protocol::{generate_semantic_id, Choice};
@@ -37,5 +37,5 @@
 mod types;
 
 pub use prompt::SelectPrompt;
-use search::*;
-use types::*;
+pub(super) use search::*;
+pub(super) use types::*;
diff --git a/src/prompts/select/prompt.rs b/src/prompts/select/prompt.rs
index c5f98f5318f5b520e9223811f735e866ee06e7fb..5ba2de479b2f5680a73db72642377f68d26ee54e
--- a/src/prompts/select/prompt.rs
+++ b/src/prompts/select/prompt.rs
@@ -19,6 +19,8 @@
     pub filtered_choices: Vec<usize>,
     /// Currently focused index in filtered list
     pub focused_index: usize,
+    /// Currently hovered index in filtered list
+    pub hovered_index: Option<usize>,
     /// Filter text
     pub filter_text: String,
     /// Whether multiple selection is allowed
@@ -68,6 +70,7 @@
             selected: HashSet::new(),
             filtered_choices,
             focused_index: 0,
+            hovered_index: None,
             filter_text: String::new(),
             multiple,
             focus_handle,
@@ -84,6 +87,7 @@
         if trimmed_filter.is_empty() {
             self.filtered_choices = (0..self.choices.len()).collect();
             self.focused_index = 0;
+            self.hovered_index = None;
             return;
         }
 
@@ -109,6 +113,7 @@
 
         self.filtered_choices = scored_matches.into_iter().map(|(idx, _)| idx).collect();
         self.focused_index = 0;
+        self.hovered_index = None;
     }
 
     /// Set the filter text programmatically
@@ -168,6 +173,7 @@
     pub(super) fn move_up(&mut self, cx: &mut Context<Self>) {
         if self.focused_index > 0 {
             self.focused_index -= 1;
+            self.hovered_index = None;
             self.list_scroll_handle
                 .scroll_to_item(self.focused_index, ScrollStrategy::Nearest);
             cx.notify();
@@ -178,6 +184,7 @@
     pub(super) fn move_down(&mut self, cx: &mut Context<Self>) {
         if self.focused_index < self.filtered_choices.len().saturating_sub(1) {
             self.focused_index += 1;
+            self.hovered_index = None;
             self.list_scroll_handle
                 .scroll_to_item(self.focused_index, ScrollStrategy::Nearest);
             cx.notify();
diff --git a/src/prompts/select/render.rs b/src/prompts/select/render.rs
index 62109896c9c14b1b2fbf5b4d25d5d94e4388e4aa..e224ca641be966e7357474d1892f16fb9d59f392
--- a/src/prompts/select/render.rs
+++ b/src/prompts/select/render.rs
@@ -1,5 +1,78 @@
 use super::*;
 
+const ROW_FOCUSED_BG_ALPHA: u32 = 0x3A;
+const ROW_HOVER_BG_ALPHA: u32 = 0x26;
+
+#[derive(Clone, Copy, Debug, PartialEq, Eq)]
+pub(super) struct SelectRowState {
+    pub is_focused: bool,
+    pub is_selected: bool,
+    pub is_hovered: bool,
+}
+
+pub(super) fn compute_row_state(
+    display_idx: usize,
+    focused_index: usize,
+    choice_idx: usize,
+    selected: &HashSet<usize>,
+    hovered_index: Option<usize>,
+) -> SelectRowState {
+    SelectRowState {
+        is_focused: display_idx == focused_index,
+        is_selected: selected.contains(&choice_idx),
+        is_hovered: hovered_index == Some(display_idx),
+    }
+}
+
+pub(super) fn extract_choice_icon_hint(description: Option<&str>) -> Option<&str> {
+    description.and_then(|raw| {
+        raw.split(['‚Ä¢', '|', '\n'])
+            .map(str::trim)
+            .find_map(|token| {
+                let token_lower = token.to_ascii_lowercase();
+                if token_lower == "icon"
+                    || token_lower.starts_with("icon:")
+                    || token_lower.starts_with("icon=")
+                    || token_lower.starts_with("icon ")
+                {
+                    token
+                        .split_once(':')
+                        .or_else(|| token.split_once('='))
+                        .map(|(_, value)| value.trim())
+                        .or_else(|| token.split_whitespace().nth(1))
+                } else {
+                    None
+                }
+            })
+            .filter(|value| !value.is_empty())
+    })
+}
+
+pub(super) fn icon_kind_from_choice(choice: &Choice) -> IconKind {
+    let metadata_icon =
+        extract_choice_icon_hint(choice.description.as_deref()).and_then(IconKind::from_icon_hint);
+    let name_prefix_icon = choice
+        .name
+        .split_whitespace()
+        .next()
+        .and_then(IconKind::from_icon_hint);
+
+    metadata_icon
+        .or(name_prefix_icon)
+        .unwrap_or_else(|| IconKind::Svg("Code".to_string()))
+}
+
+fn leading_content_from_icon_kind(icon_kind: IconKind) -> LeadingContent {
+    match icon_kind {
+        IconKind::Emoji(emoji) => LeadingContent::Emoji(emoji.into()),
+        IconKind::Image(render_image) => LeadingContent::AppIcon(render_image),
+        IconKind::Svg(name) => LeadingContent::Icon {
+            name: SharedString::from(name),
+            color: None,
+        },
+    }
+}
+
 impl Focusable for SelectPrompt {
     fn focus_handle(&self, _cx: &gpui::App) -> FocusHandle {
         self.focus_handle.clone()
@@ -76,6 +149,13 @@
             self.design_variant,
             &colors,
         ));
+        let row_accent_color = if self.design_variant == DesignVariant::Default {
+            self.theme.colors.accent.selected
+        } else {
+            colors.accent
+        };
+        let focused_row_bg = rgba((row_accent_color << 8) | ROW_FOCUSED_BG_ALPHA);
+        let hovered_row_bg = rgba((row_accent_color << 8) | ROW_HOVER_BG_ALPHA);
 
         let placeholder = self
             .placeholder
@@ -145,8 +225,12 @@
                     move |this: &mut SelectPrompt,
                           visible_range: std::ops::Range<usize>,
                           _window,
-                          _cx| {
-                        let row_colors = UnifiedListItemColors::from_theme(&this.theme);
+                          cx| {
+                        let item_colors = UnifiedListItemColors {
+                            selected_opacity: 0.0,
+                            hover_opacity: 0.0,
+                            ..UnifiedListItemColors::from_theme(&this.theme)
+                        };
                         let mut rows = Vec::with_capacity(visible_range.len());
 
                         for display_idx in visible_range {
@@ -154,21 +238,30 @@
                                 if let Some(choice) = this.choices.get(choice_idx) {
                                     if let Some(indexed_choice) = this.choice_index.get(choice_idx)
                                     {
-                                        let is_focused = display_idx == this.focused_index;
-                                        let is_selected = this.selected.contains(&choice_idx);
-                                        let is_selected_for_ui = if this.multiple {
-                                            is_selected
-                                        } else {
-                                            is_focused
-                                        };
+                                        let row_state = compute_row_state(
+                                            display_idx,
+                                            this.focused_index,
+                                            choice_idx,
+                                            &this.selected,
+                                            this.hovered_index,
+                                        );
+                                        let is_focused = row_state.is_focused;
+                                        let is_selected = row_state.is_selected;
+                                        let is_hovered = row_state.is_hovered;
                                         let semantic_id =
                                             choice.semantic_id.clone().unwrap_or_else(|| {
                                                 indexed_choice.stable_semantic_id.clone()
                                             });
-                                        let indicator = choice_selection_indicator(
-                                            this.multiple,
-                                            is_selected_for_ui,
-                                        );
+                                        let leading = if this.multiple {
+                                            Some(LeadingContent::Emoji(
+                                                choice_selection_indicator(true, is_selected)
+                                                    .into(),
+                                            ))
+                                        } else {
+                                            Some(leading_content_from_icon_kind(
+                                                icon_kind_from_choice(choice),
+                                            ))
+                                        };
                                         let subtitle = indexed_choice
                                             .metadata
                                             .subtitle_text()
@@ -185,34 +278,60 @@
                                                     ))
                                                 },
                                             );
+                                        let row_bg = if is_focused {
+                                            focused_row_bg
+                                        } else if is_hovered {
+                                            hovered_row_bg
+                                        } else {
+                                            rgba(0x00000000)
+                                        };
+                                        let hover_handler = cx.listener(
+                                            move |this: &mut SelectPrompt,
+                                                  hovered: &bool,
+                                                  _window,
+                                                  cx| {
+                                                if *hovered {
+                                                    if this.hovered_index != Some(display_idx) {
+                                                        this.hovered_index = Some(display_idx);
+                                                        cx.notify();
+                                                    }
+                                                } else if this.hovered_index == Some(display_idx) {
+                                                    this.hovered_index = None;
+                                                    cx.notify();
+                                                }
+                                            },
+                                        );
+
+                                        let mut row = div()
+                                            .id(display_idx)
+                                            .w_full()
+                                            .h(px(LIST_ITEM_HEIGHT))
+                                            .rounded(px(8.0))
+                                            .bg(row_bg)
+                                            .cursor_pointer()
+                                            .on_hover(hover_handler)
+                                            .child(
+                                                UnifiedListItem::new(
+                                                    gpui::ElementId::Name(semantic_id.into()),
+                                                    title,
+                                                )
+                                                .subtitle_opt(subtitle)
+                                                .leading_opt(leading)
+                                                .trailing_opt(trailing)
+                                                .state(ItemState {
+                                                    is_selected,
+                                                    is_hovered,
+                                                    is_disabled: false,
+                                                })
+                                                .density(Density::Comfortable)
+                                                .colors(item_colors),
+                                            );
+
+                                        if !is_focused {
+                                            row = row.hover(move |s| s.bg(hovered_row_bg));
+                                        }
 
-                                        rows.push(
-                                            div()
-                                                .id(display_idx)
-                                                .w_full()
-                                                .h(px(LIST_ITEM_HEIGHT))
-                                                .border_b_1()
-                                                .border_color(border_color)
-                                                .child(
-                                                    UnifiedListItem::new(
-                                                        gpui::ElementId::Name(semantic_id.into()),
-                                                        title,
-                                                    )
-                                                    .subtitle_opt(subtitle)
-                                                    .leading(LeadingContent::Emoji(
-                                                        indicator.into(),
-                                                    ))
-                                                    .trailing_opt(trailing)
-                                                    .state(ItemState {
-                                                        is_selected: is_focused,
-                                                        is_hovered: false,
-                                                        is_disabled: false,
-                                                    })
-                                                    .density(Density::Comfortable)
-                                                    .colors(row_colors)
-                                                    .with_accent_bar(is_selected_for_ui),
-                                                ),
-                                        );
+                                        rows.push(row);
                                     }
                                 }
                             }
@@ -234,6 +353,7 @@
             .flex_col()
             .flex_1()
             .w_full()
+            .px(px(8.0))
             .child(choices_content);
 
         div()
diff --git a/src/prompts/select/tests.rs b/src/prompts/select/tests.rs
index 250ec9d63282ad81dd952efa12855f784330232c..2b048753d5f168dcbc59ccb0e399e4604bc39167
--- a/src/prompts/select/tests.rs
+++ b/src/prompts/select/tests.rs
@@ -184,3 +184,36 @@
         0x445566
     );
 }
+
+#[test]
+fn test_select_prompt_extracts_icon_hint_from_choice_metadata() {
+    let description = Some("Shortcut: cmd+k ‚Ä¢ icon: terminal ‚Ä¢ script");
+    assert_eq!(
+        render::extract_choice_icon_hint(description),
+        Some("terminal")
+    );
+}
+
+#[test]
+fn test_select_prompt_icon_kind_falls_back_to_code_icon_without_hint() {
+    let choice = choice("Deploy API", "/Users/me/.scriptkit/scripts/deploy.ts", None);
+
+    match render::icon_kind_from_choice(&choice) {
+        IconKind::Svg(name) => assert_eq!(name, "Code"),
+        _ => panic!("expected fallback Code SVG icon"),
+    }
+}
+
+#[test]
+fn test_select_prompt_compute_row_state_keeps_focus_and_selection_independent() {
+    let selected = std::collections::HashSet::from([5]);
+    let focused_but_unselected = render::compute_row_state(2, 2, 1, &selected, Some(1));
+    assert!(focused_but_unselected.is_focused);
+    assert!(!focused_but_unselected.is_selected);
+    assert!(!focused_but_unselected.is_hovered);
+
+    let selected_but_unfocused = render::compute_row_state(1, 2, 5, &selected, Some(1));
+    assert!(!selected_but_unfocused.is_focused);
+    assert!(selected_but_unfocused.is_selected);
+    assert!(selected_but_unfocused.is_hovered);
+}


thinking
**Verifying rustfmt changes**
exec
/bin/zsh -lc 'cd /Users/johnlindquist/dev/script-kit-gpui && git diff -- src/prompts/select/mod.rs src/prompts/select/prompt.rs src/prompts/select/render.rs src/prompts/select/tests.rs src/list_item/part_000.rs src/list_item/part_001.rs' in /Users/johnlindquist/dev/script-kit-gpuiexec
/bin/zsh -lc "cd /Users/johnlindquist/dev/script-kit-gpui && sed -n '1,160p' src/prompts/select/mod.rs" in /Users/johnlindquist/dev/script-kit-gpui succeeded in 50ms:
diff --git a/src/list_item/part_000.rs b/src/list_item/part_000.rs
index 733d4ac..283b226 100644
--- a/src/list_item/part_000.rs
+++ b/src/list_item/part_000.rs
@@ -15,6 +15,37 @@ pub enum IconKind {
     /// Maps to IconName from designs::icon_variations
     Svg(String),
 }
+
+impl IconKind {
+    /// Resolve icon metadata into an IconKind for list rendering.
+    ///
+    /// Supports:
+    /// - Known SVG names/aliases via `icon_name_from_str` (e.g., "Terminal", "file-code")
+    /// - Emoji/symbol glyphs (e.g., "üìÑ", "‚ö°")
+    pub fn from_icon_hint(icon_hint: &str) -> Option<Self> {
+        let trimmed = icon_hint.trim();
+        if trimmed.is_empty() {
+            return None;
+        }
 succeeded in 51ms:
//! SelectPrompt - Multi-select from choices
//!
//! Features:
//! - Select multiple items from a list
//! - Toggle selection with Cmd/Ctrl+Space
//! - Filter choices by typing
//! - Submit selected items

use gpui::{
    div, prelude::*, px, rgb, uniform_list, AnyElement, Context, FocusHandle, Focusable, Render,
    ScrollStrategy, SharedString, UniformListScrollHandle, Window,
};
use std::collections::HashSet;
use std::ops::Range;
use std::sync::Arc;

use crate::components::{
    Density, ItemState, LeadingContent, TextContent, TrailingContent, UnifiedListItem,
    UnifiedListItemColors,
};
file update:
diff --git a/src/list_item/part_000.rs b/src/list_item/part_000.rs
index 733d4ac2aa5b1b27b29a5999310e6f3f45cc54c3..283b2263d56a92c73c22d44443db7b40971d26ce
--- a/src/list_item/part_000.rs
+++ b/src/list_item/part_000.rs
@@ -15,6 +15,37 @@
     /// Maps to IconName from designs::icon_variations
     Svg(String),
 }
+
+impl IconKind {
+    /// Resolve icon metadata into an IconKind for list rendering.
+    ///
+    /// Supports:
+    /// - Known SVG names/aliases via `icon_name_from_str` (e.g., "Terminal", "file-code")
+    /// - Emoji/symbol glyphs (e.g., "üìÑ", "‚ö°")
+    pub fn from_icon_hint(icon_hint: &str) -> Option<Self> {
+        let trimmed = icon_hint.trim();
+        if trimmed.is_empty() {
+            return None;
+        }
+
+        if icon_name_from_str(trimmed).is_some() {
+            return Some(Self::Svg(trimmed.to_string()));
+        }
+
+        if looks_like_symbol_icon_hint(trimmed) {
+            return Some(Self::Emoji(trimmed.to_string()));
+        }
+
+        None
+    }
+}
+
+fn looks_like_symbol_icon_hint(icon_hint: &str) -> bool {
+    let has_ascii_alnum = icon_hint.chars().any(|ch| ch.is_ascii_alphanumeric());
+    let char_count = icon_hint.chars().count();
+
+    !has_ascii_alnum && char_count <= 4
+}
 /// Fixed height for list items used in uniform-height virtualized lists.
 ///
 /// IMPORTANT: When using GPUI `uniform_list`, the item closure must render
@@ -437,3 +468,29 @@
     /// Text color for content displayed on accent/warning backgrounds
     pub text_on_accent: u32,
 }
+
+#[cfg(test)]
+mod icon_kind_tests {
+    use super::IconKind;
+
+    #[test]
+    fn test_icon_kind_from_icon_hint_returns_svg_when_known_icon_name() {
+        match IconKind::from_icon_hint("terminal") {
+            Some(IconKind::Svg(name)) => assert_eq!(name, "terminal"),
+            _ => panic!("expected SVG icon from known icon hint"),
+        }
+    }
+
+    #[test]
+    fn test_icon_kind_from_icon_hint_returns_emoji_when_symbol_glyph() {
+        match IconKind::from_icon_hint("üìÑ") {
+            Some(IconKind::Emoji(emoji)) => assert_eq!(emoji, "üìÑ"),
+            _ => panic!("expected emoji icon for symbol glyph"),
+        }
+    }
+
+    #[test]
+    fn test_icon_kind_from_icon_hint_returns_none_for_unknown_ascii_word() {
+        assert!(IconKind::from_icon_hint("unknown-icon-name").is_none());
+    }
+}
diff --git a/src/prompts/select/mod.rs b/src/prompts/select/mod.rs
index b6366dabfb14f3fae09f854f9de824fa629e0a3b..32ec6dd9fa7ee4b5d29009f3cc5a665713f97a10
--- a/src/prompts/select/mod.rs
+++ b/src/prompts/select/mod.rs
@@ -19,7 +19,7 @@
     UnifiedListItemColors,
 };
 use crate::designs::{get_tokens, DesignColors, DesignVariant};
-use crate::list_item::LIST_ITEM_HEIGHT;
+use crate::list_item::{IconKind, LIST_ITEM_HEIGHT};
 use crate::logging;
 use crate::panel::PROMPT_INPUT_FIELD_HEIGHT;
 use crate::protocol::{generate_semantic_id, Choice};
@@ -37,5 +37,5 @@
 mod types;
 
 pub use prompt::SelectPrompt;
-use search::*;
-use types::*;
+pub(super) use search::*;
+pub(super) use types::*;
diff --git a/src/prompts/select/prompt.rs b/src/prompts/select/prompt.rs
index c5f98f5318f5b520e9223811f735e866ee06e7fb..5ba2de479b2f5680a73db72642377f68d26ee54e
--- a/src/prompts/select/prompt.rs
+++ b/src/prompts/select/prompt.rs
@@ -19,6 +19,8 @@
     pub filtered_choices: Vec<usize>,
     /// Currently focused index in filtered list
     pub focused_index: usize,
+    /// Currently hovered index in filtered list
+    pub hovered_index: Option<usize>,
     /// Filter text
     pub filter_text: String,
     /// Whether multiple selection is allowed
@@ -68,6 +70,7 @@
             selected: HashSet::new(),
             filtered_choices,
             focused_index: 0,
+            hovered_index: None,
             filter_text: String::new(),
             multiple,
             focus_handle,
@@ -84,6 +87,7 @@
         if trimmed_filter.is_empty() {
             self.filtered_choices = (0..self.choices.len()).collect();
             self.focused_index = 0;
+            self.hovered_index = None;
             return;
         }
 
@@ -109,6 +113,7 @@
 
         self.filtered_choices = scored_matches.into_iter().map(|(idx, _)| idx).collect();
         self.focused_index = 0;
+        self.hovered_index = None;
     }
 
     /// Set the filter text programmatically
@@ -168,6 +173,7 @@
     pub(super) fn move_up(&mut self, cx: &mut Context<Self>) {
         if self.focused_index > 0 {
             self.focused_index -= 1;
+            self.hovered_index = None;
             self.list_scroll_handle
                 .scroll_to_item(self.focused_index, ScrollStrategy::Nearest);
             cx.notify();
@@ -178,6 +184,7 @@
     pub(super) fn move_down(&mut self, cx: &mut Context<Self>) {
         if self.focused_index < self.filtered_choices.len().saturating_sub(1) {
             self.focused_index += 1;
+            self.hovered_index = None;
             self.list_scroll_handle
                 .scroll_to_item(self.focused_index, ScrollStrategy::Nearest);
             cx.notify();
diff --git a/src/prompts/select/render.rs b/src/prompts/select/render.rs
index 62109896c9c14b1b2fbf5b4d25d5d94e4388e4aa..e224ca641be966e7357474d1892f16fb9d59f392
--- a/src/prompts/select/render.rs
+++ b/src/prompts/select/render.rs
@@ -1,5 +1,78 @@
 use super::*;
 
+const ROW_FOCUSED_BG_ALPHA: u32 = 0x3A;
+const ROW_HOVER_BG_ALPHA: u32 = 0x26;
+
+#[derive(Clone, Copy, Debug, PartialEq, Eq)]
+pub(super) struct SelectRowState {
+    pub is_focused: bool,
+    pub is_selected: bool,
+    pub is_hovered: bool,
+}
+
+pub(super) fn compute_row_state(
+    display_idx: usize,
+    focused_index: usize,
+    choice_idx: usize,
+    selected: &HashSet<usize>,
+    hovered_index: Option<usize>,
+) -> SelectRowState {
+    SelectRowState {
+        is_focused: display_idx == focused_index,
+        is_selected: selected.contains(&choice_idx),
+        is_hovered: hovered_index == Some(display_idx),
+    }
+}
+
+pub(super) fn extract_choice_icon_hint(description: Option<&str>) -> Option<&str> {
+    description.and_then(|raw| {
+        raw.split(['‚Ä¢', '|', '\n'])
+            .map(str::trim)
+            .find_map(|token| {
+                let token_lower = token.to_ascii_lowercase();
+                if token_lower == "icon"
+                    || token_lower.starts_with("icon:")
+                    || token_lower.starts_with("icon=")
+                    || token_lower.starts_with("icon ")
+                {
+                    token
+                        .split_once(':')
+                        .or_else(|| token.split_once('='))
+                        .map(|(_, value)| value.trim())
+                        .or_else(|| token.split_whitespace().nth(1))
+                } else {
+                    None
+                }
+            })
+            .filter(|value| !value.is_empty())
+    })
+}
+
+pub(super) fn icon_kind_from_choice(choice: &Choice) -> IconKind {
+    let metadata_icon =
+        extract_choice_icon_hint(choice.description.as_deref()).and_then(IconKind::from_icon_hint);
+    let name_prefix_icon = choice
+        .name
+        .split_whitespace()
+        .next()
+        .and_then(IconKind::from_icon_hint);
+
+    metadata_icon
+        .or(name_prefix_icon)
+        .unwrap_or_else(|| IconKind::Svg("Code".to_string()))
+}
+
+fn leading_content_from_icon_kind(icon_kind: IconKind) -> LeadingContent {
+    match icon_kind {
+        IconKind::Emoji(emoji) => LeadingContent::Emoji(emoji.into()),
+        IconKind::Image(render_image) => LeadingContent::AppIcon(render_image),
+        IconKind::Svg(name) => LeadingContent::Icon {
+            name: SharedString::from(name),
+            color: None,
+        },
+    }
+}
+
 impl Focusable for SelectPrompt {
     fn focus_handle(&self, _cx: &gpui::App) -> FocusHandle {
         self.focus_handle.clone()
@@ -76,6 +149,13 @@
             self.design_variant,
             &colors,
         ));
+        let row_accent_color = if self.design_variant == DesignVariant::Default {
+            self.theme.colors.accent.selected
+        } else {
+            colors.accent
+        };
+        let focused_row_bg = rgba((row_accent_color << 8) | ROW_FOCUSED_BG_ALPHA);
+        let hovered_row_bg = rgba((row_accent_color << 8) | ROW_HOVER_BG_ALPHA);
 
         let placeholder = self
             .placeholder
@@ -145,8 +225,12 @@
                     move |this: &mut SelectPrompt,
                           visible_range: std::ops::Range<usize>,
                           _window,
-                          _cx| {
-                        let row_colors = UnifiedListItemColors::from_theme(&this.theme);
+                          cx| {
+                        let item_colors = UnifiedListItemColors {
+                            selected_opacity: 0.0,
+                            hover_opacity: 0.0,
+                            ..UnifiedListItemColors::from_theme(&this.theme)
+                        };
                         let mut rows = Vec::with_capacity(visible_range.len());
 
                         for display_idx in visible_range {
@@ -154,21 +238,30 @@
                                 if let Some(choice) = this.choices.get(choice_idx) {
                                     if let Some(indexed_choice) = this.choice_index.get(choice_idx)
                                     {
-                                        let is_focused = display_idx == this.focused_index;
-                                        let is_selected = this.selected.contains(&choice_idx);
-                                        let is_selected_for_ui = if this.multiple {
-                                            is_selected
-                                        } else {
-                                            is_focused
-                                        };
+                                        let row_state = compute_row_state(
+                                            display_idx,
+                                            this.focused_index,
+                                            choice_idx,
+                                            &this.selected,
+                                            this.hovered_index,
+                                        );
+                                        let is_focused = row_state.is_focused;
+                                        let is_selected = row_state.is_selected;
+                                        let is_hovered = row_state.is_hovered;
                                         let semantic_id =
                                             choice.semantic_id.clone().unwrap_or_else(|| {
                                                 indexed_choice.stable_semantic_id.clone()
                                             });
-                                        let indicator = choice_selection_indicator(
-                                            this.multiple,
-                                            is_selected_for_ui,
-                                        );
+                                        let leading = if this.multiple {
+                                            Some(LeadingContent::Emoji(
+                                                choice_selection_indicator(true, is_selected)
+                                                    .into(),
+                                            ))
+                                        } else {
+                                            Some(leading_content_from_icon_kind(
+                                                icon_kind_from_choice(choice),
+                                            ))
+                                        };
                                         let subtitle = indexed_choice
                                             .metadata
                                             .subtitle_text()
@@ -185,34 +278,60 @@
                                                     ))
                                                 },
                                             );
+                                        let row_bg = if is_focused {
+                                            focused_row_bg
+                                        } else if is_hovered {
+                                            hovered_row_bg
+                                        } else {
+                                            rgba(0x00000000)
+                                        };
+                                        let hover_handler = cx.listener(
+                                            move |this: &mut SelectPrompt,
+                                                  hovered: &bool,
+                                                  _window,
+                                                  cx| {
+                                                if *hovered {
+                                                    if this.hovered_index != Some(display_idx) {
+                                                        this.hovered_index = Some(display_idx);
+                                                        cx.notify();
+                                                    }
+                                                } else if this.hovered_index == Some(display_idx) {
+                                                    this.hovered_index = None;
+                                                    cx.notify();
+                                                }
+                                            },
+                                        );
+
+                                        let mut row = div()
+                                            .id(display_idx)
+                                            .w_full()
+                                            .h(px(LIST_ITEM_HEIGHT))
+                                            .rounded(px(8.0))
+                                            .bg(row_bg)
+                                            .cursor_pointer()
+                                            .on_hover(hover_handler)
+                                            .child(
+                                                UnifiedListItem::new(
+                                                    gpui::ElementId::Name(semantic_id.into()),
+                                                    title,
+                                                )
+                                                .subtitle_opt(subtitle)
+                                                .leading_opt(leading)
+                                                .trailing_opt(trailing)
+                                                .state(ItemState {
+                                                    is_selected,
+                                                    is_hovered,
+                                                    is_disabled: false,
+                                                })
+                                                .density(Density::Comfortable)
+                                                .colors(item_colors),
+                                            );
+
+                                        if !is_focused {
+                                            row = row.hover(move |s| s.bg(hovered_row_bg));
+                                        }
 
-                                        rows.push(
-                                            div()
-                                                .id(display_idx)
-                                                .w_full()
-                                                .h(px(LIST_ITEM_HEIGHT))
-                                                .border_b_1()
-                                                .border_color(border_color)
-                                                .child(
-                                                    UnifiedListItem::new(
-                                                        gpui::ElementId::Name(semantic_id.into()),
-                                                        title,
-                                                    )
-                                                    .subtitle_opt(subtitle)
-                                                    .leading(LeadingContent::Emoji(
-                                                        indicator.into(),
-                                                    ))
-                                                    .trailing_opt(trailing)
-                                                    .state(ItemState {
-                                                        is_selected: is_focused,
-                                                        is_hovered: false,
-                                                        is_disabled: false,
-                                                    })
-                                                    .density(Density::Comfortable)
-                                                    .colors(row_colors)
-                                                    .with_accent_bar(is_selected_for_ui),
-                                                ),
-                                        );
+                                        rows.push(row);
                                     }
                                 }
                             }
@@ -234,6 +353,7 @@
             .flex_col()
             .flex_1()
             .w_full()
+            .px(px(8.0))
             .child(choices_content);
 
         div()
diff --git a/src/prompts/select/tests.rs b/src/prompts/select/tests.rs
index 250ec9d63282ad81dd952efa12855f784330232c..2b048753d5f168dcbc59ccb0e399e4604bc39167
--- a/src/prompts/select/tests.rs
+++ b/src/prompts/select/tests.rs
@@ -184,3 +184,36 @@
         0x445566
     );
 }
+
+#[test]
+fn test_select_prompt_extracts_icon_hint_from_choice_metadata() {
+    let description = Some("Shortcut: cmd+k ‚Ä¢ icon: terminal ‚Ä¢ script");
+    assert_eq!(
+        render::extract_choice_icon_hint(description),
+        Some("terminal")
+    );
+}
+
+#[test]
+fn test_select_prompt_icon_kind_falls_back_to_code_icon_without_hint() {
+    let choice = choice("Deploy API", "/Users/me/.scriptkit/scripts/deploy.ts", None);
+
+    match render::icon_kind_from_choice(&choice) {
+        IconKind::Svg(name) => assert_eq!(name, "Code"),
+        _ => panic!("expected fallback Code SVG icon"),
+    }
+}
+
+#[test]
+fn test_select_prompt_compute_row_state_keeps_focus_and_selection_independent() {
+    let selected = std::collections::HashSet::from([5]);
+    let focused_but_unselected = render::compute_row_state(2, 2, 1, &selected, Some(1));
+    assert!(focused_but_unselected.is_focused);
+    assert!(!focused_but_unselected.is_selected);
+    assert!(!focused_but_unselected.is_hovered);
+
+    let selected_but_unfocused = render::compute_row_state(1, 2, 5, &selected, Some(1));
+    assert!(!selected_but_unfocused.is_focused);
+    assert!(selected_but_unfocused.is_selected);
+    assert!(selected_but_unfocused.is_hovered);
+}


thinking
**Verifying render module changes**
exec
/bin/zsh -lc 'cd /Users/johnlindquist/dev/script-kit-gpui && rg -n "''^name'"\\s*=\\s*\\\"\" Cargo.toml | head" in /Users/johnlindquist/dev/script-kit-gpui succeeded in 51ms:
2:name = "script-kit-gpui"
8:name = "script_kit_gpui"
12:name = "script-kit-gpui"
17:name = "smoke-test"
22:name = "storybook"
177:name = "Script Kit"
file update:
diff --git a/src/list_item/part_000.rs b/src/list_item/part_000.rs
index 733d4ac2aa5b1b27b29a5999310e6f3f45cc54c3..283b2263d56a92c73c22d44443db7b40971d26ce
--- a/src/list_item/part_000.rs
+++ b/src/list_item/part_000.rs
@@ -15,6 +15,37 @@
     /// Maps to IconName from designs::icon_variations
     Svg(String),
 }
+
+impl IconKind {
+    /// Resolve icon metadata into an IconKind for list rendering.
+    ///
+    /// Supports:
+    /// - Known SVG names/aliases via `icon_name_from_str` (e.g., "Terminal", "file-code")
+    /// - Emoji/symbol glyphs (e.g., "üìÑ", "‚ö°")
+    pub fn from_icon_hint(icon_hint: &str) -> Option<Self> {
+        let trimmed = icon_hint.trim();
+        if trimmed.is_empty() {
+            return None;
+        }
+
+        if icon_name_from_str(trimmed).is_some() {
+            return Some(Self::Svg(trimmed.to_string()));
+        }
+
+        if looks_like_symbol_icon_hint(trimmed) {
+            return Some(Self::Emoji(trimmed.to_string()));
+        }
+
+        None
+    }
+}
+
+fn looks_like_symbol_icon_hint(icon_hint: &str) -> bool {
+    let has_ascii_alnum = icon_hint.chars().any(|ch| ch.is_ascii_alphanumeric());
+    let char_count = icon_hint.chars().count();
+
+    !has_ascii_alnum && char_count <= 4
+}
 /// Fixed height for list items used in uniform-height virtualized lists.
 ///
 /// IMPORTANT: When using GPUI `uniform_list`, the item closure must render
@@ -437,3 +468,29 @@
     /// Text color for content displayed on accent/warning backgrounds
     pub text_on_accent: u32,
 }
+
+#[cfg(test)]
+mod icon_kind_tests {
+    use super::IconKind;
+
+    #[test]
+    fn test_icon_kind_from_icon_hint_returns_svg_when_known_icon_name() {
+        match IconKind::from_icon_hint("terminal") {
+            Some(IconKind::Svg(name)) => assert_eq!(name, "terminal"),
+            _ => panic!("expected SVG icon from known icon hint"),
+        }
+    }
+
+    #[test]
+    fn test_icon_kind_from_icon_hint_returns_emoji_when_symbol_glyph() {
+        match IconKind::from_icon_hint("üìÑ") {
+            Some(IconKind::Emoji(emoji)) => assert_eq!(emoji, "üìÑ"),
+            _ => panic!("expected emoji icon for symbol glyph"),
+        }
+    }
+
+    #[test]
+    fn test_icon_kind_from_icon_hint_returns_none_for_unknown_ascii_word() {
+        assert!(IconKind::from_icon_hint("unknown-icon-name").is_none());
+    }
+}
diff --git a/src/prompts/select/mod.rs b/src/prompts/select/mod.rs
index b6366dabfb14f3fae09f854f9de824fa629e0a3b..32ec6dd9fa7ee4b5d29009f3cc5a665713f97a10
--- a/src/prompts/select/mod.rs
+++ b/src/prompts/select/mod.rs
@@ -19,7 +19,7 @@
     UnifiedListItemColors,
 };
 use crate::designs::{get_tokens, DesignColors, DesignVariant};
-use crate::list_item::LIST_ITEM_HEIGHT;
+use crate::list_item::{IconKind, LIST_ITEM_HEIGHT};
 use crate::logging;
 use crate::panel::PROMPT_INPUT_FIELD_HEIGHT;
 use crate::protocol::{generate_semantic_id, Choice};
@@ -37,5 +37,5 @@
 mod types;
 
 pub use prompt::SelectPrompt;
-use search::*;
-use types::*;
+pub(super) use search::*;
+pub(super) use types::*;
diff --git a/src/prompts/select/prompt.rs b/src/prompts/select/prompt.rs
index c5f98f5318f5b520e9223811f735e866ee06e7fb..5ba2de479b2f5680a73db72642377f68d26ee54e
--- a/src/prompts/select/prompt.rs
+++ b/src/prompts/select/prompt.rs
@@ -19,6 +19,8 @@
     pub filtered_choices: Vec<usize>,
     /// Currently focused index in filtered list
     pub focused_index: usize,
+    /// Currently hovered index in filtered list
+    pub hovered_index: Option<usize>,
     /// Filter text
     pub filter_text: String,
     /// Whether multiple selection is allowed
@@ -68,6 +70,7 @@
             selected: HashSet::new(),
             filtered_choices,
             focused_index: 0,
+            hovered_index: None,
             filter_text: String::new(),
             multiple,
             focus_handle,
@@ -84,6 +87,7 @@
         if trimmed_filter.is_empty() {
             self.filtered_choices = (0..self.choices.len()).collect();
             self.focused_index = 0;
+            self.hovered_index = None;
             return;
         }
 
@@ -109,6 +113,7 @@
 
         self.filtered_choices = scored_matches.into_iter().map(|(idx, _)| idx).collect();
         self.focused_index = 0;
+        self.hovered_index = None;
     }
 
     /// Set the filter text programmatically
@@ -168,6 +173,7 @@
     pub(super) fn move_up(&mut self, cx: &mut Context<Self>) {
         if self.focused_index > 0 {
             self.focused_index -= 1;
+            self.hovered_index = None;
             self.list_scroll_handle
                 .scroll_to_item(self.focused_index, ScrollStrategy::Nearest);
             cx.notify();
@@ -178,6 +184,7 @@
     pub(super) fn move_down(&mut self, cx: &mut Context<Self>) {
         if self.focused_index < self.filtered_choices.len().saturating_sub(1) {
             self.focused_index += 1;
+            self.hovered_index = None;
             self.list_scroll_handle
                 .scroll_to_item(self.focused_index, ScrollStrategy::Nearest);
             cx.notify();
diff --git a/src/prompts/select/render.rs b/src/prompts/select/render.rs
index 62109896c9c14b1b2fbf5b4d25d5d94e4388e4aa..e224ca641be966e7357474d1892f16fb9d59f392
--- a/src/prompts/select/render.rs
+++ b/src/prompts/select/render.rs
@@ -1,5 +1,78 @@
 use super::*;
 
+const ROW_FOCUSED_BG_ALPHA: u32 = 0x3A;
+const ROW_HOVER_BG_ALPHA: u32 = 0x26;
+
+#[derive(Clone, Copy, Debug, PartialEq, Eq)]
+pub(super) struct SelectRowState {
+    pub is_focused: bool,
+    pub is_selected: bool,
+    pub is_hovered: bool,
+}
+
+pub(super) fn compute_row_state(
+    display_idx: usize,
+    focused_index: usize,
+    choice_idx: usize,
+    selected: &HashSet<usize>,
+    hovered_index: Option<usize>,
+) -> SelectRowState {
+    SelectRowState {
+        is_focused: display_idx == focused_index,
+        is_selected: selected.contains(&choice_idx),
+        is_hovered: hovered_index == Some(display_idx),
+    }
+}
+
+pub(super) fn extract_choice_icon_hint(description: Option<&str>) -> Option<&str> {
+    description.and_then(|raw| {
+        raw.split(['‚Ä¢', '|', '\n'])
+            .map(str::trim)
+            .find_map(|token| {
+                let token_lower = token.to_ascii_lowercase();
+                if token_lower == "icon"
+                    || token_lower.starts_with("icon:")
+                    || token_lower.starts_with("icon=")
+                    || token_lower.starts_with("icon ")
+                {
+                    token
+                        .split_once(':')
+                        .or_else(|| token.split_once('='))
+                        .map(|(_, value)| value.trim())
+                        .or_else(|| token.split_whitespace().nth(1))
+                } else {
+                    None
+                }
+            })
+            .filter(|value| !value.is_empty())
+    })
+}
+
+pub(super) fn icon_kind_from_choice(choice: &Choice) -> IconKind {
+    let metadata_icon =
+        extract_choice_icon_hint(choice.description.as_deref()).and_then(IconKind::from_icon_hint);
+    let name_prefix_icon = choice
+        .name
+        .split_whitespace()
+        .next()
+        .and_then(IconKind::from_icon_hint);
+
+    metadata_icon
+        .or(name_prefix_icon)
+        .unwrap_or_else(|| IconKind::Svg("Code".to_string()))
+}
+
+fn leading_content_from_icon_kind(icon_kind: IconKind) -> LeadingContent {
+    match icon_kind {
+        IconKind::Emoji(emoji) => LeadingContent::Emoji(emoji.into()),
+        IconKind::Image(render_image) => LeadingContent::AppIcon(render_image),
+        IconKind::Svg(name) => LeadingContent::Icon {
+            name: SharedString::from(name),
+            color: None,
+        },
+    }
+}
+
 impl Focusable for SelectPrompt {
     fn focus_handle(&self, _cx: &gpui::App) -> FocusHandle {
         self.focus_handle.clone()
@@ -76,6 +149,13 @@
             self.design_variant,
             &colors,
         ));
+        let row_accent_color = if self.design_variant == DesignVariant::Default {
+            self.theme.colors.accent.selected
+        } else {
+            colors.accent
+        };
+        let focused_row_bg = rgba((row_accent_color << 8) | ROW_FOCUSED_BG_ALPHA);
+        let hovered_row_bg = rgba((row_accent_color << 8) | ROW_HOVER_BG_ALPHA);
 
         let placeholder = self
             .placeholder
@@ -145,8 +225,12 @@
                     move |this: &mut SelectPrompt,
                           visible_range: std::ops::Range<usize>,
                           _window,
-                          _cx| {
-                        let row_colors = UnifiedListItemColors::from_theme(&this.theme);
+                          cx| {
+                        let item_colors = UnifiedListItemColors {
+                            selected_opacity: 0.0,
+                            hover_opacity: 0.0,
+                            ..UnifiedListItemColors::from_theme(&this.theme)
+                        };
                         let mut rows = Vec::with_capacity(visible_range.len());
 
                         for display_idx in visible_range {
@@ -154,21 +238,30 @@
                                 if let Some(choice) = this.choices.get(choice_idx) {
                                     if let Some(indexed_choice) = this.choice_index.get(choice_idx)
                                     {
-                                        let is_focused = display_idx == this.focused_index;
-                                        let is_selected = this.selected.contains(&choice_idx);
-                                        let is_selected_for_ui = if this.multiple {
-                                            is_selected
-                                        } else {
-                                            is_focused
-                                        };
+                                        let row_state = compute_row_state(
+                                            display_idx,
+                                            this.focused_index,
+                                            choice_idx,
+                                            &this.selected,
+                                            this.hovered_index,
+                                        );
+                                        let is_focused = row_state.is_focused;
+                                        let is_selected = row_state.is_selected;
+                                        let is_hovered = row_state.is_hovered;
                                         let semantic_id =
                                             choice.semantic_id.clone().unwrap_or_else(|| {
                                                 indexed_choice.stable_semantic_id.clone()
                                             });
-                                        let indicator = choice_selection_indicator(
-                                            this.multiple,
-                                            is_selected_for_ui,
-                                        );
+                                        let leading = if this.multiple {
+                                            Some(LeadingContent::Emoji(
+                                                choice_selection_indicator(true, is_selected)
+                                                    .into(),
+                                            ))
+                                        } else {
+                                            Some(leading_content_from_icon_kind(
+                                                icon_kind_from_choice(choice),
+                                            ))
+                                        };
                                         let subtitle = indexed_choice
                                             .metadata
                                             .subtitle_text()
@@ -185,34 +278,60 @@
                                                     ))
                                                 },
                                             );
+                                        let row_bg = if is_focused {
+                                            focused_row_bg
+                                        } else if is_hovered {
+                                            hovered_row_bg
+                                        } else {
+                                            rgba(0x00000000)
+                                        };
+                                        let hover_handler = cx.listener(
+                                            move |this: &mut SelectPrompt,
+                                                  hovered: &bool,
+                                                  _window,
+                                                  cx| {
+                                                if *hovered {
+                                                    if this.hovered_index != Some(display_idx) {
+                                                        this.hovered_index = Some(display_idx);
+                                                        cx.notify();
+                                                    }
+                                                } else if this.hovered_index == Some(display_idx) {
+                                                    this.hovered_index = None;
+                                                    cx.notify();
+                                                }
+                                            },
+                                        );
+
+                                        let mut row = div()
+                                            .id(display_idx)
+                                            .w_full()
+                                            .h(px(LIST_ITEM_HEIGHT))
+                                            .rounded(px(8.0))
+                                            .bg(row_bg)
+                                            .cursor_pointer()
+                                            .on_hover(hover_handler)
+                                            .child(
+                                                UnifiedListItem::new(
+                                                    gpui::ElementId::Name(semantic_id.into()),
+                                                    title,
+                                                )
+                                                .subtitle_opt(subtitle)
+                                                .leading_opt(leading)
+                                                .trailing_opt(trailing)
+                                                .state(ItemState {
+                                                    is_selected,
+                                                    is_hovered,
+                                                    is_disabled: false,
+                                                })
+                                                .density(Density::Comfortable)
+                                                .colors(item_colors),
+                                            );
+
+                                        if !is_focused {
+                                            row = row.hover(move |s| s.bg(hovered_row_bg));
+                                        }
 
-                                        rows.push(
-                                            div()
-                                                .id(display_idx)
-                                                .w_full()
-                                                .h(px(LIST_ITEM_HEIGHT))
-                                                .border_b_1()
-                                                .border_color(border_color)
-                                                .child(
-                                                    UnifiedListItem::new(
-                                                        gpui::ElementId::Name(semantic_id.into()),
-                                                        title,
-                                                    )
-                                                    .subtitle_opt(subtitle)
-                                                    .leading(LeadingContent::Emoji(
-                                                        indicator.into(),
-                                                    ))
-                                                    .trailing_opt(trailing)
-                                                    .state(ItemState {
-                                                        is_selected: is_focused,
-                                                        is_hovered: false,
-                                                        is_disabled: false,
-                                                    })
-                                                    .density(Density::Comfortable)
-                                                    .colors(row_colors)
-                                                    .with_accent_bar(is_selected_for_ui),
-                                                ),
-                                        );
+                                        rows.push(row);
                                     }
                                 }
                             }
@@ -234,6 +353,7 @@
             .flex_col()
             .flex_1()
             .w_full()
+            .px(px(8.0))
             .child(choices_content);
 
         div()
diff --git a/src/prompts/select/tests.rs b/src/prompts/select/tests.rs
index 250ec9d63282ad81dd952efa12855f784330232c..2b048753d5f168dcbc59ccb0e399e4604bc39167
--- a/src/prompts/select/tests.rs
+++ b/src/prompts/select/tests.rs
@@ -184,3 +184,36 @@
         0x445566
     );
 }
+
+#[test]
+fn test_select_prompt_extracts_icon_hint_from_choice_metadata() {
+    let description = Some("Shortcut: cmd+k ‚Ä¢ icon: terminal ‚Ä¢ script");
+    assert_eq!(
+        render::extract_choice_icon_hint(description),
+        Some("terminal")
+    );
+}
+
+#[test]
+fn test_select_prompt_icon_kind_falls_back_to_code_icon_without_hint() {
+    let choice = choice("Deploy API", "/Users/me/.scriptkit/scripts/deploy.ts", None);
+
+    match render::icon_kind_from_choice(&choice) {
+        IconKind::Svg(name) => assert_eq!(name, "Code"),
+        _ => panic!("expected fallback Code SVG icon"),
+    }
+}
+
+#[test]
+fn test_select_prompt_compute_row_state_keeps_focus_and_selection_independent() {
+    let selected = std::collections::HashSet::from([5]);
+    let focused_but_unselected = render::compute_row_state(2, 2, 1, &selected, Some(1));
+    assert!(focused_but_unselected.is_focused);
+    assert!(!focused_but_unselected.is_selected);
+    assert!(!focused_but_unselected.is_hovered);
+
+    let selected_but_unfocused = render::compute_row_state(1, 2, 5, &selected, Some(1));
+    assert!(!selected_but_unfocused.is_focused);
+    assert!(selected_but_unfocused.is_selected);
+    assert!(selected_but_unfocused.is_hovered);
+}


thinking
**Planning scoped cargo commands**
codex
Edits are in place and formatted. I‚Äôm now running scoped verification for this package (`-p script-kit-gpui`) with check, clippy, and tests to ensure these changes compile and pass in the parallel-agent workspace.
exec
/bin/zsh -lc 'cd /Users/johnlindquist/dev/script-kit-gpui && cargo check -p script-kit-gpui' in /Users/johnlindquist/dev/script-kit-gpuifile update:
diff --git a/src/list_item/part_000.rs b/src/list_item/part_000.rs
index 733d4ac2aa5b1b27b29a5999310e6f3f45cc54c3..283b2263d56a92c73c22d44443db7b40971d26ce
--- a/src/list_item/part_000.rs
+++ b/src/list_item/part_000.rs
@@ -15,6 +15,37 @@
     /// Maps to IconName from designs::icon_variations
     Svg(String),
 }
+
+impl IconKind {
+    /// Resolve icon metadata into an IconKind for list rendering.
+    ///
+    /// Supports:
+    /// - Known SVG names/aliases via `icon_name_from_str` (e.g., "Terminal", "file-code")
+    /// - Emoji/symbol glyphs (e.g., "üìÑ", "‚ö°")
+    pub fn from_icon_hint(icon_hint: &str) -> Option<Self> {
+        let trimmed = icon_hint.trim();
+        if trimmed.is_empty() {
+            return None;
+        }
+
+        if icon_name_from_str(trimmed).is_some() {
+            return Some(Self::Svg(trimmed.to_string()));
+        }
+
+        if looks_like_symbol_icon_hint(trimmed) {
+            return Some(Self::Emoji(trimmed.to_string()));
+        }
+
+        None
+    }
+}
+
+fn looks_like_symbol_icon_hint(icon_hint: &str) -> bool {
+    let has_ascii_alnum = icon_hint.chars().any(|ch| ch.is_ascii_alphanumeric());
+    let char_count = icon_hint.chars().count();
+
+    !has_ascii_alnum && char_count <= 4
+}
 /// Fixed height for list items used in uniform-height virtualized lists.
 ///
 /// IMPORTANT: When using GPUI `uniform_list`, the item closure must render
@@ -437,3 +468,29 @@
     /// Text color for content displayed on accent/warning backgrounds
     pub text_on_accent: u32,
 }
+
+#[cfg(test)]
+mod icon_kind_tests {
+    use super::IconKind;
+
+    #[test]
+    fn test_icon_kind_from_icon_hint_returns_svg_when_known_icon_name() {
+        match IconKind::from_icon_hint("terminal") {
+            Some(IconKind::Svg(name)) => assert_eq!(name, "terminal"),
+            _ => panic!("expected SVG icon from known icon hint"),
+        }
+    }
+
+    #[test]
+    fn test_icon_kind_from_icon_hint_returns_emoji_when_symbol_glyph() {
+        match IconKind::from_icon_hint("üìÑ") {
+            Some(IconKind::Emoji(emoji)) => assert_eq!(emoji, "üìÑ"),
+            _ => panic!("expected emoji icon for symbol glyph"),
+        }
+    }
+
+    #[test]
+    fn test_icon_kind_from_icon_hint_returns_none_for_unknown_ascii_word() {
+        assert!(IconKind::from_icon_hint("unknown-icon-name").is_none());
+    }
+}
diff --git a/src/prompts/select/mod.rs b/src/prompts/select/mod.rs
index b6366dabfb14f3fae09f854f9de824fa629e0a3b..32ec6dd9fa7ee4b5d29009f3cc5a665713f97a10
--- a/src/prompts/select/mod.rs
+++ b/src/prompts/select/mod.rs
@@ -19,7 +19,7 @@
     UnifiedListItemColors,
 };
 use crate::designs::{get_tokens, DesignColors, DesignVariant};
-use crate::list_item::LIST_ITEM_HEIGHT;
+use crate::list_item::{IconKind, LIST_ITEM_HEIGHT};
 use crate::logging;
 use crate::panel::PROMPT_INPUT_FIELD_HEIGHT;
 use crate::protocol::{generate_semantic_id, Choice};
@@ -37,5 +37,5 @@
 mod types;
 
 pub use prompt::SelectPrompt;
-use search::*;
-use types::*;
+pub(super) use search::*;
+pub(super) use types::*;
diff --git a/src/prompts/select/prompt.rs b/src/prompts/select/prompt.rs
index c5f98f5318f5b520e9223811f735e866ee06e7fb..5ba2de479b2f5680a73db72642377f68d26ee54e
--- a/src/prompts/select/prompt.rs
+++ b/src/prompts/select/prompt.rs
@@ -19,6 +19,8 @@
     pub filtered_choices: Vec<usize>,
     /// Currently focused index in filtered list
     pub focused_index: usize,
+    /// Currently hovered index in filtered list
+    pub hovered_index: Option<usize>,
     /// Filter text
     pub filter_text: String,
     /// Whether multiple selection is allowed
@@ -68,6 +70,7 @@
             selected: HashSet::new(),
             filtered_choices,
             focused_index: 0,
+            hovered_index: None,
             filter_text: String::new(),
             multiple,
             focus_handle,
@@ -84,6 +87,7 @@
         if trimmed_filter.is_empty() {
             self.filtered_choices = (0..self.choices.len()).collect();
             self.focused_index = 0;
+            self.hovered_index = None;
             return;
         }
 
@@ -109,6 +113,7 @@
 
         self.filtered_choices = scored_matches.into_iter().map(|(idx, _)| idx).collect();
         self.focused_index = 0;
+        self.hovered_index = None;
     }
 
     /// Set the filter text programmatically
@@ -168,6 +173,7 @@
     pub(super) fn move_up(&mut self, cx: &mut Context<Self>) {
         if self.focused_index > 0 {
             self.focused_index -= 1;
+            self.hovered_index = None;
             self.list_scroll_handle
                 .scroll_to_item(self.focused_index, ScrollStrategy::Nearest);
             cx.notify();
@@ -178,6 +184,7 @@
     pub(super) fn move_down(&mut self, cx: &mut Context<Self>) {
         if self.focused_index < self.filtered_choices.len().saturating_sub(1) {
             self.focused_index += 1;
+            self.hovered_index = None;
             self.list_scroll_handle
                 .scroll_to_item(self.focused_index, ScrollStrategy::Nearest);
             cx.notify();
diff --git a/src/prompts/select/render.rs b/src/prompts/select/render.rs
index 62109896c9c14b1b2fbf5b4d25d5d94e4388e4aa..e224ca641be966e7357474d1892f16fb9d59f392
--- a/src/prompts/select/render.rs
+++ b/src/prompts/select/render.rs
@@ -1,5 +1,78 @@
 use super::*;
 
+const ROW_FOCUSED_BG_ALPHA: u32 = 0x3A;
+const ROW_HOVER_BG_ALPHA: u32 = 0x26;
+
+#[derive(Clone, Copy, Debug, PartialEq, Eq)]
+pub(super) struct SelectRowState {
+    pub is_focused: bool,
+    pub is_selected: bool,
+    pub is_hovered: bool,
+}
+
+pub(super) fn compute_row_state(
+    display_idx: usize,
+    focused_index: usize,
+    choice_idx: usize,
+    selected: &HashSet<usize>,
+    hovered_index: Option<usize>,
+) -> SelectRowState {
+    SelectRowState {
+        is_focused: display_idx == focused_index,
+        is_selected: selected.contains(&choice_idx),
+        is_hovered: hovered_index == Some(display_idx),
+    }
+}
+
+pub(super) fn extract_choice_icon_hint(description: Option<&str>) -> Option<&str> {
+    description.and_then(|raw| {
+        raw.split(['‚Ä¢', '|', '\n'])
+            .map(str::trim)
+            .find_map(|token| {
+                let token_lower = token.to_ascii_lowercase();
+                if token_lower == "icon"
+                    || token_lower.starts_with("icon:")
+                    || token_lower.starts_with("icon=")
+                    || token_lower.starts_with("icon ")
+                {
+                    token
+                        .split_once(':')
+                        .or_else(|| token.split_once('='))
+                        .map(|(_, value)| value.trim())
+                        .or_else(|| token.split_whitespace().nth(1))
+                } else {
+                    None
+                }
+            })
+            .filter(|value| !value.is_empty())
+    })
+}
+
+pub(super) fn icon_kind_from_choice(choice: &Choice) -> IconKind {
+    let metadata_icon =
+        extract_choice_icon_hint(choice.description.as_deref()).and_then(IconKind::from_icon_hint);
+    let name_prefix_icon = choice
+        .name
+        .split_whitespace()
+        .next()
+        .and_then(IconKind::from_icon_hint);
+
+    metadata_icon
+        .or(name_prefix_icon)
+        .unwrap_or_else(|| IconKind::Svg("Code".to_string()))
+}
+
+fn leading_content_from_icon_kind(icon_kind: IconKind) -> LeadingContent {
+    match icon_kind {
+        IconKind::Emoji(emoji) => LeadingContent::Emoji(emoji.into()),
+        IconKind::Image(render_image) => LeadingContent::AppIcon(render_image),
+        IconKind::Svg(name) => LeadingContent::Icon {
+            name: SharedString::from(name),
+            color: None,
+        },
+    }
+}
+
 impl Focusable for SelectPrompt {
     fn focus_handle(&self, _cx: &gpui::App) -> FocusHandle {
         self.focus_handle.clone()
@@ -76,6 +149,13 @@
             self.design_variant,
             &colors,
         ));
+        let row_accent_color = if self.design_variant == DesignVariant::Default {
+            self.theme.colors.accent.selected
+        } else {
+            colors.accent
+        };
+        let focused_row_bg = rgba((row_accent_color << 8) | ROW_FOCUSED_BG_ALPHA);
+        let hovered_row_bg = rgba((row_accent_color << 8) | ROW_HOVER_BG_ALPHA);
 
         let placeholder = self
             .placeholder
@@ -145,8 +225,12 @@
                     move |this: &mut SelectPrompt,
                           visible_range: std::ops::Range<usize>,
                           _window,
-                          _cx| {
-                        let row_colors = UnifiedListItemColors::from_theme(&this.theme);
+                          cx| {
+                        let item_colors = UnifiedListItemColors {
+                            selected_opacity: 0.0,
+                            hover_opacity: 0.0,
+                            ..UnifiedListItemColors::from_theme(&this.theme)
+                        };
                         let mut rows = Vec::with_capacity(visible_range.len());
 
                         for display_idx in visible_range {
@@ -154,21 +238,30 @@
                                 if let Some(choice) = this.choices.get(choice_idx) {
                                     if let Some(indexed_choice) = this.choice_index.get(choice_idx)
                                     {
-                                        let is_focused = display_idx == this.focused_index;
-                                        let is_selected = this.selected.contains(&choice_idx);
-                                        let is_selected_for_ui = if this.multiple {
-                                            is_selected
-                                        } else {
-                                            is_focused
-                                        };
+                                        let row_state = compute_row_state(
+                                            display_idx,
+                                            this.focused_index,
+                                            choice_idx,
+                                            &this.selected,
+                                            this.hovered_index,
+                                        );
+                                        let is_focused = row_state.is_focused;
+                                        let is_selected = row_state.is_selected;
+                                        let is_hovered = row_state.is_hovered;
                                         let semantic_id =
                                             choice.semantic_id.clone().unwrap_or_else(|| {
                                                 indexed_choice.stable_semantic_id.clone()
                                             });
-                                        let indicator = choice_selection_indicator(
-                                            this.multiple,
-                                            is_selected_for_ui,
-                                        );
+                                        let leading = if this.multiple {
+                                            Some(LeadingContent::Emoji(
+                                                choice_selection_indicator(true, is_selected)
+                                                    .into(),
+                                            ))
+                                        } else {
+                                            Some(leading_content_from_icon_kind(
+                                                icon_kind_from_choice(choice),
+                                            ))
+                                        };
                                         let subtitle = indexed_choice
                                             .metadata
                                             .subtitle_text()
@@ -185,34 +278,60 @@
                                                     ))
                                                 },
                                             );
+                                        let row_bg = if is_focused {
+                                            focused_row_bg
+                                        } else if is_hovered {
+                                            hovered_row_bg
+                                        } else {
+                                            rgba(0x00000000)
+                                        };
+                                        let hover_handler = cx.listener(
+                                            move |this: &mut SelectPrompt,
+                                                  hovered: &bool,
+                                                  _window,
+                                                  cx| {
+                                                if *hovered {
+                                                    if this.hovered_index != Some(display_idx) {
+                                                        this.hovered_index = Some(display_idx);
+                                                        cx.notify();
+                                                    }
+                                                } else if this.hovered_index == Some(display_idx) {
+                                                    this.hovered_index = None;
+                                                    cx.notify();
+                                                }
+                                            },
+                                        );
+
+                                        let mut row = div()
+                                            .id(display_idx)
+                                            .w_full()
+                                            .h(px(LIST_ITEM_HEIGHT))
+                                            .rounded(px(8.0))
+                                            .bg(row_bg)
+                                            .cursor_pointer()
+                                            .on_hover(hover_handler)
+                                            .child(
+                                                UnifiedListItem::new(
+                                                    gpui::ElementId::Name(semantic_id.into()),
+                                                    title,
+                                                )
+                                                .subtitle_opt(subtitle)
+                                                .leading_opt(leading)
+                                                .trailing_opt(trailing)
+                                                .state(ItemState {
+                                                    is_selected,
+                                                    is_hovered,
+                                                    is_disabled: false,
+                                                })
+                                                .density(Density::Comfortable)
+                                                .colors(item_colors),
+                                            );
+
+                                        if !is_focused {
+                                            row = row.hover(move |s| s.bg(hovered_row_bg));
+                                        }
 
-                                        rows.push(
-                                            div()
-                                                .id(display_idx)
-                                                .w_full()
-                                                .h(px(LIST_ITEM_HEIGHT))
-                                                .border_b_1()
-                                                .border_color(border_color)
-                                                .child(
-                                                    UnifiedListItem::new(
-                                                        gpui::ElementId::Name(semantic_id.into()),
-                                                        title,
-                                                    )
-                                                    .subtitle_opt(subtitle)
-                                                    .leading(LeadingContent::Emoji(
-                                                        indicator.into(),
-                                                    ))
-                                                    .trailing_opt(trailing)
-                                                    .state(ItemState {
-                                                        is_selected: is_focused,
-                                                        is_hovered: false,
-                                                        is_disabled: false,
-                                                    })
-                                                    .density(Density::Comfortable)
-                                                    .colors(row_colors)
-                                                    .with_accent_bar(is_selected_for_ui),
-                                                ),
-                                        );
+                                        rows.push(row);
                                     }
                                 }
                             }
@@ -234,6 +353,7 @@
             .flex_col()
             .flex_1()
             .w_full()
+            .px(px(8.0))
             .child(choices_content);
 
         div()
diff --git a/src/prompts/select/tests.rs b/src/prompts/select/tests.rs
index 250ec9d63282ad81dd952efa12855f784330232c..2b048753d5f168dcbc59ccb0e399e4604bc39167
--- a/src/prompts/select/tests.rs
+++ b/src/prompts/select/tests.rs
@@ -184,3 +184,36 @@
         0x445566
     );
 }
+
+#[test]
+fn test_select_prompt_extracts_icon_hint_from_choice_metadata() {
+    let description = Some("Shortcut: cmd+k ‚Ä¢ icon: terminal ‚Ä¢ script");
+    assert_eq!(
+        render::extract_choice_icon_hint(description),
+        Some("terminal")
+    );
+}
+
+#[test]
+fn test_select_prompt_icon_kind_falls_back_to_code_icon_without_hint() {
+    let choice = choice("Deploy API", "/Users/me/.scriptkit/scripts/deploy.ts", None);
+
+    match render::icon_kind_from_choice(&choice) {
+        IconKind::Svg(name) => assert_eq!(name, "Code"),
+        _ => panic!("expected fallback Code SVG icon"),
+    }
+}
+
+#[test]
+fn test_select_prompt_compute_row_state_keeps_focus_and_selection_independent() {
+    let selected = std::collections::HashSet::from([5]);
+    let focused_but_unselected = render::compute_row_state(2, 2, 1, &selected, Some(1));
+    assert!(focused_but_unselected.is_focused);
+    assert!(!focused_but_unselected.is_selected);
+    assert!(!focused_but_unselected.is_hovered);
+
+    let selected_but_unfocused = render::compute_row_state(1, 2, 5, &selected, Some(1));
+    assert!(!selected_but_unfocused.is_focused);
+    assert!(selected_but_unfocused.is_selected);
+    assert!(selected_but_unfocused.is_hovered);
+}


thinking
**Planning session polling**
file update:
diff --git a/src/list_item/part_000.rs b/src/list_item/part_000.rs
index 733d4ac2aa5b1b27b29a5999310e6f3f45cc54c3..283b2263d56a92c73c22d44443db7b40971d26ce
--- a/src/list_item/part_000.rs
+++ b/src/list_item/part_000.rs
@@ -15,6 +15,37 @@
     /// Maps to IconName from designs::icon_variations
     Svg(String),
 }
+
+impl IconKind {
+    /// Resolve icon metadata into an IconKind for list rendering.
+    ///
+    /// Supports:
+    /// - Known SVG names/aliases via `icon_name_from_str` (e.g., "Terminal", "file-code")
+    /// - Emoji/symbol glyphs (e.g., "üìÑ", "‚ö°")
+    pub fn from_icon_hint(icon_hint: &str) -> Option<Self> {
+        let trimmed = icon_hint.trim();
+        if trimmed.is_empty() {
+            return None;
+        }
+
+        if icon_name_from_str(trimmed).is_some() {
+            return Some(Self::Svg(trimmed.to_string()));
+        }
+
+        if looks_like_symbol_icon_hint(trimmed) {
+            return Some(Self::Emoji(trimmed.to_string()));
+        }
+
+        None
+    }
+}
+
+fn looks_like_symbol_icon_hint(icon_hint: &str) -> bool {
+    let has_ascii_alnum = icon_hint.chars().any(|ch| ch.is_ascii_alphanumeric());
+    let char_count = icon_hint.chars().count();
+
+    !has_ascii_alnum && char_count <= 4
+}
 /// Fixed height for list items used in uniform-height virtualized lists.
 ///
 /// IMPORTANT: When using GPUI `uniform_list`, the item closure must render
@@ -437,3 +468,29 @@
     /// Text color for content displayed on accent/warning backgrounds
     pub text_on_accent: u32,
 }
+
+#[cfg(test)]
+mod icon_kind_tests {
+    use super::IconKind;
+
+    #[test]
+    fn test_icon_kind_from_icon_hint_returns_svg_when_known_icon_name() {
+        match IconKind::from_icon_hint("terminal") {
+            Some(IconKind::Svg(name)) => assert_eq!(name, "terminal"),
+            _ => panic!("expected SVG icon from known icon hint"),
+        }
+    }
+
+    #[test]
+    fn test_icon_kind_from_icon_hint_returns_emoji_when_symbol_glyph() {
+        match IconKind::from_icon_hint("üìÑ") {
+            Some(IconKind::Emoji(emoji)) => assert_eq!(emoji, "üìÑ"),
+            _ => panic!("expected emoji icon for symbol glyph"),
+        }
+    }
+
+    #[test]
+    fn test_icon_kind_from_icon_hint_returns_none_for_unknown_ascii_word() {
+        assert!(IconKind::from_icon_hint("unknown-icon-name").is_none());
+    }
+}
diff --git a/src/prompts/select/mod.rs b/src/prompts/select/mod.rs
index b6366dabfb14f3fae09f854f9de824fa629e0a3b..32ec6dd9fa7ee4b5d29009f3cc5a665713f97a10
--- a/src/prompts/select/mod.rs
+++ b/src/prompts/select/mod.rs
@@ -19,7 +19,7 @@
     UnifiedListItemColors,
 };
 use crate::designs::{get_tokens, DesignColors, DesignVariant};
-use crate::list_item::LIST_ITEM_HEIGHT;
+use crate::list_item::{IconKind, LIST_ITEM_HEIGHT};
 use crate::logging;
 use crate::panel::PROMPT_INPUT_FIELD_HEIGHT;
 use crate::protocol::{generate_semantic_id, Choice};
@@ -37,5 +37,5 @@
 mod types;
 
 pub use prompt::SelectPrompt;
-use search::*;
-use types::*;
+pub(super) use search::*;
+pub(super) use types::*;
diff --git a/src/prompts/select/prompt.rs b/src/prompts/select/prompt.rs
index c5f98f5318f5b520e9223811f735e866ee06e7fb..5ba2de479b2f5680a73db72642377f68d26ee54e
--- a/src/prompts/select/prompt.rs
+++ b/src/prompts/select/prompt.rs
@@ -19,6 +19,8 @@
     pub filtered_choices: Vec<usize>,
     /// Currently focused index in filtered list
     pub focused_index: usize,
+    /// Currently hovered index in filtered list
+    pub hovered_index: Option<usize>,
     /// Filter text
     pub filter_text: String,
     /// Whether multiple selection is allowed
@@ -68,6 +70,7 @@
             selected: HashSet::new(),
             filtered_choices,
             focused_index: 0,
+            hovered_index: None,
             filter_text: String::new(),
             multiple,
             focus_handle,
@@ -84,6 +87,7 @@
         if trimmed_filter.is_empty() {
             self.filtered_choices = (0..self.choices.len()).collect();
             self.focused_index = 0;
+            self.hovered_index = None;
             return;
         }
 
@@ -109,6 +113,7 @@
 
         self.filtered_choices = scored_matches.into_iter().map(|(idx, _)| idx).collect();
         self.focused_index = 0;
+        self.hovered_index = None;
     }
 
     /// Set the filter text programmatically
@@ -168,6 +173,7 @@
     pub(super) fn move_up(&mut self, cx: &mut Context<Self>) {
         if self.focused_index > 0 {
             self.focused_index -= 1;
+            self.hovered_index = None;
             self.list_scroll_handle
                 .scroll_to_item(self.focused_index, ScrollStrategy::Nearest);
             cx.notify();
@@ -178,6 +184,7 @@
     pub(super) fn move_down(&mut self, cx: &mut Context<Self>) {
         if self.focused_index < self.filtered_choices.len().saturating_sub(1) {
             self.focused_index += 1;
+            self.hovered_index = None;
             self.list_scroll_handle
                 .scroll_to_item(self.focused_index, ScrollStrategy::Nearest);
             cx.notify();
diff --git a/src/prompts/select/render.rs b/src/prompts/select/render.rs
index 62109896c9c14b1b2fbf5b4d25d5d94e4388e4aa..e224ca641be966e7357474d1892f16fb9d59f392
--- a/src/prompts/select/render.rs
+++ b/src/prompts/select/render.rs
@@ -1,5 +1,78 @@
 use super::*;
 
+const ROW_FOCUSED_BG_ALPHA: u32 = 0x3A;
+const ROW_HOVER_BG_ALPHA: u32 = 0x26;
+
+#[derive(Clone, Copy, Debug, PartialEq, Eq)]
+pub(super) struct SelectRowState {
+    pub is_focused: bool,
+    pub is_selected: bool,
+    pub is_hovered: bool,
+}
+
+pub(super) fn compute_row_state(
+    display_idx: usize,
+    focused_index: usize,
+    choice_idx: usize,
+    selected: &HashSet<usize>,
+    hovered_index: Option<usize>,
+) -> SelectRowState {
+    SelectRowState {
+        is_focused: display_idx == focused_index,
+        is_selected: selected.contains(&choice_idx),
+        is_hovered: hovered_index == Some(display_idx),
+    }
+}
+
+pub(super) fn extract_choice_icon_hint(description: Option<&str>) -> Option<&str> {
+    description.and_then(|raw| {
+        raw.split(['‚Ä¢', '|', '\n'])
+            .map(str::trim)
+            .find_map(|token| {
+                let token_lower = token.to_ascii_lowercase();
+                if token_lower == "icon"
+                    || token_lower.starts_with("icon:")
+                    || token_lower.starts_with("icon=")
+                    || token_lower.starts_with("icon ")
+                {
+                    token
+                        .split_once(':')
+                        .or_else(|| token.split_once('='))
+                        .map(|(_, value)| value.trim())
+                        .or_else(|| token.split_whitespace().nth(1))
+                } else {
+                    None
+                }
+            })
+            .filter(|value| !value.is_empty())
+    })
+}
+
+pub(super) fn icon_kind_from_choice(choice: &Choice) -> IconKind {
+    let metadata_icon =
+        extract_choice_icon_hint(choice.description.as_deref()).and_then(IconKind::from_icon_hint);
+    let name_prefix_icon = choice
+        .name
+        .split_whitespace()
+        .next()
+        .and_then(IconKind::from_icon_hint);
+
+    metadata_icon
+        .or(name_prefix_icon)
+        .unwrap_or_else(|| IconKind::Svg("Code".to_string()))
+}
+
+fn leading_content_from_icon_kind(icon_kind: IconKind) -> LeadingContent {
+    match icon_kind {
+        IconKind::Emoji(emoji) => LeadingContent::Emoji(emoji.into()),
+        IconKind::Image(render_image) => LeadingContent::AppIcon(render_image),
+        IconKind::Svg(name) => LeadingContent::Icon {
+            name: SharedString::from(name),
+            color: None,
+        },
+    }
+}
+
 impl Focusable for SelectPrompt {
     fn focus_handle(&self, _cx: &gpui::App) -> FocusHandle {
         self.focus_handle.clone()
@@ -76,6 +149,13 @@
             self.design_variant,
             &colors,
         ));
+        let row_accent_color = if self.design_variant == DesignVariant::Default {
+            self.theme.colors.accent.selected
+        } else {
+            colors.accent
+        };
+        let focused_row_bg = rgba((row_accent_color << 8) | ROW_FOCUSED_BG_ALPHA);
+        let hovered_row_bg = rgba((row_accent_color << 8) | ROW_HOVER_BG_ALPHA);
 
         let placeholder = self
             .placeholder
@@ -145,8 +225,12 @@
                     move |this: &mut SelectPrompt,
                           visible_range: std::ops::Range<usize>,
                           _window,
-                          _cx| {
-                        let row_colors = UnifiedListItemColors::from_theme(&this.theme);
+                          cx| {
+                        let item_colors = UnifiedListItemColors {
+                            selected_opacity: 0.0,
+                            hover_opacity: 0.0,
+                            ..UnifiedListItemColors::from_theme(&this.theme)
+                        };
                         let mut rows = Vec::with_capacity(visible_range.len());
 
                         for display_idx in visible_range {
@@ -154,21 +238,30 @@
                                 if let Some(choice) = this.choices.get(choice_idx) {
                                     if let Some(indexed_choice) = this.choice_index.get(choice_idx)
                                     {
-                                        let is_focused = display_idx == this.focused_index;
-                                        let is_selected = this.selected.contains(&choice_idx);
-                                        let is_selected_for_ui = if this.multiple {
-                                            is_selected
-                                        } else {
-                                            is_focused
-                                        };
+                                        let row_state = compute_row_state(
+                                            display_idx,
+                                            this.focused_index,
+                                            choice_idx,
+                                            &this.selected,
+                                            this.hovered_index,
+                                        );
+                                        let is_focused = row_state.is_focused;
+                                        let is_selected = row_state.is_selected;
+                                        let is_hovered = row_state.is_hovered;
                                         let semantic_id =
                                             choice.semantic_id.clone().unwrap_or_else(|| {
                                                 indexed_choice.stable_semantic_id.clone()
                                             });
-                                        let indicator = choice_selection_indicator(
-                                            this.multiple,
-                                            is_selected_for_ui,
-                                        );
+                                        let leading = if this.multiple {
+                                            Some(LeadingContent::Emoji(
+                                                choice_selection_indicator(true, is_selected)
+                                                    .into(),
+                                            ))
+                                        } else {
+                                            Some(leading_content_from_icon_kind(
+                                                icon_kind_from_choice(choice),
+                                            ))
+                                        };
                                         let subtitle = indexed_choice
                                             .metadata
                                             .subtitle_text()
@@ -185,34 +278,60 @@
                                                     ))
                                                 },
                                             );
+                                        let row_bg = if is_focused {
+                                            focused_row_bg
+                                        } else if is_hovered {
+                                            hovered_row_bg
+                                        } else {
+                                            rgba(0x00000000)
+                                        };
+                                        let hover_handler = cx.listener(
+                                            move |this: &mut SelectPrompt,
+                                                  hovered: &bool,
+                                                  _window,
+                                                  cx| {
+                                                if *hovered {
+                                                    if this.hovered_index != Some(display_idx) {
+                                                        this.hovered_index = Some(display_idx);
+                                                        cx.notify();
+                                                    }
+                                                } else if this.hovered_index == Some(display_idx) {
+                                                    this.hovered_index = None;
+                                                    cx.notify();
+                                                }
+                                            },
+                                        );
+
+                                        let mut row = div()
+                                            .id(display_idx)
+                                            .w_full()
+                                            .h(px(LIST_ITEM_HEIGHT))
+                                            .rounded(px(8.0))
+                                            .bg(row_bg)
+                                            .cursor_pointer()
+                                            .on_hover(hover_handler)
+                                            .child(
+                                                UnifiedListItem::new(
+                                                    gpui::ElementId::Name(semantic_id.into()),
+                                                    title,
+                                                )
+                                                .subtitle_opt(subtitle)
+                                                .leading_opt(leading)
+                                                .trailing_opt(trailing)
+                                                .state(ItemState {
+                                                    is_selected,
+                                                    is_hovered,
+                                                    is_disabled: false,
+                                                })
+                                                .density(Density::Comfortable)
+                                                .colors(item_colors),
+                                            );
+
+                                        if !is_focused {
+                                            row = row.hover(move |s| s.bg(hovered_row_bg));
+                                        }
 
-                                        rows.push(
-                                            div()
-                                                .id(display_idx)
-                                                .w_full()
-                                                .h(px(LIST_ITEM_HEIGHT))
-                                                .border_b_1()
-                                                .border_color(border_color)
-                                                .child(
-                                                    UnifiedListItem::new(
-                                                        gpui::ElementId::Name(semantic_id.into()),
-                                                        title,
-                                                    )
-                                                    .subtitle_opt(subtitle)
-                                                    .leading(LeadingContent::Emoji(
-                                                        indicator.into(),
-                                                    ))
-                                                    .trailing_opt(trailing)
-                                                    .state(ItemState {
-                                                        is_selected: is_focused,
-                                                        is_hovered: false,
-                                                        is_disabled: false,
-                                                    })
-                                                    .density(Density::Comfortable)
-                                                    .colors(row_colors)
-                                                    .with_accent_bar(is_selected_for_ui),
-                                                ),
-                                        );
+                                        rows.push(row);
                                     }
                                 }
                             }
@@ -234,6 +353,7 @@
             .flex_col()
             .flex_1()
             .w_full()
+            .px(px(8.0))
             .child(choices_content);
 
         div()
diff --git a/src/prompts/select/tests.rs b/src/prompts/select/tests.rs
index 250ec9d63282ad81dd952efa12855f784330232c..2b048753d5f168dcbc59ccb0e399e4604bc39167
--- a/src/prompts/select/tests.rs
+++ b/src/prompts/select/tests.rs
@@ -184,3 +184,36 @@
         0x445566
     );
 }
+
+#[test]
+fn test_select_prompt_extracts_icon_hint_from_choice_metadata() {
+    let description = Some("Shortcut: cmd+k ‚Ä¢ icon: terminal ‚Ä¢ script");
+    assert_eq!(
+        render::extract_choice_icon_hint(description),
+        Some("terminal")
+    );
+}
+
+#[test]
+fn test_select_prompt_icon_kind_falls_back_to_code_icon_without_hint() {
+    let choice = choice("Deploy API", "/Users/me/.scriptkit/scripts/deploy.ts", None);
+
+    match render::icon_kind_from_choice(&choice) {
+        IconKind::Svg(name) => assert_eq!(name, "Code"),
+        _ => panic!("expected fallback Code SVG icon"),
+    }
+}
+
+#[test]
+fn test_select_prompt_compute_row_state_keeps_focus_and_selection_independent() {
+    let selected = std::collections::HashSet::from([5]);
+    let focused_but_unselected = render::compute_row_state(2, 2, 1, &selected, Some(1));
+    assert!(focused_but_unselected.is_focused);
+    assert!(!focused_but_unselected.is_selected);
+    assert!(!focused_but_unselected.is_hovered);
+
+    let selected_but_unfocused = render::compute_row_state(1, 2, 5, &selected, Some(1));
+    assert!(!selected_but_unfocused.is_focused);
+    assert!(selected_but_unfocused.is_selected);
+    assert!(selected_but_unfocused.is_hovered);
+}

 exited 101 in 8.51s:
    Checking script-kit-gpui v0.1.0 (/Users/johnlindquist/dev/script-kit-gpui)
error[E0425]: cannot find function `rgba` in this scope
   --> src/prompts/select/render.rs:157:30
    |
157 |         let focused_row_bg = rgba((row_accent_color << 8) | ROW_FOCUSED_BG_ALPHA);
    |                              ^^^^
    |
   ::: /Users/johnlindquist/.cargo/git/checkouts/zed-a70e2ad075855582/94faaeb/crates/gpui/src/color.rs:14:1
    |
 14 | pub fn rgb(hex: u32) -> Rgba {
    | ---------------------------- similarly named function `rgb` defined here
    |
    = note: function `crate::ai::window::window_api::rgba` exists but is inaccessible
help: a function with a similar name exists
    |
157 -         let focused_row_bg = rgba((row_accent_color << 8) | ROW_FOCUSED_BG_ALPHA);
157 +         let focused_row_bg = rgb((row_accent_color << 8) | ROW_FOCUSED_BG_ALPHA);
    |
help: consider importing this function
    |

thinking
**Adding process completion polling**
file update:
diff --git a/src/list_item/part_000.rs b/src/list_item/part_000.rs
index 733d4ac2aa5b1b27b29a5999310e6f3f45cc54c3..283b2263d56a92c73c22d44443db7b40971d26ce
--- a/src/list_item/part_000.rs
+++ b/src/list_item/part_000.rs
@@ -15,6 +15,37 @@
     /// Maps to IconName from designs::icon_variations
     Svg(String),
 }
+
+impl IconKind {
+    /// Resolve icon metadata into an IconKind for list rendering.
+    ///
+    /// Supports:
+    /// - Known SVG names/aliases via `icon_name_from_str` (e.g., "Terminal", "file-code")
+    /// - Emoji/symbol glyphs (e.g., "üìÑ", "‚ö°")
+    pub fn from_icon_hint(icon_hint: &str) -> Option<Self> {
+        let trimmed = icon_hint.trim();
+        if trimmed.is_empty() {
+            return None;
+        }
+
+        if icon_name_from_str(trimmed).is_some() {
+            return Some(Self::Svg(trimmed.to_string()));
+        }
+
+        if looks_like_symbol_icon_hint(trimmed) {
+            return Some(Self::Emoji(trimmed.to_string()));
+        }
+
+        None
+    }
+}
+
+fn looks_like_symbol_icon_hint(icon_hint: &str) -> bool {
+    let has_ascii_alnum = icon_hint.chars().any(|ch| ch.is_ascii_alphanumeric());
+    let char_count = icon_hint.chars().count();
+
+    !has_ascii_alnum && char_count <= 4
+}
 /// Fixed height for list items used in uniform-height virtualized lists.
 ///
 /// IMPORTANT: When using GPUI `uniform_list`, the item closure must render
@@ -437,3 +468,29 @@
     /// Text color for content displayed on accent/warning backgrounds
     pub text_on_accent: u32,
 }
+
+#[cfg(test)]
+mod icon_kind_tests {
+    use super::IconKind;
+
+    #[test]
+    fn test_icon_kind_from_icon_hint_returns_svg_when_known_icon_name() {
+        match IconKind::from_icon_hint("terminal") {
+            Some(IconKind::Svg(name)) => assert_eq!(name, "terminal"),
+            _ => panic!("expected SVG icon from known icon hint"),
+        }
+    }
+
+    #[test]
+    fn test_icon_kind_from_icon_hint_returns_emoji_when_symbol_glyph() {
+        match IconKind::from_icon_hint("üìÑ") {
+            Some(IconKind::Emoji(emoji)) => assert_eq!(emoji, "üìÑ"),
+            _ => panic!("expected emoji icon for symbol glyph"),
+        }
+    }
+
+    #[test]
+    fn test_icon_kind_from_icon_hint_returns_none_for_unknown_ascii_word() {
+        assert!(IconKind::from_icon_hint("unknown-icon-name").is_none());
+    }
+}
diff --git a/src/prompts/select/mod.rs b/src/prompts/select/mod.rs
index b6366dabfb14f3fae09f854f9de824fa629e0a3b..32ec6dd9fa7ee4b5d29009f3cc5a665713f97a10
--- a/src/prompts/select/mod.rs
+++ b/src/prompts/select/mod.rs
@@ -19,7 +19,7 @@
     UnifiedListItemColors,
 };
 use crate::designs::{get_tokens, DesignColors, DesignVariant};
-use crate::list_item::LIST_ITEM_HEIGHT;
+use crate::list_item::{IconKind, LIST_ITEM_HEIGHT};
 use crate::logging;
 use crate::panel::PROMPT_INPUT_FIELD_HEIGHT;
 use crate::protocol::{generate_semantic_id, Choice};
@@ -37,5 +37,5 @@
 mod types;
 
 pub use prompt::SelectPrompt;
-use search::*;
-use types::*;
+pub(super) use search::*;
+pub(super) use types::*;
diff --git a/src/prompts/select/prompt.rs b/src/prompts/select/prompt.rs
index c5f98f5318f5b520e9223811f735e866ee06e7fb..5ba2de479b2f5680a73db72642377f68d26ee54e
--- a/src/prompts/select/prompt.rs
+++ b/src/prompts/select/prompt.rs
@@ -19,6 +19,8 @@
     pub filtered_choices: Vec<usize>,
     /// Currently focused index in filtered list
     pub focused_index: usize,
+    /// Currently hovered index in filtered list
+    pub hovered_index: Option<usize>,
     /// Filter text
     pub filter_text: String,
     /// Whether multiple selection is allowed
@@ -68,6 +70,7 @@
             selected: HashSet::new(),
             filtered_choices,
             focused_index: 0,
+            hovered_index: None,
             filter_text: String::new(),
             multiple,
             focus_handle,
@@ -84,6 +87,7 @@
         if trimmed_filter.is_empty() {
             self.filtered_choices = (0..self.choices.len()).collect();
             self.focused_index = 0;
+            self.hovered_index = None;
             return;
         }
 
@@ -109,6 +113,7 @@
 
         self.filtered_choices = scored_matches.into_iter().map(|(idx, _)| idx).collect();
         self.focused_index = 0;
+        self.hovered_index = None;
     }
 
     /// Set the filter text programmatically
@@ -168,6 +173,7 @@
     pub(super) fn move_up(&mut self, cx: &mut Context<Self>) {
         if self.focused_index > 0 {
             self.focused_index -= 1;
+            self.hovered_index = None;
             self.list_scroll_handle
                 .scroll_to_item(self.focused_index, ScrollStrategy::Nearest);
             cx.notify();
@@ -178,6 +184,7 @@
     pub(super) fn move_down(&mut self, cx: &mut Context<Self>) {
         if self.focused_index < self.filtered_choices.len().saturating_sub(1) {
             self.focused_index += 1;
+            self.hovered_index = None;
             self.list_scroll_handle
                 .scroll_to_item(self.focused_index, ScrollStrategy::Nearest);
             cx.notify();
diff --git a/src/prompts/select/render.rs b/src/prompts/select/render.rs
index 62109896c9c14b1b2fbf5b4d25d5d94e4388e4aa..e224ca641be966e7357474d1892f16fb9d59f392
--- a/src/prompts/select/render.rs
+++ b/src/prompts/select/render.rs
@@ -1,5 +1,78 @@
 use super::*;
 
+const ROW_FOCUSED_BG_ALPHA: u32 = 0x3A;
+const ROW_HOVER_BG_ALPHA: u32 = 0x26;
+
+#[derive(Clone, Copy, Debug, PartialEq, Eq)]
+pub(super) struct SelectRowState {
+    pub is_focused: bool,
+    pub is_selected: bool,
+    pub is_hovered: bool,
+}
+
+pub(super) fn compute_row_state(
+    display_idx: usize,
+    focused_index: usize,
+    choice_idx: usize,
+    selected: &HashSet<usize>,
+    hovered_index: Option<usize>,
+) -> SelectRowState {
+    SelectRowState {
+        is_focused: display_idx == focused_index,
+        is_selected: selected.contains(&choice_idx),
+        is_hovered: hovered_index == Some(display_idx),
+    }
+}
+
+pub(super) fn extract_choice_icon_hint(description: Option<&str>) -> Option<&str> {
+    description.and_then(|raw| {
+        raw.split(['‚Ä¢', '|', '\n'])
+            .map(str::trim)
+            .find_map(|token| {
+                let token_lower = token.to_ascii_lowercase();
+                if token_lower == "icon"
+                    || token_lower.starts_with("icon:")
+                    || token_lower.starts_with("icon=")
+                    || token_lower.starts_with("icon ")
+                {
+                    token
+                        .split_once(':')
+                        .or_else(|| token.split_once('='))
+                        .map(|(_, value)| value.trim())
+                        .or_else(|| token.split_whitespace().nth(1))
+                } else {
+                    None
+                }
+            })
+            .filter(|value| !value.is_empty())
+    })
+}
+
+pub(super) fn icon_kind_from_choice(choice: &Choice) -> IconKind {
+    let metadata_icon =
+        extract_choice_icon_hint(choice.description.as_deref()).and_then(IconKind::from_icon_hint);
+    let name_prefix_icon = choice
+        .name
+        .split_whitespace()
+        .next()
+        .and_then(IconKind::from_icon_hint);
+
+    metadata_icon
+        .or(name_prefix_icon)
+        .unwrap_or_else(|| IconKind::Svg("Code".to_string()))
+}
+
+fn leading_content_from_icon_kind(icon_kind: IconKind) -> LeadingContent {
+    match icon_kind {
+        IconKind::Emoji(emoji) => LeadingContent::Emoji(emoji.into()),
+        IconKind::Image(render_image) => LeadingContent::AppIcon(render_image),
+        IconKind::Svg(name) => LeadingContent::Icon {
+            name: SharedString::from(name),
+            color: None,
+        },
+    }
+}
+
 impl Focusable for SelectPrompt {
     fn focus_handle(&self, _cx: &gpui::App) -> FocusHandle {
         self.focus_handle.clone()
@@ -76,6 +149,13 @@
             self.design_variant,
             &colors,
         ));
+        let row_accent_color = if self.design_variant == DesignVariant::Default {
+            self.theme.colors.accent.selected
+        } else {
+            colors.accent
+        };
+        let focused_row_bg = rgba((row_accent_color << 8) | ROW_FOCUSED_BG_ALPHA);
+        let hovered_row_bg = rgba((row_accent_color << 8) | ROW_HOVER_BG_ALPHA);
 
         let placeholder = self
             .placeholder
@@ -145,8 +225,12 @@
                     move |this: &mut SelectPrompt,
                           visible_range: std::ops::Range<usize>,
                           _window,
-                          _cx| {
-                        let row_colors = UnifiedListItemColors::from_theme(&this.theme);
+                          cx| {
+                        let item_colors = UnifiedListItemColors {
+                            selected_opacity: 0.0,
+                            hover_opacity: 0.0,
+                            ..UnifiedListItemColors::from_theme(&this.theme)
+                        };
                         let mut rows = Vec::with_capacity(visible_range.len());
 
                         for display_idx in visible_range {
@@ -154,21 +238,30 @@
                                 if let Some(choice) = this.choices.get(choice_idx) {
                                     if let Some(indexed_choice) = this.choice_index.get(choice_idx)
                                     {
-                                        let is_focused = display_idx == this.focused_index;
-                                        let is_selected = this.selected.contains(&choice_idx);
-                                        let is_selected_for_ui = if this.multiple {
-                                            is_selected
-                                        } else {
-                                            is_focused
-                                        };
+                                        let row_state = compute_row_state(
+                                            display_idx,
+                                            this.focused_index,
+                                            choice_idx,
+                                            &this.selected,
+                                            this.hovered_index,
+                                        );
+                                        let is_focused = row_state.is_focused;
+                                        let is_selected = row_state.is_selected;
+                                        let is_hovered = row_state.is_hovered;
                                         let semantic_id =
                                             choice.semantic_id.clone().unwrap_or_else(|| {
                                                 indexed_choice.stable_semantic_id.clone()
                                             });
-                                        let indicator = choice_selection_indicator(
-                                            this.multiple,
-                                            is_selected_for_ui,
-                                        );
+                                        let leading = if this.multiple {
+                                            Some(LeadingContent::Emoji(
+                                                choice_selection_indicator(true, is_selected)
+                                                    .into(),
+                                            ))
+                                        } else {
+                                            Some(leading_content_from_icon_kind(
+                                                icon_kind_from_choice(choice),
+                                            ))
+                                        };
                                         let subtitle = indexed_choice
                                             .metadata
                                             .subtitle_text()
@@ -185,34 +278,60 @@
                                                     ))
                                                 },
                                             );
+                                        let row_bg = if is_focused {
+                                            focused_row_bg
+                                        } else if is_hovered {
+                                            hovered_row_bg
+                                        } else {
+                                            rgba(0x00000000)
+                                        };
+                                        let hover_handler = cx.listener(
+                                            move |this: &mut SelectPrompt,
+                                                  hovered: &bool,
+                                                  _window,
+                                                  cx| {
+                                                if *hovered {
+                                                    if this.hovered_index != Some(display_idx) {
+                                                        this.hovered_index = Some(display_idx);
+                                                        cx.notify();
+                                                    }
+                                                } else if this.hovered_index == Some(display_idx) {
+                                                    this.hovered_index = None;
+                                                    cx.notify();
+                                                }
+                                            },
+                                        );
+
+                                        let mut row = div()
+                                            .id(display_idx)
+                                            .w_full()
+                                            .h(px(LIST_ITEM_HEIGHT))
+                                            .rounded(px(8.0))
+                                            .bg(row_bg)
+                                            .cursor_pointer()
+                                            .on_hover(hover_handler)
+                                            .child(
+                                                UnifiedListItem::new(
+                                                    gpui::ElementId::Name(semantic_id.into()),
+                                                    title,
+                                                )
+                                                .subtitle_opt(subtitle)
+                                                .leading_opt(leading)
+                                                .trailing_opt(trailing)
+                                                .state(ItemState {
+                                                    is_selected,
+                                                    is_hovered,
+                                                    is_disabled: false,
+                                                })
+                                                .density(Density::Comfortable)
+                                                .colors(item_colors),
+                                            );
+
+                                        if !is_focused {
+                                            row = row.hover(move |s| s.bg(hovered_row_bg));
+                                        }
 
-                                        rows.push(
-                                            div()
-                                                .id(display_idx)
-                                                .w_full()
-                                                .h(px(LIST_ITEM_HEIGHT))
-                                                .border_b_1()
-                                                .border_color(border_color)
-                                                .child(
-                                                    UnifiedListItem::new(
-                                                        gpui::ElementId::Name(semantic_id.into()),
-                                                        title,
-                                                    )
-                                                    .subtitle_opt(subtitle)
-                                                    .leading(LeadingContent::Emoji(
-                                                        indicator.into(),
-                                                    ))
-                                                    .trailing_opt(trailing)
-                                                    .state(ItemState {
-                                                        is_selected: is_focused,
-                                                        is_hovered: false,
-                                                        is_disabled: false,
-                                                    })
-                                                    .density(Density::Comfortable)
-                                                    .colors(row_colors)
-                                                    .with_accent_bar(is_selected_for_ui),
-                                                ),
-                                        );
+                                        rows.push(row);
                                     }
                                 }
                             }
@@ -234,6 +353,7 @@
             .flex_col()
             .flex_1()
             .w_full()
+            .px(px(8.0))
             .child(choices_content);
 
         div()
diff --git a/src/prompts/select/tests.rs b/src/prompts/select/tests.rs
index 250ec9d63282ad81dd952efa12855f784330232c..2b048753d5f168dcbc59ccb0e399e4604bc39167
--- a/src/prompts/select/tests.rs
+++ b/src/prompts/select/tests.rs
@@ -184,3 +184,36 @@
         0x445566
     );
 }
+
+#[test]
+fn test_select_prompt_extracts_icon_hint_from_choice_metadata() {
+    let description = Some("Shortcut: cmd+k ‚Ä¢ icon: terminal ‚Ä¢ script");
+    assert_eq!(
+        render::extract_choice_icon_hint(description),
+        Some("terminal")
+    );
+}
+
+#[test]
+fn test_select_prompt_icon_kind_falls_back_to_code_icon_without_hint() {
+    let choice = choice("Deploy API", "/Users/me/.scriptkit/scripts/deploy.ts", None);
+
+    match render::icon_kind_from_choice(&choice) {
+        IconKind::Svg(name) => assert_eq!(name, "Code"),
+        _ => panic!("expected fallback Code SVG icon"),
+    }
+}
+
+#[test]
+fn test_select_prompt_compute_row_state_keeps_focus_and_selection_independent() {
+    let selected = std::collections::HashSet::from([5]);
+    let focused_but_unselected = render::compute_row_state(2, 2, 1, &selected, Some(1));
+    assert!(focused_but_unselected.is_focused);
+    assert!(!focused_but_unselected.is_selected);
+    assert!(!focused_but_unselected.is_hovered);
+
+    let selected_but_unfocused = render::compute_row_state(1, 2, 5, &selected, Some(1));
+    assert!(!selected_but_unfocused.is_focused);
+    assert!(selected_but_unfocused.is_selected);
+    assert!(selected_but_unfocused.is_hovered);
+}


thinking
**Reverting imports to avoid warnings**
codex
`cargo check -p` surfaced compile issues: missing `rgba` import and warning-producing `pub(super) use search/types` lines. I‚Äôm patching those now, then re-running the scoped gate.
file update
M /Users/johnlindquist/dev/script-kit-gpui/src/prompts/select/mod.rs
@@ -9,4 +9,4 @@
 use gpui::{
-    div, prelude::*, px, rgb, uniform_list, AnyElement, Context, FocusHandle, Focusable, Render,
-    ScrollStrategy, SharedString, UniformListScrollHandle, Window,
+    div, prelude::*, px, rgb, rgba, uniform_list, AnyElement, Context, FocusHandle, Focusable,
+    Render, ScrollStrategy, SharedString, UniformListScrollHandle, Window,
 };
@@ -39,3 +39,3 @@
 pub use prompt::SelectPrompt;
-pub(super) use search::*;
-pub(super) use types::*;
+use search::*;
+use types::*;
apply_patch(auto_approved=true) exited 0 in 31ms:
Success. Updated the following files:
M /Users/johnlindquist/dev/script-kit-gpui/src/prompts/select/mod.rs
file update:
diff --git a/src/list_item/part_000.rs b/src/list_item/part_000.rs
index 733d4ac2aa5b1b27b29a5999310e6f3f45cc54c3..283b2263d56a92c73c22d44443db7b40971d26ce
--- a/src/list_item/part_000.rs
+++ b/src/list_item/part_000.rs
@@ -15,6 +15,37 @@
     /// Maps to IconName from designs::icon_variations
     Svg(String),
 }
+
+impl IconKind {
+    /// Resolve icon metadata into an IconKind for list rendering.
+    ///
+    /// Supports:
+    /// - Known SVG names/aliases via `icon_name_from_str` (e.g., "Terminal", "file-code")
+    /// - Emoji/symbol glyphs (e.g., "üìÑ", "‚ö°")
+    pub fn from_icon_hint(icon_hint: &str) -> Option<Self> {
+        let trimmed = icon_hint.trim();
+        if trimmed.is_empty() {
+            return None;
+        }
+
+        if icon_name_from_str(trimmed).is_some() {
+            return Some(Self::Svg(trimmed.to_string()));
+        }
+
+        if looks_like_symbol_icon_hint(trimmed) {
+            return Some(Self::Emoji(trimmed.to_string()));
+        }
+
+        None
+    }
+}
+
+fn looks_like_symbol_icon_hint(icon_hint: &str) -> bool {
+    let has_ascii_alnum = icon_hint.chars().any(|ch| ch.is_ascii_alphanumeric());
+    let char_count = icon_hint.chars().count();
+
+    !has_ascii_alnum && char_count <= 4
+}
 /// Fixed height for list items used in uniform-height virtualized lists.
 ///
 /// IMPORTANT: When using GPUI `uniform_list`, the item closure must render
@@ -437,3 +468,29 @@
     /// Text color for content displayed on accent/warning backgrounds
     pub text_on_accent: u32,
 }
+
+#[cfg(test)]
+mod icon_kind_tests {
+    use super::IconKind;
+
+    #[test]
+    fn test_icon_kind_from_icon_hint_returns_svg_when_known_icon_name() {
+        match IconKind::from_icon_hint("terminal") {
+            Some(IconKind::Svg(name)) => assert_eq!(name, "terminal"),
+            _ => panic!("expected SVG icon from known icon hint"),
+        }
+    }
+
+    #[test]
+    fn test_icon_kind_from_icon_hint_returns_emoji_when_symbol_glyph() {
+        match IconKind::from_icon_hint("üìÑ") {
+            Some(IconKind::Emoji(emoji)) => assert_eq!(emoji, "üìÑ"),
+            _ => panic!("expected emoji icon for symbol glyph"),
+        }
+    }
+
+    #[test]
+    fn test_icon_kind_from_icon_hint_returns_none_for_unknown_ascii_word() {
+        assert!(IconKind::from_icon_hint("unknown-icon-name").is_none());
+    }
+}
diff --git a/src/prompts/select/mod.rs b/src/prompts/select/mod.rs
index b6366dabfb14f3fae09f854f9de824fa629e0a3b..80287d57d8b538dba0d85476dc6de3aa3409a2fd
--- a/src/prompts/select/mod.rs
+++ b/src/prompts/select/mod.rs
@@ -7,8 +7,8 @@
 //! - Submit selected items
 
 use gpui::{
-    div, prelude::*, px, rgb, uniform_list, AnyElement, Context, FocusHandle, Focusable, Render,
-    ScrollStrategy, SharedString, UniformListScrollHandle, Window,
+    div, prelude::*, px, rgb, rgba, uniform_list, AnyElement, Context, FocusHandle, Focusable,
+    Render, ScrollStrategy, SharedString, UniformListScrollHandle, Window,
 };
 use std::collections::HashSet;
 use std::ops::Range;
@@ -19,7 +19,7 @@
     UnifiedListItemColors,
 };
 use crate::designs::{get_tokens, DesignColors, DesignVariant};
-use crate::list_item::LIST_ITEM_HEIGHT;
+use crate::list_item::{IconKind, LIST_ITEM_HEIGHT};
 use crate::logging;
 use crate::panel::PROMPT_INPUT_FIELD_HEIGHT;
 use crate::protocol::{generate_semantic_id, Choice};
diff --git a/src/prompts/select/prompt.rs b/src/prompts/select/prompt.rs
index c5f98f5318f5b520e9223811f735e866ee06e7fb..5ba2de479b2f5680a73db72642377f68d26ee54e
--- a/src/prompts/select/prompt.rs
+++ b/src/prompts/select/prompt.rs
@@ -19,6 +19,8 @@
     pub filtered_choices: Vec<usize>,
     /// Currently focused index in filtered list
     pub focused_index: usize,
+    /// Currently hovered index in filtered list
+    pub hovered_index: Option<usize>,
     /// Filter text
     pub filter_text: String,
     /// Whether multiple selection is allowed
@@ -68,6 +70,7 @@
             selected: HashSet::new(),
             filtered_choices,
             focused_index: 0,
+            hovered_index: None,
             filter_text: String::new(),
             multiple,
             focus_handle,
@@ -84,6 +87,7 @@
         if trimmed_filter.is_empty() {
             self.filtered_choices = (0..self.choices.len()).collect();
             self.focused_index = 0;
+            self.hovered_index = None;
             return;
         }
 
@@ -109,6 +113,7 @@
 
         self.filtered_choices = scored_matches.into_iter().map(|(idx, _)| idx).collect();
         self.focused_index = 0;
+        self.hovered_index = None;
     }
 
     /// Set the filter text programmatically
@@ -168,6 +173,7 @@
     pub(super) fn move_up(&mut self, cx: &mut Context<Self>) {
         if self.focused_index > 0 {
             self.focused_index -= 1;
+            self.hovered_index = None;
             self.list_scroll_handle
                 .scroll_to_item(self.focused_index, ScrollStrategy::Nearest);
             cx.notify();
@@ -178,6 +184,7 @@
     pub(super) fn move_down(&mut self, cx: &mut Context<Self>) {
         if self.focused_index < self.filtered_choices.len().saturating_sub(1) {
             self.focused_index += 1;
+            self.hovered_index = None;
             self.list_scroll_handle
                 .scroll_to_item(self.focused_index, ScrollStrategy::Nearest);
             cx.notify();
diff --git a/src/prompts/select/render.rs b/src/prompts/select/render.rs
index 62109896c9c14b1b2fbf5b4d25d5d94e4388e4aa..e224ca641be966e7357474d1892f16fb9d59f392
--- a/src/prompts/select/render.rs
+++ b/src/prompts/select/render.rs
@@ -1,5 +1,78 @@
 use super::*;
 
+const ROW_FOCUSED_BG_ALPHA: u32 = 0x3A;
+const ROW_HOVER_BG_ALPHA: u32 = 0x26;
+
+#[derive(Clone, Copy, Debug, PartialEq, Eq)]
+pub(super) struct SelectRowState {
+    pub is_focused: bool,
+    pub is_selected: bool,
+    pub is_hovered: bool,
+}
+
+pub(super) fn compute_row_state(
+    display_idx: usize,
+    focused_index: usize,
+    choice_idx: usize,
+    selected: &HashSet<usize>,
+    hovered_index: Option<usize>,
+) -> SelectRowState {
+    SelectRowState {
+        is_focused: display_idx == focused_index,
+        is_selected: selected.contains(&choice_idx),
+        is_hovered: hovered_index == Some(display_idx),
+    }
+}
+
+pub(super) fn extract_choice_icon_hint(description: Option<&str>) -> Option<&str> {
+    description.and_then(|raw| {
+        raw.split(['‚Ä¢', '|', '\n'])
+            .map(str::trim)
+            .find_map(|token| {
+                let token_lower = token.to_ascii_lowercase();
+                if token_lower == "icon"
+                    || token_lower.starts_with("icon:")
+                    || token_lower.starts_with("icon=")
+                    || token_lower.starts_with("icon ")
+                {
+                    token
+                        .split_once(':')
+                        .or_else(|| token.split_once('='))
+                        .map(|(_, value)| value.trim())
+                        .or_else(|| token.split_whitespace().nth(1))
+                } else {
+                    None
+                }
+            })
+            .filter(|value| !value.is_empty())
+    })
+}
+
+pub(super) fn icon_kind_from_choice(choice: &Choice) -> IconKind {
+    let metadata_icon =
+        extract_choice_icon_hint(choice.description.as_deref()).and_then(IconKind::from_icon_hint);
+    let name_prefix_icon = choice
+        .name
+        .split_whitespace()
+        .next()
+        .and_then(IconKind::from_icon_hint);
+
+    metadata_icon
+        .or(name_prefix_icon)
+        .unwrap_or_else(|| IconKind::Svg("Code".to_string()))
+}
+
+fn leading_content_from_icon_kind(icon_kind: IconKind) -> LeadingContent {
+    match icon_kind {
+        IconKind::Emoji(emoji) => LeadingContent::Emoji(emoji.into()),
+        IconKind::Image(render_image) => LeadingContent::AppIcon(render_image),
+        IconKind::Svg(name) => LeadingContent::Icon {
+            name: SharedString::from(name),
+            color: None,
+        },
+    }
+}
+
 impl Focusable for SelectPrompt {
     fn focus_handle(&self, _cx: &gpui::App) -> FocusHandle {
         self.focus_handle.clone()
@@ -76,6 +149,13 @@
             self.design_variant,
             &colors,
         ));
+        let row_accent_color = if self.design_variant == DesignVariant::Default {
+            self.theme.colors.accent.selected
+        } else {
+            colors.accent
+        };
+        let focused_row_bg = rgba((row_accent_color << 8) | ROW_FOCUSED_BG_ALPHA);
+        let hovered_row_bg = rgba((row_accent_color << 8) | ROW_HOVER_BG_ALPHA);
 
         let placeholder = self
             .placeholder
@@ -145,8 +225,12 @@
                     move |this: &mut SelectPrompt,
                           visible_range: std::ops::Range<usize>,
                           _window,
-                          _cx| {
-                        let row_colors = UnifiedListItemColors::from_theme(&this.theme);
+                          cx| {
+                        let item_colors = UnifiedListItemColors {
+                            selected_opacity: 0.0,
+                            hover_opacity: 0.0,
+                            ..UnifiedListItemColors::from_theme(&this.theme)
+                        };
                         let mut rows = Vec::with_capacity(visible_range.len());
 
                         for display_idx in visible_range {
@@ -154,21 +238,30 @@
                                 if let Some(choice) = this.choices.get(choice_idx) {
                                     if let Some(indexed_choice) = this.choice_index.get(choice_idx)
                                     {
-                                        let is_focused = display_idx == this.focused_index;
-                                        let is_selected = this.selected.contains(&choice_idx);
-                                        let is_selected_for_ui = if this.multiple {
-                                            is_selected
-                                        } else {
-                                            is_focused
-                                        };
+                                        let row_state = compute_row_state(
+                                            display_idx,
+                                            this.focused_index,
+                                            choice_idx,
+                                            &this.selected,
+                                            this.hovered_index,
+                                        );
+                                        let is_focused = row_state.is_focused;
+                                        let is_selected = row_state.is_selected;
+                                        let is_hovered = row_state.is_hovered;
                                         let semantic_id =
                                             choice.semantic_id.clone().unwrap_or_else(|| {
                                                 indexed_choice.stable_semantic_id.clone()
                                             });
-                                        let indicator = choice_selection_indicator(
-                                            this.multiple,
-                                            is_selected_for_ui,
-                                        );
+                                        let leading = if this.multiple {
+                                            Some(LeadingContent::Emoji(
+                                                choice_selection_indicator(true, is_selected)
+                                                    .into(),
+                                            ))
+                                        } else {
+                                            Some(leading_content_from_icon_kind(
+                                                icon_kind_from_choice(choice),
+                                            ))
+                                        };
                                         let subtitle = indexed_choice
                                             .metadata
                                             .subtitle_text()
@@ -185,34 +278,60 @@
                                                     ))
                                                 },
                                             );
+                                        let row_bg = if is_focused {
+                                            focused_row_bg
+                                        } else if is_hovered {
+                                            hovered_row_bg
+                                        } else {
+                                            rgba(0x00000000)
+                                        };
+                                        let hover_handler = cx.listener(
+                                            move |this: &mut SelectPrompt,
+                                                  hovered: &bool,
+                                                  _window,
+                                                  cx| {
+                                                if *hovered {
+                                                    if this.hovered_index != Some(display_idx) {
+                                                        this.hovered_index = Some(display_idx);
+                                                        cx.notify();
+                                                    }
+                                                } else if this.hovered_index == Some(display_idx) {
+                                                    this.hovered_index = None;
+                                                    cx.notify();
+                                                }
+                                            },
+                                        );
+
+                                        let mut row = div()
+                                            .id(display_idx)
+                                            .w_full()
+                                            .h(px(LIST_ITEM_HEIGHT))
+                                            .rounded(px(8.0))
+                                            .bg(row_bg)
+                                            .cursor_pointer()
+                                            .on_hover(hover_handler)
+                                            .child(
+                                                UnifiedListItem::new(
+                                                    gpui::ElementId::Name(semantic_id.into()),
+                                                    title,
+                                                )
+                                                .subtitle_opt(subtitle)
+                                                .leading_opt(leading)
+                                                .trailing_opt(trailing)
+                                                .state(ItemState {
+                                                    is_selected,
+                                                    is_hovered,
+                                                    is_disabled: false,
+                                                })
+                                                .density(Density::Comfortable)
+                                                .colors(item_colors),
+                                            );
+
+                                        if !is_focused {
+                                            row = row.hover(move |s| s.bg(hovered_row_bg));
+                                        }
 
-                                        rows.push(
-                                            div()
-                                                .id(display_idx)
-                                                .w_full()
-                                                .h(px(LIST_ITEM_HEIGHT))
-                                                .border_b_1()
-                                                .border_color(border_color)
-                                                .child(
-                                                    UnifiedListItem::new(
-                                                        gpui::ElementId::Name(semantic_id.into()),
-                                                        title,
-                                                    )
-                                                    .subtitle_opt(subtitle)
-                                                    .leading(LeadingContent::Emoji(
-                                                        indicator.into(),
-                                                    ))
-                                                    .trailing_opt(trailing)
-                                                    .state(ItemState {
-                                                        is_selected: is_focused,
-                                                        is_hovered: false,
-                                                        is_disabled: false,
-                                                    })
-                                                    .density(Density::Comfortable)
-                                                    .colors(row_colors)
-                                                    .with_accent_bar(is_selected_for_ui),
-                                                ),
-                                        );
+                                        rows.push(row);
                                     }
                                 }
                             }
@@ -234,6 +353,7 @@
             .flex_col()
             .flex_1()
             .w_full()
+            .px(px(8.0))
             .child(choices_content);
 
         div()
diff --git a/src/prompts/select/tests.rs b/src/prompts/select/tests.rs
index 250ec9d63282ad81dd952efa12855f784330232c..2b048753d5f168dcbc59ccb0e399e4604bc39167
--- a/src/prompts/select/tests.rs
+++ b/src/prompts/select/tests.rs
@@ -184,3 +184,36 @@
         0x445566
     );
 }
+
+#[test]
+fn test_select_prompt_extracts_icon_hint_from_choice_metadata() {
+    let description = Some("Shortcut: cmd+k ‚Ä¢ icon: terminal ‚Ä¢ script");
+    assert_eq!(
+        render::extract_choice_icon_hint(description),
+        Some("terminal")
+    );
+}
+
+#[test]
+fn test_select_prompt_icon_kind_falls_back_to_code_icon_without_hint() {
+    let choice = choice("Deploy API", "/Users/me/.scriptkit/scripts/deploy.ts", None);
+
+    match render::icon_kind_from_choice(&choice) {
+        IconKind::Svg(name) => assert_eq!(name, "Code"),
+        _ => panic!("expected fallback Code SVG icon"),
+    }
+}
+
+#[test]
+fn test_select_prompt_compute_row_state_keeps_focus_and_selection_independent() {
+    let selected = std::collections::HashSet::from([5]);
+    let focused_but_unselected = render::compute_row_state(2, 2, 1, &selected, Some(1));
+    assert!(focused_but_unselected.is_focused);
+    assert!(!focused_but_unselected.is_selected);
+    assert!(!focused_but_unselected.is_hovered);
+
+    let selected_but_unfocused = render::compute_row_state(1, 2, 5, &selected, Some(1));
+    assert!(!selected_but_unfocused.is_focused);
+    assert!(selected_but_unfocused.is_selected);
+    assert!(selected_but_unfocused.is_hovered);
+}

file update:
diff --git a/src/list_item/part_000.rs b/src/list_item/part_000.rs
index 733d4ac2aa5b1b27b29a5999310e6f3f45cc54c3..283b2263d56a92c73c22d44443db7b40971d26ce
--- a/src/list_item/part_000.rs
+++ b/src/list_item/part_000.rs
@@ -15,6 +15,37 @@
     /// Maps to IconName from designs::icon_variations
     Svg(String),
 }
+
+impl IconKind {
+    /// Resolve icon metadata into an IconKind for list rendering.
+    ///
+    /// Supports:
+    /// - Known SVG names/aliases via `icon_name_from_str` (e.g., "Terminal", "file-code")
+    /// - Emoji/symbol glyphs (e.g., "üìÑ", "‚ö°")
+    pub fn from_icon_hint(icon_hint: &str) -> Option<Self> {
+        let trimmed = icon_hint.trim();
+        if trimmed.is_empty() {
+            return None;
+        }
+
+        if icon_name_from_str(trimmed).is_some() {
+            return Some(Self::Svg(trimmed.to_string()));
+        }
+
+        if looks_like_symbol_icon_hint(trimmed) {
+            return Some(Self::Emoji(trimmed.to_string()));
+        }
+
+        None
+    }
+}
+
+fn looks_like_symbol_icon_hint(icon_hint: &str) -> bool {
+    let has_ascii_alnum = icon_hint.chars().any(|ch| ch.is_ascii_alphanumeric());
+    let char_count = icon_hint.chars().count();
+
+    !has_ascii_alnum && char_count <= 4
+}
 /// Fixed height for list items used in uniform-height virtualized lists.
 ///
 /// IMPORTANT: When using GPUI `uniform_list`, the item closure must render
@@ -437,3 +468,29 @@
     /// Text color for content displayed on accent/warning backgrounds
     pub text_on_accent: u32,
 }
+
+#[cfg(test)]
+mod icon_kind_tests {
+    use super::IconKind;
+
+    #[test]
+    fn test_icon_kind_from_icon_hint_returns_svg_when_known_icon_name() {
+        match IconKind::from_icon_hint("terminal") {
+            Some(IconKind::Svg(name)) => assert_eq!(name, "terminal"),
+            _ => panic!("expected SVG icon from known icon hint"),
+        }
+    }
+
+    #[test]
+    fn test_icon_kind_from_icon_hint_returns_emoji_when_symbol_glyph() {
+        match IconKind::from_icon_hint("üìÑ") {
+            Some(IconKind::Emoji(emoji)) => assert_eq!(emoji, "üìÑ"),
+            _ => panic!("expected emoji icon for symbol glyph"),
+        }
+    }
+
+    #[test]
+    fn test_icon_kind_from_icon_hint_returns_none_for_unknown_ascii_word() {
+        assert!(IconKind::from_icon_hint("unknown-icon-name").is_none());
+    }
+}
diff --git a/src/prompts/select/mod.rs b/src/prompts/select/mod.rs
index b6366dabfb14f3fae09f854f9de824fa629e0a3b..80287d57d8b538dba0d85476dc6de3aa3409a2fd
--- a/src/prompts/select/mod.rs
+++ b/src/prompts/select/mod.rs
@@ -7,8 +7,8 @@
 //! - Submit selected items
 
 use gpui::{
-    div, prelude::*, px, rgb, uniform_list, AnyElement, Context, FocusHandle, Focusable, Render,
-    ScrollStrategy, SharedString, UniformListScrollHandle, Window,
+    div, prelude::*, px, rgb, rgba, uniform_list, AnyElement, Context, FocusHandle, Focusable,
+    Render, ScrollStrategy, SharedString, UniformListScrollHandle, Window,
 };
 use std::collections::HashSet;
 use std::ops::Range;
@@ -19,7 +19,7 @@
     UnifiedListItemColors,
 };
 use crate::designs::{get_tokens, DesignColors, DesignVariant};
-use crate::list_item::LIST_ITEM_HEIGHT;
+use crate::list_item::{IconKind, LIST_ITEM_HEIGHT};
 use crate::logging;
 use crate::panel::PROMPT_INPUT_FIELD_HEIGHT;
 use crate::protocol::{generate_semantic_id, Choice};
diff --git a/src/prompts/select/prompt.rs b/src/prompts/select/prompt.rs
index c5f98f5318f5b520e9223811f735e866ee06e7fb..5ba2de479b2f5680a73db72642377f68d26ee54e
--- a/src/prompts/select/prompt.rs
+++ b/src/prompts/select/prompt.rs
@@ -19,6 +19,8 @@
     pub filtered_choices: Vec<usize>,
     /// Currently focused index in filtered list
     pub focused_index: usize,
+    /// Currently hovered index in filtered list
+    pub hovered_index: Option<usize>,
     /// Filter text
     pub filter_text: String,
     /// Whether multiple selection is allowed
@@ -68,6 +70,7 @@
             selected: HashSet::new(),
             filtered_choices,
             focused_index: 0,
+            hovered_index: None,
             filter_text: String::new(),
             multiple,
             focus_handle,
@@ -84,6 +87,7 @@
         if trimmed_filter.is_empty() {
             self.filtered_choices = (0..self.choices.len()).collect();
             self.focused_index = 0;
+            self.hovered_index = None;
             return;
         }
 
@@ -109,6 +113,7 @@
 
         self.filtered_choices = scored_matches.into_iter().map(|(idx, _)| idx).collect();
         self.focused_index = 0;
+        self.hovered_index = None;
     }
 
     /// Set the filter text programmatically
@@ -168,6 +173,7 @@
     pub(super) fn move_up(&mut self, cx: &mut Context<Self>) {
         if self.focused_index > 0 {
             self.focused_index -= 1;
+            self.hovered_index = None;
             self.list_scroll_handle
                 .scroll_to_item(self.focused_index, ScrollStrategy::Nearest);
             cx.notify();
@@ -178,6 +184,7 @@
     pub(super) fn move_down(&mut self, cx: &mut Context<Self>) {
         if self.focused_index < self.filtered_choices.len().saturating_sub(1) {
             self.focused_index += 1;
+            self.hovered_index = None;
             self.list_scroll_handle
                 .scroll_to_item(self.focused_index, ScrollStrategy::Nearest);
             cx.notify();
diff --git a/src/prompts/select/render.rs b/src/prompts/select/render.rs
index 62109896c9c14b1b2fbf5b4d25d5d94e4388e4aa..e224ca641be966e7357474d1892f16fb9d59f392
--- a/src/prompts/select/render.rs
+++ b/src/prompts/select/render.rs
@@ -1,5 +1,78 @@
 use super::*;
 
+const ROW_FOCUSED_BG_ALPHA: u32 = 0x3A;
+const ROW_HOVER_BG_ALPHA: u32 = 0x26;
+
+#[derive(Clone, Copy, Debug, PartialEq, Eq)]
+pub(super) struct SelectRowState {
+    pub is_focused: bool,
+    pub is_selected: bool,
+    pub is_hovered: bool,
+}
+
+pub(super) fn compute_row_state(
+    display_idx: usize,
+    focused_index: usize,
+    choice_idx: usize,
+    selected: &HashSet<usize>,
+    hovered_index: Option<usize>,
+) -> SelectRowState {
+    SelectRowState {
+        is_focused: display_idx == focused_index,
+        is_selected: selected.contains(&choice_idx),
+        is_hovered: hovered_index == Some(display_idx),
+    }
+}
+
+pub(super) fn extract_choice_icon_hint(description: Option<&str>) -> Option<&str> {
+    description.and_then(|raw| {
+        raw.split(['‚Ä¢', '|', '\n'])
+            .map(str::trim)
+            .find_map(|token| {
+                let token_lower = token.to_ascii_lowercase();
+                if token_lower == "icon"
+                    || token_lower.starts_with("icon:")
+                    || token_lower.starts_with("icon=")
+                    || token_lower.starts_with("icon ")
+                {
+                    token
+                        .split_once(':')
+                        .or_else(|| token.split_once('='))
+                        .map(|(_, value)| value.trim())
+                        .or_else(|| token.split_whitespace().nth(1))
+                } else {
+                    None
+                }
+            })
+            .filter(|value| !value.is_empty())
+    })
+}
+
+pub(super) fn icon_kind_from_choice(choice: &Choice) -> IconKind {
+    let metadata_icon =
+        extract_choice_icon_hint(choice.description.as_deref()).and_then(IconKind::from_icon_hint);
+    let name_prefix_icon = choice
+        .name
+        .split_whitespace()
+        .next()
+        .and_then(IconKind::from_icon_hint);
+
+    metadata_icon
+        .or(name_prefix_icon)
+        .unwrap_or_else(|| IconKind::Svg("Code".to_string()))
+}
+
+fn leading_content_from_icon_kind(icon_kind: IconKind) -> LeadingContent {
+    match icon_kind {
+        IconKind::Emoji(emoji) => LeadingContent::Emoji(emoji.into()),
+        IconKind::Image(render_image) => LeadingContent::AppIcon(render_image),
+        IconKind::Svg(name) => LeadingContent::Icon {
+            name: SharedString::from(name),
+            color: None,
+        },
+    }
+}
+
 impl Focusable for SelectPrompt {
     fn focus_handle(&self, _cx: &gpui::App) -> FocusHandle {
         self.focus_handle.clone()
@@ -76,6 +149,13 @@
             self.design_variant,
             &colors,
         ));
+        let row_accent_color = if self.design_variant == DesignVariant::Default {
+            self.theme.colors.accent.selected
+        } else {
+            colors.accent
+        };
+        let focused_row_bg = rgba((row_accent_color << 8) | ROW_FOCUSED_BG_ALPHA);
+        let hovered_row_bg = rgba((row_accent_color << 8) | ROW_HOVER_BG_ALPHA);
 
         let placeholder = self
             .placeholder
@@ -145,8 +225,12 @@
                     move |this: &mut SelectPrompt,
                           visible_range: std::ops::Range<usize>,
                           _window,
-                          _cx| {
-                        let row_colors = UnifiedListItemColors::from_theme(&this.theme);
+                          cx| {
+                        let item_colors = UnifiedListItemColors {
+                            selected_opacity: 0.0,
+                            hover_opacity: 0.0,
+                            ..UnifiedListItemColors::from_theme(&this.theme)
+                        };
                         let mut rows = Vec::with_capacity(visible_range.len());
 
                         for display_idx in visible_range {
@@ -154,21 +238,30 @@
                                 if let Some(choice) = this.choices.get(choice_idx) {
                                     if let Some(indexed_choice) = this.choice_index.get(choice_idx)
                                     {
-                                        let is_focused = display_idx == this.focused_index;
-                                        let is_selected = this.selected.contains(&choice_idx);
-                                        let is_selected_for_ui = if this.multiple {
-                                            is_selected
-                                        } else {
-                                            is_focused
-                                        };
+                                        let row_state = compute_row_state(
+                                            display_idx,
+                                            this.focused_index,
+                                            choice_idx,
+                                            &this.selected,
+                                            this.hovered_index,
+                                        );
+                                        let is_focused = row_state.is_focused;
+                                        let is_selected = row_state.is_selected;
+                                        let is_hovered = row_state.is_hovered;
                                         let semantic_id =
                                             choice.semantic_id.clone().unwrap_or_else(|| {
                                                 indexed_choice.stable_semantic_id.clone()
                                             });
-                                        let indicator = choice_selection_indicator(
-                                            this.multiple,
-                                            is_selected_for_ui,
-                                        );
+                                        let leading = if this.multiple {
+                                            Some(LeadingContent::Emoji(
+                                                choice_selection_indicator(true, is_selected)
+                                                    .into(),
+                                            ))
+                                        } else {
+                                            Some(leading_content_from_icon_kind(
+                                                icon_kind_from_choice(choice),
+                                            ))
+                                        };
                                         let subtitle = indexed_choice
                                             .metadata
                                             .subtitle_text()
@@ -185,34 +278,60 @@
                                                     ))
                                                 },
                                             );
+                                        let row_bg = if is_focused {
+                                            focused_row_bg
+                                        } else if is_hovered {
+                                            hovered_row_bg
+                                        } else {
+                                            rgba(0x00000000)
+                                        };
+                                        let hover_handler = cx.listener(
+                                            move |this: &mut SelectPrompt,
+                                                  hovered: &bool,
+                                                  _window,
+                                                  cx| {
+                                                if *hovered {
+                                                    if this.hovered_index != Some(display_idx) {
+                                                        this.hovered_index = Some(display_idx);
+                                                        cx.notify();
+                                                    }
+                                                } else if this.hovered_index == Some(display_idx) {
+                                                    this.hovered_index = None;
+                                                    cx.notify();
+                                                }
+                                            },
+                                        );
+
+                                        let mut row = div()
+                                            .id(display_idx)
+                                            .w_full()
+                                            .h(px(LIST_ITEM_HEIGHT))
+                                            .rounded(px(8.0))
+                                            .bg(row_bg)
+                                            .cursor_pointer()
+                                            .on_hover(hover_handler)
+                                            .child(
+                                                UnifiedListItem::new(
+                                                    gpui::ElementId::Name(semantic_id.into()),
+                                                    title,
+                                                )
+                                                .subtitle_opt(subtitle)
+                                                .leading_opt(leading)
+                                                .trailing_opt(trailing)
+                                                .state(ItemState {
+                                                    is_selected,
+                                                    is_hovered,
+                                                    is_disabled: false,
+                                                })
+                                                .density(Density::Comfortable)
+                                                .colors(item_colors),
+                                            );
+
+                                        if !is_focused {
+                                            row = row.hover(move |s| s.bg(hovered_row_bg));
+                                        }
 
-                                        rows.push(
-                                            div()
-                                                .id(display_idx)
-                                                .w_full()
-                                                .h(px(LIST_ITEM_HEIGHT))
-                                                .border_b_1()
-                                                .border_color(border_color)
-                                                .child(
-                                                    UnifiedListItem::new(
-                                                        gpui::ElementId::Name(semantic_id.into()),
-                                                        title,
-                                                    )
-                                                    .subtitle_opt(subtitle)
-                                                    .leading(LeadingContent::Emoji(
-                                                        indicator.into(),
-                                                    ))
-                                                    .trailing_opt(trailing)
-                                                    .state(ItemState {
-                                                        is_selected: is_focused,
-                                                        is_hovered: false,
-                                                        is_disabled: false,
-                                                    })
-                                                    .density(Density::Comfortable)
-                                                    .colors(row_colors)
-                                                    .with_accent_bar(is_selected_for_ui),
-                                                ),
-                                        );
+                                        rows.push(row);
                                     }
                                 }
                             }
@@ -234,6 +353,7 @@
             .flex_col()
             .flex_1()
             .w_full()
+            .px(px(8.0))
             .child(choices_content);
 
         div()
diff --git a/src/prompts/select/tests.rs b/src/prompts/select/tests.rs
index 250ec9d63282ad81dd952efa12855f784330232c..2b048753d5f168dcbc59ccb0e399e4604bc39167
--- a/src/prompts/select/tests.rs
+++ b/src/prompts/select/tests.rs
@@ -184,3 +184,36 @@
         0x445566
     );
 }
+
+#[test]
+fn test_select_prompt_extracts_icon_hint_from_choice_metadata() {
+    let description = Some("Shortcut: cmd+k ‚Ä¢ icon: terminal ‚Ä¢ script");
+    assert_eq!(
+        render::extract_choice_icon_hint(description),
+        Some("terminal")
+    );
+}
+
+#[test]
+fn test_select_prompt_icon_kind_falls_back_to_code_icon_without_hint() {
+    let choice = choice("Deploy API", "/Users/me/.scriptkit/scripts/deploy.ts", None);
+
+    match render::icon_kind_from_choice(&choice) {
+        IconKind::Svg(name) => assert_eq!(name, "Code"),
+        _ => panic!("expected fallback Code SVG icon"),
+    }
+}
+
+#[test]
+fn test_select_prompt_compute_row_state_keeps_focus_and_selection_independent() {
+    let selected = std::collections::HashSet::from([5]);
+    let focused_but_unselected = render::compute_row_state(2, 2, 1, &selected, Some(1));
+    assert!(focused_but_unselected.is_focused);
+    assert!(!focused_but_unselected.is_selected);
+    assert!(!focused_but_unselected.is_hovered);
+
+    let selected_but_unfocused = render::compute_row_state(1, 2, 5, &selected, Some(1));
+    assert!(!selected_but_unfocused.is_focused);
+    assert!(selected_but_unfocused.is_selected);
+    assert!(selected_but_unfocused.is_hovered);
+}


thinking
**Preparing to format module file**
exec
/bin/zsh -lc 'cd /Users/johnlindquist/dev/script-kit-gpui && rustfmt src/prompts/select/mod.rs' in /Users/johnlindquist/dev/script-kit-gpui succeeded in 51ms:

file update:
diff --git a/src/list_item/part_000.rs b/src/list_item/part_000.rs
index 733d4ac2aa5b1b27b29a5999310e6f3f45cc54c3..283b2263d56a92c73c22d44443db7b40971d26ce
--- a/src/list_item/part_000.rs
+++ b/src/list_item/part_000.rs
@@ -15,6 +15,37 @@
     /// Maps to IconName from designs::icon_variations
     Svg(String),
 }
+
+impl IconKind {
+    /// Resolve icon metadata into an IconKind for list rendering.
+    ///
+    /// Supports:
+    /// - Known SVG names/aliases via `icon_name_from_str` (e.g., "Terminal", "file-code")
+    /// - Emoji/symbol glyphs (e.g., "üìÑ", "‚ö°")
+    pub fn from_icon_hint(icon_hint: &str) -> Option<Self> {
+        let trimmed = icon_hint.trim();
+        if trimmed.is_empty() {
+            return None;
+        }
+
+        if icon_name_from_str(trimmed).is_some() {
+            return Some(Self::Svg(trimmed.to_string()));
+        }
+
+        if looks_like_symbol_icon_hint(trimmed) {
+            return Some(Self::Emoji(trimmed.to_string()));
+        }
+
+        None
+    }
+}
+
+fn looks_like_symbol_icon_hint(icon_hint: &str) -> bool {
+    let has_ascii_alnum = icon_hint.chars().any(|ch| ch.is_ascii_alphanumeric());
+    let char_count = icon_hint.chars().count();
+
+    !has_ascii_alnum && char_count <= 4
+}
 /// Fixed height for list items used in uniform-height virtualized lists.
 ///
 /// IMPORTANT: When using GPUI `uniform_list`, the item closure must render
@@ -437,3 +468,29 @@
     /// Text color for content displayed on accent/warning backgrounds
     pub text_on_accent: u32,
 }
+
+#[cfg(test)]
+mod icon_kind_tests {
+    use super::IconKind;
+
+    #[test]
+    fn test_icon_kind_from_icon_hint_returns_svg_when_known_icon_name() {
+        match IconKind::from_icon_hint("terminal") {
+            Some(IconKind::Svg(name)) => assert_eq!(name, "terminal"),
+            _ => panic!("expected SVG icon from known icon hint"),
+        }
+    }
+
+    #[test]
+    fn test_icon_kind_from_icon_hint_returns_emoji_when_symbol_glyph() {
+        match IconKind::from_icon_hint("üìÑ") {
+            Some(IconKind::Emoji(emoji)) => assert_eq!(emoji, "üìÑ"),
+            _ => panic!("expected emoji icon for symbol glyph"),
+        }
+    }
+
+    #[test]
+    fn test_icon_kind_from_icon_hint_returns_none_for_unknown_ascii_word() {
+        assert!(IconKind::from_icon_hint("unknown-icon-name").is_none());
+    }
+}
diff --git a/src/prompts/select/mod.rs b/src/prompts/select/mod.rs
index b6366dabfb14f3fae09f854f9de824fa629e0a3b..80287d57d8b538dba0d85476dc6de3aa3409a2fd
--- a/src/prompts/select/mod.rs
+++ b/src/prompts/select/mod.rs
@@ -7,8 +7,8 @@
 //! - Submit selected items
 
 use gpui::{
-    div, prelude::*, px, rgb, uniform_list, AnyElement, Context, FocusHandle, Focusable, Render,
-    ScrollStrategy, SharedString, UniformListScrollHandle, Window,
+    div, prelude::*, px, rgb, rgba, uniform_list, AnyElement, Context, FocusHandle, Focusable,
+    Render, ScrollStrategy, SharedString, UniformListScrollHandle, Window,
 };
 use std::collections::HashSet;
 use std::ops::Range;
@@ -19,7 +19,7 @@
     UnifiedListItemColors,
 };
 use crate::designs::{get_tokens, DesignColors, DesignVariant};
-use crate::list_item::LIST_ITEM_HEIGHT;
+use crate::list_item::{IconKind, LIST_ITEM_HEIGHT};
 use crate::logging;
 use crate::panel::PROMPT_INPUT_FIELD_HEIGHT;
 use crate::protocol::{generate_semantic_id, Choice};
diff --git a/src/prompts/select/prompt.rs b/src/prompts/select/prompt.rs
index c5f98f5318f5b520e9223811f735e866ee06e7fb..5ba2de479b2f5680a73db72642377f68d26ee54e
--- a/src/prompts/select/prompt.rs
+++ b/src/prompts/select/prompt.rs
@@ -19,6 +19,8 @@
     pub filtered_choices: Vec<usize>,
     /// Currently focused index in filtered list
     pub focused_index: usize,
+    /// Currently hovered index in filtered list
+    pub hovered_index: Option<usize>,
     /// Filter text
     pub filter_text: String,
     /// Whether multiple selection is allowed
@@ -68,6 +70,7 @@
             selected: HashSet::new(),
             filtered_choices,
             focused_index: 0,
+            hovered_index: None,
             filter_text: String::new(),
             multiple,
             focus_handle,
@@ -84,6 +87,7 @@
         if trimmed_filter.is_empty() {
             self.filtered_choices = (0..self.choices.len()).collect();
             self.focused_index = 0;
+            self.hovered_index = None;
             return;
         }
 
@@ -109,6 +113,7 @@
 
         self.filtered_choices = scored_matches.into_iter().map(|(idx, _)| idx).collect();
         self.focused_index = 0;
+        self.hovered_index = None;
     }
 
     /// Set the filter text programmatically
@@ -168,6 +173,7 @@
     pub(super) fn move_up(&mut self, cx: &mut Context<Self>) {
         if self.focused_index > 0 {
             self.focused_index -= 1;
+            self.hovered_index = None;
             self.list_scroll_handle
                 .scroll_to_item(self.focused_index, ScrollStrategy::Nearest);
             cx.notify();
@@ -178,6 +184,7 @@
     pub(super) fn move_down(&mut self, cx: &mut Context<Self>) {
         if self.focused_index < self.filtered_choices.len().saturating_sub(1) {
             self.focused_index += 1;
+            self.hovered_index = None;
             self.list_scroll_handle
                 .scroll_to_item(self.focused_index, ScrollStrategy::Nearest);
             cx.notify();
diff --git a/src/prompts/select/render.rs b/src/prompts/select/render.rs
index 62109896c9c14b1b2fbf5b4d25d5d94e4388e4aa..e224ca641be966e7357474d1892f16fb9d59f392
--- a/src/prompts/select/render.rs
+++ b/src/prompts/select/render.rs
@@ -1,5 +1,78 @@
 use super::*;
 
+const ROW_FOCUSED_BG_ALPHA: u32 = 0x3A;
+const ROW_HOVER_BG_ALPHA: u32 = 0x26;
+
+#[derive(Clone, Copy, Debug, PartialEq, Eq)]
+pub(super) struct SelectRowState {
+    pub is_focused: bool,
+    pub is_selected: bool,
+    pub is_hovered: bool,
+}
+
+pub(super) fn compute_row_state(
+    display_idx: usize,
+    focused_index: usize,
+    choice_idx: usize,
+    selected: &HashSet<usize>,
+    hovered_index: Option<usize>,
+) -> SelectRowState {
+    SelectRowState {
+        is_focused: display_idx == focused_index,
+        is_selected: selected.contains(&choice_idx),
+        is_hovered: hovered_index == Some(display_idx),
+    }
+}
+
+pub(super) fn extract_choice_icon_hint(description: Option<&str>) -> Option<&str> {
+    description.and_then(|raw| {
+        raw.split(['‚Ä¢', '|', '\n'])
+            .map(str::trim)
+            .find_map(|token| {
+                let token_lower = token.to_ascii_lowercase();
+                if token_lower == "icon"
+                    || token_lower.starts_with("icon:")
+                    || token_lower.starts_with("icon=")
+                    || token_lower.starts_with("icon ")
+                {
+                    token
+                        .split_once(':')
+                        .or_else(|| token.split_once('='))
+                        .map(|(_, value)| value.trim())
+                        .or_else(|| token.split_whitespace().nth(1))
+                } else {
+                    None
+                }
+            })
+            .filter(|value| !value.is_empty())
+    })
+}
+
+pub(super) fn icon_kind_from_choice(choice: &Choice) -> IconKind {
+    let metadata_icon =
+        extract_choice_icon_hint(choice.description.as_deref()).and_then(IconKind::from_icon_hint);
+    let name_prefix_icon = choice
+        .name
+        .split_whitespace()
+        .next()
+        .and_then(IconKind::from_icon_hint);
+
+    metadata_icon
+        .or(name_prefix_icon)
+        .unwrap_or_else(|| IconKind::Svg("Code".to_string()))
+}
+
+fn leading_content_from_icon_kind(icon_kind: IconKind) -> LeadingContent {
+    match icon_kind {
+        IconKind::Emoji(emoji) => LeadingContent::Emoji(emoji.into()),
+        IconKind::Image(render_image) => LeadingContent::AppIcon(render_image),
+        IconKind::Svg(name) => LeadingContent::Icon {
+            name: SharedString::from(name),
+            color: None,
+        },
+    }
+}
+
 impl Focusable for SelectPrompt {
     fn focus_handle(&self, _cx: &gpui::App) -> FocusHandle {
         self.focus_handle.clone()
@@ -76,6 +149,13 @@
             self.design_variant,
             &colors,
         ));
+        let row_accent_color = if self.design_variant == DesignVariant::Default {
+            self.theme.colors.accent.selected
+        } else {
+            colors.accent
+        };
+        let focused_row_bg = rgba((row_accent_color << 8) | ROW_FOCUSED_BG_ALPHA);
+        let hovered_row_bg = rgba((row_accent_color << 8) | ROW_HOVER_BG_ALPHA);
 
         let placeholder = self
             .placeholder
@@ -145,8 +225,12 @@
                     move |this: &mut SelectPrompt,
                           visible_range: std::ops::Range<usize>,
                           _window,
-                          _cx| {
-                        let row_colors = UnifiedListItemColors::from_theme(&this.theme);
+                          cx| {
+                        let item_colors = UnifiedListItemColors {
+                            selected_opacity: 0.0,
+                            hover_opacity: 0.0,
+                            ..UnifiedListItemColors::from_theme(&this.theme)
+                        };
                         let mut rows = Vec::with_capacity(visible_range.len());
 
                         for display_idx in visible_range {
@@ -154,21 +238,30 @@
                                 if let Some(choice) = this.choices.get(choice_idx) {
                                     if let Some(indexed_choice) = this.choice_index.get(choice_idx)
                                     {
-                                        let is_focused = display_idx == this.focused_index;
-                                        let is_selected = this.selected.contains(&choice_idx);
-                                        let is_selected_for_ui = if this.multiple {
-                                            is_selected
-                                        } else {
-                                            is_focused
-                                        };
+                                        let row_state = compute_row_state(
+                                            display_idx,
+                                            this.focused_index,
+                                            choice_idx,
+                                            &this.selected,
+                                            this.hovered_index,
+                                        );
+                                        let is_focused = row_state.is_focused;
+                                        let is_selected = row_state.is_selected;
+                                        let is_hovered = row_state.is_hovered;
                                         let semantic_id =
                                             choice.semantic_id.clone().unwrap_or_else(|| {
                                                 indexed_choice.stable_semantic_id.clone()
                                             });
-                                        let indicator = choice_selection_indicator(
-                                            this.multiple,
-                                            is_selected_for_ui,
-                                        );
+                                        let leading = if this.multiple {
+                                            Some(LeadingContent::Emoji(
+                                                choice_selection_indicator(true, is_selected)
+                                                    .into(),
+                                            ))
+                                        } else {
+                                            Some(leading_content_from_icon_kind(
+                                                icon_kind_from_choice(choice),
+                                            ))
+                                        };
                                         let subtitle = indexed_choice
                                             .metadata
                                             .subtitle_text()
@@ -185,34 +278,60 @@
                                                     ))
                                                 },
                                             );
+                                        let row_bg = if is_focused {
+                                            focused_row_bg
+                                        } else if is_hovered {
+                                            hovered_row_bg
+                                        } else {
+                                            rgba(0x00000000)
+                                        };
+                                        let hover_handler = cx.listener(
+                                            move |this: &mut SelectPrompt,
+                                                  hovered: &bool,
+                                                  _window,
+                                                  cx| {
+                                                if *hovered {
+                                                    if this.hovered_index != Some(display_idx) {
+                                                        this.hovered_index = Some(display_idx);
+                                                        cx.notify();
+                                                    }
+                                                } else if this.hovered_index == Some(display_idx) {
+                                                    this.hovered_index = None;
+                                                    cx.notify();
+                                                }
+                                            },
+                                        );
+
+                                        let mut row = div()
+                                            .id(display_idx)
+                                            .w_full()
+                                            .h(px(LIST_ITEM_HEIGHT))
+                                            .rounded(px(8.0))
+                                            .bg(row_bg)
+                                            .cursor_pointer()
+                                            .on_hover(hover_handler)
+                                            .child(
+                                                UnifiedListItem::new(
+                                                    gpui::ElementId::Name(semantic_id.into()),
+                                                    title,
+                                                )
+                                                .subtitle_opt(subtitle)
+                                                .leading_opt(leading)
+                                                .trailing_opt(trailing)
+                                                .state(ItemState {
+                                                    is_selected,
+                                                    is_hovered,
+                                                    is_disabled: false,
+                                                })
+                                                .density(Density::Comfortable)
+                                                .colors(item_colors),
+                                            );
+
+                                        if !is_focused {
+                                            row = row.hover(move |s| s.bg(hovered_row_bg));
+                                        }
 
-                                        rows.push(
-                                            div()
-                                                .id(display_idx)
-                                                .w_full()
-                                                .h(px(LIST_ITEM_HEIGHT))
-                                                .border_b_1()
-                                                .border_color(border_color)
-                                                .child(
-                                                    UnifiedListItem::new(
-                                                        gpui::ElementId::Name(semantic_id.into()),
-                                                        title,
-                                                    )
-                                                    .subtitle_opt(subtitle)
-                                                    .leading(LeadingContent::Emoji(
-                                                        indicator.into(),
-                                                    ))
-                                                    .trailing_opt(trailing)
-                                                    .state(ItemState {
-                                                        is_selected: is_focused,
-                                                        is_hovered: false,
-                                                        is_disabled: false,
-                                                    })
-                                                    .density(Density::Comfortable)
-                                                    .colors(row_colors)
-                                                    .with_accent_bar(is_selected_for_ui),
-                                                ),
-                                        );
+                                        rows.push(row);
                                     }
                                 }
                             }
@@ -234,6 +353,7 @@
             .flex_col()
             .flex_1()
             .w_full()
+            .px(px(8.0))
             .child(choices_content);
 
         div()
diff --git a/src/prompts/select/tests.rs b/src/prompts/select/tests.rs
index 250ec9d63282ad81dd952efa12855f784330232c..2b048753d5f168dcbc59ccb0e399e4604bc39167
--- a/src/prompts/select/tests.rs
+++ b/src/prompts/select/tests.rs
@@ -184,3 +184,36 @@
         0x445566
     );
 }
+
+#[test]
+fn test_select_prompt_extracts_icon_hint_from_choice_metadata() {
+    let description = Some("Shortcut: cmd+k ‚Ä¢ icon: terminal ‚Ä¢ script");
+    assert_eq!(
+        render::extract_choice_icon_hint(description),
+        Some("terminal")
+    );
+}
+
+#[test]
+fn test_select_prompt_icon_kind_falls_back_to_code_icon_without_hint() {
+    let choice = choice("Deploy API", "/Users/me/.scriptkit/scripts/deploy.ts", None);
+
+    match render::icon_kind_from_choice(&choice) {
+        IconKind::Svg(name) => assert_eq!(name, "Code"),
+        _ => panic!("expected fallback Code SVG icon"),
+    }
+}
+
+#[test]
+fn test_select_prompt_compute_row_state_keeps_focus_and_selection_independent() {
+    let selected = std::collections::HashSet::from([5]);
+    let focused_but_unselected = render::compute_row_state(2, 2, 1, &selected, Some(1));
+    assert!(focused_but_unselected.is_focused);
+    assert!(!focused_but_unselected.is_selected);
+    assert!(!focused_but_unselected.is_hovered);
+
+    let selected_but_unfocused = render::compute_row_state(1, 2, 5, &selected, Some(1));
+    assert!(!selected_but_unfocused.is_focused);
+    assert!(selected_but_unfocused.is_selected);
+    assert!(selected_but_unfocused.is_hovered);
+}

exec
/bin/zsh -lc 'cd /Users/johnlindquist/dev/script-kit-gpui && cargo check -p script-kit-gpui' in /Users/johnlindquist/dev/script-kit-gpuifile update:
diff --git a/src/list_item/part_000.rs b/src/list_item/part_000.rs
index 733d4ac2aa5b1b27b29a5999310e6f3f45cc54c3..283b2263d56a92c73c22d44443db7b40971d26ce
--- a/src/list_item/part_000.rs
+++ b/src/list_item/part_000.rs
@@ -15,6 +15,37 @@
     /// Maps to IconName from designs::icon_variations
     Svg(String),
 }
+
+impl IconKind {
+    /// Resolve icon metadata into an IconKind for list rendering.
+    ///
+    /// Supports:
+    /// - Known SVG names/aliases via `icon_name_from_str` (e.g., "Terminal", "file-code")
+    /// - Emoji/symbol glyphs (e.g., "üìÑ", "‚ö°")
+    pub fn from_icon_hint(icon_hint: &str) -> Option<Self> {
+        let trimmed = icon_hint.trim();
+        if trimmed.is_empty() {
+            return None;
+        }
+
+        if icon_name_from_str(trimmed).is_some() {
+            return Some(Self::Svg(trimmed.to_string()));
+        }
+
+        if looks_like_symbol_icon_hint(trimmed) {
+            return Some(Self::Emoji(trimmed.to_string()));
+        }
+
+        None
+    }
+}
+
+fn looks_like_symbol_icon_hint(icon_hint: &str) -> bool {
+    let has_ascii_alnum = icon_hint.chars().any(|ch| ch.is_ascii_alphanumeric());
+    let char_count = icon_hint.chars().count();
+
+    !has_ascii_alnum && char_count <= 4
+}
 /// Fixed height for list items used in uniform-height virtualized lists.
 ///
 /// IMPORTANT: When using GPUI `uniform_list`, the item closure must render
@@ -437,3 +468,29 @@
     /// Text color for content displayed on accent/warning backgrounds
     pub text_on_accent: u32,
 }
+
+#[cfg(test)]
+mod icon_kind_tests {
+    use super::IconKind;
+
+    #[test]
+    fn test_icon_kind_from_icon_hint_returns_svg_when_known_icon_name() {
+        match IconKind::from_icon_hint("terminal") {
+            Some(IconKind::Svg(name)) => assert_eq!(name, "terminal"),
+            _ => panic!("expected SVG icon from known icon hint"),
+        }
+    }
+
+    #[test]
+    fn test_icon_kind_from_icon_hint_returns_emoji_when_symbol_glyph() {
+        match IconKind::from_icon_hint("üìÑ") {
+            Some(IconKind::Emoji(emoji)) => assert_eq!(emoji, "üìÑ"),
+            _ => panic!("expected emoji icon for symbol glyph"),
+        }
+    }
+
+    #[test]
+    fn test_icon_kind_from_icon_hint_returns_none_for_unknown_ascii_word() {
+        assert!(IconKind::from_icon_hint("unknown-icon-name").is_none());
+    }
+}
diff --git a/src/prompts/select/mod.rs b/src/prompts/select/mod.rs
index b6366dabfb14f3fae09f854f9de824fa629e0a3b..80287d57d8b538dba0d85476dc6de3aa3409a2fd
--- a/src/prompts/select/mod.rs
+++ b/src/prompts/select/mod.rs
@@ -7,8 +7,8 @@
 //! - Submit selected items
 
 use gpui::{
-    div, prelude::*, px, rgb, uniform_list, AnyElement, Context, FocusHandle, Focusable, Render,
-    ScrollStrategy, SharedString, UniformListScrollHandle, Window,
+    div, prelude::*, px, rgb, rgba, uniform_list, AnyElement, Context, FocusHandle, Focusable,
+    Render, ScrollStrategy, SharedString, UniformListScrollHandle, Window,
 };
 use std::collections::HashSet;
 use std::ops::Range;
@@ -19,7 +19,7 @@
     UnifiedListItemColors,
 };
 use crate::designs::{get_tokens, DesignColors, DesignVariant};
-use crate::list_item::LIST_ITEM_HEIGHT;
+use crate::list_item::{IconKind, LIST_ITEM_HEIGHT};
 use crate::logging;
 use crate::panel::PROMPT_INPUT_FIELD_HEIGHT;
 use crate::protocol::{generate_semantic_id, Choice};
diff --git a/src/prompts/select/prompt.rs b/src/prompts/select/prompt.rs
index c5f98f5318f5b520e9223811f735e866ee06e7fb..5ba2de479b2f5680a73db72642377f68d26ee54e
--- a/src/prompts/select/prompt.rs
+++ b/src/prompts/select/prompt.rs
@@ -19,6 +19,8 @@
     pub filtered_choices: Vec<usize>,
     /// Currently focused index in filtered list
     pub focused_index: usize,
+    /// Currently hovered index in filtered list
+    pub hovered_index: Option<usize>,
     /// Filter text
     pub filter_text: String,
     /// Whether multiple selection is allowed
@@ -68,6 +70,7 @@
             selected: HashSet::new(),
             filtered_choices,
             focused_index: 0,
+            hovered_index: None,
             filter_text: String::new(),
             multiple,
             focus_handle,
@@ -84,6 +87,7 @@
         if trimmed_filter.is_empty() {
             self.filtered_choices = (0..self.choices.len()).collect();
             self.focused_index = 0;
+            self.hovered_index = None;
             return;
         }
 
@@ -109,6 +113,7 @@
 
         self.filtered_choices = scored_matches.into_iter().map(|(idx, _)| idx).collect();
         self.focused_index = 0;
+        self.hovered_index = None;
     }
 
     /// Set the filter text programmatically
@@ -168,6 +173,7 @@
     pub(super) fn move_up(&mut self, cx: &mut Context<Self>) {
         if self.focused_index > 0 {
             self.focused_index -= 1;
+            self.hovered_index = None;
             self.list_scroll_handle
                 .scroll_to_item(self.focused_index, ScrollStrategy::Nearest);
             cx.notify();
@@ -178,6 +184,7 @@
     pub(super) fn move_down(&mut self, cx: &mut Context<Self>) {
         if self.focused_index < self.filtered_choices.len().saturating_sub(1) {
             self.focused_index += 1;
+            self.hovered_index = None;
             self.list_scroll_handle
                 .scroll_to_item(self.focused_index, ScrollStrategy::Nearest);
             cx.notify();
diff --git a/src/prompts/select/render.rs b/src/prompts/select/render.rs
index 62109896c9c14b1b2fbf5b4d25d5d94e4388e4aa..e224ca641be966e7357474d1892f16fb9d59f392
--- a/src/prompts/select/render.rs
+++ b/src/prompts/select/render.rs
@@ -1,5 +1,78 @@
 use super::*;
 
+const ROW_FOCUSED_BG_ALPHA: u32 = 0x3A;
+const ROW_HOVER_BG_ALPHA: u32 = 0x26;
+
+#[derive(Clone, Copy, Debug, PartialEq, Eq)]
+pub(super) struct SelectRowState {
+    pub is_focused: bool,
+    pub is_selected: bool,
+    pub is_hovered: bool,
+}
+
+pub(super) fn compute_row_state(
+    display_idx: usize,
+    focused_index: usize,
+    choice_idx: usize,
+    selected: &HashSet<usize>,
+    hovered_index: Option<usize>,
+) -> SelectRowState {
+    SelectRowState {
+        is_focused: display_idx == focused_index,
+        is_selected: selected.contains(&choice_idx),
+        is_hovered: hovered_index == Some(display_idx),
+    }
+}
+
+pub(super) fn extract_choice_icon_hint(description: Option<&str>) -> Option<&str> {
+    description.and_then(|raw| {
+        raw.split(['‚Ä¢', '|', '\n'])
+            .map(str::trim)
+            .find_map(|token| {
+                let token_lower = token.to_ascii_lowercase();
+                if token_lower == "icon"
+                    || token_lower.starts_with("icon:")
+                    || token_lower.starts_with("icon=")
+                    || token_lower.starts_with("icon ")
+                {
+                    token
+                        .split_once(':')
+                        .or_else(|| token.split_once('='))
+                        .map(|(_, value)| value.trim())
+                        .or_else(|| token.split_whitespace().nth(1))
+                } else {
+                    None
+                }
+            })
+            .filter(|value| !value.is_empty())
+    })
+}
+
+pub(super) fn icon_kind_from_choice(choice: &Choice) -> IconKind {
+    let metadata_icon =
+        extract_choice_icon_hint(choice.description.as_deref()).and_then(IconKind::from_icon_hint);
+    let name_prefix_icon = choice
+        .name
+        .split_whitespace()
+        .next()
+        .and_then(IconKind::from_icon_hint);
+
+    metadata_icon
+        .or(name_prefix_icon)
+        .unwrap_or_else(|| IconKind::Svg("Code".to_string()))
+}
+
+fn leading_content_from_icon_kind(icon_kind: IconKind) -> LeadingContent {
+    match icon_kind {
+        IconKind::Emoji(emoji) => LeadingContent::Emoji(emoji.into()),
+        IconKind::Image(render_image) => LeadingContent::AppIcon(render_image),
+        IconKind::Svg(name) => LeadingContent::Icon {
+            name: SharedString::from(name),
+            color: None,
+        },
+    }
+}
+
 impl Focusable for SelectPrompt {
     fn focus_handle(&self, _cx: &gpui::App) -> FocusHandle {
         self.focus_handle.clone()
@@ -76,6 +149,13 @@
             self.design_variant,
             &colors,
         ));
+        let row_accent_color = if self.design_variant == DesignVariant::Default {
+            self.theme.colors.accent.selected
+        } else {
+            colors.accent
+        };
+        let focused_row_bg = rgba((row_accent_color << 8) | ROW_FOCUSED_BG_ALPHA);
+        let hovered_row_bg = rgba((row_accent_color << 8) | ROW_HOVER_BG_ALPHA);
 
         let placeholder = self
             .placeholder
@@ -145,8 +225,12 @@
                     move |this: &mut SelectPrompt,
                           visible_range: std::ops::Range<usize>,
                           _window,
-                          _cx| {
-                        let row_colors = UnifiedListItemColors::from_theme(&this.theme);
+                          cx| {
+                        let item_colors = UnifiedListItemColors {
+                            selected_opacity: 0.0,
+                            hover_opacity: 0.0,
+                            ..UnifiedListItemColors::from_theme(&this.theme)
+                        };
                         let mut rows = Vec::with_capacity(visible_range.len());
 
                         for display_idx in visible_range {
@@ -154,21 +238,30 @@
                                 if let Some(choice) = this.choices.get(choice_idx) {
                                     if let Some(indexed_choice) = this.choice_index.get(choice_idx)
                                     {
-                                        let is_focused = display_idx == this.focused_index;
-                                        let is_selected = this.selected.contains(&choice_idx);
-                                        let is_selected_for_ui = if this.multiple {
-                                            is_selected
-                                        } else {
-                                            is_focused
-                                        };
+                                        let row_state = compute_row_state(
+                                            display_idx,
+                                            this.focused_index,
+                                            choice_idx,
+                                            &this.selected,
+                                            this.hovered_index,
+                                        );
+                                        let is_focused = row_state.is_focused;
+                                        let is_selected = row_state.is_selected;
+                                        let is_hovered = row_state.is_hovered;
                                         let semantic_id =
                                             choice.semantic_id.clone().unwrap_or_else(|| {
                                                 indexed_choice.stable_semantic_id.clone()
                                             });
-                                        let indicator = choice_selection_indicator(
-                                            this.multiple,
-                                            is_selected_for_ui,
-                                        );
+                                        let leading = if this.multiple {
+                                            Some(LeadingContent::Emoji(
+                                                choice_selection_indicator(true, is_selected)
+                                                    .into(),
+                                            ))
+                                        } else {
+                                            Some(leading_content_from_icon_kind(
+                                                icon_kind_from_choice(choice),
+                                            ))
+                                        };
                                         let subtitle = indexed_choice
                                             .metadata
                                             .subtitle_text()
@@ -185,34 +278,60 @@
                                                     ))
                                                 },
                                             );
+                                        let row_bg = if is_focused {
+                                            focused_row_bg
+                                        } else if is_hovered {
+                                            hovered_row_bg
+                                        } else {
+                                            rgba(0x00000000)
+                                        };
+                                        let hover_handler = cx.listener(
+                                            move |this: &mut SelectPrompt,
+                                                  hovered: &bool,
+                                                  _window,
+                                                  cx| {
+                                                if *hovered {
+                                                    if this.hovered_index != Some(display_idx) {
+                                                        this.hovered_index = Some(display_idx);
+                                                        cx.notify();
+                                                    }
+                                                } else if this.hovered_index == Some(display_idx) {
+                                                    this.hovered_index = None;
+                                                    cx.notify();
+                                                }
+                                            },
+                                        );
+
+                                        let mut row = div()
+                                            .id(display_idx)
+                                            .w_full()
+                                            .h(px(LIST_ITEM_HEIGHT))
+                                            .rounded(px(8.0))
+                                            .bg(row_bg)
+                                            .cursor_pointer()
+                                            .on_hover(hover_handler)
+                                            .child(
+                                                UnifiedListItem::new(
+                                                    gpui::ElementId::Name(semantic_id.into()),
+                                                    title,
+                                                )
+                                                .subtitle_opt(subtitle)
+                                                .leading_opt(leading)
+                                                .trailing_opt(trailing)
+                                                .state(ItemState {
+                                                    is_selected,
+                                                    is_hovered,
+                                                    is_disabled: false,
+                                                })
+                                                .density(Density::Comfortable)
+                                                .colors(item_colors),
+                                            );
+
+                                        if !is_focused {
+                                            row = row.hover(move |s| s.bg(hovered_row_bg));
+                                        }
 
-                                        rows.push(
-                                            div()
-                                                .id(display_idx)
-                                                .w_full()
-                                                .h(px(LIST_ITEM_HEIGHT))
-                                                .border_b_1()
-                                                .border_color(border_color)
-                                                .child(
-                                                    UnifiedListItem::new(
-                                                        gpui::ElementId::Name(semantic_id.into()),
-                                                        title,
-                                                    )
-                                                    .subtitle_opt(subtitle)
-                                                    .leading(LeadingContent::Emoji(
-                                                        indicator.into(),
-                                                    ))
-                                                    .trailing_opt(trailing)
-                                                    .state(ItemState {
-                                                        is_selected: is_focused,
-                                                        is_hovered: false,
-                                                        is_disabled: false,
-                                                    })
-                                                    .density(Density::Comfortable)
-                                                    .colors(row_colors)
-                                                    .with_accent_bar(is_selected_for_ui),
-                                                ),
-                                        );
+                                        rows.push(row);
                                     }
                                 }
                             }
@@ -234,6 +353,7 @@
             .flex_col()
             .flex_1()
             .w_full()
+            .px(px(8.0))
             .child(choices_content);
 
         div()
diff --git a/src/prompts/select/tests.rs b/src/prompts/select/tests.rs
index 250ec9d63282ad81dd952efa12855f784330232c..2b048753d5f168dcbc59ccb0e399e4604bc39167
--- a/src/prompts/select/tests.rs
+++ b/src/prompts/select/tests.rs
@@ -184,3 +184,36 @@
         0x445566
     );
 }
+
+#[test]
+fn test_select_prompt_extracts_icon_hint_from_choice_metadata() {
+    let description = Some("Shortcut: cmd+k ‚Ä¢ icon: terminal ‚Ä¢ script");
+    assert_eq!(
+        render::extract_choice_icon_hint(description),
+        Some("terminal")
+    );
+}
+
+#[test]
+fn test_select_prompt_icon_kind_falls_back_to_code_icon_without_hint() {
+    let choice = choice("Deploy API", "/Users/me/.scriptkit/scripts/deploy.ts", None);
+
+    match render::icon_kind_from_choice(&choice) {
+        IconKind::Svg(name) => assert_eq!(name, "Code"),
+        _ => panic!("expected fallback Code SVG icon"),
+    }
+}
+
+#[test]
+fn test_select_prompt_compute_row_state_keeps_focus_and_selection_independent() {
+    let selected = std::collections::HashSet::from([5]);
+    let focused_but_unselected = render::compute_row_state(2, 2, 1, &selected, Some(1));
+    assert!(focused_but_unselected.is_focused);
+    assert!(!focused_but_unselected.is_selected);
+    assert!(!focused_but_unselected.is_hovered);
+
+    let selected_but_unfocused = render::compute_row_state(1, 2, 5, &selected, Some(1));
+    assert!(!selected_but_unfocused.is_focused);
+    assert!(selected_but_unfocused.is_selected);
+    assert!(selected_but_unfocused.is_hovered);
+}

file update:
diff --git a/src/list_item/part_000.rs b/src/list_item/part_000.rs
index 733d4ac2aa5b1b27b29a5999310e6f3f45cc54c3..283b2263d56a92c73c22d44443db7b40971d26ce
--- a/src/list_item/part_000.rs
+++ b/src/list_item/part_000.rs
@@ -15,6 +15,37 @@
     /// Maps to IconName from designs::icon_variations
     Svg(String),
 }
+
+impl IconKind {
+    /// Resolve icon metadata into an IconKind for list rendering.
+    ///
+    /// Supports:
+    /// - Known SVG names/aliases via `icon_name_from_str` (e.g., "Terminal", "file-code")
+    /// - Emoji/symbol glyphs (e.g., "üìÑ", "‚ö°")
+    pub fn from_icon_hint(icon_hint: &str) -> Option<Self> {
+        let trimmed = icon_hint.trim();
+        if trimmed.is_empty() {
+            return None;
+        }
+
+        if icon_name_from_str(trimmed).is_some() {
+            return Some(Self::Svg(trimmed.to_string()));
+        }
+
+        if looks_like_symbol_icon_hint(trimmed) {
+            return Some(Self::Emoji(trimmed.to_string()));
+        }
+
+        None
+    }
+}
+
+fn looks_like_symbol_icon_hint(icon_hint: &str) -> bool {
+    let has_ascii_alnum = icon_hint.chars().any(|ch| ch.is_ascii_alphanumeric());
+    let char_count = icon_hint.chars().count();
+
+    !has_ascii_alnum && char_count <= 4
+}
 /// Fixed height for list items used in uniform-height virtualized lists.
 ///
 /// IMPORTANT: When using GPUI `uniform_list`, the item closure must render
@@ -437,3 +468,29 @@
     /// Text color for content displayed on accent/warning backgrounds
     pub text_on_accent: u32,
 }
+
+#[cfg(test)]
+mod icon_kind_tests {
+    use super::IconKind;
+
+    #[test]
+    fn test_icon_kind_from_icon_hint_returns_svg_when_known_icon_name() {
+        match IconKind::from_icon_hint("terminal") {
+            Some(IconKind::Svg(name)) => assert_eq!(name, "terminal"),
+            _ => panic!("expected SVG icon from known icon hint"),
+        }
+    }
+
+    #[test]
+    fn test_icon_kind_from_icon_hint_returns_emoji_when_symbol_glyph() {
+        match IconKind::from_icon_hint("üìÑ") {
+            Some(IconKind::Emoji(emoji)) => assert_eq!(emoji, "üìÑ"),
+            _ => panic!("expected emoji icon for symbol glyph"),
+        }
+    }
+
+    #[test]
+    fn test_icon_kind_from_icon_hint_returns_none_for_unknown_ascii_word() {
+        assert!(IconKind::from_icon_hint("unknown-icon-name").is_none());
+    }
+}
diff --git a/src/prompts/select/mod.rs b/src/prompts/select/mod.rs
index b6366dabfb14f3fae09f854f9de824fa629e0a3b..80287d57d8b538dba0d85476dc6de3aa3409a2fd
--- a/src/prompts/select/mod.rs
+++ b/src/prompts/select/mod.rs
@@ -7,8 +7,8 @@
 //! - Submit selected items
 
 use gpui::{
-    div, prelude::*, px, rgb, uniform_list, AnyElement, Context, FocusHandle, Focusable, Render,
-    ScrollStrategy, SharedString, UniformListScrollHandle, Window,
+    div, prelude::*, px, rgb, rgba, uniform_list, AnyElement, Context, FocusHandle, Focusable,
+    Render, ScrollStrategy, SharedString, UniformListScrollHandle, Window,
 };
 use std::collections::HashSet;
 use std::ops::Range;
@@ -19,7 +19,7 @@
     UnifiedListItemColors,
 };
 use crate::designs::{get_tokens, DesignColors, DesignVariant};
-use crate::list_item::LIST_ITEM_HEIGHT;
+use crate::list_item::{IconKind, LIST_ITEM_HEIGHT};
 use crate::logging;
 use crate::panel::PROMPT_INPUT_FIELD_HEIGHT;
 use crate::protocol::{generate_semantic_id, Choice};
diff --git a/src/prompts/select/prompt.rs b/src/prompts/select/prompt.rs
index c5f98f5318f5b520e9223811f735e866ee06e7fb..5ba2de479b2f5680a73db72642377f68d26ee54e
--- a/src/prompts/select/prompt.rs
+++ b/src/prompts/select/prompt.rs
@@ -19,6 +19,8 @@
     pub filtered_choices: Vec<usize>,
     /// Currently focused index in filtered list
     pub focused_index: usize,
+    /// Currently hovered index in filtered list
+    pub hovered_index: Option<usize>,
     /// Filter text
     pub filter_text: String,
     /// Whether multiple selection is allowed
@@ -68,6 +70,7 @@
             selected: HashSet::new(),
             filtered_choices,
             focused_index: 0,
+            hovered_index: None,
             filter_text: String::new(),
             multiple,
             focus_handle,
@@ -84,6 +87,7 @@
         if trimmed_filter.is_empty() {
             self.filtered_choices = (0..self.choices.len()).collect();
             self.focused_index = 0;
+            self.hovered_index = None;
             return;
         }
 
@@ -109,6 +113,7 @@
 
         self.filtered_choices = scored_matches.into_iter().map(|(idx, _)| idx).collect();
         self.focused_index = 0;
+        self.hovered_index = None;
     }
 
     /// Set the filter text programmatically
@@ -168,6 +173,7 @@
     pub(super) fn move_up(&mut self, cx: &mut Context<Self>) {
         if self.focused_index > 0 {
             self.focused_index -= 1;
+            self.hovered_index = None;
             self.list_scroll_handle
                 .scroll_to_item(self.focused_index, ScrollStrategy::Nearest);
             cx.notify();
@@ -178,6 +184,7 @@
     pub(super) fn move_down(&mut self, cx: &mut Context<Self>) {
         if self.focused_index < self.filtered_choices.len().saturating_sub(1) {
             self.focused_index += 1;
+            self.hovered_index = None;
             self.list_scroll_handle
                 .scroll_to_item(self.focused_index, ScrollStrategy::Nearest);
             cx.notify();
diff --git a/src/prompts/select/render.rs b/src/prompts/select/render.rs
index 62109896c9c14b1b2fbf5b4d25d5d94e4388e4aa..e224ca641be966e7357474d1892f16fb9d59f392
--- a/src/prompts/select/render.rs
+++ b/src/prompts/select/render.rs
@@ -1,5 +1,78 @@
 use super::*;
 
+const ROW_FOCUSED_BG_ALPHA: u32 = 0x3A;
+const ROW_HOVER_BG_ALPHA: u32 = 0x26;
+
+#[derive(Clone, Copy, Debug, PartialEq, Eq)]
+pub(super) struct SelectRowState {
+    pub is_focused: bool,
+    pub is_selected: bool,
+    pub is_hovered: bool,
+}
+
+pub(super) fn compute_row_state(
+    display_idx: usize,
+    focused_index: usize,
+    choice_idx: usize,
+    selected: &HashSet<usize>,
+    hovered_index: Option<usize>,
+) -> SelectRowState {
+    SelectRowState {
+        is_focused: display_idx == focused_index,
+        is_selected: selected.contains(&choice_idx),
+        is_hovered: hovered_index == Some(display_idx),
+    }
+}
+
+pub(super) fn extract_choice_icon_hint(description: Option<&str>) -> Option<&str> {
+    description.and_then(|raw| {
+        raw.split(['‚Ä¢', '|', '\n'])
+            .map(str::trim)
+            .find_map(|token| {
+                let token_lower = token.to_ascii_lowercase();
+                if token_lower == "icon"
+                    || token_lower.starts_with("icon:")
+                    || token_lower.starts_with("icon=")
+                    || token_lower.starts_with("icon ")
+                {
+                    token
+                        .split_once(':')
+                        .or_else(|| token.split_once('='))
+                        .map(|(_, value)| value.trim())
+                        .or_else(|| token.split_whitespace().nth(1))
+                } else {
+                    None
+                }
+            })
+            .filter(|value| !value.is_empty())
+    })
+}
+
+pub(super) fn icon_kind_from_choice(choice: &Choice) -> IconKind {
+    let metadata_icon =
+        extract_choice_icon_hint(choice.description.as_deref()).and_then(IconKind::from_icon_hint);
+    let name_prefix_icon = choice
+        .name
+        .split_whitespace()
+        .next()
+        .and_then(IconKind::from_icon_hint);
+
+    metadata_icon
+        .or(name_prefix_icon)
+        .unwrap_or_else(|| IconKind::Svg("Code".to_string()))
+}
+
+fn leading_content_from_icon_kind(icon_kind: IconKind) -> LeadingContent {
+    match icon_kind {
+        IconKind::Emoji(emoji) => LeadingContent::Emoji(emoji.into()),
+        IconKind::Image(render_image) => LeadingContent::AppIcon(render_image),
+        IconKind::Svg(name) => LeadingContent::Icon {
+            name: SharedString::from(name),
+            color: None,
+        },
+    }
+}
+
 impl Focusable for SelectPrompt {
     fn focus_handle(&self, _cx: &gpui::App) -> FocusHandle {
         self.focus_handle.clone()
@@ -76,6 +149,13 @@
             self.design_variant,
             &colors,
         ));
+        let row_accent_color = if self.design_variant == DesignVariant::Default {
+            self.theme.colors.accent.selected
+        } else {
+            colors.accent
+        };
+        let focused_row_bg = rgba((row_accent_color << 8) | ROW_FOCUSED_BG_ALPHA);
+        let hovered_row_bg = rgba((row_accent_color << 8) | ROW_HOVER_BG_ALPHA);
 
         let placeholder = self
             .placeholder
@@ -145,8 +225,12 @@
                     move |this: &mut SelectPrompt,
                           visible_range: std::ops::Range<usize>,
                           _window,
-                          _cx| {
-                        let row_colors = UnifiedListItemColors::from_theme(&this.theme);
+                          cx| {
+                        let item_colors = UnifiedListItemColors {
+                            selected_opacity: 0.0,
+                            hover_opacity: 0.0,
+                            ..UnifiedListItemColors::from_theme(&this.theme)
+                        };
                         let mut rows = Vec::with_capacity(visible_range.len());
 
                         for display_idx in visible_range {
@@ -154,21 +238,30 @@
                                 if let Some(choice) = this.choices.get(choice_idx) {
                                     if let Some(indexed_choice) = this.choice_index.get(choice_idx)
                                     {
-                                        let is_focused = display_idx == this.focused_index;
-                                        let is_selected = this.selected.contains(&choice_idx);
-                                        let is_selected_for_ui = if this.multiple {
-                                            is_selected
-                                        } else {
-                                            is_focused
-                                        };
+                                        let row_state = compute_row_state(
+                                            display_idx,
+                                            this.focused_index,
+                                            choice_idx,
+                                            &this.selected,
+                                            this.hovered_index,
+                                        );
+                                        let is_focused = row_state.is_focused;
+                                        let is_selected = row_state.is_selected;
+                                        let is_hovered = row_state.is_hovered;
                                         let semantic_id =
                                             choice.semantic_id.clone().unwrap_or_else(|| {
                                                 indexed_choice.stable_semantic_id.clone()
                                             });
-                                        let indicator = choice_selection_indicator(
-                                            this.multiple,
-                                            is_selected_for_ui,
-                                        );
+                                        let leading = if this.multiple {
+                                            Some(LeadingContent::Emoji(
+                                                choice_selection_indicator(true, is_selected)
+                                                    .into(),
+                                            ))
+                                        } else {
+                                            Some(leading_content_from_icon_kind(
+                                                icon_kind_from_choice(choice),
+                                            ))
+                                        };
                                         let subtitle = indexed_choice
                                             .metadata
                                             .subtitle_text()
@@ -185,34 +278,60 @@
                                                     ))
                                                 },
                                             );
+                                        let row_bg = if is_focused {
+                                            focused_row_bg
+                                        } else if is_hovered {
+                                            hovered_row_bg
+                                        } else {
+                                            rgba(0x00000000)
+                                        };
+                                        let hover_handler = cx.listener(
+                                            move |this: &mut SelectPrompt,
+                                                  hovered: &bool,
+                                                  _window,
+                                                  cx| {
+                                                if *hovered {
+                                                    if this.hovered_index != Some(display_idx) {
+                                                        this.hovered_index = Some(display_idx);
+                                                        cx.notify();
+                                                    }
+                                                } else if this.hovered_index == Some(display_idx) {
+                                                    this.hovered_index = None;
+                                                    cx.notify();
+                                                }
+                                            },
+                                        );
+
+                                        let mut row = div()
+                                            .id(display_idx)
+                                            .w_full()
+                                            .h(px(LIST_ITEM_HEIGHT))
+                                            .rounded(px(8.0))
+                                            .bg(row_bg)
+                                            .cursor_pointer()
+                                            .on_hover(hover_handler)
+                                            .child(
+                                                UnifiedListItem::new(
+                                                    gpui::ElementId::Name(semantic_id.into()),
+                                                    title,
+                                                )
+                                                .subtitle_opt(subtitle)
+                                                .leading_opt(leading)
+                                                .trailing_opt(trailing)
+                                                .state(ItemState {
+                                                    is_selected,
+                                                    is_hovered,
+                                                    is_disabled: false,
+                                                })
+                                                .density(Density::Comfortable)
+                                                .colors(item_colors),
+                                            );
+
+                                        if !is_focused {
+                                            row = row.hover(move |s| s.bg(hovered_row_bg));
+                                        }
 
-                                        rows.push(
-                                            div()
-                                                .id(display_idx)
-                                                .w_full()
-                                                .h(px(LIST_ITEM_HEIGHT))
-                                                .border_b_1()
-                                                .border_color(border_color)
-                                                .child(
-                                                    UnifiedListItem::new(
-                                                        gpui::ElementId::Name(semantic_id.into()),
-                                                        title,
-                                                    )
-                                                    .subtitle_opt(subtitle)
-                                                    .leading(LeadingContent::Emoji(
-                                                        indicator.into(),
-                                                    ))
-                                                    .trailing_opt(trailing)
-                                                    .state(ItemState {
-                                                        is_selected: is_focused,
-                                                        is_hovered: false,
-                                                        is_disabled: false,
-                                                    })
-                                                    .density(Density::Comfortable)
-                                                    .colors(row_colors)
-                                                    .with_accent_bar(is_selected_for_ui),
-                                                ),
-                                        );
+                                        rows.push(row);
                                     }
                                 }
                             }
@@ -234,6 +353,7 @@
             .flex_col()
             .flex_1()
             .w_full()
+            .px(px(8.0))
             .child(choices_content);
 
         div()
diff --git a/src/prompts/select/tests.rs b/src/prompts/select/tests.rs
index 250ec9d63282ad81dd952efa12855f784330232c..2b048753d5f168dcbc59ccb0e399e4604bc39167
--- a/src/prompts/select/tests.rs
+++ b/src/prompts/select/tests.rs
@@ -184,3 +184,36 @@
         0x445566
     );
 }
+
+#[test]
+fn test_select_prompt_extracts_icon_hint_from_choice_metadata() {
+    let description = Some("Shortcut: cmd+k ‚Ä¢ icon: terminal ‚Ä¢ script");
+    assert_eq!(
+        render::extract_choice_icon_hint(description),
+        Some("terminal")
+    );
+}
+
+#[test]
+fn test_select_prompt_icon_kind_falls_back_to_code_icon_without_hint() {
+    let choice = choice("Deploy API", "/Users/me/.scriptkit/scripts/deploy.ts", None);
+
+    match render::icon_kind_from_choice(&choice) {
+        IconKind::Svg(name) => assert_eq!(name, "Code"),
+        _ => panic!("expected fallback Code SVG icon"),
+    }
+}
+
+#[test]
+fn test_select_prompt_compute_row_state_keeps_focus_and_selection_independent() {
+    let selected = std::collections::HashSet::from([5]);
+    let focused_but_unselected = render::compute_row_state(2, 2, 1, &selected, Some(1));
+    assert!(focused_but_unselected.is_focused);
+    assert!(!focused_but_unselected.is_selected);
+    assert!(!focused_but_unselected.is_hovered);
+
+    let selected_but_unfocused = render::compute_row_state(1, 2, 5, &selected, Some(1));
+    assert!(!selected_but_unfocused.is_focused);
+    assert!(selected_but_unfocused.is_selected);
+    assert!(selected_but_unfocused.is_hovered);
+}

file update:
diff --git a/src/list_item/part_000.rs b/src/list_item/part_000.rs
index 733d4ac2aa5b1b27b29a5999310e6f3f45cc54c3..283b2263d56a92c73c22d44443db7b40971d26ce
--- a/src/list_item/part_000.rs
+++ b/src/list_item/part_000.rs
@@ -15,6 +15,37 @@
     /// Maps to IconName from designs::icon_variations
     Svg(String),
 }
+
+impl IconKind {
+    /// Resolve icon metadata into an IconKind for list rendering.
+    ///
+    /// Supports:
+    /// - Known SVG names/aliases via `icon_name_from_str` (e.g., "Terminal", "file-code")
+    /// - Emoji/symbol glyphs (e.g., "üìÑ", "‚ö°")
+    pub fn from_icon_hint(icon_hint: &str) -> Option<Self> {
+        let trimmed = icon_hint.trim();
+        if trimmed.is_empty() {
+            return None;
+        }
+
+        if icon_name_from_str(trimmed).is_some() {
+            return Some(Self::Svg(trimmed.to_string()));
+        }
+
+        if looks_like_symbol_icon_hint(trimmed) {
+            return Some(Self::Emoji(trimmed.to_string()));
+        }
+
+        None
+    }
+}
+
+fn looks_like_symbol_icon_hint(icon_hint: &str) -> bool {
+    let has_ascii_alnum = icon_hint.chars().any(|ch| ch.is_ascii_alphanumeric());
+    let char_count = icon_hint.chars().count();
+
+    !has_ascii_alnum && char_count <= 4
+}
 /// Fixed height for list items used in uniform-height virtualized lists.
 ///
 /// IMPORTANT: When using GPUI `uniform_list`, the item closure must render
@@ -437,3 +468,29 @@
     /// Text color for content displayed on accent/warning backgrounds
     pub text_on_accent: u32,
 }
+
+#[cfg(test)]
+mod icon_kind_tests {
+    use super::IconKind;
+
+    #[test]
+    fn test_icon_kind_from_icon_hint_returns_svg_when_known_icon_name() {
+        match IconKind::from_icon_hint("terminal") {
+            Some(IconKind::Svg(name)) => assert_eq!(name, "terminal"),
+            _ => panic!("expected SVG icon from known icon hint"),
+        }
+    }
+
+    #[test]
+    fn test_icon_kind_from_icon_hint_returns_emoji_when_symbol_glyph() {
+        match IconKind::from_icon_hint("üìÑ") {
+            Some(IconKind::Emoji(emoji)) => assert_eq!(emoji, "üìÑ"),
+            _ => panic!("expected emoji icon for symbol glyph"),
+        }
+    }
+
+    #[test]
+    fn test_icon_kind_from_icon_hint_returns_none_for_unknown_ascii_word() {
+        assert!(IconKind::from_icon_hint("unknown-icon-name").is_none());
+    }
+}
diff --git a/src/prompts/select/mod.rs b/src/prompts/select/mod.rs
index b6366dabfb14f3fae09f854f9de824fa629e0a3b..80287d57d8b538dba0d85476dc6de3aa3409a2fd
--- a/src/prompts/select/mod.rs
+++ b/src/prompts/select/mod.rs
@@ -7,8 +7,8 @@
 //! - Submit selected items
 
 use gpui::{
-    div, prelude::*, px, rgb, uniform_list, AnyElement, Context, FocusHandle, Focusable, Render,
-    ScrollStrategy, SharedString, UniformListScrollHandle, Window,
+    div, prelude::*, px, rgb, rgba, uniform_list, AnyElement, Context, FocusHandle, Focusable,
+    Render, ScrollStrategy, SharedString, UniformListScrollHandle, Window,
 };
 use std::collections::HashSet;
 use std::ops::Range;
@@ -19,7 +19,7 @@
     UnifiedListItemColors,
 };
 use crate::designs::{get_tokens, DesignColors, DesignVariant};
-use crate::list_item::LIST_ITEM_HEIGHT;
+use crate::list_item::{IconKind, LIST_ITEM_HEIGHT};
 use crate::logging;
 use crate::panel::PROMPT_INPUT_FIELD_HEIGHT;
 use crate::protocol::{generate_semantic_id, Choice};
diff --git a/src/prompts/select/prompt.rs b/src/prompts/select/prompt.rs
index c5f98f5318f5b520e9223811f735e866ee06e7fb..5ba2de479b2f5680a73db72642377f68d26ee54e
--- a/src/prompts/select/prompt.rs
+++ b/src/prompts/select/prompt.rs
@@ -19,6 +19,8 @@
     pub filtered_choices: Vec<usize>,
     /// Currently focused index in filtered list
     pub focused_index: usize,
+    /// Currently hovered index in filtered list
+    pub hovered_index: Option<usize>,
     /// Filter text
     pub filter_text: String,
     /// Whether multiple selection is allowed
@@ -68,6 +70,7 @@
             selected: HashSet::new(),
             filtered_choices,
             focused_index: 0,
+            hovered_index: None,
             filter_text: String::new(),
             multiple,
             focus_handle,
@@ -84,6 +87,7 @@
         if trimmed_filter.is_empty() {
             self.filtered_choices = (0..self.choices.len()).collect();
             self.focused_index = 0;
+            self.hovered_index = None;
             return;
         }
 
@@ -109,6 +113,7 @@
 
         self.filtered_choices = scored_matches.into_iter().map(|(idx, _)| idx).collect();
         self.focused_index = 0;
+        self.hovered_index = None;
     }
 
     /// Set the filter text programmatically
@@ -168,6 +173,7 @@
     pub(super) fn move_up(&mut self, cx: &mut Context<Self>) {
         if self.focused_index > 0 {
             self.focused_index -= 1;
+            self.hovered_index = None;
             self.list_scroll_handle
                 .scroll_to_item(self.focused_index, ScrollStrategy::Nearest);
             cx.notify();
@@ -178,6 +184,7 @@
     pub(super) fn move_down(&mut self, cx: &mut Context<Self>) {
         if self.focused_index < self.filtered_choices.len().saturating_sub(1) {
             self.focused_index += 1;
+            self.hovered_index = None;
             self.list_scroll_handle
                 .scroll_to_item(self.focused_index, ScrollStrategy::Nearest);
             cx.notify();
diff --git a/src/prompts/select/render.rs b/src/prompts/select/render.rs
index 62109896c9c14b1b2fbf5b4d25d5d94e4388e4aa..e224ca641be966e7357474d1892f16fb9d59f392
--- a/src/prompts/select/render.rs
+++ b/src/prompts/select/render.rs
@@ -1,5 +1,78 @@
 use super::*;
 
+const ROW_FOCUSED_BG_ALPHA: u32 = 0x3A;
+const ROW_HOVER_BG_ALPHA: u32 = 0x26;
+
+#[derive(Clone, Copy, Debug, PartialEq, Eq)]
+pub(super) struct SelectRowState {
+    pub is_focused: bool,
+    pub is_selected: bool,
+    pub is_hovered: bool,
+}
+
+pub(super) fn compute_row_state(
+    display_idx: usize,
+    focused_index: usize,
+    choice_idx: usize,
+    selected: &HashSet<usize>,
+    hovered_index: Option<usize>,
+) -> SelectRowState {
+    SelectRowState {
+        is_focused: display_idx == focused_index,
+        is_selected: selected.contains(&choice_idx),
+        is_hovered: hovered_index == Some(display_idx),
+    }
+}
+
+pub(super) fn extract_choice_icon_hint(description: Option<&str>) -> Option<&str> {
+    description.and_then(|raw| {
+        raw.split(['‚Ä¢', '|', '\n'])
+            .map(str::trim)
+            .find_map(|token| {
+                let token_lower = token.to_ascii_lowercase();
+                if token_lower == "icon"
+                    || token_lower.starts_with("icon:")
+                    || token_lower.starts_with("icon=")
+                    || token_lower.starts_with("icon ")
+                {
+                    token
+                        .split_once(':')
+                        .or_else(|| token.split_once('='))
+                        .map(|(_, value)| value.trim())
+                        .or_else(|| token.split_whitespace().nth(1))
+                } else {
+                    None
+                }
+            })
+            .filter(|value| !value.is_empty())
+    })
+}
+
+pub(super) fn icon_kind_from_choice(choice: &Choice) -> IconKind {
+    let metadata_icon =
+        extract_choice_icon_hint(choice.description.as_deref()).and_then(IconKind::from_icon_hint);
+    let name_prefix_icon = choice
+        .name
+        .split_whitespace()
+        .next()
+        .and_then(IconKind::from_icon_hint);
+
+    metadata_icon
+        .or(name_prefix_icon)
+        .unwrap_or_else(|| IconKind::Svg("Code".to_string()))
+}
+
+fn leading_content_from_icon_kind(icon_kind: IconKind) -> LeadingContent {
+    match icon_kind {
+        IconKind::Emoji(emoji) => LeadingContent::Emoji(emoji.into()),
+        IconKind::Image(render_image) => LeadingContent::AppIcon(render_image),
+        IconKind::Svg(name) => LeadingContent::Icon {
+            name: SharedString::from(name),
+            color: None,
+        },
+    }
+}
+
 impl Focusable for SelectPrompt {
     fn focus_handle(&self, _cx: &gpui::App) -> FocusHandle {
         self.focus_handle.clone()
@@ -76,6 +149,13 @@
             self.design_variant,
             &colors,
         ));
+        let row_accent_color = if self.design_variant == DesignVariant::Default {
+            self.theme.colors.accent.selected
+        } else {
+            colors.accent
+        };
+        let focused_row_bg = rgba((row_accent_color << 8) | ROW_FOCUSED_BG_ALPHA);
+        let hovered_row_bg = rgba((row_accent_color << 8) | ROW_HOVER_BG_ALPHA);
 
         let placeholder = self
             .placeholder
@@ -145,8 +225,12 @@
                     move |this: &mut SelectPrompt,
                           visible_range: std::ops::Range<usize>,
                           _window,
-                          _cx| {
-                        let row_colors = UnifiedListItemColors::from_theme(&this.theme);
+                          cx| {
+                        let item_colors = UnifiedListItemColors {
+                            selected_opacity: 0.0,
+                            hover_opacity: 0.0,
+                            ..UnifiedListItemColors::from_theme(&this.theme)
+                        };
                         let mut rows = Vec::with_capacity(visible_range.len());
 
                         for display_idx in visible_range {
@@ -154,21 +238,30 @@
                                 if let Some(choice) = this.choices.get(choice_idx) {
                                     if let Some(indexed_choice) = this.choice_index.get(choice_idx)
                                     {
-                                        let is_focused = display_idx == this.focused_index;
-                                        let is_selected = this.selected.contains(&choice_idx);
-                                        let is_selected_for_ui = if this.multiple {
-                                            is_selected
-                                        } else {
-                                            is_focused
-                                        };
+                                        let row_state = compute_row_state(
+                                            display_idx,
+                                            this.focused_index,
+                                            choice_idx,
+                                            &this.selected,
+                                            this.hovered_index,
+                                        );
+                                        let is_focused = row_state.is_focused;
+                                        let is_selected = row_state.is_selected;
+                                        let is_hovered = row_state.is_hovered;
                                         let semantic_id =
                                             choice.semantic_id.clone().unwrap_or_else(|| {
                                                 indexed_choice.stable_semantic_id.clone()
                                             });
-                                        let indicator = choice_selection_indicator(
-                                            this.multiple,
-                                            is_selected_for_ui,
-                                        );
+                                        let leading = if this.multiple {
+                                            Some(LeadingContent::Emoji(
+                                                choice_selection_indicator(true, is_selected)
+                                                    .into(),
+                                            ))
+                                        } else {
+                                            Some(leading_content_from_icon_kind(
+                                                icon_kind_from_choice(choice),
+                                            ))
+                                        };
                                         let subtitle = indexed_choice
                                             .metadata
                                             .subtitle_text()
@@ -185,34 +278,60 @@
                                                     ))
                                                 },
                                             );
+                                        let row_bg = if is_focused {
+                                            focused_row_bg
+                                        } else if is_hovered {
+                                            hovered_row_bg
+                                        } else {
+                                            rgba(0x00000000)
+                                        };
+                                        let hover_handler = cx.listener(
+                                            move |this: &mut SelectPrompt,
+                                                  hovered: &bool,
+                                                  _window,
+                                                  cx| {
+                                                if *hovered {
+                                                    if this.hovered_index != Some(display_idx) {
+                                                        this.hovered_index = Some(display_idx);
+                                                        cx.notify();
+                                                    }
+                                                } else if this.hovered_index == Some(display_idx) {
+                                                    this.hovered_index = None;
+                                                    cx.notify();
+                                                }
+                                            },
+                                        );
+
+                                        let mut row = div()
+                                            .id(display_idx)
+                                            .w_full()
+                                            .h(px(LIST_ITEM_HEIGHT))
+                                            .rounded(px(8.0))
+                                            .bg(row_bg)
+                                            .cursor_pointer()
+                                            .on_hover(hover_handler)
+                                            .child(
+                                                UnifiedListItem::new(
+                                                    gpui::ElementId::Name(semantic_id.into()),
+                                                    title,
+                                                )
+                                                .subtitle_opt(subtitle)
+                                                .leading_opt(leading)
+                                                .trailing_opt(trailing)
+                                                .state(ItemState {
+                                                    is_selected,
+                                                    is_hovered,
+                                                    is_disabled: false,
+                                                })
+                                                .density(Density::Comfortable)
+                                                .colors(item_colors),
+                                            );
+
+                                        if !is_focused {
+                                            row = row.hover(move |s| s.bg(hovered_row_bg));
+                                        }
 
-                                        rows.push(
-                                            div()
-                                                .id(display_idx)
-                                                .w_full()
-                                                .h(px(LIST_ITEM_HEIGHT))
-                                                .border_b_1()
-                                                .border_color(border_color)
-                                                .child(
-                                                    UnifiedListItem::new(
-                                                        gpui::ElementId::Name(semantic_id.into()),
-                                                        title,
-                                                    )
-                                                    .subtitle_opt(subtitle)
-                                                    .leading(LeadingContent::Emoji(
-                                                        indicator.into(),
-                                                    ))
-                                                    .trailing_opt(trailing)
-                                                    .state(ItemState {
-                                                        is_selected: is_focused,
-                                                        is_hovered: false,
-                                                        is_disabled: false,
-                                                    })
-                                                    .density(Density::Comfortable)
-                                                    .colors(row_colors)
-                                                    .with_accent_bar(is_selected_for_ui),
-                                                ),
-                                        );
+                                        rows.push(row);
                                     }
                                 }
                             }
@@ -234,6 +353,7 @@
             .flex_col()
             .flex_1()
             .w_full()
+            .px(px(8.0))
             .child(choices_content);
 
         div()
diff --git a/src/prompts/select/tests.rs b/src/prompts/select/tests.rs
index 250ec9d63282ad81dd952efa12855f784330232c..2b048753d5f168dcbc59ccb0e399e4604bc39167
--- a/src/prompts/select/tests.rs
+++ b/src/prompts/select/tests.rs
@@ -184,3 +184,36 @@
         0x445566
     );
 }
+
+#[test]
+fn test_select_prompt_extracts_icon_hint_from_choice_metadata() {
+    let description = Some("Shortcut: cmd+k ‚Ä¢ icon: terminal ‚Ä¢ script");
+    assert_eq!(
+        render::extract_choice_icon_hint(description),
+        Some("terminal")
+    );
+}
+
+#[test]
+fn test_select_prompt_icon_kind_falls_back_to_code_icon_without_hint() {
+    let choice = choice("Deploy API", "/Users/me/.scriptkit/scripts/deploy.ts", None);
+
+    match render::icon_kind_from_choice(&choice) {
+        IconKind::Svg(name) => assert_eq!(name, "Code"),
+        _ => panic!("expected fallback Code SVG icon"),
+    }
+}
+
+#[test]
+fn test_select_prompt_compute_row_state_keeps_focus_and_selection_independent() {
+    let selected = std::collections::HashSet::from([5]);
+    let focused_but_unselected = render::compute_row_state(2, 2, 1, &selected, Some(1));
+    assert!(focused_but_unselected.is_focused);
+    assert!(!focused_but_unselected.is_selected);
+    assert!(!focused_but_unselected.is_hovered);
+
+    let selected_but_unfocused = render::compute_row_state(1, 2, 5, &selected, Some(1));
+    assert!(!selected_but_unfocused.is_focused);
+    assert!(selected_but_unfocused.is_selected);
+    assert!(selected_but_unfocused.is_hovered);
+}

 exited 101 in 12.64s:
    Checking script-kit-gpui v0.1.0 (/Users/johnlindquist/dev/script-kit-gpui)
error[E0603]: constant `ALPHA_SEPARATOR` is private
   --> src/app_render/group_header_item.rs:70:75
    |
 70 |     let divider_color = rgba((colors.text_muted << 8) | crate::list_item::ALPHA_SEPARATOR);
    |                                                                           ^^^^^^^^^^^^^^^ private constant
    |
note: the constant `ALPHA_SEPARATOR` is defined here
   --> src/list_item/part_000.rs:192:1
    |
192 | const ALPHA_SEPARATOR: u32 = 0x14;
    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

error[E0603]: constant `SECTION_PADDING_TOP` is private
   --> src/app_render/group_header_item.rs:77:34
    |
 77 |         .pt(px(crate::list_item::SECTION_PADDING_TOP))
    |                                  ^^^^^^^^^^^^^^^^^^^ private constant
    |
note: the constant `SECTION_PADDING_TOP` is defined here

thinking
**Adjusting build checks to bypass unrelated failures**
codex
The package-wide `cargo check -p` is blocked by unrelated parallel edits in `src/app_render/group_header_item.rs` (private constant visibility), outside this task scope. I‚Äôm switching to narrower verification (`--lib` and targeted tests for select/list_item) so this change set is still validated independently.
exec
/bin/zsh -lc 'cd /Users/johnlindquist/dev/script-kit-gpui && cargo test -p script-kit-gpui --lib test_icon_kind_from_icon_hint_returns_svg_when_known_icon_name test_icon_kind_from_icon_hint_returns_emoji_when_symbol_glyph test_icon_kind_from_icon_hint_returns_none_for_unknown_ascii_word' in /Users/johnlindquist/dev/script-kit-gpuiexec
/bin/zsh -lc 'cd /Users/johnlindquist/dev/script-kit-gpui && cargo test -p script-kit-gpui --lib test_select_prompt_extracts_icon_hint_from_choice_metadata test_select_prompt_icon_kind_falls_back_to_code_icon_without_hint test_select_prompt_compute_row_state_keeps_focus_and_selection_independent' in /Users/johnlindquist/dev/script-kit-gpui exited 1 in 50ms:
error: unexpected argument 'test_icon_kind_from_icon_hint_returns_emoji_when_symbol_glyph' found

Usage: cargo test [OPTIONS] [TESTNAME] [-- [ARGS]...]

For more information, try '--help'.
 exited 1 in 50ms:
error: unexpected argument 'test_select_prompt_icon_kind_falls_back_to_code_icon_without_hint' found

Usage: cargo test [OPTIONS] [TESTNAME] [-- [ARGS]...]

For more information, try '--help'.
exec
/bin/zsh -lc 'cd /Users/johnlindquist/dev/script-kit-gpui && cargo check -p script-kit-gpui --lib' in /Users/johnlindquist/dev/script-kit-gpui succeeded in 237ms:
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.29s
warning: the following packages contain code that will be rejected by a future version of Rust: nom v1.2.4
note: to see what the problems were, use the option `--future-incompat-report`, or run `cargo report future-incompatibilities --id 1`
file update:
diff --git a/src/list_item/part_000.rs b/src/list_item/part_000.rs
index 733d4ac2aa5b1b27b29a5999310e6f3f45cc54c3..283b2263d56a92c73c22d44443db7b40971d26ce
--- a/src/list_item/part_000.rs
+++ b/src/list_item/part_000.rs
@@ -15,6 +15,37 @@
     /// Maps to IconName from designs::icon_variations
     Svg(String),
 }
+
+impl IconKind {
+    /// Resolve icon metadata into an IconKind for list rendering.
+    ///
+    /// Supports:
+    /// - Known SVG names/aliases via `icon_name_from_str` (e.g., "Terminal", "file-code")
+    /// - Emoji/symbol glyphs (e.g., "üìÑ", "‚ö°")
+    pub fn from_icon_hint(icon_hint: &str) -> Option<Self> {
+        let trimmed = icon_hint.trim();
+        if trimmed.is_empty() {
+            return None;
+        }
+
+        if icon_name_from_str(trimmed).is_some() {
+            return Some(Self::Svg(trimmed.to_string()));
+        }
+
+        if looks_like_symbol_icon_hint(trimmed) {
+            return Some(Self::Emoji(trimmed.to_string()));
+        }
+
+        None
+    }
+}
+
+fn looks_like_symbol_icon_hint(icon_hint: &str) -> bool {
+    let has_ascii_alnum = icon_hint.chars().any(|ch| ch.is_ascii_alphanumeric());
+    let char_count = icon_hint.chars().count();
+
+    !has_ascii_alnum && char_count <= 4
+}
 /// Fixed height for list items used in uniform-height virtualized lists.
 ///
 /// IMPORTANT: When using GPUI `uniform_list`, the item closure must render
@@ -437,3 +468,29 @@
     /// Text color for content displayed on accent/warning backgrounds
     pub text_on_accent: u32,
 }
+
+#[cfg(test)]
+mod icon_kind_tests {
+    use super::IconKind;
+
+    #[test]
+    fn test_icon_kind_from_icon_hint_returns_svg_when_known_icon_name() {
+        match IconKind::from_icon_hint("terminal") {
+            Some(IconKind::Svg(name)) => assert_eq!(name, "terminal"),
+            _ => panic!("expected SVG icon from known icon hint"),
+        }
+    }
+
+    #[test]
+    fn test_icon_kind_from_icon_hint_returns_emoji_when_symbol_glyph() {
+        match IconKind::from_icon_hint("üìÑ") {
+            Some(IconKind::Emoji(emoji)) => assert_eq!(emoji, "üìÑ"),
+            _ => panic!("expected emoji icon for symbol glyph"),
+        }
+    }
+
+    #[test]
+    fn test_icon_kind_from_icon_hint_returns_none_for_unknown_ascii_word() {
+        assert!(IconKind::from_icon_hint("unknown-icon-name").is_none());
+    }
+}
diff --git a/src/prompts/select/mod.rs b/src/prompts/select/mod.rs
index b6366dabfb14f3fae09f854f9de824fa629e0a3b..80287d57d8b538dba0d85476dc6de3aa3409a2fd
--- a/src/prompts/select/mod.rs
+++ b/src/prompts/select/mod.rs
@@ -7,8 +7,8 @@
 //! - Submit selected items
 
 use gpui::{
-    div, prelude::*, px, rgb, uniform_list, AnyElement, Context, FocusHandle, Focusable, Render,
-    ScrollStrategy, SharedString, UniformListScrollHandle, Window,
+    div, prelude::*, px, rgb, rgba, uniform_list, AnyElement, Context, FocusHandle, Focusable,
+    Render, ScrollStrategy, SharedString, UniformListScrollHandle, Window,
 };
 use std::collections::HashSet;
 use std::ops::Range;
@@ -19,7 +19,7 @@
     UnifiedListItemColors,
 };
 use crate::designs::{get_tokens, DesignColors, DesignVariant};
-use crate::list_item::LIST_ITEM_HEIGHT;
+use crate::list_item::{IconKind, LIST_ITEM_HEIGHT};
 use crate::logging;
 use crate::panel::PROMPT_INPUT_FIELD_HEIGHT;
 use crate::protocol::{generate_semantic_id, Choice};
diff --git a/src/prompts/select/prompt.rs b/src/prompts/select/prompt.rs
index c5f98f5318f5b520e9223811f735e866ee06e7fb..5ba2de479b2f5680a73db72642377f68d26ee54e
--- a/src/prompts/select/prompt.rs
+++ b/src/prompts/select/prompt.rs
@@ -19,6 +19,8 @@
     pub filtered_choices: Vec<usize>,
     /// Currently focused index in filtered list
     pub focused_index: usize,
+    /// Currently hovered index in filtered list
+    pub hovered_index: Option<usize>,
     /// Filter text
     pub filter_text: String,
     /// Whether multiple selection is allowed
@@ -68,6 +70,7 @@
             selected: HashSet::new(),
             filtered_choices,
             focused_index: 0,
+            hovered_index: None,
             filter_text: String::new(),
             multiple,
             focus_handle,
@@ -84,6 +87,7 @@
         if trimmed_filter.is_empty() {
             self.filtered_choices = (0..self.choices.len()).collect();
             self.focused_index = 0;
+            self.hovered_index = None;
             return;
         }
 
@@ -109,6 +113,7 @@
 
         self.filtered_choices = scored_matches.into_iter().map(|(idx, _)| idx).collect();
         self.focused_index = 0;
+        self.hovered_index = None;
     }
 
     /// Set the filter text programmatically
@@ -168,6 +173,7 @@
     pub(super) fn move_up(&mut self, cx: &mut Context<Self>) {
         if self.focused_index > 0 {
             self.focused_index -= 1;
+            self.hovered_index = None;
             self.list_scroll_handle
                 .scroll_to_item(self.focused_index, ScrollStrategy::Nearest);
             cx.notify();
@@ -178,6 +184,7 @@
     pub(super) fn move_down(&mut self, cx: &mut Context<Self>) {
         if self.focused_index < self.filtered_choices.len().saturating_sub(1) {
             self.focused_index += 1;
+            self.hovered_index = None;
             self.list_scroll_handle
                 .scroll_to_item(self.focused_index, ScrollStrategy::Nearest);
             cx.notify();
diff --git a/src/prompts/select/render.rs b/src/prompts/select/render.rs
index 62109896c9c14b1b2fbf5b4d25d5d94e4388e4aa..e224ca641be966e7357474d1892f16fb9d59f392
--- a/src/prompts/select/render.rs
+++ b/src/prompts/select/render.rs
@@ -1,5 +1,78 @@
 use super::*;
 
+const ROW_FOCUSED_BG_ALPHA: u32 = 0x3A;
+const ROW_HOVER_BG_ALPHA: u32 = 0x26;
+
+#[derive(Clone, Copy, Debug, PartialEq, Eq)]
+pub(super) struct SelectRowState {
+    pub is_focused: bool,
+    pub is_selected: bool,
+    pub is_hovered: bool,
+}
+
+pub(super) fn compute_row_state(
+    display_idx: usize,
+    focused_index: usize,
+    choice_idx: usize,
+    selected: &HashSet<usize>,
+    hovered_index: Option<usize>,
+) -> SelectRowState {
+    SelectRowState {
+        is_focused: display_idx == focused_index,
+        is_selected: selected.contains(&choice_idx),
+        is_hovered: hovered_index == Some(display_idx),
+    }
+}
+
+pub(super) fn extract_choice_icon_hint(description: Option<&str>) -> Option<&str> {
+    description.and_then(|raw| {
+        raw.split(['‚Ä¢', '|', '\n'])
+            .map(str::trim)
+            .find_map(|token| {
+                let token_lower = token.to_ascii_lowercase();
+                if token_lower == "icon"
+                    || token_lower.starts_with("icon:")
+                    || token_lower.starts_with("icon=")
+                    || token_lower.starts_with("icon ")
+                {
+                    token
+                        .split_once(':')
+                        .or_else(|| token.split_once('='))
+                        .map(|(_, value)| value.trim())
+                        .or_else(|| token.split_whitespace().nth(1))
+                } else {
+                    None
+                }
+            })
+            .filter(|value| !value.is_empty())
+    })
+}
+
+pub(super) fn icon_kind_from_choice(choice: &Choice) -> IconKind {
+    let metadata_icon =
+        extract_choice_icon_hint(choice.description.as_deref()).and_then(IconKind::from_icon_hint);
+    let name_prefix_icon = choice
+        .name
+        .split_whitespace()
+        .next()
+        .and_then(IconKind::from_icon_hint);
+
+    metadata_icon
+        .or(name_prefix_icon)
+        .unwrap_or_else(|| IconKind::Svg("Code".to_string()))
+}
+
+fn leading_content_from_icon_kind(icon_kind: IconKind) -> LeadingContent {
+    match icon_kind {
+        IconKind::Emoji(emoji) => LeadingContent::Emoji(emoji.into()),
+        IconKind::Image(render_image) => LeadingContent::AppIcon(render_image),
+        IconKind::Svg(name) => LeadingContent::Icon {
+            name: SharedString::from(name),
+            color: None,
+        },
+    }
+}
+
 impl Focusable for SelectPrompt {
     fn focus_handle(&self, _cx: &gpui::App) -> FocusHandle {
         self.focus_handle.clone()
@@ -76,6 +149,13 @@
             self.design_variant,
             &colors,
         ));
+        let row_accent_color = if self.design_variant == DesignVariant::Default {
+            self.theme.colors.accent.selected
+        } else {
+            colors.accent
+        };
+        let focused_row_bg = rgba((row_accent_color << 8) | ROW_FOCUSED_BG_ALPHA);
+        let hovered_row_bg = rgba((row_accent_color << 8) | ROW_HOVER_BG_ALPHA);
 
         let placeholder = self
             .placeholder
@@ -145,8 +225,12 @@
                     move |this: &mut SelectPrompt,
                           visible_range: std::ops::Range<usize>,
                           _window,
-                          _cx| {
-                        let row_colors = UnifiedListItemColors::from_theme(&this.theme);
+                          cx| {
+                        let item_colors = UnifiedListItemColors {
+                            selected_opacity: 0.0,
+                            hover_opacity: 0.0,
+                            ..UnifiedListItemColors::from_theme(&this.theme)
+                        };
                         let mut rows = Vec::with_capacity(visible_range.len());
 
                         for display_idx in visible_range {
@@ -154,21 +238,30 @@
                                 if let Some(choice) = this.choices.get(choice_idx) {
                                     if let Some(indexed_choice) = this.choice_index.get(choice_idx)
                                     {
-                                        let is_focused = display_idx == this.focused_index;
-                                        let is_selected = this.selected.contains(&choice_idx);
-                                        let is_selected_for_ui = if this.multiple {
-                                            is_selected
-                                        } else {
-                                            is_focused
-                                        };
+                                        let row_state = compute_row_state(
+                                            display_idx,
+                                            this.focused_index,
+                                            choice_idx,
+                                            &this.selected,
+                                            this.hovered_index,
+                                        );
+                                        let is_focused = row_state.is_focused;
+                                        let is_selected = row_state.is_selected;
+                                        let is_hovered = row_state.is_hovered;
                                         let semantic_id =
                                             choice.semantic_id.clone().unwrap_or_else(|| {
                                                 indexed_choice.stable_semantic_id.clone()
                                             });
-                                        let indicator = choice_selection_indicator(
-                                            this.multiple,
-                                            is_selected_for_ui,
-                                        );
+                                        let leading = if this.multiple {
+                                            Some(LeadingContent::Emoji(
+                                                choice_selection_indicator(true, is_selected)
+                                                    .into(),
+                                            ))
+                                        } else {
+                                            Some(leading_content_from_icon_kind(
+                                                icon_kind_from_choice(choice),
+                                            ))
+                                        };
                                         let subtitle = indexed_choice
                                             .metadata
                                             .subtitle_text()
@@ -185,34 +278,60 @@
                                                     ))
                                                 },
                                             );
+                                        let row_bg = if is_focused {
+                                            focused_row_bg
+                                        } else if is_hovered {
+                                            hovered_row_bg
+                                        } else {
+                                            rgba(0x00000000)
+                                        };
+                                        let hover_handler = cx.listener(
+                                            move |this: &mut SelectPrompt,
+                                                  hovered: &bool,
+                                                  _window,
+                                                  cx| {
+                                                if *hovered {
+                                                    if this.hovered_index != Some(display_idx) {
+                                                        this.hovered_index = Some(display_idx);
+                                                        cx.notify();
+                                                    }
+                                                } else if this.hovered_index == Some(display_idx) {
+                                                    this.hovered_index = None;
+                                                    cx.notify();
+                                                }
+                                            },
+                                        );
+
+                                        let mut row = div()
+                                            .id(display_idx)
+                                            .w_full()
+                                            .h(px(LIST_ITEM_HEIGHT))
+                                            .rounded(px(8.0))
+                                            .bg(row_bg)
+                                            .cursor_pointer()
+                                            .on_hover(hover_handler)
+                                            .child(
+                                                UnifiedListItem::new(
+                                                    gpui::ElementId::Name(semantic_id.into()),
+                                                    title,
+                                                )
+                                                .subtitle_opt(subtitle)
+                                                .leading_opt(leading)
+                                                .trailing_opt(trailing)
+                                                .state(ItemState {
+                                                    is_selected,
+                                                    is_hovered,
+                                                    is_disabled: false,
+                                                })
+                                                .density(Density::Comfortable)
+                                                .colors(item_colors),
+                                            );
+
+                                        if !is_focused {
+                                            row = row.hover(move |s| s.bg(hovered_row_bg));
+                                        }
 
-                                        rows.push(
-                                            div()
-                                                .id(display_idx)
-                                                .w_full()
-                                                .h(px(LIST_ITEM_HEIGHT))
-                                                .border_b_1()
-                                                .border_color(border_color)
-                                                .child(
-                                                    UnifiedListItem::new(
-                                                        gpui::ElementId::Name(semantic_id.into()),
-                                                        title,
-                                                    )
-                                                    .subtitle_opt(subtitle)
-                                                    .leading(LeadingContent::Emoji(
-                                                        indicator.into(),
-                                                    ))
-                                                    .trailing_opt(trailing)
-                                                    .state(ItemState {
-                                                        is_selected: is_focused,
-                                                        is_hovered: false,
-                                                        is_disabled: false,
-                                                    })
-                                                    .density(Density::Comfortable)
-                                                    .colors(row_colors)
-                                                    .with_accent_bar(is_selected_for_ui),
-                                                ),
-                                        );
+                                        rows.push(row);
                                     }
                                 }
                             }
@@ -234,6 +353,7 @@
             .flex_col()
             .flex_1()
             .w_full()
+            .px(px(8.0))
             .child(choices_content);
 
         div()
diff --git a/src/prompts/select/tests.rs b/src/prompts/select/tests.rs
index 250ec9d63282ad81dd952efa12855f784330232c..2b048753d5f168dcbc59ccb0e399e4604bc39167
--- a/src/prompts/select/tests.rs
+++ b/src/prompts/select/tests.rs
@@ -184,3 +184,36 @@
         0x445566
     );
 }
+
+#[test]
+fn test_select_prompt_extracts_icon_hint_from_choice_metadata() {
+    let description = Some("Shortcut: cmd+k ‚Ä¢ icon: terminal ‚Ä¢ script");
+    assert_eq!(
+        render::extract_choice_icon_hint(description),
+        Some("terminal")
+    );
+}
+
+#[test]
+fn test_select_prompt_icon_kind_falls_back_to_code_icon_without_hint() {
+    let choice = choice("Deploy API", "/Users/me/.scriptkit/scripts/deploy.ts", None);
+
+    match render::icon_kind_from_choice(&choice) {
+        IconKind::Svg(name) => assert_eq!(name, "Code"),
+        _ => panic!("expected fallback Code SVG icon"),
+    }
+}
+
+#[test]
+fn test_select_prompt_compute_row_state_keeps_focus_and_selection_independent() {
+    let selected = std::collections::HashSet::from([5]);
+    let focused_but_unselected = render::compute_row_state(2, 2, 1, &selected, Some(1));
+    assert!(focused_but_unselected.is_focused);
+    assert!(!focused_but_unselected.is_selected);
+    assert!(!focused_but_unselected.is_hovered);
+
+    let selected_but_unfocused = render::compute_row_state(1, 2, 5, &selected, Some(1));
+    assert!(!selected_but_unfocused.is_focused);
+    assert!(selected_but_unfocused.is_selected);
+    assert!(selected_but_unfocused.is_hovered);
+}


thinking
**Planning scoped test and clippy runs**
codex
`cargo test` only accepts one filter string, so I‚Äôm rerunning as scoped single-filter test commands and then running scoped clippy on the library target.
exec
/bin/zsh -lc 'cd /Users/johnlindquist/dev/script-kit-gpui && cargo test -p script-kit-gpui --lib icon_kind_from_icon_hint' in /Users/johnlindquist/dev/script-kit-gpuiexec
/bin/zsh -lc 'cd /Users/johnlindquist/dev/script-kit-gpui && cargo test -p script-kit-gpui --lib test_select_prompt_compute_row_state_keeps_focus_and_selection_independent' in /Users/johnlindquist/dev/script-kit-gpuiexec
/bin/zsh -lc 'cd /Users/johnlindquist/dev/script-kit-gpui && cargo test -p script-kit-gpui --lib test_select_prompt_icon_kind_falls_back_to_code_icon_without_hint' in /Users/johnlindquist/dev/script-kit-gpuiexec
/bin/zsh -lc 'cd /Users/johnlindquist/dev/script-kit-gpui && cargo test -p script-kit-gpui --lib test_select_prompt_extracts_icon_hint_from_choice_metadata' in /Users/johnlindquist/dev/script-kit-gpuifile update:
diff --git a/src/list_item/part_000.rs b/src/list_item/part_000.rs
index 733d4ac2aa5b1b27b29a5999310e6f3f45cc54c3..283b2263d56a92c73c22d44443db7b40971d26ce
--- a/src/list_item/part_000.rs
+++ b/src/list_item/part_000.rs
@@ -15,6 +15,37 @@
     /// Maps to IconName from designs::icon_variations
     Svg(String),
 }
+
+impl IconKind {
+    /// Resolve icon metadata into an IconKind for list rendering.
+    ///
+    /// Supports:
+    /// - Known SVG names/aliases via `icon_name_from_str` (e.g., "Terminal", "file-code")
+    /// - Emoji/symbol glyphs (e.g., "üìÑ", "‚ö°")
+    pub fn from_icon_hint(icon_hint: &str) -> Option<Self> {
+        let trimmed = icon_hint.trim();
+        if trimmed.is_empty() {
+            return None;
+        }
+
+        if icon_name_from_str(trimmed).is_some() {
+            return Some(Self::Svg(trimmed.to_string()));
+        }
+
+        if looks_like_symbol_icon_hint(trimmed) {
+            return Some(Self::Emoji(trimmed.to_string()));
+        }
+
+        None
+    }
+}
+
+fn looks_like_symbol_icon_hint(icon_hint: &str) -> bool {
+    let has_ascii_alnum = icon_hint.chars().any(|ch| ch.is_ascii_alphanumeric());
+    let char_count = icon_hint.chars().count();
+
+    !has_ascii_alnum && char_count <= 4
+}
 /// Fixed height for list items used in uniform-height virtualized lists.
 ///
 /// IMPORTANT: When using GPUI `uniform_list`, the item closure must render
@@ -437,3 +468,29 @@
     /// Text color for content displayed on accent/warning backgrounds
     pub text_on_accent: u32,
 }
+
+#[cfg(test)]
+mod icon_kind_tests {
+    use super::IconKind;
+
+    #[test]
+    fn test_icon_kind_from_icon_hint_returns_svg_when_known_icon_name() {
+        match IconKind::from_icon_hint("terminal") {
+            Some(IconKind::Svg(name)) => assert_eq!(name, "terminal"),
+            _ => panic!("expected SVG icon from known icon hint"),
+        }
+    }
+
+    #[test]
+    fn test_icon_kind_from_icon_hint_returns_emoji_when_symbol_glyph() {
+        match IconKind::from_icon_hint("üìÑ") {
+            Some(IconKind::Emoji(emoji)) => assert_eq!(emoji, "üìÑ"),
+            _ => panic!("expected emoji icon for symbol glyph"),
+        }
+    }
+
+    #[test]
+    fn test_icon_kind_from_icon_hint_returns_none_for_unknown_ascii_word() {
+        assert!(IconKind::from_icon_hint("unknown-icon-name").is_none());
+    }
+}
diff --git a/src/prompts/select/mod.rs b/src/prompts/select/mod.rs
index b6366dabfb14f3fae09f854f9de824fa629e0a3b..80287d57d8b538dba0d85476dc6de3aa3409a2fd
--- a/src/prompts/select/mod.rs
+++ b/src/prompts/select/mod.rs
@@ -7,8 +7,8 @@
 //! - Submit selected items
 
 use gpui::{
-    div, prelude::*, px, rgb, uniform_list, AnyElement, Context, FocusHandle, Focusable, Render,
-    ScrollStrategy, SharedString, UniformListScrollHandle, Window,
+    div, prelude::*, px, rgb, rgba, uniform_list, AnyElement, Context, FocusHandle, Focusable,
+    Render, ScrollStrategy, SharedString, UniformListScrollHandle, Window,
 };
 use std::collections::HashSet;
 use std::ops::Range;
@@ -19,7 +19,7 @@
     UnifiedListItemColors,
 };
 use crate::designs::{get_tokens, DesignColors, DesignVariant};
-use crate::list_item::LIST_ITEM_HEIGHT;
+use crate::list_item::{IconKind, LIST_ITEM_HEIGHT};
 use crate::logging;
 use crate::panel::PROMPT_INPUT_FIELD_HEIGHT;
 use crate::protocol::{generate_semantic_id, Choice};
diff --git a/src/prompts/select/prompt.rs b/src/prompts/select/prompt.rs
index c5f98f5318f5b520e9223811f735e866ee06e7fb..5ba2de479b2f5680a73db72642377f68d26ee54e
--- a/src/prompts/select/prompt.rs
+++ b/src/prompts/select/prompt.rs
@@ -19,6 +19,8 @@
     pub filtered_choices: Vec<usize>,
     /// Currently focused index in filtered list
     pub focused_index: usize,
+    /// Currently hovered index in filtered list
+    pub hovered_index: Option<usize>,
     /// Filter text
     pub filter_text: String,
     /// Whether multiple selection is allowed
@@ -68,6 +70,7 @@
             selected: HashSet::new(),
             filtered_choices,
             focused_index: 0,
+            hovered_index: None,
             filter_text: String::new(),
             multiple,
             focus_handle,
@@ -84,6 +87,7 @@
         if trimmed_filter.is_empty() {
             self.filtered_choices = (0..self.choices.len()).collect();
             self.focused_index = 0;
+            self.hovered_index = None;
             return;
         }
 
@@ -109,6 +113,7 @@
 
         self.filtered_choices = scored_matches.into_iter().map(|(idx, _)| idx).collect();
         self.focused_index = 0;
+        self.hovered_index = None;
     }
 
     /// Set the filter text programmatically
@@ -168,6 +173,7 @@
     pub(super) fn move_up(&mut self, cx: &mut Context<Self>) {
         if self.focused_index > 0 {
             self.focused_index -= 1;
+            self.hovered_index = None;
             self.list_scroll_handle
                 .scroll_to_item(self.focused_index, ScrollStrategy::Nearest);
             cx.notify();
@@ -178,6 +184,7 @@
     pub(super) fn move_down(&mut self, cx: &mut Context<Self>) {
         if self.focused_index < self.filtered_choices.len().saturating_sub(1) {
             self.focused_index += 1;
+            self.hovered_index = None;
             self.list_scroll_handle
                 .scroll_to_item(self.focused_index, ScrollStrategy::Nearest);
             cx.notify();
diff --git a/src/prompts/select/render.rs b/src/prompts/select/render.rs
index 62109896c9c14b1b2fbf5b4d25d5d94e4388e4aa..e224ca641be966e7357474d1892f16fb9d59f392
--- a/src/prompts/select/render.rs
+++ b/src/prompts/select/render.rs
@@ -1,5 +1,78 @@
 use super::*;
 
+const ROW_FOCUSED_BG_ALPHA: u32 = 0x3A;
+const ROW_HOVER_BG_ALPHA: u32 = 0x26;
+
+#[derive(Clone, Copy, Debug, PartialEq, Eq)]
+pub(super) struct SelectRowState {
+    pub is_focused: bool,
+    pub is_selected: bool,
+    pub is_hovered: bool,
+}
+
+pub(super) fn compute_row_state(
+    display_idx: usize,
+    focused_index: usize,
+    choice_idx: usize,
+    selected: &HashSet<usize>,
+    hovered_index: Option<usize>,
+) -> SelectRowState {
+    SelectRowState {
+        is_focused: display_idx == focused_index,
+        is_selected: selected.contains(&choice_idx),
+        is_hovered: hovered_index == Some(display_idx),
+    }
+}
+
+pub(super) fn extract_choice_icon_hint(description: Option<&str>) -> Option<&str> {
+    description.and_then(|raw| {
+        raw.split(['‚Ä¢', '|', '\n'])
+            .map(str::trim)
+            .find_map(|token| {
+                let token_lower = token.to_ascii_lowercase();
+                if token_lower == "icon"
+                    || token_lower.starts_with("icon:")
+                    || token_lower.starts_with("icon=")
+                    || token_lower.starts_with("icon ")
+                {
+                    token
+                        .split_once(':')
+                        .or_else(|| token.split_once('='))
+                        .map(|(_, value)| value.trim())
+                        .or_else(|| token.split_whitespace().nth(1))
+                } else {
+                    None
+                }
+            })
+            .filter(|value| !value.is_empty())
+    })
+}
+
+pub(super) fn icon_kind_from_choice(choice: &Choice) -> IconKind {
+    let metadata_icon =
+        extract_choice_icon_hint(choice.description.as_deref()).and_then(IconKind::from_icon_hint);
+    let name_prefix_icon = choice
+        .name
+        .split_whitespace()
+        .next()
+        .and_then(IconKind::from_icon_hint);
+
+    metadata_icon
+        .or(name_prefix_icon)
+        .unwrap_or_else(|| IconKind::Svg("Code".to_string()))
+}
+
+fn leading_content_from_icon_kind(icon_kind: IconKind) -> LeadingContent {
+    match icon_kind {
+        IconKind::Emoji(emoji) => LeadingContent::Emoji(emoji.into()),
+        IconKind::Image(render_image) => LeadingContent::AppIcon(render_image),
+        IconKind::Svg(name) => LeadingContent::Icon {
+            name: SharedString::from(name),
+            color: None,
+        },
+    }
+}
+
 impl Focusable for SelectPrompt {
     fn focus_handle(&self, _cx: &gpui::App) -> FocusHandle {
         self.focus_handle.clone()
@@ -76,6 +149,13 @@
             self.design_variant,
             &colors,
         ));
+        let row_accent_color = if self.design_variant == DesignVariant::Default {
+            self.theme.colors.accent.selected
+        } else {
+            colors.accent
+        };
+        let focused_row_bg = rgba((row_accent_color << 8) | ROW_FOCUSED_BG_ALPHA);
+        let hovered_row_bg = rgba((row_accent_color << 8) | ROW_HOVER_BG_ALPHA);
 
         let placeholder = self
             .placeholder
@@ -145,8 +225,12 @@
                     move |this: &mut SelectPrompt,
                           visible_range: std::ops::Range<usize>,
                           _window,
-                          _cx| {
-                        let row_colors = UnifiedListItemColors::from_theme(&this.theme);
+                          cx| {
+                        let item_colors = UnifiedListItemColors {
+                            selected_opacity: 0.0,
+                            hover_opacity: 0.0,
+                            ..UnifiedListItemColors::from_theme(&this.theme)
+                        };
                         let mut rows = Vec::with_capacity(visible_range.len());
 
                         for display_idx in visible_range {
@@ -154,21 +238,30 @@
                                 if let Some(choice) = this.choices.get(choice_idx) {
                                     if let Some(indexed_choice) = this.choice_index.get(choice_idx)
                                     {
-                                        let is_focused = display_idx == this.focused_index;
-                                        let is_selected = this.selected.contains(&choice_idx);
-                                        let is_selected_for_ui = if this.multiple {
-                                            is_selected
-                                        } else {
-                                            is_focused
-                                        };
+                                        let row_state = compute_row_state(
+                                            display_idx,
+                                            this.focused_index,
+                                            choice_idx,
+                                            &this.selected,
+                                            this.hovered_index,
+                                        );
+                                        let is_focused = row_state.is_focused;
+                                        let is_selected = row_state.is_selected;
+                                        let is_hovered = row_state.is_hovered;
                                         let semantic_id =
                                             choice.semantic_id.clone().unwrap_or_else(|| {
                                                 indexed_choice.stable_semantic_id.clone()
                                             });
-                                        let indicator = choice_selection_indicator(
-                                            this.multiple,
-                                            is_selected_for_ui,
-                                        );
+                                        let leading = if this.multiple {
+                                            Some(LeadingContent::Emoji(
+                                                choice_selection_indicator(true, is_selected)
+                                                    .into(),
+                                            ))
+                                        } else {
+                                            Some(leading_content_from_icon_kind(
+                                                icon_kind_from_choice(choice),
+                                            ))
+                                        };
                                         let subtitle = indexed_choice
                                             .metadata
                                             .subtitle_text()
@@ -185,34 +278,60 @@
                                                     ))
                                                 },
                                             );
+                                        let row_bg = if is_focused {
+                                            focused_row_bg
+                                        } else if is_hovered {
+                                            hovered_row_bg
+                                        } else {
+                                            rgba(0x00000000)
+                                        };
+                                        let hover_handler = cx.listener(
+                                            move |this: &mut SelectPrompt,
+                                                  hovered: &bool,
+                                                  _window,
+                                                  cx| {
+                                                if *hovered {
+                                                    if this.hovered_index != Some(display_idx) {
+                                                        this.hovered_index = Some(display_idx);
+                                                        cx.notify();
+                                                    }
+                                                } else if this.hovered_index == Some(display_idx) {
+                                                    this.hovered_index = None;
+                                                    cx.notify();
+                                                }
+                                            },
+                                        );
+
+                                        let mut row = div()
+                                            .id(display_idx)
+                                            .w_full()
+                                            .h(px(LIST_ITEM_HEIGHT))
+                                            .rounded(px(8.0))
+                                            .bg(row_bg)
+                                            .cursor_pointer()
+                                            .on_hover(hover_handler)
+                                            .child(
+                                                UnifiedListItem::new(
+                                                    gpui::ElementId::Name(semantic_id.into()),
+                                                    title,
+                                                )
+                                                .subtitle_opt(subtitle)
+                                                .leading_opt(leading)
+                                                .trailing_opt(trailing)
+                                                .state(ItemState {
+                                                    is_selected,
+                                                    is_hovered,
+                                                    is_disabled: false,
+                                                })
+                                                .density(Density::Comfortable)
+                                                .colors(item_colors),
+                                            );
+
+                                        if !is_focused {
+                                            row = row.hover(move |s| s.bg(hovered_row_bg));
+                                        }
 
-                                        rows.push(
-                                            div()
-                                                .id(display_idx)
-                                                .w_full()
-                                                .h(px(LIST_ITEM_HEIGHT))
-                                                .border_b_1()
-                                                .border_color(border_color)
-                                                .child(
-                                                    UnifiedListItem::new(
-                                                        gpui::ElementId::Name(semantic_id.into()),
-                                                        title,
-                                                    )
-                                                    .subtitle_opt(subtitle)
-                                                    .leading(LeadingContent::Emoji(
-                                                        indicator.into(),
-                                                    ))
-                                                    .trailing_opt(trailing)
-                                                    .state(ItemState {
-                                                        is_selected: is_focused,
-                                                        is_hovered: false,
-                                                        is_disabled: false,
-                                                    })
-                                                    .density(Density::Comfortable)
-                                                    .colors(row_colors)
-                                                    .with_accent_bar(is_selected_for_ui),
-                                                ),
-                                        );
+                                        rows.push(row);
                                     }
                                 }
                             }
@@ -234,6 +353,7 @@
             .flex_col()
             .flex_1()
             .w_full()
+            .px(px(8.0))
             .child(choices_content);
 
         div()
diff --git a/src/prompts/select/tests.rs b/src/prompts/select/tests.rs
index 250ec9d63282ad81dd952efa12855f784330232c..2b048753d5f168dcbc59ccb0e399e4604bc39167
--- a/src/prompts/select/tests.rs
+++ b/src/prompts/select/tests.rs
@@ -184,3 +184,36 @@
         0x445566
     );
 }
+
+#[test]
+fn test_select_prompt_extracts_icon_hint_from_choice_metadata() {
+    let description = Some("Shortcut: cmd+k ‚Ä¢ icon: terminal ‚Ä¢ script");
+    assert_eq!(
+        render::extract_choice_icon_hint(description),
+        Some("terminal")
+    );
+}
+
+#[test]
+fn test_select_prompt_icon_kind_falls_back_to_code_icon_without_hint() {
+    let choice = choice("Deploy API", "/Users/me/.scriptkit/scripts/deploy.ts", None);
+
+    match render::icon_kind_from_choice(&choice) {
+        IconKind::Svg(name) => assert_eq!(name, "Code"),
+        _ => panic!("expected fallback Code SVG icon"),
+    }
+}
+
+#[test]
+fn test_select_prompt_compute_row_state_keeps_focus_and_selection_independent() {
+    let selected = std::collections::HashSet::from([5]);
+    let focused_but_unselected = render::compute_row_state(2, 2, 1, &selected, Some(1));
+    assert!(focused_but_unselected.is_focused);
+    assert!(!focused_but_unselected.is_selected);
+    assert!(!focused_but_unselected.is_hovered);
+
+    let selected_but_unfocused = render::compute_row_state(1, 2, 5, &selected, Some(1));
+    assert!(!selected_but_unfocused.is_focused);
+    assert!(selected_but_unfocused.is_selected);
+    assert!(selected_but_unfocused.is_hovered);
+}


thinking
**Handling parallel test lock conflicts**

[swarm-timeout] max runtime 600s reached; sending SIGTERM
[swarm-commit-gate] author=swarm:codex-list-polish start_sha=7a6c0cb31c1cfca916e9e1fdda23a3d9c1b7e0aa commits=0 files=(none)
[swarm-policy] scope=src/prompts/select/render.rs,src/prompts/select/mod.rs,src/list_item/part_000.rs,src/list_item/part_001.rs commits=(none) out_of_scope=(none) report_changed=(none) issue=missing_agent_report_json
[swarm-report] issue=missing_agent_report_json policy_issue=missing_agent_report_json commits=0 files=(none)
