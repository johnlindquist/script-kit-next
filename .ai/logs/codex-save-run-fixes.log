==== spawn @ 2026-02-08T07:27:48.932Z ====
cmd: codex "exec" "--cd" "/Users/johnlindquist/dev/script-kit-gpui" "--model" "gpt-5.3-codex" "-c" "model_reasoning_effort=\"xhigh\"" "-c" "model_auto_compact_token_limit=120000" "-c" "developer_instructions=\"You are Codex implementer agent \\\"codex-save-run-fixes\\\".\\n\\n## Coordination\\nThis repo runs parallel agents in ONE working tree. Before editing any file, you MUST claim it.\\nCommands (run via shell):\\n  - View roster: ~/.claude/bin/swarm.ts status\\n  - Claim files (blocks until free): ~/.claude/bin/swarm.ts claim --wait --id codex-save-run-fixes path/to/file\\n  - Release: ~/.claude/bin/swarm.ts release --id codex-save-run-fixes path/to/file\\n  - Update status/notes: ~/.claude/bin/swarm.ts update --id codex-save-run-fixes --status in_progress --notes \\\"...\\\"\\nRules:\\n  - Never edit a file you haven't claimed.\\n  - Keep claims tight (claim only what you're actively changing).\\n  - If blocked, set status=blocked and say what you're waiting on.\\n  - When finished, set status=done and release claims.\\n\\n## Development practices (this code is maintained by AI agents)\\n  - Log state transitions with enough context to diagnose failures from logs alone.\\n  - Structured errors: include what was attempted, what failed, and current state.\\n  - Name things for grepability — unique identifiers agents can find on the first search.\\n  - Every behavior change gets a test. Untested code is invisible to the next agent.\\n  - Test names describe the scenario: test_X_does_Y_when_Z.\\n  - Keep functions small and single-purpose. 500-line functions burn agent context.\\n  - Use types to encode constraints (enums > strings for errors).\\n\\n## CRITICAL: Parallel-safe verification\\n  - Other agents are modifying other files RIGHT NOW. Full test suites WILL show their failures.\\n  - ONLY run tests that cover YOUR changed files. Scope every test/check command:\\n    Rust: cargo test -p your-crate -- module::test_name | JS: npx jest your/file.test.ts\\n  - Do NOT run: cargo test (unscoped), cargo check (whole workspace), npm test (unscoped).\\n  - If a scoped test fails, it's YOUR bug — fix it. If tests outside your scope fail, ignore them.\\n\\n## Git commit discipline\\n  - NEVER commit unverified work. Run tests/lints/type-checks FIRST. If it fails, fix it before committing.\\n  - A commit is a declaration: \\\"this works and here's the proof.\\\"\\n  - Commit FREQUENTLY — after each meaningful unit of VERIFIED work, not just at the end.\\n  - A \\\"unit\\\" = one logical change that passes verification (new function, bug fix, refactor, test added).\\n  - NEVER batch an entire task into one giant commit. Small commits are searchable; big ones aren't.\\n  - Commit message format:\\n      Line 1: <type>(<scope>): <what changed> (imperative, max 72 chars)\\n      Line 3+: WHY this change was made, WHAT was verified, and HOW to test it.\\n    Types: feat, fix, refactor, test, docs, chore\\n    Example:\\n      feat(auth): add refresh token rotation\\n      \\n      Tokens now rotate on each refresh call to prevent replay attacks.\\n      The old token is invalidated immediately on rotation.\\n      \\n      Verified: cargo test --lib -- auth::refresh (4 tests pass)\\n      Verified: manual smoke test via curl — token rotates, old token returns 401\\n  - The \\\"Verified:\\\" lines are REQUIRED. Future agents will read git log to understand\\n    what was tested and how to re-verify. This is the most valuable part of the message.\\n  - In your final message, list all commits you made with their hashes.\\n\\n## Time budget\\nYou have approximately 10 minutes. If your task is too broad to complete in time:\\n(1) Commit any verified progress.\\n(2) Run: ~/.claude/bin/swarm.ts update --id YOUR_ID --status needs_split --notes 'suggest: 1) sub-task-desc scope:files 2) sub-task-desc scope:files'.\\n(3) Exit cleanly. The dispatcher will read your suggestions and spawn narrower workers.\"" "--output-last-message" "/Users/johnlindquist/dev/script-kit-gpui/.ai/logs/codex-save-run-fixes.final.md" "--yolo" "You are agent codex-save-run-fixes.\n\nCurrent parallel-agent roster (read this first):\n```\nSWARM SNAPSHOT @ 2026-02-08T07:27:48.929Z\n- codex-save-run-fixes [starting] scope=src/prompts/chat/render_core.rs,src/prompts/chat/actions.rs,src/prompts/chat/prompt.rs,src/prompts/chat/mod.rs,src/app_impl/prompt_ai.rs,src/ai/script_generation.rs,src/components/prompt_footer.rs task=Three fixes for the script generation ChatPrompt:\n\n1) SAVE AND RUN must show the script in the main window. Currently r…\n```\n\nYour assignment:\n- Task: Three fixes for the script generation ChatPrompt:\n\n1) SAVE AND RUN must show the script in the main window. Currently run_saved_script() in src/ai/script_generation.rs spawns bun/kit as a detached process, which doesn't show anything in the app. Instead, after saving the script, the 'Run' and 'Save and Run' actions should execute the script through the app's normal script execution pipeline. Look at how scripts are normally executed in the app - check src/app_impl/execution_scripts.rs and src/execute_script/ for the pattern. The ChatPrompt's handle_script_generation_action in src/prompts/chat/actions.rs needs to signal back to the parent app (ScriptListApp) to execute the saved script. One approach: after saving, use a callback or channel to tell the app to run the script at the saved path. Check how the ChatPrompt communicates with the parent app (escape_callback pattern, or the on_submit callback). You may need to add an on_run_script callback to ChatPrompt that the parent app provides when creating the script generation chat (in show_script_generation_chat in src/app_impl/prompt_ai.rs).\n\n2) Add Cmd+Return (⌘↵) keyboard shortcut for 'Save and Run'. In the ChatPrompt key handler, when script_generation_mode is true and Cmd+Return is pressed, trigger handle_script_generation_action(ScriptGenerationAction::SaveAndRun). Look at how other keyboard shortcuts are handled in the chat prompt key events.\n\n3) Button styles must match the standard PromptFooter button style used throughout the app. Look at src/components/prompt_footer.rs for the PromptFooter component and its button styling. The script generation footer buttons (Save, Run, Save and Run) should use the exact same visual treatment - same font size, colors, padding, and hover states. Run cargo check.\n- Scope: src/prompts/chat/render_core.rs,src/prompts/chat/actions.rs,src/prompts/chat/prompt.rs,src/prompts/chat/mod.rs,src/app_impl/prompt_ai.rs,src/ai/script_generation.rs,src/components/prompt_footer.rs\n\nOperating constraints:\n- Single working tree (no worktrees, no patches).\n- You MUST claim files before editing (~/.claude/bin/swarm.ts claim --wait ...).\n\nDeliverables:\n- Make the code changes required by the task.\n- Run the most relevant tests/linters.\n- In your FINAL message, include: changed files, how to test, and any risks/known gaps."

OpenAI Codex v0.98.0 (research preview)
--------
workdir: /Users/johnlindquist/dev/script-kit-gpui
model: gpt-5.3-codex
provider: openai
approval: never
sandbox: danger-full-access
reasoning effort: xhigh
reasoning summaries: auto
session id: 019c3c26-4cf5-7690-b7dc-21fa971c7321
--------
user
You are agent codex-save-run-fixes.

Current parallel-agent roster (read this first):
```
SWARM SNAPSHOT @ 2026-02-08T07:27:48.929Z
- codex-save-run-fixes [starting] scope=src/prompts/chat/render_core.rs,src/prompts/chat/actions.rs,src/prompts/chat/prompt.rs,src/prompts/chat/mod.rs,src/app_impl/prompt_ai.rs,src/ai/script_generation.rs,src/components/prompt_footer.rs task=Three fixes for the script generation ChatPrompt:

1) SAVE AND RUN must show the script in the main window. Currently r…
```

Your assignment:
- Task: Three fixes for the script generation ChatPrompt:

1) SAVE AND RUN must show the script in the main window. Currently run_saved_script() in src/ai/script_generation.rs spawns bun/kit as a detached process, which doesn't show anything in the app. Instead, after saving the script, the 'Run' and 'Save and Run' actions should execute the script through the app's normal script execution pipeline. Look at how scripts are normally executed in the app - check src/app_impl/execution_scripts.rs and src/execute_script/ for the pattern. The ChatPrompt's handle_script_generation_action in src/prompts/chat/actions.rs needs to signal back to the parent app (ScriptListApp) to execute the saved script. One approach: after saving, use a callback or channel to tell the app to run the script at the saved path. Check how the ChatPrompt communicates with the parent app (escape_callback pattern, or the on_submit callback). You may need to add an on_run_script callback to ChatPrompt that the parent app provides when creating the script generation chat (in show_script_generation_chat in src/app_impl/prompt_ai.rs).

2) Add Cmd+Return (⌘↵) keyboard shortcut for 'Save and Run'. In the ChatPrompt key handler, when script_generation_mode is true and Cmd+Return is pressed, trigger handle_script_generation_action(ScriptGenerationAction::SaveAndRun). Look at how other keyboard shortcuts are handled in the chat prompt key events.

3) Button styles must match the standard PromptFooter button style used throughout the app. Look at src/components/prompt_footer.rs for the PromptFooter component and its button styling. The script generation footer buttons (Save, Run, Save and Run) should use the exact same visual treatment - same font size, colors, padding, and hover states. Run cargo check.
- Scope: src/prompts/chat/render_core.rs,src/prompts/chat/actions.rs,src/prompts/chat/prompt.rs,src/prompts/chat/mod.rs,src/app_impl/prompt_ai.rs,src/ai/script_generation.rs,src/components/prompt_footer.rs

Operating constraints:
- Single working tree (no worktrees, no patches).
- You MUST claim files before editing (~/.claude/bin/swarm.ts claim --wait ...).

Deliverables:
- Make the code changes required by the task.
- Run the most relevant tests/linters.
- In your FINAL message, include: changed files, how to test, and any risks/known gaps.
warning: Under-development features enabled: responses_websockets. Under-development features are incomplete and may behave unpredictably. To suppress this warning, set `suppress_unstable_features_warning = true` in /Users/johnlindquist/.codex/config.toml.
mcp: deepwiki starting
mcp: deepwiki ready
mcp startup: ready: deepwiki

thinking
**Planning parallel command usage**
codex
I’ll implement the three ChatPrompt fixes now. First I’m checking the current file state and wiring points for script execution, then I’ll claim the target files before making edits.
exec
/bin/zsh -lc 'cd /Users/johnlindquist/dev/script-kit-gpui && ~/.claude/bin/swarm.ts status && ~/.claude/bin/swarm.ts update --id codex-save-run-fixes --status in_progress --notes "implementing save+run pipeline callback, cmd+enter shortcut, footer style parity"' in /Users/johnlindquist/dev/script-kit-gpui succeeded in 51ms:
Repo: /Users/johnlindquist/dev/script-kit-gpui
Updated: 2026-02-08T07:28:04.252Z

Active agents (1):
codex-save-run-fixes [in_progress] codex/gpt-5.3-codex/exec
  task: Three fixes for the script generation ChatPrompt:

1) SAVE AND RUN must show the script in the main window. Currently r…
  scope: src/prompts/chat/render_core.rs,src/prompts/chat/actions.rs,src/prompts/chat/prompt.rs,src/prompts/chat/mod.rs,src/app_…
  claims: (none)
  notes: spawned codex (exec)

Inactive agents (271):
- codex-accessibility [done] done. exit=0. final=.ai/logs/codex-accessibility.final.md. See final message file.
- codex-action-labels [failed] failed. exit=1. final=.ai/logs/codex-action-labels.final.md.
- codex-actions-audit [failed] failed. exit=1. final=.ai/logs/codex-actions-audit.final.md. See final message file.
- codex-actions-consistency [failed] failed. exit=1. final=.ai/logs/codex-actions-consistency.final.md.
- codex-actions-dialog [done] done. exit=0. final=.ai/logs/codex-actions-dialog.final.md. See final message file.
- codex-actions-feedback [failed] failed. exit=1. final=.ai/logs/codex-actions-feedback.final.md.
- codex-actions-feedback-v2 [done] done. exit=0. final=.ai/logs/codex-actions-feedback-v2.final.md. See final message file.

thinking
**Planning parallel file inspection**
codex
I’ve set status to in progress. Next I’m reading the chat prompt/action/execution files to map the existing callback path and keyboard handling before claiming and editing.
exec
/bin/zsh -lc "cd /Users/johnlindquist/dev/script-kit-gpui && sed -n '1,260p' src/prompts/chat/prompt.rs" in /Users/johnlindquist/dev/script-kit-gpuiexec
/bin/zsh -lc "cd /Users/johnlindquist/dev/script-kit-gpui && sed -n '1,260p' src/prompts/chat/actions.rs" in /Users/johnlindquist/dev/script-kit-gpuiexec
/bin/zsh -lc "cd /Users/johnlindquist/dev/script-kit-gpui && sed -n '1,260p' src/prompts/chat/render_core.rs" in /Users/johnlindquist/dev/script-kit-gpui succeeded in 52ms:
use super::*;
pub struct ChatPrompt {
    pub id: String,
    pub messages: Vec<ChatPromptMessage>,
    pub placeholder: Option<String>,
    pub hint: Option<String>,
    pub footer: Option<String>,
    pub model: Option<String>,
    pub models: Vec<ChatModel>,
    pub title: Option<String>,
    pub focus_handle: FocusHandle,
    pub input: TextInputState,
    pub on_submit: ChatSubmitCallback,
    pub on_escape: Option<ChatEscapeCallback>,
    pub on_continue: Option<ChatContinueCallback>,
    pub on_retry: Option<ChatRetryCallback>,
    pub theme: Arc<theme::Theme>,
    pub turns_list_state: ListState,
    pub(super) prompt_colors: theme::PromptColors,
    pub(super) conversation_turns_cache: Arc<Vec<ConversationTurn>>,
 succeeded in 52ms:
use super::*;

impl ChatPrompt {
    pub(super) fn handle_escape(&mut self, _cx: &mut Context<Self>) {
        logging::log("CHAT", "Escape pressed - closing chat");

        // Save conversation to database if save_history is enabled
        if self.save_history {
            self.save_to_database();
        }

        if let Some(ref callback) = self.on_escape {
            callback(self.id.clone());
        }
    }

    /// Save the current conversation to the AI chats database
    pub(super) fn save_to_database(&self) {
        // Only save if we have messages
        if self.messages.is_empty() {
 succeeded in 50ms:
use super::*;

impl ChatPrompt {
    fn render_footer_button(
        &self,
        id: &'static str,
        label: &'static str,
        shortcut: Option<&'static str>,
        accent_color: u32,
        muted_color: u32,
    ) -> AnyElement {
        div()
            .id(id)
            .flex()
            .flex_row()
            .items_center()
            .gap(px(6.0))
            .px(px(8.0))
            .py(px(2.0))
            .rounded(px(4.0))

thinking
**Scanning key and input modules**
codex
I found the current run path in `handle_script_generation_action` and it’s still using the detached bun launcher. I’m now tracing the parent app callback path and the normal script execution flow so we can route Save/Run through it.
exec
/bin/zsh -lc "cd /Users/johnlindquist/dev/script-kit-gpui && sed -n '1,320p' src/app_impl/prompt_ai.rs" in /Users/johnlindquist/dev/script-kit-gpuiexec
/bin/zsh -lc "cd /Users/johnlindquist/dev/script-kit-gpui && sed -n '1,260p' src/ai/script_generation.rs" in /Users/johnlindquist/dev/script-kit-gpuiexec
/bin/zsh -lc "cd /Users/johnlindquist/dev/script-kit-gpui && sed -n '1,360p' src/app_impl/execution_scripts.rs" in /Users/johnlindquist/dev/script-kit-gpui succeeded in 51ms:
use anyhow::{Context, Result};
use std::fs::{self, OpenOptions};
use std::io::{ErrorKind, Write};
use std::path::{Path, PathBuf};
use std::sync::Arc;

use super::config::ModelInfo;
use super::providers::{AiProvider, ProviderMessage, ProviderRegistry};

const AI_SCRIPT_OUTPUT_DIR: &str = "~/.kenv/scripts";
const AI_SCRIPT_DEFAULT_SLUG: &str = "ai-script";
const AI_SCRIPT_MAX_SLUG_LEN: usize = 64;
const SCRIPT_KIT_SDK_IMPORT_MODULE: &str = "@scriptkit/sdk";
const SCRIPT_KIT_SDK_IMPORT_STATEMENT: &str = "import \"@scriptkit/sdk\";";

pub(crate) const AI_SCRIPT_GENERATION_SYSTEM_PROMPT: &str =
    r#"You write production-ready Script Kit TypeScript scripts.

Return ONLY TypeScript source code for one Script Kit script.
Do not return markdown fences or explanations.
 succeeded in 51ms:
use super::*;
use anyhow::{anyhow, Context as AnyhowContext, Result};

#[derive(Debug, Clone, Copy)]
enum AiScriptGenerationStage {
    SelectModel,
    ResolveProvider,
    RequestCompletion,
    ExtractScript,
    CreateScriptFile,
    WriteScriptFile,
    OpenEditor,
}

impl AiScriptGenerationStage {
    fn as_str(self) -> &'static str {
        match self {
            Self::SelectModel => "select_model",
            Self::ResolveProvider => "resolve_provider",
            Self::RequestCompletion => "request_completion",
 succeeded in 52ms:
use super::*;

const NO_MAIN_WINDOW_BUILTINS: &[&str] = &[
    "builtin-ai-chat",
    "builtin-open-ai",
    "builtin-notes",
    "builtin-open-notes",
    "builtin-new-note",
    "builtin-search-notes",
    "builtin-quick-capture",
    "builtin-new-conversation",
];

fn builtin_needs_main_window_for_command_id(identifier: &str) -> bool {
    !NO_MAIN_WINDOW_BUILTINS.contains(&identifier)
}

#[cfg(test)]
mod builtin_command_window_visibility_tests {
    use super::builtin_needs_main_window_for_command_id;

thinking
**Mapping event handlers and prompt styles**
codex
I’ve confirmed the normal execution entrypoint is `execute_script_by_path`/`execute_interactive` in `execution_scripts.rs`. I’m now locating where `ChatPrompt` key events and constructor callbacks are defined so we can add a run-script callback cleanly.
exec
/bin/zsh -lc "cd /Users/johnlindquist/dev/script-kit-gpui && sed -n '1,320p' src/components/prompt_footer.rs" in /Users/johnlindquist/dev/script-kit-gpuiexec
/bin/zsh -lc "cd /Users/johnlindquist/dev/script-kit-gpui && sed -n '1,360p' src/prompts/chat/mod.rs" in /Users/johnlindquist/dev/script-kit-gpuiexec
/bin/zsh -lc "cd /Users/johnlindquist/dev/script-kit-gpui && rg -n \"script_generation_mode|KeyDownEvent|cmd|return|enter|on_submit|on_escape|on_show_actions|with_escape_callback|save_and_run|ScriptGenerationAction\" src/prompts/chat -g'*.rs'" in /Users/johnlindquist/dev/script-kit-gpui succeeded in 52ms:
//! ChatPrompt - Raycast-style chat interface
//!
//! Features:
//! - Input at TOP (not bottom)
//! - Messages bundled as conversation turns (user prompt + AI response in same container)
//! - Full-width containers (not bubbles)
//! - Footer with model selector and "Continue in Chat"
//! - Actions menu (⌘+K) with model picker

use crate::components::prompt_footer::PromptFooterColors;
use crate::components::TextInputState;
use crate::designs::icon_variations::IconName;
use gpui::{
    div, img, list, prelude::*, px, rgb, rgba, svg, AnyElement, App, Context, ExternalPaths,
    FocusHandle, Focusable, Hsla, KeyDownEvent, ListAlignment, ListSizingBehavior, ListState,
    Render, RenderImage, ScrollWheelEvent, Timer, Window,
};
use gpui_component::{scroll::ScrollableElement, theme::ActiveTheme};
use std::collections::HashMap;
use std::sync::atomic::{AtomicBool, Ordering};
 succeeded in 52ms:
//! PromptFooter - Reusable footer component for prompts
//!
//! This module provides a theme-aware footer component used across all prompt types.
//! It includes a Script Kit logo, optional helper text, primary action button, divider,
//! and secondary action button.
//!
//! # Structure
//! ```text
//! | [Logo] [Helper Text] |              | [Info] | [Primary ↵] | [Secondary ⌘K] |
//! ```
//!
//! # Example
//! ```rust,ignore
//! let footer = PromptFooter::new(
//!     PromptFooterConfig::new()
//!         .primary_label("Run Script")
//!         .primary_shortcut("↵")
//!         .secondary_label("Actions")
//!         .secondary_shortcut("⌘K"),
//!     PromptFooterColors::from_theme(&theme),
 succeeded in 51ms:
src/prompts/chat/render_input.rs:15:            .items_center()
src/prompts/chat/render_input.rs:52:            input_content = div().flex().flex_row().items_center().child(cursor).child(
src/prompts/chat/render_input.rs:74:            .items_center()
src/prompts/chat/render_input.rs:93:            .items_center()
src/prompts/chat/render_turns.rs:58:            let mut error_row = div().flex().flex_row().items_center().gap(px(8.0)).child(
src/prompts/chat/render_turns.rs:112:                self.script_generation_mode,
src/prompts/chat/render_turns.rs:152:            .items_center()
src/prompts/chat/render_turns.rs:153:            .justify_center()
src/prompts/chat/render_setup.rs:23:            .items_center()
src/prompts/chat/render_setup.rs:24:            .justify_center()
src/prompts/chat/render_setup.rs:33:                    .items_center()
src/prompts/chat/render_setup.rs:34:                    .justify_center()
src/prompts/chat/render_setup.rs:58:                    .text_center()
src/prompts/chat/render_setup.rs:68:                    .items_center()
src/prompts/chat/render_setup.rs:76:                            .items_center()
src/prompts/chat/render_setup.rs:77:                            .justify_center()
src/prompts/chat/render_setup.rs:134:                            .items_center()
src/prompts/chat/render_setup.rs:135:                            .justify_center()
src/prompts/chat/render_setup.rs:192:                    .items_center()
src/prompts/chat/render_setup.rs:210:            .items_center()

thinking
**Planning targeted code review**
exec
/bin/zsh -lc "cd /Users/johnlindquist/dev/script-kit-gpui && sed -n '260,760p' src/prompts/chat/render_core.rs" in /Users/johnlindquist/dev/script-kit-gpuiexec
/bin/zsh -lc "cd /Users/johnlindquist/dev/script-kit-gpui && sed -n '240,620p' src/prompts/chat/prompt.rs" in /Users/johnlindquist/dev/script-kit-gpuiexec
/bin/zsh -lc "cd /Users/johnlindquist/dev/script-kit-gpui && sed -n '1,260p' src/prompts/chat/types.rs" in /Users/johnlindquist/dev/script-kit-gpui succeeded in 51ms:

        // Process pending_submit on first render (used when Tab opens chat with query)
        // Skip if in setup mode or while providers are still loading
        if !self.needs_setup
            && !self.loading_providers
            && self.pending_submit
            && !self.input.is_empty()
        {
            self.pending_submit = false;
            logging::log(
                "CHAT",
                "Processing pending_submit - auto-submitting query from Tab",
            );
            self.handle_submit(cx);
        }

        // Process needs_initial_response on first render (used for scriptlets with pre-populated messages)
        // Skip if in setup mode or loading providers, requires built-in AI to be enabled
        if !self.needs_setup
            && !self.loading_providers
 succeeded in 51ms:
        }
        self
    }

    /// Set the default model
    pub fn with_default_model(mut self, model: String) -> Self {
        self.model = Some(model);
        self
    }

    /// Set the escape callback
    pub fn with_escape_callback(mut self, callback: ChatEscapeCallback) -> Self {
        self.on_escape = Some(callback);
        self
    }

    /// Set the continue callback
    pub fn with_continue_callback(mut self, callback: ChatContinueCallback) -> Self {
        self.on_continue = Some(callback);
        self
 succeeded in 51ms:
use super::*;
use std::borrow::Cow;
/// Available AI models for the chat
#[derive(Clone, Debug, PartialEq)]
pub struct ChatModel {
    pub id: String,
    pub name: String,
    pub provider: String,
}

impl ChatModel {
    pub fn new(
        id: impl Into<String>,
        name: impl Into<String>,
        provider: impl Into<String>,
    ) -> Self {
        Self {
            id: id.into(),
            name: name.into(),
            provider: provider.into(),

thinking
**Planning test updates**
exec
/bin/zsh -lc "cd /Users/johnlindquist/dev/script-kit-gpui && sed -n '1,320p' src/prompts/chat/tests.rs" in /Users/johnlindquist/dev/script-kit-gpui succeeded in 51ms:
use super::*;
#[cfg(test)]
#[allow(clippy::module_inception)]
mod tests {
    use std::{collections::HashMap, fs};

    use crate::protocol::ChatPromptMessage;

    use super::{
        next_chat_scroll_follow_state, next_reveal_boundary, resolve_chat_input_key_action,
        resolve_setup_card_key, should_ignore_stream_reveal_update,
        should_show_script_generation_actions, ChatInputKeyAction, ChatScrollDirection,
        ScriptGenerationAction, SetupCardAction,
    };

    #[test]
    fn resolve_setup_card_key_cycles_focus_for_tab_and_arrows() {
        assert_eq!(
            resolve_setup_card_key("tab", false, 0),
            (1, SetupCardAction::None, true)

thinking
**Inspecting script generation construction**
exec
/bin/zsh -lc 'cd /Users/johnlindquist/dev/script-kit-gpui && rg -n "show_script_generation_chat|ChatPrompt::new|with_script_generation_mode|on_show_actions|with_escape_callback|script_generation" src/app_impl/prompt_ai.rs' in /Users/johnlindquist/dev/script-kit-gpui succeeded in 50ms:
42:fn build_ai_script_generation_user_prompt(description: &str) -> String {
145:        crate::ai::ProviderMessage::user(build_ai_script_generation_user_prompt(prompt_description)),
393:            let chat_prompt = ChatPrompt::new(
405:            .with_escape_callback(escape_callback.clone())
437:        let mut chat_prompt = ChatPrompt::new(
449:        .with_escape_callback(escape_callback)
471:    pub fn show_script_generation_chat(
530:            let chat_prompt = ChatPrompt::new(
542:            .with_escape_callback(escape_callback.clone())
574:        let mut chat_prompt = ChatPrompt::new(
586:        .with_escape_callback(escape_callback)
588:        .with_builtin_system_prompt(crate::ai::script_generation::AI_SCRIPT_GENERATION_SYSTEM_PROMPT)
589:        .with_script_generation_mode(true);
664:                "state=queued attempted=shift_tab_script_generation model_id={} provider={} prompt_len={}",
791:    fn test_build_ai_script_generation_user_prompt_includes_description() {
792:        let prompt = build_ai_script_generation_user_prompt("create a weather script");
827:    fn test_ai_script_generation_system_prompt_references_scriptkit_sdk_not_legacy_kit() {

thinking
**Identifying script generation chat section**
exec
/bin/zsh -lc "cd /Users/johnlindquist/dev/script-kit-gpui && sed -n '330,740p' src/app_impl/prompt_ai.rs" in /Users/johnlindquist/dev/script-kit-gpui succeeded in 51ms:
                (g - b) / d + if g < b { 6.0 } else { 0.0 }
            } else if max == g {
                (b - r) / d + 2.0
            } else {
                (r - g) / d + 4.0
            };
            (h / 6.0, s)
        };

        vec![BoxShadow {
            color: hsla(h, s, l, shadow_config.opacity),
            offset: point(px(shadow_config.offset_x), px(shadow_config.offset_y)),
            blur_radius: px(shadow_config.blur_radius),
            spread_radius: px(shadow_config.spread_radius),
        }]
    }

    /// Show inline AI chat prompt with built-in AI provider support.
    /// This switches to the ChatPrompt view with direct AI integration (no SDK needed).
    /// Prefers Vercel AI Gateway if configured, otherwise uses the first available provider.

thinking
**Inspecting script execution flow**
exec
/bin/zsh -lc "cd /Users/johnlindquist/dev/script-kit-gpui && rg -n \"execute_script_by_path\\(|execute_interactive\\(|run_script\\(|show_script_generation_chat|ChatPrompt\" src/app_impl src/execute_script -g'*.rs'" in /Users/johnlindquist/dev/script-kit-gpuiexec
/bin/zsh -lc "cd /Users/johnlindquist/dev/script-kit-gpui && ls src/execute_script && sed -n '1,260p' src/execute_script/mod.rs" in /Users/johnlindquist/dev/script-kit-gpuiexec
/bin/zsh -lc "cd /Users/johnlindquist/dev/script-kit-gpui && rg -n \"with_.*callback\\(|set_on_show_actions|on_show_actions|on_submit\" src/prompts/chat src/app_impl -g'*.rs'" in /Users/johnlindquist/dev/script-kit-gpui succeeded in 51ms:
src/app_impl/filter_input_change.rs:432:                            self.execute_interactive(&script, cx);
src/execute_script/part_001.rs:2:    fn execute_interactive(&mut self, script: &scripts::Script, cx: &mut Context<Self>) {
src/app_impl/startup_new_actions.rs:94:                                AppView::ChatPrompt { .. } => {
src/app_impl/startup_new_actions.rs:96:                                    logging::log("KEY", "Interceptor: Cmd+K -> toggle_chat_actions (ChatPrompt)");
src/app_impl/startup_new_actions.rs:202:                                AppView::ChatPrompt { .. } => Some(ActionsDialogHost::ChatPrompt),
src/app_impl/startup_new_actions.rs:228:                                            ActionsDialogHost::ChatPrompt => {
src/app_impl/selection_fallback.rs:174:                        self.execute_interactive(&script_match.script, cx);
src/app_impl/selection_fallback.rs:238:                self.execute_interactive(&config.script, cx);
src/app_impl/selection_fallback.rs:278:                    self.execute_interactive(&config.script, cx);
src/app_impl/actions_dialog.rs:266:        // pop_focus_overlay sets pending_focus to the saved target (e.g. ChatPrompt).
src/app_impl/startup_new_arrow.rs:25:                            // This ensures ALL views (ChatPrompt, ArgPrompt, etc.) route
src/app_impl/ui_window.rs:57:            AppView::ChatPrompt { .. } => Some((ViewType::DivPrompt, 0)), // Chat prompt uses div size
src/app_impl/actions_toggle.rs:359:        use crate::actions::{ChatModelInfo, ChatPromptInfo};
src/app_impl/actions_toggle.rs:371:            self.close_actions_popup(ActionsDialogHost::ChatPrompt, window, cx);
src/app_impl/actions_toggle.rs:373:            // Get chat info from current ChatPrompt entity
src/app_impl/actions_toggle.rs:374:            let chat_info = if let AppView::ChatPrompt { entity, .. } = &self.current_view {
src/app_impl/actions_toggle.rs:376:                ChatPromptInfo {
src/app_impl/actions_toggle.rs:396:                    "toggle_chat_actions called but current view is not ChatPrompt",
src/app_impl/actions_toggle.rs:406:            // CRITICAL: Transfer focus from ChatPrompt to main focus_handle
src/app_impl/actions_toggle.rs:407:            // This prevents the ChatPrompt from receiving text input while
 succeeded in 51ms:
mod.rs
part_000.rs
part_001.rs
part_001_body
part_002.rs
/// Convert protocol TilePosition to window_control TilePosition
include!("part_000.rs");
include!("part_001.rs");
include!("part_002.rs");
 succeeded in 51ms:
src/prompts/chat/streaming.rs:23:            (self.on_submit)(self.id.clone(), text);
src/prompts/chat/render_core.rs:600:            // Note: Actions menu is now handled by parent via on_show_actions callback
src/prompts/chat/prompt.rs:13:    pub on_submit: ChatSubmitCallback,
src/prompts/chat/prompt.rs:62:    pub(super) on_show_actions: Option<ChatShowActionsCallback>,
src/prompts/chat/prompt.rs:81:        on_submit: ChatSubmitCallback,
src/prompts/chat/prompt.rs:101:            on_submit,
src/prompts/chat/prompt.rs:136:            on_show_actions: None,
src/prompts/chat/prompt.rs:145:    pub fn set_on_show_actions(&mut self, callback: ChatShowActionsCallback) {
src/prompts/chat/prompt.rs:146:        self.on_show_actions = Some(callback);
src/prompts/chat/prompt.rs:251:    pub fn with_escape_callback(mut self, callback: ChatEscapeCallback) -> Self {
src/prompts/chat/prompt.rs:257:    pub fn with_continue_callback(mut self, callback: ChatContinueCallback) -> Self {
src/prompts/chat/prompt.rs:263:    pub fn with_retry_callback(mut self, callback: ChatRetryCallback) -> Self {
src/prompts/chat/prompt.rs:410:    pub fn with_configure_callback(mut self, callback: ChatConfigureCallback) -> Self {
src/prompts/chat/prompt.rs:416:    pub fn with_claude_code_callback(mut self, callback: ChatClaudeCodeCallback) -> Self {
src/app_impl/prompt_ai.rs:405:            .with_escape_callback(escape_callback.clone())
src/app_impl/prompt_ai.rs:407:            .with_configure_callback(configure_callback)
src/app_impl/prompt_ai.rs:408:            .with_claude_code_callback(claude_code_callback);
src/app_impl/prompt_ai.rs:449:        .with_escape_callback(escape_callback)
src/app_impl/prompt_ai.rs:542:            .with_escape_callback(escape_callback.clone())
src/app_impl/prompt_ai.rs:544:            .with_configure_callback(configure_callback)

thinking
**Checking script execution details**
exec
/bin/zsh -lc "cd /Users/johnlindquist/dev/script-kit-gpui && sed -n '1,320p' src/execute_script/part_001.rs" in /Users/johnlindquist/dev/script-kit-gpui succeeded in 51ms:
impl ScriptListApp {
    fn execute_interactive(&mut self, script: &scripts::Script, cx: &mut Context<Self>) {
        include!("part_001_body/execute_interactive_merged.rs");
    }
}

thinking
**Assessing callback integration options**
exec
/bin/zsh -lc "cd /Users/johnlindquist/dev/script-kit-gpui && rg -n \"set_on_show_actions|on_show_actions|ChatShowActionsCallback|toggle_chat_actions\" src/app_impl src/prompts -g'*.rs'" in /Users/johnlindquist/dev/script-kit-gpui succeeded in 51ms:
src/app_impl/startup_new_actions.rs:96:                                    logging::log("KEY", "Interceptor: Cmd+K -> toggle_chat_actions (ChatPrompt)");
src/app_impl/startup_new_actions.rs:97:                                    this.toggle_chat_actions(cx, window);
src/app_impl/actions_toggle.rs:191:    /// Opens as a separate window (same pattern as toggle_chat_actions).
src/app_impl/actions_toggle.rs:208:            // Open actions as a separate window — same pattern as toggle_chat_actions
src/app_impl/actions_toggle.rs:236:            // Set up on_close callback — same pattern as toggle_chat_actions
src/app_impl/actions_toggle.rs:256:            // Open the actions window — same as toggle_chat_actions
src/app_impl/actions_toggle.rs:358:    pub fn toggle_chat_actions(&mut self, cx: &mut Context<Self>, window: &mut Window) {
src/app_impl/actions_toggle.rs:364:                "toggle_chat_actions called: show_actions_popup={}, actions_dialog.is_some={}",
src/app_impl/actions_toggle.rs:396:                    "toggle_chat_actions called but current view is not ChatPrompt",
src/app_impl/startup.rs:1215:                                    logging::log("KEY", "Interceptor: Cmd+K -> toggle_chat_actions (ChatPrompt)");
src/app_impl/startup.rs:1216:                                    this.toggle_chat_actions(cx, window);
src/prompts/path/prompt.rs:41:            on_show_actions: None,
src/prompts/path/prompt.rs:51:        self.on_show_actions = Some(callback);
src/prompts/path/prompt.rs:57:        self.on_show_actions = Some(callback);
src/prompts/path/prompt.rs:192:            if let Some(ref callback) = self.on_show_actions {
src/prompts/path/types.rs:79:    pub on_show_actions: Option<ShowActionsCallback>,
src/prompts/chat/render_core.rs:600:            // Note: Actions menu is now handled by parent via on_show_actions callback
src/prompts/chat/prompt.rs:62:    pub(super) on_show_actions: Option<ChatShowActionsCallback>,
src/prompts/chat/prompt.rs:136:            on_show_actions: None,
src/prompts/chat/prompt.rs:145:    pub fn set_on_show_actions(&mut self, callback: ChatShowActionsCallback) {

thinking
**Inspecting prompt callback usage**
exec
/bin/zsh -lc "cd /Users/johnlindquist/dev/script-kit-gpui && sed -n '1,260p' src/prompts/path/types.rs" in /Users/johnlindquist/dev/script-kit-gpuiexec
/bin/zsh -lc "cd /Users/johnlindquist/dev/script-kit-gpui && sed -n '1,260p' src/prompts/path/prompt.rs" in /Users/johnlindquist/dev/script-kit-gpui succeeded in 51ms:
use super::*;

/// Callback for prompt submission
/// Signature: (id: String, value: Option<String>)
pub type SubmitCallback = Arc<dyn Fn(String, Option<String>) + Send + Sync>;

/// Events emitted by PathPrompt for parent handling
/// Uses GPUI's EventEmitter pattern instead of mutex polling
#[derive(Debug, Clone)]
pub enum PathPromptEvent {
    /// Request to show actions dialog for the given path
    ShowActions(PathInfo),
    /// Request to close actions dialog
    CloseActions,
}

/// Information about a file/folder path for context-aware actions
/// Used for path-specific actions in the actions dialog
#[derive(Debug, Clone)]
pub struct PathInfo {
 succeeded in 50ms:
use super::*;

impl PathPrompt {
    pub fn new(
        id: String,
        start_path: Option<String>,
        hint: Option<String>,
        focus_handle: FocusHandle,
        on_submit: SubmitCallback,
        theme: Arc<theme::Theme>,
    ) -> Self {
        let current_path = start_path.clone().unwrap_or_else(|| {
            dirs::home_dir()
                .map(|p| p.to_string_lossy().to_string())
                .unwrap_or_else(|| "/".to_string())
        });

        logging::log(
            "PROMPTS",
            &format!("PathPrompt::new starting at: {}", current_path),

thinking
**Checking event emitter usage**
exec
/bin/zsh -lc "cd /Users/johnlindquist/dev/script-kit-gpui && rg -n \"impl EventEmitter<|emit\\(|ChatPromptEvent|PathPromptEvent\" src/prompts src/app_impl -g'*.rs'" in /Users/johnlindquist/dev/script-kit-gpui succeeded in 51ms:
src/prompts/prelude.rs:13:pub use super::path::{PathInfo, PathPrompt, PathPromptEvent, ShowActionsCallback};
src/prompts/mod.rs:65:pub use path::PathPromptEvent;
src/prompts/path/prompt.rs:178:    /// Emits PathPromptEvent::ShowActions for parent to handle
src/prompts/path/prompt.rs:190:            cx.emit(PathPromptEvent::ShowActions(path_info.clone()));
src/prompts/path/prompt.rs:200:    /// Emits PathPromptEvent::CloseActions for parent to handle
src/prompts/path/prompt.rs:204:        cx.emit(PathPromptEvent::CloseActions);
src/prompts/path/mod.rs:10://! - Parent subscribes to PathPromptEvent::ShowActions / CloseActions
src/prompts/path/mod.rs:34:    CloseActionsCallback, PathEntry, PathInfo, PathPrompt, PathPromptEvent, ShowActionsCallback,
src/prompts/path/render.rs:9:impl EventEmitter<PathPromptEvent> for PathPrompt {}
src/prompts/path/types.rs:10:pub enum PathPromptEvent {

thinking
**Planning callback integration**
codex
I located the existing `PathPrompt` event/callback pattern and I’m checking the chat prompt host loop for how prompt callbacks are consumed. That will determine whether we should use a direct callback or a channel bridge for run-script.
exec
/bin/zsh -lc "cd /Users/johnlindquist/dev/script-kit-gpui && rg -n \"inline_chat_escape|inline_chat_configure|inline_chat_claude|try_recv\\(|show_script_generation_chat|AppView::ChatPrompt\" src/app_impl/startup.rs src/app_impl/startup_new_state.rs src/app_impl/startup_new_tab.rs src/app_impl/startup_new_actions.rs -g'*.rs'" in /Users/johnlindquist/dev/script-kit-gpuiexec
/bin/zsh -lc "cd /Users/johnlindquist/dev/script-kit-gpui && sed -n '430,860p' src/app_impl/startup.rs" in /Users/johnlindquist/dev/script-kit-gpui succeeded in 50ms:
src/app_impl/startup_new_actions.rs:94:                                AppView::ChatPrompt { .. } => {
src/app_impl/startup_new_actions.rs:202:                                AppView::ChatPrompt { .. } => Some(ActionsDialogHost::ChatPrompt),
src/app_impl/startup_new_state.rs:11:        let (inline_chat_escape_tx, inline_chat_escape_rx) = mpsc::sync_channel(4);
src/app_impl/startup_new_state.rs:13:        let (inline_chat_configure_tx, inline_chat_configure_rx) = mpsc::sync_channel(4);
src/app_impl/startup_new_state.rs:15:        let (inline_chat_claude_code_tx, inline_chat_claude_code_rx) = mpsc::sync_channel(4);
src/app_impl/startup_new_state.rs:195:            inline_chat_escape_sender: inline_chat_escape_tx,
src/app_impl/startup_new_state.rs:196:            inline_chat_escape_receiver: inline_chat_escape_rx,
src/app_impl/startup_new_state.rs:198:            inline_chat_configure_sender: inline_chat_configure_tx,
src/app_impl/startup_new_state.rs:199:            inline_chat_configure_receiver: inline_chat_configure_rx,
src/app_impl/startup_new_state.rs:201:            inline_chat_claude_code_sender: inline_chat_claude_code_tx,
src/app_impl/startup_new_state.rs:202:            inline_chat_claude_code_receiver: inline_chat_claude_code_rx,
src/app_impl/startup_new_tab.rs:166:                            if let AppView::ChatPrompt { entity, .. } = &this.current_view {
src/app_impl/startup_new_tab.rs:188:                                    this.show_script_generation_chat(Some(query), cx);
src/app_impl/startup.rs:297:        let (inline_chat_escape_tx, inline_chat_escape_rx) = mpsc::sync_channel(4);
src/app_impl/startup.rs:299:        let (inline_chat_configure_tx, inline_chat_configure_rx) = mpsc::sync_channel(4);
src/app_impl/startup.rs:301:        let (inline_chat_claude_code_tx, inline_chat_claude_code_rx) = mpsc::sync_channel(4);
src/app_impl/startup.rs:481:            inline_chat_escape_sender: inline_chat_escape_tx,
src/app_impl/startup.rs:482:            inline_chat_escape_receiver: inline_chat_escape_rx,
src/app_impl/startup.rs:484:            inline_chat_configure_sender: inline_chat_configure_tx,
src/app_impl/startup.rs:485:            inline_chat_configure_receiver: inline_chat_configure_rx,
 succeeded in 51ms:
            // Navigation coalescing for rapid arrow key events
            nav_coalescer: NavCoalescer::new(),
            // Wheel scroll accumulator starts at 0
            wheel_accum: 0.0,
            // Window focus tracking - for detecting focus lost and auto-dismissing prompts
            was_window_focused: false,
            // Pin state - when true, window stays open on blur
            is_pinned: false,
            // Pending focus: start with MainFilter since that's what we want focused initially
            // DEPRECATED: Use focus_coordinator instead. This remains for gradual migration.
            pending_focus: Some(FocusTarget::MainFilter),
            // Focus coordinator: unified focus management with push/pop overlay semantics
            focus_coordinator: focus_coordinator::FocusCoordinator::with_main_filter_focus(),
            // Scroll stabilization: track last scrolled index for each handle
            last_scrolled_main: None,
            last_scrolled_arg: None,
            last_scrolled_clipboard: None,
            last_scrolled_window: None,
            last_scrolled_design_gallery: None,
            // Show warning banner when bun is not available

thinking
**Locating inline chat receiver polling**
exec
/bin/zsh -lc "cd /Users/johnlindquist/dev/script-kit-gpui && rg -n \"inline_chat_escape_receiver|inline_chat_configure_receiver|inline_chat_claude_code_receiver|try_recv\\(\\)\" src/app_impl -g'*.rs'" in /Users/johnlindquist/dev/script-kit-gpui succeeded in 50ms:
src/app_impl/filter_input_change.rs:194:                                    while let Ok(event) = rx.try_recv() {
src/app_impl/filter_input_change.rs:320:                            while let Ok(event) = rx.try_recv() {
src/app_impl/startup.rs:482:            inline_chat_escape_receiver: inline_chat_escape_rx,
src/app_impl/startup.rs:485:            inline_chat_configure_receiver: inline_chat_configure_rx,
src/app_impl/startup.rs:488:            inline_chat_claude_code_receiver: inline_chat_claude_code_rx,
src/app_impl/startup_new_state.rs:196:            inline_chat_escape_receiver: inline_chat_escape_rx,
src/app_impl/startup_new_state.rs:199:            inline_chat_configure_receiver: inline_chat_configure_rx,
src/app_impl/startup_new_state.rs:202:            inline_chat_claude_code_receiver: inline_chat_claude_code_rx,

thinking
**Inspecting input change handling**
exec
/bin/zsh -lc "cd /Users/johnlindquist/dev/script-kit-gpui && sed -n '120,420p' src/app_impl/filter_input_change.rs" in /Users/johnlindquist/dev/script-kit-gpui succeeded in 51ms:

                    // Update query immediately for responsive UI
                    *query = new_text.clone();
                    *selected_index = 0;

                    // CRITICAL: Increment generation and cancel previous search
                    // This ensures stale results are ignored AND mdfind process is killed
                    self.file_search_gen += 1;
                    let gen = self.file_search_gen;
                    logging::log("SEARCH", &format!("Generation incremented to {}", gen));

                    // Cancel any in-flight search by setting the cancel token
                    if let Some(cancel) = self.file_search_cancel.take() {
                        cancel.store(true, std::sync::atomic::Ordering::Relaxed);
                    }

                    // Cancel existing debounce task (drops the Task, stopping the async work)
                    self.file_search_debounce_task = None;

                    // Check if this is a directory path with potential filter

thinking
**Searching for message handling**
exec
/bin/zsh -lc "cd /Users/johnlindquist/dev/script-kit-gpui && rg -n \"inline_chat_escape_receiver|inline_chat_configure_receiver|inline_chat_claude_code_receiver|api_key_completion_receiver\" src -g'*.rs'" in /Users/johnlindquist/dev/script-kit-gpui succeeded in 51ms:
src/main_sections/app_state.rs:254:    api_key_completion_receiver: mpsc::Receiver<(String, bool)>,
src/main_sections/app_state.rs:263:    inline_chat_escape_receiver: mpsc::Receiver<()>,
src/main_sections/app_state.rs:269:    inline_chat_configure_receiver: mpsc::Receiver<()>,
src/main_sections/app_state.rs:275:    inline_chat_claude_code_receiver: mpsc::Receiver<()>,
src/main_sections/render_impl.rs:35:        if let Ok((provider, success)) = self.api_key_completion_receiver.try_recv() {
src/main_sections/render_impl.rs:48:        if self.inline_chat_escape_receiver.try_recv().is_ok() {
src/main_sections/render_impl.rs:58:        if self.inline_chat_configure_receiver.try_recv().is_ok() {
src/main_sections/render_impl.rs:76:        if self.inline_chat_claude_code_receiver.try_recv().is_ok() {
src/app_impl/startup_new_state.rs:191:            api_key_completion_receiver: api_key_rx,
src/app_impl/startup_new_state.rs:196:            inline_chat_escape_receiver: inline_chat_escape_rx,
src/app_impl/startup_new_state.rs:199:            inline_chat_configure_receiver: inline_chat_configure_rx,
src/app_impl/startup_new_state.rs:202:            inline_chat_claude_code_receiver: inline_chat_claude_code_rx,
src/app_impl/startup.rs:477:            api_key_completion_receiver: api_key_rx,
src/app_impl/startup.rs:482:            inline_chat_escape_receiver: inline_chat_escape_rx,
src/app_impl/startup.rs:485:            inline_chat_configure_receiver: inline_chat_configure_rx,
src/app_impl/startup.rs:488:            inline_chat_claude_code_receiver: inline_chat_claude_code_rx,

thinking
**Assessing script execution entrypoints**
exec
/bin/zsh -lc "cd /Users/johnlindquist/dev/script-kit-gpui && rg -n \"fn .*script.*path|pub fn .*execute|run_saved_script|execute_script_by_path|execute_interactive|open_script|run_script\" src/execute_script src/app_impl src -g'*.rs' | head -n 200" in /Users/johnlindquist/dev/script-kit-gpui succeeded in 51ms:
src/execute_script/part_000.rs:104:fn format_missing_interactive_session_error(script_name: &str, script_path: &std::path::Path) -> String {
src/app_impl/filter_input_change.rs:432:                            self.execute_interactive(&script, cx);
src/execute_script/part_001.rs:2:    fn execute_interactive(&mut self, script: &scripts::Script, cx: &mut Context<Self>) {
src/execute_script/part_001.rs:3:        include!("part_001_body/execute_interactive_merged.rs");
src/app_impl/selection_fallback.rs:174:                        self.execute_interactive(&script_match.script, cx);
src/app_impl/selection_fallback.rs:206:    pub fn execute_fallback_item(
src/app_impl/selection_fallback.rs:238:                self.execute_interactive(&config.script, cx);
src/app_impl/selection_fallback.rs:250:    pub fn execute_selected_fallback(&mut self, cx: &mut Context<Self>) {
src/app_impl/selection_fallback.rs:278:                    self.execute_interactive(&config.script, cx);
src/menu_executor/part_000.rs:413:pub fn execute_menu_action(bundle_id: &str, menu_path: &[String]) -> Result<()> {
src/app_impl/execution_scripts.rs:99:            self.execute_interactive(&script, cx);
src/app_impl/execution_scripts.rs:184:        match executor::run_scriptlet(&exec_scriptlet, options) {
src/app_impl/execution_scripts.rs:268:    pub(crate) fn execute_script_by_path(&mut self, path: &str, cx: &mut Context<Self>) {
src/app_impl/execution_scripts.rs:294:            self.execute_interactive(&script_clone, cx);
src/app_impl/execution_scripts.rs:324:            self.execute_interactive(&script, cx);
src/app_impl/execution_scripts.rs:341:    pub fn execute_by_command_id_or_path(
src/app_impl/execution_scripts.rs:444:        self.execute_script_by_path(command_id, cx);
src/app_impl/shortcut_recorder.rs:4:    pub(crate) fn edit_script(&mut self, path: &std::path::Path) {
src/app_impl/chat_actions.rs:4:    pub fn execute_chat_action(&mut self, action_id: &str, cx: &mut Context<Self>) {
src/app_actions/handle_action.rs:562:            "run_script" => {

thinking
**Exploring callback channel reuse**
exec
/bin/zsh -lc "cd /Users/johnlindquist/dev/script-kit-gpui && rg -n \"WeakEntity<ScriptListApp>|Entity<ScriptListApp>|static .*ScriptListApp|global.*app|app_entity|downgrade\\(\\)\" src/main_sections src/app_impl src/main_entry -g'*.rs' | head -n 200" in /Users/johnlindquist/dev/script-kit-gpui succeeded in 51ms:
src/main_entry/runtime_watchers_scheduler.rs:8:            let app_entity_for_config = app_entity.clone();
src/main_entry/runtime_watchers_scheduler.rs:28:                            app_entity_for_config.update(cx, |view, ctx| {
src/main_entry/runtime_watchers_scheduler.rs:45:            let app_entity_for_scripts = app_entity.clone();
src/main_entry/runtime_watchers_scheduler.rs:75:                                        app_entity_for_scripts.update(cx, |view, ctx| {
src/main_entry/runtime_watchers_scheduler.rs:89:                                        app_entity_for_scripts.update(cx, |view, ctx| {
src/main_entry/runtime_watchers_scheduler.rs:102:                                        app_entity_for_scripts.update(cx, |view, ctx| {
src/main_entry/runtime_watchers_scheduler.rs:109:                                        app_entity_for_scripts.update(cx, |view, ctx| {
src/main_entry/runtime_watchers_scheduler.rs:125:                                    app_entity_for_scripts.update(cx, |view, ctx| {
src/main_entry/runtime_watchers_scheduler.rs:147:            let app_entity_for_apps = app_entity.clone();
src/main_entry/runtime_watchers_scheduler.rs:178:                        app_entity_for_apps.update(cx, |view, ctx| {
src/main_entry/runtime_watchers_scheduler.rs:305:            let app_entity_for_test = app_entity.clone();
src/main_entry/runtime_watchers_scheduler.rs:322:                                    let app_entity_inner = app_entity_for_test.clone();
src/main_entry/runtime_watchers_scheduler.rs:324:                                        app_entity_inner.update(cx, |view, ctx| {
src/app_impl/alias_input.rs:197:                    let app_entity = cx.entity().downgrade();
src/app_impl/alias_input.rs:201:                            if let Some(app) = app_entity.upgrade() {
src/app_impl/alias_input.rs:217:                    let app_entity = cx.entity().downgrade();
src/app_impl/alias_input.rs:221:                            if let Some(app) = app_entity.upgrade() {
src/main_sections/window_visibility.rs:20:/// * `app_entity` - The ScriptListApp entity
src/main_sections/window_visibility.rs:24:    app_entity: Entity<ScriptListApp>,
src/main_sections/window_visibility.rs:117:    app_entity.update(cx, |view, ctx| {

thinking
**Planning callback closure with app entity update**
exec
/bin/zsh -lc "cd /Users/johnlindquist/dev/script-kit-gpui && rg -n \"let app_entity = cx\\.entity\\(\\)|downgrade\\(\\)|Arc::new\\(move.*app\\.update|callback.*app_entity|with_.*callback\\(.*Arc::new\\(move\" src/app_impl src/prompts -g'*.rs' | head -n 200" in /Users/johnlindquist/dev/script-kit-gpui succeeded in 52ms:
src/app_impl/alias_input.rs:197:                    let app_entity = cx.entity().downgrade();
src/app_impl/alias_input.rs:217:                    let app_entity = cx.entity().downgrade();
src/app_impl/startup_new_actions.rs:3:        let app_entity_for_actions = cx.entity().downgrade();
src/app_impl/startup_new_arrow.rs:3:        let app_entity_for_arrows = cx.entity().downgrade();
src/app_impl/startup_new_arrow.rs:313:        let app_entity_for_home_end = cx.entity().downgrade();
src/app_impl/actions_toggle.rs:62:            let app_entity = cx.entity().clone();
src/app_impl/actions_toggle.rs:237:            let app_entity = cx.entity().clone();
src/app_impl/actions_toggle.rs:427:            let app_entity = cx.entity().clone();
src/prompts/env/render.rs:269:                        let handle_delete = cx.entity().downgrade();
src/prompts/env/render.rs:338:                let handle = cx.entity().downgrade();
src/prompts/env/render.rs:339:                let handle_cancel = cx.entity().downgrade();
src/app_impl/startup.rs:553:        let app_entity_for_tab = cx.entity().downgrade();
src/app_impl/startup.rs:755:        let app_entity_for_arrows = cx.entity().downgrade();
src/app_impl/startup.rs:1065:        let app_entity_for_home_end = cx.entity().downgrade();
src/app_impl/startup.rs:1122:        let app_entity_for_actions = cx.entity().downgrade();
src/prompts/path/render.rs:123:        let handle_select = cx.entity().downgrade();
src/prompts/path/render.rs:124:        let handle_actions = cx.entity().downgrade();
src/app_impl/startup_new_tab.rs:4:        let app_entity_for_tab = cx.entity().downgrade();
src/app_impl/shortcut_recorder.rs:241:            let app_entity = cx.entity().downgrade();
src/app_impl/shortcut_recorder.rs:310:                    let app_entity = cx.entity().downgrade();

thinking
**Weighing callback design and cross-entity updates**
exec
/bin/zsh -lc "cd /Users/johnlindquist/dev/script-kit-gpui && sed -n '150,280p' src/app_impl/alias_input.rs" in /Users/johnlindquist/dev/script-kit-gpui succeeded in 50ms:
        let state = self.alias_input_state.as_ref()?;

        // Create entity if needed (only once per show)
        if self.alias_input_entity.is_none() {
            let command_id = state.command_id.clone();
            let command_name = state.command_name.clone();
            let current_alias = if state.alias_text.is_empty() {
                None
            } else {
                Some(state.alias_text.clone())
            };
            let theme = std::sync::Arc::clone(&self.theme);

            let input_entity = cx.new(move |cx| {
                // Create the alias input with its own focus handle from its own context
                // This is CRITICAL for keyboard events to work
                AliasInput::new(cx, theme)
                    .with_command_name(command_name)
                    .with_command_id(command_id)
                    .with_current_alias(current_alias)

thinking
**Planning event-driven script execution**
exec
/bin/zsh -lc "cd /Users/johnlindquist/dev/script-kit-gpui && rg -n \"cx\\.subscribe\\(|subscribe\\(&.*PathPromptEvent|PathPromptEvent::|EventEmitter\" src/app_impl src/main_sections src/prompts -g'*.rs'" in /Users/johnlindquist/dev/script-kit-gpui succeeded in 51ms:
src/prompts/path/prompt.rs:178:    /// Emits PathPromptEvent::ShowActions for parent to handle
src/prompts/path/prompt.rs:190:            cx.emit(PathPromptEvent::ShowActions(path_info.clone()));
src/prompts/path/prompt.rs:200:    /// Emits PathPromptEvent::CloseActions for parent to handle
src/prompts/path/prompt.rs:204:        cx.emit(PathPromptEvent::CloseActions);
src/prompts/path/render.rs:9:impl EventEmitter<PathPromptEvent> for PathPrompt {}
src/prompts/path/mod.rs:9://! Uses GPUI EventEmitter pattern for actions dialog communication:
src/prompts/path/mod.rs:10://! - Parent subscribes to PathPromptEvent::ShowActions / CloseActions
src/prompts/path/mod.rs:14:    div, prelude::*, uniform_list, Context, EventEmitter, FocusHandle, Focusable, Render,
src/prompts/path/types.rs:8:/// Uses GPUI's EventEmitter pattern instead of mutex polling

thinking
**Planning callback redesign and UI style consistency**
exec
/bin/zsh -lc "cd /Users/johnlindquist/dev/script-kit-gpui && rg -n \"render_button|hover|active|text_size|px\\(|py\\(|rounded\\(|text_color\\(|font_weight\" src/components/prompt_footer.rs" in /Users/johnlindquist/dev/script-kit-gpui succeeded in 50ms:
158:fn footer_button_hover_rgba(colors: PromptFooterColors) -> u32 {
162:fn footer_button_active_rgba(colors: PromptFooterColors) -> u32 {
322:            .size(px(PROMPT_FOOTER_LOGO_SIZE_PX))
323:            .ml(px(PROMPT_FOOTER_LOGO_NUDGE_X_PX))
324:            .text_color(rgb(self.colors.accent)) // Accent color (yellow/gold)
328:    fn render_button(
342:        let hover_bg = rgba(footer_button_hover_rgba(self.colors));
343:        let active_bg = rgba(footer_button_active_rgba(self.colors));
350:            .gap(px(6.))
351:            .px(px(8.))
352:            .py(px(2.))
353:            .rounded(px(4.))
357:                    .text_size(px(button_font_size))
358:                    .text_color(self.colors.accent.to_rgb())
363:                    .text_size(px(button_font_size))
364:                    .text_color(self.colors.text_muted.to_rgb())
371:                .hover(move |s| s.bg(hover_bg))
372:                .active(move |s| s.bg(active_bg));
401:            .w(px(PROMPT_FOOTER_DIVIDER_WIDTH_PX))
402:            .h(px(PROMPT_FOOTER_DIVIDER_HEIGHT_PX))
exec
/bin/zsh -lc "cd /Users/johnlindquist/dev/script-kit-gpui && sed -n '300,460p' src/components/prompt_footer.rs" in /Users/johnlindquist/dev/script-kit-gpui succeeded in 50ms:
            colors,
            on_primary_click: None,
            on_secondary_click: None,
        }
    }

    /// Set the primary button click callback
    pub fn on_primary_click(mut self, callback: FooterClickCallback) -> Self {
        self.on_primary_click = Some(Rc::new(callback));
        self
    }

    /// Set the secondary button click callback
    pub fn on_secondary_click(mut self, callback: FooterClickCallback) -> Self {
        self.on_secondary_click = Some(Rc::new(callback));
        self
    }

    /// Render the Script Kit logo (accent-colored icon, no background)
    fn render_logo(&self) -> impl IntoElement {

thinking
**Unifying button styles and adding run callback**
exec
/bin/zsh -lc "cd /Users/johnlindquist/dev/script-kit-gpui && rg -n \"run_saved_script\\(\" src -g'*.rs'" in /Users/johnlindquist/dev/script-kit-gpui succeeded in 51ms:
src/prompts/chat/actions.rs:180:                    crate::ai::script_generation::run_saved_script(&path_clone)
src/ai/script_generation.rs:151:pub(crate) fn run_saved_script(path: &Path) -> Result<()> {

thinking
**Standardizing script footer button styles**
exec
/bin/zsh -lc "cd /Users/johnlindquist/dev/script-kit-gpui && sed -n '740,920p' src/app_impl/prompt_ai.rs" in /Users/johnlindquist/dev/script-kit-gpui succeeded in 51ms:
                    }
                })
            });
        })
        .detach();
    }

    /// Rebuild the cached provider registry in a background thread.
    /// Called after config changes (API key saved, Claude Code enabled, etc.)
    pub fn rebuild_provider_registry_async(&mut self, cx: &mut Context<Self>) {
        self.cached_provider_registry = None;
        let config_clone = self.config.clone();
        let (tx, rx) = async_channel::bounded::<crate::ai::ProviderRegistry>(1);

        std::thread::spawn(move || {
            let registry =
                crate::ai::ProviderRegistry::from_environment_with_config(Some(&config_clone));
            if tx.send_blocking(registry).is_err() {
                logging::log(
                    "APP",

thinking
**Inspecting test coverage and patterns**
exec
/bin/zsh -lc "cd /Users/johnlindquist/dev/script-kit-gpui && rg -n \"run_saved_script|prepare_script_from_ai_response|cfg\\(test\\)|test_\" src/ai/script_generation.rs" in /Users/johnlindquist/dev/script-kit-gpui succeeded in 51ms:
85:    let (slug, finalized) = prepare_script_from_ai_response(normalized_prompt, &raw_response)?;
110:pub(crate) fn prepare_script_from_ai_response(
133:    let (slug, script_source) = prepare_script_from_ai_response(prompt, raw_response)?;
151:pub(crate) fn run_saved_script(path: &Path) -> Result<()> {
449:#[cfg(test)]
455:    fn test_slugify_script_name_handles_spaces_and_symbols() {
464:    fn test_extract_script_code_prefers_typescript_fence_when_multiple_blocks_exist() {
478:    fn test_extract_script_code_falls_back_to_first_fenced_block() {
488:    fn test_extract_script_code_returns_trimmed_response_when_no_fence_exists() {
494:    fn test_enforce_script_kit_conventions_adds_missing_metadata_and_import() {
505:    fn test_enforce_script_kit_conventions_keeps_existing_metadata_and_import() {
532:    fn test_has_kit_import_accepts_scriptkit_sdk_and_rejects_legacy_kit_import() {
539:    fn test_ai_script_generation_system_prompt_uses_modern_sdk_conventions() {
549:    fn test_write_generated_script_in_dir_appends_numeric_suffix_for_collisions() {
559:    fn test_prepare_script_from_ai_response_adds_conventions_when_ai_omits_them() {
563:        let (slug, source) = prepare_script_from_ai_response(prompt, response).unwrap();
572:    fn test_prepare_script_from_ai_response_extracts_typescript_fence_when_present() {
580:        let (_slug, source) = prepare_script_from_ai_response(prompt, response).unwrap();

thinking
**Scoping edits to core prompt files**
codex
I’ve mapped the integration path and I’m ready to edit. I’m claiming the chat/action/footer/app files now, then I’ll implement the run callback wiring, Cmd+Return behavior, and button style parity together.
exec
/bin/zsh -lc 'cd /Users/johnlindquist/dev/script-kit-gpui && ~/.claude/bin/swarm.ts claim --wait --id codex-save-run-fixes src/prompts/chat/actions.rs src/prompts/chat/prompt.rs src/prompts/chat/render_core.rs src/app_impl/prompt_ai.rs src/components/prompt_footer.rs src/ai/script_generation.rs' in /Users/johnlindquist/dev/script-kit-gpui succeeded in 51ms:
Claimed for codex-save-run-fixes: src/prompts/chat/actions.rs, src/prompts/chat/prompt.rs, src/prompts/chat/render_core.rs, src/app_impl/prompt_ai.rs, src/components/prompt_footer.rs, src/ai/script_generation.rs

thinking
**Adding field near on_show_actions**
file update
M /Users/johnlindquist/dev/script-kit-gpui/src/prompts/chat/prompt.rs
@@ -62,2 +62,5 @@
     pub(super) on_show_actions: Option<ChatShowActionsCallback>,
+    // Callback for running a saved generated script via parent app pipeline
+    pub(super) on_run_script:
+        Option<Arc<dyn Fn(std::path::PathBuf, &mut Context<ChatPrompt>) + Send + Sync>>,
     // Stable UUID for Claude Code CLI session continuity within this prompt's lifetime.
@@ -136,2 +139,3 @@
             on_show_actions: None,
+            on_run_script: None,
             cli_session_id: uuid::Uuid::new_v4().to_string(),
@@ -148,2 +152,11 @@
 
+    /// Set the callback for running a generated script path in the parent app.
+    pub fn with_run_script_callback(
+        mut self,
+        callback: impl Fn(std::path::PathBuf, &mut Context<Self>) + Send + Sync + 'static,
+    ) -> Self {
+        self.on_run_script = Some(Arc::new(callback));
+        self
+    }
+
     /// Start the cursor blink timer
apply_patch(auto_approved=true) exited 0 in 13ms:
Success. Updated the following files:
M /Users/johnlindquist/dev/script-kit-gpui/src/prompts/chat/prompt.rs
file update:
diff --git a/src/prompts/chat/prompt.rs b/src/prompts/chat/prompt.rs
index 4ef4ac1aae4123a9bdd9771500998f87f424660b..78a8d8354e9e50914fdbcf1cc0fce0292b4feac2
--- a/src/prompts/chat/prompt.rs
+++ b/src/prompts/chat/prompt.rs
@@ -60,6 +60,9 @@
     pub(super) on_claude_code: Option<ChatClaudeCodeCallback>,
     // Callback for showing actions dialog (handled by parent)
     pub(super) on_show_actions: Option<ChatShowActionsCallback>,
+    // Callback for running a saved generated script via parent app pipeline
+    pub(super) on_run_script:
+        Option<Arc<dyn Fn(std::path::PathBuf, &mut Context<ChatPrompt>) + Send + Sync>>,
     // Stable UUID for Claude Code CLI session continuity within this prompt's lifetime.
     // Generated once at construction so all messages share the same session.
     pub(super) cli_session_id: String,
@@ -134,6 +137,7 @@
             on_configure: None,
             on_claude_code: None,
             on_show_actions: None,
+            on_run_script: None,
             cli_session_id: uuid::Uuid::new_v4().to_string(),
             pending_image: None,
             pending_image_render: None,
@@ -146,6 +150,15 @@
         self.on_show_actions = Some(callback);
     }
 
+    /// Set the callback for running a generated script path in the parent app.
+    pub fn with_run_script_callback(
+        mut self,
+        callback: impl Fn(std::path::PathBuf, &mut Context<Self>) + Send + Sync + 'static,
+    ) -> Self {
+        self.on_run_script = Some(Arc::new(callback));
+        self
+    }
+
     /// Start the cursor blink timer
     pub fn start_cursor_blink(&mut self, cx: &mut Context<Self>) {
         cx.spawn(async move |this, cx| {

file update:
diff --git a/src/prompts/chat/prompt.rs b/src/prompts/chat/prompt.rs
index 4ef4ac1aae4123a9bdd9771500998f87f424660b..78a8d8354e9e50914fdbcf1cc0fce0292b4feac2
--- a/src/prompts/chat/prompt.rs
+++ b/src/prompts/chat/prompt.rs
@@ -60,6 +60,9 @@
     pub(super) on_claude_code: Option<ChatClaudeCodeCallback>,
     // Callback for showing actions dialog (handled by parent)
     pub(super) on_show_actions: Option<ChatShowActionsCallback>,
+    // Callback for running a saved generated script via parent app pipeline
+    pub(super) on_run_script:
+        Option<Arc<dyn Fn(std::path::PathBuf, &mut Context<ChatPrompt>) + Send + Sync>>,
     // Stable UUID for Claude Code CLI session continuity within this prompt's lifetime.
     // Generated once at construction so all messages share the same session.
     pub(super) cli_session_id: String,
@@ -134,6 +137,7 @@
             on_configure: None,
             on_claude_code: None,
             on_show_actions: None,
+            on_run_script: None,
             cli_session_id: uuid::Uuid::new_v4().to_string(),
             pending_image: None,
             pending_image_render: None,
@@ -146,6 +150,15 @@
         self.on_show_actions = Some(callback);
     }
 
+    /// Set the callback for running a generated script path in the parent app.
+    pub fn with_run_script_callback(
+        mut self,
+        callback: impl Fn(std::path::PathBuf, &mut Context<Self>) + Send + Sync + 'static,
+    ) -> Self {
+        self.on_run_script = Some(Arc::new(callback));
+        self
+    }
+
     /// Start the cursor blink timer
     pub fn start_cursor_blink(&mut self, cx: &mut Context<Self>) {
         cx.spawn(async move |this, cx| {


thinking
**Refactoring action handler to callback**
file update
M /Users/johnlindquist/dev/script-kit-gpui/src/prompts/chat/actions.rs
@@ -174,44 +174,32 @@
             self.set_script_generation_status(false, format!("Running {}...", script_name), cx);
-
-            let path_clone = script_path.clone();
-            let name_clone = script_name.clone();
-            cx.spawn(async move |this, cx| {
-                let run_result = std::thread::spawn(move || {
-                    crate::ai::script_generation::run_saved_script(&path_clone)
-                })
-                .join()
-                .map_err(|_| anyhow::anyhow!("run thread panicked"))
-                .and_then(|r| r);
-
-                let _ = cx.update(|cx| {
-                    this.update(cx, |chat, cx| match run_result {
-                        Ok(()) => {
-                            chat.set_script_generation_status(
-                                false,
-                                format!("Saved and running {}", name_clone),
-                                cx,
-                            );
-                            logging::log(
-                                "CHAT_SCRIPT_GEN",
-                                &format!("state=run_ok action={:?} script={}", action, name_clone),
-                            );
-                        }
-                        Err(error) => {
-                            chat.set_script_generation_status(
-                                true,
-                                format!("Saved {} but failed to run: {}", name_clone, error),
-                                cx,
-                            );
-                            logging::log(
-                                "CHAT_SCRIPT_GEN",
-                                &format!(
-                                    "state=run_failed action={:?} script={} error={}",
-                                    action, name_clone, error
-                                ),
-                            );
-                        }
-                    })
-                });
-            })
-            .detach();
+            if let Some(ref callback) = self.on_run_script {
+                callback(script_path.clone(), cx);
+                self.set_script_generation_status(
+                    false,
+                    format!("Saved and running {}", script_name),
+                    cx,
+                );
+                logging::log(
+                    "CHAT_SCRIPT_GEN",
+                    &format!(
+                        "state=run_dispatched action={:?} path={}",
+                        action,
+                        script_path.display()
+                    ),
+                );
+            } else {
+                self.set_script_generation_status(
+                    true,
+                    format!("Saved {} but run action is unavailable", script_name),
+                    cx,
+                );
+                logging::log(
+                    "CHAT_SCRIPT_GEN",
+                    &format!(
+                        "state=run_dispatch_failed action={:?} path={} reason=missing_callback",
+                        action,
+                        script_path.display()
+                    ),
+                );
+            }
             return;
apply_patch(auto_approved=true) exited 0 in 21ms:
Success. Updated the following files:
M /Users/johnlindquist/dev/script-kit-gpui/src/prompts/chat/actions.rs
file update:
diff --git a/src/prompts/chat/actions.rs b/src/prompts/chat/actions.rs
index 8ae41af43235d867176126f8de45f9fc8f3f2cbf..4d01323e1d134ef8e6f56be60d0a1eee086247e7
--- a/src/prompts/chat/actions.rs
+++ b/src/prompts/chat/actions.rs
@@ -172,48 +172,36 @@
 
         if action.should_run_after_save() {
             self.set_script_generation_status(false, format!("Running {}...", script_name), cx);
-
-            let path_clone = script_path.clone();
-            let name_clone = script_name.clone();
-            cx.spawn(async move |this, cx| {
-                let run_result = std::thread::spawn(move || {
-                    crate::ai::script_generation::run_saved_script(&path_clone)
-                })
-                .join()
-                .map_err(|_| anyhow::anyhow!("run thread panicked"))
-                .and_then(|r| r);
-
-                let _ = cx.update(|cx| {
-                    this.update(cx, |chat, cx| match run_result {
-                        Ok(()) => {
-                            chat.set_script_generation_status(
-                                false,
-                                format!("Saved and running {}", name_clone),
-                                cx,
-                            );
-                            logging::log(
-                                "CHAT_SCRIPT_GEN",
-                                &format!("state=run_ok action={:?} script={}", action, name_clone),
-                            );
-                        }
-                        Err(error) => {
-                            chat.set_script_generation_status(
-                                true,
-                                format!("Saved {} but failed to run: {}", name_clone, error),
-                                cx,
-                            );
-                            logging::log(
-                                "CHAT_SCRIPT_GEN",
-                                &format!(
-                                    "state=run_failed action={:?} script={} error={}",
-                                    action, name_clone, error
-                                ),
-                            );
-                        }
-                    })
-                });
-            })
-            .detach();
+            if let Some(ref callback) = self.on_run_script {
+                callback(script_path.clone(), cx);
+                self.set_script_generation_status(
+                    false,
+                    format!("Saved and running {}", script_name),
+                    cx,
+                );
+                logging::log(
+                    "CHAT_SCRIPT_GEN",
+                    &format!(
+                        "state=run_dispatched action={:?} path={}",
+                        action,
+                        script_path.display()
+                    ),
+                );
+            } else {
+                self.set_script_generation_status(
+                    true,
+                    format!("Saved {} but run action is unavailable", script_name),
+                    cx,
+                );
+                logging::log(
+                    "CHAT_SCRIPT_GEN",
+                    &format!(
+                        "state=run_dispatch_failed action={:?} path={} reason=missing_callback",
+                        action,
+                        script_path.display()
+                    ),
+                );
+            }
             return;
         }
 
diff --git a/src/prompts/chat/prompt.rs b/src/prompts/chat/prompt.rs
index 4ef4ac1aae4123a9bdd9771500998f87f424660b..78a8d8354e9e50914fdbcf1cc0fce0292b4feac2
--- a/src/prompts/chat/prompt.rs
+++ b/src/prompts/chat/prompt.rs
@@ -60,6 +60,9 @@
     pub(super) on_claude_code: Option<ChatClaudeCodeCallback>,
     // Callback for showing actions dialog (handled by parent)
     pub(super) on_show_actions: Option<ChatShowActionsCallback>,
+    // Callback for running a saved generated script via parent app pipeline
+    pub(super) on_run_script:
+        Option<Arc<dyn Fn(std::path::PathBuf, &mut Context<ChatPrompt>) + Send + Sync>>,
     // Stable UUID for Claude Code CLI session continuity within this prompt's lifetime.
     // Generated once at construction so all messages share the same session.
     pub(super) cli_session_id: String,
@@ -134,6 +137,7 @@
             on_configure: None,
             on_claude_code: None,
             on_show_actions: None,
+            on_run_script: None,
             cli_session_id: uuid::Uuid::new_v4().to_string(),
             pending_image: None,
             pending_image_render: None,
@@ -146,6 +150,15 @@
         self.on_show_actions = Some(callback);
     }
 
+    /// Set the callback for running a generated script path in the parent app.
+    pub fn with_run_script_callback(
+        mut self,
+        callback: impl Fn(std::path::PathBuf, &mut Context<Self>) + Send + Sync + 'static,
+    ) -> Self {
+        self.on_run_script = Some(Arc::new(callback));
+        self
+    }
+
     /// Start the cursor blink timer
     pub fn start_cursor_blink(&mut self, cx: &mut Context<Self>) {
         cx.spawn(async move |this, cx| {

file update:
diff --git a/src/prompts/chat/actions.rs b/src/prompts/chat/actions.rs
index 8ae41af43235d867176126f8de45f9fc8f3f2cbf..4d01323e1d134ef8e6f56be60d0a1eee086247e7
--- a/src/prompts/chat/actions.rs
+++ b/src/prompts/chat/actions.rs
@@ -172,48 +172,36 @@
 
         if action.should_run_after_save() {
             self.set_script_generation_status(false, format!("Running {}...", script_name), cx);
-
-            let path_clone = script_path.clone();
-            let name_clone = script_name.clone();
-            cx.spawn(async move |this, cx| {
-                let run_result = std::thread::spawn(move || {
-                    crate::ai::script_generation::run_saved_script(&path_clone)
-                })
-                .join()
-                .map_err(|_| anyhow::anyhow!("run thread panicked"))
-                .and_then(|r| r);
-
-                let _ = cx.update(|cx| {
-                    this.update(cx, |chat, cx| match run_result {
-                        Ok(()) => {
-                            chat.set_script_generation_status(
-                                false,
-                                format!("Saved and running {}", name_clone),
-                                cx,
-                            );
-                            logging::log(
-                                "CHAT_SCRIPT_GEN",
-                                &format!("state=run_ok action={:?} script={}", action, name_clone),
-                            );
-                        }
-                        Err(error) => {
-                            chat.set_script_generation_status(
-                                true,
-                                format!("Saved {} but failed to run: {}", name_clone, error),
-                                cx,
-                            );
-                            logging::log(
-                                "CHAT_SCRIPT_GEN",
-                                &format!(
-                                    "state=run_failed action={:?} script={} error={}",
-                                    action, name_clone, error
-                                ),
-                            );
-                        }
-                    })
-                });
-            })
-            .detach();
+            if let Some(ref callback) = self.on_run_script {
+                callback(script_path.clone(), cx);
+                self.set_script_generation_status(
+                    false,
+                    format!("Saved and running {}", script_name),
+                    cx,
+                );
+                logging::log(
+                    "CHAT_SCRIPT_GEN",
+                    &format!(
+                        "state=run_dispatched action={:?} path={}",
+                        action,
+                        script_path.display()
+                    ),
+                );
+            } else {
+                self.set_script_generation_status(
+                    true,
+                    format!("Saved {} but run action is unavailable", script_name),
+                    cx,
+                );
+                logging::log(
+                    "CHAT_SCRIPT_GEN",
+                    &format!(
+                        "state=run_dispatch_failed action={:?} path={} reason=missing_callback",
+                        action,
+                        script_path.display()
+                    ),
+                );
+            }
             return;
         }
 
diff --git a/src/prompts/chat/prompt.rs b/src/prompts/chat/prompt.rs
index 4ef4ac1aae4123a9bdd9771500998f87f424660b..78a8d8354e9e50914fdbcf1cc0fce0292b4feac2
--- a/src/prompts/chat/prompt.rs
+++ b/src/prompts/chat/prompt.rs
@@ -60,6 +60,9 @@
     pub(super) on_claude_code: Option<ChatClaudeCodeCallback>,
     // Callback for showing actions dialog (handled by parent)
     pub(super) on_show_actions: Option<ChatShowActionsCallback>,
+    // Callback for running a saved generated script via parent app pipeline
+    pub(super) on_run_script:
+        Option<Arc<dyn Fn(std::path::PathBuf, &mut Context<ChatPrompt>) + Send + Sync>>,
     // Stable UUID for Claude Code CLI session continuity within this prompt's lifetime.
     // Generated once at construction so all messages share the same session.
     pub(super) cli_session_id: String,
@@ -134,6 +137,7 @@
             on_configure: None,
             on_claude_code: None,
             on_show_actions: None,
+            on_run_script: None,
             cli_session_id: uuid::Uuid::new_v4().to_string(),
             pending_image: None,
             pending_image_render: None,
@@ -146,6 +150,15 @@
         self.on_show_actions = Some(callback);
     }
 
+    /// Set the callback for running a generated script path in the parent app.
+    pub fn with_run_script_callback(
+        mut self,
+        callback: impl Fn(std::path::PathBuf, &mut Context<Self>) + Send + Sync + 'static,
+    ) -> Self {
+        self.on_run_script = Some(Arc::new(callback));
+        self
+    }
+
     /// Start the cursor blink timer
     pub fn start_cursor_blink(&mut self, cx: &mut Context<Self>) {
         cx.spawn(async move |this, cx| {


thinking
**Refactoring footer button and key handling**
file update
M /Users/johnlindquist/dev/script-kit-gpui/src/prompts/chat/render_core.rs
@@ -34,6 +34,14 @@
         action: ScriptGenerationAction,
-        accent_color: u32,
-        muted_color: u32,
+        footer_colors: PromptFooterColors,
         cx: &mut Context<Self>,
     ) -> AnyElement {
+        let button_font_size =
+            crate::components::prompt_footer::footer_button_font_size_px(&self.theme);
+        let hover_bg = rgba(crate::components::prompt_footer::footer_button_hover_rgba(
+            footer_colors,
+        ));
+        let active_bg = rgba(crate::components::prompt_footer::footer_button_active_rgba(
+            footer_colors,
+        ));
+
         div()
@@ -48,5 +56,17 @@
             .cursor_pointer()
-            .child(div().text_xs().text_color(rgb(accent_color)).child(label))
+            .hover(move |d| d.bg(hover_bg))
+            .active(move |d| d.bg(active_bg))
+            .child(
+                div()
+                    .text_size(px(button_font_size))
+                    .text_color(rgb(footer_colors.accent))
+                    .child(label),
+            )
             .when_some(shortcut, |d, shortcut| {
-                d.child(div().text_xs().text_color(rgb(muted_color)).child(shortcut))
+                d.child(
+                    div()
+                        .text_size(px(button_font_size))
+                        .text_color(rgb(footer_colors.text_muted))
+                        .child(shortcut),
+                )
             })
@@ -111,6 +131,5 @@
                 "Save and Run",
-                None,
+                Some("⌘↵"),
                 ScriptGenerationAction::SaveAndRun,
-                footer_colors.accent,
-                footer_colors.text_muted,
+                footer_colors,
                 cx,
@@ -196,4 +215,3 @@
                     ScriptGenerationAction::Save,
-                    footer_colors.accent,
-                    footer_colors.text_muted,
+                    footer_colors,
                     cx,
@@ -205,4 +223,3 @@
                     ScriptGenerationAction::Run,
-                    footer_colors.accent,
-                    footer_colors.text_muted,
+                    footer_colors,
                     cx,
@@ -358,3 +375,9 @@
                 ChatInputKeyAction::ToggleActions => this.toggle_actions_menu(cx),
-                ChatInputKeyAction::ContinueInChat => this.handle_continue_in_chat(cx),
+                ChatInputKeyAction::ContinueInChat => {
+                    if this.script_generation_mode {
+                        this.handle_script_generation_action(ScriptGenerationAction::SaveAndRun, cx);
+                    } else {
+                        this.handle_continue_in_chat(cx);
+                    }
+                }
                 ChatInputKeyAction::Submit => this.handle_submit(cx),
apply_patch(auto_approved=true) exited 0 in 22ms:
Success. Updated the following files:
M /Users/johnlindquist/dev/script-kit-gpui/src/prompts/chat/render_core.rs
file update:
diff --git a/src/prompts/chat/actions.rs b/src/prompts/chat/actions.rs
index 8ae41af43235d867176126f8de45f9fc8f3f2cbf..4d01323e1d134ef8e6f56be60d0a1eee086247e7
--- a/src/prompts/chat/actions.rs
+++ b/src/prompts/chat/actions.rs
@@ -172,48 +172,36 @@
 
         if action.should_run_after_save() {
             self.set_script_generation_status(false, format!("Running {}...", script_name), cx);
-
-            let path_clone = script_path.clone();
-            let name_clone = script_name.clone();
-            cx.spawn(async move |this, cx| {
-                let run_result = std::thread::spawn(move || {
-                    crate::ai::script_generation::run_saved_script(&path_clone)
-                })
-                .join()
-                .map_err(|_| anyhow::anyhow!("run thread panicked"))
-                .and_then(|r| r);
-
-                let _ = cx.update(|cx| {
-                    this.update(cx, |chat, cx| match run_result {
-                        Ok(()) => {
-                            chat.set_script_generation_status(
-                                false,
-                                format!("Saved and running {}", name_clone),
-                                cx,
-                            );
-                            logging::log(
-                                "CHAT_SCRIPT_GEN",
-                                &format!("state=run_ok action={:?} script={}", action, name_clone),
-                            );
-                        }
-                        Err(error) => {
-                            chat.set_script_generation_status(
-                                true,
-                                format!("Saved {} but failed to run: {}", name_clone, error),
-                                cx,
-                            );
-                            logging::log(
-                                "CHAT_SCRIPT_GEN",
-                                &format!(
-                                    "state=run_failed action={:?} script={} error={}",
-                                    action, name_clone, error
-                                ),
-                            );
-                        }
-                    })
-                });
-            })
-            .detach();
+            if let Some(ref callback) = self.on_run_script {
+                callback(script_path.clone(), cx);
+                self.set_script_generation_status(
+                    false,
+                    format!("Saved and running {}", script_name),
+                    cx,
+                );
+                logging::log(
+                    "CHAT_SCRIPT_GEN",
+                    &format!(
+                        "state=run_dispatched action={:?} path={}",
+                        action,
+                        script_path.display()
+                    ),
+                );
+            } else {
+                self.set_script_generation_status(
+                    true,
+                    format!("Saved {} but run action is unavailable", script_name),
+                    cx,
+                );
+                logging::log(
+                    "CHAT_SCRIPT_GEN",
+                    &format!(
+                        "state=run_dispatch_failed action={:?} path={} reason=missing_callback",
+                        action,
+                        script_path.display()
+                    ),
+                );
+            }
             return;
         }
 
diff --git a/src/prompts/chat/prompt.rs b/src/prompts/chat/prompt.rs
index 4ef4ac1aae4123a9bdd9771500998f87f424660b..78a8d8354e9e50914fdbcf1cc0fce0292b4feac2
--- a/src/prompts/chat/prompt.rs
+++ b/src/prompts/chat/prompt.rs
@@ -60,6 +60,9 @@
     pub(super) on_claude_code: Option<ChatClaudeCodeCallback>,
     // Callback for showing actions dialog (handled by parent)
     pub(super) on_show_actions: Option<ChatShowActionsCallback>,
+    // Callback for running a saved generated script via parent app pipeline
+    pub(super) on_run_script:
+        Option<Arc<dyn Fn(std::path::PathBuf, &mut Context<ChatPrompt>) + Send + Sync>>,
     // Stable UUID for Claude Code CLI session continuity within this prompt's lifetime.
     // Generated once at construction so all messages share the same session.
     pub(super) cli_session_id: String,
@@ -134,6 +137,7 @@
             on_configure: None,
             on_claude_code: None,
             on_show_actions: None,
+            on_run_script: None,
             cli_session_id: uuid::Uuid::new_v4().to_string(),
             pending_image: None,
             pending_image_render: None,
@@ -146,6 +150,15 @@
         self.on_show_actions = Some(callback);
     }
 
+    /// Set the callback for running a generated script path in the parent app.
+    pub fn with_run_script_callback(
+        mut self,
+        callback: impl Fn(std::path::PathBuf, &mut Context<Self>) + Send + Sync + 'static,
+    ) -> Self {
+        self.on_run_script = Some(Arc::new(callback));
+        self
+    }
+
     /// Start the cursor blink timer
     pub fn start_cursor_blink(&mut self, cx: &mut Context<Self>) {
         cx.spawn(async move |this, cx| {
diff --git a/src/prompts/chat/render_core.rs b/src/prompts/chat/render_core.rs
index 4e91d2d0ed474e69c143cd50e58e0491df58450b..2a347eb5b4dc13841dd27bb8203c7d74e04aa3fa
--- a/src/prompts/chat/render_core.rs
+++ b/src/prompts/chat/render_core.rs
@@ -32,10 +32,18 @@
         label: &'static str,
         shortcut: Option<&'static str>,
         action: ScriptGenerationAction,
-        accent_color: u32,
-        muted_color: u32,
+        footer_colors: PromptFooterColors,
         cx: &mut Context<Self>,
     ) -> AnyElement {
+        let button_font_size =
+            crate::components::prompt_footer::footer_button_font_size_px(&self.theme);
+        let hover_bg = rgba(crate::components::prompt_footer::footer_button_hover_rgba(
+            footer_colors,
+        ));
+        let active_bg = rgba(crate::components::prompt_footer::footer_button_active_rgba(
+            footer_colors,
+        ));
+
         div()
             .id(id)
             .flex()
@@ -46,9 +54,21 @@
             .py(px(2.0))
             .rounded(px(4.0))
             .cursor_pointer()
-            .child(div().text_xs().text_color(rgb(accent_color)).child(label))
+            .hover(move |d| d.bg(hover_bg))
+            .active(move |d| d.bg(active_bg))
+            .child(
+                div()
+                    .text_size(px(button_font_size))
+                    .text_color(rgb(footer_colors.accent))
+                    .child(label),
+            )
             .when_some(shortcut, |d, shortcut| {
-                d.child(div().text_xs().text_color(rgb(muted_color)).child(shortcut))
+                d.child(
+                    div()
+                        .text_size(px(button_font_size))
+                        .text_color(rgb(footer_colors.text_muted))
+                        .child(shortcut),
+                )
             })
             .on_click(cx.listener(move |this, _event, _window, cx| {
                 this.handle_script_generation_action(action, cx);
@@ -109,10 +129,9 @@
             self.render_script_generation_footer_button(
                 "chat-footer-primary-button",
                 "Save and Run",
-                None,
+                Some("⌘↵"),
                 ScriptGenerationAction::SaveAndRun,
-                footer_colors.accent,
-                footer_colors.text_muted,
+                footer_colors,
                 cx,
             )
         } else {
@@ -194,8 +213,7 @@
                     "Save",
                     None,
                     ScriptGenerationAction::Save,
-                    footer_colors.accent,
-                    footer_colors.text_muted,
+                    footer_colors,
                     cx,
                 ))
                 .child(self.render_script_generation_footer_button(
@@ -203,8 +221,7 @@
                     "Run",
                     None,
                     ScriptGenerationAction::Run,
-                    footer_colors.accent,
-                    footer_colors.text_muted,
+                    footer_colors,
                     cx,
                 ));
         }
@@ -356,7 +373,13 @@
                     }
                 }
                 ChatInputKeyAction::ToggleActions => this.toggle_actions_menu(cx),
-                ChatInputKeyAction::ContinueInChat => this.handle_continue_in_chat(cx),
+                ChatInputKeyAction::ContinueInChat => {
+                    if this.script_generation_mode {
+                        this.handle_script_generation_action(ScriptGenerationAction::SaveAndRun, cx);
+                    } else {
+                        this.handle_continue_in_chat(cx);
+                    }
+                }
                 ChatInputKeyAction::Submit => this.handle_submit(cx),
                 ChatInputKeyAction::InsertNewline => {
                     this.input.insert_char('\n');

file update:
diff --git a/src/prompts/chat/actions.rs b/src/prompts/chat/actions.rs
index 8ae41af43235d867176126f8de45f9fc8f3f2cbf..4d01323e1d134ef8e6f56be60d0a1eee086247e7
--- a/src/prompts/chat/actions.rs
+++ b/src/prompts/chat/actions.rs
@@ -172,48 +172,36 @@
 
         if action.should_run_after_save() {
             self.set_script_generation_status(false, format!("Running {}...", script_name), cx);
-
-            let path_clone = script_path.clone();
-            let name_clone = script_name.clone();
-            cx.spawn(async move |this, cx| {
-                let run_result = std::thread::spawn(move || {
-                    crate::ai::script_generation::run_saved_script(&path_clone)
-                })
-                .join()
-                .map_err(|_| anyhow::anyhow!("run thread panicked"))
-                .and_then(|r| r);
-
-                let _ = cx.update(|cx| {
-                    this.update(cx, |chat, cx| match run_result {
-                        Ok(()) => {
-                            chat.set_script_generation_status(
-                                false,
-                                format!("Saved and running {}", name_clone),
-                                cx,
-                            );
-                            logging::log(
-                                "CHAT_SCRIPT_GEN",
-                                &format!("state=run_ok action={:?} script={}", action, name_clone),
-                            );
-                        }
-                        Err(error) => {
-                            chat.set_script_generation_status(
-                                true,
-                                format!("Saved {} but failed to run: {}", name_clone, error),
-                                cx,
-                            );
-                            logging::log(
-                                "CHAT_SCRIPT_GEN",
-                                &format!(
-                                    "state=run_failed action={:?} script={} error={}",
-                                    action, name_clone, error
-                                ),
-                            );
-                        }
-                    })
-                });
-            })
-            .detach();
+            if let Some(ref callback) = self.on_run_script {
+                callback(script_path.clone(), cx);
+                self.set_script_generation_status(
+                    false,
+                    format!("Saved and running {}", script_name),
+                    cx,
+                );
+                logging::log(
+                    "CHAT_SCRIPT_GEN",
+                    &format!(
+                        "state=run_dispatched action={:?} path={}",
+                        action,
+                        script_path.display()
+                    ),
+                );
+            } else {
+                self.set_script_generation_status(
+                    true,
+                    format!("Saved {} but run action is unavailable", script_name),
+                    cx,
+                );
+                logging::log(
+                    "CHAT_SCRIPT_GEN",
+                    &format!(
+                        "state=run_dispatch_failed action={:?} path={} reason=missing_callback",
+                        action,
+                        script_path.display()
+                    ),
+                );
+            }
             return;
         }
 
diff --git a/src/prompts/chat/prompt.rs b/src/prompts/chat/prompt.rs
index 4ef4ac1aae4123a9bdd9771500998f87f424660b..78a8d8354e9e50914fdbcf1cc0fce0292b4feac2
--- a/src/prompts/chat/prompt.rs
+++ b/src/prompts/chat/prompt.rs
@@ -60,6 +60,9 @@
     pub(super) on_claude_code: Option<ChatClaudeCodeCallback>,
     // Callback for showing actions dialog (handled by parent)
     pub(super) on_show_actions: Option<ChatShowActionsCallback>,
+    // Callback for running a saved generated script via parent app pipeline
+    pub(super) on_run_script:
+        Option<Arc<dyn Fn(std::path::PathBuf, &mut Context<ChatPrompt>) + Send + Sync>>,
     // Stable UUID for Claude Code CLI session continuity within this prompt's lifetime.
     // Generated once at construction so all messages share the same session.
     pub(super) cli_session_id: String,
@@ -134,6 +137,7 @@
             on_configure: None,
             on_claude_code: None,
             on_show_actions: None,
+            on_run_script: None,
             cli_session_id: uuid::Uuid::new_v4().to_string(),
             pending_image: None,
             pending_image_render: None,
@@ -146,6 +150,15 @@
         self.on_show_actions = Some(callback);
     }
 
+    /// Set the callback for running a generated script path in the parent app.
+    pub fn with_run_script_callback(
+        mut self,
+        callback: impl Fn(std::path::PathBuf, &mut Context<Self>) + Send + Sync + 'static,
+    ) -> Self {
+        self.on_run_script = Some(Arc::new(callback));
+        self
+    }
+
     /// Start the cursor blink timer
     pub fn start_cursor_blink(&mut self, cx: &mut Context<Self>) {
         cx.spawn(async move |this, cx| {
diff --git a/src/prompts/chat/render_core.rs b/src/prompts/chat/render_core.rs
index 4e91d2d0ed474e69c143cd50e58e0491df58450b..2a347eb5b4dc13841dd27bb8203c7d74e04aa3fa
--- a/src/prompts/chat/render_core.rs
+++ b/src/prompts/chat/render_core.rs
@@ -32,10 +32,18 @@
         label: &'static str,
         shortcut: Option<&'static str>,
         action: ScriptGenerationAction,
-        accent_color: u32,
-        muted_color: u32,
+        footer_colors: PromptFooterColors,
         cx: &mut Context<Self>,
     ) -> AnyElement {
+        let button_font_size =
+            crate::components::prompt_footer::footer_button_font_size_px(&self.theme);
+        let hover_bg = rgba(crate::components::prompt_footer::footer_button_hover_rgba(
+            footer_colors,
+        ));
+        let active_bg = rgba(crate::components::prompt_footer::footer_button_active_rgba(
+            footer_colors,
+        ));
+
         div()
             .id(id)
             .flex()
@@ -46,9 +54,21 @@
             .py(px(2.0))
             .rounded(px(4.0))
             .cursor_pointer()
-            .child(div().text_xs().text_color(rgb(accent_color)).child(label))
+            .hover(move |d| d.bg(hover_bg))
+            .active(move |d| d.bg(active_bg))
+            .child(
+                div()
+                    .text_size(px(button_font_size))
+                    .text_color(rgb(footer_colors.accent))
+                    .child(label),
+            )
             .when_some(shortcut, |d, shortcut| {
-                d.child(div().text_xs().text_color(rgb(muted_color)).child(shortcut))
+                d.child(
+                    div()
+                        .text_size(px(button_font_size))
+                        .text_color(rgb(footer_colors.text_muted))
+                        .child(shortcut),
+                )
             })
             .on_click(cx.listener(move |this, _event, _window, cx| {
                 this.handle_script_generation_action(action, cx);
@@ -109,10 +129,9 @@
             self.render_script_generation_footer_button(
                 "chat-footer-primary-button",
                 "Save and Run",
-                None,
+                Some("⌘↵"),
                 ScriptGenerationAction::SaveAndRun,
-                footer_colors.accent,
-                footer_colors.text_muted,
+                footer_colors,
                 cx,
             )
         } else {
@@ -194,8 +213,7 @@
                     "Save",
                     None,
                     ScriptGenerationAction::Save,
-                    footer_colors.accent,
-                    footer_colors.text_muted,
+                    footer_colors,
                     cx,
                 ))
                 .child(self.render_script_generation_footer_button(
@@ -203,8 +221,7 @@
                     "Run",
                     None,
                     ScriptGenerationAction::Run,
-                    footer_colors.accent,
-                    footer_colors.text_muted,
+                    footer_colors,
                     cx,
                 ));
         }
@@ -356,7 +373,13 @@
                     }
                 }
                 ChatInputKeyAction::ToggleActions => this.toggle_actions_menu(cx),
-                ChatInputKeyAction::ContinueInChat => this.handle_continue_in_chat(cx),
+                ChatInputKeyAction::ContinueInChat => {
+                    if this.script_generation_mode {
+                        this.handle_script_generation_action(ScriptGenerationAction::SaveAndRun, cx);
+                    } else {
+                        this.handle_continue_in_chat(cx);
+                    }
+                }
                 ChatInputKeyAction::Submit => this.handle_submit(cx),
                 ChatInputKeyAction::InsertNewline => {
                     this.input.insert_char('\n');


thinking
**Updating tests for new output**
file update
M /Users/johnlindquist/dev/script-kit-gpui/src/prompts/chat/render_core.rs
@@ -643,3 +643,5 @@
         assert!(
-            normalized.contains("\"chat-footer-primary-button\",\"SaveandRun\",None,ScriptGenerationAction::SaveAndRun,"),
+            normalized.contains(
+                "\"chat-footer-primary-button\",\"SaveandRun\",Some(\"⌘↵\"),ScriptGenerationAction::SaveAndRun,"
+            ),
             "Script generation mode should render Save and Run as the primary footer action"
@@ -672,2 +674,16 @@
     }
+
+    #[test]
+    fn test_cmd_enter_runs_save_and_run_when_script_generation_mode_enabled() {
+        let content = fs::read_to_string("src/prompts/chat/render_core.rs")
+            .expect("Failed to read src/prompts/chat/render_core.rs");
+        let normalized: String = content.chars().filter(|c| !c.is_whitespace()).collect();
+
+        assert!(
+            normalized.contains(
+                "ChatInputKeyAction::ContinueInChat=>{ifthis.script_generation_mode{this.handle_script_generation_action(ScriptGenerationAction::SaveAndRun,cx);}else{this.handle_continue_in_chat(cx);}}"
+            ),
+            "Cmd+Enter should trigger SaveAndRun in script generation mode and ContinueInChat otherwise"
+        );
+    }
 }
apply_patch(auto_approved=true) exited 0 in 23ms:
Success. Updated the following files:
M /Users/johnlindquist/dev/script-kit-gpui/src/prompts/chat/render_core.rs
file update:
diff --git a/src/prompts/chat/actions.rs b/src/prompts/chat/actions.rs
index 8ae41af43235d867176126f8de45f9fc8f3f2cbf..4d01323e1d134ef8e6f56be60d0a1eee086247e7
--- a/src/prompts/chat/actions.rs
+++ b/src/prompts/chat/actions.rs
@@ -172,48 +172,36 @@
 
         if action.should_run_after_save() {
             self.set_script_generation_status(false, format!("Running {}...", script_name), cx);
-
-            let path_clone = script_path.clone();
-            let name_clone = script_name.clone();
-            cx.spawn(async move |this, cx| {
-                let run_result = std::thread::spawn(move || {
-                    crate::ai::script_generation::run_saved_script(&path_clone)
-                })
-                .join()
-                .map_err(|_| anyhow::anyhow!("run thread panicked"))
-                .and_then(|r| r);
-
-                let _ = cx.update(|cx| {
-                    this.update(cx, |chat, cx| match run_result {
-                        Ok(()) => {
-                            chat.set_script_generation_status(
-                                false,
-                                format!("Saved and running {}", name_clone),
-                                cx,
-                            );
-                            logging::log(
-                                "CHAT_SCRIPT_GEN",
-                                &format!("state=run_ok action={:?} script={}", action, name_clone),
-                            );
-                        }
-                        Err(error) => {
-                            chat.set_script_generation_status(
-                                true,
-                                format!("Saved {} but failed to run: {}", name_clone, error),
-                                cx,
-                            );
-                            logging::log(
-                                "CHAT_SCRIPT_GEN",
-                                &format!(
-                                    "state=run_failed action={:?} script={} error={}",
-                                    action, name_clone, error
-                                ),
-                            );
-                        }
-                    })
-                });
-            })
-            .detach();
+            if let Some(ref callback) = self.on_run_script {
+                callback(script_path.clone(), cx);
+                self.set_script_generation_status(
+                    false,
+                    format!("Saved and running {}", script_name),
+                    cx,
+                );
+                logging::log(
+                    "CHAT_SCRIPT_GEN",
+                    &format!(
+                        "state=run_dispatched action={:?} path={}",
+                        action,
+                        script_path.display()
+                    ),
+                );
+            } else {
+                self.set_script_generation_status(
+                    true,
+                    format!("Saved {} but run action is unavailable", script_name),
+                    cx,
+                );
+                logging::log(
+                    "CHAT_SCRIPT_GEN",
+                    &format!(
+                        "state=run_dispatch_failed action={:?} path={} reason=missing_callback",
+                        action,
+                        script_path.display()
+                    ),
+                );
+            }
             return;
         }
 
diff --git a/src/prompts/chat/prompt.rs b/src/prompts/chat/prompt.rs
index 4ef4ac1aae4123a9bdd9771500998f87f424660b..78a8d8354e9e50914fdbcf1cc0fce0292b4feac2
--- a/src/prompts/chat/prompt.rs
+++ b/src/prompts/chat/prompt.rs
@@ -60,6 +60,9 @@
     pub(super) on_claude_code: Option<ChatClaudeCodeCallback>,
     // Callback for showing actions dialog (handled by parent)
     pub(super) on_show_actions: Option<ChatShowActionsCallback>,
+    // Callback for running a saved generated script via parent app pipeline
+    pub(super) on_run_script:
+        Option<Arc<dyn Fn(std::path::PathBuf, &mut Context<ChatPrompt>) + Send + Sync>>,
     // Stable UUID for Claude Code CLI session continuity within this prompt's lifetime.
     // Generated once at construction so all messages share the same session.
     pub(super) cli_session_id: String,
@@ -134,6 +137,7 @@
             on_configure: None,
             on_claude_code: None,
             on_show_actions: None,
+            on_run_script: None,
             cli_session_id: uuid::Uuid::new_v4().to_string(),
             pending_image: None,
             pending_image_render: None,
@@ -146,6 +150,15 @@
         self.on_show_actions = Some(callback);
     }
 
+    /// Set the callback for running a generated script path in the parent app.
+    pub fn with_run_script_callback(
+        mut self,
+        callback: impl Fn(std::path::PathBuf, &mut Context<Self>) + Send + Sync + 'static,
+    ) -> Self {
+        self.on_run_script = Some(Arc::new(callback));
+        self
+    }
+
     /// Start the cursor blink timer
     pub fn start_cursor_blink(&mut self, cx: &mut Context<Self>) {
         cx.spawn(async move |this, cx| {
diff --git a/src/prompts/chat/render_core.rs b/src/prompts/chat/render_core.rs
index 4e91d2d0ed474e69c143cd50e58e0491df58450b..7a066a4f6a2e6ac66e5e870f4a926cfbe0c56618
--- a/src/prompts/chat/render_core.rs
+++ b/src/prompts/chat/render_core.rs
@@ -32,10 +32,18 @@
         label: &'static str,
         shortcut: Option<&'static str>,
         action: ScriptGenerationAction,
-        accent_color: u32,
-        muted_color: u32,
+        footer_colors: PromptFooterColors,
         cx: &mut Context<Self>,
     ) -> AnyElement {
+        let button_font_size =
+            crate::components::prompt_footer::footer_button_font_size_px(&self.theme);
+        let hover_bg = rgba(crate::components::prompt_footer::footer_button_hover_rgba(
+            footer_colors,
+        ));
+        let active_bg = rgba(crate::components::prompt_footer::footer_button_active_rgba(
+            footer_colors,
+        ));
+
         div()
             .id(id)
             .flex()
@@ -46,9 +54,21 @@
             .py(px(2.0))
             .rounded(px(4.0))
             .cursor_pointer()
-            .child(div().text_xs().text_color(rgb(accent_color)).child(label))
+            .hover(move |d| d.bg(hover_bg))
+            .active(move |d| d.bg(active_bg))
+            .child(
+                div()
+                    .text_size(px(button_font_size))
+                    .text_color(rgb(footer_colors.accent))
+                    .child(label),
+            )
             .when_some(shortcut, |d, shortcut| {
-                d.child(div().text_xs().text_color(rgb(muted_color)).child(shortcut))
+                d.child(
+                    div()
+                        .text_size(px(button_font_size))
+                        .text_color(rgb(footer_colors.text_muted))
+                        .child(shortcut),
+                )
             })
             .on_click(cx.listener(move |this, _event, _window, cx| {
                 this.handle_script_generation_action(action, cx);
@@ -109,10 +129,9 @@
             self.render_script_generation_footer_button(
                 "chat-footer-primary-button",
                 "Save and Run",
-                None,
+                Some("⌘↵"),
                 ScriptGenerationAction::SaveAndRun,
-                footer_colors.accent,
-                footer_colors.text_muted,
+                footer_colors,
                 cx,
             )
         } else {
@@ -194,8 +213,7 @@
                     "Save",
                     None,
                     ScriptGenerationAction::Save,
-                    footer_colors.accent,
-                    footer_colors.text_muted,
+                    footer_colors,
                     cx,
                 ))
                 .child(self.render_script_generation_footer_button(
@@ -203,8 +221,7 @@
                     "Run",
                     None,
                     ScriptGenerationAction::Run,
-                    footer_colors.accent,
-                    footer_colors.text_muted,
+                    footer_colors,
                     cx,
                 ));
         }
@@ -356,7 +373,13 @@
                     }
                 }
                 ChatInputKeyAction::ToggleActions => this.toggle_actions_menu(cx),
-                ChatInputKeyAction::ContinueInChat => this.handle_continue_in_chat(cx),
+                ChatInputKeyAction::ContinueInChat => {
+                    if this.script_generation_mode {
+                        this.handle_script_generation_action(ScriptGenerationAction::SaveAndRun, cx);
+                    } else {
+                        this.handle_continue_in_chat(cx);
+                    }
+                }
                 ChatInputKeyAction::Submit => this.handle_submit(cx),
                 ChatInputKeyAction::InsertNewline => {
                     this.input.insert_char('\n');
@@ -618,7 +641,9 @@
             "Footer primary action should branch on script_generation_mode"
         );
         assert!(
-            normalized.contains("\"chat-footer-primary-button\",\"SaveandRun\",None,ScriptGenerationAction::SaveAndRun,"),
+            normalized.contains(
+                "\"chat-footer-primary-button\",\"SaveandRun\",Some(\"⌘↵\"),ScriptGenerationAction::SaveAndRun,"
+            ),
             "Script generation mode should render Save and Run as the primary footer action"
         );
         assert!(
@@ -647,4 +672,18 @@
             "Save and Run should only appear as the primary footer action slot"
         );
     }
+
+    #[test]
+    fn test_cmd_enter_runs_save_and_run_when_script_generation_mode_enabled() {
+        let content = fs::read_to_string("src/prompts/chat/render_core.rs")
+            .expect("Failed to read src/prompts/chat/render_core.rs");
+        let normalized: String = content.chars().filter(|c| !c.is_whitespace()).collect();
+
+        assert!(
+            normalized.contains(
+                "ChatInputKeyAction::ContinueInChat=>{ifthis.script_generation_mode{this.handle_script_generation_action(ScriptGenerationAction::SaveAndRun,cx);}else{this.handle_continue_in_chat(cx);}}"
+            ),
+            "Cmd+Enter should trigger SaveAndRun in script generation mode and ContinueInChat otherwise"
+        );
+    }
 }

file update:
diff --git a/src/prompts/chat/actions.rs b/src/prompts/chat/actions.rs
index 8ae41af43235d867176126f8de45f9fc8f3f2cbf..4d01323e1d134ef8e6f56be60d0a1eee086247e7
--- a/src/prompts/chat/actions.rs
+++ b/src/prompts/chat/actions.rs
@@ -172,48 +172,36 @@
 
         if action.should_run_after_save() {
             self.set_script_generation_status(false, format!("Running {}...", script_name), cx);
-
-            let path_clone = script_path.clone();
-            let name_clone = script_name.clone();
-            cx.spawn(async move |this, cx| {
-                let run_result = std::thread::spawn(move || {
-                    crate::ai::script_generation::run_saved_script(&path_clone)
-                })
-                .join()
-                .map_err(|_| anyhow::anyhow!("run thread panicked"))
-                .and_then(|r| r);
-
-                let _ = cx.update(|cx| {
-                    this.update(cx, |chat, cx| match run_result {
-                        Ok(()) => {
-                            chat.set_script_generation_status(
-                                false,
-                                format!("Saved and running {}", name_clone),
-                                cx,
-                            );
-                            logging::log(
-                                "CHAT_SCRIPT_GEN",
-                                &format!("state=run_ok action={:?} script={}", action, name_clone),
-                            );
-                        }
-                        Err(error) => {
-                            chat.set_script_generation_status(
-                                true,
-                                format!("Saved {} but failed to run: {}", name_clone, error),
-                                cx,
-                            );
-                            logging::log(
-                                "CHAT_SCRIPT_GEN",
-                                &format!(
-                                    "state=run_failed action={:?} script={} error={}",
-                                    action, name_clone, error
-                                ),
-                            );
-                        }
-                    })
-                });
-            })
-            .detach();
+            if let Some(ref callback) = self.on_run_script {
+                callback(script_path.clone(), cx);
+                self.set_script_generation_status(
+                    false,
+                    format!("Saved and running {}", script_name),
+                    cx,
+                );
+                logging::log(
+                    "CHAT_SCRIPT_GEN",
+                    &format!(
+                        "state=run_dispatched action={:?} path={}",
+                        action,
+                        script_path.display()
+                    ),
+                );
+            } else {
+                self.set_script_generation_status(
+                    true,
+                    format!("Saved {} but run action is unavailable", script_name),
+                    cx,
+                );
+                logging::log(
+                    "CHAT_SCRIPT_GEN",
+                    &format!(
+                        "state=run_dispatch_failed action={:?} path={} reason=missing_callback",
+                        action,
+                        script_path.display()
+                    ),
+                );
+            }
             return;
         }
 
diff --git a/src/prompts/chat/prompt.rs b/src/prompts/chat/prompt.rs
index 4ef4ac1aae4123a9bdd9771500998f87f424660b..78a8d8354e9e50914fdbcf1cc0fce0292b4feac2
--- a/src/prompts/chat/prompt.rs
+++ b/src/prompts/chat/prompt.rs
@@ -60,6 +60,9 @@
     pub(super) on_claude_code: Option<ChatClaudeCodeCallback>,
     // Callback for showing actions dialog (handled by parent)
     pub(super) on_show_actions: Option<ChatShowActionsCallback>,
+    // Callback for running a saved generated script via parent app pipeline
+    pub(super) on_run_script:
+        Option<Arc<dyn Fn(std::path::PathBuf, &mut Context<ChatPrompt>) + Send + Sync>>,
     // Stable UUID for Claude Code CLI session continuity within this prompt's lifetime.
     // Generated once at construction so all messages share the same session.
     pub(super) cli_session_id: String,
@@ -134,6 +137,7 @@
             on_configure: None,
             on_claude_code: None,
             on_show_actions: None,
+            on_run_script: None,
             cli_session_id: uuid::Uuid::new_v4().to_string(),
             pending_image: None,
             pending_image_render: None,
@@ -146,6 +150,15 @@
         self.on_show_actions = Some(callback);
     }
 
+    /// Set the callback for running a generated script path in the parent app.
+    pub fn with_run_script_callback(
+        mut self,
+        callback: impl Fn(std::path::PathBuf, &mut Context<Self>) + Send + Sync + 'static,
+    ) -> Self {
+        self.on_run_script = Some(Arc::new(callback));
+        self
+    }
+
     /// Start the cursor blink timer
     pub fn start_cursor_blink(&mut self, cx: &mut Context<Self>) {
         cx.spawn(async move |this, cx| {
diff --git a/src/prompts/chat/render_core.rs b/src/prompts/chat/render_core.rs
index 4e91d2d0ed474e69c143cd50e58e0491df58450b..7a066a4f6a2e6ac66e5e870f4a926cfbe0c56618
--- a/src/prompts/chat/render_core.rs
+++ b/src/prompts/chat/render_core.rs
@@ -32,10 +32,18 @@
         label: &'static str,
         shortcut: Option<&'static str>,
         action: ScriptGenerationAction,
-        accent_color: u32,
-        muted_color: u32,
+        footer_colors: PromptFooterColors,
         cx: &mut Context<Self>,
     ) -> AnyElement {
+        let button_font_size =
+            crate::components::prompt_footer::footer_button_font_size_px(&self.theme);
+        let hover_bg = rgba(crate::components::prompt_footer::footer_button_hover_rgba(
+            footer_colors,
+        ));
+        let active_bg = rgba(crate::components::prompt_footer::footer_button_active_rgba(
+            footer_colors,
+        ));
+
         div()
             .id(id)
             .flex()
@@ -46,9 +54,21 @@
             .py(px(2.0))
             .rounded(px(4.0))
             .cursor_pointer()
-            .child(div().text_xs().text_color(rgb(accent_color)).child(label))
+            .hover(move |d| d.bg(hover_bg))
+            .active(move |d| d.bg(active_bg))
+            .child(
+                div()
+                    .text_size(px(button_font_size))
+                    .text_color(rgb(footer_colors.accent))
+                    .child(label),
+            )
             .when_some(shortcut, |d, shortcut| {
-                d.child(div().text_xs().text_color(rgb(muted_color)).child(shortcut))
+                d.child(
+                    div()
+                        .text_size(px(button_font_size))
+                        .text_color(rgb(footer_colors.text_muted))
+                        .child(shortcut),
+                )
             })
             .on_click(cx.listener(move |this, _event, _window, cx| {
                 this.handle_script_generation_action(action, cx);
@@ -109,10 +129,9 @@
             self.render_script_generation_footer_button(
                 "chat-footer-primary-button",
                 "Save and Run",
-                None,
+                Some("⌘↵"),
                 ScriptGenerationAction::SaveAndRun,
-                footer_colors.accent,
-                footer_colors.text_muted,
+                footer_colors,
                 cx,
             )
         } else {
@@ -194,8 +213,7 @@
                     "Save",
                     None,
                     ScriptGenerationAction::Save,
-                    footer_colors.accent,
-                    footer_colors.text_muted,
+                    footer_colors,
                     cx,
                 ))
                 .child(self.render_script_generation_footer_button(
@@ -203,8 +221,7 @@
                     "Run",
                     None,
                     ScriptGenerationAction::Run,
-                    footer_colors.accent,
-                    footer_colors.text_muted,
+                    footer_colors,
                     cx,
                 ));
         }
@@ -356,7 +373,13 @@
                     }
                 }
                 ChatInputKeyAction::ToggleActions => this.toggle_actions_menu(cx),
-                ChatInputKeyAction::ContinueInChat => this.handle_continue_in_chat(cx),
+                ChatInputKeyAction::ContinueInChat => {
+                    if this.script_generation_mode {
+                        this.handle_script_generation_action(ScriptGenerationAction::SaveAndRun, cx);
+                    } else {
+                        this.handle_continue_in_chat(cx);
+                    }
+                }
                 ChatInputKeyAction::Submit => this.handle_submit(cx),
                 ChatInputKeyAction::InsertNewline => {
                     this.input.insert_char('\n');
@@ -618,7 +641,9 @@
             "Footer primary action should branch on script_generation_mode"
         );
         assert!(
-            normalized.contains("\"chat-footer-primary-button\",\"SaveandRun\",None,ScriptGenerationAction::SaveAndRun,"),
+            normalized.contains(
+                "\"chat-footer-primary-button\",\"SaveandRun\",Some(\"⌘↵\"),ScriptGenerationAction::SaveAndRun,"
+            ),
             "Script generation mode should render Save and Run as the primary footer action"
         );
         assert!(
@@ -647,4 +672,18 @@
             "Save and Run should only appear as the primary footer action slot"
         );
     }
+
+    #[test]
+    fn test_cmd_enter_runs_save_and_run_when_script_generation_mode_enabled() {
+        let content = fs::read_to_string("src/prompts/chat/render_core.rs")
+            .expect("Failed to read src/prompts/chat/render_core.rs");
+        let normalized: String = content.chars().filter(|c| !c.is_whitespace()).collect();
+
+        assert!(
+            normalized.contains(
+                "ChatInputKeyAction::ContinueInChat=>{ifthis.script_generation_mode{this.handle_script_generation_action(ScriptGenerationAction::SaveAndRun,cx);}else{this.handle_continue_in_chat(cx);}}"
+            ),
+            "Cmd+Enter should trigger SaveAndRun in script generation mode and ContinueInChat otherwise"
+        );
+    }
 }


thinking
**Adding script run callback**
codex
I’m implementing the parent-app run callback next by wiring `show_script_generation_chat` to pass a run-script closure into `ChatPrompt`, so Save/Run actions execute through `execute_script_by_path` instead of detached bun/kit.
file update
M /Users/johnlindquist/dev/script-kit-gpui/src/app_impl/prompt_ai.rs
@@ -570,2 +570,34 @@
         });
+        let app_entity = cx.entity().downgrade();
+        let run_script_callback = move |script_path: std::path::PathBuf,
+                                        chat_cx: &mut gpui::Context<ChatPrompt>| {
+            let script_path_string = script_path.to_string_lossy().to_string();
+            let app_entity = app_entity.clone();
+            chat_cx
+                .spawn(async move |_this, cx| {
+                    let _ = cx.update(|cx| {
+                        if let Some(app) = app_entity.upgrade() {
+                            logging::log(
+                                "CHAT_SCRIPT_GEN",
+                                &format!(
+                                    "state=dispatch_run attempted=execute_script_by_path path={}",
+                                    script_path_string
+                                ),
+                            );
+                            app.update(cx, |app, cx| {
+                                app.execute_script_by_path(&script_path_string, cx);
+                            });
+                        } else {
+                            logging::log(
+                                "CHAT_SCRIPT_GEN",
+                                &format!(
+                                    "state=dispatch_run_failed attempted=execute_script_by_path path={} reason=app_entity_unavailable",
+                                    script_path_string
+                                ),
+                            );
+                        }
+                    });
+                })
+                .detach();
+        };
 
@@ -586,2 +618,3 @@
         .with_escape_callback(escape_callback)
+        .with_run_script_callback(run_script_callback)
         .with_builtin_ai(registry, true) // true = prefer Vercel AI Gateway
apply_patch(auto_approved=true) exited 0 in 25ms:
Success. Updated the following files:
M /Users/johnlindquist/dev/script-kit-gpui/src/app_impl/prompt_ai.rs
file update:
diff --git a/src/app_impl/prompt_ai.rs b/src/app_impl/prompt_ai.rs
index c8266b6cb798ec62e6e7e9a8a59005512e44b72f..6c10ca4234dc2d80bb14bc0d5163caddf97656cc
--- a/src/app_impl/prompt_ai.rs
+++ b/src/app_impl/prompt_ai.rs
@@ -568,6 +568,38 @@
         let noop_callback: ChatSubmitCallback = std::sync::Arc::new(|_id, _text| {
             // Built-in AI mode handles this internally
         });
+        let app_entity = cx.entity().downgrade();
+        let run_script_callback = move |script_path: std::path::PathBuf,
+                                        chat_cx: &mut gpui::Context<ChatPrompt>| {
+            let script_path_string = script_path.to_string_lossy().to_string();
+            let app_entity = app_entity.clone();
+            chat_cx
+                .spawn(async move |_this, cx| {
+                    let _ = cx.update(|cx| {
+                        if let Some(app) = app_entity.upgrade() {
+                            logging::log(
+                                "CHAT_SCRIPT_GEN",
+                                &format!(
+                                    "state=dispatch_run attempted=execute_script_by_path path={}",
+                                    script_path_string
+                                ),
+                            );
+                            app.update(cx, |app, cx| {
+                                app.execute_script_by_path(&script_path_string, cx);
+                            });
+                        } else {
+                            logging::log(
+                                "CHAT_SCRIPT_GEN",
+                                &format!(
+                                    "state=dispatch_run_failed attempted=execute_script_by_path path={} reason=app_entity_unavailable",
+                                    script_path_string
+                                ),
+                            );
+                        }
+                    });
+                })
+                .detach();
+        };
 
         let placeholder = Some("Describe the script you want to generate...".to_string());
 
@@ -584,6 +616,7 @@
         .with_title("Generate Script with AI")
         .with_save_history(false)
         .with_escape_callback(escape_callback)
+        .with_run_script_callback(run_script_callback)
         .with_builtin_ai(registry, true) // true = prefer Vercel AI Gateway
         .with_builtin_system_prompt(crate::ai::script_generation::AI_SCRIPT_GENERATION_SYSTEM_PROMPT)
         .with_script_generation_mode(true);
diff --git a/src/prompts/chat/actions.rs b/src/prompts/chat/actions.rs
index 8ae41af43235d867176126f8de45f9fc8f3f2cbf..4d01323e1d134ef8e6f56be60d0a1eee086247e7
--- a/src/prompts/chat/actions.rs
+++ b/src/prompts/chat/actions.rs
@@ -172,48 +172,36 @@
 
         if action.should_run_after_save() {
             self.set_script_generation_status(false, format!("Running {}...", script_name), cx);
-
-            let path_clone = script_path.clone();
-            let name_clone = script_name.clone();
-            cx.spawn(async move |this, cx| {
-                let run_result = std::thread::spawn(move || {
-                    crate::ai::script_generation::run_saved_script(&path_clone)
-                })
-                .join()
-                .map_err(|_| anyhow::anyhow!("run thread panicked"))
-                .and_then(|r| r);
-
-                let _ = cx.update(|cx| {
-                    this.update(cx, |chat, cx| match run_result {
-                        Ok(()) => {
-                            chat.set_script_generation_status(
-                                false,
-                                format!("Saved and running {}", name_clone),
-                                cx,
-                            );
-                            logging::log(
-                                "CHAT_SCRIPT_GEN",
-                                &format!("state=run_ok action={:?} script={}", action, name_clone),
-                            );
-                        }
-                        Err(error) => {
-                            chat.set_script_generation_status(
-                                true,
-                                format!("Saved {} but failed to run: {}", name_clone, error),
-                                cx,
-                            );
-                            logging::log(
-                                "CHAT_SCRIPT_GEN",
-                                &format!(
-                                    "state=run_failed action={:?} script={} error={}",
-                                    action, name_clone, error
-                                ),
-                            );
-                        }
-                    })
-                });
-            })
-            .detach();
+            if let Some(ref callback) = self.on_run_script {
+                callback(script_path.clone(), cx);
+                self.set_script_generation_status(
+                    false,
+                    format!("Saved and running {}", script_name),
+                    cx,
+                );
+                logging::log(
+                    "CHAT_SCRIPT_GEN",
+                    &format!(
+                        "state=run_dispatched action={:?} path={}",
+                        action,
+                        script_path.display()
+                    ),
+                );
+            } else {
+                self.set_script_generation_status(
+                    true,
+                    format!("Saved {} but run action is unavailable", script_name),
+                    cx,
+                );
+                logging::log(
+                    "CHAT_SCRIPT_GEN",
+                    &format!(
+                        "state=run_dispatch_failed action={:?} path={} reason=missing_callback",
+                        action,
+                        script_path.display()
+                    ),
+                );
+            }
             return;
         }
 
diff --git a/src/prompts/chat/prompt.rs b/src/prompts/chat/prompt.rs
index 4ef4ac1aae4123a9bdd9771500998f87f424660b..78a8d8354e9e50914fdbcf1cc0fce0292b4feac2
--- a/src/prompts/chat/prompt.rs
+++ b/src/prompts/chat/prompt.rs
@@ -60,6 +60,9 @@
     pub(super) on_claude_code: Option<ChatClaudeCodeCallback>,
     // Callback for showing actions dialog (handled by parent)
     pub(super) on_show_actions: Option<ChatShowActionsCallback>,
+    // Callback for running a saved generated script via parent app pipeline
+    pub(super) on_run_script:
+        Option<Arc<dyn Fn(std::path::PathBuf, &mut Context<ChatPrompt>) + Send + Sync>>,
     // Stable UUID for Claude Code CLI session continuity within this prompt's lifetime.
     // Generated once at construction so all messages share the same session.
     pub(super) cli_session_id: String,
@@ -134,6 +137,7 @@
             on_configure: None,
             on_claude_code: None,
             on_show_actions: None,
+            on_run_script: None,
             cli_session_id: uuid::Uuid::new_v4().to_string(),
             pending_image: None,
             pending_image_render: None,
@@ -146,6 +150,15 @@
         self.on_show_actions = Some(callback);
     }
 
+    /// Set the callback for running a generated script path in the parent app.
+    pub fn with_run_script_callback(
+        mut self,
+        callback: impl Fn(std::path::PathBuf, &mut Context<Self>) + Send + Sync + 'static,
+    ) -> Self {
+        self.on_run_script = Some(Arc::new(callback));
+        self
+    }
+
     /// Start the cursor blink timer
     pub fn start_cursor_blink(&mut self, cx: &mut Context<Self>) {
         cx.spawn(async move |this, cx| {
diff --git a/src/prompts/chat/render_core.rs b/src/prompts/chat/render_core.rs
index 4e91d2d0ed474e69c143cd50e58e0491df58450b..7a066a4f6a2e6ac66e5e870f4a926cfbe0c56618
--- a/src/prompts/chat/render_core.rs
+++ b/src/prompts/chat/render_core.rs
@@ -32,10 +32,18 @@
         label: &'static str,
         shortcut: Option<&'static str>,
         action: ScriptGenerationAction,
-        accent_color: u32,
-        muted_color: u32,
+        footer_colors: PromptFooterColors,
         cx: &mut Context<Self>,
     ) -> AnyElement {
+        let button_font_size =
+            crate::components::prompt_footer::footer_button_font_size_px(&self.theme);
+        let hover_bg = rgba(crate::components::prompt_footer::footer_button_hover_rgba(
+            footer_colors,
+        ));
+        let active_bg = rgba(crate::components::prompt_footer::footer_button_active_rgba(
+            footer_colors,
+        ));
+
         div()
             .id(id)
             .flex()
@@ -46,9 +54,21 @@
             .py(px(2.0))
             .rounded(px(4.0))
             .cursor_pointer()
-            .child(div().text_xs().text_color(rgb(accent_color)).child(label))
+            .hover(move |d| d.bg(hover_bg))
+            .active(move |d| d.bg(active_bg))
+            .child(
+                div()
+                    .text_size(px(button_font_size))
+                    .text_color(rgb(footer_colors.accent))
+                    .child(label),
+            )
             .when_some(shortcut, |d, shortcut| {
-                d.child(div().text_xs().text_color(rgb(muted_color)).child(shortcut))
+                d.child(
+                    div()
+                        .text_size(px(button_font_size))
+                        .text_color(rgb(footer_colors.text_muted))
+                        .child(shortcut),
+                )
             })
             .on_click(cx.listener(move |this, _event, _window, cx| {
                 this.handle_script_generation_action(action, cx);
@@ -109,10 +129,9 @@
             self.render_script_generation_footer_button(
                 "chat-footer-primary-button",
                 "Save and Run",
-                None,
+                Some("⌘↵"),
                 ScriptGenerationAction::SaveAndRun,
-                footer_colors.accent,
-                footer_colors.text_muted,
+                footer_colors,
                 cx,
             )
         } else {
@@ -194,8 +213,7 @@
                     "Save",
                     None,
                     ScriptGenerationAction::Save,
-                    footer_colors.accent,
-                    footer_colors.text_muted,
+                    footer_colors,
                     cx,
                 ))
                 .child(self.render_script_generation_footer_button(
@@ -203,8 +221,7 @@
                     "Run",
                     None,
                     ScriptGenerationAction::Run,
-                    footer_colors.accent,
-                    footer_colors.text_muted,
+                    footer_colors,
                     cx,
                 ));
         }
@@ -356,7 +373,13 @@
                     }
                 }
                 ChatInputKeyAction::ToggleActions => this.toggle_actions_menu(cx),
-                ChatInputKeyAction::ContinueInChat => this.handle_continue_in_chat(cx),
+                ChatInputKeyAction::ContinueInChat => {
+                    if this.script_generation_mode {
+                        this.handle_script_generation_action(ScriptGenerationAction::SaveAndRun, cx);
+                    } else {
+                        this.handle_continue_in_chat(cx);
+                    }
+                }
                 ChatInputKeyAction::Submit => this.handle_submit(cx),
                 ChatInputKeyAction::InsertNewline => {
                     this.input.insert_char('\n');
@@ -618,7 +641,9 @@
             "Footer primary action should branch on script_generation_mode"
         );
         assert!(
-            normalized.contains("\"chat-footer-primary-button\",\"SaveandRun\",None,ScriptGenerationAction::SaveAndRun,"),
+            normalized.contains(
+                "\"chat-footer-primary-button\",\"SaveandRun\",Some(\"⌘↵\"),ScriptGenerationAction::SaveAndRun,"
+            ),
             "Script generation mode should render Save and Run as the primary footer action"
         );
         assert!(
@@ -647,4 +672,18 @@
             "Save and Run should only appear as the primary footer action slot"
         );
     }
+
+    #[test]
+    fn test_cmd_enter_runs_save_and_run_when_script_generation_mode_enabled() {
+        let content = fs::read_to_string("src/prompts/chat/render_core.rs")
+            .expect("Failed to read src/prompts/chat/render_core.rs");
+        let normalized: String = content.chars().filter(|c| !c.is_whitespace()).collect();
+
+        assert!(
+            normalized.contains(
+                "ChatInputKeyAction::ContinueInChat=>{ifthis.script_generation_mode{this.handle_script_generation_action(ScriptGenerationAction::SaveAndRun,cx);}else{this.handle_continue_in_chat(cx);}}"
+            ),
+            "Cmd+Enter should trigger SaveAndRun in script generation mode and ContinueInChat otherwise"
+        );
+    }
 }

file update:
diff --git a/src/app_impl/prompt_ai.rs b/src/app_impl/prompt_ai.rs
index c8266b6cb798ec62e6e7e9a8a59005512e44b72f..6c10ca4234dc2d80bb14bc0d5163caddf97656cc
--- a/src/app_impl/prompt_ai.rs
+++ b/src/app_impl/prompt_ai.rs
@@ -568,6 +568,38 @@
         let noop_callback: ChatSubmitCallback = std::sync::Arc::new(|_id, _text| {
             // Built-in AI mode handles this internally
         });
+        let app_entity = cx.entity().downgrade();
+        let run_script_callback = move |script_path: std::path::PathBuf,
+                                        chat_cx: &mut gpui::Context<ChatPrompt>| {
+            let script_path_string = script_path.to_string_lossy().to_string();
+            let app_entity = app_entity.clone();
+            chat_cx
+                .spawn(async move |_this, cx| {
+                    let _ = cx.update(|cx| {
+                        if let Some(app) = app_entity.upgrade() {
+                            logging::log(
+                                "CHAT_SCRIPT_GEN",
+                                &format!(
+                                    "state=dispatch_run attempted=execute_script_by_path path={}",
+                                    script_path_string
+                                ),
+                            );
+                            app.update(cx, |app, cx| {
+                                app.execute_script_by_path(&script_path_string, cx);
+                            });
+                        } else {
+                            logging::log(
+                                "CHAT_SCRIPT_GEN",
+                                &format!(
+                                    "state=dispatch_run_failed attempted=execute_script_by_path path={} reason=app_entity_unavailable",
+                                    script_path_string
+                                ),
+                            );
+                        }
+                    });
+                })
+                .detach();
+        };
 
         let placeholder = Some("Describe the script you want to generate...".to_string());
 
@@ -584,6 +616,7 @@
         .with_title("Generate Script with AI")
         .with_save_history(false)
         .with_escape_callback(escape_callback)
+        .with_run_script_callback(run_script_callback)
         .with_builtin_ai(registry, true) // true = prefer Vercel AI Gateway
         .with_builtin_system_prompt(crate::ai::script_generation::AI_SCRIPT_GENERATION_SYSTEM_PROMPT)
         .with_script_generation_mode(true);
diff --git a/src/prompts/chat/actions.rs b/src/prompts/chat/actions.rs
index 8ae41af43235d867176126f8de45f9fc8f3f2cbf..4d01323e1d134ef8e6f56be60d0a1eee086247e7
--- a/src/prompts/chat/actions.rs
+++ b/src/prompts/chat/actions.rs
@@ -172,48 +172,36 @@
 
         if action.should_run_after_save() {
             self.set_script_generation_status(false, format!("Running {}...", script_name), cx);
-
-            let path_clone = script_path.clone();
-            let name_clone = script_name.clone();
-            cx.spawn(async move |this, cx| {
-                let run_result = std::thread::spawn(move || {
-                    crate::ai::script_generation::run_saved_script(&path_clone)
-                })
-                .join()
-                .map_err(|_| anyhow::anyhow!("run thread panicked"))
-                .and_then(|r| r);
-
-                let _ = cx.update(|cx| {
-                    this.update(cx, |chat, cx| match run_result {
-                        Ok(()) => {
-                            chat.set_script_generation_status(
-                                false,
-                                format!("Saved and running {}", name_clone),
-                                cx,
-                            );
-                            logging::log(
-                                "CHAT_SCRIPT_GEN",
-                                &format!("state=run_ok action={:?} script={}", action, name_clone),
-                            );
-                        }
-                        Err(error) => {
-                            chat.set_script_generation_status(
-                                true,
-                                format!("Saved {} but failed to run: {}", name_clone, error),
-                                cx,
-                            );
-                            logging::log(
-                                "CHAT_SCRIPT_GEN",
-                                &format!(
-                                    "state=run_failed action={:?} script={} error={}",
-                                    action, name_clone, error
-                                ),
-                            );
-                        }
-                    })
-                });
-            })
-            .detach();
+            if let Some(ref callback) = self.on_run_script {
+                callback(script_path.clone(), cx);
+                self.set_script_generation_status(
+                    false,
+                    format!("Saved and running {}", script_name),
+                    cx,
+                );
+                logging::log(
+                    "CHAT_SCRIPT_GEN",
+                    &format!(
+                        "state=run_dispatched action={:?} path={}",
+                        action,
+                        script_path.display()
+                    ),
+                );
+            } else {
+                self.set_script_generation_status(
+                    true,
+                    format!("Saved {} but run action is unavailable", script_name),
+                    cx,
+                );
+                logging::log(
+                    "CHAT_SCRIPT_GEN",
+                    &format!(
+                        "state=run_dispatch_failed action={:?} path={} reason=missing_callback",
+                        action,
+                        script_path.display()
+                    ),
+                );
+            }
             return;
         }
 
diff --git a/src/prompts/chat/prompt.rs b/src/prompts/chat/prompt.rs
index 4ef4ac1aae4123a9bdd9771500998f87f424660b..78a8d8354e9e50914fdbcf1cc0fce0292b4feac2
--- a/src/prompts/chat/prompt.rs
+++ b/src/prompts/chat/prompt.rs
@@ -60,6 +60,9 @@
     pub(super) on_claude_code: Option<ChatClaudeCodeCallback>,
     // Callback for showing actions dialog (handled by parent)
     pub(super) on_show_actions: Option<ChatShowActionsCallback>,
+    // Callback for running a saved generated script via parent app pipeline
+    pub(super) on_run_script:
+        Option<Arc<dyn Fn(std::path::PathBuf, &mut Context<ChatPrompt>) + Send + Sync>>,
     // Stable UUID for Claude Code CLI session continuity within this prompt's lifetime.
     // Generated once at construction so all messages share the same session.
     pub(super) cli_session_id: String,
@@ -134,6 +137,7 @@
             on_configure: None,
             on_claude_code: None,
             on_show_actions: None,
+            on_run_script: None,
             cli_session_id: uuid::Uuid::new_v4().to_string(),
             pending_image: None,
             pending_image_render: None,
@@ -146,6 +150,15 @@
         self.on_show_actions = Some(callback);
     }
 
+    /// Set the callback for running a generated script path in the parent app.
+    pub fn with_run_script_callback(
+        mut self,
+        callback: impl Fn(std::path::PathBuf, &mut Context<Self>) + Send + Sync + 'static,
+    ) -> Self {
+        self.on_run_script = Some(Arc::new(callback));
+        self
+    }
+
     /// Start the cursor blink timer
     pub fn start_cursor_blink(&mut self, cx: &mut Context<Self>) {
         cx.spawn(async move |this, cx| {
diff --git a/src/prompts/chat/render_core.rs b/src/prompts/chat/render_core.rs
index 4e91d2d0ed474e69c143cd50e58e0491df58450b..7a066a4f6a2e6ac66e5e870f4a926cfbe0c56618
--- a/src/prompts/chat/render_core.rs
+++ b/src/prompts/chat/render_core.rs
@@ -32,10 +32,18 @@
         label: &'static str,
         shortcut: Option<&'static str>,
         action: ScriptGenerationAction,
-        accent_color: u32,
-        muted_color: u32,
+        footer_colors: PromptFooterColors,
         cx: &mut Context<Self>,
     ) -> AnyElement {
+        let button_font_size =
+            crate::components::prompt_footer::footer_button_font_size_px(&self.theme);
+        let hover_bg = rgba(crate::components::prompt_footer::footer_button_hover_rgba(
+            footer_colors,
+        ));
+        let active_bg = rgba(crate::components::prompt_footer::footer_button_active_rgba(
+            footer_colors,
+        ));
+
         div()
             .id(id)
             .flex()
@@ -46,9 +54,21 @@
             .py(px(2.0))
             .rounded(px(4.0))
             .cursor_pointer()
-            .child(div().text_xs().text_color(rgb(accent_color)).child(label))
+            .hover(move |d| d.bg(hover_bg))
+            .active(move |d| d.bg(active_bg))
+            .child(
+                div()
+                    .text_size(px(button_font_size))
+                    .text_color(rgb(footer_colors.accent))
+                    .child(label),
+            )
             .when_some(shortcut, |d, shortcut| {
-                d.child(div().text_xs().text_color(rgb(muted_color)).child(shortcut))
+                d.child(
+                    div()
+                        .text_size(px(button_font_size))
+                        .text_color(rgb(footer_colors.text_muted))
+                        .child(shortcut),
+                )
             })
             .on_click(cx.listener(move |this, _event, _window, cx| {
                 this.handle_script_generation_action(action, cx);
@@ -109,10 +129,9 @@
             self.render_script_generation_footer_button(
                 "chat-footer-primary-button",
                 "Save and Run",
-                None,
+                Some("⌘↵"),
                 ScriptGenerationAction::SaveAndRun,
-                footer_colors.accent,
-                footer_colors.text_muted,
+                footer_colors,
                 cx,
             )
         } else {
@@ -194,8 +213,7 @@
                     "Save",
                     None,
                     ScriptGenerationAction::Save,
-                    footer_colors.accent,
-                    footer_colors.text_muted,
+                    footer_colors,
                     cx,
                 ))
                 .child(self.render_script_generation_footer_button(
@@ -203,8 +221,7 @@
                     "Run",
                     None,
                     ScriptGenerationAction::Run,
-                    footer_colors.accent,
-                    footer_colors.text_muted,
+                    footer_colors,
                     cx,
                 ));
         }
@@ -356,7 +373,13 @@
                     }
                 }
                 ChatInputKeyAction::ToggleActions => this.toggle_actions_menu(cx),
-                ChatInputKeyAction::ContinueInChat => this.handle_continue_in_chat(cx),
+                ChatInputKeyAction::ContinueInChat => {
+                    if this.script_generation_mode {
+                        this.handle_script_generation_action(ScriptGenerationAction::SaveAndRun, cx);
+                    } else {
+                        this.handle_continue_in_chat(cx);
+                    }
+                }
                 ChatInputKeyAction::Submit => this.handle_submit(cx),
                 ChatInputKeyAction::InsertNewline => {
                     this.input.insert_char('\n');
@@ -618,7 +641,9 @@
             "Footer primary action should branch on script_generation_mode"
         );
         assert!(
-            normalized.contains("\"chat-footer-primary-button\",\"SaveandRun\",None,ScriptGenerationAction::SaveAndRun,"),
+            normalized.contains(
+                "\"chat-footer-primary-button\",\"SaveandRun\",Some(\"⌘↵\"),ScriptGenerationAction::SaveAndRun,"
+            ),
             "Script generation mode should render Save and Run as the primary footer action"
         );
         assert!(
@@ -647,4 +672,18 @@
             "Save and Run should only appear as the primary footer action slot"
         );
     }
+
+    #[test]
+    fn test_cmd_enter_runs_save_and_run_when_script_generation_mode_enabled() {
+        let content = fs::read_to_string("src/prompts/chat/render_core.rs")
+            .expect("Failed to read src/prompts/chat/render_core.rs");
+        let normalized: String = content.chars().filter(|c| !c.is_whitespace()).collect();
+
+        assert!(
+            normalized.contains(
+                "ChatInputKeyAction::ContinueInChat=>{ifthis.script_generation_mode{this.handle_script_generation_action(ScriptGenerationAction::SaveAndRun,cx);}else{this.handle_continue_in_chat(cx);}}"
+            ),
+            "Cmd+Enter should trigger SaveAndRun in script generation mode and ContinueInChat otherwise"
+        );
+    }
 }


thinking
**Refactoring footer helpers and font size**
file update
M /Users/johnlindquist/dev/script-kit-gpui/src/components/prompt_footer.rs
@@ -157,3 +157,3 @@
 
-fn footer_button_hover_rgba(colors: PromptFooterColors) -> u32 {
+pub fn footer_button_hover_rgba(colors: PromptFooterColors) -> u32 {
     (colors.background << 8) | (PROMPT_FOOTER_BUTTON_HOVER_OPACITY as u32)
@@ -161,3 +161,3 @@
 
-fn footer_button_active_rgba(colors: PromptFooterColors) -> u32 {
+pub fn footer_button_active_rgba(colors: PromptFooterColors) -> u32 {
     (colors.background << 8) | (PROMPT_FOOTER_BUTTON_ACTIVE_OPACITY as u32)
@@ -165,2 +165,7 @@
 
+pub fn footer_button_font_size_px(theme: &Theme) -> f32 {
+    (theme.get_fonts().ui_size - PROMPT_FOOTER_BUTTON_FONT_DELTA_PX)
+        .max(PROMPT_FOOTER_BUTTON_FONT_MIN_PX)
+}
+
 /// Configuration for PromptFooter display
@@ -336,4 +341,3 @@
         let theme = crate::theme::get_cached_theme();
-        let button_font_size = (theme.get_fonts().ui_size - PROMPT_FOOTER_BUTTON_FONT_DELTA_PX)
-            .max(PROMPT_FOOTER_BUTTON_FONT_MIN_PX);
+        let button_font_size = footer_button_font_size_px(&theme);
         let has_click_handler = on_click.is_some();
apply_patch(auto_approved=true) exited 0 in 35ms:
Success. Updated the following files:
M /Users/johnlindquist/dev/script-kit-gpui/src/components/prompt_footer.rs
file update:
diff --git a/src/app_impl/prompt_ai.rs b/src/app_impl/prompt_ai.rs
index c8266b6cb798ec62e6e7e9a8a59005512e44b72f..6c10ca4234dc2d80bb14bc0d5163caddf97656cc
--- a/src/app_impl/prompt_ai.rs
+++ b/src/app_impl/prompt_ai.rs
@@ -568,6 +568,38 @@
         let noop_callback: ChatSubmitCallback = std::sync::Arc::new(|_id, _text| {
             // Built-in AI mode handles this internally
         });
+        let app_entity = cx.entity().downgrade();
+        let run_script_callback = move |script_path: std::path::PathBuf,
+                                        chat_cx: &mut gpui::Context<ChatPrompt>| {
+            let script_path_string = script_path.to_string_lossy().to_string();
+            let app_entity = app_entity.clone();
+            chat_cx
+                .spawn(async move |_this, cx| {
+                    let _ = cx.update(|cx| {
+                        if let Some(app) = app_entity.upgrade() {
+                            logging::log(
+                                "CHAT_SCRIPT_GEN",
+                                &format!(
+                                    "state=dispatch_run attempted=execute_script_by_path path={}",
+                                    script_path_string
+                                ),
+                            );
+                            app.update(cx, |app, cx| {
+                                app.execute_script_by_path(&script_path_string, cx);
+                            });
+                        } else {
+                            logging::log(
+                                "CHAT_SCRIPT_GEN",
+                                &format!(
+                                    "state=dispatch_run_failed attempted=execute_script_by_path path={} reason=app_entity_unavailable",
+                                    script_path_string
+                                ),
+                            );
+                        }
+                    });
+                })
+                .detach();
+        };
 
         let placeholder = Some("Describe the script you want to generate...".to_string());
 
@@ -584,6 +616,7 @@
         .with_title("Generate Script with AI")
         .with_save_history(false)
         .with_escape_callback(escape_callback)
+        .with_run_script_callback(run_script_callback)
         .with_builtin_ai(registry, true) // true = prefer Vercel AI Gateway
         .with_builtin_system_prompt(crate::ai::script_generation::AI_SCRIPT_GENERATION_SYSTEM_PROMPT)
         .with_script_generation_mode(true);
diff --git a/src/components/prompt_footer.rs b/src/components/prompt_footer.rs
index 6bfa86a1edacaec90dc82185bb178cd09dfb7b61..0ce40c6c9c2ea6aa9f9e7599cb8065ebd2c5318b
--- a/src/components/prompt_footer.rs
+++ b/src/components/prompt_footer.rs
@@ -155,14 +155,19 @@
     )
 }
 
-fn footer_button_hover_rgba(colors: PromptFooterColors) -> u32 {
+pub fn footer_button_hover_rgba(colors: PromptFooterColors) -> u32 {
     (colors.background << 8) | (PROMPT_FOOTER_BUTTON_HOVER_OPACITY as u32)
 }
 
-fn footer_button_active_rgba(colors: PromptFooterColors) -> u32 {
+pub fn footer_button_active_rgba(colors: PromptFooterColors) -> u32 {
     (colors.background << 8) | (PROMPT_FOOTER_BUTTON_ACTIVE_OPACITY as u32)
 }
 
+pub fn footer_button_font_size_px(theme: &Theme) -> f32 {
+    (theme.get_fonts().ui_size - PROMPT_FOOTER_BUTTON_FONT_DELTA_PX)
+        .max(PROMPT_FOOTER_BUTTON_FONT_MIN_PX)
+}
+
 /// Configuration for PromptFooter display
 #[derive(Clone, Debug)]
 pub struct PromptFooterConfig {
@@ -334,8 +339,7 @@
         on_click: Option<Rc<FooterClickCallback>>,
     ) -> impl IntoElement {
         let theme = crate::theme::get_cached_theme();
-        let button_font_size = (theme.get_fonts().ui_size - PROMPT_FOOTER_BUTTON_FONT_DELTA_PX)
-            .max(PROMPT_FOOTER_BUTTON_FONT_MIN_PX);
+        let button_font_size = footer_button_font_size_px(&theme);
         let has_click_handler = on_click.is_some();
         let is_clickable = is_footer_button_clickable(has_click_handler, disabled);
         let on_click_for_key = on_click.clone();
diff --git a/src/prompts/chat/actions.rs b/src/prompts/chat/actions.rs
index 8ae41af43235d867176126f8de45f9fc8f3f2cbf..4d01323e1d134ef8e6f56be60d0a1eee086247e7
--- a/src/prompts/chat/actions.rs
+++ b/src/prompts/chat/actions.rs
@@ -172,48 +172,36 @@
 
         if action.should_run_after_save() {
             self.set_script_generation_status(false, format!("Running {}...", script_name), cx);
-
-            let path_clone = script_path.clone();
-            let name_clone = script_name.clone();
-            cx.spawn(async move |this, cx| {
-                let run_result = std::thread::spawn(move || {
-                    crate::ai::script_generation::run_saved_script(&path_clone)
-                })
-                .join()
-                .map_err(|_| anyhow::anyhow!("run thread panicked"))
-                .and_then(|r| r);
-
-                let _ = cx.update(|cx| {
-                    this.update(cx, |chat, cx| match run_result {
-                        Ok(()) => {
-                            chat.set_script_generation_status(
-                                false,
-                                format!("Saved and running {}", name_clone),
-                                cx,
-                            );
-                            logging::log(
-                                "CHAT_SCRIPT_GEN",
-                                &format!("state=run_ok action={:?} script={}", action, name_clone),
-                            );
-                        }
-                        Err(error) => {
-                            chat.set_script_generation_status(
-                                true,
-                                format!("Saved {} but failed to run: {}", name_clone, error),
-                                cx,
-                            );
-                            logging::log(
-                                "CHAT_SCRIPT_GEN",
-                                &format!(
-                                    "state=run_failed action={:?} script={} error={}",
-                                    action, name_clone, error
-                                ),
-                            );
-                        }
-                    })
-                });
-            })
-            .detach();
+            if let Some(ref callback) = self.on_run_script {
+                callback(script_path.clone(), cx);
+                self.set_script_generation_status(
+                    false,
+                    format!("Saved and running {}", script_name),
+                    cx,
+                );
+                logging::log(
+                    "CHAT_SCRIPT_GEN",
+                    &format!(
+                        "state=run_dispatched action={:?} path={}",
+                        action,
+                        script_path.display()
+                    ),
+                );
+            } else {
+                self.set_script_generation_status(
+                    true,
+                    format!("Saved {} but run action is unavailable", script_name),
+                    cx,
+                );
+                logging::log(
+                    "CHAT_SCRIPT_GEN",
+                    &format!(
+                        "state=run_dispatch_failed action={:?} path={} reason=missing_callback",
+                        action,
+                        script_path.display()
+                    ),
+                );
+            }
             return;
         }
 
diff --git a/src/prompts/chat/prompt.rs b/src/prompts/chat/prompt.rs
index 4ef4ac1aae4123a9bdd9771500998f87f424660b..78a8d8354e9e50914fdbcf1cc0fce0292b4feac2
--- a/src/prompts/chat/prompt.rs
+++ b/src/prompts/chat/prompt.rs
@@ -60,6 +60,9 @@
     pub(super) on_claude_code: Option<ChatClaudeCodeCallback>,
     // Callback for showing actions dialog (handled by parent)
     pub(super) on_show_actions: Option<ChatShowActionsCallback>,
+    // Callback for running a saved generated script via parent app pipeline
+    pub(super) on_run_script:
+        Option<Arc<dyn Fn(std::path::PathBuf, &mut Context<ChatPrompt>) + Send + Sync>>,
     // Stable UUID for Claude Code CLI session continuity within this prompt's lifetime.
     // Generated once at construction so all messages share the same session.
     pub(super) cli_session_id: String,
@@ -134,6 +137,7 @@
             on_configure: None,
             on_claude_code: None,
             on_show_actions: None,
+            on_run_script: None,
             cli_session_id: uuid::Uuid::new_v4().to_string(),
             pending_image: None,
             pending_image_render: None,
@@ -146,6 +150,15 @@
         self.on_show_actions = Some(callback);
     }
 
+    /// Set the callback for running a generated script path in the parent app.
+    pub fn with_run_script_callback(
+        mut self,
+        callback: impl Fn(std::path::PathBuf, &mut Context<Self>) + Send + Sync + 'static,
+    ) -> Self {
+        self.on_run_script = Some(Arc::new(callback));
+        self
+    }
+
     /// Start the cursor blink timer
     pub fn start_cursor_blink(&mut self, cx: &mut Context<Self>) {
         cx.spawn(async move |this, cx| {
diff --git a/src/prompts/chat/render_core.rs b/src/prompts/chat/render_core.rs
index 4e91d2d0ed474e69c143cd50e58e0491df58450b..7a066a4f6a2e6ac66e5e870f4a926cfbe0c56618
--- a/src/prompts/chat/render_core.rs
+++ b/src/prompts/chat/render_core.rs
@@ -32,10 +32,18 @@
         label: &'static str,
         shortcut: Option<&'static str>,
         action: ScriptGenerationAction,
-        accent_color: u32,
-        muted_color: u32,
+        footer_colors: PromptFooterColors,
         cx: &mut Context<Self>,
     ) -> AnyElement {
+        let button_font_size =
+            crate::components::prompt_footer::footer_button_font_size_px(&self.theme);
+        let hover_bg = rgba(crate::components::prompt_footer::footer_button_hover_rgba(
+            footer_colors,
+        ));
+        let active_bg = rgba(crate::components::prompt_footer::footer_button_active_rgba(
+            footer_colors,
+        ));
+
         div()
             .id(id)
             .flex()
@@ -46,9 +54,21 @@
             .py(px(2.0))
             .rounded(px(4.0))
             .cursor_pointer()
-            .child(div().text_xs().text_color(rgb(accent_color)).child(label))
+            .hover(move |d| d.bg(hover_bg))
+            .active(move |d| d.bg(active_bg))
+            .child(
+                div()
+                    .text_size(px(button_font_size))
+                    .text_color(rgb(footer_colors.accent))
+                    .child(label),
+            )
             .when_some(shortcut, |d, shortcut| {
-                d.child(div().text_xs().text_color(rgb(muted_color)).child(shortcut))
+                d.child(
+                    div()
+                        .text_size(px(button_font_size))
+                        .text_color(rgb(footer_colors.text_muted))
+                        .child(shortcut),
+                )
             })
             .on_click(cx.listener(move |this, _event, _window, cx| {
                 this.handle_script_generation_action(action, cx);
@@ -109,10 +129,9 @@
             self.render_script_generation_footer_button(
                 "chat-footer-primary-button",
                 "Save and Run",
-                None,
+                Some("⌘↵"),
                 ScriptGenerationAction::SaveAndRun,
-                footer_colors.accent,
-                footer_colors.text_muted,
+                footer_colors,
                 cx,
             )
         } else {
@@ -194,8 +213,7 @@
                     "Save",
                     None,
                     ScriptGenerationAction::Save,
-                    footer_colors.accent,
-                    footer_colors.text_muted,
+                    footer_colors,
                     cx,
                 ))
                 .child(self.render_script_generation_footer_button(
@@ -203,8 +221,7 @@
                     "Run",
                     None,
                     ScriptGenerationAction::Run,
-                    footer_colors.accent,
-                    footer_colors.text_muted,
+                    footer_colors,
                     cx,
                 ));
         }
@@ -356,7 +373,13 @@
                     }
                 }
                 ChatInputKeyAction::ToggleActions => this.toggle_actions_menu(cx),
-                ChatInputKeyAction::ContinueInChat => this.handle_continue_in_chat(cx),
+                ChatInputKeyAction::ContinueInChat => {
+                    if this.script_generation_mode {
+                        this.handle_script_generation_action(ScriptGenerationAction::SaveAndRun, cx);
+                    } else {
+                        this.handle_continue_in_chat(cx);
+                    }
+                }
                 ChatInputKeyAction::Submit => this.handle_submit(cx),
                 ChatInputKeyAction::InsertNewline => {
                     this.input.insert_char('\n');
@@ -618,7 +641,9 @@
             "Footer primary action should branch on script_generation_mode"
         );
         assert!(
-            normalized.contains("\"chat-footer-primary-button\",\"SaveandRun\",None,ScriptGenerationAction::SaveAndRun,"),
+            normalized.contains(
+                "\"chat-footer-primary-button\",\"SaveandRun\",Some(\"⌘↵\"),ScriptGenerationAction::SaveAndRun,"
+            ),
             "Script generation mode should render Save and Run as the primary footer action"
         );
         assert!(
@@ -647,4 +672,18 @@
             "Save and Run should only appear as the primary footer action slot"
         );
     }
+
+    #[test]
+    fn test_cmd_enter_runs_save_and_run_when_script_generation_mode_enabled() {
+        let content = fs::read_to_string("src/prompts/chat/render_core.rs")
+            .expect("Failed to read src/prompts/chat/render_core.rs");
+        let normalized: String = content.chars().filter(|c| !c.is_whitespace()).collect();
+
+        assert!(
+            normalized.contains(
+                "ChatInputKeyAction::ContinueInChat=>{ifthis.script_generation_mode{this.handle_script_generation_action(ScriptGenerationAction::SaveAndRun,cx);}else{this.handle_continue_in_chat(cx);}}"
+            ),
+            "Cmd+Enter should trigger SaveAndRun in script generation mode and ContinueInChat otherwise"
+        );
+    }
 }

file update:
diff --git a/src/app_impl/prompt_ai.rs b/src/app_impl/prompt_ai.rs
index c8266b6cb798ec62e6e7e9a8a59005512e44b72f..6c10ca4234dc2d80bb14bc0d5163caddf97656cc
--- a/src/app_impl/prompt_ai.rs
+++ b/src/app_impl/prompt_ai.rs
@@ -568,6 +568,38 @@
         let noop_callback: ChatSubmitCallback = std::sync::Arc::new(|_id, _text| {
             // Built-in AI mode handles this internally
         });
+        let app_entity = cx.entity().downgrade();
+        let run_script_callback = move |script_path: std::path::PathBuf,
+                                        chat_cx: &mut gpui::Context<ChatPrompt>| {
+            let script_path_string = script_path.to_string_lossy().to_string();
+            let app_entity = app_entity.clone();
+            chat_cx
+                .spawn(async move |_this, cx| {
+                    let _ = cx.update(|cx| {
+                        if let Some(app) = app_entity.upgrade() {
+                            logging::log(
+                                "CHAT_SCRIPT_GEN",
+                                &format!(
+                                    "state=dispatch_run attempted=execute_script_by_path path={}",
+                                    script_path_string
+                                ),
+                            );
+                            app.update(cx, |app, cx| {
+                                app.execute_script_by_path(&script_path_string, cx);
+                            });
+                        } else {
+                            logging::log(
+                                "CHAT_SCRIPT_GEN",
+                                &format!(
+                                    "state=dispatch_run_failed attempted=execute_script_by_path path={} reason=app_entity_unavailable",
+                                    script_path_string
+                                ),
+                            );
+                        }
+                    });
+                })
+                .detach();
+        };
 
         let placeholder = Some("Describe the script you want to generate...".to_string());
 
@@ -584,6 +616,7 @@
         .with_title("Generate Script with AI")
         .with_save_history(false)
         .with_escape_callback(escape_callback)
+        .with_run_script_callback(run_script_callback)
         .with_builtin_ai(registry, true) // true = prefer Vercel AI Gateway
         .with_builtin_system_prompt(crate::ai::script_generation::AI_SCRIPT_GENERATION_SYSTEM_PROMPT)
         .with_script_generation_mode(true);
diff --git a/src/components/prompt_footer.rs b/src/components/prompt_footer.rs
index 6bfa86a1edacaec90dc82185bb178cd09dfb7b61..0ce40c6c9c2ea6aa9f9e7599cb8065ebd2c5318b
--- a/src/components/prompt_footer.rs
+++ b/src/components/prompt_footer.rs
@@ -155,14 +155,19 @@
     )
 }
 
-fn footer_button_hover_rgba(colors: PromptFooterColors) -> u32 {
+pub fn footer_button_hover_rgba(colors: PromptFooterColors) -> u32 {
     (colors.background << 8) | (PROMPT_FOOTER_BUTTON_HOVER_OPACITY as u32)
 }
 
-fn footer_button_active_rgba(colors: PromptFooterColors) -> u32 {
+pub fn footer_button_active_rgba(colors: PromptFooterColors) -> u32 {
     (colors.background << 8) | (PROMPT_FOOTER_BUTTON_ACTIVE_OPACITY as u32)
 }
 
+pub fn footer_button_font_size_px(theme: &Theme) -> f32 {
+    (theme.get_fonts().ui_size - PROMPT_FOOTER_BUTTON_FONT_DELTA_PX)
+        .max(PROMPT_FOOTER_BUTTON_FONT_MIN_PX)
+}
+
 /// Configuration for PromptFooter display
 #[derive(Clone, Debug)]
 pub struct PromptFooterConfig {
@@ -334,8 +339,7 @@
         on_click: Option<Rc<FooterClickCallback>>,
     ) -> impl IntoElement {
         let theme = crate::theme::get_cached_theme();
-        let button_font_size = (theme.get_fonts().ui_size - PROMPT_FOOTER_BUTTON_FONT_DELTA_PX)
-            .max(PROMPT_FOOTER_BUTTON_FONT_MIN_PX);
+        let button_font_size = footer_button_font_size_px(&theme);
         let has_click_handler = on_click.is_some();
         let is_clickable = is_footer_button_clickable(has_click_handler, disabled);
         let on_click_for_key = on_click.clone();
diff --git a/src/prompts/chat/actions.rs b/src/prompts/chat/actions.rs
index 8ae41af43235d867176126f8de45f9fc8f3f2cbf..4d01323e1d134ef8e6f56be60d0a1eee086247e7
--- a/src/prompts/chat/actions.rs
+++ b/src/prompts/chat/actions.rs
@@ -172,48 +172,36 @@
 
         if action.should_run_after_save() {
             self.set_script_generation_status(false, format!("Running {}...", script_name), cx);
-
-            let path_clone = script_path.clone();
-            let name_clone = script_name.clone();
-            cx.spawn(async move |this, cx| {
-                let run_result = std::thread::spawn(move || {
-                    crate::ai::script_generation::run_saved_script(&path_clone)
-                })
-                .join()
-                .map_err(|_| anyhow::anyhow!("run thread panicked"))
-                .and_then(|r| r);
-
-                let _ = cx.update(|cx| {
-                    this.update(cx, |chat, cx| match run_result {
-                        Ok(()) => {
-                            chat.set_script_generation_status(
-                                false,
-                                format!("Saved and running {}", name_clone),
-                                cx,
-                            );
-                            logging::log(
-                                "CHAT_SCRIPT_GEN",
-                                &format!("state=run_ok action={:?} script={}", action, name_clone),
-                            );
-                        }
-                        Err(error) => {
-                            chat.set_script_generation_status(
-                                true,
-                                format!("Saved {} but failed to run: {}", name_clone, error),
-                                cx,
-                            );
-                            logging::log(
-                                "CHAT_SCRIPT_GEN",
-                                &format!(
-                                    "state=run_failed action={:?} script={} error={}",
-                                    action, name_clone, error
-                                ),
-                            );
-                        }
-                    })
-                });
-            })
-            .detach();
+            if let Some(ref callback) = self.on_run_script {
+                callback(script_path.clone(), cx);
+                self.set_script_generation_status(
+                    false,
+                    format!("Saved and running {}", script_name),
+                    cx,
+                );
+                logging::log(
+                    "CHAT_SCRIPT_GEN",
+                    &format!(
+                        "state=run_dispatched action={:?} path={}",
+                        action,
+                        script_path.display()
+                    ),
+                );
+            } else {
+                self.set_script_generation_status(
+                    true,
+                    format!("Saved {} but run action is unavailable", script_name),
+                    cx,
+                );
+                logging::log(
+                    "CHAT_SCRIPT_GEN",
+                    &format!(
+                        "state=run_dispatch_failed action={:?} path={} reason=missing_callback",
+                        action,
+                        script_path.display()
+                    ),
+                );
+            }
             return;
         }
 
diff --git a/src/prompts/chat/prompt.rs b/src/prompts/chat/prompt.rs
index 4ef4ac1aae4123a9bdd9771500998f87f424660b..78a8d8354e9e50914fdbcf1cc0fce0292b4feac2
--- a/src/prompts/chat/prompt.rs
+++ b/src/prompts/chat/prompt.rs
@@ -60,6 +60,9 @@
     pub(super) on_claude_code: Option<ChatClaudeCodeCallback>,
     // Callback for showing actions dialog (handled by parent)
     pub(super) on_show_actions: Option<ChatShowActionsCallback>,
+    // Callback for running a saved generated script via parent app pipeline
+    pub(super) on_run_script:
+        Option<Arc<dyn Fn(std::path::PathBuf, &mut Context<ChatPrompt>) + Send + Sync>>,
     // Stable UUID for Claude Code CLI session continuity within this prompt's lifetime.
     // Generated once at construction so all messages share the same session.
     pub(super) cli_session_id: String,
@@ -134,6 +137,7 @@
             on_configure: None,
             on_claude_code: None,
             on_show_actions: None,
+            on_run_script: None,
             cli_session_id: uuid::Uuid::new_v4().to_string(),
             pending_image: None,
             pending_image_render: None,
@@ -146,6 +150,15 @@
         self.on_show_actions = Some(callback);
     }
 
+    /// Set the callback for running a generated script path in the parent app.
+    pub fn with_run_script_callback(
+        mut self,
+        callback: impl Fn(std::path::PathBuf, &mut Context<Self>) + Send + Sync + 'static,
+    ) -> Self {
+        self.on_run_script = Some(Arc::new(callback));
+        self
+    }
+
     /// Start the cursor blink timer
     pub fn start_cursor_blink(&mut self, cx: &mut Context<Self>) {
         cx.spawn(async move |this, cx| {
diff --git a/src/prompts/chat/render_core.rs b/src/prompts/chat/render_core.rs
index 4e91d2d0ed474e69c143cd50e58e0491df58450b..7a066a4f6a2e6ac66e5e870f4a926cfbe0c56618
--- a/src/prompts/chat/render_core.rs
+++ b/src/prompts/chat/render_core.rs
@@ -32,10 +32,18 @@
         label: &'static str,
         shortcut: Option<&'static str>,
         action: ScriptGenerationAction,
-        accent_color: u32,
-        muted_color: u32,
+        footer_colors: PromptFooterColors,
         cx: &mut Context<Self>,
     ) -> AnyElement {
+        let button_font_size =
+            crate::components::prompt_footer::footer_button_font_size_px(&self.theme);
+        let hover_bg = rgba(crate::components::prompt_footer::footer_button_hover_rgba(
+            footer_colors,
+        ));
+        let active_bg = rgba(crate::components::prompt_footer::footer_button_active_rgba(
+            footer_colors,
+        ));
+
         div()
             .id(id)
             .flex()
@@ -46,9 +54,21 @@
             .py(px(2.0))
             .rounded(px(4.0))
             .cursor_pointer()
-            .child(div().text_xs().text_color(rgb(accent_color)).child(label))
+            .hover(move |d| d.bg(hover_bg))
+            .active(move |d| d.bg(active_bg))
+            .child(
+                div()
+                    .text_size(px(button_font_size))
+                    .text_color(rgb(footer_colors.accent))
+                    .child(label),
+            )
             .when_some(shortcut, |d, shortcut| {
-                d.child(div().text_xs().text_color(rgb(muted_color)).child(shortcut))
+                d.child(
+                    div()
+                        .text_size(px(button_font_size))
+                        .text_color(rgb(footer_colors.text_muted))
+                        .child(shortcut),
+                )
             })
             .on_click(cx.listener(move |this, _event, _window, cx| {
                 this.handle_script_generation_action(action, cx);
@@ -109,10 +129,9 @@
             self.render_script_generation_footer_button(
                 "chat-footer-primary-button",
                 "Save and Run",
-                None,
+                Some("⌘↵"),
                 ScriptGenerationAction::SaveAndRun,
-                footer_colors.accent,
-                footer_colors.text_muted,
+                footer_colors,
                 cx,
             )
         } else {
@@ -194,8 +213,7 @@
                     "Save",
                     None,
                     ScriptGenerationAction::Save,
-                    footer_colors.accent,
-                    footer_colors.text_muted,
+                    footer_colors,
                     cx,
                 ))
                 .child(self.render_script_generation_footer_button(
@@ -203,8 +221,7 @@
                     "Run",
                     None,
                     ScriptGenerationAction::Run,
-                    footer_colors.accent,
-                    footer_colors.text_muted,
+                    footer_colors,
                     cx,
                 ));
         }
@@ -356,7 +373,13 @@
                     }
                 }
                 ChatInputKeyAction::ToggleActions => this.toggle_actions_menu(cx),
-                ChatInputKeyAction::ContinueInChat => this.handle_continue_in_chat(cx),
+                ChatInputKeyAction::ContinueInChat => {
+                    if this.script_generation_mode {
+                        this.handle_script_generation_action(ScriptGenerationAction::SaveAndRun, cx);
+                    } else {
+                        this.handle_continue_in_chat(cx);
+                    }
+                }
                 ChatInputKeyAction::Submit => this.handle_submit(cx),
                 ChatInputKeyAction::InsertNewline => {
                     this.input.insert_char('\n');
@@ -618,7 +641,9 @@
             "Footer primary action should branch on script_generation_mode"
         );
         assert!(
-            normalized.contains("\"chat-footer-primary-button\",\"SaveandRun\",None,ScriptGenerationAction::SaveAndRun,"),
+            normalized.contains(
+                "\"chat-footer-primary-button\",\"SaveandRun\",Some(\"⌘↵\"),ScriptGenerationAction::SaveAndRun,"
+            ),
             "Script generation mode should render Save and Run as the primary footer action"
         );
         assert!(
@@ -647,4 +672,18 @@
             "Save and Run should only appear as the primary footer action slot"
         );
     }
+
+    #[test]
+    fn test_cmd_enter_runs_save_and_run_when_script_generation_mode_enabled() {
+        let content = fs::read_to_string("src/prompts/chat/render_core.rs")
+            .expect("Failed to read src/prompts/chat/render_core.rs");
+        let normalized: String = content.chars().filter(|c| !c.is_whitespace()).collect();
+
+        assert!(
+            normalized.contains(
+                "ChatInputKeyAction::ContinueInChat=>{ifthis.script_generation_mode{this.handle_script_generation_action(ScriptGenerationAction::SaveAndRun,cx);}else{this.handle_continue_in_chat(cx);}}"
+            ),
+            "Cmd+Enter should trigger SaveAndRun in script generation mode and ContinueInChat otherwise"
+        );
+    }
 }


thinking
**Assessing path usage in script_generation**
exec
/bin/zsh -lc "cd /Users/johnlindquist/dev/script-kit-gpui && rg -n \"\\bPath\\b\" src/ai/script_generation.rs" in /Users/johnlindquist/dev/script-kit-gpui succeeded in 51ms:
4:use std::path::{Path, PathBuf};
151:pub(crate) fn run_saved_script(path: &Path) -> Result<()> {
412:    output_dir: &Path,
file update:
diff --git a/src/app_impl/prompt_ai.rs b/src/app_impl/prompt_ai.rs
index c8266b6cb798ec62e6e7e9a8a59005512e44b72f..6c10ca4234dc2d80bb14bc0d5163caddf97656cc
--- a/src/app_impl/prompt_ai.rs
+++ b/src/app_impl/prompt_ai.rs
@@ -568,6 +568,38 @@
         let noop_callback: ChatSubmitCallback = std::sync::Arc::new(|_id, _text| {
             // Built-in AI mode handles this internally
         });
+        let app_entity = cx.entity().downgrade();
+        let run_script_callback = move |script_path: std::path::PathBuf,
+                                        chat_cx: &mut gpui::Context<ChatPrompt>| {
+            let script_path_string = script_path.to_string_lossy().to_string();
+            let app_entity = app_entity.clone();
+            chat_cx
+                .spawn(async move |_this, cx| {
+                    let _ = cx.update(|cx| {
+                        if let Some(app) = app_entity.upgrade() {
+                            logging::log(
+                                "CHAT_SCRIPT_GEN",
+                                &format!(
+                                    "state=dispatch_run attempted=execute_script_by_path path={}",
+                                    script_path_string
+                                ),
+                            );
+                            app.update(cx, |app, cx| {
+                                app.execute_script_by_path(&script_path_string, cx);
+                            });
+                        } else {
+                            logging::log(
+                                "CHAT_SCRIPT_GEN",
+                                &format!(
+                                    "state=dispatch_run_failed attempted=execute_script_by_path path={} reason=app_entity_unavailable",
+                                    script_path_string
+                                ),
+                            );
+                        }
+                    });
+                })
+                .detach();
+        };
 
         let placeholder = Some("Describe the script you want to generate...".to_string());
 
@@ -584,6 +616,7 @@
         .with_title("Generate Script with AI")
         .with_save_history(false)
         .with_escape_callback(escape_callback)
+        .with_run_script_callback(run_script_callback)
         .with_builtin_ai(registry, true) // true = prefer Vercel AI Gateway
         .with_builtin_system_prompt(crate::ai::script_generation::AI_SCRIPT_GENERATION_SYSTEM_PROMPT)
         .with_script_generation_mode(true);
diff --git a/src/components/prompt_footer.rs b/src/components/prompt_footer.rs
index 6bfa86a1edacaec90dc82185bb178cd09dfb7b61..0ce40c6c9c2ea6aa9f9e7599cb8065ebd2c5318b
--- a/src/components/prompt_footer.rs
+++ b/src/components/prompt_footer.rs
@@ -155,14 +155,19 @@
     )
 }
 
-fn footer_button_hover_rgba(colors: PromptFooterColors) -> u32 {
+pub fn footer_button_hover_rgba(colors: PromptFooterColors) -> u32 {
     (colors.background << 8) | (PROMPT_FOOTER_BUTTON_HOVER_OPACITY as u32)
 }
 
-fn footer_button_active_rgba(colors: PromptFooterColors) -> u32 {
+pub fn footer_button_active_rgba(colors: PromptFooterColors) -> u32 {
     (colors.background << 8) | (PROMPT_FOOTER_BUTTON_ACTIVE_OPACITY as u32)
 }
 
+pub fn footer_button_font_size_px(theme: &Theme) -> f32 {
+    (theme.get_fonts().ui_size - PROMPT_FOOTER_BUTTON_FONT_DELTA_PX)
+        .max(PROMPT_FOOTER_BUTTON_FONT_MIN_PX)
+}
+
 /// Configuration for PromptFooter display
 #[derive(Clone, Debug)]
 pub struct PromptFooterConfig {
@@ -334,8 +339,7 @@
         on_click: Option<Rc<FooterClickCallback>>,
     ) -> impl IntoElement {
         let theme = crate::theme::get_cached_theme();
-        let button_font_size = (theme.get_fonts().ui_size - PROMPT_FOOTER_BUTTON_FONT_DELTA_PX)
-            .max(PROMPT_FOOTER_BUTTON_FONT_MIN_PX);
+        let button_font_size = footer_button_font_size_px(&theme);
         let has_click_handler = on_click.is_some();
         let is_clickable = is_footer_button_clickable(has_click_handler, disabled);
         let on_click_for_key = on_click.clone();
diff --git a/src/prompts/chat/actions.rs b/src/prompts/chat/actions.rs
index 8ae41af43235d867176126f8de45f9fc8f3f2cbf..4d01323e1d134ef8e6f56be60d0a1eee086247e7
--- a/src/prompts/chat/actions.rs
+++ b/src/prompts/chat/actions.rs
@@ -172,48 +172,36 @@
 
         if action.should_run_after_save() {
             self.set_script_generation_status(false, format!("Running {}...", script_name), cx);
-
-            let path_clone = script_path.clone();
-            let name_clone = script_name.clone();
-            cx.spawn(async move |this, cx| {
-                let run_result = std::thread::spawn(move || {
-                    crate::ai::script_generation::run_saved_script(&path_clone)
-                })
-                .join()
-                .map_err(|_| anyhow::anyhow!("run thread panicked"))
-                .and_then(|r| r);
-
-                let _ = cx.update(|cx| {
-                    this.update(cx, |chat, cx| match run_result {
-                        Ok(()) => {
-                            chat.set_script_generation_status(
-                                false,
-                                format!("Saved and running {}", name_clone),
-                                cx,
-                            );
-                            logging::log(
-                                "CHAT_SCRIPT_GEN",
-                                &format!("state=run_ok action={:?} script={}", action, name_clone),
-                            );
-                        }
-                        Err(error) => {
-                            chat.set_script_generation_status(
-                                true,
-                                format!("Saved {} but failed to run: {}", name_clone, error),
-                                cx,
-                            );
-                            logging::log(
-                                "CHAT_SCRIPT_GEN",
-                                &format!(
-                                    "state=run_failed action={:?} script={} error={}",
-                                    action, name_clone, error
-                                ),
-                            );
-                        }
-                    })
-                });
-            })
-            .detach();
+            if let Some(ref callback) = self.on_run_script {
+                callback(script_path.clone(), cx);
+                self.set_script_generation_status(
+                    false,
+                    format!("Saved and running {}", script_name),
+                    cx,
+                );
+                logging::log(
+                    "CHAT_SCRIPT_GEN",
+                    &format!(
+                        "state=run_dispatched action={:?} path={}",
+                        action,
+                        script_path.display()
+                    ),
+                );
+            } else {
+                self.set_script_generation_status(
+                    true,
+                    format!("Saved {} but run action is unavailable", script_name),
+                    cx,
+                );
+                logging::log(
+                    "CHAT_SCRIPT_GEN",
+                    &format!(
+                        "state=run_dispatch_failed action={:?} path={} reason=missing_callback",
+                        action,
+                        script_path.display()
+                    ),
+                );
+            }
             return;
         }
 
diff --git a/src/prompts/chat/prompt.rs b/src/prompts/chat/prompt.rs
index 4ef4ac1aae4123a9bdd9771500998f87f424660b..78a8d8354e9e50914fdbcf1cc0fce0292b4feac2
--- a/src/prompts/chat/prompt.rs
+++ b/src/prompts/chat/prompt.rs
@@ -60,6 +60,9 @@
     pub(super) on_claude_code: Option<ChatClaudeCodeCallback>,
     // Callback for showing actions dialog (handled by parent)
     pub(super) on_show_actions: Option<ChatShowActionsCallback>,
+    // Callback for running a saved generated script via parent app pipeline
+    pub(super) on_run_script:
+        Option<Arc<dyn Fn(std::path::PathBuf, &mut Context<ChatPrompt>) + Send + Sync>>,
     // Stable UUID for Claude Code CLI session continuity within this prompt's lifetime.
     // Generated once at construction so all messages share the same session.
     pub(super) cli_session_id: String,
@@ -134,6 +137,7 @@
             on_configure: None,
             on_claude_code: None,
             on_show_actions: None,
+            on_run_script: None,
             cli_session_id: uuid::Uuid::new_v4().to_string(),
             pending_image: None,
             pending_image_render: None,
@@ -146,6 +150,15 @@
         self.on_show_actions = Some(callback);
     }
 
+    /// Set the callback for running a generated script path in the parent app.
+    pub fn with_run_script_callback(
+        mut self,
+        callback: impl Fn(std::path::PathBuf, &mut Context<Self>) + Send + Sync + 'static,
+    ) -> Self {
+        self.on_run_script = Some(Arc::new(callback));
+        self
+    }
+
     /// Start the cursor blink timer
     pub fn start_cursor_blink(&mut self, cx: &mut Context<Self>) {
         cx.spawn(async move |this, cx| {
diff --git a/src/prompts/chat/render_core.rs b/src/prompts/chat/render_core.rs
index 4e91d2d0ed474e69c143cd50e58e0491df58450b..7a066a4f6a2e6ac66e5e870f4a926cfbe0c56618
--- a/src/prompts/chat/render_core.rs
+++ b/src/prompts/chat/render_core.rs
@@ -32,10 +32,18 @@
         label: &'static str,
         shortcut: Option<&'static str>,
         action: ScriptGenerationAction,
-        accent_color: u32,
-        muted_color: u32,
+        footer_colors: PromptFooterColors,
         cx: &mut Context<Self>,
     ) -> AnyElement {
+        let button_font_size =
+            crate::components::prompt_footer::footer_button_font_size_px(&self.theme);
+        let hover_bg = rgba(crate::components::prompt_footer::footer_button_hover_rgba(
+            footer_colors,
+        ));
+        let active_bg = rgba(crate::components::prompt_footer::footer_button_active_rgba(
+            footer_colors,
+        ));
+
         div()
             .id(id)
             .flex()
@@ -46,9 +54,21 @@
             .py(px(2.0))
             .rounded(px(4.0))
             .cursor_pointer()
-            .child(div().text_xs().text_color(rgb(accent_color)).child(label))
+            .hover(move |d| d.bg(hover_bg))
+            .active(move |d| d.bg(active_bg))
+            .child(
+                div()
+                    .text_size(px(button_font_size))
+                    .text_color(rgb(footer_colors.accent))
+                    .child(label),
+            )
             .when_some(shortcut, |d, shortcut| {
-                d.child(div().text_xs().text_color(rgb(muted_color)).child(shortcut))
+                d.child(
+                    div()
+                        .text_size(px(button_font_size))
+                        .text_color(rgb(footer_colors.text_muted))
+                        .child(shortcut),
+                )
             })
             .on_click(cx.listener(move |this, _event, _window, cx| {
                 this.handle_script_generation_action(action, cx);
@@ -109,10 +129,9 @@
             self.render_script_generation_footer_button(
                 "chat-footer-primary-button",
                 "Save and Run",
-                None,
+                Some("⌘↵"),
                 ScriptGenerationAction::SaveAndRun,
-                footer_colors.accent,
-                footer_colors.text_muted,
+                footer_colors,
                 cx,
             )
         } else {
@@ -194,8 +213,7 @@
                     "Save",
                     None,
                     ScriptGenerationAction::Save,
-                    footer_colors.accent,
-                    footer_colors.text_muted,
+                    footer_colors,
                     cx,
                 ))
                 .child(self.render_script_generation_footer_button(
@@ -203,8 +221,7 @@
                     "Run",
                     None,
                     ScriptGenerationAction::Run,
-                    footer_colors.accent,
-                    footer_colors.text_muted,
+                    footer_colors,
                     cx,
                 ));
         }
@@ -356,7 +373,13 @@
                     }
                 }
                 ChatInputKeyAction::ToggleActions => this.toggle_actions_menu(cx),
-                ChatInputKeyAction::ContinueInChat => this.handle_continue_in_chat(cx),
+                ChatInputKeyAction::ContinueInChat => {
+                    if this.script_generation_mode {
+                        this.handle_script_generation_action(ScriptGenerationAction::SaveAndRun, cx);
+                    } else {
+                        this.handle_continue_in_chat(cx);
+                    }
+                }
                 ChatInputKeyAction::Submit => this.handle_submit(cx),
                 ChatInputKeyAction::InsertNewline => {
                     this.input.insert_char('\n');
@@ -618,7 +641,9 @@
             "Footer primary action should branch on script_generation_mode"
         );
         assert!(
-            normalized.contains("\"chat-footer-primary-button\",\"SaveandRun\",None,ScriptGenerationAction::SaveAndRun,"),
+            normalized.contains(
+                "\"chat-footer-primary-button\",\"SaveandRun\",Some(\"⌘↵\"),ScriptGenerationAction::SaveAndRun,"
+            ),
             "Script generation mode should render Save and Run as the primary footer action"
         );
         assert!(
@@ -647,4 +672,18 @@
             "Save and Run should only appear as the primary footer action slot"
         );
     }
+
+    #[test]
+    fn test_cmd_enter_runs_save_and_run_when_script_generation_mode_enabled() {
+        let content = fs::read_to_string("src/prompts/chat/render_core.rs")
+            .expect("Failed to read src/prompts/chat/render_core.rs");
+        let normalized: String = content.chars().filter(|c| !c.is_whitespace()).collect();
+
+        assert!(
+            normalized.contains(
+                "ChatInputKeyAction::ContinueInChat=>{ifthis.script_generation_mode{this.handle_script_generation_action(ScriptGenerationAction::SaveAndRun,cx);}else{this.handle_continue_in_chat(cx);}}"
+            ),
+            "Cmd+Enter should trigger SaveAndRun in script generation mode and ContinueInChat otherwise"
+        );
+    }
 }


thinking
**Refining patch to keep import and remove function**
file update
M /Users/johnlindquist/dev/script-kit-gpui/src/ai/script_generation.rs
@@ -150,71 +150,2 @@
 
-pub(crate) fn run_saved_script(path: &Path) -> Result<()> {
-    let script_path = path.to_string_lossy().to_string();
-    let attempts: &[(&str, &[&str])] = &[
-        ("kit", &["run", &script_path]),
-        ("bun", &["run", &script_path]),
-    ];
-
-    let mut failures = Vec::new();
-
-    for &(cmd, args) in attempts {
-        let result = std::process::Command::new(cmd)
-            .args(args)
-            .stderr(std::process::Stdio::piped())
-            .stdout(std::process::Stdio::piped())
-            .spawn();
-
-        match result {
-            Ok(mut child) => {
-                // Wait briefly for quick failures (e.g. bun cache corruption, missing deps).
-                // If still running after the timeout, assume it launched successfully.
-                let timeout = std::time::Duration::from_secs(5);
-                let start = std::time::Instant::now();
-                loop {
-                    match child.try_wait() {
-                        Ok(Some(status)) if !status.success() => {
-                            let stderr_text = child
-                                .stderr
-                                .take()
-                                .map(|mut s| {
-                                    let mut buf = String::new();
-                                    std::io::Read::read_to_string(&mut s, &mut buf).ok();
-                                    buf
-                                })
-                                .unwrap_or_default();
-                            let detail = if stderr_text.trim().is_empty() {
-                                format!("exit {}", status)
-                            } else {
-                                stderr_text.trim().to_string()
-                            };
-                            failures.push(format!("{}: {}", cmd, detail));
-                            break;
-                        }
-                        Ok(Some(_)) => return Ok(()), // exited successfully
-                        Ok(None) => {
-                            if start.elapsed() >= timeout {
-                                return Ok(()); // still running — launched OK
-                            }
-                            std::thread::sleep(std::time::Duration::from_millis(50));
-                        }
-                        Err(error) => {
-                            failures.push(format!("{}: wait failed: {}", cmd, error));
-                            break;
-                        }
-                    }
-                }
-            }
-            Err(error) => {
-                failures.push(format!("{}: {}", cmd, error));
-            }
-        }
-    }
-
-    anyhow::bail!(
-        "Failed to run script (path={}, attempts={})",
-        path.display(),
-        failures.join(" | ")
-    );
-}
-
 fn select_generation_model(
apply_patch(auto_approved=true) exited 0 in 40ms:
Success. Updated the following files:
M /Users/johnlindquist/dev/script-kit-gpui/src/ai/script_generation.rs
file update:
diff --git a/src/ai/script_generation.rs b/src/ai/script_generation.rs
index f29715b032570028241789219179c413e5c5ed83..a89e4e8d4161e386089b6e3cac57975cd36b3cd0
--- a/src/ai/script_generation.rs
+++ b/src/ai/script_generation.rs
@@ -148,75 +148,6 @@
     Ok(script_path)
 }
 
-pub(crate) fn run_saved_script(path: &Path) -> Result<()> {
-    let script_path = path.to_string_lossy().to_string();
-    let attempts: &[(&str, &[&str])] = &[
-        ("kit", &["run", &script_path]),
-        ("bun", &["run", &script_path]),
-    ];
-
-    let mut failures = Vec::new();
-
-    for &(cmd, args) in attempts {
-        let result = std::process::Command::new(cmd)
-            .args(args)
-            .stderr(std::process::Stdio::piped())
-            .stdout(std::process::Stdio::piped())
-            .spawn();
-
-        match result {
-            Ok(mut child) => {
-                // Wait briefly for quick failures (e.g. bun cache corruption, missing deps).
-                // If still running after the timeout, assume it launched successfully.
-                let timeout = std::time::Duration::from_secs(5);
-                let start = std::time::Instant::now();
-                loop {
-                    match child.try_wait() {
-                        Ok(Some(status)) if !status.success() => {
-                            let stderr_text = child
-                                .stderr
-                                .take()
-                                .map(|mut s| {
-                                    let mut buf = String::new();
-                                    std::io::Read::read_to_string(&mut s, &mut buf).ok();
-                                    buf
-                                })
-                                .unwrap_or_default();
-                            let detail = if stderr_text.trim().is_empty() {
-                                format!("exit {}", status)
-                            } else {
-                                stderr_text.trim().to_string()
-                            };
-                            failures.push(format!("{}: {}", cmd, detail));
-                            break;
-                        }
-                        Ok(Some(_)) => return Ok(()), // exited successfully
-                        Ok(None) => {
-                            if start.elapsed() >= timeout {
-                                return Ok(()); // still running — launched OK
-                            }
-                            std::thread::sleep(std::time::Duration::from_millis(50));
-                        }
-                        Err(error) => {
-                            failures.push(format!("{}: wait failed: {}", cmd, error));
-                            break;
-                        }
-                    }
-                }
-            }
-            Err(error) => {
-                failures.push(format!("{}: {}", cmd, error));
-            }
-        }
-    }
-
-    anyhow::bail!(
-        "Failed to run script (path={}, attempts={})",
-        path.display(),
-        failures.join(" | ")
-    );
-}
-
 fn select_generation_model(
     registry: &ProviderRegistry,
 ) -> Result<(ModelInfo, Arc<dyn AiProvider>)> {
diff --git a/src/app_impl/prompt_ai.rs b/src/app_impl/prompt_ai.rs
index c8266b6cb798ec62e6e7e9a8a59005512e44b72f..6c10ca4234dc2d80bb14bc0d5163caddf97656cc
--- a/src/app_impl/prompt_ai.rs
+++ b/src/app_impl/prompt_ai.rs
@@ -568,6 +568,38 @@
         let noop_callback: ChatSubmitCallback = std::sync::Arc::new(|_id, _text| {
             // Built-in AI mode handles this internally
         });
+        let app_entity = cx.entity().downgrade();
+        let run_script_callback = move |script_path: std::path::PathBuf,
+                                        chat_cx: &mut gpui::Context<ChatPrompt>| {
+            let script_path_string = script_path.to_string_lossy().to_string();
+            let app_entity = app_entity.clone();
+            chat_cx
+                .spawn(async move |_this, cx| {
+                    let _ = cx.update(|cx| {
+                        if let Some(app) = app_entity.upgrade() {
+                            logging::log(
+                                "CHAT_SCRIPT_GEN",
+                                &format!(
+                                    "state=dispatch_run attempted=execute_script_by_path path={}",
+                                    script_path_string
+                                ),
+                            );
+                            app.update(cx, |app, cx| {
+                                app.execute_script_by_path(&script_path_string, cx);
+                            });
+                        } else {
+                            logging::log(
+                                "CHAT_SCRIPT_GEN",
+                                &format!(
+                                    "state=dispatch_run_failed attempted=execute_script_by_path path={} reason=app_entity_unavailable",
+                                    script_path_string
+                                ),
+                            );
+                        }
+                    });
+                })
+                .detach();
+        };
 
         let placeholder = Some("Describe the script you want to generate...".to_string());
 
@@ -584,6 +616,7 @@
         .with_title("Generate Script with AI")
         .with_save_history(false)
         .with_escape_callback(escape_callback)
+        .with_run_script_callback(run_script_callback)
         .with_builtin_ai(registry, true) // true = prefer Vercel AI Gateway
         .with_builtin_system_prompt(crate::ai::script_generation::AI_SCRIPT_GENERATION_SYSTEM_PROMPT)
         .with_script_generation_mode(true);
diff --git a/src/components/prompt_footer.rs b/src/components/prompt_footer.rs
index 6bfa86a1edacaec90dc82185bb178cd09dfb7b61..0ce40c6c9c2ea6aa9f9e7599cb8065ebd2c5318b
--- a/src/components/prompt_footer.rs
+++ b/src/components/prompt_footer.rs
@@ -155,14 +155,19 @@
     )
 }
 
-fn footer_button_hover_rgba(colors: PromptFooterColors) -> u32 {
+pub fn footer_button_hover_rgba(colors: PromptFooterColors) -> u32 {
     (colors.background << 8) | (PROMPT_FOOTER_BUTTON_HOVER_OPACITY as u32)
 }
 
-fn footer_button_active_rgba(colors: PromptFooterColors) -> u32 {
+pub fn footer_button_active_rgba(colors: PromptFooterColors) -> u32 {
     (colors.background << 8) | (PROMPT_FOOTER_BUTTON_ACTIVE_OPACITY as u32)
 }
 
+pub fn footer_button_font_size_px(theme: &Theme) -> f32 {
+    (theme.get_fonts().ui_size - PROMPT_FOOTER_BUTTON_FONT_DELTA_PX)
+        .max(PROMPT_FOOTER_BUTTON_FONT_MIN_PX)
+}
+
 /// Configuration for PromptFooter display
 #[derive(Clone, Debug)]
 pub struct PromptFooterConfig {
@@ -334,8 +339,7 @@
         on_click: Option<Rc<FooterClickCallback>>,
     ) -> impl IntoElement {
         let theme = crate::theme::get_cached_theme();
-        let button_font_size = (theme.get_fonts().ui_size - PROMPT_FOOTER_BUTTON_FONT_DELTA_PX)
-            .max(PROMPT_FOOTER_BUTTON_FONT_MIN_PX);
+        let button_font_size = footer_button_font_size_px(&theme);
         let has_click_handler = on_click.is_some();
         let is_clickable = is_footer_button_clickable(has_click_handler, disabled);
         let on_click_for_key = on_click.clone();
diff --git a/src/prompts/chat/actions.rs b/src/prompts/chat/actions.rs
index 8ae41af43235d867176126f8de45f9fc8f3f2cbf..4d01323e1d134ef8e6f56be60d0a1eee086247e7
--- a/src/prompts/chat/actions.rs
+++ b/src/prompts/chat/actions.rs
@@ -172,48 +172,36 @@
 
         if action.should_run_after_save() {
             self.set_script_generation_status(false, format!("Running {}...", script_name), cx);
-
-            let path_clone = script_path.clone();
-            let name_clone = script_name.clone();
-            cx.spawn(async move |this, cx| {
-                let run_result = std::thread::spawn(move || {
-                    crate::ai::script_generation::run_saved_script(&path_clone)
-                })
-                .join()
-                .map_err(|_| anyhow::anyhow!("run thread panicked"))
-                .and_then(|r| r);
-
-                let _ = cx.update(|cx| {
-                    this.update(cx, |chat, cx| match run_result {
-                        Ok(()) => {
-                            chat.set_script_generation_status(
-                                false,
-                                format!("Saved and running {}", name_clone),
-                                cx,
-                            );
-                            logging::log(
-                                "CHAT_SCRIPT_GEN",
-                                &format!("state=run_ok action={:?} script={}", action, name_clone),
-                            );
-                        }
-                        Err(error) => {
-                            chat.set_script_generation_status(
-                                true,
-                                format!("Saved {} but failed to run: {}", name_clone, error),
-                                cx,
-                            );
-                            logging::log(
-                                "CHAT_SCRIPT_GEN",
-                                &format!(
-                                    "state=run_failed action={:?} script={} error={}",
-                                    action, name_clone, error
-                                ),
-                            );
-                        }
-                    })
-                });
-            })
-            .detach();
+            if let Some(ref callback) = self.on_run_script {
+                callback(script_path.clone(), cx);
+                self.set_script_generation_status(
+                    false,
+                    format!("Saved and running {}", script_name),
+                    cx,
+                );
+                logging::log(
+                    "CHAT_SCRIPT_GEN",
+                    &format!(
+                        "state=run_dispatched action={:?} path={}",
+                        action,
+                        script_path.display()
+                    ),
+                );
+            } else {
+                self.set_script_generation_status(
+                    true,
+                    format!("Saved {} but run action is unavailable", script_name),
+                    cx,
+                );
+                logging::log(
+                    "CHAT_SCRIPT_GEN",
+                    &format!(
+                        "state=run_dispatch_failed action={:?} path={} reason=missing_callback",
+                        action,
+                        script_path.display()
+                    ),
+                );
+            }
             return;
         }
 
diff --git a/src/prompts/chat/prompt.rs b/src/prompts/chat/prompt.rs
index 4ef4ac1aae4123a9bdd9771500998f87f424660b..78a8d8354e9e50914fdbcf1cc0fce0292b4feac2
--- a/src/prompts/chat/prompt.rs
+++ b/src/prompts/chat/prompt.rs
@@ -60,6 +60,9 @@
     pub(super) on_claude_code: Option<ChatClaudeCodeCallback>,
     // Callback for showing actions dialog (handled by parent)
     pub(super) on_show_actions: Option<ChatShowActionsCallback>,
+    // Callback for running a saved generated script via parent app pipeline
+    pub(super) on_run_script:
+        Option<Arc<dyn Fn(std::path::PathBuf, &mut Context<ChatPrompt>) + Send + Sync>>,
     // Stable UUID for Claude Code CLI session continuity within this prompt's lifetime.
     // Generated once at construction so all messages share the same session.
     pub(super) cli_session_id: String,
@@ -134,6 +137,7 @@
             on_configure: None,
             on_claude_code: None,
             on_show_actions: None,
+            on_run_script: None,
             cli_session_id: uuid::Uuid::new_v4().to_string(),
             pending_image: None,
             pending_image_render: None,
@@ -146,6 +150,15 @@
         self.on_show_actions = Some(callback);
     }
 
+    /// Set the callback for running a generated script path in the parent app.
+    pub fn with_run_script_callback(
+        mut self,
+        callback: impl Fn(std::path::PathBuf, &mut Context<Self>) + Send + Sync + 'static,
+    ) -> Self {
+        self.on_run_script = Some(Arc::new(callback));
+        self
+    }
+
     /// Start the cursor blink timer
     pub fn start_cursor_blink(&mut self, cx: &mut Context<Self>) {
         cx.spawn(async move |this, cx| {
diff --git a/src/prompts/chat/render_core.rs b/src/prompts/chat/render_core.rs
index 4e91d2d0ed474e69c143cd50e58e0491df58450b..7a066a4f6a2e6ac66e5e870f4a926cfbe0c56618
--- a/src/prompts/chat/render_core.rs
+++ b/src/prompts/chat/render_core.rs
@@ -32,10 +32,18 @@
         label: &'static str,
         shortcut: Option<&'static str>,
         action: ScriptGenerationAction,
-        accent_color: u32,
-        muted_color: u32,
+        footer_colors: PromptFooterColors,
         cx: &mut Context<Self>,
     ) -> AnyElement {
+        let button_font_size =
+            crate::components::prompt_footer::footer_button_font_size_px(&self.theme);
+        let hover_bg = rgba(crate::components::prompt_footer::footer_button_hover_rgba(
+            footer_colors,
+        ));
+        let active_bg = rgba(crate::components::prompt_footer::footer_button_active_rgba(
+            footer_colors,
+        ));
+
         div()
             .id(id)
             .flex()
@@ -46,9 +54,21 @@
             .py(px(2.0))
             .rounded(px(4.0))
             .cursor_pointer()
-            .child(div().text_xs().text_color(rgb(accent_color)).child(label))
+            .hover(move |d| d.bg(hover_bg))
+            .active(move |d| d.bg(active_bg))
+            .child(
+                div()
+                    .text_size(px(button_font_size))
+                    .text_color(rgb(footer_colors.accent))
+                    .child(label),
+            )
             .when_some(shortcut, |d, shortcut| {
-                d.child(div().text_xs().text_color(rgb(muted_color)).child(shortcut))
+                d.child(
+                    div()
+                        .text_size(px(button_font_size))
+                        .text_color(rgb(footer_colors.text_muted))
+                        .child(shortcut),
+                )
             })
             .on_click(cx.listener(move |this, _event, _window, cx| {
                 this.handle_script_generation_action(action, cx);
@@ -109,10 +129,9 @@
             self.render_script_generation_footer_button(
                 "chat-footer-primary-button",
                 "Save and Run",
-                None,
+                Some("⌘↵"),
                 ScriptGenerationAction::SaveAndRun,
-                footer_colors.accent,
-                footer_colors.text_muted,
+                footer_colors,
                 cx,
             )
         } else {
@@ -194,8 +213,7 @@
                     "Save",
                     None,
                     ScriptGenerationAction::Save,
-                    footer_colors.accent,
-                    footer_colors.text_muted,
+                    footer_colors,
                     cx,
                 ))
                 .child(self.render_script_generation_footer_button(
@@ -203,8 +221,7 @@
                     "Run",
                     None,
                     ScriptGenerationAction::Run,
-                    footer_colors.accent,
-                    footer_colors.text_muted,
+                    footer_colors,
                     cx,
                 ));
         }
@@ -356,7 +373,13 @@
                     }
                 }
                 ChatInputKeyAction::ToggleActions => this.toggle_actions_menu(cx),
-                ChatInputKeyAction::ContinueInChat => this.handle_continue_in_chat(cx),
+                ChatInputKeyAction::ContinueInChat => {
+                    if this.script_generation_mode {
+                        this.handle_script_generation_action(ScriptGenerationAction::SaveAndRun, cx);
+                    } else {
+                        this.handle_continue_in_chat(cx);
+                    }
+                }
                 ChatInputKeyAction::Submit => this.handle_submit(cx),
                 ChatInputKeyAction::InsertNewline => {
                     this.input.insert_char('\n');
@@ -618,7 +641,9 @@
             "Footer primary action should branch on script_generation_mode"
         );
         assert!(
-            normalized.contains("\"chat-footer-primary-button\",\"SaveandRun\",None,ScriptGenerationAction::SaveAndRun,"),
+            normalized.contains(
+                "\"chat-footer-primary-button\",\"SaveandRun\",Some(\"⌘↵\"),ScriptGenerationAction::SaveAndRun,"
+            ),
             "Script generation mode should render Save and Run as the primary footer action"
         );
         assert!(
@@ -647,4 +672,18 @@
             "Save and Run should only appear as the primary footer action slot"
         );
     }
+
+    #[test]
+    fn test_cmd_enter_runs_save_and_run_when_script_generation_mode_enabled() {
+        let content = fs::read_to_string("src/prompts/chat/render_core.rs")
+            .expect("Failed to read src/prompts/chat/render_core.rs");
+        let normalized: String = content.chars().filter(|c| !c.is_whitespace()).collect();
+
+        assert!(
+            normalized.contains(
+                "ChatInputKeyAction::ContinueInChat=>{ifthis.script_generation_mode{this.handle_script_generation_action(ScriptGenerationAction::SaveAndRun,cx);}else{this.handle_continue_in_chat(cx);}}"
+            ),
+            "Cmd+Enter should trigger SaveAndRun in script generation mode and ContinueInChat otherwise"
+        );
+    }
 }

file update:
diff --git a/src/ai/script_generation.rs b/src/ai/script_generation.rs
index f29715b032570028241789219179c413e5c5ed83..a89e4e8d4161e386089b6e3cac57975cd36b3cd0
--- a/src/ai/script_generation.rs
+++ b/src/ai/script_generation.rs
@@ -148,75 +148,6 @@
     Ok(script_path)
 }
 
-pub(crate) fn run_saved_script(path: &Path) -> Result<()> {
-    let script_path = path.to_string_lossy().to_string();
-    let attempts: &[(&str, &[&str])] = &[
-        ("kit", &["run", &script_path]),
-        ("bun", &["run", &script_path]),
-    ];
-
-    let mut failures = Vec::new();
-
-    for &(cmd, args) in attempts {
-        let result = std::process::Command::new(cmd)
-            .args(args)
-            .stderr(std::process::Stdio::piped())
-            .stdout(std::process::Stdio::piped())
-            .spawn();
-
-        match result {
-            Ok(mut child) => {
-                // Wait briefly for quick failures (e.g. bun cache corruption, missing deps).
-                // If still running after the timeout, assume it launched successfully.
-                let timeout = std::time::Duration::from_secs(5);
-                let start = std::time::Instant::now();
-                loop {
-                    match child.try_wait() {
-                        Ok(Some(status)) if !status.success() => {
-                            let stderr_text = child
-                                .stderr
-                                .take()
-                                .map(|mut s| {
-                                    let mut buf = String::new();
-                                    std::io::Read::read_to_string(&mut s, &mut buf).ok();
-                                    buf
-                                })
-                                .unwrap_or_default();
-                            let detail = if stderr_text.trim().is_empty() {
-                                format!("exit {}", status)
-                            } else {
-                                stderr_text.trim().to_string()
-                            };
-                            failures.push(format!("{}: {}", cmd, detail));
-                            break;
-                        }
-                        Ok(Some(_)) => return Ok(()), // exited successfully
-                        Ok(None) => {
-                            if start.elapsed() >= timeout {
-                                return Ok(()); // still running — launched OK
-                            }
-                            std::thread::sleep(std::time::Duration::from_millis(50));
-                        }
-                        Err(error) => {
-                            failures.push(format!("{}: wait failed: {}", cmd, error));
-                            break;
-                        }
-                    }
-                }
-            }
-            Err(error) => {
-                failures.push(format!("{}: {}", cmd, error));
-            }
-        }
-    }
-
-    anyhow::bail!(
-        "Failed to run script (path={}, attempts={})",
-        path.display(),
-        failures.join(" | ")
-    );
-}
-
 fn select_generation_model(
     registry: &ProviderRegistry,
 ) -> Result<(ModelInfo, Arc<dyn AiProvider>)> {
diff --git a/src/app_impl/prompt_ai.rs b/src/app_impl/prompt_ai.rs
index c8266b6cb798ec62e6e7e9a8a59005512e44b72f..6c10ca4234dc2d80bb14bc0d5163caddf97656cc
--- a/src/app_impl/prompt_ai.rs
+++ b/src/app_impl/prompt_ai.rs
@@ -568,6 +568,38 @@
         let noop_callback: ChatSubmitCallback = std::sync::Arc::new(|_id, _text| {
             // Built-in AI mode handles this internally
         });
+        let app_entity = cx.entity().downgrade();
+        let run_script_callback = move |script_path: std::path::PathBuf,
+                                        chat_cx: &mut gpui::Context<ChatPrompt>| {
+            let script_path_string = script_path.to_string_lossy().to_string();
+            let app_entity = app_entity.clone();
+            chat_cx
+                .spawn(async move |_this, cx| {
+                    let _ = cx.update(|cx| {
+                        if let Some(app) = app_entity.upgrade() {
+                            logging::log(
+                                "CHAT_SCRIPT_GEN",
+                                &format!(
+                                    "state=dispatch_run attempted=execute_script_by_path path={}",
+                                    script_path_string
+                                ),
+                            );
+                            app.update(cx, |app, cx| {
+                                app.execute_script_by_path(&script_path_string, cx);
+                            });
+                        } else {
+                            logging::log(
+                                "CHAT_SCRIPT_GEN",
+                                &format!(
+                                    "state=dispatch_run_failed attempted=execute_script_by_path path={} reason=app_entity_unavailable",
+                                    script_path_string
+                                ),
+                            );
+                        }
+                    });
+                })
+                .detach();
+        };
 
         let placeholder = Some("Describe the script you want to generate...".to_string());
 
@@ -584,6 +616,7 @@
         .with_title("Generate Script with AI")
         .with_save_history(false)
         .with_escape_callback(escape_callback)
+        .with_run_script_callback(run_script_callback)
         .with_builtin_ai(registry, true) // true = prefer Vercel AI Gateway
         .with_builtin_system_prompt(crate::ai::script_generation::AI_SCRIPT_GENERATION_SYSTEM_PROMPT)
         .with_script_generation_mode(true);
diff --git a/src/components/prompt_footer.rs b/src/components/prompt_footer.rs
index 6bfa86a1edacaec90dc82185bb178cd09dfb7b61..0ce40c6c9c2ea6aa9f9e7599cb8065ebd2c5318b
--- a/src/components/prompt_footer.rs
+++ b/src/components/prompt_footer.rs
@@ -155,14 +155,19 @@
     )
 }
 
-fn footer_button_hover_rgba(colors: PromptFooterColors) -> u32 {
+pub fn footer_button_hover_rgba(colors: PromptFooterColors) -> u32 {
     (colors.background << 8) | (PROMPT_FOOTER_BUTTON_HOVER_OPACITY as u32)
 }
 
-fn footer_button_active_rgba(colors: PromptFooterColors) -> u32 {
+pub fn footer_button_active_rgba(colors: PromptFooterColors) -> u32 {
     (colors.background << 8) | (PROMPT_FOOTER_BUTTON_ACTIVE_OPACITY as u32)
 }
 
+pub fn footer_button_font_size_px(theme: &Theme) -> f32 {
+    (theme.get_fonts().ui_size - PROMPT_FOOTER_BUTTON_FONT_DELTA_PX)
+        .max(PROMPT_FOOTER_BUTTON_FONT_MIN_PX)
+}
+
 /// Configuration for PromptFooter display
 #[derive(Clone, Debug)]
 pub struct PromptFooterConfig {
@@ -334,8 +339,7 @@
         on_click: Option<Rc<FooterClickCallback>>,
     ) -> impl IntoElement {
         let theme = crate::theme::get_cached_theme();
-        let button_font_size = (theme.get_fonts().ui_size - PROMPT_FOOTER_BUTTON_FONT_DELTA_PX)
-            .max(PROMPT_FOOTER_BUTTON_FONT_MIN_PX);
+        let button_font_size = footer_button_font_size_px(&theme);
         let has_click_handler = on_click.is_some();
         let is_clickable = is_footer_button_clickable(has_click_handler, disabled);
         let on_click_for_key = on_click.clone();
diff --git a/src/prompts/chat/actions.rs b/src/prompts/chat/actions.rs
index 8ae41af43235d867176126f8de45f9fc8f3f2cbf..4d01323e1d134ef8e6f56be60d0a1eee086247e7
--- a/src/prompts/chat/actions.rs
+++ b/src/prompts/chat/actions.rs
@@ -172,48 +172,36 @@
 
         if action.should_run_after_save() {
             self.set_script_generation_status(false, format!("Running {}...", script_name), cx);
-
-            let path_clone = script_path.clone();
-            let name_clone = script_name.clone();
-            cx.spawn(async move |this, cx| {
-                let run_result = std::thread::spawn(move || {
-                    crate::ai::script_generation::run_saved_script(&path_clone)
-                })
-                .join()
-                .map_err(|_| anyhow::anyhow!("run thread panicked"))
-                .and_then(|r| r);
-
-                let _ = cx.update(|cx| {
-                    this.update(cx, |chat, cx| match run_result {
-                        Ok(()) => {
-                            chat.set_script_generation_status(
-                                false,
-                                format!("Saved and running {}", name_clone),
-                                cx,
-                            );
-                            logging::log(
-                                "CHAT_SCRIPT_GEN",
-                                &format!("state=run_ok action={:?} script={}", action, name_clone),
-                            );
-                        }
-                        Err(error) => {
-                            chat.set_script_generation_status(
-                                true,
-                                format!("Saved {} but failed to run: {}", name_clone, error),
-                                cx,
-                            );
-                            logging::log(
-                                "CHAT_SCRIPT_GEN",
-                                &format!(
-                                    "state=run_failed action={:?} script={} error={}",
-                                    action, name_clone, error
-                                ),
-                            );
-                        }
-                    })
-                });
-            })
-            .detach();
+            if let Some(ref callback) = self.on_run_script {
+                callback(script_path.clone(), cx);
+                self.set_script_generation_status(
+                    false,
+                    format!("Saved and running {}", script_name),
+                    cx,
+                );
+                logging::log(
+                    "CHAT_SCRIPT_GEN",
+                    &format!(
+                        "state=run_dispatched action={:?} path={}",
+                        action,
+                        script_path.display()
+                    ),
+                );
+            } else {
+                self.set_script_generation_status(
+                    true,
+                    format!("Saved {} but run action is unavailable", script_name),
+                    cx,
+                );
+                logging::log(
+                    "CHAT_SCRIPT_GEN",
+                    &format!(
+                        "state=run_dispatch_failed action={:?} path={} reason=missing_callback",
+                        action,
+                        script_path.display()
+                    ),
+                );
+            }
             return;
         }
 
diff --git a/src/prompts/chat/prompt.rs b/src/prompts/chat/prompt.rs
index 4ef4ac1aae4123a9bdd9771500998f87f424660b..78a8d8354e9e50914fdbcf1cc0fce0292b4feac2
--- a/src/prompts/chat/prompt.rs
+++ b/src/prompts/chat/prompt.rs
@@ -60,6 +60,9 @@
     pub(super) on_claude_code: Option<ChatClaudeCodeCallback>,
     // Callback for showing actions dialog (handled by parent)
     pub(super) on_show_actions: Option<ChatShowActionsCallback>,
+    // Callback for running a saved generated script via parent app pipeline
+    pub(super) on_run_script:
+        Option<Arc<dyn Fn(std::path::PathBuf, &mut Context<ChatPrompt>) + Send + Sync>>,
     // Stable UUID for Claude Code CLI session continuity within this prompt's lifetime.
     // Generated once at construction so all messages share the same session.
     pub(super) cli_session_id: String,
@@ -134,6 +137,7 @@
             on_configure: None,
             on_claude_code: None,
             on_show_actions: None,
+            on_run_script: None,
             cli_session_id: uuid::Uuid::new_v4().to_string(),
             pending_image: None,
             pending_image_render: None,
@@ -146,6 +150,15 @@
         self.on_show_actions = Some(callback);
     }
 
+    /// Set the callback for running a generated script path in the parent app.
+    pub fn with_run_script_callback(
+        mut self,
+        callback: impl Fn(std::path::PathBuf, &mut Context<Self>) + Send + Sync + 'static,
+    ) -> Self {
+        self.on_run_script = Some(Arc::new(callback));
+        self
+    }
+
     /// Start the cursor blink timer
     pub fn start_cursor_blink(&mut self, cx: &mut Context<Self>) {
         cx.spawn(async move |this, cx| {
diff --git a/src/prompts/chat/render_core.rs b/src/prompts/chat/render_core.rs
index 4e91d2d0ed474e69c143cd50e58e0491df58450b..7a066a4f6a2e6ac66e5e870f4a926cfbe0c56618
--- a/src/prompts/chat/render_core.rs
+++ b/src/prompts/chat/render_core.rs
@@ -32,10 +32,18 @@
         label: &'static str,
         shortcut: Option<&'static str>,
         action: ScriptGenerationAction,
-        accent_color: u32,
-        muted_color: u32,
+        footer_colors: PromptFooterColors,
         cx: &mut Context<Self>,
     ) -> AnyElement {
+        let button_font_size =
+            crate::components::prompt_footer::footer_button_font_size_px(&self.theme);
+        let hover_bg = rgba(crate::components::prompt_footer::footer_button_hover_rgba(
+            footer_colors,
+        ));
+        let active_bg = rgba(crate::components::prompt_footer::footer_button_active_rgba(
+            footer_colors,
+        ));
+
         div()
             .id(id)
             .flex()
@@ -46,9 +54,21 @@
             .py(px(2.0))
             .rounded(px(4.0))
             .cursor_pointer()
-            .child(div().text_xs().text_color(rgb(accent_color)).child(label))
+            .hover(move |d| d.bg(hover_bg))
+            .active(move |d| d.bg(active_bg))
+            .child(
+                div()
+                    .text_size(px(button_font_size))
+                    .text_color(rgb(footer_colors.accent))
+                    .child(label),
+            )
             .when_some(shortcut, |d, shortcut| {
-                d.child(div().text_xs().text_color(rgb(muted_color)).child(shortcut))
+                d.child(
+                    div()
+                        .text_size(px(button_font_size))
+                        .text_color(rgb(footer_colors.text_muted))
+                        .child(shortcut),
+                )
             })
             .on_click(cx.listener(move |this, _event, _window, cx| {
                 this.handle_script_generation_action(action, cx);
@@ -109,10 +129,9 @@
             self.render_script_generation_footer_button(
                 "chat-footer-primary-button",
                 "Save and Run",
-                None,
+                Some("⌘↵"),
                 ScriptGenerationAction::SaveAndRun,
-                footer_colors.accent,
-                footer_colors.text_muted,
+                footer_colors,
                 cx,
             )
         } else {
@@ -194,8 +213,7 @@
                     "Save",
                     None,
                     ScriptGenerationAction::Save,
-                    footer_colors.accent,
-                    footer_colors.text_muted,
+                    footer_colors,
                     cx,
                 ))
                 .child(self.render_script_generation_footer_button(
@@ -203,8 +221,7 @@
                     "Run",
                     None,
                     ScriptGenerationAction::Run,
-                    footer_colors.accent,
-                    footer_colors.text_muted,
+                    footer_colors,
                     cx,
                 ));
         }
@@ -356,7 +373,13 @@
                     }
                 }
                 ChatInputKeyAction::ToggleActions => this.toggle_actions_menu(cx),
-                ChatInputKeyAction::ContinueInChat => this.handle_continue_in_chat(cx),
+                ChatInputKeyAction::ContinueInChat => {
+                    if this.script_generation_mode {
+                        this.handle_script_generation_action(ScriptGenerationAction::SaveAndRun, cx);
+                    } else {
+                        this.handle_continue_in_chat(cx);
+                    }
+                }
                 ChatInputKeyAction::Submit => this.handle_submit(cx),
                 ChatInputKeyAction::InsertNewline => {
                     this.input.insert_char('\n');
@@ -618,7 +641,9 @@
             "Footer primary action should branch on script_generation_mode"
         );
         assert!(
-            normalized.contains("\"chat-footer-primary-button\",\"SaveandRun\",None,ScriptGenerationAction::SaveAndRun,"),
+            normalized.contains(
+                "\"chat-footer-primary-button\",\"SaveandRun\",Some(\"⌘↵\"),ScriptGenerationAction::SaveAndRun,"
+            ),
             "Script generation mode should render Save and Run as the primary footer action"
         );
         assert!(
@@ -647,4 +672,18 @@
             "Save and Run should only appear as the primary footer action slot"
         );
     }
+
+    #[test]
+    fn test_cmd_enter_runs_save_and_run_when_script_generation_mode_enabled() {
+        let content = fs::read_to_string("src/prompts/chat/render_core.rs")
+            .expect("Failed to read src/prompts/chat/render_core.rs");
+        let normalized: String = content.chars().filter(|c| !c.is_whitespace()).collect();
+
+        assert!(
+            normalized.contains(
+                "ChatInputKeyAction::ContinueInChat=>{ifthis.script_generation_mode{this.handle_script_generation_action(ScriptGenerationAction::SaveAndRun,cx);}else{this.handle_continue_in_chat(cx);}}"
+            ),
+            "Cmd+Enter should trigger SaveAndRun in script generation mode and ContinueInChat otherwise"
+        );
+    }
 }


thinking
**Verifying cleanup and access modifiers**
exec
/bin/zsh -lc 'cd /Users/johnlindquist/dev/script-kit-gpui && git diff -- src/prompts/chat/prompt.rs src/prompts/chat/actions.rs src/prompts/chat/render_core.rs src/app_impl/prompt_ai.rs src/components/prompt_footer.rs src/ai/script_generation.rs' in /Users/johnlindquist/dev/script-kit-gpui succeeded in 51ms:
Total output lines: 1064

diff --git a/src/ai/script_generation.rs b/src/ai/script_generation.rs
index 8338b9c..a89e4e8 100644
--- a/src/ai/script_generation.rs
+++ b/src/ai/script_generation.rs
@@ -10,19 +10,25 @@ use super::providers::{AiProvider, ProviderMessage, ProviderRegistry};
 const AI_SCRIPT_OUTPUT_DIR: &str = "~/.kenv/scripts";
 const AI_SCRIPT_DEFAULT_SLUG: &str = "ai-script";
 const AI_SCRIPT_MAX_SLUG_LEN: usize = 64;
+const SCRIPT_KIT_SDK_IMPORT_MODULE: &str = "@scriptkit/sdk";
+const SCRIPT_KIT_SDK_IMPORT_STATEMENT: &str = "import \"@scriptkit/sdk\";";
 
-const AI_SCRIPT_GENERATION_SYSTEM_PROMPT: &str = r#"You write production-ready Script Kit scripts.
+pub(crate) const AI_SCRIPT_GENERATION_SYSTEM_PROMPT: &str =
+    r#"You write production-ready Script Kit TypeScript scripts.
 
-Return ONLY TypeScript source code for one Script Kit script. Do not include explanations.
+Return ONLY TypeScript source code for one Script Kit script.
+Do not return markdown fences or explanations.
file update:
diff --git a/src/ai/script_generation.rs b/src/ai/script_generation.rs
index f29715b032570028241789219179c413e5c5ed83..a89e4e8d4161e386089b6e3cac57975cd36b3cd0
--- a/src/ai/script_generation.rs
+++ b/src/ai/script_generation.rs
@@ -148,75 +148,6 @@
     Ok(script_path)
 }
 
-pub(crate) fn run_saved_script(path: &Path) -> Result<()> {
-    let script_path = path.to_string_lossy().to_string();
-    let attempts: &[(&str, &[&str])] = &[
-        ("kit", &["run", &script_path]),
-        ("bun", &["run", &script_path]),
-    ];
-
-    let mut failures = Vec::new();
-
-    for &(cmd, args) in attempts {
-        let result = std::process::Command::new(cmd)
-            .args(args)
-            .stderr(std::process::Stdio::piped())
-            .stdout(std::process::Stdio::piped())
-            .spawn();
-
-        match result {
-            Ok(mut child) => {
-                // Wait briefly for quick failures (e.g. bun cache corruption, missing deps).
-                // If still running after the timeout, assume it launched successfully.
-                let timeout = std::time::Duration::from_secs(5);
-                let start = std::time::Instant::now();
-                loop {
-                    match child.try_wait() {
-                        Ok(Some(status)) if !status.success() => {
-                            let stderr_text = child
-                                .stderr
-                                .take()
-                                .map(|mut s| {
-                                    let mut buf = String::new();
-                                    std::io::Read::read_to_string(&mut s, &mut buf).ok();
-                                    buf
-                                })
-                                .unwrap_or_default();
-                            let detail = if stderr_text.trim().is_empty() {
-                                format!("exit {}", status)
-                            } else {
-                                stderr_text.trim().to_string()
-                            };
-                            failures.push(format!("{}: {}", cmd, detail));
-                            break;
-                        }
-                        Ok(Some(_)) => return Ok(()), // exited successfully
-                        Ok(None) => {
-                            if start.elapsed() >= timeout {
-                                return Ok(()); // still running — launched OK
-                            }
-                            std::thread::sleep(std::time::Duration::from_millis(50));
-                        }
-                        Err(error) => {
-                            failures.push(format!("{}: wait failed: {}", cmd, error));
-                            break;
-                        }
-                    }
-                }
-            }
-            Err(error) => {
-                failures.push(format!("{}: {}", cmd, error));
-            }
-        }
-    }
-
-    anyhow::bail!(
-        "Failed to run script (path={}, attempts={})",
-        path.display(),
-        failures.join(" | ")
-    );
-}
-
 fn select_generation_model(
     registry: &ProviderRegistry,
 ) -> Result<(ModelInfo, Arc<dyn AiProvider>)> {
diff --git a/src/app_impl/prompt_ai.rs b/src/app_impl/prompt_ai.rs
index c8266b6cb798ec62e6e7e9a8a59005512e44b72f..6c10ca4234dc2d80bb14bc0d5163caddf97656cc
--- a/src/app_impl/prompt_ai.rs
+++ b/src/app_impl/prompt_ai.rs
@@ -568,6 +568,38 @@
         let noop_callback: ChatSubmitCallback = std::sync::Arc::new(|_id, _text| {
             // Built-in AI mode handles this internally
         });
+        let app_entity = cx.entity().downgrade();
+        let run_script_callback = move |script_path: std::path::PathBuf,
+                                        chat_cx: &mut gpui::Context<ChatPrompt>| {
+            let script_path_string = script_path.to_string_lossy().to_string();
+            let app_entity = app_entity.clone();
+            chat_cx
+                .spawn(async move |_this, cx| {
+                    let _ = cx.update(|cx| {
+                        if let Some(app) = app_entity.upgrade() {
+                            logging::log(
+                                "CHAT_SCRIPT_GEN",
+                                &format!(
+                                    "state=dispatch_run attempted=execute_script_by_path path={}",
+                                    script_path_string
+                                ),
+                            );
+                            app.update(cx, |app, cx| {
+                                app.execute_script_by_path(&script_path_string, cx);
+                            });
+                        } else {
+                            logging::log(
+                                "CHAT_SCRIPT_GEN",
+                                &format!(
+                                    "state=dispatch_run_failed attempted=execute_script_by_path path={} reason=app_entity_unavailable",
+                                    script_path_string
+                                ),
+                            );
+                        }
+                    });
+                })
+                .detach();
+        };
 
         let placeholder = Some("Describe the script you want to generate...".to_string());
 
@@ -584,6 +616,7 @@
         .with_title("Generate Script with AI")
         .with_save_history(false)
         .with_escape_callback(escape_callback)
+        .with_run_script_callback(run_script_callback)
         .with_builtin_ai(registry, true) // true = prefer Vercel AI Gateway
         .with_builtin_system_prompt(crate::ai::script_generation::AI_SCRIPT_GENERATION_SYSTEM_PROMPT)
         .with_script_generation_mode(true);
diff --git a/src/components/prompt_footer.rs b/src/components/prompt_footer.rs
index 6bfa86a1edacaec90dc82185bb178cd09dfb7b61..0ce40c6c9c2ea6aa9f9e7599cb8065ebd2c5318b
--- a/src/components/prompt_footer.rs
+++ b/src/components/prompt_footer.rs
@@ -155,14 +155,19 @@
     )
 }
 
-fn footer_button_hover_rgba(colors: PromptFooterColors) -> u32 {
+pub fn footer_button_hover_rgba(colors: PromptFooterColors) -> u32 {
     (colors.background << 8) | (PROMPT_FOOTER_BUTTON_HOVER_OPACITY as u32)
 }
 
-fn footer_button_active_rgba(colors: PromptFooterColors) -> u32 {
+pub fn footer_button_active_rgba(colors: PromptFooterColors) -> u32 {
     (colors.background << 8) | (PROMPT_FOOTER_BUTTON_ACTIVE_OPACITY as u32)
 }
 
+pub fn footer_button_font_size_px(theme: &Theme) -> f32 {
+    (theme.get_fonts().ui_size - PROMPT_FOOTER_BUTTON_FONT_DELTA_PX)
+        .max(PROMPT_FOOTER_BUTTON_FONT_MIN_PX)
+}
+
 /// Configuration for PromptFooter display
 #[derive(Clone, Debug)]
 pub struct PromptFooterConfig {
@@ -334,8 +339,7 @@
         on_click: Option<Rc<FooterClickCallback>>,
     ) -> impl IntoElement {
         let theme = crate::theme::get_cached_theme();
-        let button_font_size = (theme.get_fonts().ui_size - PROMPT_FOOTER_BUTTON_FONT_DELTA_PX)
-            .max(PROMPT_FOOTER_BUTTON_FONT_MIN_PX);
+        let button_font_size = footer_button_font_size_px(&theme);
         let has_click_handler = on_click.is_some();
         let is_clickable = is_footer_button_clickable(has_click_handler, disabled);
         let on_click_for_key = on_click.clone();
diff --git a/src/prompts/chat/actions.rs b/src/prompts/chat/actions.rs
index 8ae41af43235d867176126f8de45f9fc8f3f2cbf..4d01323e1d134ef8e6f56be60d0a1eee086247e7
--- a/src/prompts/chat/actions.rs
+++ b/src/prompts/chat/actions.rs
@@ -172,48 +172,36 @@
 
         if action.should_run_after_save() {
             self.set_script_generation_status(false, format!("Running {}...", script_name), cx);
-
-            let path_clone = script_path.clone();
-            let name_clone = script_name.clone();
-            cx.spawn(async move |this, cx| {
-                let run_result = std::thread::spawn(move || {
-                    crate::ai::script_generation::run_saved_script(&path_clone)
-                })
-                .join()
-                .map_err(|_| anyhow::anyhow!("run thread panicked"))
-                .and_then(|r| r);
-
-                let _ = cx.update(|cx| {
-                    this.update(cx, |chat, cx| match run_result {
-                        Ok(()) => {
-                            chat.set_script_generation_status(
-                                false,
-                                format!("Saved and running {}", name_clone),
-                                cx,
-                            );
-                            logging::log(
-                                "CHAT_SCRIPT_GEN",
-                                &format!("state=run_ok action={:?} script={}", action, name_clone),
-                            );
-                        }
-                        Err(error) => {
-                            chat.set_script_generation_status(
-                                true,
-                                format!("Saved {} but failed to run: {}", name_clone, error),
-                                cx,
-                            );
-                            logging::log(
-                                "CHAT_SCRIPT_GEN",
-                                &format!(
-                                    "state=run_failed action={:?} script={} error={}",
-                                    action, name_clone, error
-                                ),
-                            );
-                        }
-                    })
-                });
-            })
-            .detach();
+            if let Some(ref callback) = self.on_run_script {
+                callback(script_path.clone(), cx);
+                self.set_script_generation_status(
+                    false,
+                    format!("Saved and running {}", script_name),
+                    cx,
+                );
+                logging::log(
+                    "CHAT_SCRIPT_GEN",
+                    &format!(
+                        "state=run_dispatched action={:?} path={}",
+                        action,
+                        script_path.display()
+                    ),
+                );
+            } else {
+                self.set_script_generation_status(
+                    true,
+                    format!("Saved {} but run action is unavailable", script_name),
+                    cx,
+                );
+                logging::log(
+                    "CHAT_SCRIPT_GEN",
+                    &format!(
+                        "state=run_dispatch_failed action={:?} path={} reason=missing_callback",
+                        action,
+                        script_path.display()
+                    ),
+                );
+            }
             return;
         }
 
diff --git a/src/prompts/chat/prompt.rs b/src/prompts/chat/prompt.rs
index 4ef4ac1aae4123a9bdd9771500998f87f424660b..78a8d8354e9e50914fdbcf1cc0fce0292b4feac2
--- a/src/prompts/chat/prompt.rs
+++ b/src/prompts/chat/prompt.rs
@@ -60,6 +60,9 @@
     pub(super) on_claude_code: Option<ChatClaudeCodeCallback>,
     // Callback for showing actions dialog (handled by parent)
     pub(super) on_show_actions: Option<ChatShowActionsCallback>,
+    // Callback for running a saved generated script via parent app pipeline
+    pub(super) on_run_script:
+        Option<Arc<dyn Fn(std::path::PathBuf, &mut Context<ChatPrompt>) + Send + Sync>>,
     // Stable UUID for Claude Code CLI session continuity within this prompt's lifetime.
     // Generated once at construction so all messages share the same session.
     pub(super) cli_session_id: String,
@@ -134,6 +137,7 @@
             on_configure: None,
             on_claude_code: None,
             on_show_actions: None,
+            on_run_script: None,
             cli_session_id: uuid::Uuid::new_v4().to_string(),
             pending_image: None,
             pending_image_render: None,
@@ -146,6 +150,15 @@
         self.on_show_actions = Some(callback);
     }
 
+    /// Set the callback for running a generated script path in the parent app.
+    pub fn with_run_script_callback(
+        mut self,
+        callback: impl Fn(std::path::PathBuf, &mut Context<Self>) + Send + Sync + 'static,
+    ) -> Self {
+        self.on_run_script = Some(Arc::new(callback));
+        self
+    }
+
     /// Start the cursor blink timer
     pub fn start_cursor_blink(&mut self, cx: &mut Context<Self>) {
         cx.spawn(async move |this, cx| {
diff --git a/src/prompts/chat/render_core.rs b/src/prompts/chat/render_core.rs
index 4e91d2d0ed474e69c143cd50e58e0491df58450b..7a066a4f6a2e6ac66e5e870f4a926cfbe0c56618
--- a/src/prompts/chat/render_core.rs
+++ b/src/prompts/chat/render_core.rs
@@ -32,10 +32,18 @@
         label: &'static str,
         shortcut: Option<&'static str>,
         action: ScriptGenerationAction,
-        accent_color: u32,
-        muted_color: u32,
+        footer_colors: PromptFooterColors,
         cx: &mut Context<Self>,
     ) -> AnyElement {
+        let button_font_size =
+            crate::components::prompt_footer::footer_button_font_size_px(&self.theme);
+        let hover_bg = rgba(crate::components::prompt_footer::footer_button_hover_rgba(
+            footer_colors,
+        ));
+        let active_bg = rgba(crate::components::prompt_footer::footer_button_active_rgba(
+            footer_colors,
+        ));
+
         div()
             .id(id)
             .flex()
@@ -46,9 +54,21 @@
             .py(px(2.0))
             .rounded(px(4.0))
             .cursor_pointer()
-            .child(div().text_xs().text_color(rgb(accent_color)).child(label))
+            .hover(move |d| d.bg(hover_bg))
+            .active(move |d| d.bg(active_bg))
+            .child(
+                div()
+                    .text_size(px(button_font_size))
+                    .text_color(rgb(footer_colors.accent))
+                    .child(label),
+            )
             .when_some(shortcut, |d, shortcut| {
-                d.child(div().text_xs().text_color(rgb(muted_color)).child(shortcut))
+                d.child(
+                    div()
+                        .text_size(px(button_font_size))
+                        .text_color(rgb(footer_colors.text_muted))
+                        .child(shortcut),
+                )
             })
             .on_click(cx.listener(move |this, _event, _window, cx| {
                 this.handle_script_generation_action(action, cx);
@@ -109,10 +129,9 @@
             self.render_script_generation_footer_button(
                 "chat-footer-primary-button",
                 "Save and Run",
-                None,
+                Some("⌘↵"),
                 ScriptGenerationAction::SaveAndRun,
-                footer_colors.accent,
-                footer_colors.text_muted,
+                footer_colors,
                 cx,
             )
         } else {
@@ -194,8 +213,7 @@
                     "Save",
                     None,
                     ScriptGenerationAction::Save,
-                    footer_colors.accent,
-                    footer_colors.text_muted,
+                    footer_colors,
                     cx,
                 ))
                 .child(self.render_script_generation_footer_button(
@@ -203,8 +221,7 @@
                     "Run",
                     None,
                     ScriptGenerationAction::Run,
-                    footer_colors.accent,
-                    footer_colors.text_muted,
+                    footer_colors,
                     cx,
                 ));
         }
@@ -356,7 +373,13 @@
                     }
                 }
                 ChatInputKeyAction::ToggleActions => this.toggle_actions_menu(cx),
-                ChatInputKeyAction::ContinueInChat => this.handle_continue_in_chat(cx),
+                ChatInputKeyAction::ContinueInChat => {
+                    if this.script_generation_mode {
+                        this.handle_script_generation_action(ScriptGenerationAction::SaveAndRun, cx);
+                    } else {
+                        this.handle_continue_in_chat(cx);
+                    }
+                }
                 ChatInputKeyAction::Submit => this.handle_submit(cx),
                 ChatInputKeyAction::InsertNewline => {
                     this.input.insert_char('\n');
@@ -618,7 +641,9 @@
             "Footer primary action should branch on script_generation_mode"
         );
         assert!(
-            normalized.contains("\"chat-footer-primary-button\",\"SaveandRun\",None,ScriptGenerationAction::SaveAndRun,"),
+            normalized.contains(
+                "\"chat-footer-primary-button\",\"SaveandRun\",Some(\"⌘↵\"),ScriptGenerationAction::SaveAndRun,"
+            ),
             "Script generation mode should render Save and Run as the primary footer action"
         );
         assert!(
@@ -647,4 +672,18 @@
             "Save and Run should only appear as the primary footer action slot"
         );
     }
+
+    #[test]
+    fn test_cmd_enter_runs_save_and_run_when_script_generation_mode_enabled() {
+        let content = fs::read_to_string("src/prompts/chat/render_core.rs")
+            .expect("Failed to read src/prompts/chat/render_core.rs");
+        let normalized: String = content.chars().filter(|c| !c.is_whitespace()).collect();
+
+        assert!(
+            normalized.contains(
+                "ChatInputKeyAction::ContinueInChat=>{ifthis.script_generation_mode{this.handle_script_generation_action(ScriptGenerationAction::SaveAndRun,cx);}else{this.handle_continue_in_chat(cx);}}"
+            ),
+            "Cmd+Enter should trigger SaveAndRun in script generation mode and ContinueInChat otherwise"
+        );
+    }
 }


thinking
**Verifying function duplication risk**
exec
/bin/zsh -lc 'cd /Users/johnlindquist/dev/script-kit-gpui && rg -n "pub fn show_script_generation_chat" src/app_impl/prompt_ai.rs' in /Users/johnlindquist/dev/script-kit-gpui succeeded in 50ms:
471:    pub fn show_script_generation_chat(
file update:
diff --git a/src/ai/script_generation.rs b/src/ai/script_generation.rs
index f29715b032570028241789219179c413e5c5ed83..a89e4e8d4161e386089b6e3cac57975cd36b3cd0
--- a/src/ai/script_generation.rs
+++ b/src/ai/script_generation.rs
@@ -148,75 +148,6 @@
     Ok(script_path)
 }
 
-pub(crate) fn run_saved_script(path: &Path) -> Result<()> {
-    let script_path = path.to_string_lossy().to_string();
-    let attempts: &[(&str, &[&str])] = &[
-        ("kit", &["run", &script_path]),
-        ("bun", &["run", &script_path]),
-    ];
-
-    let mut failures = Vec::new();
-
-    for &(cmd, args) in attempts {
-        let result = std::process::Command::new(cmd)
-            .args(args)
-            .stderr(std::process::Stdio::piped())
-            .stdout(std::process::Stdio::piped())
-            .spawn();
-
-        match result {
-            Ok(mut child) => {
-                // Wait briefly for quick failures (e.g. bun cache corruption, missing deps).
-                // If still running after the timeout, assume it launched successfully.
-                let timeout = std::time::Duration::from_secs(5);
-                let start = std::time::Instant::now();
-                loop {
-                    match child.try_wait() {
-                        Ok(Some(status)) if !status.success() => {
-                            let stderr_text = child
-                                .stderr
-                                .take()
-                                .map(|mut s| {
-                                    let mut buf = String::new();
-                                    std::io::Read::read_to_string(&mut s, &mut buf).ok();
-                                    buf
-                                })
-                                .unwrap_or_default();
-                            let detail = if stderr_text.trim().is_empty() {
-                                format!("exit {}", status)
-                            } else {
-                                stderr_text.trim().to_string()
-                            };
-                            failures.push(format!("{}: {}", cmd, detail));
-                            break;
-                        }
-                        Ok(Some(_)) => return Ok(()), // exited successfully
-                        Ok(None) => {
-                            if start.elapsed() >= timeout {
-                                return Ok(()); // still running — launched OK
-                            }
-                            std::thread::sleep(std::time::Duration::from_millis(50));
-                        }
-                        Err(error) => {
-                            failures.push(format!("{}: wait failed: {}", cmd, error));
-                            break;
-                        }
-                    }
-                }
-            }
-            Err(error) => {
-                failures.push(format!("{}: {}", cmd, error));
-            }
-        }
-    }
-
-    anyhow::bail!(
-        "Failed to run script (path={}, attempts={})",
-        path.display(),
-        failures.join(" | ")
-    );
-}
-
 fn select_generation_model(
     registry: &ProviderRegistry,
 ) -> Result<(ModelInfo, Arc<dyn AiProvider>)> {
diff --git a/src/app_impl/prompt_ai.rs b/src/app_impl/prompt_ai.rs
index c8266b6cb798ec62e6e7e9a8a59005512e44b72f..6c10ca4234dc2d80bb14bc0d5163caddf97656cc
--- a/src/app_impl/prompt_ai.rs
+++ b/src/app_impl/prompt_ai.rs
@@ -568,6 +568,38 @@
         let noop_callback: ChatSubmitCallback = std::sync::Arc::new(|_id, _text| {
             // Built-in AI mode handles this internally
         });
+        let app_entity = cx.entity().downgrade();
+        let run_script_callback = move |script_path: std::path::PathBuf,
+                                        chat_cx: &mut gpui::Context<ChatPrompt>| {
+            let script_path_string = script_path.to_string_lossy().to_string();
+            let app_entity = app_entity.clone();
+            chat_cx
+                .spawn(async move |_this, cx| {
+                    let _ = cx.update(|cx| {
+                        if let Some(app) = app_entity.upgrade() {
+                            logging::log(
+                                "CHAT_SCRIPT_GEN",
+                                &format!(
+                                    "state=dispatch_run attempted=execute_script_by_path path={}",
+                                    script_path_string
+                                ),
+                            );
+                            app.update(cx, |app, cx| {
+                                app.execute_script_by_path(&script_path_string, cx);
+                            });
+                        } else {
+                            logging::log(
+                                "CHAT_SCRIPT_GEN",
+                                &format!(
+                                    "state=dispatch_run_failed attempted=execute_script_by_path path={} reason=app_entity_unavailable",
+                                    script_path_string
+                                ),
+                            );
+                        }
+                    });
+                })
+                .detach();
+        };
 
         let placeholder = Some("Describe the script you want to generate...".to_string());
 
@@ -584,6 +616,7 @@
         .with_title("Generate Script with AI")
         .with_save_history(false)
         .with_escape_callback(escape_callback)
+        .with_run_script_callback(run_script_callback)
         .with_builtin_ai(registry, true) // true = prefer Vercel AI Gateway
         .with_builtin_system_prompt(crate::ai::script_generation::AI_SCRIPT_GENERATION_SYSTEM_PROMPT)
         .with_script_generation_mode(true);
diff --git a/src/components/prompt_footer.rs b/src/components/prompt_footer.rs
index 6bfa86a1edacaec90dc82185bb178cd09dfb7b61..0ce40c6c9c2ea6aa9f9e7599cb8065ebd2c5318b
--- a/src/components/prompt_footer.rs
+++ b/src/components/prompt_footer.rs
@@ -155,14 +155,19 @@
     )
 }
 
-fn footer_button_hover_rgba(colors: PromptFooterColors) -> u32 {
+pub fn footer_button_hover_rgba(colors: PromptFooterColors) -> u32 {
     (colors.background << 8) | (PROMPT_FOOTER_BUTTON_HOVER_OPACITY as u32)
 }
 
-fn footer_button_active_rgba(colors: PromptFooterColors) -> u32 {
+pub fn footer_button_active_rgba(colors: PromptFooterColors) -> u32 {
     (colors.background << 8) | (PROMPT_FOOTER_BUTTON_ACTIVE_OPACITY as u32)
 }
 
+pub fn footer_button_font_size_px(theme: &Theme) -> f32 {
+    (theme.get_fonts().ui_size - PROMPT_FOOTER_BUTTON_FONT_DELTA_PX)
+        .max(PROMPT_FOOTER_BUTTON_FONT_MIN_PX)
+}
+
 /// Configuration for PromptFooter display
 #[derive(Clone, Debug)]
 pub struct PromptFooterConfig {
@@ -334,8 +339,7 @@
         on_click: Option<Rc<FooterClickCallback>>,
     ) -> impl IntoElement {
         let theme = crate::theme::get_cached_theme();
-        let button_font_size = (theme.get_fonts().ui_size - PROMPT_FOOTER_BUTTON_FONT_DELTA_PX)
-            .max(PROMPT_FOOTER_BUTTON_FONT_MIN_PX);
+        let button_font_size = footer_button_font_size_px(&theme);
         let has_click_handler = on_click.is_some();
         let is_clickable = is_footer_button_clickable(has_click_handler, disabled);
         let on_click_for_key = on_click.clone();
diff --git a/src/prompts/chat/actions.rs b/src/prompts/chat/actions.rs
index 8ae41af43235d867176126f8de45f9fc8f3f2cbf..4d01323e1d134ef8e6f56be60d0a1eee086247e7
--- a/src/prompts/chat/actions.rs
+++ b/src/prompts/chat/actions.rs
@@ -172,48 +172,36 @@
 
         if action.should_run_after_save() {
             self.set_script_generation_status(false, format!("Running {}...", script_name), cx);
-
-            let path_clone = script_path.clone();
-            let name_clone = script_name.clone();
-            cx.spawn(async move |this, cx| {
-                let run_result = std::thread::spawn(move || {
-                    crate::ai::script_generation::run_saved_script(&path_clone)
-                })
-                .join()
-                .map_err(|_| anyhow::anyhow!("run thread panicked"))
-                .and_then(|r| r);
-
-                let _ = cx.update(|cx| {
-                    this.update(cx, |chat, cx| match run_result {
-                        Ok(()) => {
-                            chat.set_script_generation_status(
-                                false,
-                                format!("Saved and running {}", name_clone),
-                                cx,
-                            );
-                            logging::log(
-                                "CHAT_SCRIPT_GEN",
-                                &format!("state=run_ok action={:?} script={}", action, name_clone),
-                            );
-                        }
-                        Err(error) => {
-                            chat.set_script_generation_status(
-                                true,
-                                format!("Saved {} but failed to run: {}", name_clone, error),
-                                cx,
-                            );
-                            logging::log(
-                                "CHAT_SCRIPT_GEN",
-                                &format!(
-                                    "state=run_failed action={:?} script={} error={}",
-                                    action, name_clone, error
-                                ),
-                            );
-                        }
-                    })
-                });
-            })
-            .detach();
+            if let Some(ref callback) = self.on_run_script {
+                callback(script_path.clone(), cx);
+                self.set_script_generation_status(
+                    false,
+                    format!("Saved and running {}", script_name),
+                    cx,
+                );
+                logging::log(
+                    "CHAT_SCRIPT_GEN",
+                    &format!(
+                        "state=run_dispatched action={:?} path={}",
+                        action,
+                        script_path.display()
+                    ),
+                );
+            } else {
+                self.set_script_generation_status(
+                    true,
+                    format!("Saved {} but run action is unavailable", script_name),
+                    cx,
+                );
+                logging::log(
+                    "CHAT_SCRIPT_GEN",
+                    &format!(
+                        "state=run_dispatch_failed action={:?} path={} reason=missing_callback",
+                        action,
+                        script_path.display()
+                    ),
+                );
+            }
             return;
         }
 
diff --git a/src/prompts/chat/prompt.rs b/src/prompts/chat/prompt.rs
index 4ef4ac1aae4123a9bdd9771500998f87f424660b..78a8d8354e9e50914fdbcf1cc0fce0292b4feac2
--- a/src/prompts/chat/prompt.rs
+++ b/src/prompts/chat/prompt.rs
@@ -60,6 +60,9 @@
     pub(super) on_claude_code: Option<ChatClaudeCodeCallback>,
     // Callback for showing actions dialog (handled by parent)
     pub(super) on_show_actions: Option<ChatShowActionsCallback>,
+    // Callback for running a saved generated script via parent app pipeline
+    pub(super) on_run_script:
+        Option<Arc<dyn Fn(std::path::PathBuf, &mut Context<ChatPrompt>) + Send + Sync>>,
     // Stable UUID for Claude Code CLI session continuity within this prompt's lifetime.
     // Generated once at construction so all messages share the same session.
     pub(super) cli_session_id: String,
@@ -134,6 +137,7 @@
             on_configure: None,
             on_claude_code: None,
             on_show_actions: None,
+            on_run_script: None,
             cli_session_id: uuid::Uuid::new_v4().to_string(),
             pending_image: None,
             pending_image_render: None,
@@ -146,6 +150,15 @@
         self.on_show_actions = Some(callback);
     }
 
+    /// Set the callback for running a generated script path in the parent app.
+    pub fn with_run_script_callback(
+        mut self,
+        callback: impl Fn(std::path::PathBuf, &mut Context<Self>) + Send + Sync + 'static,
+    ) -> Self {
+        self.on_run_script = Some(Arc::new(callback));
+        self
+    }
+
     /// Start the cursor blink timer
     pub fn start_cursor_blink(&mut self, cx: &mut Context<Self>) {
         cx.spawn(async move |this, cx| {
diff --git a/src/prompts/chat/render_core.rs b/src/prompts/chat/render_core.rs
index 4e91d2d0ed474e69c143cd50e58e0491df58450b..7a066a4f6a2e6ac66e5e870f4a926cfbe0c56618
--- a/src/prompts/chat/render_core.rs
+++ b/src/prompts/chat/render_core.rs
@@ -32,10 +32,18 @@
         label: &'static str,
         shortcut: Option<&'static str>,
         action: ScriptGenerationAction,
-        accent_color: u32,
-        muted_color: u32,
+        footer_colors: PromptFooterColors,
         cx: &mut Context<Self>,
     ) -> AnyElement {
+        let button_font_size =
+            crate::components::prompt_footer::footer_button_font_size_px(&self.theme);
+        let hover_bg = rgba(crate::components::prompt_footer::footer_button_hover_rgba(
+            footer_colors,
+        ));
+        let active_bg = rgba(crate::components::prompt_footer::footer_button_active_rgba(
+            footer_colors,
+        ));
+
         div()
             .id(id)
             .flex()
@@ -46,9 +54,21 @@
             .py(px(2.0))
             .rounded(px(4.0))
             .cursor_pointer()
-            .child(div().text_xs().text_color(rgb(accent_color)).child(label))
+            .hover(move |d| d.bg(hover_bg))
+            .active(move |d| d.bg(active_bg))
+            .child(
+                div()
+                    .text_size(px(button_font_size))
+                    .text_color(rgb(footer_colors.accent))
+                    .child(label),
+            )
             .when_some(shortcut, |d, shortcut| {
-                d.child(div().text_xs().text_color(rgb(muted_color)).child(shortcut))
+                d.child(
+                    div()
+                        .text_size(px(button_font_size))
+                        .text_color(rgb(footer_colors.text_muted))
+                        .child(shortcut),
+                )
             })
             .on_click(cx.listener(move |this, _event, _window, cx| {
                 this.handle_script_generation_action(action, cx);
@@ -109,10 +129,9 @@
             self.render_script_generation_footer_button(
                 "chat-footer-primary-button",
                 "Save and Run",
-                None,
+                Some("⌘↵"),
                 ScriptGenerationAction::SaveAndRun,
-                footer_colors.accent,
-                footer_colors.text_muted,
+                footer_colors,
                 cx,
             )
         } else {
@@ -194,8 +213,7 @@
                     "Save",
                     None,
                     ScriptGenerationAction::Save,
-                    footer_colors.accent,
-                    footer_colors.text_muted,
+                    footer_colors,
                     cx,
                 ))
                 .child(self.render_script_generation_footer_button(
@@ -203,8 +221,7 @@
                     "Run",
                     None,
                     ScriptGenerationAction::Run,
-                    footer_colors.accent,
-                    footer_colors.text_muted,
+                    footer_colors,
                     cx,
                 ));
         }
@@ -356,7 +373,13 @@
                     }
                 }
                 ChatInputKeyAction::ToggleActions => this.toggle_actions_menu(cx),
-                ChatInputKeyAction::ContinueInChat => this.handle_continue_in_chat(cx),
+                ChatInputKeyAction::ContinueInChat => {
+                    if this.script_generation_mode {
+                        this.handle_script_generation_action(ScriptGenerationAction::SaveAndRun, cx);
+                    } else {
+                        this.handle_continue_in_chat(cx);
+                    }
+                }
                 ChatInputKeyAction::Submit => this.handle_submit(cx),
                 ChatInputKeyAction::InsertNewline => {
                     this.input.insert_char('\n');
@@ -618,7 +641,9 @@
             "Footer primary action should branch on script_generation_mode"
         );
         assert!(
-            normalized.contains("\"chat-footer-primary-button\",\"SaveandRun\",None,ScriptGenerationAction::SaveAndRun,"),
+            normalized.contains(
+                "\"chat-footer-primary-button\",\"SaveandRun\",Some(\"⌘↵\"),ScriptGenerationAction::SaveAndRun,"
+            ),
             "Script generation mode should render Save and Run as the primary footer action"
         );
         assert!(
@@ -647,4 +672,18 @@
             "Save and Run should only appear as the primary footer action slot"
         );
     }
+
+    #[test]
+    fn test_cmd_enter_runs_save_and_run_when_script_generation_mode_enabled() {
+        let content = fs::read_to_string("src/prompts/chat/render_core.rs")
+            .expect("Failed to read src/prompts/chat/render_core.rs");
+        let normalized: String = content.chars().filter(|c| !c.is_whitespace()).collect();
+
+        assert!(
+            normalized.contains(
+                "ChatInputKeyAction::ContinueInChat=>{ifthis.script_generation_mode{this.handle_script_generation_action(ScriptGenerationAction::SaveAndRun,cx);}else{this.handle_continue_in_chat(cx);}}"
+            ),
+            "Cmd+Enter should trigger SaveAndRun in script generation mode and ContinueInChat otherwise"
+        );
+    }
 }


thinking
**Assessing large diffs and file changes**
exec
/bin/zsh -lc 'cd /Users/johnlindquist/dev/script-kit-gpui && rg -n "on_run_script|with_run_script_callback" src/prompts/chat/prompt.rs src/prompts/chat/actions.rs src/app_impl/prompt_ai.rs' in /Users/johnlindquist/dev/script-kit-gpuiexec
/bin/zsh -lc "cd /Users/johnlindquist/dev/script-kit-gpui && sed -n '1,120p' src/prompts/chat/prompt.rs" in /Users/johnlindquist/dev/script-kit-gpuiexec
/bin/zsh -lc "cd /Users/johnlindquist/dev/script-kit-gpui && sed -n '120,260p' src/prompts/chat/actions.rs" in /Users/johnlindquist/dev/script-kit-gpui succeeded in 50ms:
src/app_impl/prompt_ai.rs:619:        .with_run_script_callback(run_script_callback)
src/prompts/chat/prompt.rs:64:    pub(super) on_run_script:
src/prompts/chat/prompt.rs:140:            on_run_script: None,
src/prompts/chat/prompt.rs:154:    pub fn with_run_script_callback(
src/prompts/chat/prompt.rs:158:        self.on_run_script = Some(Arc::new(callback));
src/prompts/chat/actions.rs:175:            if let Some(ref callback) = self.on_run_script {
 succeeded in 52ms:
use super::*;
pub struct ChatPrompt {
    pub id: String,
    pub messages: Vec<ChatPromptMessage>,
    pub placeholder: Option<String>,
    pub hint: Option<String>,
    pub footer: Option<String>,
    pub model: Option<String>,
    pub models: Vec<ChatModel>,
    pub title: Option<String>,
    pub focus_handle: FocusHandle,
    pub input: TextInputState,
    pub on_submit: ChatSubmitCallback,
    pub on_escape: Option<ChatEscapeCallback>,
    pub on_continue: Option<ChatContinueCallback>,
    pub on_retry: Option<ChatRetryCallback>,
    pub theme: Arc<theme::Theme>,
    pub turns_list_state: ListState,
    pub(super) prompt_colors: theme::PromptColors,
    pub(super) conversation_turns_cache: Arc<Vec<ConversationTurn>>,
 succeeded in 52ms:
            self.last_copied_response = Some(content.clone());
            logging::log("CHAT", &format!("Copied response: {} chars", content.len()));
            // Copy to clipboard via cx
            cx.write_to_clipboard(gpui::ClipboardItem::new_string(content));
        }
    }

    pub(super) fn handle_clear(&mut self, cx: &mut Context<Self>) {
        logging::log("CHAT", "Clearing conversation (⌘+⌫)");
        self.clear_messages(cx);
    }

    pub(super) fn handle_script_generation_action(
        &mut self,
        action: ScriptGenerationAction,
        cx: &mut Context<Self>,
    ) {
        let Some((prompt_description, raw_response)) = self.latest_script_generation_draft() else {
            self.set_script_generation_status(true, "No generated script to save yet.", cx);
            return;
file update:
diff --git a/src/ai/script_generation.rs b/src/ai/script_generation.rs
index f29715b032570028241789219179c413e5c5ed83..a89e4e8d4161e386089b6e3cac57975cd36b3cd0
--- a/src/ai/script_generation.rs
+++ b/src/ai/script_generation.rs
@@ -148,75 +148,6 @@
     Ok(script_path)
 }
 
-pub(crate) fn run_saved_script(path: &Path) -> Result<()> {
-    let script_path = path.to_string_lossy().to_string();
-    let attempts: &[(&str, &[&str])] = &[
-        ("kit", &["run", &script_path]),
-        ("bun", &["run", &script_path]),
-    ];
-
-    let mut failures = Vec::new();
-
-    for &(cmd, args) in attempts {
-        let result = std::process::Command::new(cmd)
-            .args(args)
-            .stderr(std::process::Stdio::piped())
-            .stdout(std::process::Stdio::piped())
-            .spawn();
-
-        match result {
-            Ok(mut child) => {
-                // Wait briefly for quick failures (e.g. bun cache corruption, missing deps).
-                // If still running after the timeout, assume it launched successfully.
-                let timeout = std::time::Duration::from_secs(5);
-                let start = std::time::Instant::now();
-                loop {
-                    match child.try_wait() {
-                        Ok(Some(status)) if !status.success() => {
-                            let stderr_text = child
-                                .stderr
-                                .take()
-                                .map(|mut s| {
-                                    let mut buf = String::new();
-                                    std::io::Read::read_to_string(&mut s, &mut buf).ok();
-                                    buf
-                                })
-                                .unwrap_or_default();
-                            let detail = if stderr_text.trim().is_empty() {
-                                format!("exit {}", status)
-                            } else {
-                                stderr_text.trim().to_string()
-                            };
-                            failures.push(format!("{}: {}", cmd, detail));
-                            break;
-                        }
-                        Ok(Some(_)) => return Ok(()), // exited successfully
-                        Ok(None) => {
-                            if start.elapsed() >= timeout {
-                                return Ok(()); // still running — launched OK
-                            }
-                            std::thread::sleep(std::time::Duration::from_millis(50));
-                        }
-                        Err(error) => {
-                            failures.push(format!("{}: wait failed: {}", cmd, error));
-                            break;
-                        }
-                    }
-                }
-            }
-            Err(error) => {
-                failures.push(format!("{}: {}", cmd, error));
-            }
-        }
-    }
-
-    anyhow::bail!(
-        "Failed to run script (path={}, attempts={})",
-        path.display(),
-        failures.join(" | ")
-    );
-}
-
 fn select_generation_model(
     registry: &ProviderRegistry,
 ) -> Result<(ModelInfo, Arc<dyn AiProvider>)> {
diff --git a/src/app_impl/prompt_ai.rs b/src/app_impl/prompt_ai.rs
index c8266b6cb798ec62e6e7e9a8a59005512e44b72f..6c10ca4234dc2d80bb14bc0d5163caddf97656cc
--- a/src/app_impl/prompt_ai.rs
+++ b/src/app_impl/prompt_ai.rs
@@ -568,6 +568,38 @@
         let noop_callback: ChatSubmitCallback = std::sync::Arc::new(|_id, _text| {
             // Built-in AI mode handles this internally
         });
+        let app_entity = cx.entity().downgrade();
+        let run_script_callback = move |script_path: std::path::PathBuf,
+                                        chat_cx: &mut gpui::Context<ChatPrompt>| {
+            let script_path_string = script_path.to_string_lossy().to_string();
+            let app_entity = app_entity.clone();
+            chat_cx
+                .spawn(async move |_this, cx| {
+                    let _ = cx.update(|cx| {
+                        if let Some(app) = app_entity.upgrade() {
+                            logging::log(
+                                "CHAT_SCRIPT_GEN",
+                                &format!(
+                                    "state=dispatch_run attempted=execute_script_by_path path={}",
+                                    script_path_string
+                                ),
+                            );
+                            app.update(cx, |app, cx| {
+                                app.execute_script_by_path(&script_path_string, cx);
+                            });
+                        } else {
+                            logging::log(
+                                "CHAT_SCRIPT_GEN",
+                                &format!(
+                                    "state=dispatch_run_failed attempted=execute_script_by_path path={} reason=app_entity_unavailable",
+                                    script_path_string
+                                ),
+                            );
+                        }
+                    });
+                })
+                .detach();
+        };
 
         let placeholder = Some("Describe the script you want to generate...".to_string());
 
@@ -584,6 +616,7 @@
         .with_title("Generate Script with AI")
         .with_save_history(false)
         .with_escape_callback(escape_callback)
+        .with_run_script_callback(run_script_callback)
         .with_builtin_ai(registry, true) // true = prefer Vercel AI Gateway
         .with_builtin_system_prompt(crate::ai::script_generation::AI_SCRIPT_GENERATION_SYSTEM_PROMPT)
         .with_script_generation_mode(true);
diff --git a/src/components/prompt_footer.rs b/src/components/prompt_footer.rs
index 6bfa86a1edacaec90dc82185bb178cd09dfb7b61..0ce40c6c9c2ea6aa9f9e7599cb8065ebd2c5318b
--- a/src/components/prompt_footer.rs
+++ b/src/components/prompt_footer.rs
@@ -155,14 +155,19 @@
     )
 }
 
-fn footer_button_hover_rgba(colors: PromptFooterColors) -> u32 {
+pub fn footer_button_hover_rgba(colors: PromptFooterColors) -> u32 {
     (colors.background << 8) | (PROMPT_FOOTER_BUTTON_HOVER_OPACITY as u32)
 }
 
-fn footer_button_active_rgba(colors: PromptFooterColors) -> u32 {
+pub fn footer_button_active_rgba(colors: PromptFooterColors) -> u32 {
     (colors.background << 8) | (PROMPT_FOOTER_BUTTON_ACTIVE_OPACITY as u32)
 }
 
+pub fn footer_button_font_size_px(theme: &Theme) -> f32 {
+    (theme.get_fonts().ui_size - PROMPT_FOOTER_BUTTON_FONT_DELTA_PX)
+        .max(PROMPT_FOOTER_BUTTON_FONT_MIN_PX)
+}
+
 /// Configuration for PromptFooter display
 #[derive(Clone, Debug)]
 pub struct PromptFooterConfig {
@@ -334,8 +339,7 @@
         on_click: Option<Rc<FooterClickCallback>>,
     ) -> impl IntoElement {
         let theme = crate::theme::get_cached_theme();
-        let button_font_size = (theme.get_fonts().ui_size - PROMPT_FOOTER_BUTTON_FONT_DELTA_PX)
-            .max(PROMPT_FOOTER_BUTTON_FONT_MIN_PX);
+        let button_font_size = footer_button_font_size_px(&theme);
         let has_click_handler = on_click.is_some();
         let is_clickable = is_footer_button_clickable(has_click_handler, disabled);
         let on_click_for_key = on_click.clone();
diff --git a/src/prompts/chat/actions.rs b/src/prompts/chat/actions.rs
index 8ae41af43235d867176126f8de45f9fc8f3f2cbf..4d01323e1d134ef8e6f56be60d0a1eee086247e7
--- a/src/prompts/chat/actions.rs
+++ b/src/prompts/chat/actions.rs
@@ -172,48 +172,36 @@
 
         if action.should_run_after_save() {
             self.set_script_generation_status(false, format!("Running {}...", script_name), cx);
-
-            let path_clone = script_path.clone();
-            let name_clone = script_name.clone();
-            cx.spawn(async move |this, cx| {
-                let run_result = std::thread::spawn(move || {
-                    crate::ai::script_generation::run_saved_script(&path_clone)
-                })
-                .join()
-                .map_err(|_| anyhow::anyhow!("run thread panicked"))
-                .and_then(|r| r);
-
-                let _ = cx.update(|cx| {
-                    this.update(cx, |chat, cx| match run_result {
-                        Ok(()) => {
-                            chat.set_script_generation_status(
-                                false,
-                                format!("Saved and running {}", name_clone),
-                                cx,
-                            );
-                            logging::log(
-                                "CHAT_SCRIPT_GEN",
-                                &format!("state=run_ok action={:?} script={}", action, name_clone),
-                            );
-                        }
-                        Err(error) => {
-                            chat.set_script_generation_status(
-                                true,
-                                format!("Saved {} but failed to run: {}", name_clone, error),
-                                cx,
-                            );
-                            logging::log(
-                                "CHAT_SCRIPT_GEN",
-                                &format!(
-                                    "state=run_failed action={:?} script={} error={}",
-                                    action, name_clone, error
-                                ),
-                            );
-                        }
-                    })
-                });
-            })
-            .detach();
+            if let Some(ref callback) = self.on_run_script {
+                callback(script_path.clone(), cx);
+                self.set_script_generation_status(
+                    false,
+                    format!("Saved and running {}", script_name),
+                    cx,
+                );
+                logging::log(
+                    "CHAT_SCRIPT_GEN",
+                    &format!(
+                        "state=run_dispatched action={:?} path={}",
+                        action,
+                        script_path.display()
+                    ),
+                );
+            } else {
+                self.set_script_generation_status(
+                    true,
+                    format!("Saved {} but run action is unavailable", script_name),
+                    cx,
+                );
+                logging::log(
+                    "CHAT_SCRIPT_GEN",
+                    &format!(
+                        "state=run_dispatch_failed action={:?} path={} reason=missing_callback",
+                        action,
+                        script_path.display()
+                    ),
+                );
+            }
             return;
         }
 
diff --git a/src/prompts/chat/prompt.rs b/src/prompts/chat/prompt.rs
index 4ef4ac1aae4123a9bdd9771500998f87f424660b..78a8d8354e9e50914fdbcf1cc0fce0292b4feac2
--- a/src/prompts/chat/prompt.rs
+++ b/src/prompts/chat/prompt.rs
@@ -60,6 +60,9 @@
     pub(super) on_claude_code: Option<ChatClaudeCodeCallback>,
     // Callback for showing actions dialog (handled by parent)
     pub(super) on_show_actions: Option<ChatShowActionsCallback>,
+    // Callback for running a saved generated script via parent app pipeline
+    pub(super) on_run_script:
+        Option<Arc<dyn Fn(std::path::PathBuf, &mut Context<ChatPrompt>) + Send + Sync>>,
     // Stable UUID for Claude Code CLI session continuity within this prompt's lifetime.
     // Generated once at construction so all messages share the same session.
     pub(super) cli_session_id: String,
@@ -134,6 +137,7 @@
             on_configure: None,
             on_claude_code: None,
             on_show_actions: None,
+            on_run_script: None,
             cli_session_id: uuid::Uuid::new_v4().to_string(),
             pending_image: None,
             pending_image_render: None,
@@ -146,6 +150,15 @@
         self.on_show_actions = Some(callback);
     }
 
+    /// Set the callback for running a generated script path in the parent app.
+    pub fn with_run_script_callback(
+        mut self,
+        callback: impl Fn(std::path::PathBuf, &mut Context<Self>) + Send + Sync + 'static,
+    ) -> Self {
+        self.on_run_script = Some(Arc::new(callback));
+        self
+    }
+
     /// Start the cursor blink timer
     pub fn start_cursor_blink(&mut self, cx: &mut Context<Self>) {
         cx.spawn(async move |this, cx| {
diff --git a/src/prompts/chat/render_core.rs b/src/prompts/chat/render_core.rs
index 4e91d2d0ed474e69c143cd50e58e0491df58450b..7a066a4f6a2e6ac66e5e870f4a926cfbe0c56618
--- a/src/prompts/chat/render_core.rs
+++ b/src/prompts/chat/render_core.rs
@@ -32,10 +32,18 @@
         label: &'static str,
         shortcut: Option<&'static str>,
         action: ScriptGenerationAction,
-        accent_color: u32,
-        muted_color: u32,
+        footer_colors: PromptFooterColors,
         cx: &mut Context<Self>,
     ) -> AnyElement {
+        let button_font_size =
+            crate::components::prompt_footer::footer_button_font_size_px(&self.theme);
+        let hover_bg = rgba(crate::components::prompt_footer::footer_button_hover_rgba(
+            footer_colors,
+        ));
+        let active_bg = rgba(crate::components::prompt_footer::footer_button_active_rgba(
+            footer_colors,
+        ));
+
         div()
             .id(id)
             .flex()
@@ -46,9 +54,21 @@
             .py(px(2.0))
             .rounded(px(4.0))
             .cursor_pointer()
-            .child(div().text_xs().text_color(rgb(accent_color)).child(label))
+            .hover(move |d| d.bg(hover_bg))
+            .active(move |d| d.bg(active_bg))
+            .child(
+                div()
+                    .text_size(px(button_font_size))
+                    .text_color(rgb(footer_colors.accent))
+                    .child(label),
+            )
             .when_some(shortcut, |d, shortcut| {
-                d.child(div().text_xs().text_color(rgb(muted_color)).child(shortcut))
+                d.child(
+                    div()
+                        .text_size(px(button_font_size))
+                        .text_color(rgb(footer_colors.text_muted))
+                        .child(shortcut),
+                )
             })
             .on_click(cx.listener(move |this, _event, _window, cx| {
                 this.handle_script_generation_action(action, cx);
@@ -109,10 +129,9 @@
             self.render_script_generation_footer_button(
                 "chat-footer-primary-button",
                 "Save and Run",
-                None,
+                Some("⌘↵"),
                 ScriptGenerationAction::SaveAndRun,
-                footer_colors.accent,
-                footer_colors.text_muted,
+                footer_colors,
                 cx,
             )
         } else {
@@ -194,8 +213,7 @@
                     "Save",
                     None,
                     ScriptGenerationAction::Save,
-                    footer_colors.accent,
-                    footer_colors.text_muted,
+                    footer_colors,
                     cx,
                 ))
                 .child(self.render_script_generation_footer_button(
@@ -203,8 +221,7 @@
                     "Run",
                     None,
                     ScriptGenerationAction::Run,
-                    footer_colors.accent,
-                    footer_colors.text_muted,
+                    footer_colors,
                     cx,
                 ));
         }
@@ -356,7 +373,13 @@
                     }
                 }
                 ChatInputKeyAction::ToggleActions => this.toggle_actions_menu(cx),
-                ChatInputKeyAction::ContinueInChat => this.handle_continue_in_chat(cx),
+                ChatInputKeyAction::ContinueInChat => {
+                    if this.script_generation_mode {
+                        this.handle_script_generation_action(ScriptGenerationAction::SaveAndRun, cx);
+                    } else {
+                        this.handle_continue_in_chat(cx);
+                    }
+                }
                 ChatInputKeyAction::Submit => this.handle_submit(cx),
                 ChatInputKeyAction::InsertNewline => {
                     this.input.insert_char('\n');
@@ -618,7 +641,9 @@
             "Footer primary action should branch on script_generation_mode"
         );
         assert!(
-            normalized.contains("\"chat-footer-primary-button\",\"SaveandRun\",None,ScriptGenerationAction::SaveAndRun,"),
+            normalized.contains(
+                "\"chat-footer-primary-button\",\"SaveandRun\",Some(\"⌘↵\"),ScriptGenerationAction::SaveAndRun,"
+            ),
             "Script generation mode should render Save and Run as the primary footer action"
         );
         assert!(
@@ -647,4 +672,18 @@
             "Save and Run should only appear as the primary footer action slot"
         );
     }
+
+    #[test]
+    fn test_cmd_enter_runs_save_and_run_when_script_generation_mode_enabled() {
+        let content = fs::read_to_string("src/prompts/chat/render_core.rs")
+            .expect("Failed to read src/prompts/chat/render_core.rs");
+        let normalized: String = content.chars().filter(|c| !c.is_whitespace()).collect();
+
+        assert!(
+            normalized.contains(
+                "ChatInputKeyAction::ContinueInChat=>{ifthis.script_generation_mode{this.handle_script_generation_action(ScriptGenerationAction::SaveAndRun,cx);}else{this.handle_continue_in_chat(cx);}}"
+            ),
+            "Cmd+Enter should trigger SaveAndRun in script generation mode and ContinueInChat otherwise"
+        );
+    }
 }


thinking
**Reviewing prompt callback logic**
exec
/bin/zsh -lc "cd /Users/johnlindquist/dev/script-kit-gpui && sed -n '540,700p' src/app_impl/prompt_ai.rs" in /Users/johnlindquist/dev/script-kit-gpui succeeded in 50ms:
            .with_title("Generate Script with AI")
            .with_save_history(false) // Don't save setup state to history
            .with_escape_callback(escape_callback.clone())
            .with_needs_setup(true)
            .with_configure_callback(configure_callback)
            .with_claude_code_callback(claude_code_callback);

            let entity = cx.new(|_| chat_prompt);
            self.current_view = AppView::ChatPrompt {
                id: "script-generation-setup".to_string(),
                entity,
            };
            self.focused_input = FocusedInput::None;
            self.pending_focus = Some(FocusTarget::ChatPrompt);
            resize_to_view_sync(ViewType::DivPrompt, 0);
            cx.notify();
            return;
        }

        crate::logging::log(
file update:
diff --git a/src/ai/script_generation.rs b/src/ai/script_generation.rs
index f29715b032570028241789219179c413e5c5ed83..a89e4e8d4161e386089b6e3cac57975cd36b3cd0
--- a/src/ai/script_generation.rs
+++ b/src/ai/script_generation.rs
@@ -148,75 +148,6 @@
     Ok(script_path)
 }
 
-pub(crate) fn run_saved_script(path: &Path) -> Result<()> {
-    let script_path = path.to_string_lossy().to_string();
-    let attempts: &[(&str, &[&str])] = &[
-        ("kit", &["run", &script_path]),
-        ("bun", &["run", &script_path]),
-    ];
-
-    let mut failures = Vec::new();
-
-    for &(cmd, args) in attempts {
-        let result = std::process::Command::new(cmd)
-            .args(args)
-            .stderr(std::process::Stdio::piped())
-            .stdout(std::process::Stdio::piped())
-            .spawn();
-
-        match result {
-            Ok(mut child) => {
-                // Wait briefly for quick failures (e.g. bun cache corruption, missing deps).
-                // If still running after the timeout, assume it launched successfully.
-                let timeout = std::time::Duration::from_secs(5);
-                let start = std::time::Instant::now();
-                loop {
-                    match child.try_wait() {
-                        Ok(Some(status)) if !status.success() => {
-                            let stderr_text = child
-                                .stderr
-                                .take()
-                                .map(|mut s| {
-                                    let mut buf = String::new();
-                                    std::io::Read::read_to_string(&mut s, &mut buf).ok();
-                                    buf
-                                })
-                                .unwrap_or_default();
-                            let detail = if stderr_text.trim().is_empty() {
-                                format!("exit {}", status)
-                            } else {
-                                stderr_text.trim().to_string()
-                            };
-                            failures.push(format!("{}: {}", cmd, detail));
-                            break;
-                        }
-                        Ok(Some(_)) => return Ok(()), // exited successfully
-                        Ok(None) => {
-                            if start.elapsed() >= timeout {
-                                return Ok(()); // still running — launched OK
-                            }
-                            std::thread::sleep(std::time::Duration::from_millis(50));
-                        }
-                        Err(error) => {
-                            failures.push(format!("{}: wait failed: {}", cmd, error));
-                            break;
-                        }
-                    }
-                }
-            }
-            Err(error) => {
-                failures.push(format!("{}: {}", cmd, error));
-            }
-        }
-    }
-
-    anyhow::bail!(
-        "Failed to run script (path={}, attempts={})",
-        path.display(),
-        failures.join(" | ")
-    );
-}
-
 fn select_generation_model(
     registry: &ProviderRegistry,
 ) -> Result<(ModelInfo, Arc<dyn AiProvider>)> {
diff --git a/src/app_impl/prompt_ai.rs b/src/app_impl/prompt_ai.rs
index c8266b6cb798ec62e6e7e9a8a59005512e44b72f..6c10ca4234dc2d80bb14bc0d5163caddf97656cc
--- a/src/app_impl/prompt_ai.rs
+++ b/src/app_impl/prompt_ai.rs
@@ -568,6 +568,38 @@
         let noop_callback: ChatSubmitCallback = std::sync::Arc::new(|_id, _text| {
             // Built-in AI mode handles this internally
         });
+        let app_entity = cx.entity().downgrade();
+        let run_script_callback = move |script_path: std::path::PathBuf,
+                                        chat_cx: &mut gpui::Context<ChatPrompt>| {
+            let script_path_string = script_path.to_string_lossy().to_string();
+            let app_entity = app_entity.clone();
+            chat_cx
+                .spawn(async move |_this, cx| {
+                    let _ = cx.update(|cx| {
+                        if let Some(app) = app_entity.upgrade() {
+                            logging::log(
+                                "CHAT_SCRIPT_GEN",
+                                &format!(
+                                    "state=dispatch_run attempted=execute_script_by_path path={}",
+                                    script_path_string
+                                ),
+                            );
+                            app.update(cx, |app, cx| {
+                                app.execute_script_by_path(&script_path_string, cx);
+                            });
+                        } else {
+                            logging::log(
+                                "CHAT_SCRIPT_GEN",
+                                &format!(
+                                    "state=dispatch_run_failed attempted=execute_script_by_path path={} reason=app_entity_unavailable",
+                                    script_path_string
+                                ),
+                            );
+                        }
+                    });
+                })
+                .detach();
+        };
 
         let placeholder = Some("Describe the script you want to generate...".to_string());
 
@@ -584,6 +616,7 @@
         .with_title("Generate Script with AI")
         .with_save_history(false)
         .with_escape_callback(escape_callback)
+        .with_run_script_callback(run_script_callback)
         .with_builtin_ai(registry, true) // true = prefer Vercel AI Gateway
         .with_builtin_system_prompt(crate::ai::script_generation::AI_SCRIPT_GENERATION_SYSTEM_PROMPT)
         .with_script_generation_mode(true);
diff --git a/src/components/prompt_footer.rs b/src/components/prompt_footer.rs
index 6bfa86a1edacaec90dc82185bb178cd09dfb7b61..0ce40c6c9c2ea6aa9f9e7599cb8065ebd2c5318b
--- a/src/components/prompt_footer.rs
+++ b/src/components/prompt_footer.rs
@@ -155,14 +155,19 @@
     )
 }
 
-fn footer_button_hover_rgba(colors: PromptFooterColors) -> u32 {
+pub fn footer_button_hover_rgba(colors: PromptFooterColors) -> u32 {
     (colors.background << 8) | (PROMPT_FOOTER_BUTTON_HOVER_OPACITY as u32)
 }
 
-fn footer_button_active_rgba(colors: PromptFooterColors) -> u32 {
+pub fn footer_button_active_rgba(colors: PromptFooterColors) -> u32 {
     (colors.background << 8) | (PROMPT_FOOTER_BUTTON_ACTIVE_OPACITY as u32)
 }
 
+pub fn footer_button_font_size_px(theme: &Theme) -> f32 {
+    (theme.get_fonts().ui_size - PROMPT_FOOTER_BUTTON_FONT_DELTA_PX)
+        .max(PROMPT_FOOTER_BUTTON_FONT_MIN_PX)
+}
+
 /// Configuration for PromptFooter display
 #[derive(Clone, Debug)]
 pub struct PromptFooterConfig {
@@ -334,8 +339,7 @@
         on_click: Option<Rc<FooterClickCallback>>,
     ) -> impl IntoElement {
         let theme = crate::theme::get_cached_theme();
-        let button_font_size = (theme.get_fonts().ui_size - PROMPT_FOOTER_BUTTON_FONT_DELTA_PX)
-            .max(PROMPT_FOOTER_BUTTON_FONT_MIN_PX);
+        let button_font_size = footer_button_font_size_px(&theme);
         let has_click_handler = on_click.is_some();
         let is_clickable = is_footer_button_clickable(has_click_handler, disabled);
         let on_click_for_key = on_click.clone();
diff --git a/src/prompts/chat/actions.rs b/src/prompts/chat/actions.rs
index 8ae41af43235d867176126f8de45f9fc8f3f2cbf..4d01323e1d134ef8e6f56be60d0a1eee086247e7
--- a/src/prompts/chat/actions.rs
+++ b/src/prompts/chat/actions.rs
@@ -172,48 +172,36 @@
 
         if action.should_run_after_save() {
             self.set_script_generation_status(false, format!("Running {}...", script_name), cx);
-
-            let path_clone = script_path.clone();
-            let name_clone = script_name.clone();
-            cx.spawn(async move |this, cx| {
-                let run_result = std::thread::spawn(move || {
-                    crate::ai::script_generation::run_saved_script(&path_clone)
-                })
-                .join()
-                .map_err(|_| anyhow::anyhow!("run thread panicked"))
-                .and_then(|r| r);
-
-                let _ = cx.update(|cx| {
-                    this.update(cx, |chat, cx| match run_result {
-                        Ok(()) => {
-                            chat.set_script_generation_status(
-                                false,
-                                format!("Saved and running {}", name_clone),
-                                cx,
-                            );
-                            logging::log(
-                                "CHAT_SCRIPT_GEN",
-                                &format!("state=run_ok action={:?} script={}", action, name_clone),
-                            );
-                        }
-                        Err(error) => {
-                            chat.set_script_generation_status(
-                                true,
-                                format!("Saved {} but failed to run: {}", name_clone, error),
-                                cx,
-                            );
-                            logging::log(
-                                "CHAT_SCRIPT_GEN",
-                                &format!(
-                                    "state=run_failed action={:?} script={} error={}",
-                                    action, name_clone, error
-                                ),
-                            );
-                        }
-                    })
-                });
-            })
-            .detach();
+            if let Some(ref callback) = self.on_run_script {
+                callback(script_path.clone(), cx);
+                self.set_script_generation_status(
+                    false,
+                    format!("Saved and running {}", script_name),
+                    cx,
+                );
+                logging::log(
+                    "CHAT_SCRIPT_GEN",
+                    &format!(
+                        "state=run_dispatched action={:?} path={}",
+                        action,
+                        script_path.display()
+                    ),
+                );
+            } else {
+                self.set_script_generation_status(
+                    true,
+                    format!("Saved {} but run action is unavailable", script_name),
+                    cx,
+                );
+                logging::log(
+                    "CHAT_SCRIPT_GEN",
+                    &format!(
+                        "state=run_dispatch_failed action={:?} path={} reason=missing_callback",
+                        action,
+                        script_path.display()
+                    ),
+                );
+            }
             return;
         }
 
diff --git a/src/prompts/chat/prompt.rs b/src/prompts/chat/prompt.rs
index 4ef4ac1aae4123a9bdd9771500998f87f424660b..78a8d8354e9e50914fdbcf1cc0fce0292b4feac2
--- a/src/prompts/chat/prompt.rs
+++ b/src/prompts/chat/prompt.rs
@@ -60,6 +60,9 @@
     pub(super) on_claude_code: Option<ChatClaudeCodeCallback>,
     // Callback for showing actions dialog (handled by parent)
     pub(super) on_show_actions: Option<ChatShowActionsCallback>,
+    // Callback for running a saved generated script via parent app pipeline
+    pub(super) on_run_script:
+        Option<Arc<dyn Fn(std::path::PathBuf, &mut Context<ChatPrompt>) + Send + Sync>>,
     // Stable UUID for Claude Code CLI session continuity within this prompt's lifetime.
     // Generated once at construction so all messages share the same session.
     pub(super) cli_session_id: String,
@@ -134,6 +137,7 @@
             on_configure: None,
             on_claude_code: None,
             on_show_actions: None,
+            on_run_script: None,
             cli_session_id: uuid::Uuid::new_v4().to_string(),
             pending_image: None,
             pending_image_render: None,
@@ -146,6 +150,15 @@
         self.on_show_actions = Some(callback);
     }
 
+    /// Set the callback for running a generated script path in the parent app.
+    pub fn with_run_script_callback(
+        mut self,
+        callback: impl Fn(std::path::PathBuf, &mut Context<Self>) + Send + Sync + 'static,
+    ) -> Self {
+        self.on_run_script = Some(Arc::new(callback));
+        self
+    }
+
     /// Start the cursor blink timer
     pub fn start_cursor_blink(&mut self, cx: &mut Context<Self>) {
         cx.spawn(async move |this, cx| {
diff --git a/src/prompts/chat/render_core.rs b/src/prompts/chat/render_core.rs
index 4e91d2d0ed474e69c143cd50e58e0491df58450b..7a066a4f6a2e6ac66e5e870f4a926cfbe0c56618
--- a/src/prompts/chat/render_core.rs
+++ b/src/prompts/chat/render_core.rs
@@ -32,10 +32,18 @@
         label: &'static str,
         shortcut: Option<&'static str>,
         action: ScriptGenerationAction,
-        accent_color: u32,
-        muted_color: u32,
+        footer_colors: PromptFooterColors,
         cx: &mut Context<Self>,
     ) -> AnyElement {
+        let button_font_size =
+            crate::components::prompt_footer::footer_button_font_size_px(&self.theme);
+        let hover_bg = rgba(crate::components::prompt_footer::footer_button_hover_rgba(
+            footer_colors,
+        ));
+        let active_bg = rgba(crate::components::prompt_footer::footer_button_active_rgba(
+            footer_colors,
+        ));
+
         div()
             .id(id)
             .flex()
@@ -46,9 +54,21 @@
             .py(px(2.0))
             .rounded(px(4.0))
             .cursor_pointer()
-            .child(div().text_xs().text_color(rgb(accent_color)).child(label))
+            .hover(move |d| d.bg(hover_bg))
+            .active(move |d| d.bg(active_bg))
+            .child(
+                div()
+                    .text_size(px(button_font_size))
+                    .text_color(rgb(footer_colors.accent))
+                    .child(label),
+            )
             .when_some(shortcut, |d, shortcut| {
-                d.child(div().text_xs().text_color(rgb(muted_color)).child(shortcut))
+                d.child(
+                    div()
+                        .text_size(px(button_font_size))
+                        .text_color(rgb(footer_colors.text_muted))
+                        .child(shortcut),
+                )
             })
             .on_click(cx.listener(move |this, _event, _window, cx| {
                 this.handle_script_generation_action(action, cx);
@@ -109,10 +129,9 @@
             self.render_script_generation_footer_button(
                 "chat-footer-primary-button",
                 "Save and Run",
-                None,
+                Some("⌘↵"),
                 ScriptGenerationAction::SaveAndRun,
-                footer_colors.accent,
-                footer_colors.text_muted,
+                footer_colors,
                 cx,
             )
         } else {
@@ -194,8 +213,7 @@
                     "Save",
                     None,
                     ScriptGenerationAction::Save,
-                    footer_colors.accent,
-                    footer_colors.text_muted,
+                    footer_colors,
                     cx,
                 ))
                 .child(self.render_script_generation_footer_button(
@@ -203,8 +221,7 @@
                     "Run",
                     None,
                     ScriptGenerationAction::Run,
-                    footer_colors.accent,
-                    footer_colors.text_muted,
+                    footer_colors,
                     cx,
                 ));
         }
@@ -356,7 +373,13 @@
                     }
                 }
                 ChatInputKeyAction::ToggleActions => this.toggle_actions_menu(cx),
-                ChatInputKeyAction::ContinueInChat => this.handle_continue_in_chat(cx),
+                ChatInputKeyAction::ContinueInChat => {
+                    if this.script_generation_mode {
+                        this.handle_script_generation_action(ScriptGenerationAction::SaveAndRun, cx);
+                    } else {
+                        this.handle_continue_in_chat(cx);
+                    }
+                }
                 ChatInputKeyAction::Submit => this.handle_submit(cx),
                 ChatInputKeyAction::InsertNewline => {
                     this.input.insert_char('\n');
@@ -618,7 +641,9 @@
             "Footer primary action should branch on script_generation_mode"
         );
         assert!(
-            normalized.contains("\"chat-footer-primary-button\",\"SaveandRun\",None,ScriptGenerationAction::SaveAndRun,"),
+            normalized.contains(
+                "\"chat-footer-primary-button\",\"SaveandRun\",Some(\"⌘↵\"),ScriptGenerationAction::SaveAndRun,"
+            ),
             "Script generation mode should render Save and Run as the primary footer action"
         );
         assert!(
@@ -647,4 +672,18 @@
             "Save and Run should only appear as the primary footer action slot"
         );
     }
+
+    #[test]
+    fn test_cmd_enter_runs_save_and_run_when_script_generation_mode_enabled() {
+        let content = fs::read_to_string("src/prompts/chat/render_core.rs")
+            .expect("Failed to read src/prompts/chat/render_core.rs");
+        let normalized: String = content.chars().filter(|c| !c.is_whitespace()).collect();
+
+        assert!(
+            normalized.contains(
+                "ChatInputKeyAction::ContinueInChat=>{ifthis.script_generation_mode{this.handle_script_generation_action(ScriptGenerationAction::SaveAndRun,cx);}else{this.handle_continue_in_chat(cx);}}"
+            ),
+            "Cmd+Enter should trigger SaveAndRun in script generation mode and ContinueInChat otherwise"
+        );
+    }
 }


thinking
**Reviewing render_core imports and closure usage**
exec
/bin/zsh -lc "cd /Users/johnlindquist/dev/script-kit-gpui && sed -n '1,260p' src/prompts/chat/render_core.rs" in /Users/johnlindquist/dev/script-kit-gpui succeeded in 51ms:
use super::*;

impl ChatPrompt {
    fn render_footer_button(
        &self,
        id: &'static str,
        label: &'static str,
        shortcut: Option<&'static str>,
        accent_color: u32,
        muted_color: u32,
    ) -> AnyElement {
        div()
            .id(id)
            .flex()
            .flex_row()
            .items_center()
            .gap(px(6.0))
            .px(px(8.0))
            .py(px(2.0))
            .rounded(px(4.0))
file update:
diff --git a/src/ai/script_generation.rs b/src/ai/script_generation.rs
index f29715b032570028241789219179c413e5c5ed83..a89e4e8d4161e386089b6e3cac57975cd36b3cd0
--- a/src/ai/script_generation.rs
+++ b/src/ai/script_generation.rs
@@ -148,75 +148,6 @@
     Ok(script_path)
 }
 
-pub(crate) fn run_saved_script(path: &Path) -> Result<()> {
-    let script_path = path.to_string_lossy().to_string();
-    let attempts: &[(&str, &[&str])] = &[
-        ("kit", &["run", &script_path]),
-        ("bun", &["run", &script_path]),
-    ];
-
-    let mut failures = Vec::new();
-
-    for &(cmd, args) in attempts {
-        let result = std::process::Command::new(cmd)
-            .args(args)
-            .stderr(std::process::Stdio::piped())
-            .stdout(std::process::Stdio::piped())
-            .spawn();
-
-        match result {
-            Ok(mut child) => {
-                // Wait briefly for quick failures (e.g. bun cache corruption, missing deps).
-                // If still running after the timeout, assume it launched successfully.
-                let timeout = std::time::Duration::from_secs(5);
-                let start = std::time::Instant::now();
-                loop {
-                    match child.try_wait() {
-                        Ok(Some(status)) if !status.success() => {
-                            let stderr_text = child
-                                .stderr
-                                .take()
-                                .map(|mut s| {
-                                    let mut buf = String::new();
-                                    std::io::Read::read_to_string(&mut s, &mut buf).ok();
-                                    buf
-                                })
-                                .unwrap_or_default();
-                            let detail = if stderr_text.trim().is_empty() {
-                                format!("exit {}", status)
-                            } else {
-                                stderr_text.trim().to_string()
-                            };
-                            failures.push(format!("{}: {}", cmd, detail));
-                            break;
-                        }
-                        Ok(Some(_)) => return Ok(()), // exited successfully
-                        Ok(None) => {
-                            if start.elapsed() >= timeout {
-                                return Ok(()); // still running — launched OK
-                            }
-                            std::thread::sleep(std::time::Duration::from_millis(50));
-                        }
-                        Err(error) => {
-                            failures.push(format!("{}: wait failed: {}", cmd, error));
-                            break;
-                        }
-                    }
-                }
-            }
-            Err(error) => {
-                failures.push(format!("{}: {}", cmd, error));
-            }
-        }
-    }
-
-    anyhow::bail!(
-        "Failed to run script (path={}, attempts={})",
-        path.display(),
-        failures.join(" | ")
-    );
-}
-
 fn select_generation_model(
     registry: &ProviderRegistry,
 ) -> Result<(ModelInfo, Arc<dyn AiProvider>)> {
diff --git a/src/app_impl/prompt_ai.rs b/src/app_impl/prompt_ai.rs
index c8266b6cb798ec62e6e7e9a8a59005512e44b72f..6c10ca4234dc2d80bb14bc0d5163caddf97656cc
--- a/src/app_impl/prompt_ai.rs
+++ b/src/app_impl/prompt_ai.rs
@@ -568,6 +568,38 @@
         let noop_callback: ChatSubmitCallback = std::sync::Arc::new(|_id, _text| {
             // Built-in AI mode handles this internally
         });
+        let app_entity = cx.entity().downgrade();
+        let run_script_callback = move |script_path: std::path::PathBuf,
+                                        chat_cx: &mut gpui::Context<ChatPrompt>| {
+            let script_path_string = script_path.to_string_lossy().to_string();
+            let app_entity = app_entity.clone();
+            chat_cx
+                .spawn(async move |_this, cx| {
+                    let _ = cx.update(|cx| {
+                        if let Some(app) = app_entity.upgrade() {
+                            logging::log(
+                                "CHAT_SCRIPT_GEN",
+                                &format!(
+                                    "state=dispatch_run attempted=execute_script_by_path path={}",
+                                    script_path_string
+                                ),
+                            );
+                            app.update(cx, |app, cx| {
+                                app.execute_script_by_path(&script_path_string, cx);
+                            });
+                        } else {
+                            logging::log(
+                                "CHAT_SCRIPT_GEN",
+                                &format!(
+                                    "state=dispatch_run_failed attempted=execute_script_by_path path={} reason=app_entity_unavailable",
+                                    script_path_string
+                                ),
+                            );
+                        }
+                    });
+                })
+                .detach();
+        };
 
         let placeholder = Some("Describe the script you want to generate...".to_string());
 
@@ -584,6 +616,7 @@
         .with_title("Generate Script with AI")
         .with_save_history(false)
         .with_escape_callback(escape_callback)
+        .with_run_script_callback(run_script_callback)
         .with_builtin_ai(registry, true) // true = prefer Vercel AI Gateway
         .with_builtin_system_prompt(crate::ai::script_generation::AI_SCRIPT_GENERATION_SYSTEM_PROMPT)
         .with_script_generation_mode(true);
diff --git a/src/components/prompt_footer.rs b/src/components/prompt_footer.rs
index 6bfa86a1edacaec90dc82185bb178cd09dfb7b61..0ce40c6c9c2ea6aa9f9e7599cb8065ebd2c5318b
--- a/src/components/prompt_footer.rs
+++ b/src/components/prompt_footer.rs
@@ -155,14 +155,19 @@
     )
 }
 
-fn footer_button_hover_rgba(colors: PromptFooterColors) -> u32 {
+pub fn footer_button_hover_rgba(colors: PromptFooterColors) -> u32 {
     (colors.background << 8) | (PROMPT_FOOTER_BUTTON_HOVER_OPACITY as u32)
 }
 
-fn footer_button_active_rgba(colors: PromptFooterColors) -> u32 {
+pub fn footer_button_active_rgba(colors: PromptFooterColors) -> u32 {
     (colors.background << 8) | (PROMPT_FOOTER_BUTTON_ACTIVE_OPACITY as u32)
 }
 
+pub fn footer_button_font_size_px(theme: &Theme) -> f32 {
+    (theme.get_fonts().ui_size - PROMPT_FOOTER_BUTTON_FONT_DELTA_PX)
+        .max(PROMPT_FOOTER_BUTTON_FONT_MIN_PX)
+}
+
 /// Configuration for PromptFooter display
 #[derive(Clone, Debug)]
 pub struct PromptFooterConfig {
@@ -334,8 +339,7 @@
         on_click: Option<Rc<FooterClickCallback>>,
     ) -> impl IntoElement {
         let theme = crate::theme::get_cached_theme();
-        let button_font_size = (theme.get_fonts().ui_size - PROMPT_FOOTER_BUTTON_FONT_DELTA_PX)
-            .max(PROMPT_FOOTER_BUTTON_FONT_MIN_PX);
+        let button_font_size = footer_button_font_size_px(&theme);
         let has_click_handler = on_click.is_some();
         let is_clickable = is_footer_button_clickable(has_click_handler, disabled);
         let on_click_for_key = on_click.clone();
diff --git a/src/prompts/chat/actions.rs b/src/prompts/chat/actions.rs
index 8ae41af43235d867176126f8de45f9fc8f3f2cbf..4d01323e1d134ef8e6f56be60d0a1eee086247e7
--- a/src/prompts/chat/actions.rs
+++ b/src/prompts/chat/actions.rs
@@ -172,48 +172,36 @@
 
         if action.should_run_after_save() {
             self.set_script_generation_status(false, format!("Running {}...", script_name), cx);
-
-            let path_clone = script_path.clone();
-            let name_clone = script_name.clone();
-            cx.spawn(async move |this, cx| {
-                let run_result = std::thread::spawn(move || {
-                    crate::ai::script_generation::run_saved_script(&path_clone)
-                })
-                .join()
-                .map_err(|_| anyhow::anyhow!("run thread panicked"))
-                .and_then(|r| r);
-
-                let _ = cx.update(|cx| {
-                    this.update(cx, |chat, cx| match run_result {
-                        Ok(()) => {
-                            chat.set_script_generation_status(
-                                false,
-                                format!("Saved and running {}", name_clone),
-                                cx,
-                            );
-                            logging::log(
-                                "CHAT_SCRIPT_GEN",
-                                &format!("state=run_ok action={:?} script={}", action, name_clone),
-                            );
-                        }
-                        Err(error) => {
-                            chat.set_script_generation_status(
-                                true,
-                                format!("Saved {} but failed to run: {}", name_clone, error),
-                                cx,
-                            );
-                            logging::log(
-                                "CHAT_SCRIPT_GEN",
-                                &format!(
-                                    "state=run_failed action={:?} script={} error={}",
-                                    action, name_clone, error
-                                ),
-                            );
-                        }
-                    })
-                });
-            })
-            .detach();
+            if let Some(ref callback) = self.on_run_script {
+                callback(script_path.clone(), cx);
+                self.set_script_generation_status(
+                    false,
+                    format!("Saved and running {}", script_name),
+                    cx,
+                );
+                logging::log(
+                    "CHAT_SCRIPT_GEN",
+                    &format!(
+                        "state=run_dispatched action={:?} path={}",
+                        action,
+                        script_path.display()
+                    ),
+                );
+            } else {
+                self.set_script_generation_status(
+                    true,
+                    format!("Saved {} but run action is unavailable", script_name),
+                    cx,
+                );
+                logging::log(
+                    "CHAT_SCRIPT_GEN",
+                    &format!(
+                        "state=run_dispatch_failed action={:?} path={} reason=missing_callback",
+                        action,
+                        script_path.display()
+                    ),
+                );
+            }
             return;
         }
 
diff --git a/src/prompts/chat/prompt.rs b/src/prompts/chat/prompt.rs
index 4ef4ac1aae4123a9bdd9771500998f87f424660b..78a8d8354e9e50914fdbcf1cc0fce0292b4feac2
--- a/src/prompts/chat/prompt.rs
+++ b/src/prompts/chat/prompt.rs
@@ -60,6 +60,9 @@
     pub(super) on_claude_code: Option<ChatClaudeCodeCallback>,
     // Callback for showing actions dialog (handled by parent)
     pub(super) on_show_actions: Option<ChatShowActionsCallback>,
+    // Callback for running a saved generated script via parent app pipeline
+    pub(super) on_run_script:
+        Option<Arc<dyn Fn(std::path::PathBuf, &mut Context<ChatPrompt>) + Send + Sync>>,
     // Stable UUID for Claude Code CLI session continuity within this prompt's lifetime.
     // Generated once at construction so all messages share the same session.
     pub(super) cli_session_id: String,
@@ -134,6 +137,7 @@
             on_configure: None,
             on_claude_code: None,
             on_show_actions: None,
+            on_run_script: None,
             cli_session_id: uuid::Uuid::new_v4().to_string(),
             pending_image: None,
             pending_image_render: None,
@@ -146,6 +150,15 @@
         self.on_show_actions = Some(callback);
     }
 
+    /// Set the callback for running a generated script path in the parent app.
+    pub fn with_run_script_callback(
+        mut self,
+        callback: impl Fn(std::path::PathBuf, &mut Context<Self>) + Send + Sync + 'static,
+    ) -> Self {
+        self.on_run_script = Some(Arc::new(callback));
+        self
+    }
+
     /// Start the cursor blink timer
     pub fn start_cursor_blink(&mut self, cx: &mut Context<Self>) {
         cx.spawn(async move |this, cx| {
diff --git a/src/prompts/chat/render_core.rs b/src/prompts/chat/render_core.rs
index 4e91d2d0ed474e69c143cd50e58e0491df58450b..7a066a4f6a2e6ac66e5e870f4a926cfbe0c56618
--- a/src/prompts/chat/render_core.rs
+++ b/src/prompts/chat/render_core.rs
@@ -32,10 +32,18 @@
         label: &'static str,
         shortcut: Option<&'static str>,
         action: ScriptGenerationAction,
-        accent_color: u32,
-        muted_color: u32,
+        footer_colors: PromptFooterColors,
         cx: &mut Context<Self>,
     ) -> AnyElement {
+        let button_font_size =
+            crate::components::prompt_footer::footer_button_font_size_px(&self.theme);
+        let hover_bg = rgba(crate::components::prompt_footer::footer_button_hover_rgba(
+            footer_colors,
+        ));
+        let active_bg = rgba(crate::components::prompt_footer::footer_button_active_rgba(
+            footer_colors,
+        ));
+
         div()
             .id(id)
             .flex()
@@ -46,9 +54,21 @@
             .py(px(2.0))
             .rounded(px(4.0))
             .cursor_pointer()
-            .child(div().text_xs().text_color(rgb(accent_color)).child(label))
+            .hover(move |d| d.bg(hover_bg))
+            .active(move |d| d.bg(active_bg))
+            .child(
+                div()
+                    .text_size(px(button_font_size))
+                    .text_color(rgb(footer_colors.accent))
+                    .child(label),
+            )
             .when_some(shortcut, |d, shortcut| {
-                d.child(div().text_xs().text_color(rgb(muted_color)).child(shortcut))
+                d.child(
+                    div()
+                        .text_size(px(button_font_size))
+                        .text_color(rgb(footer_colors.text_muted))
+                        .child(shortcut),
+                )
             })
             .on_click(cx.listener(move |this, _event, _window, cx| {
                 this.handle_script_generation_action(action, cx);
@@ -109,10 +129,9 @@
             self.render_script_generation_footer_button(
                 "chat-footer-primary-button",
                 "Save and Run",
-                None,
+                Some("⌘↵"),
                 ScriptGenerationAction::SaveAndRun,
-                footer_colors.accent,
-                footer_colors.text_muted,
+                footer_colors,
                 cx,
             )
         } else {
@@ -194,8 +213,7 @@
                     "Save",
                     None,
                     ScriptGenerationAction::Save,
-                    footer_colors.accent,
-                    footer_colors.text_muted,
+                    footer_colors,
                     cx,
                 ))
                 .child(self.render_script_generation_footer_button(
@@ -203,8 +221,7 @@
                     "Run",
                     None,
                     ScriptGenerationAction::Run,
-                    footer_colors.accent,
-                    footer_colors.text_muted,
+                    footer_colors,
                     cx,
                 ));
         }
@@ -356,7 +373,13 @@
                     }
                 }
                 ChatInputKeyAction::ToggleActions => this.toggle_actions_menu(cx),
-                ChatInputKeyAction::ContinueInChat => this.handle_continue_in_chat(cx),
+                ChatInputKeyAction::ContinueInChat => {
+                    if this.script_generation_mode {
+                        this.handle_script_generation_action(ScriptGenerationAction::SaveAndRun, cx);
+                    } else {
+                        this.handle_continue_in_chat(cx);
+                    }
+                }
                 ChatInputKeyAction::Submit => this.handle_submit(cx),
                 ChatInputKeyAction::InsertNewline => {
                     this.input.insert_char('\n');
@@ -618,7 +641,9 @@
             "Footer primary action should branch on script_generation_mode"
         );
         assert!(
-            normalized.contains("\"chat-footer-primary-button\",\"SaveandRun\",None,ScriptGenerationAction::SaveAndRun,"),
+            normalized.contains(
+                "\"chat-footer-primary-button\",\"SaveandRun\",Some(\"⌘↵\"),ScriptGenerationAction::SaveAndRun,"
+            ),
             "Script generation mode should render Save and Run as the primary footer action"
         );
         assert!(
@@ -647,4 +672,18 @@
             "Save and Run should only appear as the primary footer action slot"
         );
     }
+
+    #[test]
+    fn test_cmd_enter_runs_save_and_run_when_script_generation_mode_enabled() {
+        let content = fs::read_to_string("src/prompts/chat/render_core.rs")
+            .expect("Failed to read src/prompts/chat/render_core.rs");
+        let normalized: String = content.chars().filter(|c| !c.is_whitespace()).collect();
+
+        assert!(
+            normalized.contains(
+                "ChatInputKeyAction::ContinueInChat=>{ifthis.script_generation_mode{this.handle_script_generation_action(ScriptGenerationAction::SaveAndRun,cx);}else{this.handle_continue_in_chat(cx);}}"
+            ),
+            "Cmd+Enter should trigger SaveAndRun in script generation mode and ContinueInChat otherwise"
+        );
+    }
 }


thinking
**Inspecting key handler snippet**
exec
/bin/zsh -lc "cd /Users/johnlindquist/dev/script-kit-gpui && sed -n '320,430p' src/prompts/chat/render_core.rs" in /Users/johnlindquist/dev/script-kit-gpui succeeded in 51ms:

            // Setup mode: keyboard navigation for Configure / Claude Code buttons
            if needs_setup {
                let (next_index, action, changed) = resolve_setup_card_key(
                    key,
                    event.keystroke.modifiers.shift,
                    this.setup_focus_index,
                );
                let handled = changed || !matches!(action, SetupCardAction::None);

                if changed {
                    this.setup_focus_index = next_index;
                    cx.notify();
                }

                match action {
                    SetupCardAction::ActivateConfigure => {
                        if let Some(ref callback) = on_configure {
                            logging::log("CHAT", "Setup key activate configure");
                            callback();
file update:
diff --git a/src/ai/script_generation.rs b/src/ai/script_generation.rs
index f29715b032570028241789219179c413e5c5ed83..a89e4e8d4161e386089b6e3cac57975cd36b3cd0
--- a/src/ai/script_generation.rs
+++ b/src/ai/script_generation.rs
@@ -148,75 +148,6 @@
     Ok(script_path)
 }
 
-pub(crate) fn run_saved_script(path: &Path) -> Result<()> {
-    let script_path = path.to_string_lossy().to_string();
-    let attempts: &[(&str, &[&str])] = &[
-        ("kit", &["run", &script_path]),
-        ("bun", &["run", &script_path]),
-    ];
-
-    let mut failures = Vec::new();
-
-    for &(cmd, args) in attempts {
-        let result = std::process::Command::new(cmd)
-            .args(args)
-            .stderr(std::process::Stdio::piped())
-            .stdout(std::process::Stdio::piped())
-            .spawn();
-
-        match result {
-            Ok(mut child) => {
-                // Wait briefly for quick failures (e.g. bun cache corruption, missing deps).
-                // If still running after the timeout, assume it launched successfully.
-                let timeout = std::time::Duration::from_secs(5);
-                let start = std::time::Instant::now();
-                loop {
-                    match child.try_wait() {
-                        Ok(Some(status)) if !status.success() => {
-                            let stderr_text = child
-                                .stderr
-                                .take()
-                                .map(|mut s| {
-                                    let mut buf = String::new();
-                                    std::io::Read::read_to_string(&mut s, &mut buf).ok();
-                                    buf
-                                })
-                                .unwrap_or_default();
-                            let detail = if stderr_text.trim().is_empty() {
-                                format!("exit {}", status)
-                            } else {
-                                stderr_text.trim().to_string()
-                            };
-                            failures.push(format!("{}: {}", cmd, detail));
-                            break;
-                        }
-                        Ok(Some(_)) => return Ok(()), // exited successfully
-                        Ok(None) => {
-                            if start.elapsed() >= timeout {
-                                return Ok(()); // still running — launched OK
-                            }
-                            std::thread::sleep(std::time::Duration::from_millis(50));
-                        }
-                        Err(error) => {
-                            failures.push(format!("{}: wait failed: {}", cmd, error));
-                            break;
-                        }
-                    }
-                }
-            }
-            Err(error) => {
-                failures.push(format!("{}: {}", cmd, error));
-            }
-        }
-    }
-
-    anyhow::bail!(
-        "Failed to run script (path={}, attempts={})",
-        path.display(),
-        failures.join(" | ")
-    );
-}
-
 fn select_generation_model(
     registry: &ProviderRegistry,
 ) -> Result<(ModelInfo, Arc<dyn AiProvider>)> {
diff --git a/src/app_impl/prompt_ai.rs b/src/app_impl/prompt_ai.rs
index c8266b6cb798ec62e6e7e9a8a59005512e44b72f..6c10ca4234dc2d80bb14bc0d5163caddf97656cc
--- a/src/app_impl/prompt_ai.rs
+++ b/src/app_impl/prompt_ai.rs
@@ -568,6 +568,38 @@
         let noop_callback: ChatSubmitCallback = std::sync::Arc::new(|_id, _text| {
             // Built-in AI mode handles this internally
         });
+        let app_entity = cx.entity().downgrade();
+        let run_script_callback = move |script_path: std::path::PathBuf,
+                                        chat_cx: &mut gpui::Context<ChatPrompt>| {
+            let script_path_string = script_path.to_string_lossy().to_string();
+            let app_entity = app_entity.clone();
+            chat_cx
+                .spawn(async move |_this, cx| {
+                    let _ = cx.update(|cx| {
+                        if let Some(app) = app_entity.upgrade() {
+                            logging::log(
+                                "CHAT_SCRIPT_GEN",
+                                &format!(
+                                    "state=dispatch_run attempted=execute_script_by_path path={}",
+                                    script_path_string
+                                ),
+                            );
+                            app.update(cx, |app, cx| {
+                                app.execute_script_by_path(&script_path_string, cx);
+                            });
+                        } else {
+                            logging::log(
+                                "CHAT_SCRIPT_GEN",
+                                &format!(
+                                    "state=dispatch_run_failed attempted=execute_script_by_path path={} reason=app_entity_unavailable",
+                                    script_path_string
+                                ),
+                            );
+                        }
+                    });
+                })
+                .detach();
+        };
 
         let placeholder = Some("Describe the script you want to generate...".to_string());
 
@@ -584,6 +616,7 @@
         .with_title("Generate Script with AI")
         .with_save_history(false)
         .with_escape_callback(escape_callback)
+        .with_run_script_callback(run_script_callback)
         .with_builtin_ai(registry, true) // true = prefer Vercel AI Gateway
         .with_builtin_system_prompt(crate::ai::script_generation::AI_SCRIPT_GENERATION_SYSTEM_PROMPT)
         .with_script_generation_mode(true);
diff --git a/src/components/prompt_footer.rs b/src/components/prompt_footer.rs
index 6bfa86a1edacaec90dc82185bb178cd09dfb7b61..0ce40c6c9c2ea6aa9f9e7599cb8065ebd2c5318b
--- a/src/components/prompt_footer.rs
+++ b/src/components/prompt_footer.rs
@@ -155,14 +155,19 @@
     )
 }
 
-fn footer_button_hover_rgba(colors: PromptFooterColors) -> u32 {
+pub fn footer_button_hover_rgba(colors: PromptFooterColors) -> u32 {
     (colors.background << 8) | (PROMPT_FOOTER_BUTTON_HOVER_OPACITY as u32)
 }
 
-fn footer_button_active_rgba(colors: PromptFooterColors) -> u32 {
+pub fn footer_button_active_rgba(colors: PromptFooterColors) -> u32 {
     (colors.background << 8) | (PROMPT_FOOTER_BUTTON_ACTIVE_OPACITY as u32)
 }
 
+pub fn footer_button_font_size_px(theme: &Theme) -> f32 {
+    (theme.get_fonts().ui_size - PROMPT_FOOTER_BUTTON_FONT_DELTA_PX)
+        .max(PROMPT_FOOTER_BUTTON_FONT_MIN_PX)
+}
+
 /// Configuration for PromptFooter display
 #[derive(Clone, Debug)]
 pub struct PromptFooterConfig {
@@ -334,8 +339,7 @@
         on_click: Option<Rc<FooterClickCallback>>,
     ) -> impl IntoElement {
         let theme = crate::theme::get_cached_theme();
-        let button_font_size = (theme.get_fonts().ui_size - PROMPT_FOOTER_BUTTON_FONT_DELTA_PX)
-            .max(PROMPT_FOOTER_BUTTON_FONT_MIN_PX);
+        let button_font_size = footer_button_font_size_px(&theme);
         let has_click_handler = on_click.is_some();
         let is_clickable = is_footer_button_clickable(has_click_handler, disabled);
         let on_click_for_key = on_click.clone();
diff --git a/src/prompts/chat/actions.rs b/src/prompts/chat/actions.rs
index 8ae41af43235d867176126f8de45f9fc8f3f2cbf..4d01323e1d134ef8e6f56be60d0a1eee086247e7
--- a/src/prompts/chat/actions.rs
+++ b/src/prompts/chat/actions.rs
@@ -172,48 +172,36 @@
 
         if action.should_run_after_save() {
             self.set_script_generation_status(false, format!("Running {}...", script_name), cx);
-
-            let path_clone = script_path.clone();
-            let name_clone = script_name.clone();
-            cx.spawn(async move |this, cx| {
-                let run_result = std::thread::spawn(move || {
-                    crate::ai::script_generation::run_saved_script(&path_clone)
-                })
-                .join()
-                .map_err(|_| anyhow::anyhow!("run thread panicked"))
-                .and_then(|r| r);
-
-                let _ = cx.update(|cx| {
-                    this.update(cx, |chat, cx| match run_result {
-                        Ok(()) => {
-                            chat.set_script_generation_status(
-                                false,
-                                format!("Saved and running {}", name_clone),
-                                cx,
-                            );
-                            logging::log(
-                                "CHAT_SCRIPT_GEN",
-                                &format!("state=run_ok action={:?} script={}", action, name_clone),
-                            );
-                        }
-                        Err(error) => {
-                            chat.set_script_generation_status(
-                                true,
-                                format!("Saved {} but failed to run: {}", name_clone, error),
-                                cx,
-                            );
-                            logging::log(
-                                "CHAT_SCRIPT_GEN",
-                                &format!(
-                                    "state=run_failed action={:?} script={} error={}",
-                                    action, name_clone, error
-                                ),
-                            );
-                        }
-                    })
-                });
-            })
-            .detach();
+            if let Some(ref callback) = self.on_run_script {
+                callback(script_path.clone(), cx);
+                self.set_script_generation_status(
+                    false,
+                    format!("Saved and running {}", script_name),
+                    cx,
+                );
+                logging::log(
+                    "CHAT_SCRIPT_GEN",
+                    &format!(
+                        "state=run_dispatched action={:?} path={}",
+                        action,
+                        script_path.display()
+                    ),
+                );
+            } else {
+                self.set_script_generation_status(
+                    true,
+                    format!("Saved {} but run action is unavailable", script_name),
+                    cx,
+                );
+                logging::log(
+                    "CHAT_SCRIPT_GEN",
+                    &format!(
+                        "state=run_dispatch_failed action={:?} path={} reason=missing_callback",
+                        action,
+                        script_path.display()
+                    ),
+                );
+            }
             return;
         }
 
diff --git a/src/prompts/chat/prompt.rs b/src/prompts/chat/prompt.rs
index 4ef4ac1aae4123a9bdd9771500998f87f424660b..78a8d8354e9e50914fdbcf1cc0fce0292b4feac2
--- a/src/prompts/chat/prompt.rs
+++ b/src/prompts/chat/prompt.rs
@@ -60,6 +60,9 @@
     pub(super) on_claude_code: Option<ChatClaudeCodeCallback>,
     // Callback for showing actions dialog (handled by parent)
     pub(super) on_show_actions: Option<ChatShowActionsCallback>,
+    // Callback for running a saved generated script via parent app pipeline
+    pub(super) on_run_script:
+        Option<Arc<dyn Fn(std::path::PathBuf, &mut Context<ChatPrompt>) + Send + Sync>>,
     // Stable UUID for Claude Code CLI session continuity within this prompt's lifetime.
     // Generated once at construction so all messages share the same session.
     pub(super) cli_session_id: String,
@@ -134,6 +137,7 @@
             on_configure: None,
             on_claude_code: None,
             on_show_actions: None,
+            on_run_script: None,
             cli_session_id: uuid::Uuid::new_v4().to_string(),
             pending_image: None,
             pending_image_render: None,
@@ -146,6 +150,15 @@
         self.on_show_actions = Some(callback);
     }
 
+    /// Set the callback for running a generated script path in the parent app.
+    pub fn with_run_script_callback(
+        mut self,
+        callback: impl Fn(std::path::PathBuf, &mut Context<Self>) + Send + Sync + 'static,
+    ) -> Self {
+        self.on_run_script = Some(Arc::new(callback));
+        self
+    }
+
     /// Start the cursor blink timer
     pub fn start_cursor_blink(&mut self, cx: &mut Context<Self>) {
         cx.spawn(async move |this, cx| {
diff --git a/src/prompts/chat/render_core.rs b/src/prompts/chat/render_core.rs
index 4e91d2d0ed474e69c143cd50e58e0491df58450b..7a066a4f6a2e6ac66e5e870f4a926cfbe0c56618
--- a/src/prompts/chat/render_core.rs
+++ b/src/prompts/chat/render_core.rs
@@ -32,10 +32,18 @@
         label: &'static str,
         shortcut: Option<&'static str>,
         action: ScriptGenerationAction,
-        accent_color: u32,
-        muted_color: u32,
+        footer_colors: PromptFooterColors,
         cx: &mut Context<Self>,
     ) -> AnyElement {
+        let button_font_size =
+            crate::components::prompt_footer::footer_button_font_size_px(&self.theme);
+        let hover_bg = rgba(crate::components::prompt_footer::footer_button_hover_rgba(
+            footer_colors,
+        ));
+        let active_bg = rgba(crate::components::prompt_footer::footer_button_active_rgba(
+            footer_colors,
+        ));
+
         div()
             .id(id)
             .flex()
@@ -46,9 +54,21 @@
             .py(px(2.0))
             .rounded(px(4.0))
             .cursor_pointer()
-            .child(div().text_xs().text_color(rgb(accent_color)).child(label))
+            .hover(move |d| d.bg(hover_bg))
+            .active(move |d| d.bg(active_bg))
+            .child(
+                div()
+                    .text_size(px(button_font_size))
+                    .text_color(rgb(footer_colors.accent))
+                    .child(label),
+            )
             .when_some(shortcut, |d, shortcut| {
-                d.child(div().text_xs().text_color(rgb(muted_color)).child(shortcut))
+                d.child(
+                    div()
+                        .text_size(px(button_font_size))
+                        .text_color(rgb(footer_colors.text_muted))
+                        .child(shortcut),
+                )
             })
             .on_click(cx.listener(move |this, _event, _window, cx| {
                 this.handle_script_generation_action(action, cx);
@@ -109,10 +129,9 @@
             self.render_script_generation_footer_button(
                 "chat-footer-primary-button",
                 "Save and Run",
-                None,
+                Some("⌘↵"),
                 ScriptGenerationAction::SaveAndRun,
-                footer_colors.accent,
-                footer_colors.text_muted,
+                footer_colors,
                 cx,
             )
         } else {
@@ -194,8 +213,7 @@
                     "Save",
                     None,
                     ScriptGenerationAction::Save,
-                    footer_colors.accent,
-                    footer_colors.text_muted,
+                    footer_colors,
                     cx,
                 ))
                 .child(self.render_script_generation_footer_button(
@@ -203,8 +221,7 @@
                     "Run",
                     None,
                     ScriptGenerationAction::Run,
-                    footer_colors.accent,
-                    footer_colors.text_muted,
+                    footer_colors,
                     cx,
                 ));
         }
@@ -356,7 +373,13 @@
                     }
                 }
                 ChatInputKeyAction::ToggleActions => this.toggle_actions_menu(cx),
-                ChatInputKeyAction::ContinueInChat => this.handle_continue_in_chat(cx),
+                ChatInputKeyAction::ContinueInChat => {
+                    if this.script_generation_mode {
+                        this.handle_script_generation_action(ScriptGenerationAction::SaveAndRun, cx);
+                    } else {
+                        this.handle_continue_in_chat(cx);
+                    }
+                }
                 ChatInputKeyAction::Submit => this.handle_submit(cx),
                 ChatInputKeyAction::InsertNewline => {
                     this.input.insert_char('\n');
@@ -618,7 +641,9 @@
             "Footer primary action should branch on script_generation_mode"
         );
         assert!(
-            normalized.contains("\"chat-footer-primary-button\",\"SaveandRun\",None,ScriptGenerationAction::SaveAndRun,"),
+            normalized.contains(
+                "\"chat-footer-primary-button\",\"SaveandRun\",Some(\"⌘↵\"),ScriptGenerationAction::SaveAndRun,"
+            ),
             "Script generation mode should render Save and Run as the primary footer action"
         );
         assert!(
@@ -647,4 +672,18 @@
             "Save and Run should only appear as the primary footer action slot"
         );
     }
+
+    #[test]
+    fn test_cmd_enter_runs_save_and_run_when_script_generation_mode_enabled() {
+        let content = fs::read_to_string("src/prompts/chat/render_core.rs")
+            .expect("Failed to read src/prompts/chat/render_core.rs");
+        let normalized: String = content.chars().filter(|c| !c.is_whitespace()).collect();
+
+        assert!(
+            normalized.contains(
+                "ChatInputKeyAction::ContinueInChat=>{ifthis.script_generation_mode{this.handle_script_generation_action(ScriptGenerationAction::SaveAndRun,cx);}else{this.handle_continue_in_chat(cx);}}"
+            ),
+            "Cmd+Enter should trigger SaveAndRun in script generation mode and ContinueInChat otherwise"
+        );
+    }
 }


thinking
**Checking test duplication**
codex
Core wiring is in place. I’m now validating for compile/runtime safety (including potential callback lifetime/type issues) and then I’ll run scoped checks/tests for these changed files.
exec
/bin/zsh -lc "cd /Users/johnlindquist/dev/script-kit-gpui && sed -n '620,760p' src/prompts/chat/render_core.rs" in /Users/johnlindquist/dev/script-kit-gpuiexec
/bin/zsh -lc "cd /Users/johnlindquist/dev/script-kit-gpui && sed -n '120,220p' src/components/prompt_footer.rs" in /Users/johnlindquist/dev/script-kit-gpuiexec
/bin/zsh -lc "cd /Users/johnlindquist/dev/script-kit-gpui && rg -n \"run_saved_script\\(|footer_button_font_size_px|with_run_script_callback|ContinueInChat=>\\{|SaveandRun\\\",Some\\(\\\"⌘↵\\\"\\)\" src -g'*.rs'" in /Users/johnlindquist/dev/script-kit-gpui succeeded in 51ms:
            .child(messages_content)
            // Footer with model selector and footer actions
            .child(self.render_footer(cx))
            // Note: Actions menu is now handled by parent via on_show_actions callback
            // The parent opens the standard ActionsDialog window
            .into_any_element()
    }
}

#[cfg(test)]
mod render_core_footer_tests {
    use std::fs;

    #[test]
    fn test_script_generation_mode_replaces_continue_with_save_and_run_primary_button() {
        let content = fs::read_to_string("src/prompts/chat/render_core.rs")
            .expect("Failed to read src/prompts/chat/render_core.rs");
        let normalized: String = content.chars().filter(|c| !c.is_whitespace()).collect();

        assert!(
 succeeded in 50ms:
}

impl Default for PromptFooterColors {
    fn default() -> Self {
        Self::from_theme(&crate::theme::get_cached_theme())
    }
}

/// Resolve footer surface color with mode-specific opacity.
pub fn footer_surface_rgba(colors: PromptFooterColors) -> u32 {
    if colors.is_light_mode {
        // Neutral warm gray for light mode — blocks vibrancy so footer text stays legible.
        0xf0eeefff
    } else {
        // Dark mode: use selected_subtle as a subtle overlay (~12% opacity).
        (colors.background << 8) | 0x1f
    }
}

fn footer_shadow_alpha(colors: PromptFooterColors) -> u8 {
 succeeded in 52ms:
src/app_impl/prompt_ai.rs:619:        .with_run_script_callback(run_script_callback)
src/prompts/chat/render_core.rs:39:            crate::components::prompt_footer::footer_button_font_size_px(&self.theme);
src/prompts/chat/render_core.rs:684:                "ChatInputKeyAction::ContinueInChat=>{ifthis.script_generation_mode{this.handle_script_generation_action(ScriptGenerationAction::SaveAndRun,cx);}else{this.handle_continue_in_chat(cx);}}"
src/prompts/chat/prompt.rs:154:    pub fn with_run_script_callback(
src/components/prompt_footer.rs:166:pub fn footer_button_font_size_px(theme: &Theme) -> f32 {
src/components/prompt_footer.rs:342:        let button_font_size = footer_button_font_size_px(&theme);
file update:
diff --git a/src/ai/script_generation.rs b/src/ai/script_generation.rs
index f29715b032570028241789219179c413e5c5ed83..a89e4e8d4161e386089b6e3cac57975cd36b3cd0
--- a/src/ai/script_generation.rs
+++ b/src/ai/script_generation.rs
@@ -148,75 +148,6 @@
     Ok(script_path)
 }
 
-pub(crate) fn run_saved_script(path: &Path) -> Result<()> {
-    let script_path = path.to_string_lossy().to_string();
-    let attempts: &[(&str, &[&str])] = &[
-        ("kit", &["run", &script_path]),
-        ("bun", &["run", &script_path]),
-    ];
-
-    let mut failures = Vec::new();
-
-    for &(cmd, args) in attempts {
-        let result = std::process::Command::new(cmd)
-            .args(args)
-            .stderr(std::process::Stdio::piped())
-            .stdout(std::process::Stdio::piped())
-            .spawn();
-
-        match result {
-            Ok(mut child) => {
-                // Wait briefly for quick failures (e.g. bun cache corruption, missing deps).
-                // If still running after the timeout, assume it launched successfully.
-                let timeout = std::time::Duration::from_secs(5);
-                let start = std::time::Instant::now();
-                loop {
-                    match child.try_wait() {
-                        Ok(Some(status)) if !status.success() => {
-                            let stderr_text = child
-                                .stderr
-                                .take()
-                                .map(|mut s| {
-                                    let mut buf = String::new();
-                                    std::io::Read::read_to_string(&mut s, &mut buf).ok();
-                                    buf
-                                })
-                                .unwrap_or_default();
-                            let detail = if stderr_text.trim().is_empty() {
-                                format!("exit {}", status)
-                            } else {
-                                stderr_text.trim().to_string()
-                            };
-                            failures.push(format!("{}: {}", cmd, detail));
-                            break;
-                        }
-                        Ok(Some(_)) => return Ok(()), // exited successfully
-                        Ok(None) => {
-                            if start.elapsed() >= timeout {
-                                return Ok(()); // still running — launched OK
-                            }
-                            std::thread::sleep(std::time::Duration::from_millis(50));
-                        }
-                        Err(error) => {
-                            failures.push(format!("{}: wait failed: {}", cmd, error));
-                            break;
-                        }
-                    }
-                }
-            }
-            Err(error) => {
-                failures.push(format!("{}: {}", cmd, error));
-            }
-        }
-    }
-
-    anyhow::bail!(
-        "Failed to run script (path={}, attempts={})",
-        path.display(),
-        failures.join(" | ")
-    );
-}
-
 fn select_generation_model(
     registry: &ProviderRegistry,
 ) -> Result<(ModelInfo, Arc<dyn AiProvider>)> {
diff --git a/src/app_impl/prompt_ai.rs b/src/app_impl/prompt_ai.rs
index c8266b6cb798ec62e6e7e9a8a59005512e44b72f..6c10ca4234dc2d80bb14bc0d5163caddf97656cc
--- a/src/app_impl/prompt_ai.rs
+++ b/src/app_impl/prompt_ai.rs
@@ -568,6 +568,38 @@
         let noop_callback: ChatSubmitCallback = std::sync::Arc::new(|_id, _text| {
             // Built-in AI mode handles this internally
         });
+        let app_entity = cx.entity().downgrade();
+        let run_script_callback = move |script_path: std::path::PathBuf,
+                                        chat_cx: &mut gpui::Context<ChatPrompt>| {
+            let script_path_string = script_path.to_string_lossy().to_string();
+            let app_entity = app_entity.clone();
+            chat_cx
+                .spawn(async move |_this, cx| {
+                    let _ = cx.update(|cx| {
+                        if let Some(app) = app_entity.upgrade() {
+                            logging::log(
+                                "CHAT_SCRIPT_GEN",
+                                &format!(
+                                    "state=dispatch_run attempted=execute_script_by_path path={}",
+                                    script_path_string
+                                ),
+                            );
+                            app.update(cx, |app, cx| {
+                                app.execute_script_by_path(&script_path_string, cx);
+                            });
+                        } else {
+                            logging::log(
+                                "CHAT_SCRIPT_GEN",
+                                &format!(
+                                    "state=dispatch_run_failed attempted=execute_script_by_path path={} reason=app_entity_unavailable",
+                                    script_path_string
+                                ),
+                            );
+                        }
+                    });
+                })
+                .detach();
+        };
 
         let placeholder = Some("Describe the script you want to generate...".to_string());
 
@@ -584,6 +616,7 @@
         .with_title("Generate Script with AI")
         .with_save_history(false)
         .with_escape_callback(escape_callback)
+        .with_run_script_callback(run_script_callback)
         .with_builtin_ai(registry, true) // true = prefer Vercel AI Gateway
         .with_builtin_system_prompt(crate::ai::script_generation::AI_SCRIPT_GENERATION_SYSTEM_PROMPT)
         .with_script_generation_mode(true);
diff --git a/src/components/prompt_footer.rs b/src/components/prompt_footer.rs
index 6bfa86a1edacaec90dc82185bb178cd09dfb7b61..0ce40c6c9c2ea6aa9f9e7599cb8065ebd2c5318b
--- a/src/components/prompt_footer.rs
+++ b/src/components/prompt_footer.rs
@@ -155,14 +155,19 @@
     )
 }
 
-fn footer_button_hover_rgba(colors: PromptFooterColors) -> u32 {
+pub fn footer_button_hover_rgba(colors: PromptFooterColors) -> u32 {
     (colors.background << 8) | (PROMPT_FOOTER_BUTTON_HOVER_OPACITY as u32)
 }
 
-fn footer_button_active_rgba(colors: PromptFooterColors) -> u32 {
+pub fn footer_button_active_rgba(colors: PromptFooterColors) -> u32 {
     (colors.background << 8) | (PROMPT_FOOTER_BUTTON_ACTIVE_OPACITY as u32)
 }
 
+pub fn footer_button_font_size_px(theme: &Theme) -> f32 {
+    (theme.get_fonts().ui_size - PROMPT_FOOTER_BUTTON_FONT_DELTA_PX)
+        .max(PROMPT_FOOTER_BUTTON_FONT_MIN_PX)
+}
+
 /// Configuration for PromptFooter display
 #[derive(Clone, Debug)]
 pub struct PromptFooterConfig {
@@ -334,8 +339,7 @@
         on_click: Option<Rc<FooterClickCallback>>,
     ) -> impl IntoElement {
         let theme = crate::theme::get_cached_theme();
-        let button_font_size = (theme.get_fonts().ui_size - PROMPT_FOOTER_BUTTON_FONT_DELTA_PX)
-            .max(PROMPT_FOOTER_BUTTON_FONT_MIN_PX);
+        let button_font_size = footer_button_font_size_px(&theme);
         let has_click_handler = on_click.is_some();
         let is_clickable = is_footer_button_clickable(has_click_handler, disabled);
         let on_click_for_key = on_click.clone();
diff --git a/src/prompts/chat/actions.rs b/src/prompts/chat/actions.rs
index 8ae41af43235d867176126f8de45f9fc8f3f2cbf..4d01323e1d134ef8e6f56be60d0a1eee086247e7
--- a/src/prompts/chat/actions.rs
+++ b/src/prompts/chat/actions.rs
@@ -172,48 +172,36 @@
 
         if action.should_run_after_save() {
             self.set_script_generation_status(false, format!("Running {}...", script_name), cx);
-
-            let path_clone = script_path.clone();
-            let name_clone = script_name.clone();
-            cx.spawn(async move |this, cx| {
-                let run_result = std::thread::spawn(move || {
-                    crate::ai::script_generation::run_saved_script(&path_clone)
-                })
-                .join()
-                .map_err(|_| anyhow::anyhow!("run thread panicked"))
-                .and_then(|r| r);
-
-                let _ = cx.update(|cx| {
-                    this.update(cx, |chat, cx| match run_result {
-                        Ok(()) => {
-                            chat.set_script_generation_status(
-                                false,
-                                format!("Saved and running {}", name_clone),
-                                cx,
-                            );
-                            logging::log(
-                                "CHAT_SCRIPT_GEN",
-                                &format!("state=run_ok action={:?} script={}", action, name_clone),
-                            );
-                        }
-                        Err(error) => {
-                            chat.set_script_generation_status(
-                                true,
-                                format!("Saved {} but failed to run: {}", name_clone, error),
-                                cx,
-                            );
-                            logging::log(
-                                "CHAT_SCRIPT_GEN",
-                                &format!(
-                                    "state=run_failed action={:?} script={} error={}",
-                                    action, name_clone, error
-                                ),
-                            );
-                        }
-                    })
-                });
-            })
-            .detach();
+            if let Some(ref callback) = self.on_run_script {
+                callback(script_path.clone(), cx);
+                self.set_script_generation_status(
+                    false,
+                    format!("Saved and running {}", script_name),
+                    cx,
+                );
+                logging::log(
+                    "CHAT_SCRIPT_GEN",
+                    &format!(
+                        "state=run_dispatched action={:?} path={}",
+                        action,
+                        script_path.display()
+                    ),
+                );
+            } else {
+                self.set_script_generation_status(
+                    true,
+                    format!("Saved {} but run action is unavailable", script_name),
+                    cx,
+                );
+                logging::log(
+                    "CHAT_SCRIPT_GEN",
+                    &format!(
+                        "state=run_dispatch_failed action={:?} path={} reason=missing_callback",
+                        action,
+                        script_path.display()
+                    ),
+                );
+            }
             return;
         }
 
diff --git a/src/prompts/chat/prompt.rs b/src/prompts/chat/prompt.rs
index 4ef4ac1aae4123a9bdd9771500998f87f424660b..78a8d8354e9e50914fdbcf1cc0fce0292b4feac2
--- a/src/prompts/chat/prompt.rs
+++ b/src/prompts/chat/prompt.rs
@@ -60,6 +60,9 @@
     pub(super) on_claude_code: Option<ChatClaudeCodeCallback>,
     // Callback for showing actions dialog (handled by parent)
     pub(super) on_show_actions: Option<ChatShowActionsCallback>,
+    // Callback for running a saved generated script via parent app pipeline
+    pub(super) on_run_script:
+        Option<Arc<dyn Fn(std::path::PathBuf, &mut Context<ChatPrompt>) + Send + Sync>>,
     // Stable UUID for Claude Code CLI session continuity within this prompt's lifetime.
     // Generated once at construction so all messages share the same session.
     pub(super) cli_session_id: String,
@@ -134,6 +137,7 @@
             on_configure: None,
             on_claude_code: None,
             on_show_actions: None,
+            on_run_script: None,
             cli_session_id: uuid::Uuid::new_v4().to_string(),
             pending_image: None,
             pending_image_render: None,
@@ -146,6 +150,15 @@
         self.on_show_actions = Some(callback);
     }
 
+    /// Set the callback for running a generated script path in the parent app.
+    pub fn with_run_script_callback(
+        mut self,
+        callback: impl Fn(std::path::PathBuf, &mut Context<Self>) + Send + Sync + 'static,
+    ) -> Self {
+        self.on_run_script = Some(Arc::new(callback));
+        self
+    }
+
     /// Start the cursor blink timer
     pub fn start_cursor_blink(&mut self, cx: &mut Context<Self>) {
         cx.spawn(async move |this, cx| {
diff --git a/src/prompts/chat/render_core.rs b/src/prompts/chat/render_core.rs
index 4e91d2d0ed474e69c143cd50e58e0491df58450b..7a066a4f6a2e6ac66e5e870f4a926cfbe0c56618
--- a/src/prompts/chat/render_core.rs
+++ b/src/prompts/chat/render_core.rs
@@ -32,10 +32,18 @@
         label: &'static str,
         shortcut: Option<&'static str>,
         action: ScriptGenerationAction,
-        accent_color: u32,
-        muted_color: u32,
+        footer_colors: PromptFooterColors,
         cx: &mut Context<Self>,
     ) -> AnyElement {
+        let button_font_size =
+            crate::components::prompt_footer::footer_button_font_size_px(&self.theme);
+        let hover_bg = rgba(crate::components::prompt_footer::footer_button_hover_rgba(
+            footer_colors,
+        ));
+        let active_bg = rgba(crate::components::prompt_footer::footer_button_active_rgba(
+            footer_colors,
+        ));
+
         div()
             .id(id)
             .flex()
@@ -46,9 +54,21 @@
             .py(px(2.0))
             .rounded(px(4.0))
             .cursor_pointer()
-            .child(div().text_xs().text_color(rgb(accent_color)).child(label))
+            .hover(move |d| d.bg(hover_bg))
+            .active(move |d| d.bg(active_bg))
+            .child(
+                div()
+                    .text_size(px(button_font_size))
+                    .text_color(rgb(footer_colors.accent))
+                    .child(label),
+            )
             .when_some(shortcut, |d, shortcut| {
-                d.child(div().text_xs().text_color(rgb(muted_color)).child(shortcut))
+                d.child(
+                    div()
+                        .text_size(px(button_font_size))
+                        .text_color(rgb(footer_colors.text_muted))
+                        .child(shortcut),
+                )
             })
             .on_click(cx.listener(move |this, _event, _window, cx| {
                 this.handle_script_generation_action(action, cx);
@@ -109,10 +129,9 @@
             self.render_script_generation_footer_button(
                 "chat-footer-primary-button",
                 "Save and Run",
-                None,
+                Some("⌘↵"),
                 ScriptGenerationAction::SaveAndRun,
-                footer_colors.accent,
-                footer_colors.text_muted,
+                footer_colors,
                 cx,
             )
         } else {
@@ -194,8 +213,7 @@
                     "Save",
                     None,
                     ScriptGenerationAction::Save,
-                    footer_colors.accent,
-                    footer_colors.text_muted,
+                    footer_colors,
                     cx,
                 ))
                 .child(self.render_script_generation_footer_button(
@@ -203,8 +221,7 @@
                     "Run",
                     None,
                     ScriptGenerationAction::Run,
-                    footer_colors.accent,
-                    footer_colors.text_muted,
+                    footer_colors,
                     cx,
                 ));
         }
@@ -356,7 +373,13 @@
                     }
                 }
                 ChatInputKeyAction::ToggleActions => this.toggle_actions_menu(cx),
-                ChatInputKeyAction::ContinueInChat => this.handle_continue_in_chat(cx),
+                ChatInputKeyAction::ContinueInChat => {
+                    if this.script_generation_mode {
+                        this.handle_script_generation_action(ScriptGenerationAction::SaveAndRun, cx);
+                    } else {
+                        this.handle_continue_in_chat(cx);
+                    }
+                }
                 ChatInputKeyAction::Submit => this.handle_submit(cx),
                 ChatInputKeyAction::InsertNewline => {
                     this.input.insert_char('\n');
@@ -618,7 +641,9 @@
             "Footer primary action should branch on script_generation_mode"
         );
         assert!(
-            normalized.contains("\"chat-footer-primary-button\",\"SaveandRun\",None,ScriptGenerationAction::SaveAndRun,"),
+            normalized.contains(
+                "\"chat-footer-primary-button\",\"SaveandRun\",Some(\"⌘↵\"),ScriptGenerationAction::SaveAndRun,"
+            ),
             "Script generation mode should render Save and Run as the primary footer action"
         );
         assert!(
@@ -647,4 +672,18 @@
             "Save and Run should only appear as the primary footer action slot"
         );
     }
+
+    #[test]
+    fn test_cmd_enter_runs_save_and_run_when_script_generation_mode_enabled() {
+        let content = fs::read_to_string("src/prompts/chat/render_core.rs")
+            .expect("Failed to read src/prompts/chat/render_core.rs");
+        let normalized: String = content.chars().filter(|c| !c.is_whitespace()).collect();
+
+        assert!(
+            normalized.contains(
+                "ChatInputKeyAction::ContinueInChat=>{ifthis.script_generation_mode{this.handle_script_generation_action(ScriptGenerationAction::SaveAndRun,cx);}else{this.handle_continue_in_chat(cx);}}"
+            ),
+            "Cmd+Enter should trigger SaveAndRun in script generation mode and ContinueInChat otherwise"
+        );
+    }
 }


thinking
**Planning targeted Rust checks**
codex
Edits are complete; I’m running scoped verification now: `cargo check` for this crate plus focused tests around chat footer/shortcut behavior and prompt footer helpers.
exec
/bin/zsh -lc 'cd /Users/johnlindquist/dev/script-kit-gpui && cargo check -p script-kit-gpui' in /Users/johnlindquist/dev/script-kit-gpuifile update:
diff --git a/src/ai/script_generation.rs b/src/ai/script_generation.rs
index f29715b032570028241789219179c413e5c5ed83..a89e4e8d4161e386089b6e3cac57975cd36b3cd0
--- a/src/ai/script_generation.rs
+++ b/src/ai/script_generation.rs
@@ -148,75 +148,6 @@
     Ok(script_path)
 }
 
-pub(crate) fn run_saved_script(path: &Path) -> Result<()> {
-    let script_path = path.to_string_lossy().to_string();
-    let attempts: &[(&str, &[&str])] = &[
-        ("kit", &["run", &script_path]),
-        ("bun", &["run", &script_path]),
-    ];
-
-    let mut failures = Vec::new();
-
-    for &(cmd, args) in attempts {
-        let result = std::process::Command::new(cmd)
-            .args(args)
-            .stderr(std::process::Stdio::piped())
-            .stdout(std::process::Stdio::piped())
-            .spawn();
-
-        match result {
-            Ok(mut child) => {
-                // Wait briefly for quick failures (e.g. bun cache corruption, missing deps).
-                // If still running after the timeout, assume it launched successfully.
-                let timeout = std::time::Duration::from_secs(5);
-                let start = std::time::Instant::now();
-                loop {
-                    match child.try_wait() {
-                        Ok(Some(status)) if !status.success() => {
-                            let stderr_text = child
-                                .stderr
-                                .take()
-                                .map(|mut s| {
-                                    let mut buf = String::new();
-                                    std::io::Read::read_to_string(&mut s, &mut buf).ok();
-                                    buf
-                                })
-                                .unwrap_or_default();
-                            let detail = if stderr_text.trim().is_empty() {
-                                format!("exit {}", status)
-                            } else {
-                                stderr_text.trim().to_string()
-                            };
-                            failures.push(format!("{}: {}", cmd, detail));
-                            break;
-                        }
-                        Ok(Some(_)) => return Ok(()), // exited successfully
-                        Ok(None) => {
-                            if start.elapsed() >= timeout {
-                                return Ok(()); // still running — launched OK
-                            }
-                            std::thread::sleep(std::time::Duration::from_millis(50));
-                        }
-                        Err(error) => {
-                            failures.push(format!("{}: wait failed: {}", cmd, error));
-                            break;
-                        }
-                    }
-                }
-            }
-            Err(error) => {
-                failures.push(format!("{}: {}", cmd, error));
-            }
-        }
-    }
-
-    anyhow::bail!(
-        "Failed to run script (path={}, attempts={})",
-        path.display(),
-        failures.join(" | ")
-    );
-}
-
 fn select_generation_model(
     registry: &ProviderRegistry,
 ) -> Result<(ModelInfo, Arc<dyn AiProvider>)> {
diff --git a/src/app_impl/prompt_ai.rs b/src/app_impl/prompt_ai.rs
index c8266b6cb798ec62e6e7e9a8a59005512e44b72f..6c10ca4234dc2d80bb14bc0d5163caddf97656cc
--- a/src/app_impl/prompt_ai.rs
+++ b/src/app_impl/prompt_ai.rs
@@ -568,6 +568,38 @@
         let noop_callback: ChatSubmitCallback = std::sync::Arc::new(|_id, _text| {
             // Built-in AI mode handles this internally
         });
+        let app_entity = cx.entity().downgrade();
+        let run_script_callback = move |script_path: std::path::PathBuf,
+                                        chat_cx: &mut gpui::Context<ChatPrompt>| {
+            let script_path_string = script_path.to_string_lossy().to_string();
+            let app_entity = app_entity.clone();
+            chat_cx
+                .spawn(async move |_this, cx| {
+                    let _ = cx.update(|cx| {
+                        if let Some(app) = app_entity.upgrade() {
+                            logging::log(
+                                "CHAT_SCRIPT_GEN",
+                                &format!(
+                                    "state=dispatch_run attempted=execute_script_by_path path={}",
+                                    script_path_string
+                                ),
+                            );
+                            app.update(cx, |app, cx| {
+                                app.execute_script_by_path(&script_path_string, cx);
+                            });
+                        } else {
+                            logging::log(
+                                "CHAT_SCRIPT_GEN",
+                                &format!(
+                                    "state=dispatch_run_failed attempted=execute_script_by_path path={} reason=app_entity_unavailable",
+                                    script_path_string
+                                ),
+                            );
+                        }
+                    });
+                })
+                .detach();
+        };
 
         let placeholder = Some("Describe the script you want to generate...".to_string());
 
@@ -584,6 +616,7 @@
         .with_title("Generate Script with AI")
         .with_save_history(false)
         .with_escape_callback(escape_callback)
+        .with_run_script_callback(run_script_callback)
         .with_builtin_ai(registry, true) // true = prefer Vercel AI Gateway
         .with_builtin_system_prompt(crate::ai::script_generation::AI_SCRIPT_GENERATION_SYSTEM_PROMPT)
         .with_script_generation_mode(true);
diff --git a/src/components/prompt_footer.rs b/src/components/prompt_footer.rs
index 6bfa86a1edacaec90dc82185bb178cd09dfb7b61..0ce40c6c9c2ea6aa9f9e7599cb8065ebd2c5318b
--- a/src/components/prompt_footer.rs
+++ b/src/components/prompt_footer.rs
@@ -155,14 +155,19 @@
     )
 }
 
-fn footer_button_hover_rgba(colors: PromptFooterColors) -> u32 {
+pub fn footer_button_hover_rgba(colors: PromptFooterColors) -> u32 {
     (colors.background << 8) | (PROMPT_FOOTER_BUTTON_HOVER_OPACITY as u32)
 }
 
-fn footer_button_active_rgba(colors: PromptFooterColors) -> u32 {
+pub fn footer_button_active_rgba(colors: PromptFooterColors) -> u32 {
     (colors.background << 8) | (PROMPT_FOOTER_BUTTON_ACTIVE_OPACITY as u32)
 }
 
+pub fn footer_button_font_size_px(theme: &Theme) -> f32 {
+    (theme.get_fonts().ui_size - PROMPT_FOOTER_BUTTON_FONT_DELTA_PX)
+        .max(PROMPT_FOOTER_BUTTON_FONT_MIN_PX)
+}
+
 /// Configuration for PromptFooter display
 #[derive(Clone, Debug)]
 pub struct PromptFooterConfig {
@@ -334,8 +339,7 @@
         on_click: Option<Rc<FooterClickCallback>>,
     ) -> impl IntoElement {
         let theme = crate::theme::get_cached_theme();
-        let button_font_size = (theme.get_fonts().ui_size - PROMPT_FOOTER_BUTTON_FONT_DELTA_PX)
-            .max(PROMPT_FOOTER_BUTTON_FONT_MIN_PX);
+        let button_font_size = footer_button_font_size_px(&theme);
         let has_click_handler = on_click.is_some();
         let is_clickable = is_footer_button_clickable(has_click_handler, disabled);
         let on_click_for_key = on_click.clone();
diff --git a/src/prompts/chat/actions.rs b/src/prompts/chat/actions.rs
index 8ae41af43235d867176126f8de45f9fc8f3f2cbf..4d01323e1d134ef8e6f56be60d0a1eee086247e7
--- a/src/prompts/chat/actions.rs
+++ b/src/prompts/chat/actions.rs
@@ -172,48 +172,36 @@
 
         if action.should_run_after_save() {
             self.set_script_generation_status(false, format!("Running {}...", script_name), cx);
-
-            let path_clone = script_path.clone();
-            let name_clone = script_name.clone();
-            cx.spawn(async move |this, cx| {
-                let run_result = std::thread::spawn(move || {
-                    crate::ai::script_generation::run_saved_script(&path_clone)
-                })
-                .join()
-                .map_err(|_| anyhow::anyhow!("run thread panicked"))
-                .and_then(|r| r);
-
-                let _ = cx.update(|cx| {
-                    this.update(cx, |chat, cx| match run_result {
-                        Ok(()) => {
-                            chat.set_script_generation_status(
-                                false,
-                                format!("Saved and running {}", name_clone),
-                                cx,
-                            );
-                            logging::log(
-                                "CHAT_SCRIPT_GEN",
-                                &format!("state=run_ok action={:?} script={}", action, name_clone),
-                            );
-                        }
-                        Err(error) => {
-                            chat.set_script_generation_status(
-                                true,
-                                format!("Saved {} but failed to run: {}", name_clone, error),
-                                cx,
-                            );
-                            logging::log(
-                                "CHAT_SCRIPT_GEN",
-                                &format!(
-                                    "state=run_failed action={:?} script={} error={}",
-                                    action, name_clone, error
-                                ),
-                            );
-                        }
-                    })
-                });
-            })
-            .detach();
+            if let Some(ref callback) = self.on_run_script {
+                callback(script_path.clone(), cx);
+                self.set_script_generation_status(
+                    false,
+                    format!("Saved and running {}", script_name),
+                    cx,
+                );
+                logging::log(
+                    "CHAT_SCRIPT_GEN",
+                    &format!(
+                        "state=run_dispatched action={:?} path={}",
+                        action,
+                        script_path.display()
+                    ),
+                );
+            } else {
+                self.set_script_generation_status(
+                    true,
+                    format!("Saved {} but run action is unavailable", script_name),
+                    cx,
+                );
+                logging::log(
+                    "CHAT_SCRIPT_GEN",
+                    &format!(
+                        "state=run_dispatch_failed action={:?} path={} reason=missing_callback",
+                        action,
+                        script_path.display()
+                    ),
+                );
+            }
             return;
         }
 
diff --git a/src/prompts/chat/prompt.rs b/src/prompts/chat/prompt.rs
index 4ef4ac1aae4123a9bdd9771500998f87f424660b..78a8d8354e9e50914fdbcf1cc0fce0292b4feac2
--- a/src/prompts/chat/prompt.rs
+++ b/src/prompts/chat/prompt.rs
@@ -60,6 +60,9 @@
     pub(super) on_claude_code: Option<ChatClaudeCodeCallback>,
     // Callback for showing actions dialog (handled by parent)
     pub(super) on_show_actions: Option<ChatShowActionsCallback>,
+    // Callback for running a saved generated script via parent app pipeline
+    pub(super) on_run_script:
+        Option<Arc<dyn Fn(std::path::PathBuf, &mut Context<ChatPrompt>) + Send + Sync>>,
     // Stable UUID for Claude Code CLI session continuity within this prompt's lifetime.
     // Generated once at construction so all messages share the same session.
     pub(super) cli_session_id: String,
@@ -134,6 +137,7 @@
             on_configure: None,
             on_claude_code: None,
             on_show_actions: None,
+            on_run_script: None,
             cli_session_id: uuid::Uuid::new_v4().to_string(),
             pending_image: None,
             pending_image_render: None,
@@ -146,6 +150,15 @@
         self.on_show_actions = Some(callback);
     }
 
+    /// Set the callback for running a generated script path in the parent app.
+    pub fn with_run_script_callback(
+        mut self,
+        callback: impl Fn(std::path::PathBuf, &mut Context<Self>) + Send + Sync + 'static,
+    ) -> Self {
+        self.on_run_script = Some(Arc::new(callback));
+        self
+    }
+
     /// Start the cursor blink timer
     pub fn start_cursor_blink(&mut self, cx: &mut Context<Self>) {
         cx.spawn(async move |this, cx| {
diff --git a/src/prompts/chat/render_core.rs b/src/prompts/chat/render_core.rs
index 4e91d2d0ed474e69c143cd50e58e0491df58450b..7a066a4f6a2e6ac66e5e870f4a926cfbe0c56618
--- a/src/prompts/chat/render_core.rs
+++ b/src/prompts/chat/render_core.rs
@@ -32,10 +32,18 @@
         label: &'static str,
         shortcut: Option<&'static str>,
         action: ScriptGenerationAction,
-        accent_color: u32,
-        muted_color: u32,
+        footer_colors: PromptFooterColors,
         cx: &mut Context<Self>,
     ) -> AnyElement {
+        let button_font_size =
+            crate::components::prompt_footer::footer_button_font_size_px(&self.theme);
+        let hover_bg = rgba(crate::components::prompt_footer::footer_button_hover_rgba(
+            footer_colors,
+        ));
+        let active_bg = rgba(crate::components::prompt_footer::footer_button_active_rgba(
+            footer_colors,
+        ));
+
         div()
             .id(id)
             .flex()
@@ -46,9 +54,21 @@
             .py(px(2.0))
             .rounded(px(4.0))
             .cursor_pointer()
-            .child(div().text_xs().text_color(rgb(accent_color)).child(label))
+            .hover(move |d| d.bg(hover_bg))
+            .active(move |d| d.bg(active_bg))
+            .child(
+                div()
+                    .text_size(px(button_font_size))
+                    .text_color(rgb(footer_colors.accent))
+                    .child(label),
+            )
             .when_some(shortcut, |d, shortcut| {
-                d.child(div().text_xs().text_color(rgb(muted_color)).child(shortcut))
+                d.child(
+                    div()
+                        .text_size(px(button_font_size))
+                        .text_color(rgb(footer_colors.text_muted))
+                        .child(shortcut),
+                )
             })
             .on_click(cx.listener(move |this, _event, _window, cx| {
                 this.handle_script_generation_action(action, cx);
@@ -109,10 +129,9 @@
             self.render_script_generation_footer_button(
                 "chat-footer-primary-button",
                 "Save and Run",
-                None,
+                Some("⌘↵"),
                 ScriptGenerationAction::SaveAndRun,
-                footer_colors.accent,
-                footer_colors.text_muted,
+                footer_colors,
                 cx,
             )
         } else {
@@ -194,8 +213,7 @@
                     "Save",
                     None,
                     ScriptGenerationAction::Save,
-                    footer_colors.accent,
-                    footer_colors.text_muted,
+                    footer_colors,
                     cx,
                 ))
                 .child(self.render_script_generation_footer_button(
@@ -203,8 +221,7 @@
                     "Run",
                     None,
                     ScriptGenerationAction::Run,
-                    footer_colors.accent,
-                    footer_colors.text_muted,
+                    footer_colors,
                     cx,
                 ));
         }
@@ -356,7 +373,13 @@
                     }
                 }
                 ChatInputKeyAction::ToggleActions => this.toggle_actions_menu(cx),
-                ChatInputKeyAction::ContinueInChat => this.handle_continue_in_chat(cx),
+                ChatInputKeyAction::ContinueInChat => {
+                    if this.script_generation_mode {
+                        this.handle_script_generation_action(ScriptGenerationAction::SaveAndRun, cx);
+                    } else {
+                        this.handle_continue_in_chat(cx);
+                    }
+                }
                 ChatInputKeyAction::Submit => this.handle_submit(cx),
                 ChatInputKeyAction::InsertNewline => {
                     this.input.insert_char('\n');
@@ -618,7 +641,9 @@
             "Footer primary action should branch on script_generation_mode"
         );
         assert!(
-            normalized.contains("\"chat-footer-primary-button\",\"SaveandRun\",None,ScriptGenerationAction::SaveAndRun,"),
+            normalized.contains(
+                "\"chat-footer-primary-button\",\"SaveandRun\",Some(\"⌘↵\"),ScriptGenerationAction::SaveAndRun,"
+            ),
             "Script generation mode should render Save and Run as the primary footer action"
         );
         assert!(
@@ -647,4 +672,18 @@
             "Save and Run should only appear as the primary footer action slot"
         );
     }
+
+    #[test]
+    fn test_cmd_enter_runs_save_and_run_when_script_generation_mode_enabled() {
+        let content = fs::read_to_string("src/prompts/chat/render_core.rs")
+            .expect("Failed to read src/prompts/chat/render_core.rs");
+        let normalized: String = content.chars().filter(|c| !c.is_whitespace()).collect();
+
+        assert!(
+            normalized.contains(
+                "ChatInputKeyAction::ContinueInChat=>{ifthis.script_generation_mode{this.handle_script_generation_action(ScriptGenerationAction::SaveAndRun,cx);}else{this.handle_continue_in_chat(cx);}}"
+            ),
+            "Cmd+Enter should trigger SaveAndRun in script generation mode and ContinueInChat otherwise"
+        );
+    }
 }


thinking
**Monitoring command execution**
file update:
diff --git a/src/ai/script_generation.rs b/src/ai/script_generation.rs
index f29715b032570028241789219179c413e5c5ed83..a89e4e8d4161e386089b6e3cac57975cd36b3cd0
--- a/src/ai/script_generation.rs
+++ b/src/ai/script_generation.rs
@@ -148,75 +148,6 @@
     Ok(script_path)
 }
 
-pub(crate) fn run_saved_script(path: &Path) -> Result<()> {
-    let script_path = path.to_string_lossy().to_string();
-    let attempts: &[(&str, &[&str])] = &[
-        ("kit", &["run", &script_path]),
-        ("bun", &["run", &script_path]),
-    ];
-
-    let mut failures = Vec::new();
-
-    for &(cmd, args) in attempts {
-        let result = std::process::Command::new(cmd)
-            .args(args)
-            .stderr(std::process::Stdio::piped())
-            .stdout(std::process::Stdio::piped())
-            .spawn();
-
-        match result {
-            Ok(mut child) => {
-                // Wait briefly for quick failures (e.g. bun cache corruption, missing deps).
-                // If still running after the timeout, assume it launched successfully.
-                let timeout = std::time::Duration::from_secs(5);
-                let start = std::time::Instant::now();
-                loop {
-                    match child.try_wait() {
-                        Ok(Some(status)) if !status.success() => {
-                            let stderr_text = child
-                                .stderr
-                                .take()
-                                .map(|mut s| {
-                                    let mut buf = String::new();
-                                    std::io::Read::read_to_string(&mut s, &mut buf).ok();
-                                    buf
-                                })
-                                .unwrap_or_default();
-                            let detail = if stderr_text.trim().is_empty() {
-                                format!("exit {}", status)
-                            } else {
-                                stderr_text.trim().to_string()
-                            };
-                            failures.push(format!("{}: {}", cmd, detail));
-                            break;
-                        }
-                        Ok(Some(_)) => return Ok(()), // exited successfully
-                        Ok(None) => {
-                            if start.elapsed() >= timeout {
-                                return Ok(()); // still running — launched OK
-                            }
-                            std::thread::sleep(std::time::Duration::from_millis(50));
-                        }
-                        Err(error) => {
-                            failures.push(format!("{}: wait failed: {}", cmd, error));
-                            break;
-                        }
-                    }
-                }
-            }
-            Err(error) => {
-                failures.push(format!("{}: {}", cmd, error));
-            }
-        }
-    }
-
-    anyhow::bail!(
-        "Failed to run script (path={}, attempts={})",
-        path.display(),
-        failures.join(" | ")
-    );
-}
-
 fn select_generation_model(
     registry: &ProviderRegistry,
 ) -> Result<(ModelInfo, Arc<dyn AiProvider>)> {
diff --git a/src/app_impl/prompt_ai.rs b/src/app_impl/prompt_ai.rs
index c8266b6cb798ec62e6e7e9a8a59005512e44b72f..6c10ca4234dc2d80bb14bc0d5163caddf97656cc
--- a/src/app_impl/prompt_ai.rs
+++ b/src/app_impl/prompt_ai.rs
@@ -568,6 +568,38 @@
         let noop_callback: ChatSubmitCallback = std::sync::Arc::new(|_id, _text| {
             // Built-in AI mode handles this internally
         });
+        let app_entity = cx.entity().downgrade();
+        let run_script_callback = move |script_path: std::path::PathBuf,
+                                        chat_cx: &mut gpui::Context<ChatPrompt>| {
+            let script_path_string = script_path.to_string_lossy().to_string();
+            let app_entity = app_entity.clone();
+            chat_cx
+                .spawn(async move |_this, cx| {
+                    let _ = cx.update(|cx| {
+                        if let Some(app) = app_entity.upgrade() {
+                            logging::log(
+                                "CHAT_SCRIPT_GEN",
+                                &format!(
+                                    "state=dispatch_run attempted=execute_script_by_path path={}",
+                                    script_path_string
+                                ),
+                            );
+                            app.update(cx, |app, cx| {
+                                app.execute_script_by_path(&script_path_string, cx);
+                            });
+                        } else {
+                            logging::log(
+                                "CHAT_SCRIPT_GEN",
+                                &format!(
+                                    "state=dispatch_run_failed attempted=execute_script_by_path path={} reason=app_entity_unavailable",
+                                    script_path_string
+                                ),
+                            );
+                        }
+                    });
+                })
+                .detach();
+        };
 
         let placeholder = Some("Describe the script you want to generate...".to_string());
 
@@ -584,6 +616,7 @@
         .with_title("Generate Script with AI")
         .with_save_history(false)
         .with_escape_callback(escape_callback)
+        .with_run_script_callback(run_script_callback)
         .with_builtin_ai(registry, true) // true = prefer Vercel AI Gateway
         .with_builtin_system_prompt(crate::ai::script_generation::AI_SCRIPT_GENERATION_SYSTEM_PROMPT)
         .with_script_generation_mode(true);
diff --git a/src/components/prompt_footer.rs b/src/components/prompt_footer.rs
index 6bfa86a1edacaec90dc82185bb178cd09dfb7b61..0ce40c6c9c2ea6aa9f9e7599cb8065ebd2c5318b
--- a/src/components/prompt_footer.rs
+++ b/src/components/prompt_footer.rs
@@ -155,14 +155,19 @@
     )
 }
 
-fn footer_button_hover_rgba(colors: PromptFooterColors) -> u32 {
+pub fn footer_button_hover_rgba(colors: PromptFooterColors) -> u32 {
     (colors.background << 8) | (PROMPT_FOOTER_BUTTON_HOVER_OPACITY as u32)
 }
 
-fn footer_button_active_rgba(colors: PromptFooterColors) -> u32 {
+pub fn footer_button_active_rgba(colors: PromptFooterColors) -> u32 {
     (colors.background << 8) | (PROMPT_FOOTER_BUTTON_ACTIVE_OPACITY as u32)
 }
 
+pub fn footer_button_font_size_px(theme: &Theme) -> f32 {
+    (theme.get_fonts().ui_size - PROMPT_FOOTER_BUTTON_FONT_DELTA_PX)
+        .max(PROMPT_FOOTER_BUTTON_FONT_MIN_PX)
+}
+
 /// Configuration for PromptFooter display
 #[derive(Clone, Debug)]
 pub struct PromptFooterConfig {
@@ -334,8 +339,7 @@
         on_click: Option<Rc<FooterClickCallback>>,
     ) -> impl IntoElement {
         let theme = crate::theme::get_cached_theme();
-        let button_font_size = (theme.get_fonts().ui_size - PROMPT_FOOTER_BUTTON_FONT_DELTA_PX)
-            .max(PROMPT_FOOTER_BUTTON_FONT_MIN_PX);
+        let button_font_size = footer_button_font_size_px(&theme);
         let has_click_handler = on_click.is_some();
         let is_clickable = is_footer_button_clickable(has_click_handler, disabled);
         let on_click_for_key = on_click.clone();
diff --git a/src/prompts/chat/actions.rs b/src/prompts/chat/actions.rs
index 8ae41af43235d867176126f8de45f9fc8f3f2cbf..4d01323e1d134ef8e6f56be60d0a1eee086247e7
--- a/src/prompts/chat/actions.rs
+++ b/src/prompts/chat/actions.rs
@@ -172,48 +172,36 @@
 
         if action.should_run_after_save() {
             self.set_script_generation_status(false, format!("Running {}...", script_name), cx);
-
-            let path_clone = script_path.clone();
-            let name_clone = script_name.clone();
-            cx.spawn(async move |this, cx| {
-                let run_result = std::thread::spawn(move || {
-                    crate::ai::script_generation::run_saved_script(&path_clone)
-                })
-                .join()
-                .map_err(|_| anyhow::anyhow!("run thread panicked"))
-                .and_then(|r| r);
-
-                let _ = cx.update(|cx| {
-                    this.update(cx, |chat, cx| match run_result {
-                        Ok(()) => {
-                            chat.set_script_generation_status(
-                                false,
-                                format!("Saved and running {}", name_clone),
-                                cx,
-                            );
-                            logging::log(
-                                "CHAT_SCRIPT_GEN",
-                                &format!("state=run_ok action={:?} script={}", action, name_clone),
-                            );
-                        }
-                        Err(error) => {
-                            chat.set_script_generation_status(
-                                true,
-                                format!("Saved {} but failed to run: {}", name_clone, error),
-                                cx,
-                            );
-                            logging::log(
-                                "CHAT_SCRIPT_GEN",
-                                &format!(
-                                    "state=run_failed action={:?} script={} error={}",
-                                    action, name_clone, error
-                                ),
-                            );
-                        }
-                    })
-                });
-            })
-            .detach();
+            if let Some(ref callback) = self.on_run_script {
+                callback(script_path.clone(), cx);
+                self.set_script_generation_status(
+                    false,
+                    format!("Saved and running {}", script_name),
+                    cx,
+                );
+                logging::log(
+                    "CHAT_SCRIPT_GEN",
+                    &format!(
+                        "state=run_dispatched action={:?} path={}",
+                        action,
+                        script_path.display()
+                    ),
+                );
+            } else {
+                self.set_script_generation_status(
+                    true,
+                    format!("Saved {} but run action is unavailable", script_name),
+                    cx,
+                );
+                logging::log(
+                    "CHAT_SCRIPT_GEN",
+                    &format!(
+                        "state=run_dispatch_failed action={:?} path={} reason=missing_callback",
+                        action,
+                        script_path.display()
+                    ),
+                );
+            }
             return;
         }
 
diff --git a/src/prompts/chat/prompt.rs b/src/prompts/chat/prompt.rs
index 4ef4ac1aae4123a9bdd9771500998f87f424660b..78a8d8354e9e50914fdbcf1cc0fce0292b4feac2
--- a/src/prompts/chat/prompt.rs
+++ b/src/prompts/chat/prompt.rs
@@ -60,6 +60,9 @@
     pub(super) on_claude_code: Option<ChatClaudeCodeCallback>,
     // Callback for showing actions dialog (handled by parent)
     pub(super) on_show_actions: Option<ChatShowActionsCallback>,
+    // Callback for running a saved generated script via parent app pipeline
+    pub(super) on_run_script:
+        Option<Arc<dyn Fn(std::path::PathBuf, &mut Context<ChatPrompt>) + Send + Sync>>,
     // Stable UUID for Claude Code CLI session continuity within this prompt's lifetime.
     // Generated once at construction so all messages share the same session.
     pub(super) cli_session_id: String,
@@ -134,6 +137,7 @@
             on_configure: None,
             on_claude_code: None,
             on_show_actions: None,
+            on_run_script: None,
             cli_session_id: uuid::Uuid::new_v4().to_string(),
             pending_image: None,
             pending_image_render: None,
@@ -146,6 +150,15 @@
         self.on_show_actions = Some(callback);
     }
 
+    /// Set the callback for running a generated script path in the parent app.
+    pub fn with_run_script_callback(
+        mut self,
+        callback: impl Fn(std::path::PathBuf, &mut Context<Self>) + Send + Sync + 'static,
+    ) -> Self {
+        self.on_run_script = Some(Arc::new(callback));
+        self
+    }
+
     /// Start the cursor blink timer
     pub fn start_cursor_blink(&mut self, cx: &mut Context<Self>) {
         cx.spawn(async move |this, cx| {
diff --git a/src/prompts/chat/render_core.rs b/src/prompts/chat/render_core.rs
index 4e91d2d0ed474e69c143cd50e58e0491df58450b..7a066a4f6a2e6ac66e5e870f4a926cfbe0c56618
--- a/src/prompts/chat/render_core.rs
+++ b/src/prompts/chat/render_core.rs
@@ -32,10 +32,18 @@
         label: &'static str,
         shortcut: Option<&'static str>,
         action: ScriptGenerationAction,
-        accent_color: u32,
-        muted_color: u32,
+        footer_colors: PromptFooterColors,
         cx: &mut Context<Self>,
     ) -> AnyElement {
+        let button_font_size =
+            crate::components::prompt_footer::footer_button_font_size_px(&self.theme);
+        let hover_bg = rgba(crate::components::prompt_footer::footer_button_hover_rgba(
+            footer_colors,
+        ));
+        let active_bg = rgba(crate::components::prompt_footer::footer_button_active_rgba(
+            footer_colors,
+        ));
+
         div()
             .id(id)
             .flex()
@@ -46,9 +54,21 @@
             .py(px(2.0))
             .rounded(px(4.0))
             .cursor_pointer()
-            .child(div().text_xs().text_color(rgb(accent_color)).child(label))
+            .hover(move |d| d.bg(hover_bg))
+            .active(move |d| d.bg(active_bg))
+            .child(
+                div()
+                    .text_size(px(button_font_size))
+                    .text_color(rgb(footer_colors.accent))
+                    .child(label),
+            )
             .when_some(shortcut, |d, shortcut| {
-                d.child(div().text_xs().text_color(rgb(muted_color)).child(shortcut))
+                d.child(
+                    div()
+                        .text_size(px(button_font_size))
+                        .text_color(rgb(footer_colors.text_muted))
+                        .child(shortcut),
+                )
             })
             .on_click(cx.listener(move |this, _event, _window, cx| {
                 this.handle_script_generation_action(action, cx);
@@ -109,10 +129,9 @@
             self.render_script_generation_footer_button(
                 "chat-footer-primary-button",
                 "Save and Run",
-                None,
+                Some("⌘↵"),
                 ScriptGenerationAction::SaveAndRun,
-                footer_colors.accent,
-                footer_colors.text_muted,
+                footer_colors,
                 cx,
             )
         } else {
@@ -194,8 +213,7 @@
                     "Save",
                     None,
                     ScriptGenerationAction::Save,
-                    footer_colors.accent,
-                    footer_colors.text_muted,
+                    footer_colors,
                     cx,
                 ))
                 .child(self.render_script_generation_footer_button(
@@ -203,8 +221,7 @@
                     "Run",
                     None,
                     ScriptGenerationAction::Run,
-                    footer_colors.accent,
-                    footer_colors.text_muted,
+                    footer_colors,
                     cx,
                 ));
         }
@@ -356,7 +373,13 @@
                     }
                 }
                 ChatInputKeyAction::ToggleActions => this.toggle_actions_menu(cx),
-                ChatInputKeyAction::ContinueInChat => this.handle_continue_in_chat(cx),
+                ChatInputKeyAction::ContinueInChat => {
+                    if this.script_generation_mode {
+                        this.handle_script_generation_action(ScriptGenerationAction::SaveAndRun, cx);
+                    } else {
+                        this.handle_continue_in_chat(cx);
+                    }
+                }
                 ChatInputKeyAction::Submit => this.handle_submit(cx),
                 ChatInputKeyAction::InsertNewline => {
                     this.input.insert_char('\n');
@@ -618,7 +641,9 @@
             "Footer primary action should branch on script_generation_mode"
         );
         assert!(
-            normalized.contains("\"chat-footer-primary-button\",\"SaveandRun\",None,ScriptGenerationAction::SaveAndRun,"),
+            normalized.contains(
+                "\"chat-footer-primary-button\",\"SaveandRun\",Some(\"⌘↵\"),ScriptGenerationAction::SaveAndRun,"
+            ),
             "Script generation mode should render Save and Run as the primary footer action"
         );
         assert!(
@@ -647,4 +672,18 @@
             "Save and Run should only appear as the primary footer action slot"
         );
     }
+
+    #[test]
+    fn test_cmd_enter_runs_save_and_run_when_script_generation_mode_enabled() {
+        let content = fs::read_to_string("src/prompts/chat/render_core.rs")
+            .expect("Failed to read src/prompts/chat/render_core.rs");
+        let normalized: String = content.chars().filter(|c| !c.is_whitespace()).collect();
+
+        assert!(
+            normalized.contains(
+                "ChatInputKeyAction::ContinueInChat=>{ifthis.script_generation_mode{this.handle_script_generation_action(ScriptGenerationAction::SaveAndRun,cx);}else{this.handle_continue_in_chat(cx);}}"
+            ),
+            "Cmd+Enter should trigger SaveAndRun in script generation mode and ContinueInChat otherwise"
+        );
+    }
 }

 succeeded in 7.76s:
    Checking script-kit-gpui v0.1.0 (/Users/johnlindquist/dev/script-kit-gpui)
warning: glob import doesn't reexport anything with visibility `pub(in crate::prompts)` because no imported item is public enough
  --> src/prompts/div/mod.rs:32:16
   |
32 | pub(super) use inline::*;
   |                ^^^^^^^^^
   |
note: the most public imported item is `pub(self)`
  --> src/prompts/div/mod.rs:32:16
   |
32 | pub(super) use inline::*;
   |                ^^^^^^^^^
   = help: reduce the glob import's visibility or increase visibility of imported items
   = note: `#[warn(unused_imports)]` (part of `#[warn(unused)]`) on by default

warning: glob import doesn't reexport anything with visibility `pub(in crate::prompts)` because no imported item is public enough
  --> src/prompts/div/mod.rs:34:16
   |
34 | pub(super) use render_html::*;
   |                ^^^^^^^^^^^^^^

thinking
**Planning targeted test runs**
exec
/bin/zsh -lc 'cd /Users/johnlindquist/dev/script-kit-gpui && cargo test -p script-kit-gpui test_cmd_enter_runs_save_and_run_when_script_generation_mode_enabled -- --nocapture' in /Users/johnlindquist/dev/script-kit-gpuifile update:
diff --git a/src/ai/script_generation.rs b/src/ai/script_generation.rs
index f29715b032570028241789219179c413e5c5ed83..a89e4e8d4161e386089b6e3cac57975cd36b3cd0
--- a/src/ai/script_generation.rs
+++ b/src/ai/script_generation.rs
@@ -148,75 +148,6 @@
     Ok(script_path)
 }
 
-pub(crate) fn run_saved_script(path: &Path) -> Result<()> {
-    let script_path = path.to_string_lossy().to_string();
-    let attempts: &[(&str, &[&str])] = &[
-        ("kit", &["run", &script_path]),
-        ("bun", &["run", &script_path]),
-    ];
-
-    let mut failures = Vec::new();
-
-    for &(cmd, args) in attempts {
-        let result = std::process::Command::new(cmd)
-            .args(args)
-            .stderr(std::process::Stdio::piped())
-            .stdout(std::process::Stdio::piped())
-            .spawn();
-
-        match result {
-            Ok(mut child) => {
-                // Wait briefly for quick failures (e.g. bun cache corruption, missing deps).
-                // If still running after the timeout, assume it launched successfully.
-                let timeout = std::time::Duration::from_secs(5);
-                let start = std::time::Instant::now();
-                loop {
-                    match child.try_wait() {
-                        Ok(Some(status)) if !status.success() => {
-                            let stderr_text = child
-                                .stderr
-                                .take()
-                                .map(|mut s| {
-                                    let mut buf = String::new();
-                                    std::io::Read::read_to_string(&mut s, &mut buf).ok();
-                                    buf
-                                })
-                                .unwrap_or_default();
-                            let detail = if stderr_text.trim().is_empty() {
-                                format!("exit {}", status)
-                            } else {
-                                stderr_text.trim().to_string()
-                            };
-                            failures.push(format!("{}: {}", cmd, detail));
-                            break;
-                        }
-                        Ok(Some(_)) => return Ok(()), // exited successfully
-                        Ok(None) => {
-                            if start.elapsed() >= timeout {
-                                return Ok(()); // still running — launched OK
-                            }
-                            std::thread::sleep(std::time::Duration::from_millis(50));
-                        }
-                        Err(error) => {
-                            failures.push(format!("{}: wait failed: {}", cmd, error));
-                            break;
-                        }
-                    }
-                }
-            }
-            Err(error) => {
-                failures.push(format!("{}: {}", cmd, error));
-            }
-        }
-    }
-
-    anyhow::bail!(
-        "Failed to run script (path={}, attempts={})",
-        path.display(),
-        failures.join(" | ")
-    );
-}
-
 fn select_generation_model(
     registry: &ProviderRegistry,
 ) -> Result<(ModelInfo, Arc<dyn AiProvider>)> {
diff --git a/src/app_impl/prompt_ai.rs b/src/app_impl/prompt_ai.rs
index c8266b6cb798ec62e6e7e9a8a59005512e44b72f..6c10ca4234dc2d80bb14bc0d5163caddf97656cc
--- a/src/app_impl/prompt_ai.rs
+++ b/src/app_impl/prompt_ai.rs
@@ -568,6 +568,38 @@
         let noop_callback: ChatSubmitCallback = std::sync::Arc::new(|_id, _text| {
             // Built-in AI mode handles this internally
         });
+        let app_entity = cx.entity().downgrade();
+        let run_script_callback = move |script_path: std::path::PathBuf,
+                                        chat_cx: &mut gpui::Context<ChatPrompt>| {
+            let script_path_string = script_path.to_string_lossy().to_string();
+            let app_entity = app_entity.clone();
+            chat_cx
+                .spawn(async move |_this, cx| {
+                    let _ = cx.update(|cx| {
+                        if let Some(app) = app_entity.upgrade() {
+                            logging::log(
+                                "CHAT_SCRIPT_GEN",
+                                &format!(
+                                    "state=dispatch_run attempted=execute_script_by_path path={}",
+                                    script_path_string
+                                ),
+                            );
+                            app.update(cx, |app, cx| {
+                                app.execute_script_by_path(&script_path_string, cx);
+                            });
+                        } else {
+                            logging::log(
+                                "CHAT_SCRIPT_GEN",
+                                &format!(
+                                    "state=dispatch_run_failed attempted=execute_script_by_path path={} reason=app_entity_unavailable",
+                                    script_path_string
+                                ),
+                            );
+                        }
+                    });
+                })
+                .detach();
+        };
 
         let placeholder = Some("Describe the script you want to generate...".to_string());
 
@@ -584,6 +616,7 @@
         .with_title("Generate Script with AI")
         .with_save_history(false)
         .with_escape_callback(escape_callback)
+        .with_run_script_callback(run_script_callback)
         .with_builtin_ai(registry, true) // true = prefer Vercel AI Gateway
         .with_builtin_system_prompt(crate::ai::script_generation::AI_SCRIPT_GENERATION_SYSTEM_PROMPT)
         .with_script_generation_mode(true);
diff --git a/src/components/prompt_footer.rs b/src/components/prompt_footer.rs
index 6bfa86a1edacaec90dc82185bb178cd09dfb7b61..0ce40c6c9c2ea6aa9f9e7599cb8065ebd2c5318b
--- a/src/components/prompt_footer.rs
+++ b/src/components/prompt_footer.rs
@@ -155,14 +155,19 @@
     )
 }
 
-fn footer_button_hover_rgba(colors: PromptFooterColors) -> u32 {
+pub fn footer_button_hover_rgba(colors: PromptFooterColors) -> u32 {
     (colors.background << 8) | (PROMPT_FOOTER_BUTTON_HOVER_OPACITY as u32)
 }
 
-fn footer_button_active_rgba(colors: PromptFooterColors) -> u32 {
+pub fn footer_button_active_rgba(colors: PromptFooterColors) -> u32 {
     (colors.background << 8) | (PROMPT_FOOTER_BUTTON_ACTIVE_OPACITY as u32)
 }
 
+pub fn footer_button_font_size_px(theme: &Theme) -> f32 {
+    (theme.get_fonts().ui_size - PROMPT_FOOTER_BUTTON_FONT_DELTA_PX)
+        .max(PROMPT_FOOTER_BUTTON_FONT_MIN_PX)
+}
+
 /// Configuration for PromptFooter display
 #[derive(Clone, Debug)]
 pub struct PromptFooterConfig {
@@ -334,8 +339,7 @@
         on_click: Option<Rc<FooterClickCallback>>,
     ) -> impl IntoElement {
         let theme = crate::theme::get_cached_theme();
-        let button_font_size = (theme.get_fonts().ui_size - PROMPT_FOOTER_BUTTON_FONT_DELTA_PX)
-            .max(PROMPT_FOOTER_BUTTON_FONT_MIN_PX);
+        let button_font_size = footer_button_font_size_px(&theme);
         let has_click_handler = on_click.is_some();
         let is_clickable = is_footer_button_clickable(has_click_handler, disabled);
         let on_click_for_key = on_click.clone();
diff --git a/src/prompts/chat/actions.rs b/src/prompts/chat/actions.rs
index 8ae41af43235d867176126f8de45f9fc8f3f2cbf..4d01323e1d134ef8e6f56be60d0a1eee086247e7
--- a/src/prompts/chat/actions.rs
+++ b/src/prompts/chat/actions.rs
@@ -172,48 +172,36 @@
 
         if action.should_run_after_save() {
             self.set_script_generation_status(false, format!("Running {}...", script_name), cx);
-
-            let path_clone = script_path.clone();
-            let name_clone = script_name.clone();
-            cx.spawn(async move |this, cx| {
-                let run_result = std::thread::spawn(move || {
-                    crate::ai::script_generation::run_saved_script(&path_clone)
-                })
-                .join()
-                .map_err(|_| anyhow::anyhow!("run thread panicked"))
-                .and_then(|r| r);
-
-                let _ = cx.update(|cx| {
-                    this.update(cx, |chat, cx| match run_result {
-                        Ok(()) => {
-                            chat.set_script_generation_status(
-                                false,
-                                format!("Saved and running {}", name_clone),
-                                cx,
-                            );
-                            logging::log(
-                                "CHAT_SCRIPT_GEN",
-                                &format!("state=run_ok action={:?} script={}", action, name_clone),
-                            );
-                        }
-                        Err(error) => {
-                            chat.set_script_generation_status(
-                                true,
-                                format!("Saved {} but failed to run: {}", name_clone, error),
-                                cx,
-                            );
-                            logging::log(
-                                "CHAT_SCRIPT_GEN",
-                                &format!(
-                                    "state=run_failed action={:?} script={} error={}",
-                                    action, name_clone, error
-                                ),
-                            );
-                        }
-                    })
-                });
-            })
-            .detach();
+            if let Some(ref callback) = self.on_run_script {
+                callback(script_path.clone(), cx);
+                self.set_script_generation_status(
+                    false,
+                    format!("Saved and running {}", script_name),
+                    cx,
+                );
+                logging::log(
+                    "CHAT_SCRIPT_GEN",
+                    &format!(
+                        "state=run_dispatched action={:?} path={}",
+                        action,
+                        script_path.display()
+                    ),
+                );
+            } else {
+                self.set_script_generation_status(
+                    true,
+                    format!("Saved {} but run action is unavailable", script_name),
+                    cx,
+                );
+                logging::log(
+                    "CHAT_SCRIPT_GEN",
+                    &format!(
+                        "state=run_dispatch_failed action={:?} path={} reason=missing_callback",
+                        action,
+                        script_path.display()
+                    ),
+                );
+            }
             return;
         }
 
diff --git a/src/prompts/chat/prompt.rs b/src/prompts/chat/prompt.rs
index 4ef4ac1aae4123a9bdd9771500998f87f424660b..78a8d8354e9e50914fdbcf1cc0fce0292b4feac2
--- a/src/prompts/chat/prompt.rs
+++ b/src/prompts/chat/prompt.rs
@@ -60,6 +60,9 @@
     pub(super) on_claude_code: Option<ChatClaudeCodeCallback>,
     // Callback for showing actions dialog (handled by parent)
     pub(super) on_show_actions: Option<ChatShowActionsCallback>,
+    // Callback for running a saved generated script via parent app pipeline
+    pub(super) on_run_script:
+        Option<Arc<dyn Fn(std::path::PathBuf, &mut Context<ChatPrompt>) + Send + Sync>>,
     // Stable UUID for Claude Code CLI session continuity within this prompt's lifetime.
     // Generated once at construction so all messages share the same session.
     pub(super) cli_session_id: String,
@@ -134,6 +137,7 @@
             on_configure: None,
             on_claude_code: None,
             on_show_actions: None,
+            on_run_script: None,
             cli_session_id: uuid::Uuid::new_v4().to_string(),
             pending_image: None,
             pending_image_render: None,
@@ -146,6 +150,15 @@
         self.on_show_actions = Some(callback);
     }
 
+    /// Set the callback for running a generated script path in the parent app.
+    pub fn with_run_script_callback(
+        mut self,
+        callback: impl Fn(std::path::PathBuf, &mut Context<Self>) + Send + Sync + 'static,
+    ) -> Self {
+        self.on_run_script = Some(Arc::new(callback));
+        self
+    }
+
     /// Start the cursor blink timer
     pub fn start_cursor_blink(&mut self, cx: &mut Context<Self>) {
         cx.spawn(async move |this, cx| {
diff --git a/src/prompts/chat/render_core.rs b/src/prompts/chat/render_core.rs
index 4e91d2d0ed474e69c143cd50e58e0491df58450b..7a066a4f6a2e6ac66e5e870f4a926cfbe0c56618
--- a/src/prompts/chat/render_core.rs
+++ b/src/prompts/chat/render_core.rs
@@ -32,10 +32,18 @@
         label: &'static str,
         shortcut: Option<&'static str>,
         action: ScriptGenerationAction,
-        accent_color: u32,
-        muted_color: u32,
+        footer_colors: PromptFooterColors,
         cx: &mut Context<Self>,
     ) -> AnyElement {
+        let button_font_size =
+            crate::components::prompt_footer::footer_button_font_size_px(&self.theme);
+        let hover_bg = rgba(crate::components::prompt_footer::footer_button_hover_rgba(
+            footer_colors,
+        ));
+        let active_bg = rgba(crate::components::prompt_footer::footer_button_active_rgba(
+            footer_colors,
+        ));
+
         div()
             .id(id)
             .flex()
@@ -46,9 +54,21 @@
             .py(px(2.0))
             .rounded(px(4.0))
             .cursor_pointer()
-            .child(div().text_xs().text_color(rgb(accent_color)).child(label))
+            .hover(move |d| d.bg(hover_bg))
+            .active(move |d| d.bg(active_bg))
+            .child(
+                div()
+                    .text_size(px(button_font_size))
+                    .text_color(rgb(footer_colors.accent))
+                    .child(label),
+            )
             .when_some(shortcut, |d, shortcut| {
-                d.child(div().text_xs().text_color(rgb(muted_color)).child(shortcut))
+                d.child(
+                    div()
+                        .text_size(px(button_font_size))
+                        .text_color(rgb(footer_colors.text_muted))
+                        .child(shortcut),
+                )
             })
             .on_click(cx.listener(move |this, _event, _window, cx| {
                 this.handle_script_generation_action(action, cx);
@@ -109,10 +129,9 @@
             self.render_script_generation_footer_button(
                 "chat-footer-primary-button",
                 "Save and Run",
-                None,
+                Some("⌘↵"),
                 ScriptGenerationAction::SaveAndRun,
-                footer_colors.accent,
-                footer_colors.text_muted,
+                footer_colors,
                 cx,
             )
         } else {
@@ -194,8 +213,7 @@
                     "Save",
                     None,
                     ScriptGenerationAction::Save,
-                    footer_colors.accent,
-                    footer_colors.text_muted,
+                    footer_colors,
                     cx,
                 ))
                 .child(self.render_script_generation_footer_button(
@@ -203,8 +221,7 @@
                     "Run",
                     None,
                     ScriptGenerationAction::Run,
-                    footer_colors.accent,
-                    footer_colors.text_muted,
+                    footer_colors,
                     cx,
                 ));
         }
@@ -356,7 +373,13 @@
                     }
                 }
                 ChatInputKeyAction::ToggleActions => this.toggle_actions_menu(cx),
-                ChatInputKeyAction::ContinueInChat => this.handle_continue_in_chat(cx),
+                ChatInputKeyAction::ContinueInChat => {
+                    if this.script_generation_mode {
+                        this.handle_script_generation_action(ScriptGenerationAction::SaveAndRun, cx);
+                    } else {
+                        this.handle_continue_in_chat(cx);
+                    }
+                }
                 ChatInputKeyAction::Submit => this.handle_submit(cx),
                 ChatInputKeyAction::InsertNewline => {
                     this.input.insert_char('\n');
@@ -618,7 +641,9 @@
             "Footer primary action should branch on script_generation_mode"
         );
         assert!(
-            normalized.contains("\"chat-footer-primary-button\",\"SaveandRun\",None,ScriptGenerationAction::SaveAndRun,"),
+            normalized.contains(
+                "\"chat-footer-primary-button\",\"SaveandRun\",Some(\"⌘↵\"),ScriptGenerationAction::SaveAndRun,"
+            ),
             "Script generation mode should render Save and Run as the primary footer action"
         );
         assert!(
@@ -647,4 +672,18 @@
             "Save and Run should only appear as the primary footer action slot"
         );
     }
+
+    #[test]
+    fn test_cmd_enter_runs_save_and_run_when_script_generation_mode_enabled() {
+        let content = fs::read_to_string("src/prompts/chat/render_core.rs")
+            .expect("Failed to read src/prompts/chat/render_core.rs");
+        let normalized: String = content.chars().filter(|c| !c.is_whitespace()).collect();
+
+        assert!(
+            normalized.contains(
+                "ChatInputKeyAction::ContinueInChat=>{ifthis.script_generation_mode{this.handle_script_generation_action(ScriptGenerationAction::SaveAndRun,cx);}else{this.handle_continue_in_chat(cx);}}"
+            ),
+            "Cmd+Enter should trigger SaveAndRun in script generation mode and ContinueInChat otherwise"
+        );
+    }
 }

 exited 101 in 19.25s:
   Compiling script-kit-gpui v0.1.0 (/Users/johnlindquist/dev/script-kit-gpui)
error[E0761]: file for module `tests` found at both "src/protocol/message/tests.rs" and "src/protocol/message/tests/mod.rs"
  --> src/protocol/message/mod.rs:87:1
   |
87 | mod tests;
   | ^^^^^^^^^^
   |
   = help: delete or rename one of them to remove the ambiguity

error[E0761]: file for module `tests` found at both "src/designs/core/tests.rs" and "src/designs/core/tests/mod.rs"
 --> src/designs/core/part_04.rs:2:1
  |
2 | mod tests;
  | ^^^^^^^^^^
  |
  = help: delete or rename one of them to remove the ambiguity

warning: glob import doesn't reexport anything with visibility `pub(in crate::prompts)` because no imported item is public enough
  --> src/prompts/div/mod.rs:32:16
   |

thinking
**Analyzing commit risks from unrelated changes**
exec
/bin/zsh -lc 'cd /Users/johnlindquist/dev/script-kit-gpui && git status --short' in /Users/johnlindquist/dev/script-kit-gpui succeeded in 51ms:
 M .ai/logs/codex-audit-act-description-quality-v2.final.md
 M .ai/logs/codex-audit-act-execution-builtin.final.md
 M .ai/logs/codex-audit-act-execution-scripts.final.md
 M .ai/logs/codex-audit-act-keyboard-nav.final.md
 M .ai/logs/codex-audit-act-section-grouping.final.md
 M .ai/logs/codex-audit-act-theme-dialog-render.final.md
 M .ai/roster.json
 M src/actions/builders.rs
 M src/actions/builders/chat.rs
 M src/actions/builders/clipboard.rs
 M src/actions/builders/file_path.rs
 M src/actions/builders/notes.rs
 M src/actions/builders/script_context.rs
 M src/actions/builders/scriptlet.rs
 M src/actions/builders/shared.rs
 M src/actions/command_bar/part_01.rs
 M src/actions/command_bar/part_02.rs
 M src/actions/constants.rs
 M src/actions/dialog/part_01.rs
 M src/actions/dialog/part_02/part_01.rs
file update:
diff --git a/src/ai/script_generation.rs b/src/ai/script_generation.rs
index f29715b032570028241789219179c413e5c5ed83..a89e4e8d4161e386089b6e3cac57975cd36b3cd0
--- a/src/ai/script_generation.rs
+++ b/src/ai/script_generation.rs
@@ -148,75 +148,6 @@
     Ok(script_path)
 }
 
-pub(crate) fn run_saved_script(path: &Path) -> Result<()> {
-    let script_path = path.to_string_lossy().to_string();
-    let attempts: &[(&str, &[&str])] = &[
-        ("kit", &["run", &script_path]),
-        ("bun", &["run", &script_path]),
-    ];
-
-    let mut failures = Vec::new();
-
-    for &(cmd, args) in attempts {
-        let result = std::process::Command::new(cmd)
-            .args(args)
-            .stderr(std::process::Stdio::piped())
-            .stdout(std::process::Stdio::piped())
-            .spawn();
-
-        match result {
-            Ok(mut child) => {
-                // Wait briefly for quick failures (e.g. bun cache corruption, missing deps).
-                // If still running after the timeout, assume it launched successfully.
-                let timeout = std::time::Duration::from_secs(5);
-                let start = std::time::Instant::now();
-                loop {
-                    match child.try_wait() {
-                        Ok(Some(status)) if !status.success() => {
-                            let stderr_text = child
-                                .stderr
-                                .take()
-                                .map(|mut s| {
-                                    let mut buf = String::new();
-                                    std::io::Read::read_to_string(&mut s, &mut buf).ok();
-                                    buf
-                                })
-                                .unwrap_or_default();
-                            let detail = if stderr_text.trim().is_empty() {
-                                format!("exit {}", status)
-                            } else {
-                                stderr_text.trim().to_string()
-                            };
-                            failures.push(format!("{}: {}", cmd, detail));
-                            break;
-                        }
-                        Ok(Some(_)) => return Ok(()), // exited successfully
-                        Ok(None) => {
-                            if start.elapsed() >= timeout {
-                                return Ok(()); // still running — launched OK
-                            }
-                            std::thread::sleep(std::time::Duration::from_millis(50));
-                        }
-                        Err(error) => {
-                            failures.push(format!("{}: wait failed: {}", cmd, error));
-                            break;
-                        }
-                    }
-                }
-            }
-            Err(error) => {
-                failures.push(format!("{}: {}", cmd, error));
-            }
-        }
-    }
-
-    anyhow::bail!(
-        "Failed to run script (path={}, attempts={})",
-        path.display(),
-        failures.join(" | ")
-    );
-}
-
 fn select_generation_model(
     registry: &ProviderRegistry,
 ) -> Result<(ModelInfo, Arc<dyn AiProvider>)> {
diff --git a/src/app_impl/prompt_ai.rs b/src/app_impl/prompt_ai.rs
index c8266b6cb798ec62e6e7e9a8a59005512e44b72f..6c10ca4234dc2d80bb14bc0d5163caddf97656cc
--- a/src/app_impl/prompt_ai.rs
+++ b/src/app_impl/prompt_ai.rs
@@ -568,6 +568,38 @@
         let noop_callback: ChatSubmitCallback = std::sync::Arc::new(|_id, _text| {
             // Built-in AI mode handles this internally
         });
+        let app_entity = cx.entity().downgrade();
+        let run_script_callback = move |script_path: std::path::PathBuf,
+                                        chat_cx: &mut gpui::Context<ChatPrompt>| {
+            let script_path_string = script_path.to_string_lossy().to_string();
+            let app_entity = app_entity.clone();
+            chat_cx
+                .spawn(async move |_this, cx| {
+                    let _ = cx.update(|cx| {
+                        if let Some(app) = app_entity.upgrade() {
+                            logging::log(
+                                "CHAT_SCRIPT_GEN",
+                                &format!(
+                                    "state=dispatch_run attempted=execute_script_by_path path={}",
+                                    script_path_string
+                                ),
+                            );
+                            app.update(cx, |app, cx| {
+                                app.execute_script_by_path(&script_path_string, cx);
+                            });
+                        } else {
+                            logging::log(
+                                "CHAT_SCRIPT_GEN",
+                                &format!(
+                                    "state=dispatch_run_failed attempted=execute_script_by_path path={} reason=app_entity_unavailable",
+                                    script_path_string
+                                ),
+                            );
+                        }
+                    });
+                })
+                .detach();
+        };
 
         let placeholder = Some("Describe the script you want to generate...".to_string());
 
@@ -584,6 +616,7 @@
         .with_title("Generate Script with AI")
         .with_save_history(false)
         .with_escape_callback(escape_callback)
+        .with_run_script_callback(run_script_callback)
         .with_builtin_ai(registry, true) // true = prefer Vercel AI Gateway
         .with_builtin_system_prompt(crate::ai::script_generation::AI_SCRIPT_GENERATION_SYSTEM_PROMPT)
         .with_script_generation_mode(true);
diff --git a/src/components/prompt_footer.rs b/src/components/prompt_footer.rs
index 6bfa86a1edacaec90dc82185bb178cd09dfb7b61..0ce40c6c9c2ea6aa9f9e7599cb8065ebd2c5318b
--- a/src/components/prompt_footer.rs
+++ b/src/components/prompt_footer.rs
@@ -155,14 +155,19 @@
     )
 }
 
-fn footer_button_hover_rgba(colors: PromptFooterColors) -> u32 {
+pub fn footer_button_hover_rgba(colors: PromptFooterColors) -> u32 {
     (colors.background << 8) | (PROMPT_FOOTER_BUTTON_HOVER_OPACITY as u32)
 }
 
-fn footer_button_active_rgba(colors: PromptFooterColors) -> u32 {
+pub fn footer_button_active_rgba(colors: PromptFooterColors) -> u32 {
     (colors.background << 8) | (PROMPT_FOOTER_BUTTON_ACTIVE_OPACITY as u32)
 }
 
+pub fn footer_button_font_size_px(theme: &Theme) -> f32 {
+    (theme.get_fonts().ui_size - PROMPT_FOOTER_BUTTON_FONT_DELTA_PX)
+        .max(PROMPT_FOOTER_BUTTON_FONT_MIN_PX)
+}
+
 /// Configuration for PromptFooter display
 #[derive(Clone, Debug)]
 pub struct PromptFooterConfig {
@@ -334,8 +339,7 @@
         on_click: Option<Rc<FooterClickCallback>>,
     ) -> impl IntoElement {
         let theme = crate::theme::get_cached_theme();
-        let button_font_size = (theme.get_fonts().ui_size - PROMPT_FOOTER_BUTTON_FONT_DELTA_PX)
-            .max(PROMPT_FOOTER_BUTTON_FONT_MIN_PX);
+        let button_font_size = footer_button_font_size_px(&theme);
         let has_click_handler = on_click.is_some();
         let is_clickable = is_footer_button_clickable(has_click_handler, disabled);
         let on_click_for_key = on_click.clone();
diff --git a/src/prompts/chat/actions.rs b/src/prompts/chat/actions.rs
index 8ae41af43235d867176126f8de45f9fc8f3f2cbf..4d01323e1d134ef8e6f56be60d0a1eee086247e7
--- a/src/prompts/chat/actions.rs
+++ b/src/prompts/chat/actions.rs
@@ -172,48 +172,36 @@
 
         if action.should_run_after_save() {
             self.set_script_generation_status(false, format!("Running {}...", script_name), cx);
-
-            let path_clone = script_path.clone();
-            let name_clone = script_name.clone();
-            cx.spawn(async move |this, cx| {
-                let run_result = std::thread::spawn(move || {
-                    crate::ai::script_generation::run_saved_script(&path_clone)
-                })
-                .join()
-                .map_err(|_| anyhow::anyhow!("run thread panicked"))
-                .and_then(|r| r);
-
-                let _ = cx.update(|cx| {
-                    this.update(cx, |chat, cx| match run_result {
-                        Ok(()) => {
-                            chat.set_script_generation_status(
-                                false,
-                                format!("Saved and running {}", name_clone),
-                                cx,
-                            );
-                            logging::log(
-                                "CHAT_SCRIPT_GEN",
-                                &format!("state=run_ok action={:?} script={}", action, name_clone),
-                            );
-                        }
-                        Err(error) => {
-                            chat.set_script_generation_status(
-                                true,
-                                format!("Saved {} but failed to run: {}", name_clone, error),
-                                cx,
-                            );
-                            logging::log(
-                                "CHAT_SCRIPT_GEN",
-                                &format!(
-                                    "state=run_failed action={:?} script={} error={}",
-                                    action, name_clone, error
-                                ),
-                            );
-                        }
-                    })
-                });
-            })
-            .detach();
+            if let Some(ref callback) = self.on_run_script {
+                callback(script_path.clone(), cx);
+                self.set_script_generation_status(
+                    false,
+                    format!("Saved and running {}", script_name),
+                    cx,
+                );
+                logging::log(
+                    "CHAT_SCRIPT_GEN",
+                    &format!(
+                        "state=run_dispatched action={:?} path={}",
+                        action,
+                        script_path.display()
+                    ),
+                );
+            } else {
+                self.set_script_generation_status(
+                    true,
+                    format!("Saved {} but run action is unavailable", script_name),
+                    cx,
+                );
+                logging::log(
+                    "CHAT_SCRIPT_GEN",
+                    &format!(
+                        "state=run_dispatch_failed action={:?} path={} reason=missing_callback",
+                        action,
+                        script_path.display()
+                    ),
+                );
+            }
             return;
         }
 
diff --git a/src/prompts/chat/prompt.rs b/src/prompts/chat/prompt.rs
index 4ef4ac1aae4123a9bdd9771500998f87f424660b..78a8d8354e9e50914fdbcf1cc0fce0292b4feac2
--- a/src/prompts/chat/prompt.rs
+++ b/src/prompts/chat/prompt.rs
@@ -60,6 +60,9 @@
     pub(super) on_claude_code: Option<ChatClaudeCodeCallback>,
     // Callback for showing actions dialog (handled by parent)
     pub(super) on_show_actions: Option<ChatShowActionsCallback>,
+    // Callback for running a saved generated script via parent app pipeline
+    pub(super) on_run_script:
+        Option<Arc<dyn Fn(std::path::PathBuf, &mut Context<ChatPrompt>) + Send + Sync>>,
     // Stable UUID for Claude Code CLI session continuity within this prompt's lifetime.
     // Generated once at construction so all messages share the same session.
     pub(super) cli_session_id: String,
@@ -134,6 +137,7 @@
             on_configure: None,
             on_claude_code: None,
             on_show_actions: None,
+            on_run_script: None,
             cli_session_id: uuid::Uuid::new_v4().to_string(),
             pending_image: None,
             pending_image_render: None,
@@ -146,6 +150,15 @@
         self.on_show_actions = Some(callback);
     }
 
+    /// Set the callback for running a generated script path in the parent app.
+    pub fn with_run_script_callback(
+        mut self,
+        callback: impl Fn(std::path::PathBuf, &mut Context<Self>) + Send + Sync + 'static,
+    ) -> Self {
+        self.on_run_script = Some(Arc::new(callback));
+        self
+    }
+
     /// Start the cursor blink timer
     pub fn start_cursor_blink(&mut self, cx: &mut Context<Self>) {
         cx.spawn(async move |this, cx| {
diff --git a/src/prompts/chat/render_core.rs b/src/prompts/chat/render_core.rs
index 4e91d2d0ed474e69c143cd50e58e0491df58450b..7a066a4f6a2e6ac66e5e870f4a926cfbe0c56618
--- a/src/prompts/chat/render_core.rs
+++ b/src/prompts/chat/render_core.rs
@@ -32,10 +32,18 @@
         label: &'static str,
         shortcut: Option<&'static str>,
         action: ScriptGenerationAction,
-        accent_color: u32,
-        muted_color: u32,
+        footer_colors: PromptFooterColors,
         cx: &mut Context<Self>,
     ) -> AnyElement {
+        let button_font_size =
+            crate::components::prompt_footer::footer_button_font_size_px(&self.theme);
+        let hover_bg = rgba(crate::components::prompt_footer::footer_button_hover_rgba(
+            footer_colors,
+        ));
+        let active_bg = rgba(crate::components::prompt_footer::footer_button_active_rgba(
+            footer_colors,
+        ));
+
         div()
             .id(id)
             .flex()
@@ -46,9 +54,21 @@
             .py(px(2.0))
             .rounded(px(4.0))
             .cursor_pointer()
-            .child(div().text_xs().text_color(rgb(accent_color)).child(label))
+            .hover(move |d| d.bg(hover_bg))
+            .active(move |d| d.bg(active_bg))
+            .child(
+                div()
+                    .text_size(px(button_font_size))
+                    .text_color(rgb(footer_colors.accent))
+                    .child(label),
+            )
             .when_some(shortcut, |d, shortcut| {
-                d.child(div().text_xs().text_color(rgb(muted_color)).child(shortcut))
+                d.child(
+                    div()
+                        .text_size(px(button_font_size))
+                        .text_color(rgb(footer_colors.text_muted))
+                        .child(shortcut),
+                )
             })
             .on_click(cx.listener(move |this, _event, _window, cx| {
                 this.handle_script_generation_action(action, cx);
@@ -109,10 +129,9 @@
             self.render_script_generation_footer_button(
                 "chat-footer-primary-button",
                 "Save and Run",
-                None,
+                Some("⌘↵"),
                 ScriptGenerationAction::SaveAndRun,
-                footer_colors.accent,
-                footer_colors.text_muted,
+                footer_colors,
                 cx,
             )
         } else {
@@ -194,8 +213,7 @@
                     "Save",
                     None,
                     ScriptGenerationAction::Save,
-                    footer_colors.accent,
-                    footer_colors.text_muted,
+                    footer_colors,
                     cx,
                 ))
                 .child(self.render_script_generation_footer_button(
@@ -203,8 +221,7 @@
                     "Run",
                     None,
                     ScriptGenerationAction::Run,
-                    footer_colors.accent,
-                    footer_colors.text_muted,
+                    footer_colors,
                     cx,
                 ));
         }
@@ -356,7 +373,13 @@
                     }
                 }
                 ChatInputKeyAction::ToggleActions => this.toggle_actions_menu(cx),
-                ChatInputKeyAction::ContinueInChat => this.handle_continue_in_chat(cx),
+                ChatInputKeyAction::ContinueInChat => {
+                    if this.script_generation_mode {
+                        this.handle_script_generation_action(ScriptGenerationAction::SaveAndRun, cx);
+                    } else {
+                        this.handle_continue_in_chat(cx);
+                    }
+                }
                 ChatInputKeyAction::Submit => this.handle_submit(cx),
                 ChatInputKeyAction::InsertNewline => {
                     this.input.insert_char('\n');
@@ -618,7 +641,9 @@
             "Footer primary action should branch on script_generation_mode"
         );
         assert!(
-            normalized.contains("\"chat-footer-primary-button\",\"SaveandRun\",None,ScriptGenerationAction::SaveAndRun,"),
+            normalized.contains(
+                "\"chat-footer-primary-button\",\"SaveandRun\",Some(\"⌘↵\"),ScriptGenerationAction::SaveAndRun,"
+            ),
             "Script generation mode should render Save and Run as the primary footer action"
         );
         assert!(
@@ -647,4 +672,18 @@
             "Save and Run should only appear as the primary footer action slot"
         );
     }
+
+    #[test]
+    fn test_cmd_enter_runs_save_and_run_when_script_generation_mode_enabled() {
+        let content = fs::read_to_string("src/prompts/chat/render_core.rs")
+            .expect("Failed to read src/prompts/chat/render_core.rs");
+        let normalized: String = content.chars().filter(|c| !c.is_whitespace()).collect();
+
+        assert!(
+            normalized.contains(
+                "ChatInputKeyAction::ContinueInChat=>{ifthis.script_generation_mode{this.handle_script_generation_action(ScriptGenerationAction::SaveAndRun,cx);}else{this.handle_continue_in_chat(cx);}}"
+            ),
+            "Cmd+Enter should trigger SaveAndRun in script generation mode and ContinueInChat otherwise"
+        );
+    }
 }


thinking
**Assessing commit feasibility amid dirty tree**
codex
`cargo check -p script-kit-gpui` succeeds with existing workspace warnings. I attempted a focused `cargo test` for the new shortcut test, but test compilation is currently blocked by unrelated duplicate test-module files (`src/protocol/message/tests.rs` vs `src/protocol/message/tests/mod.rs`, and similar in `src/designs/core`). I’ll record that and then finalize/release claims.

thinking
**Updating swarm status and releasing claims**
exec
/bin/zsh -lc 'cd /Users/johnlindquist/dev/script-kit-gpui && ~/.claude/bin/swarm.ts update --id codex-save-run-fixes --status done --notes "implemented ChatPrompt run callback to app execute_script_by_path, cmd+enter save+run branch, prompt-footer style parity for save/run buttons; cargo check passed; targeted cargo test blocked by pre-existing duplicate test modules" && ~/.claude/bin/swarm.ts release --id codex-save-run-fixes src/prompts/chat/actions.rs src/prompts/chat/prompt.rs src/prompts/chat/render_core.rs src/app_impl/prompt_ai.rs src/components/prompt_footer.rs src/ai/script_generation.rs' in /Users/johnlindquist/dev/script-kit-gpui succeeded in 51ms:
Updated: codex-save-run-fixes
Released for codex-save-run-fixes: src/prompts/chat/actions.rs, src/prompts/chat/prompt.rs, src/prompts/chat/render_core.rs, src/app_impl/prompt_ai.rs, src/components/prompt_footer.rs, src/ai/script_generation.rs
file update:
diff --git a/src/ai/script_generation.rs b/src/ai/script_generation.rs
index f29715b032570028241789219179c413e5c5ed83..a89e4e8d4161e386089b6e3cac57975cd36b3cd0
--- a/src/ai/script_generation.rs
+++ b/src/ai/script_generation.rs
@@ -148,75 +148,6 @@
     Ok(script_path)
 }
 
-pub(crate) fn run_saved_script(path: &Path) -> Result<()> {
-    let script_path = path.to_string_lossy().to_string();
-    let attempts: &[(&str, &[&str])] = &[
-        ("kit", &["run", &script_path]),
-        ("bun", &["run", &script_path]),
-    ];
-
-    let mut failures = Vec::new();
-
-    for &(cmd, args) in attempts {
-        let result = std::process::Command::new(cmd)
-            .args(args)
-            .stderr(std::process::Stdio::piped())
-            .stdout(std::process::Stdio::piped())
-            .spawn();
-
-        match result {
-            Ok(mut child) => {
-                // Wait briefly for quick failures (e.g. bun cache corruption, missing deps).
-                // If still running after the timeout, assume it launched successfully.
-                let timeout = std::time::Duration::from_secs(5);
-                let start = std::time::Instant::now();
-                loop {
-                    match child.try_wait() {
-                        Ok(Some(status)) if !status.success() => {
-                            let stderr_text = child
-                                .stderr
-                                .take()
-                                .map(|mut s| {
-                                    let mut buf = String::new();
-                                    std::io::Read::read_to_string(&mut s, &mut buf).ok();
-                                    buf
-                                })
-                                .unwrap_or_default();
-                            let detail = if stderr_text.trim().is_empty() {
-                                format!("exit {}", status)
-                            } else {
-                                stderr_text.trim().to_string()
-                            };
-                            failures.push(format!("{}: {}", cmd, detail));
-                            break;
-                        }
-                        Ok(Some(_)) => return Ok(()), // exited successfully
-                        Ok(None) => {
-                            if start.elapsed() >= timeout {
-                                return Ok(()); // still running — launched OK
-                            }
-                            std::thread::sleep(std::time::Duration::from_millis(50));
-                        }
-                        Err(error) => {
-                            failures.push(format!("{}: wait failed: {}", cmd, error));
-                            break;
-                        }
-                    }
-                }
-            }
-            Err(error) => {
-                failures.push(format!("{}: {}", cmd, error));
-            }
-        }
-    }
-
-    anyhow::bail!(
-        "Failed to run script (path={}, attempts={})",
-        path.display(),
-        failures.join(" | ")
-    );
-}
-
 fn select_generation_model(
     registry: &ProviderRegistry,
 ) -> Result<(ModelInfo, Arc<dyn AiProvider>)> {
diff --git a/src/app_impl/prompt_ai.rs b/src/app_impl/prompt_ai.rs
index c8266b6cb798ec62e6e7e9a8a59005512e44b72f..6c10ca4234dc2d80bb14bc0d5163caddf97656cc
--- a/src/app_impl/prompt_ai.rs
+++ b/src/app_impl/prompt_ai.rs
@@ -568,6 +568,38 @@
         let noop_callback: ChatSubmitCallback = std::sync::Arc::new(|_id, _text| {
             // Built-in AI mode handles this internally
         });
+        let app_entity = cx.entity().downgrade();
+        let run_script_callback = move |script_path: std::path::PathBuf,
+                                        chat_cx: &mut gpui::Context<ChatPrompt>| {
+            let script_path_string = script_path.to_string_lossy().to_string();
+            let app_entity = app_entity.clone();
+            chat_cx
+                .spawn(async move |_this, cx| {
+                    let _ = cx.update(|cx| {
+                        if let Some(app) = app_entity.upgrade() {
+                            logging::log(
+                                "CHAT_SCRIPT_GEN",
+                                &format!(
+                                    "state=dispatch_run attempted=execute_script_by_path path={}",
+                                    script_path_string
+                                ),
+                            );
+                            app.update(cx, |app, cx| {
+                                app.execute_script_by_path(&script_path_string, cx);
+                            });
+                        } else {
+                            logging::log(
+                                "CHAT_SCRIPT_GEN",
+                                &format!(
+                                    "state=dispatch_run_failed attempted=execute_script_by_path path={} reason=app_entity_unavailable",
+                                    script_path_string
+                                ),
+                            );
+                        }
+                    });
+                })
+                .detach();
+        };
 
         let placeholder = Some("Describe the script you want to generate...".to_string());
 
@@ -584,6 +616,7 @@
         .with_title("Generate Script with AI")
         .with_save_history(false)
         .with_escape_callback(escape_callback)
+        .with_run_script_callback(run_script_callback)
         .with_builtin_ai(registry, true) // true = prefer Vercel AI Gateway
         .with_builtin_system_prompt(crate::ai::script_generation::AI_SCRIPT_GENERATION_SYSTEM_PROMPT)
         .with_script_generation_mode(true);
diff --git a/src/components/prompt_footer.rs b/src/components/prompt_footer.rs
index 6bfa86a1edacaec90dc82185bb178cd09dfb7b61..0ce40c6c9c2ea6aa9f9e7599cb8065ebd2c5318b
--- a/src/components/prompt_footer.rs
+++ b/src/components/prompt_footer.rs
@@ -155,14 +155,19 @@
     )
 }
 
-fn footer_button_hover_rgba(colors: PromptFooterColors) -> u32 {
+pub fn footer_button_hover_rgba(colors: PromptFooterColors) -> u32 {
     (colors.background << 8) | (PROMPT_FOOTER_BUTTON_HOVER_OPACITY as u32)
 }
 
-fn footer_button_active_rgba(colors: PromptFooterColors) -> u32 {
+pub fn footer_button_active_rgba(colors: PromptFooterColors) -> u32 {
     (colors.background << 8) | (PROMPT_FOOTER_BUTTON_ACTIVE_OPACITY as u32)
 }
 
+pub fn footer_button_font_size_px(theme: &Theme) -> f32 {
+    (theme.get_fonts().ui_size - PROMPT_FOOTER_BUTTON_FONT_DELTA_PX)
+        .max(PROMPT_FOOTER_BUTTON_FONT_MIN_PX)
+}
+
 /// Configuration for PromptFooter display
 #[derive(Clone, Debug)]
 pub struct PromptFooterConfig {
@@ -334,8 +339,7 @@
         on_click: Option<Rc<FooterClickCallback>>,
     ) -> impl IntoElement {
         let theme = crate::theme::get_cached_theme();
-        let button_font_size = (theme.get_fonts().ui_size - PROMPT_FOOTER_BUTTON_FONT_DELTA_PX)
-            .max(PROMPT_FOOTER_BUTTON_FONT_MIN_PX);
+        let button_font_size = footer_button_font_size_px(&theme);
         let has_click_handler = on_click.is_some();
         let is_clickable = is_footer_button_clickable(has_click_handler, disabled);
         let on_click_for_key = on_click.clone();
diff --git a/src/prompts/chat/actions.rs b/src/prompts/chat/actions.rs
index 8ae41af43235d867176126f8de45f9fc8f3f2cbf..4d01323e1d134ef8e6f56be60d0a1eee086247e7
--- a/src/prompts/chat/actions.rs
+++ b/src/prompts/chat/actions.rs
@@ -172,48 +172,36 @@
 
         if action.should_run_after_save() {
             self.set_script_generation_status(false, format!("Running {}...", script_name), cx);
-
-            let path_clone = script_path.clone();
-            let name_clone = script_name.clone();
-            cx.spawn(async move |this, cx| {
-                let run_result = std::thread::spawn(move || {
-                    crate::ai::script_generation::run_saved_script(&path_clone)
-                })
-                .join()
-                .map_err(|_| anyhow::anyhow!("run thread panicked"))
-                .and_then(|r| r);
-
-                let _ = cx.update(|cx| {
-                    this.update(cx, |chat, cx| match run_result {
-                        Ok(()) => {
-                            chat.set_script_generation_status(
-                                false,
-                                format!("Saved and running {}", name_clone),
-                                cx,
-                            );
-                            logging::log(
-                                "CHAT_SCRIPT_GEN",
-                                &format!("state=run_ok action={:?} script={}", action, name_clone),
-                            );
-                        }
-                        Err(error) => {
-                            chat.set_script_generation_status(
-                                true,
-                                format!("Saved {} but failed to run: {}", name_clone, error),
-                                cx,
-                            );
-                            logging::log(
-                                "CHAT_SCRIPT_GEN",
-                                &format!(
-                                    "state=run_failed action={:?} script={} error={}",
-                                    action, name_clone, error
-                                ),
-                            );
-                        }
-                    })
-                });
-            })
-            .detach();
+            if let Some(ref callback) = self.on_run_script {
+                callback(script_path.clone(), cx);
+                self.set_script_generation_status(
+                    false,
+                    format!("Saved and running {}", script_name),
+                    cx,
+                );
+                logging::log(
+                    "CHAT_SCRIPT_GEN",
+                    &format!(
+                        "state=run_dispatched action={:?} path={}",
+                        action,
+                        script_path.display()
+                    ),
+                );
+            } else {
+                self.set_script_generation_status(
+                    true,
+                    format!("Saved {} but run action is unavailable", script_name),
+                    cx,
+                );
+                logging::log(
+                    "CHAT_SCRIPT_GEN",
+                    &format!(
+                        "state=run_dispatch_failed action={:?} path={} reason=missing_callback",
+                        action,
+                        script_path.display()
+                    ),
+                );
+            }
             return;
         }
 
diff --git a/src/prompts/chat/prompt.rs b/src/prompts/chat/prompt.rs
index 4ef4ac1aae4123a9bdd9771500998f87f424660b..78a8d8354e9e50914fdbcf1cc0fce0292b4feac2
--- a/src/prompts/chat/prompt.rs
+++ b/src/prompts/chat/prompt.rs
@@ -60,6 +60,9 @@
     pub(super) on_claude_code: Option<ChatClaudeCodeCallback>,
     // Callback for showing actions dialog (handled by parent)
     pub(super) on_show_actions: Option<ChatShowActionsCallback>,
+    // Callback for running a saved generated script via parent app pipeline
+    pub(super) on_run_script:
+        Option<Arc<dyn Fn(std::path::PathBuf, &mut Context<ChatPrompt>) + Send + Sync>>,
     // Stable UUID for Claude Code CLI session continuity within this prompt's lifetime.
     // Generated once at construction so all messages share the same session.
     pub(super) cli_session_id: String,
@@ -134,6 +137,7 @@
             on_configure: None,
             on_claude_code: None,
             on_show_actions: None,
+            on_run_script: None,
             cli_session_id: uuid::Uuid::new_v4().to_string(),
             pending_image: None,
             pending_image_render: None,
@@ -146,6 +150,15 @@
         self.on_show_actions = Some(callback);
     }
 
+    /// Set the callback for running a generated script path in the parent app.
+    pub fn with_run_script_callback(
+        mut self,
+        callback: impl Fn(std::path::PathBuf, &mut Context<Self>) + Send + Sync + 'static,
+    ) -> Self {
+        self.on_run_script = Some(Arc::new(callback));
+        self
+    }
+
     /// Start the cursor blink timer
     pub fn start_cursor_blink(&mut self, cx: &mut Context<Self>) {
         cx.spawn(async move |this, cx| {
diff --git a/src/prompts/chat/render_core.rs b/src/prompts/chat/render_core.rs
index 4e91d2d0ed474e69c143cd50e58e0491df58450b..7a066a4f6a2e6ac66e5e870f4a926cfbe0c56618
--- a/src/prompts/chat/render_core.rs
+++ b/src/prompts/chat/render_core.rs
@@ -32,10 +32,18 @@
         label: &'static str,
         shortcut: Option<&'static str>,
         action: ScriptGenerationAction,
-        accent_color: u32,
-        muted_color: u32,
+        footer_colors: PromptFooterColors,
         cx: &mut Context<Self>,
     ) -> AnyElement {
+        let button_font_size =
+            crate::components::prompt_footer::footer_button_font_size_px(&self.theme);
+        let hover_bg = rgba(crate::components::prompt_footer::footer_button_hover_rgba(
+            footer_colors,
+        ));
+        let active_bg = rgba(crate::components::prompt_footer::footer_button_active_rgba(
+            footer_colors,
+        ));
+
         div()
             .id(id)
             .flex()
@@ -46,9 +54,21 @@
             .py(px(2.0))
             .rounded(px(4.0))
             .cursor_pointer()
-            .child(div().text_xs().text_color(rgb(accent_color)).child(label))
+            .hover(move |d| d.bg(hover_bg))
+            .active(move |d| d.bg(active_bg))
+            .child(
+                div()
+                    .text_size(px(button_font_size))
+                    .text_color(rgb(footer_colors.accent))
+                    .child(label),
+            )
             .when_some(shortcut, |d, shortcut| {
-                d.child(div().text_xs().text_color(rgb(muted_color)).child(shortcut))
+                d.child(
+                    div()
+                        .text_size(px(button_font_size))
+                        .text_color(rgb(footer_colors.text_muted))
+                        .child(shortcut),
+                )
             })
             .on_click(cx.listener(move |this, _event, _window, cx| {
                 this.handle_script_generation_action(action, cx);
@@ -109,10 +129,9 @@
             self.render_script_generation_footer_button(
                 "chat-footer-primary-button",
                 "Save and Run",
-                None,
+                Some("⌘↵"),
                 ScriptGenerationAction::SaveAndRun,
-                footer_colors.accent,
-                footer_colors.text_muted,
+                footer_colors,
                 cx,
             )
         } else {
@@ -194,8 +213,7 @@
                     "Save",
                     None,
                     ScriptGenerationAction::Save,
-                    footer_colors.accent,
-                    footer_colors.text_muted,
+                    footer_colors,
                     cx,
                 ))
                 .child(self.render_script_generation_footer_button(
@@ -203,8 +221,7 @@
                     "Run",
                     None,
                     ScriptGenerationAction::Run,
-                    footer_colors.accent,
-                    footer_colors.text_muted,
+                    footer_colors,
                     cx,
                 ));
         }
@@ -356,7 +373,13 @@
                     }
                 }
                 ChatInputKeyAction::ToggleActions => this.toggle_actions_menu(cx),
-                ChatInputKeyAction::ContinueInChat => this.handle_continue_in_chat(cx),
+                ChatInputKeyAction::ContinueInChat => {
+                    if this.script_generation_mode {
+                        this.handle_script_generation_action(ScriptGenerationAction::SaveAndRun, cx);
+                    } else {
+                        this.handle_continue_in_chat(cx);
+                    }
+                }
                 ChatInputKeyAction::Submit => this.handle_submit(cx),
                 ChatInputKeyAction::InsertNewline => {
                     this.input.insert_char('\n');
@@ -618,7 +641,9 @@
             "Footer primary action should branch on script_generation_mode"
         );
         assert!(
-            normalized.contains("\"chat-footer-primary-button\",\"SaveandRun\",None,ScriptGenerationAction::SaveAndRun,"),
+            normalized.contains(
+                "\"chat-footer-primary-button\",\"SaveandRun\",Some(\"⌘↵\"),ScriptGenerationAction::SaveAndRun,"
+            ),
             "Script generation mode should render Save and Run as the primary footer action"
         );
         assert!(
@@ -647,4 +672,18 @@
             "Save and Run should only appear as the primary footer action slot"
         );
     }
+
+    #[test]
+    fn test_cmd_enter_runs_save_and_run_when_script_generation_mode_enabled() {
+        let content = fs::read_to_string("src/prompts/chat/render_core.rs")
+            .expect("Failed to read src/prompts/chat/render_core.rs");
+        let normalized: String = content.chars().filter(|c| !c.is_whitespace()).collect();
+
+        assert!(
+            normalized.contains(
+                "ChatInputKeyAction::ContinueInChat=>{ifthis.script_generation_mode{this.handle_script_generation_action(ScriptGenerationAction::SaveAndRun,cx);}else{this.handle_continue_in_chat(cx);}}"
+            ),
+            "Cmd+Enter should trigger SaveAndRun in script generation mode and ContinueInChat otherwise"
+        );
+    }
 }


thinking
**Checking for changed files**
exec
/bin/zsh -lc 'cd /Users/johnlindquist/dev/script-kit-gpui && git diff --name-only -- src/prompts/chat/actions.rs src/prompts/chat/prompt.rs src/prompts/chat/render_core.rs src/app_impl/prompt_ai.rs src/components/prompt_footer.rs src/ai/script_generation.rs' in /Users/johnlindquist/dev/script-kit-gpui succeeded in 51ms:
src/ai/script_generation.rs
src/app_impl/prompt_ai.rs
src/components/prompt_footer.rs
src/prompts/chat/actions.rs
src/prompts/chat/prompt.rs
src/prompts/chat/render_core.rs
file update:
diff --git a/src/ai/script_generation.rs b/src/ai/script_generation.rs
index f29715b032570028241789219179c413e5c5ed83..a89e4e8d4161e386089b6e3cac57975cd36b3cd0
--- a/src/ai/script_generation.rs
+++ b/src/ai/script_generation.rs
@@ -148,75 +148,6 @@
     Ok(script_path)
 }
 
-pub(crate) fn run_saved_script(path: &Path) -> Result<()> {
-    let script_path = path.to_string_lossy().to_string();
-    let attempts: &[(&str, &[&str])] = &[
-        ("kit", &["run", &script_path]),
-        ("bun", &["run", &script_path]),
-    ];
-
-    let mut failures = Vec::new();
-
-    for &(cmd, args) in attempts {
-        let result = std::process::Command::new(cmd)
-            .args(args)
-            .stderr(std::process::Stdio::piped())
-            .stdout(std::process::Stdio::piped())
-            .spawn();
-
-        match result {
-            Ok(mut child) => {
-                // Wait briefly for quick failures (e.g. bun cache corruption, missing deps).
-                // If still running after the timeout, assume it launched successfully.
-                let timeout = std::time::Duration::from_secs(5);
-                let start = std::time::Instant::now();
-                loop {
-                    match child.try_wait() {
-                        Ok(Some(status)) if !status.success() => {
-                            let stderr_text = child
-                                .stderr
-                                .take()
-                                .map(|mut s| {
-                                    let mut buf = String::new();
-                                    std::io::Read::read_to_string(&mut s, &mut buf).ok();
-                                    buf
-                                })
-                                .unwrap_or_default();
-                            let detail = if stderr_text.trim().is_empty() {
-                                format!("exit {}", status)
-                            } else {
-                                stderr_text.trim().to_string()
-                            };
-                            failures.push(format!("{}: {}", cmd, detail));
-                            break;
-                        }
-                        Ok(Some(_)) => return Ok(()), // exited successfully
-                        Ok(None) => {
-                            if start.elapsed() >= timeout {
-                                return Ok(()); // still running — launched OK
-                            }
-                            std::thread::sleep(std::time::Duration::from_millis(50));
-                        }
-                        Err(error) => {
-                            failures.push(format!("{}: wait failed: {}", cmd, error));
-                            break;
-                        }
-                    }
-                }
-            }
-            Err(error) => {
-                failures.push(format!("{}: {}", cmd, error));
-            }
-        }
-    }
-
-    anyhow::bail!(
-        "Failed to run script (path={}, attempts={})",
-        path.display(),
-        failures.join(" | ")
-    );
-}
-
 fn select_generation_model(
     registry: &ProviderRegistry,
 ) -> Result<(ModelInfo, Arc<dyn AiProvider>)> {
diff --git a/src/app_impl/prompt_ai.rs b/src/app_impl/prompt_ai.rs
index c8266b6cb798ec62e6e7e9a8a59005512e44b72f..6c10ca4234dc2d80bb14bc0d5163caddf97656cc
--- a/src/app_impl/prompt_ai.rs
+++ b/src/app_impl/prompt_ai.rs
@@ -568,6 +568,38 @@
         let noop_callback: ChatSubmitCallback = std::sync::Arc::new(|_id, _text| {
             // Built-in AI mode handles this internally
         });
+        let app_entity = cx.entity().downgrade();
+        let run_script_callback = move |script_path: std::path::PathBuf,
+                                        chat_cx: &mut gpui::Context<ChatPrompt>| {
+            let script_path_string = script_path.to_string_lossy().to_string();
+            let app_entity = app_entity.clone();
+            chat_cx
+                .spawn(async move |_this, cx| {
+                    let _ = cx.update(|cx| {
+                        if let Some(app) = app_entity.upgrade() {
+                            logging::log(
+                                "CHAT_SCRIPT_GEN",
+                                &format!(
+                                    "state=dispatch_run attempted=execute_script_by_path path={}",
+                                    script_path_string
+                                ),
+                            );
+                            app.update(cx, |app, cx| {
+                                app.execute_script_by_path(&script_path_string, cx);
+                            });
+                        } else {
+                            logging::log(
+                                "CHAT_SCRIPT_GEN",
+                                &format!(
+                                    "state=dispatch_run_failed attempted=execute_script_by_path path={} reason=app_entity_unavailable",
+                                    script_path_string
+                                ),
+                            );
+                        }
+                    });
+                })
+                .detach();
+        };
 
         let placeholder = Some("Describe the script you want to generate...".to_string());
 
@@ -584,6 +616,7 @@
         .with_title("Generate Script with AI")
         .with_save_history(false)
         .with_escape_callback(escape_callback)
+        .with_run_script_callback(run_script_callback)
         .with_builtin_ai(registry, true) // true = prefer Vercel AI Gateway
         .with_builtin_system_prompt(crate::ai::script_generation::AI_SCRIPT_GENERATION_SYSTEM_PROMPT)
         .with_script_generation_mode(true);
diff --git a/src/components/prompt_footer.rs b/src/components/prompt_footer.rs
index 6bfa86a1edacaec90dc82185bb178cd09dfb7b61..0ce40c6c9c2ea6aa9f9e7599cb8065ebd2c5318b
--- a/src/components/prompt_footer.rs
+++ b/src/components/prompt_footer.rs
@@ -155,14 +155,19 @@
     )
 }
 
-fn footer_button_hover_rgba(colors: PromptFooterColors) -> u32 {
+pub fn footer_button_hover_rgba(colors: PromptFooterColors) -> u32 {
     (colors.background << 8) | (PROMPT_FOOTER_BUTTON_HOVER_OPACITY as u32)
 }
 
-fn footer_button_active_rgba(colors: PromptFooterColors) -> u32 {
+pub fn footer_button_active_rgba(colors: PromptFooterColors) -> u32 {
     (colors.background << 8) | (PROMPT_FOOTER_BUTTON_ACTIVE_OPACITY as u32)
 }
 
+pub fn footer_button_font_size_px(theme: &Theme) -> f32 {
+    (theme.get_fonts().ui_size - PROMPT_FOOTER_BUTTON_FONT_DELTA_PX)
+        .max(PROMPT_FOOTER_BUTTON_FONT_MIN_PX)
+}
+
 /// Configuration for PromptFooter display
 #[derive(Clone, Debug)]
 pub struct PromptFooterConfig {
@@ -334,8 +339,7 @@
         on_click: Option<Rc<FooterClickCallback>>,
     ) -> impl IntoElement {
         let theme = crate::theme::get_cached_theme();
-        let button_font_size = (theme.get_fonts().ui_size - PROMPT_FOOTER_BUTTON_FONT_DELTA_PX)
-            .max(PROMPT_FOOTER_BUTTON_FONT_MIN_PX);
+        let button_font_size = footer_button_font_size_px(&theme);
         let has_click_handler = on_click.is_some();
         let is_clickable = is_footer_button_clickable(has_click_handler, disabled);
         let on_click_for_key = on_click.clone();
diff --git a/src/prompts/chat/actions.rs b/src/prompts/chat/actions.rs
index 8ae41af43235d867176126f8de45f9fc8f3f2cbf..4d01323e1d134ef8e6f56be60d0a1eee086247e7
--- a/src/prompts/chat/actions.rs
+++ b/src/prompts/chat/actions.rs
@@ -172,48 +172,36 @@
 
         if action.should_run_after_save() {
             self.set_script_generation_status(false, format!("Running {}...", script_name), cx);
-
-            let path_clone = script_path.clone();
-            let name_clone = script_name.clone();
-            cx.spawn(async move |this, cx| {
-                let run_result = std::thread::spawn(move || {
-                    crate::ai::script_generation::run_saved_script(&path_clone)
-                })
-                .join()
-                .map_err(|_| anyhow::anyhow!("run thread panicked"))
-                .and_then(|r| r);
-
-                let _ = cx.update(|cx| {
-                    this.update(cx, |chat, cx| match run_result {
-                        Ok(()) => {
-                            chat.set_script_generation_status(
-                                false,
-                                format!("Saved and running {}", name_clone),
-                                cx,
-                            );
-                            logging::log(
-                                "CHAT_SCRIPT_GEN",
-                                &format!("state=run_ok action={:?} script={}", action, name_clone),
-                            );
-                        }
-                        Err(error) => {
-                            chat.set_script_generation_status(
-                                true,
-                                format!("Saved {} but failed to run: {}", name_clone, error),
-                                cx,
-                            );
-                            logging::log(
-                                "CHAT_SCRIPT_GEN",
-                                &format!(
-                                    "state=run_failed action={:?} script={} error={}",
-                                    action, name_clone, error
-                                ),
-                            );
-                        }
-                    })
-                });
-            })
-            .detach();
+            if let Some(ref callback) = self.on_run_script {
+                callback(script_path.clone(), cx);
+                self.set_script_generation_status(
+                    false,
+                    format!("Saved and running {}", script_name),
+                    cx,
+                );
+                logging::log(
+                    "CHAT_SCRIPT_GEN",
+                    &format!(
+                        "state=run_dispatched action={:?} path={}",
+                        action,
+                        script_path.display()
+                    ),
+                );
+            } else {
+                self.set_script_generation_status(
+                    true,
+                    format!("Saved {} but run action is unavailable", script_name),
+                    cx,
+                );
+                logging::log(
+                    "CHAT_SCRIPT_GEN",
+                    &format!(
+                        "state=run_dispatch_failed action={:?} path={} reason=missing_callback",
+                        action,
+                        script_path.display()
+                    ),
+                );
+            }
             return;
         }
 
diff --git a/src/prompts/chat/prompt.rs b/src/prompts/chat/prompt.rs
index 4ef4ac1aae4123a9bdd9771500998f87f424660b..78a8d8354e9e50914fdbcf1cc0fce0292b4feac2
--- a/src/prompts/chat/prompt.rs
+++ b/src/prompts/chat/prompt.rs
@@ -60,6 +60,9 @@
     pub(super) on_claude_code: Option<ChatClaudeCodeCallback>,
     // Callback for showing actions dialog (handled by parent)
     pub(super) on_show_actions: Option<ChatShowActionsCallback>,
+    // Callback for running a saved generated script via parent app pipeline
+    pub(super) on_run_script:
+        Option<Arc<dyn Fn(std::path::PathBuf, &mut Context<ChatPrompt>) + Send + Sync>>,
     // Stable UUID for Claude Code CLI session continuity within this prompt's lifetime.
     // Generated once at construction so all messages share the same session.
     pub(super) cli_session_id: String,
@@ -134,6 +137,7 @@
             on_configure: None,
             on_claude_code: None,
             on_show_actions: None,
+            on_run_script: None,
             cli_session_id: uuid::Uuid::new_v4().to_string(),
             pending_image: None,
             pending_image_render: None,
@@ -146,6 +150,15 @@
         self.on_show_actions = Some(callback);
     }
 
+    /// Set the callback for running a generated script path in the parent app.
+    pub fn with_run_script_callback(
+        mut self,
+        callback: impl Fn(std::path::PathBuf, &mut Context<Self>) + Send + Sync + 'static,
+    ) -> Self {
+        self.on_run_script = Some(Arc::new(callback));
+        self
+    }
+
     /// Start the cursor blink timer
     pub fn start_cursor_blink(&mut self, cx: &mut Context<Self>) {
         cx.spawn(async move |this, cx| {
diff --git a/src/prompts/chat/render_core.rs b/src/prompts/chat/render_core.rs
index 4e91d2d0ed474e69c143cd50e58e0491df58450b..7a066a4f6a2e6ac66e5e870f4a926cfbe0c56618
--- a/src/prompts/chat/render_core.rs
+++ b/src/prompts/chat/render_core.rs
@@ -32,10 +32,18 @@
         label: &'static str,
         shortcut: Option<&'static str>,
         action: ScriptGenerationAction,
-        accent_color: u32,
-        muted_color: u32,
+        footer_colors: PromptFooterColors,
         cx: &mut Context<Self>,
     ) -> AnyElement {
+        let button_font_size =
+            crate::components::prompt_footer::footer_button_font_size_px(&self.theme);
+        let hover_bg = rgba(crate::components::prompt_footer::footer_button_hover_rgba(
+            footer_colors,
+        ));
+        let active_bg = rgba(crate::components::prompt_footer::footer_button_active_rgba(
+            footer_colors,
+        ));
+
         div()
             .id(id)
             .flex()
@@ -46,9 +54,21 @@
             .py(px(2.0))
             .rounded(px(4.0))
             .cursor_pointer()
-            .child(div().text_xs().text_color(rgb(accent_color)).child(label))
+            .hover(move |d| d.bg(hover_bg))
+            .active(move |d| d.bg(active_bg))
+            .child(
+                div()
+                    .text_size(px(button_font_size))
+                    .text_color(rgb(footer_colors.accent))
+                    .child(label),
+            )
             .when_some(shortcut, |d, shortcut| {
-                d.child(div().text_xs().text_color(rgb(muted_color)).child(shortcut))
+                d.child(
+                    div()
+                        .text_size(px(button_font_size))
+                        .text_color(rgb(footer_colors.text_muted))
+                        .child(shortcut),
+                )
             })
             .on_click(cx.listener(move |this, _event, _window, cx| {
                 this.handle_script_generation_action(action, cx);
@@ -109,10 +129,9 @@
             self.render_script_generation_footer_button(
                 "chat-footer-primary-button",
                 "Save and Run",
-                None,
+                Some("⌘↵"),
                 ScriptGenerationAction::SaveAndRun,
-                footer_colors.accent,
-                footer_colors.text_muted,
+                footer_colors,
                 cx,
             )
         } else {
@@ -194,8 +213,7 @@
                     "Save",
                     None,
                     ScriptGenerationAction::Save,
-                    footer_colors.accent,
-                    footer_colors.text_muted,
+                    footer_colors,
                     cx,
                 ))
                 .child(self.render_script_generation_footer_button(
@@ -203,8 +221,7 @@
                     "Run",
                     None,
                     ScriptGenerationAction::Run,
-                    footer_colors.accent,
-                    footer_colors.text_muted,
+                    footer_colors,
                     cx,
                 ));
         }
@@ -356,7 +373,13 @@
                     }
                 }
                 ChatInputKeyAction::ToggleActions => this.toggle_actions_menu(cx),
-                ChatInputKeyAction::ContinueInChat => this.handle_continue_in_chat(cx),
+                ChatInputKeyAction::ContinueInChat => {
+                    if this.script_generation_mode {
+                        this.handle_script_generation_action(ScriptGenerationAction::SaveAndRun, cx);
+                    } else {
+                        this.handle_continue_in_chat(cx);
+                    }
+                }
                 ChatInputKeyAction::Submit => this.handle_submit(cx),
                 ChatInputKeyAction::InsertNewline => {
                     this.input.insert_char('\n');
@@ -618,7 +641,9 @@
             "Footer primary action should branch on script_generation_mode"
         );
         assert!(
-            normalized.contains("\"chat-footer-primary-button\",\"SaveandRun\",None,ScriptGenerationAction::SaveAndRun,"),
+            normalized.contains(
+                "\"chat-footer-primary-button\",\"SaveandRun\",Some(\"⌘↵\"),ScriptGenerationAction::SaveAndRun,"
+            ),
             "Script generation mode should render Save and Run as the primary footer action"
         );
         assert!(
@@ -647,4 +672,18 @@
             "Save and Run should only appear as the primary footer action slot"
         );
     }
+
+    #[test]
+    fn test_cmd_enter_runs_save_and_run_when_script_generation_mode_enabled() {
+        let content = fs::read_to_string("src/prompts/chat/render_core.rs")
+            .expect("Failed to read src/prompts/chat/render_core.rs");
+        let normalized: String = content.chars().filter(|c| !c.is_whitespace()).collect();
+
+        assert!(
+            normalized.contains(
+                "ChatInputKeyAction::ContinueInChat=>{ifthis.script_generation_mode{this.handle_script_generation_action(ScriptGenerationAction::SaveAndRun,cx);}else{this.handle_continue_in_chat(cx);}}"
+            ),
+            "Cmd+Enter should trigger SaveAndRun in script generation mode and ContinueInChat otherwise"
+        );
+    }
 }


thinking
**Preparing final summary details**
codex
Implemented the three requested fixes in the script-generation ChatPrompt flow.

Changed files:
- `src/prompts/chat/prompt.rs`
  - Added `on_run_script` callback field and `with_run_script_callback(...)` builder.
- `src/prompts/chat/actions.rs`
  - Updated `handle_script_generation_action(...)` so `Run`/`Save and Run` dispatch to parent callback (app pipeline) instead of detached bun/kit process.
- `src/app_impl/prompt_ai.rs`
  - In `show_script_generation_chat(...)`, wired `with_run_script_callback(...)` to call `ScriptListApp::execute_script_by_path(...)` via app entity update.
- `src/prompts/chat/render_core.rs`
  - Added Cmd+Return behavior in key handler for script-generation mode:
    - `Cmd+Return` now triggers `ScriptGenerationAction::SaveAndRun`.
  - Updated script-generation footer buttons (`Save`, `Run`, `Save and Run`) to use PromptFooter-equivalent visual treatment.
  - Added/updated footer shortcut and key-behavior tests in this file.
- `src/components/prompt_footer.rs`
  - Exposed shared footer button style helpers:
    - `footer_button_font_size_px(...)`
    - `footer_button_hover_rgba(...)`
    - `footer_button_active_rgba(...)`
- `src/ai/script_generation.rs`
  - Removed `run_saved_script(...)` detached runner (no longer used by ChatPrompt run path).

Verification run:
- `cargo check -p script-kit-gpui`  
  - Passed.
- Attempted focused test:
  - `cargo test -p script-kit-gpui test_cmd_enter_runs_save_and_run_when_script_generation_mode_enabled -- --nocapture`
  - Blocked by unrelated pre-existing duplicate test module files:
    - `src/protocol/message/tests.rs` and `src/protocol/message/tests/mod.rs`
    - `src/designs/core/tests.rs` and `src/designs/core/tests/mod.rs`

How to test manually:
1. Launch app and open script-generation chat.
2. Generate a script response.
3. Click `Run` and confirm it executes via app flow (main window/script pipeline behavior, not detached background run).
4. Click `Save and Run` and confirm same.
5. Press `Cmd+Return` in script-generation mode and confirm it triggers `Save and Run`.
6. Confirm footer button visuals for `Save`, `Run`, `Save and Run` match standard PromptFooter button treatment (font sizing, padding, hover/active surface).

Risks / known gaps:
- Rust test execution is currently blocked by unrelated duplicate test-module files in the working tree, so targeted test runtime verification could not complete.
- I did not perform screenshot-based UI verification in this run.

Commits made:
- None.
file update:
diff --git a/src/ai/script_generation.rs b/src/ai/script_generation.rs
index f29715b032570028241789219179c413e5c5ed83..a89e4e8d4161e386089b6e3cac57975cd36b3cd0
--- a/src/ai/script_generation.rs
+++ b/src/ai/script_generation.rs
@@ -148,75 +148,6 @@
     Ok(script_path)
 }
 
-pub(crate) fn run_saved_script(path: &Path) -> Result<()> {
-    let script_path = path.to_string_lossy().to_string();
-    let attempts: &[(&str, &[&str])] = &[
-        ("kit", &["run", &script_path]),
-        ("bun", &["run", &script_path]),
-    ];
-
-    let mut failures = Vec::new();
-
-    for &(cmd, args) in attempts {
-        let result = std::process::Command::new(cmd)
-            .args(args)
-            .stderr(std::process::Stdio::piped())
-            .stdout(std::process::Stdio::piped())
-            .spawn();
-
-        match result {
-            Ok(mut child) => {
-                // Wait briefly for quick failures (e.g. bun cache corruption, missing deps).
-                // If still running after the timeout, assume it launched successfully.
-                let timeout = std::time::Duration::from_secs(5);
-                let start = std::time::Instant::now();
-                loop {
-                    match child.try_wait() {
-                        Ok(Some(status)) if !status.success() => {
-                            let stderr_text = child
-                                .stderr
-                                .take()
-                                .map(|mut s| {
-                                    let mut buf = String::new();
-                                    std::io::Read::read_to_string(&mut s, &mut buf).ok();
-                                    buf
-                                })
-                                .unwrap_or_default();
-                            let detail = if stderr_text.trim().is_empty() {
-                                format!("exit {}", status)
-                            } else {
-                                stderr_text.trim().to_string()
-                            };
-                            failures.push(format!("{}: {}", cmd, detail));
-                            break;
-                        }
-                        Ok(Some(_)) => return Ok(()), // exited successfully
-                        Ok(None) => {
-                            if start.elapsed() >= timeout {
-                                return Ok(()); // still running — launched OK
-                            }
-                            std::thread::sleep(std::time::Duration::from_millis(50));
-                        }
-                        Err(error) => {
-                            failures.push(format!("{}: wait failed: {}", cmd, error));
-                            break;
-                        }
-                    }
-                }
-            }
-            Err(error) => {
-                failures.push(format!("{}: {}", cmd, error));
-            }
-        }
-    }
-
-    anyhow::bail!(
-        "Failed to run script (path={}, attempts={})",
-        path.display(),
-        failures.join(" | ")
-    );
-}
-
 fn select_generation_model(
     registry: &ProviderRegistry,
 ) -> Result<(ModelInfo, Arc<dyn AiProvider>)> {
diff --git a/src/app_impl/prompt_ai.rs b/src/app_impl/prompt_ai.rs
index c8266b6cb798ec62e6e7e9a8a59005512e44b72f..6c10ca4234dc2d80bb14bc0d5163caddf97656cc
--- a/src/app_impl/prompt_ai.rs
+++ b/src/app_impl/prompt_ai.rs
@@ -568,6 +568,38 @@
         let noop_callback: ChatSubmitCallback = std::sync::Arc::new(|_id, _text| {
             // Built-in AI mode handles this internally
         });
+        let app_entity = cx.entity().downgrade();
+        let run_script_callback = move |script_path: std::path::PathBuf,
+                                        chat_cx: &mut gpui::Context<ChatPrompt>| {
+            let script_path_string = script_path.to_string_lossy().to_string();
+            let app_entity = app_entity.clone();
+            chat_cx
+                .spawn(async move |_this, cx| {
+                    let _ = cx.update(|cx| {
+                        if let Some(app) = app_entity.upgrade() {
+                            logging::log(
+                                "CHAT_SCRIPT_GEN",
+                                &format!(
+                                    "state=dispatch_run attempted=execute_script_by_path path={}",
+                                    script_path_string
+                                ),
+                            );
+                            app.update(cx, |app, cx| {
+                                app.execute_script_by_path(&script_path_string, cx);
+                            });
+                        } else {
+                            logging::log(
+                                "CHAT_SCRIPT_GEN",
+                                &format!(
+                                    "state=dispatch_run_failed attempted=execute_script_by_path path={} reason=app_entity_unavailable",
+                                    script_path_string
+                                ),
+                            );
+                        }
+                    });
+                })
+                .detach();
+        };
 
         let placeholder = Some("Describe the script you want to generate...".to_string());
 
@@ -584,6 +616,7 @@
         .with_title("Generate Script with AI")
         .with_save_history(false)
         .with_escape_callback(escape_callback)
+        .with_run_script_callback(run_script_callback)
         .with_builtin_ai(registry, true) // true = prefer Vercel AI Gateway
         .with_builtin_system_prompt(crate::ai::script_generation::AI_SCRIPT_GENERATION_SYSTEM_PROMPT)
         .with_script_generation_mode(true);
diff --git a/src/components/prompt_footer.rs b/src/components/prompt_footer.rs
index 6bfa86a1edacaec90dc82185bb178cd09dfb7b61..0ce40c6c9c2ea6aa9f9e7599cb8065ebd2c5318b
--- a/src/components/prompt_footer.rs
+++ b/src/components/prompt_footer.rs
@@ -155,14 +155,19 @@
     )
 }
 
-fn footer_button_hover_rgba(colors: PromptFooterColors) -> u32 {
+pub fn footer_button_hover_rgba(colors: PromptFooterColors) -> u32 {
     (colors.background << 8) | (PROMPT_FOOTER_BUTTON_HOVER_OPACITY as u32)
 }
 
-fn footer_button_active_rgba(colors: PromptFooterColors) -> u32 {
+pub fn footer_button_active_rgba(colors: PromptFooterColors) -> u32 {
     (colors.background << 8) | (PROMPT_FOOTER_BUTTON_ACTIVE_OPACITY as u32)
 }
 
+pub fn footer_button_font_size_px(theme: &Theme) -> f32 {
+    (theme.get_fonts().ui_size - PROMPT_FOOTER_BUTTON_FONT_DELTA_PX)
+        .max(PROMPT_FOOTER_BUTTON_FONT_MIN_PX)
+}
+
 /// Configuration for PromptFooter display
 #[derive(Clone, Debug)]
 pub struct PromptFooterConfig {
@@ -334,8 +339,7 @@
         on_click: Option<Rc<FooterClickCallback>>,
     ) -> impl IntoElement {
         let theme = crate::theme::get_cached_theme();
-        let button_font_size = (theme.get_fonts().ui_size - PROMPT_FOOTER_BUTTON_FONT_DELTA_PX)
-            .max(PROMPT_FOOTER_BUTTON_FONT_MIN_PX);
+        let button_font_size = footer_button_font_size_px(&theme);
         let has_click_handler = on_click.is_some();
         let is_clickable = is_footer_button_clickable(has_click_handler, disabled);
         let on_click_for_key = on_click.clone();
diff --git a/src/prompts/chat/actions.rs b/src/prompts/chat/actions.rs
index 8ae41af43235d867176126f8de45f9fc8f3f2cbf..4d01323e1d134ef8e6f56be60d0a1eee086247e7
--- a/src/prompts/chat/actions.rs
+++ b/src/prompts/chat/actions.rs
@@ -172,48 +172,36 @@
 
         if action.should_run_after_save() {
             self.set_script_generation_status(false, format!("Running {}...", script_name), cx);
-
-            let path_clone = script_path.clone();
-            let name_clone = script_name.clone();
-            cx.spawn(async move |this, cx| {
-                let run_result = std::thread::spawn(move || {
-                    crate::ai::script_generation::run_saved_script(&path_clone)
-                })
-                .join()
-                .map_err(|_| anyhow::anyhow!("run thread panicked"))
-                .and_then(|r| r);
-
-                let _ = cx.update(|cx| {
-                    this.update(cx, |chat, cx| match run_result {
-                        Ok(()) => {
-                            chat.set_script_generation_status(
-                                false,
-                                format!("Saved and running {}", name_clone),
-                                cx,
-                            );
-                            logging::log(
-                                "CHAT_SCRIPT_GEN",
-                                &format!("state=run_ok action={:?} script={}", action, name_clone),
-                            );
-                        }
-                        Err(error) => {
-                            chat.set_script_generation_status(
-                                true,
-                                format!("Saved {} but failed to run: {}", name_clone, error),
-                                cx,
-                            );
-                            logging::log(
-                                "CHAT_SCRIPT_GEN",
-                                &format!(
-                                    "state=run_failed action={:?} script={} error={}",
-                                    action, name_clone, error
-                                ),
-                            );
-                        }
-                    })
-                });
-            })
-            .detach();
+            if let Some(ref callback) = self.on_run_script {
+                callback(script_path.clone(), cx);
+                self.set_script_generation_status(
+                    false,
+                    format!("Saved and running {}", script_name),
+                    cx,
+                );
+                logging::log(
+                    "CHAT_SCRIPT_GEN",
+                    &format!(
+                        "state=run_dispatched action={:?} path={}",
+                        action,
+                        script_path.display()
+                    ),
+                );
+            } else {
+                self.set_script_generation_status(
+                    true,
+                    format!("Saved {} but run action is unavailable", script_name),
+                    cx,
+                );
+                logging::log(
+                    "CHAT_SCRIPT_GEN",
+                    &format!(
+                        "state=run_dispatch_failed action={:?} path={} reason=missing_callback",
+                        action,
+                        script_path.display()
+                    ),
+                );
+            }
             return;
         }
 
diff --git a/src/prompts/chat/prompt.rs b/src/prompts/chat/prompt.rs
index 4ef4ac1aae4123a9bdd9771500998f87f424660b..78a8d8354e9e50914fdbcf1cc0fce0292b4feac2
--- a/src/prompts/chat/prompt.rs
+++ b/src/prompts/chat/prompt.rs
@@ -60,6 +60,9 @@
     pub(super) on_claude_code: Option<ChatClaudeCodeCallback>,
     // Callback for showing actions dialog (handled by parent)
     pub(super) on_show_actions: Option<ChatShowActionsCallback>,
+    // Callback for running a saved generated script via parent app pipeline
+    pub(super) on_run_script:
+        Option<Arc<dyn Fn(std::path::PathBuf, &mut Context<ChatPrompt>) + Send + Sync>>,
     // Stable UUID for Claude Code CLI session continuity within this prompt's lifetime.
     // Generated once at construction so all messages share the same session.
     pub(super) cli_session_id: String,
@@ -134,6 +137,7 @@
             on_configure: None,
             on_claude_code: None,
             on_show_actions: None,
+            on_run_script: None,
             cli_session_id: uuid::Uuid::new_v4().to_string(),
             pending_image: None,
             pending_image_render: None,
@@ -146,6 +150,15 @@
         self.on_show_actions = Some(callback);
     }
 
+    /// Set the callback for running a generated script path in the parent app.
+    pub fn with_run_script_callback(
+        mut self,
+        callback: impl Fn(std::path::PathBuf, &mut Context<Self>) + Send + Sync + 'static,
+    ) -> Self {
+        self.on_run_script = Some(Arc::new(callback));
+        self
+    }
+
     /// Start the cursor blink timer
     pub fn start_cursor_blink(&mut self, cx: &mut Context<Self>) {
         cx.spawn(async move |this, cx| {
diff --git a/src/prompts/chat/render_core.rs b/src/prompts/chat/render_core.rs
index 4e91d2d0ed474e69c143cd50e58e0491df58450b..7a066a4f6a2e6ac66e5e870f4a926cfbe0c56618
--- a/src/prompts/chat/render_core.rs
+++ b/src/prompts/chat/render_core.rs
@@ -32,10 +32,18 @@
         label: &'static str,
         shortcut: Option<&'static str>,
         action: ScriptGenerationAction,
-        accent_color: u32,
-        muted_color: u32,
+        footer_colors: PromptFooterColors,
         cx: &mut Context<Self>,
     ) -> AnyElement {
+        let button_font_size =
+            crate::components::prompt_footer::footer_button_font_size_px(&self.theme);
+        let hover_bg = rgba(crate::components::prompt_footer::footer_button_hover_rgba(
+            footer_colors,
+        ));
+        let active_bg = rgba(crate::components::prompt_footer::footer_button_active_rgba(
+            footer_colors,
+        ));
+
         div()
             .id(id)
             .flex()
@@ -46,9 +54,21 @@
             .py(px(2.0))
             .rounded(px(4.0))
             .cursor_pointer()
-            .child(div().text_xs().text_color(rgb(accent_color)).child(label))
+            .hover(move |d| d.bg(hover_bg))
+            .active(move |d| d.bg(active_bg))
+            .child(
+                div()
+                    .text_size(px(button_font_size))
+                    .text_color(rgb(footer_colors.accent))
+                    .child(label),
+            )
             .when_some(shortcut, |d, shortcut| {
-                d.child(div().text_xs().text_color(rgb(muted_color)).child(shortcut))
+                d.child(
+                    div()
+                        .text_size(px(button_font_size))
+                        .text_color(rgb(footer_colors.text_muted))
+                        .child(shortcut),
+                )
             })
             .on_click(cx.listener(move |this, _event, _window, cx| {
                 this.handle_script_generation_action(action, cx);
@@ -109,10 +129,9 @@
             self.render_script_generation_footer_button(
                 "chat-footer-primary-button",
                 "Save and Run",
-                None,
+                Some("⌘↵"),
                 ScriptGenerationAction::SaveAndRun,
-                footer_colors.accent,
-                footer_colors.text_muted,
+                footer_colors,
                 cx,
             )
         } else {
@@ -194,8 +213,7 @@
                     "Save",
                     None,
                     ScriptGenerationAction::Save,
-                    footer_colors.accent,
-                    footer_colors.text_muted,
+                    footer_colors,
                     cx,
                 ))
                 .child(self.render_script_generation_footer_button(
@@ -203,8 +221,7 @@
                     "Run",
                     None,
                     ScriptGenerationAction::Run,
-                    footer_colors.accent,
-                    footer_colors.text_muted,
+                    footer_colors,
                     cx,
                 ));
         }
@@ -356,7 +373,13 @@
                     }
                 }
                 ChatInputKeyAction::ToggleActions => this.toggle_actions_menu(cx),
-                ChatInputKeyAction::ContinueInChat => this.handle_continue_in_chat(cx),
+                ChatInputKeyAction::ContinueInChat => {
+                    if this.script_generation_mode {
+                        this.handle_script_generation_action(ScriptGenerationAction::SaveAndRun, cx);
+                    } else {
+                        this.handle_continue_in_chat(cx);
+                    }
+                }
                 ChatInputKeyAction::Submit => this.handle_submit(cx),
                 ChatInputKeyAction::InsertNewline => {
                     this.input.insert_char('\n');
@@ -618,7 +641,9 @@
             "Footer primary action should branch on script_generation_mode"
         );
         assert!(
-            normalized.contains("\"chat-footer-primary-button\",\"SaveandRun\",None,ScriptGenerationAction::SaveAndRun,"),
+            normalized.contains(
+                "\"chat-footer-primary-button\",\"SaveandRun\",Some(\"⌘↵\"),ScriptGenerationAction::SaveAndRun,"
+            ),
             "Script generation mode should render Save and Run as the primary footer action"
         );
         assert!(
@@ -647,4 +672,18 @@
             "Save and Run should only appear as the primary footer action slot"
         );
     }
+
+    #[test]
+    fn test_cmd_enter_runs_save_and_run_when_script_generation_mode_enabled() {
+        let content = fs::read_to_string("src/prompts/chat/render_core.rs")
+            .expect("Failed to read src/prompts/chat/render_core.rs");
+        let normalized: String = content.chars().filter(|c| !c.is_whitespace()).collect();
+
+        assert!(
+            normalized.contains(
+                "ChatInputKeyAction::ContinueInChat=>{ifthis.script_generation_mode{this.handle_script_generation_action(ScriptGenerationAction::SaveAndRun,cx);}else{this.handle_continue_in_chat(cx);}}"
+            ),
+            "Cmd+Enter should trigger SaveAndRun in script generation mode and ContinueInChat otherwise"
+        );
+    }
 }

tokens used
282,766
Implemented the three requested fixes in the script-generation ChatPrompt flow.

Changed files:
- `src/prompts/chat/prompt.rs`
  - Added `on_run_script` callback field and `with_run_script_callback(...)` builder.
- `src/prompts/chat/actions.rs`
  - Updated `handle_script_generation_action(...)` so `Run`/`Save and Run` dispatch to parent callback (app pipeline) instead of detached bun/kit process.
- `src/app_impl/prompt_ai.rs`
  - In `show_script_generation_chat(...)`, wired `with_run_script_callback(...)` to call `ScriptListApp::execute_script_by_path(...)` via app entity update.
- `src/prompts/chat/render_core.rs`
  - Added Cmd+Return behavior in key handler for script-generation mode:
    - `Cmd+Return` now triggers `ScriptGenerationAction::SaveAndRun`.
  - Updated script-generation footer buttons (`Save`, `Run`, `Save and Run`) to use PromptFooter-equivalent visual treatment.
  - Added/updated footer shortcut and key-behavior tests in this file.
- `src/components/prompt_footer.rs`
  - Exposed shared footer button style helpers:
    - `footer_button_font_size_px(...)`
    - `footer_button_hover_rgba(...)`
    - `footer_button_active_rgba(...)`
- `src/ai/script_generation.rs`
  - Removed `run_saved_script(...)` detached runner (no longer used by ChatPrompt run path).

Verification run:
- `cargo check -p script-kit-gpui`  
  - Passed.
- Attempted focused test:
  - `cargo test -p script-kit-gpui test_cmd_enter_runs_save_and_run_when_script_generation_mode_enabled -- --nocapture`
  - Blocked by unrelated pre-existing duplicate test module files:
    - `src/protocol/message/tests.rs` and `src/protocol/message/tests/mod.rs`
    - `src/designs/core/tests.rs` and `src/designs/core/tests/mod.rs`

How to test manually:
1. Launch app and open script-generation chat.
2. Generate a script response.
3. Click `Run` and confirm it executes via app flow (main window/script pipeline behavior, not detached background run).
4. Click `Save and Run` and confirm same.
5. Press `Cmd+Return` in script-generation mode and confirm it triggers `Save and Run`.
6. Confirm footer button visuals for `Save`, `Run`, `Save and Run` match standard PromptFooter button treatment (font sizing, padding, hover/active surface).

Risks / known gaps:
- Rust test execution is currently blocked by unrelated duplicate test-module files in the working tree, so targeted test runtime verification could not complete.
- I did not perform screenshot-based UI verification in this run.

Commits made:
- None.


==== exit @ 2026-02-08T07:35:42.172Z code=0 status=done ====
