==== spawn @ 2026-02-07T23:40:59.671Z ====
cmd: codex "exec" "--cd" "/Users/johnlindquist/dev/script-kit-gpui" "--model" "gpt-5.3-codex" "-c" "model_reasoning_effort=\"xhigh\"" "-c" "model_auto_compact_token_limit=120000" "-c" "developer_instructions=\"You are Codex implementer agent \\\"codex-fix-ai-feedback\\\".\\n\\n## Coordination\\nThis repo runs parallel agents in ONE working tree. Before editing any file, you MUST claim it.\\nCommands (run via shell):\\n  - View roster: ~/.claude/bin/swarm.ts status\\n  - Claim files (blocks until free): ~/.claude/bin/swarm.ts claim --wait --id codex-fix-ai-feedback path/to/file\\n  - Release: ~/.claude/bin/swarm.ts release --id codex-fix-ai-feedback path/to/file\\n  - Update status/notes: ~/.claude/bin/swarm.ts update --id codex-fix-ai-feedback --status in_progress --notes \\\"...\\\"\\nRules:\\n  - Never edit a file you haven't claimed.\\n  - Keep claims tight (claim only what you're actively changing).\\n  - If blocked, set status=blocked and say what you're waiting on.\\n  - When finished, set status=done and release claims.\\n\\n## Development practices (this code is maintained by AI agents)\\n  - Log state transitions with enough context to diagnose failures from logs alone.\\n  - Structured errors: include what was attempted, what failed, and current state.\\n  - Name things for grepability ‚Äî unique identifiers agents can find on the first search.\\n  - Every behavior change gets a test. Untested code is invisible to the next agent.\\n  - Test names describe the scenario: test_X_does_Y_when_Z.\\n  - Keep functions small and single-purpose. 500-line functions burn agent context.\\n  - Use types to encode constraints (enums > strings for errors).\\n\\n## CRITICAL: Parallel-safe verification\\n  - Other agents are modifying other files RIGHT NOW. Full test suites WILL show their failures.\\n  - ONLY run tests that cover YOUR changed files. Scope every test/check command:\\n    Rust: cargo test -p your-crate -- module::test_name | JS: npx jest your/file.test.ts\\n  - Do NOT run: cargo test (unscoped), cargo check (whole workspace), npm test (unscoped).\\n  - If a scoped test fails, it's YOUR bug ‚Äî fix it. If tests outside your scope fail, ignore them.\\n\\n## Git commit discipline\\n  - NEVER commit unverified work. Run tests/lints/type-checks FIRST. If it fails, fix it before committing.\\n  - A commit is a declaration: \\\"this works and here's the proof.\\\"\\n  - Commit FREQUENTLY ‚Äî after each meaningful unit of VERIFIED work, not just at the end.\\n  - A \\\"unit\\\" = one logical change that passes verification (new function, bug fix, refactor, test added).\\n  - NEVER batch an entire task into one giant commit. Small commits are searchable; big ones aren't.\\n  - Commit message format:\\n      Line 1: <type>(<scope>): <what changed> (imperative, max 72 chars)\\n      Line 3+: WHY this change was made, WHAT was verified, and HOW to test it.\\n    Types: feat, fix, refactor, test, docs, chore\\n    Example:\\n      feat(auth): add refresh token rotation\\n      \\n      Tokens now rotate on each refresh call to prevent replay attacks.\\n      The old token is invalidated immediately on rotation.\\n      \\n      Verified: cargo test --lib -- auth::refresh (4 tests pass)\\n      Verified: manual smoke test via curl ‚Äî token rotates, old token returns 401\\n  - The \\\"Verified:\\\" lines are REQUIRED. Future agents will read git log to understand\\n    what was tested and how to re-verify. This is the most valuable part of the message.\\n  - In your final message, list all commits you made with their hashes.\\n\\n## Time budget\\nYou have approximately 10 minutes. If your task is too broad to complete in time:\\n(1) Commit any verified progress.\\n(2) Run: ~/.claude/bin/swarm.ts update --id YOUR_ID --status needs_split --notes 'suggest: 1) sub-task-desc scope:files 2) sub-task-desc scope:files'.\\n(3) Exit cleanly. The dispatcher will read your suggestions and spawn narrower workers.\"" "--output-last-message" "/Users/johnlindquist/dev/script-kit-gpui/.ai/logs/codex-fix-ai-feedback.final.md" "--yolo" "You are agent codex-fix-ai-feedback.\n\nCurrent parallel-agent roster (read this first):\n```\nSWARM SNAPSHOT @ 2026-02-07T23:40:59.668Z\n- codex-fix-ai-feedback [starting] scope=src/app_execute/*.rs,src/app_impl/execution_scripts.rs task=MEDIUM FIX: In src/app_execute/builtin_execution.rs, lines 87,634,677,709,752,796 - several AI command failure paths lo‚Ä¶\n- codex-fix-stable-model-ids [in_progress] scope=src/actions/builders/notes.rs task=MEDIUM FIX: In src/actions/builders/notes.rs, lines 177,192,203 - index-based IDs like 'last_used_{idx}' and 'model_{id‚Ä¶\n  claims: src/actions/builders/notes.rs\n  notes: Claiming notes.rs and implementing stable model/preset action IDs\n```\n\nYour assignment:\n- Task: MEDIUM FIX: In src/app_execute/builtin_execution.rs, lines 87,634,677,709,752,796 - several AI command failure paths log errors without user feedback. Add user-visible error feedback (toast or HUD) for AI command execution failures. Also fix M13: add 'builtin-open-ai' and 'builtin-open-notes' to NO_MAIN_WINDOW_BUILTINS list in src/app_impl/execution_scripts.rs:317. After fix, run cargo check && cargo clippy --all-targets -- -D warnings\n- Scope: src/app_execute/*.rs,src/app_impl/execution_scripts.rs\n\nOperating constraints:\n- Single working tree (no worktrees, no patches).\n- You MUST claim files before editing (~/.claude/bin/swarm.ts claim --wait ...).\n\nDeliverables:\n- Make the code changes required by the task.\n- Run the most relevant tests/linters.\n- In your FINAL message, include: changed files, how to test, and any risks/known gaps."

OpenAI Codex v0.98.0 (research preview)
--------
workdir: /Users/johnlindquist/dev/script-kit-gpui
model: gpt-5.3-codex
provider: openai
approval: never
sandbox: danger-full-access
reasoning effort: xhigh
reasoning summaries: auto
session id: 019c3a7a-e9cb-7db3-bbd2-26a9cb9b00ed
--------
user
You are agent codex-fix-ai-feedback.

Current parallel-agent roster (read this first):
```
SWARM SNAPSHOT @ 2026-02-07T23:40:59.668Z
- codex-fix-ai-feedback [starting] scope=src/app_execute/*.rs,src/app_impl/execution_scripts.rs task=MEDIUM FIX: In src/app_execute/builtin_execution.rs, lines 87,634,677,709,752,796 - several AI command failure paths lo‚Ä¶
- codex-fix-stable-model-ids [in_progress] scope=src/actions/builders/notes.rs task=MEDIUM FIX: In src/actions/builders/notes.rs, lines 177,192,203 - index-based IDs like 'last_used_{idx}' and 'model_{id‚Ä¶
  claims: src/actions/builders/notes.rs
  notes: Claiming notes.rs and implementing stable model/preset action IDs
```

Your assignment:
- Task: MEDIUM FIX: In src/app_execute/builtin_execution.rs, lines 87,634,677,709,752,796 - several AI command failure paths log errors without user feedback. Add user-visible error feedback (toast or HUD) for AI command execution failures. Also fix M13: add 'builtin-open-ai' and 'builtin-open-notes' to NO_MAIN_WINDOW_BUILTINS list in src/app_impl/execution_scripts.rs:317. After fix, run cargo check && cargo clippy --all-targets -- -D warnings
- Scope: src/app_execute/*.rs,src/app_impl/execution_scripts.rs

Operating constraints:
- Single working tree (no worktrees, no patches).
- You MUST claim files before editing (~/.claude/bin/swarm.ts claim --wait ...).

Deliverables:
- Make the code changes required by the task.
- Run the most relevant tests/linters.
- In your FINAL message, include: changed files, how to test, and any risks/known gaps.
warning: Under-development features enabled: responses_websockets. Under-development features are incomplete and may behave unpredictably. To suppress this warning, set `suppress_unstable_features_warning = true` in /Users/johnlindquist/.codex/config.toml.
mcp: deepwiki starting
mcp: deepwiki ready
mcp startup: ready: deepwiki

thinking
**Resolving verification scope conflict**
codex
I‚Äôm implementing the AI failure feedback fix in `src/app_execute/builtin_execution.rs` plus the `NO_MAIN_WINDOW_BUILTINS` update in `src/app_impl/execution_scripts.rs`. I‚Äôll first claim those files in swarm, inspect each failure path, then patch and run scoped `cargo check`/`cargo clippy` verification.

thinking
**Planning combined status commands**
exec
/bin/zsh -lc '~/.claude/bin/swarm.ts status && ~/.claude/bin/swarm.ts update --id codex-fix-ai-feedback --status in_progress --notes "Claiming builtin execution files and implementing AI error user feedback + NO_MAIN_WINDOW_BUILTINS entries"' in /Users/johnlindquist/dev/script-kit-gpui succeeded in 50ms:
Repo: /Users/johnlindquist/dev/script-kit-gpui
Updated: 2026-02-07T23:41:16.446Z

Active agents (2):
codex-fix-ai-feedback [in_progress] codex/gpt-5.3-codex/exec
  task: MEDIUM FIX: In src/app_execute/builtin_execution.rs, lines 87,634,677,709,752,796 - several AI command failure paths lo‚Ä¶
  scope: src/app_execute/*.rs,src/app_impl/execution_scripts.rs
  claims: (none)
  notes: spawned codex (exec)

codex-fix-stable-model-ids [in_progress] codex/gpt-5.3-codex/exec
  task: MEDIUM FIX: In src/actions/builders/notes.rs, lines 177,192,203 - index-based IDs like 'last_used_{idx}' and 'model_{id‚Ä¶
  scope: src/actions/builders/notes.rs
  claims(1): src/actions/builders/notes.rs
  notes: Claiming notes.rs and implementing stable model/preset action IDs

Inactive agents (212):
- codex-accessibility [done] done. exit=0. final=.ai/logs/codex-accessibility.final.md. See final message file.
- codex-action-labels [failed] failed. exit=1. final=.ai/logs/codex-action-labels.final.md.
- codex-actions-audit [failed] failed. exit=1. final=.ai/logs/codex-actions-audit.final.md. See final message file.

thinking
**Preparing claim files for testing**
exec
/bin/zsh -lc '~/.claude/bin/swarm.ts claim --wait --id codex-fix-ai-feedback src/app_execute/builtin_execution.rs src/app_impl/execution_scripts.rs' in /Users/johnlindquist/dev/script-kit-gpui succeeded in 52ms:
Claimed for codex-fix-ai-feedback: src/app_execute/builtin_execution.rs, src/app_impl/execution_scripts.rs
codex
I‚Äôve claimed both target files. Next I‚Äôm mapping the exact failure branches in `builtin_execution.rs` and checking current feedback patterns so we can add consistent user-visible errors without changing behavior outside those paths.

thinking
**Planning parallel file processing**
exec
/bin/zsh -lc "nl -ba src/app_execute/builtin_execution.rs | sed -n '1,140p'; echo '---'; nl -ba src/app_execute/builtin_execution.rs | sed -n '600,840p'; echo '---'; nl -ba src/app_impl/execution_scripts.rs | sed -n '270,360p'" in /Users/johnlindquist/dev/script-kit-gpui succeeded in 51ms:
     1	impl ScriptListApp {
     2	    fn system_action_feedback_message(
     3	        &self,
     4	        action_type: &builtins::SystemActionType,
     5	    ) -> Option<String> {
     6	        let dark_mode_enabled = if matches!(action_type, builtins::SystemActionType::ToggleDarkMode)
     7	        {
     8	            system_actions::is_dark_mode().ok()
     9	        } else {
    10	            None
    11	        };
    12	
    13	        builtins::system_action_hud_message(*action_type, dark_mode_enabled)
    14	    }
    15	
    16	    fn execute_builtin(&mut self, entry: &builtins::BuiltInEntry, cx: &mut Context<Self>) {
    17	        logging::log(
    18	            "EXEC",
    19	            &format!("Executing built-in: {} (id: {})", entry.name, entry.id),
    20	        );

thinking
**Investigating AI error handling**
codex
I found all targeted spots: the AI command paths mostly call `ai::open_ai_window(cx)` and only log on failure, with no toast/HUD. I‚Äôm now checking the surrounding AI command branches to add one consistent user-facing error path for each failure.

thinking
**Searching code for key terms**
exec
/bin/zsh -lc 'rg -n "open_ai_window|Failed to open AI|AiCommandType|open-notes|open-ai|builtin-open-ai|builtin-open-notes" src/app_execute/builtin_execution.rs src/app_impl/execution_scripts.rs' in /Users/johnlindquist/dev/script-kit-gpui succeeded in 52ms:
src/app_execute/builtin_execution.rs:284:                        if let Err(e) = ai::open_ai_window(cx) {
src/app_execute/builtin_execution.rs:285:                            logging::log("ERROR", &format!("Failed to open AI window: {}", e));
src/app_execute/builtin_execution.rs:289:                                        format!("Failed to open AI: {}", e),
src/app_execute/builtin_execution.rs:541:                use builtins::AiCommandType;
src/app_execute/builtin_execution.rs:549:                    AiCommandType::OpenAi | AiCommandType::NewConversation => {
src/app_execute/builtin_execution.rs:551:                        if let Err(e) = ai::open_ai_window(cx) {
src/app_execute/builtin_execution.rs:555:                                    format!("Failed to open AI: {}", e),
src/app_execute/builtin_execution.rs:564:                    AiCommandType::ClearConversation => {
src/app_execute/builtin_execution.rs:569:                                if let Err(e) = ai::open_ai_window(cx) {
src/app_execute/builtin_execution.rs:613:                    AiCommandType::SendScreenToAi => {
src/app_execute/builtin_execution.rs:634:                                if let Err(e) = ai::open_ai_window(cx) {
src/app_execute/builtin_execution.rs:635:                                    logging::log("ERROR", &format!("Failed to open AI: {}", e));
src/app_execute/builtin_execution.rs:655:                    AiCommandType::SendFocusedWindowToAi => {
src/app_execute/builtin_execution.rs:677:                                if let Err(e) = ai::open_ai_window(cx) {
src/app_execute/builtin_execution.rs:678:                                    logging::log("ERROR", &format!("Failed to open AI: {}", e));
src/app_execute/builtin_execution.rs:697:                    AiCommandType::SendSelectedTextToAi => {
src/app_execute/builtin_execution.rs:709:                                if let Err(e) = ai::open_ai_window(cx) {
src/app_execute/builtin_execution.rs:710:                                    logging::log("ERROR", &format!("Failed to open AI: {}", e));
src/app_execute/builtin_execution.rs:743:                    AiCommandType::SendBrowserTabToAi => {
src/app_execute/builtin_execution.rs:752:                                if let Err(e) = ai::open_ai_window(cx) {

thinking
**Inspecting toast usage**
exec
/bin/zsh -lc "nl -ba src/app_execute/builtin_execution.rs | sed -n '220,590p'" in /Users/johnlindquist/dev/script-kit-gpui succeeded in 51ms:
   220	                        self.pending_placeholder = Some("Search windows...".to_string());
   221	                        self.current_view = AppView::WindowSwitcherView {
   222	                            filter: String::new(),
   223	                            selected_index: 0,
   224	                        };
   225	                        self.hovered_index = None;
   226	                        // Mark as opened from main menu - ESC will return to main menu
   227	                        self.opened_from_main_menu = true;
   228	                        // Use standard height for window switcher view
   229	                        resize_to_view_sync(ViewType::ScriptList, 0);
   230	                        // Focus the main filter input so cursor blinks and typing works
   231	                        self.pending_focus = Some(FocusTarget::MainFilter);
   232	                        self.focused_input = FocusedInput::MainFilter;
   233	                    }
   234	                    Err(e) => {
   235	                        logging::log("ERROR", &format!("Failed to list windows: {}", e));
   236	                        self.toast_manager.push(
   237	                            components::toast::Toast::error(
   238	                                format!("Failed to list windows: {}", e),
   239	                                &self.theme,

thinking
**Reviewing AI failure feedback and builtins**
exec
/bin/zsh -lc "rg -n \"builtin_execution|NO_MAIN_WINDOW_BUILTINS|AiCommandType|Failed to open AI|toast_manager|execute_by_command_id_or_path|#\\[test\\]\" src/app_execute src/app_impl" in /Users/johnlindquist/dev/script-kit-gpui succeeded in 51ms:
src/app_execute/builtin_confirmation.rs:77:                            self.toast_manager.push(
src/app_execute/builtin_confirmation.rs:178:                            self.toast_manager.push(
src/app_execute/builtin_confirmation.rs:193:                    self.toast_manager.push(
src/app_execute/utility_views.rs:45:                self.toast_manager.push(
src/app_execute/utility_views.rs:307:                self.toast_manager.push(
src/app_execute/utility_views.rs:450:        self.toast_manager.push(
src/app_impl/startup_new_actions.rs:161:                                this.toast_manager.push(components::toast::Toast::info(
src/app_impl/startup_new_actions.rs:174:                                this.toast_manager.push(components::toast::Toast::info(
src/app_execute/execution_helpers.rs:31:            self.toast_manager.push(
src/app_execute/execution_helpers.rs:151:            self.toast_manager.push(
src/app_execute/execution_helpers.rs:215:                        self.toast_manager.push(
src/app_execute/execution_helpers.rs:225:                        self.toast_manager.push(
src/app_execute/execution_helpers.rs:241:                        self.toast_manager.push(
src/app_execute/execution_helpers.rs:258:                self.toast_manager.push(
src/app_execute/execution_helpers.rs:290:            self.toast_manager.push(
src/app_execute/execution_helpers.rs:302:            self.toast_manager.push(
src/app_execute/execution_helpers.rs:338:                self.toast_manager.push(
src/app_execute/execution_helpers.rs:365:                self.toast_manager.push(
src/app_impl/selection_fallback.rs:388:    #[test]
src/app_impl/selection_fallback.rs:399:    #[test]

thinking
**Inspecting module structure**
codex
There‚Äôs a duplicated split-module copy under `src/app_execute/builtin_execution/feature_02.rs` with the same AI command logic. I‚Äôm checking whether that file is live code to avoid fixing one path while leaving the compiled path unchanged.

thinking
**Inspecting module declarations**
exec
/bin/zsh -lc "ls -la src/app_execute; echo '---'; ls -la src/app_execute/builtin_execution; echo '---'; rg -n \"mod builtin_execution|feature_0|include"'!|pub mod app_execute|execute_builtin" src/app_execute src/lib.rs src/main.rs' in /Users/johnlindquist/dev/script-kit-gpui succeeded in 51ms:
total 224
drwxr-xr-x    7 johnlindquist  staff    224 Feb  7 16:00 .
drwxr-xr-x  145 johnlindquist  staff   4640 Feb  7 16:08 ..
-rw-r--r--    1 johnlindquist  staff  10019 Feb  7 09:31 builtin_confirmation.rs
drwxr-xr-x    5 johnlindquist  staff    160 Feb  7 09:36 builtin_execution
-rw-r--r--    1 johnlindquist  staff  58055 Feb  7 16:00 builtin_execution.rs
-rw-r--r--    1 johnlindquist  staff  18250 Feb  7 09:31 execution_helpers.rs
-rw-r--r--    1 johnlindquist  staff  18290 Feb  7 09:31 utility_views.rs
---
total 112
drwxr-xr-x  5 johnlindquist  staff    160 Feb  7 09:36 .
drwxr-xr-x  7 johnlindquist  staff    224 Feb  7 16:00 ..
-rw-r--r--  1 johnlindquist  staff  19567 Feb  7 09:36 feature_01.rs
-rw-r--r--  1 johnlindquist  staff  18613 Feb  7 09:36 feature_02.rs
-rw-r--r--  1 johnlindquist  staff  14865 Feb  7 09:36 feature_03.rs
---
src/main.rs:260:include!("main_sections/deeplink.rs");
src/main.rs:261:include!("main_sections/window_visibility.rs");
src/main.rs:262:include!("main_sections/fallbacks.rs");
src/main.rs:263:include!("main_sections/fonts.rs");

thinking
**Inspecting command execution organization**
exec
/bin/zsh -lc "nl -ba src/app_execute.rs | sed -n '1,220p'" in /Users/johnlindquist/dev/script-kit-gpui succeeded in 51ms:
     1	// App execution methods split into sub-files for maintainability
     2	include!("app_execute/builtin_execution.rs");
     3	include!("app_execute/execution_helpers.rs");
     4	include!("app_execute/utility_views.rs");
     5	include!("app_execute/builtin_confirmation.rs");

thinking
**Planning targeted code and test updates**
exec
/bin/zsh -lc "nl -ba src/app_impl/execution_scripts.rs | sed -n '1,420p'" in /Users/johnlindquist/dev/script-kit-gpui succeeded in 50ms:
     1	use super::*;
     2	
     3	impl ScriptListApp {
     4	    pub(crate) fn execute_scriptlet(&mut self, scriptlet: &scripts::Scriptlet, cx: &mut Context<Self>) {
     5	        logging::log(
     6	            "EXEC",
     7	            &format!(
     8	                "Executing scriptlet: {} (tool: {})",
     9	                scriptlet.name, scriptlet.tool
    10	            ),
    11	        );
    12	
    13	        let tool = scriptlet.tool.to_lowercase();
    14	
    15	        // TypeScript/Kit scriptlets need to run interactively (they may use SDK prompts)
    16	        // These should be spawned like regular scripts, not run synchronously
    17	        if matches!(tool.as_str(), "kit" | "ts" | "bun" | "deno" | "js") {
    18	            logging::log(
    19	                "EXEC",
    20	                &format!(

thinking
**Inspecting module include order**
exec
/bin/zsh -lc "nl -ba src/app_impl/mod.rs | sed -n '1,260p'" in /Users/johnlindquist/dev/script-kit-gpui succeeded in 51ms:
     1	#[path = "startup.rs"]
     2	mod startup;
     3	#[path = "theme_focus.rs"]
     4	mod theme_focus;
     5	#[path = "refresh_scriptlets.rs"]
     6	mod refresh_scriptlets;
     7	#[path = "filtering_cache.rs"]
     8	mod filtering_cache;
     9	#[path = "selection_fallback.rs"]
    10	mod selection_fallback;
    11	#[path = "filter_input_core.rs"]
    12	mod filter_input_core;
    13	#[path = "filter_input_change.rs"]
    14	mod filter_input_change;
    15	#[path = "filter_input_updates.rs"]
    16	mod filter_input_updates;
    17	#[path = "ui_window.rs"]
    18	mod ui_window;
    19	#[path = "actions_toggle.rs"]
    20	mod actions_toggle;

thinking
**Inspecting test module declarations**
exec
/bin/zsh -lc "nl -ba src/app_impl/tests.rs | sed -n '1,260p'" in /Users/johnlindquist/dev/script-kit-gpui succeeded in 51ms:
     1	#[cfg(test)]
     2	mod app_impl_state_sync_tests {
     3	    use super::{calculate_fallback_error_message, ScriptListApp};
     4	
     5	    #[test]
     6	    fn test_sync_builtin_query_state_updates_query_and_selection_when_changed() {
     7	        let mut query = String::from("old");
     8	        let mut selected_index = 3;
     9	
    10	        let changed =
    11	            ScriptListApp::sync_builtin_query_state(&mut query, &mut selected_index, "new");
    12	
    13	        assert!(changed);
    14	        assert_eq!(query, "new");
    15	        assert_eq!(selected_index, 0);
    16	    }
    17	
    18	    #[test]
    19	    fn test_sync_builtin_query_state_noop_when_query_is_unchanged() {
    20	        let mut query = String::from("same");

thinking
**Planning helper methods and targeted tests**
üåê Searching the web...
üåê Searched the web

thinking
**Planning exec_command usage**
exec
/bin/zsh -lc 'rg -n "NO_MAIN_WINDOW_BUILTINS|builtin-open-ai|builtin-open-notes|builtin-ai-chat|builtin-notes" src' in /Users/johnlindquist/dev/script-kit-gpui succeeded in 51ms:
src/builtins/part_001_entries/entries_000.rs:34:        "builtin-ai-chat",
src/builtins/part_001_entries/entries_000.rs:54:        "builtin-notes",
src/builtins/part_001_entries/entries_002.rs:6:        "builtin-open-notes",
src/builtins/part_001_entries/entries_002.rs:46:        "builtin-open-ai",
src/builtins/tests/part_000.rs:57:        let ai_chat = entries.iter().find(|e| e.id == "builtin-ai-chat");
src/builtins/tests/part_000.rs:80:        assert!(entries.iter().any(|e| e.id == "builtin-ai-chat"));
src/builtins/tests/part_000.rs:81:        assert!(entries.iter().any(|e| e.id == "builtin-notes"));
src/builtins/tests/part_000.rs:98:        assert!(entries.iter().any(|e| e.id == "builtin-ai-chat"));
src/builtins/tests/part_000.rs:99:        assert!(entries.iter().any(|e| e.id == "builtin-notes"));
src/builtins/tests/part_000.rs:115:        assert!(entries.iter().any(|e| e.id == "builtin-ai-chat"));
src/builtins/tests/part_000.rs:116:        assert!(entries.iter().any(|e| e.id == "builtin-notes"));
src/builtins/tests/part_000.rs:134:        assert!(entries.iter().any(|e| e.id == "builtin-ai-chat"));
src/builtins/tests/part_000.rs:135:        assert!(entries.iter().any(|e| e.id == "builtin-notes"));
src/builtins/tests/part_000.rs:282:        assert!(entries.iter().any(|e| e.id == "builtin-open-notes"));
src/builtins/tests/part_000.rs:292:        let open_notes = entries.iter().find(|e| e.id == "builtin-open-notes");
src/builtins/tests/part_000.rs:293:        assert!(open_notes.is_some(), "builtin-open-notes should exist");
src/builtins/tests/part_000.rs:299:        let open_ai = entries.iter().find(|e| e.id == "builtin-open-ai");
src/builtins/tests/part_000.rs:300:        assert!(open_ai.is_some(), "builtin-open-ai should exist");
src/builtins/tests/part_001.rs:71:        let notes = entries.iter().find(|e| e.id == "builtin-notes").unwrap();
src/scripts_tests/chunk_12.rs:207:            id: "builtin-ai-chat".to_string(),

thinking
**Assessing test coverage for command execution**
codex
I confirmed only one live `NO_MAIN_WINDOW_BUILTINS` list exists, and it currently misses `builtin-open-ai` / `builtin-open-notes`. I‚Äôm preparing the patch now: add a small reusable AI error-toast helper and wire all missing AI failure branches to it, then update that builtins list.

thinking
**Adding toast notifications to error branches**
file update
M /Users/johnlindquist/dev/script-kit-gpui/src/app_execute/builtin_execution.rs
@@ -635,2 +635,10 @@
                                     logging::log("ERROR", &format!("Failed to open AI: {}", e));
+                                    self.toast_manager.push(
+                                        components::toast::Toast::error(
+                                            format!("Failed to open AI: {}", e),
+                                            &self.theme,
+                                        )
+                                        .duration_ms(Some(5000)),
+                                    );
+                                    cx.notify();
                                 } else {
@@ -678,2 +686,10 @@
                                     logging::log("ERROR", &format!("Failed to open AI: {}", e));
+                                    self.toast_manager.push(
+                                        components::toast::Toast::error(
+                                            format!("Failed to open AI: {}", e),
+                                            &self.theme,
+                                        )
+                                        .duration_ms(Some(5000)),
+                                    );
+                                    cx.notify();
                                 } else {
@@ -710,2 +726,10 @@
                                     logging::log("ERROR", &format!("Failed to open AI: {}", e));
+                                    self.toast_manager.push(
+                                        components::toast::Toast::error(
+                                            format!("Failed to open AI: {}", e),
+                                            &self.theme,
+                                        )
+                                        .duration_ms(Some(5000)),
+                                    );
+                                    cx.notify();
                                 } else {
@@ -753,2 +777,10 @@
                                     logging::log("ERROR", &format!("Failed to open AI: {}", e));
+                                    self.toast_manager.push(
+                                        components::toast::Toast::error(
+                                            format!("Failed to open AI: {}", e),
+                                            &self.theme,
+                                        )
+                                        .duration_ms(Some(5000)),
+                                    );
+                                    cx.notify();
                                 } else {
@@ -797,2 +829,9 @@
                             logging::log("ERROR", &format!("Failed to open AI: {}", e));
+                            self.toast_manager.push(
+                                components::toast::Toast::error(
+                                    format!("Failed to open AI: {}", e),
+                                    &self.theme,
+                                )
+                                .duration_ms(Some(5000)),
+                            );
                         }
apply_patch(auto_approved=true) exited 0 in 14ms:
Success. Updated the following files:
M src/app_execute/builtin_execution.rs
file update:
diff --git a/src/app_execute/builtin_execution.rs b/src/app_execute/builtin_execution.rs
index ea07c5b2c4e5ef82ea1337d249f517425db711fa..0f764c65a6e69513eed92f89b3a7722fc8ca1378
--- a/src/app_execute/builtin_execution.rs
+++ b/src/app_execute/builtin_execution.rs
@@ -633,6 +633,14 @@
                                 );
                                 if let Err(e) = ai::open_ai_window(cx) {
                                     logging::log("ERROR", &format!("Failed to open AI: {}", e));
+                                    self.toast_manager.push(
+                                        components::toast::Toast::error(
+                                            format!("Failed to open AI: {}", e),
+                                            &self.theme,
+                                        )
+                                        .duration_ms(Some(5000)),
+                                    );
+                                    cx.notify();
                                 } else {
                                     // Set input with the screenshot context
                                     ai::set_ai_input_with_image(cx, &message, &base64_data, false);
@@ -676,6 +684,14 @@
                                 );
                                 if let Err(e) = ai::open_ai_window(cx) {
                                     logging::log("ERROR", &format!("Failed to open AI: {}", e));
+                                    self.toast_manager.push(
+                                        components::toast::Toast::error(
+                                            format!("Failed to open AI: {}", e),
+                                            &self.theme,
+                                        )
+                                        .duration_ms(Some(5000)),
+                                    );
+                                    cx.notify();
                                 } else {
                                     ai::set_ai_input_with_image(cx, &message, &base64_data, false);
                                 }
@@ -708,6 +724,14 @@
                                 );
                                 if let Err(e) = ai::open_ai_window(cx) {
                                     logging::log("ERROR", &format!("Failed to open AI: {}", e));
+                                    self.toast_manager.push(
+                                        components::toast::Toast::error(
+                                            format!("Failed to open AI: {}", e),
+                                            &self.theme,
+                                        )
+                                        .duration_ms(Some(5000)),
+                                    );
+                                    cx.notify();
                                 } else {
                                     ai::set_ai_input(cx, &message, false);
                                 }
@@ -751,6 +775,14 @@
                                 logging::log("EXEC", &format!("Browser URL captured: {}", url));
                                 if let Err(e) = ai::open_ai_window(cx) {
                                     logging::log("ERROR", &format!("Failed to open AI: {}", e));
+                                    self.toast_manager.push(
+                                        components::toast::Toast::error(
+                                            format!("Failed to open AI: {}", e),
+                                            &self.theme,
+                                        )
+                                        .duration_ms(Some(5000)),
+                                    );
+                                    cx.notify();
                                 } else {
                                     ai::set_ai_input(cx, &message, false);
                                 }
@@ -795,6 +827,13 @@
                         );
                         if let Err(e) = ai::open_ai_window(cx) {
                             logging::log("ERROR", &format!("Failed to open AI: {}", e));
+                            self.toast_manager.push(
+                                components::toast::Toast::error(
+                                    format!("Failed to open AI: {}", e),
+                                    &self.theme,
+                                )
+                                .duration_ms(Some(5000)),
+                            );
                         }
                         cx.notify();
                     }

file update:
diff --git a/src/app_execute/builtin_execution.rs b/src/app_execute/builtin_execution.rs
index ea07c5b2c4e5ef82ea1337d249f517425db711fa..0f764c65a6e69513eed92f89b3a7722fc8ca1378
--- a/src/app_execute/builtin_execution.rs
+++ b/src/app_execute/builtin_execution.rs
@@ -633,6 +633,14 @@
                                 );
                                 if let Err(e) = ai::open_ai_window(cx) {
                                     logging::log("ERROR", &format!("Failed to open AI: {}", e));
+                                    self.toast_manager.push(
+                                        components::toast::Toast::error(
+                                            format!("Failed to open AI: {}", e),
+                                            &self.theme,
+                                        )
+                                        .duration_ms(Some(5000)),
+                                    );
+                                    cx.notify();
                                 } else {
                                     // Set input with the screenshot context
                                     ai::set_ai_input_with_image(cx, &message, &base64_data, false);
@@ -676,6 +684,14 @@
                                 );
                                 if let Err(e) = ai::open_ai_window(cx) {
                                     logging::log("ERROR", &format!("Failed to open AI: {}", e));
+                                    self.toast_manager.push(
+                                        components::toast::Toast::error(
+                                            format!("Failed to open AI: {}", e),
+                                            &self.theme,
+                                        )
+                                        .duration_ms(Some(5000)),
+                                    );
+                                    cx.notify();
                                 } else {
                                     ai::set_ai_input_with_image(cx, &message, &base64_data, false);
                                 }
@@ -708,6 +724,14 @@
                                 );
                                 if let Err(e) = ai::open_ai_window(cx) {
                                     logging::log("ERROR", &format!("Failed to open AI: {}", e));
+                                    self.toast_manager.push(
+                                        components::toast::Toast::error(
+                                            format!("Failed to open AI: {}", e),
+                                            &self.theme,
+                                        )
+                                        .duration_ms(Some(5000)),
+                                    );
+                                    cx.notify();
                                 } else {
                                     ai::set_ai_input(cx, &message, false);
                                 }
@@ -751,6 +775,14 @@
                                 logging::log("EXEC", &format!("Browser URL captured: {}", url));
                                 if let Err(e) = ai::open_ai_window(cx) {
                                     logging::log("ERROR", &format!("Failed to open AI: {}", e));
+                                    self.toast_manager.push(
+                                        components::toast::Toast::error(
+                                            format!("Failed to open AI: {}", e),
+                                            &self.theme,
+                                        )
+                                        .duration_ms(Some(5000)),
+                                    );
+                                    cx.notify();
                                 } else {
                                     ai::set_ai_input(cx, &message, false);
                                 }
@@ -795,6 +827,13 @@
                         );
                         if let Err(e) = ai::open_ai_window(cx) {
                             logging::log("ERROR", &format!("Failed to open AI: {}", e));
+                            self.toast_manager.push(
+                                components::toast::Toast::error(
+                                    format!("Failed to open AI: {}", e),
+                                    &self.theme,
+                                )
+                                .duration_ms(Some(5000)),
+                            );
                         }
                         cx.notify();
                     }


thinking
**Preparing execution scripts patch**
file update
M /Users/johnlindquist/dev/script-kit-gpui/src/app_impl/execution_scripts.rs
@@ -318,3 +318,5 @@
             "builtin-ai-chat",
+            "builtin-open-ai",
             "builtin-notes",
+            "builtin-open-notes",
             "builtin-new-note",
apply_patch(auto_approved=true) exited 0 in 17ms:
Success. Updated the following files:
M src/app_impl/execution_scripts.rs
file update:
diff --git a/src/app_execute/builtin_execution.rs b/src/app_execute/builtin_execution.rs
index ea07c5b2c4e5ef82ea1337d249f517425db711fa..0f764c65a6e69513eed92f89b3a7722fc8ca1378
--- a/src/app_execute/builtin_execution.rs
+++ b/src/app_execute/builtin_execution.rs
@@ -633,6 +633,14 @@
                                 );
                                 if let Err(e) = ai::open_ai_window(cx) {
                                     logging::log("ERROR", &format!("Failed to open AI: {}", e));
+                                    self.toast_manager.push(
+                                        components::toast::Toast::error(
+                                            format!("Failed to open AI: {}", e),
+                                            &self.theme,
+                                        )
+                                        .duration_ms(Some(5000)),
+                                    );
+                                    cx.notify();
                                 } else {
                                     // Set input with the screenshot context
                                     ai::set_ai_input_with_image(cx, &message, &base64_data, false);
@@ -676,6 +684,14 @@
                                 );
                                 if let Err(e) = ai::open_ai_window(cx) {
                                     logging::log("ERROR", &format!("Failed to open AI: {}", e));
+                                    self.toast_manager.push(
+                                        components::toast::Toast::error(
+                                            format!("Failed to open AI: {}", e),
+                                            &self.theme,
+                                        )
+                                        .duration_ms(Some(5000)),
+                                    );
+                                    cx.notify();
                                 } else {
                                     ai::set_ai_input_with_image(cx, &message, &base64_data, false);
                                 }
@@ -708,6 +724,14 @@
                                 );
                                 if let Err(e) = ai::open_ai_window(cx) {
                                     logging::log("ERROR", &format!("Failed to open AI: {}", e));
+                                    self.toast_manager.push(
+                                        components::toast::Toast::error(
+                                            format!("Failed to open AI: {}", e),
+                                            &self.theme,
+                                        )
+                                        .duration_ms(Some(5000)),
+                                    );
+                                    cx.notify();
                                 } else {
                                     ai::set_ai_input(cx, &message, false);
                                 }
@@ -751,6 +775,14 @@
                                 logging::log("EXEC", &format!("Browser URL captured: {}", url));
                                 if let Err(e) = ai::open_ai_window(cx) {
                                     logging::log("ERROR", &format!("Failed to open AI: {}", e));
+                                    self.toast_manager.push(
+                                        components::toast::Toast::error(
+                                            format!("Failed to open AI: {}", e),
+                                            &self.theme,
+                                        )
+                                        .duration_ms(Some(5000)),
+                                    );
+                                    cx.notify();
                                 } else {
                                     ai::set_ai_input(cx, &message, false);
                                 }
@@ -795,6 +827,13 @@
                         );
                         if let Err(e) = ai::open_ai_window(cx) {
                             logging::log("ERROR", &format!("Failed to open AI: {}", e));
+                            self.toast_manager.push(
+                                components::toast::Toast::error(
+                                    format!("Failed to open AI: {}", e),
+                                    &self.theme,
+                                )
+                                .duration_ms(Some(5000)),
+                            );
                         }
                         cx.notify();
                     }
diff --git a/src/app_impl/execution_scripts.rs b/src/app_impl/execution_scripts.rs
index ac99cc20952af2f8c39e301b7740e55cec8f394e..bc029cee42a4ec93c091ce0ea7912cf905c3011a
--- a/src/app_impl/execution_scripts.rs
+++ b/src/app_impl/execution_scripts.rs
@@ -316,7 +316,9 @@
         // Builtins that open their own windows and don't need main window
         const NO_MAIN_WINDOW_BUILTINS: &[&str] = &[
             "builtin-ai-chat",
+            "builtin-open-ai",
             "builtin-notes",
+            "builtin-open-notes",
             "builtin-new-note",
             "builtin-search-notes",
             "builtin-quick-capture",

file update:
diff --git a/src/app_execute/builtin_execution.rs b/src/app_execute/builtin_execution.rs
index ea07c5b2c4e5ef82ea1337d249f517425db711fa..0f764c65a6e69513eed92f89b3a7722fc8ca1378
--- a/src/app_execute/builtin_execution.rs
+++ b/src/app_execute/builtin_execution.rs
@@ -633,6 +633,14 @@
                                 );
                                 if let Err(e) = ai::open_ai_window(cx) {
                                     logging::log("ERROR", &format!("Failed to open AI: {}", e));
+                                    self.toast_manager.push(
+                                        components::toast::Toast::error(
+                                            format!("Failed to open AI: {}", e),
+                                            &self.theme,
+                                        )
+                                        .duration_ms(Some(5000)),
+                                    );
+                                    cx.notify();
                                 } else {
                                     // Set input with the screenshot context
                                     ai::set_ai_input_with_image(cx, &message, &base64_data, false);
@@ -676,6 +684,14 @@
                                 );
                                 if let Err(e) = ai::open_ai_window(cx) {
                                     logging::log("ERROR", &format!("Failed to open AI: {}", e));
+                                    self.toast_manager.push(
+                                        components::toast::Toast::error(
+                                            format!("Failed to open AI: {}", e),
+                                            &self.theme,
+                                        )
+                                        .duration_ms(Some(5000)),
+                                    );
+                                    cx.notify();
                                 } else {
                                     ai::set_ai_input_with_image(cx, &message, &base64_data, false);
                                 }
@@ -708,6 +724,14 @@
                                 );
                                 if let Err(e) = ai::open_ai_window(cx) {
                                     logging::log("ERROR", &format!("Failed to open AI: {}", e));
+                                    self.toast_manager.push(
+                                        components::toast::Toast::error(
+                                            format!("Failed to open AI: {}", e),
+                                            &self.theme,
+                                        )
+                                        .duration_ms(Some(5000)),
+                                    );
+                                    cx.notify();
                                 } else {
                                     ai::set_ai_input(cx, &message, false);
                                 }
@@ -751,6 +775,14 @@
                                 logging::log("EXEC", &format!("Browser URL captured: {}", url));
                                 if let Err(e) = ai::open_ai_window(cx) {
                                     logging::log("ERROR", &format!("Failed to open AI: {}", e));
+                                    self.toast_manager.push(
+                                        components::toast::Toast::error(
+                                            format!("Failed to open AI: {}", e),
+                                            &self.theme,
+                                        )
+                                        .duration_ms(Some(5000)),
+                                    );
+                                    cx.notify();
                                 } else {
                                     ai::set_ai_input(cx, &message, false);
                                 }
@@ -795,6 +827,13 @@
                         );
                         if let Err(e) = ai::open_ai_window(cx) {
                             logging::log("ERROR", &format!("Failed to open AI: {}", e));
+                            self.toast_manager.push(
+                                components::toast::Toast::error(
+                                    format!("Failed to open AI: {}", e),
+                                    &self.theme,
+                                )
+                                .duration_ms(Some(5000)),
+                            );
                         }
                         cx.notify();
                     }
diff --git a/src/app_impl/execution_scripts.rs b/src/app_impl/execution_scripts.rs
index ac99cc20952af2f8c39e301b7740e55cec8f394e..bc029cee42a4ec93c091ce0ea7912cf905c3011a
--- a/src/app_impl/execution_scripts.rs
+++ b/src/app_impl/execution_scripts.rs
@@ -316,7 +316,9 @@
         // Builtins that open their own windows and don't need main window
         const NO_MAIN_WINDOW_BUILTINS: &[&str] = &[
             "builtin-ai-chat",
+            "builtin-open-ai",
             "builtin-notes",
+            "builtin-open-notes",
             "builtin-new-note",
             "builtin-search-notes",
             "builtin-quick-capture",


thinking
**Adding helper functions and tests**
codex
I‚Äôve patched the missing AI branches with error toasts. I‚Äôm now adding a targeted unit test around the `NO_MAIN_WINDOW_BUILTINS` behavior (including the two new IDs) so the M13 fix is covered and regression-safe.

thinking
**Updating execution scripts**
file update:
diff --git a/src/app_execute/builtin_execution.rs b/src/app_execute/builtin_execution.rs
index ea07c5b2c4e5ef82ea1337d249f517425db711fa..0f764c65a6e69513eed92f89b3a7722fc8ca1378
--- a/src/app_execute/builtin_execution.rs
+++ b/src/app_execute/builtin_execution.rs
@@ -633,6 +633,14 @@
                                 );
                                 if let Err(e) = ai::open_ai_window(cx) {
                                     logging::log("ERROR", &format!("Failed to open AI: {}", e));
+                                    self.toast_manager.push(
+                                        components::toast::Toast::error(
+                                            format!("Failed to open AI: {}", e),
+                                            &self.theme,
+                                        )
+                                        .duration_ms(Some(5000)),
+                                    );
+                                    cx.notify();
                                 } else {
                                     // Set input with the screenshot context
                                     ai::set_ai_input_with_image(cx, &message, &base64_data, false);
@@ -676,6 +684,14 @@
                                 );
                                 if let Err(e) = ai::open_ai_window(cx) {
                                     logging::log("ERROR", &format!("Failed to open AI: {}", e));
+                                    self.toast_manager.push(
+                                        components::toast::Toast::error(
+                                            format!("Failed to open AI: {}", e),
+                                            &self.theme,
+                                        )
+                                        .duration_ms(Some(5000)),
+                                    );
+                                    cx.notify();
                                 } else {
                                     ai::set_ai_input_with_image(cx, &message, &base64_data, false);
                                 }
@@ -708,6 +724,14 @@
                                 );
                                 if let Err(e) = ai::open_ai_window(cx) {
                                     logging::log("ERROR", &format!("Failed to open AI: {}", e));
+                                    self.toast_manager.push(
+                                        components::toast::Toast::error(
+                                            format!("Failed to open AI: {}", e),
+                                            &self.theme,
+                                        )
+                                        .duration_ms(Some(5000)),
+                                    );
+                                    cx.notify();
                                 } else {
                                     ai::set_ai_input(cx, &message, false);
                                 }
@@ -751,6 +775,14 @@
                                 logging::log("EXEC", &format!("Browser URL captured: {}", url));
                                 if let Err(e) = ai::open_ai_window(cx) {
                                     logging::log("ERROR", &format!("Failed to open AI: {}", e));
+                                    self.toast_manager.push(
+                                        components::toast::Toast::error(
+                                            format!("Failed to open AI: {}", e),
+                                            &self.theme,
+                                        )
+                                        .duration_ms(Some(5000)),
+                                    );
+                                    cx.notify();
                                 } else {
                                     ai::set_ai_input(cx, &message, false);
                                 }
@@ -795,6 +827,13 @@
                         );
                         if let Err(e) = ai::open_ai_window(cx) {
                             logging::log("ERROR", &format!("Failed to open AI: {}", e));
+                            self.toast_manager.push(
+                                components::toast::Toast::error(
+                                    format!("Failed to open AI: {}", e),
+                                    &self.theme,
+                                )
+                                .duration_ms(Some(5000)),
+                            );
                         }
                         cx.notify();
                     }
diff --git a/src/app_impl/execution_scripts.rs b/src/app_impl/execution_scripts.rs
index ac99cc20952af2f8c39e301b7740e55cec8f394e..bc029cee42a4ec93c091ce0ea7912cf905c3011a
--- a/src/app_impl/execution_scripts.rs
+++ b/src/app_impl/execution_scripts.rs
@@ -316,7 +316,9 @@
         // Builtins that open their own windows and don't need main window
         const NO_MAIN_WINDOW_BUILTINS: &[&str] = &[
             "builtin-ai-chat",
+            "builtin-open-ai",
             "builtin-notes",
+            "builtin-open-notes",
             "builtin-new-note",
             "builtin-search-notes",
             "builtin-quick-capture",


thinking
**Investigating patch failure**
exec
/bin/zsh -lc 'tail -n 80 src/app_impl/execution_scripts.rs | nl -ba' in /Users/johnlindquist/dev/script-kit-gpui succeeded in 52ms:
     1	                    return false;
     2	                }
     3	                "builtin" => {
     4	                    // Execute builtin by ID
     5	                    let config = crate::config::BuiltInConfig::default();
     6	                    if let Some(entry) = builtins::get_builtin_entries(&config)
     7	                        .iter()
     8	                        .find(|e| e.id == identifier)
     9	                    {
    10	                        logging::log("EXEC", &format!("Executing builtin: {}", identifier));
    11	                        self.execute_builtin(entry, cx);
    12	                        // Check if this builtin opens its own window
    13	                        let needs_main_window = !NO_MAIN_WINDOW_BUILTINS.contains(&identifier);
    14	                        logging::log(
    15	                            "EXEC",
    16	                            &format!(
    17	                                "Builtin {} needs_main_window: {}",
    18	                                identifier, needs_main_window
    19	                            ),
    20	                        );
file update:
diff --git a/src/app_execute/builtin_execution.rs b/src/app_execute/builtin_execution.rs
index ea07c5b2c4e5ef82ea1337d249f517425db711fa..0f764c65a6e69513eed92f89b3a7722fc8ca1378
--- a/src/app_execute/builtin_execution.rs
+++ b/src/app_execute/builtin_execution.rs
@@ -633,6 +633,14 @@
                                 );
                                 if let Err(e) = ai::open_ai_window(cx) {
                                     logging::log("ERROR", &format!("Failed to open AI: {}", e));
+                                    self.toast_manager.push(
+                                        components::toast::Toast::error(
+                                            format!("Failed to open AI: {}", e),
+                                            &self.theme,
+                                        )
+                                        .duration_ms(Some(5000)),
+                                    );
+                                    cx.notify();
                                 } else {
                                     // Set input with the screenshot context
                                     ai::set_ai_input_with_image(cx, &message, &base64_data, false);
@@ -676,6 +684,14 @@
                                 );
                                 if let Err(e) = ai::open_ai_window(cx) {
                                     logging::log("ERROR", &format!("Failed to open AI: {}", e));
+                                    self.toast_manager.push(
+                                        components::toast::Toast::error(
+                                            format!("Failed to open AI: {}", e),
+                                            &self.theme,
+                                        )
+                                        .duration_ms(Some(5000)),
+                                    );
+                                    cx.notify();
                                 } else {
                                     ai::set_ai_input_with_image(cx, &message, &base64_data, false);
                                 }
@@ -708,6 +724,14 @@
                                 );
                                 if let Err(e) = ai::open_ai_window(cx) {
                                     logging::log("ERROR", &format!("Failed to open AI: {}", e));
+                                    self.toast_manager.push(
+                                        components::toast::Toast::error(
+                                            format!("Failed to open AI: {}", e),
+                                            &self.theme,
+                                        )
+                                        .duration_ms(Some(5000)),
+                                    );
+                                    cx.notify();
                                 } else {
                                     ai::set_ai_input(cx, &message, false);
                                 }
@@ -751,6 +775,14 @@
                                 logging::log("EXEC", &format!("Browser URL captured: {}", url));
                                 if let Err(e) = ai::open_ai_window(cx) {
                                     logging::log("ERROR", &format!("Failed to open AI: {}", e));
+                                    self.toast_manager.push(
+                                        components::toast::Toast::error(
+                                            format!("Failed to open AI: {}", e),
+                                            &self.theme,
+                                        )
+                                        .duration_ms(Some(5000)),
+                                    );
+                                    cx.notify();
                                 } else {
                                     ai::set_ai_input(cx, &message, false);
                                 }
@@ -795,6 +827,13 @@
                         );
                         if let Err(e) = ai::open_ai_window(cx) {
                             logging::log("ERROR", &format!("Failed to open AI: {}", e));
+                            self.toast_manager.push(
+                                components::toast::Toast::error(
+                                    format!("Failed to open AI: {}", e),
+                                    &self.theme,
+                                )
+                                .duration_ms(Some(5000)),
+                            );
                         }
                         cx.notify();
                     }
diff --git a/src/app_impl/execution_scripts.rs b/src/app_impl/execution_scripts.rs
index ac99cc20952af2f8c39e301b7740e55cec8f394e..bc029cee42a4ec93c091ce0ea7912cf905c3011a
--- a/src/app_impl/execution_scripts.rs
+++ b/src/app_impl/execution_scripts.rs
@@ -316,7 +316,9 @@
         // Builtins that open their own windows and don't need main window
         const NO_MAIN_WINDOW_BUILTINS: &[&str] = &[
             "builtin-ai-chat",
+            "builtin-open-ai",
             "builtin-notes",
+            "builtin-open-notes",
             "builtin-new-note",
             "builtin-search-notes",
             "builtin-quick-capture",


thinking
**Planning incremental code patching**
file update
M /Users/johnlindquist/dev/script-kit-gpui/src/app_impl/execution_scripts.rs
@@ -2,2 +2,17 @@
 
+const NO_MAIN_WINDOW_BUILTINS: &[&str] = &[
+    "builtin-ai-chat",
+    "builtin-open-ai",
+    "builtin-notes",
+    "builtin-open-notes",
+    "builtin-new-note",
+    "builtin-search-notes",
+    "builtin-quick-capture",
+    "builtin-new-conversation",
+];
+
+fn builtin_needs_main_window_for_command_id(identifier: &str) -> bool {
+    !NO_MAIN_WINDOW_BUILTINS.contains(&identifier)
+}
+
 impl ScriptListApp {
apply_patch(auto_approved=true) exited 0 in 18ms:
Success. Updated the following files:
M src/app_impl/execution_scripts.rs
file update:
diff --git a/src/app_execute/builtin_execution.rs b/src/app_execute/builtin_execution.rs
index ea07c5b2c4e5ef82ea1337d249f517425db711fa..0f764c65a6e69513eed92f89b3a7722fc8ca1378
--- a/src/app_execute/builtin_execution.rs
+++ b/src/app_execute/builtin_execution.rs
@@ -633,6 +633,14 @@
                                 );
                                 if let Err(e) = ai::open_ai_window(cx) {
                                     logging::log("ERROR", &format!("Failed to open AI: {}", e));
+                                    self.toast_manager.push(
+                                        components::toast::Toast::error(
+                                            format!("Failed to open AI: {}", e),
+                                            &self.theme,
+                                        )
+                                        .duration_ms(Some(5000)),
+                                    );
+                                    cx.notify();
                                 } else {
                                     // Set input with the screenshot context
                                     ai::set_ai_input_with_image(cx, &message, &base64_data, false);
@@ -676,6 +684,14 @@
                                 );
                                 if let Err(e) = ai::open_ai_window(cx) {
                                     logging::log("ERROR", &format!("Failed to open AI: {}", e));
+                                    self.toast_manager.push(
+                                        components::toast::Toast::error(
+                                            format!("Failed to open AI: {}", e),
+                                            &self.theme,
+                                        )
+                                        .duration_ms(Some(5000)),
+                                    );
+                                    cx.notify();
                                 } else {
                                     ai::set_ai_input_with_image(cx, &message, &base64_data, false);
                                 }
@@ -708,6 +724,14 @@
                                 );
                                 if let Err(e) = ai::open_ai_window(cx) {
                                     logging::log("ERROR", &format!("Failed to open AI: {}", e));
+                                    self.toast_manager.push(
+                                        components::toast::Toast::error(
+                                            format!("Failed to open AI: {}", e),
+                                            &self.theme,
+                                        )
+                                        .duration_ms(Some(5000)),
+                                    );
+                                    cx.notify();
                                 } else {
                                     ai::set_ai_input(cx, &message, false);
                                 }
@@ -751,6 +775,14 @@
                                 logging::log("EXEC", &format!("Browser URL captured: {}", url));
                                 if let Err(e) = ai::open_ai_window(cx) {
                                     logging::log("ERROR", &format!("Failed to open AI: {}", e));
+                                    self.toast_manager.push(
+                                        components::toast::Toast::error(
+                                            format!("Failed to open AI: {}", e),
+                                            &self.theme,
+                                        )
+                                        .duration_ms(Some(5000)),
+                                    );
+                                    cx.notify();
                                 } else {
                                     ai::set_ai_input(cx, &message, false);
                                 }
@@ -795,6 +827,13 @@
                         );
                         if let Err(e) = ai::open_ai_window(cx) {
                             logging::log("ERROR", &format!("Failed to open AI: {}", e));
+                            self.toast_manager.push(
+                                components::toast::Toast::error(
+                                    format!("Failed to open AI: {}", e),
+                                    &self.theme,
+                                )
+                                .duration_ms(Some(5000)),
+                            );
                         }
                         cx.notify();
                     }
diff --git a/src/app_impl/execution_scripts.rs b/src/app_impl/execution_scripts.rs
index ac99cc20952af2f8c39e301b7740e55cec8f394e..c600ea068d33505d342de9240203aa15e7090f84
--- a/src/app_impl/execution_scripts.rs
+++ b/src/app_impl/execution_scripts.rs
@@ -1,5 +1,20 @@
 use super::*;
 
+const NO_MAIN_WINDOW_BUILTINS: &[&str] = &[
+    "builtin-ai-chat",
+    "builtin-open-ai",
+    "builtin-notes",
+    "builtin-open-notes",
+    "builtin-new-note",
+    "builtin-search-notes",
+    "builtin-quick-capture",
+    "builtin-new-conversation",
+];
+
+fn builtin_needs_main_window_for_command_id(identifier: &str) -> bool {
+    !NO_MAIN_WINDOW_BUILTINS.contains(&identifier)
+}
+
 impl ScriptListApp {
     pub(crate) fn execute_scriptlet(&mut self, scriptlet: &scripts::Scriptlet, cx: &mut Context<Self>) {
         logging::log(
@@ -316,7 +331,9 @@
         // Builtins that open their own windows and don't need main window
         const NO_MAIN_WINDOW_BUILTINS: &[&str] = &[
             "builtin-ai-chat",
+            "builtin-open-ai",
             "builtin-notes",
+            "builtin-open-notes",
             "builtin-new-note",
             "builtin-search-notes",
             "builtin-quick-capture",

file update:
diff --git a/src/app_execute/builtin_execution.rs b/src/app_execute/builtin_execution.rs
index ea07c5b2c4e5ef82ea1337d249f517425db711fa..0f764c65a6e69513eed92f89b3a7722fc8ca1378
--- a/src/app_execute/builtin_execution.rs
+++ b/src/app_execute/builtin_execution.rs
@@ -633,6 +633,14 @@
                                 );
                                 if let Err(e) = ai::open_ai_window(cx) {
                                     logging::log("ERROR", &format!("Failed to open AI: {}", e));
+                                    self.toast_manager.push(
+                                        components::toast::Toast::error(
+                                            format!("Failed to open AI: {}", e),
+                                            &self.theme,
+                                        )
+                                        .duration_ms(Some(5000)),
+                                    );
+                                    cx.notify();
                                 } else {
                                     // Set input with the screenshot context
                                     ai::set_ai_input_with_image(cx, &message, &base64_data, false);
@@ -676,6 +684,14 @@
                                 );
                                 if let Err(e) = ai::open_ai_window(cx) {
                                     logging::log("ERROR", &format!("Failed to open AI: {}", e));
+                                    self.toast_manager.push(
+                                        components::toast::Toast::error(
+                                            format!("Failed to open AI: {}", e),
+                                            &self.theme,
+                                        )
+                                        .duration_ms(Some(5000)),
+                                    );
+                                    cx.notify();
                                 } else {
                                     ai::set_ai_input_with_image(cx, &message, &base64_data, false);
                                 }
@@ -708,6 +724,14 @@
                                 );
                                 if let Err(e) = ai::open_ai_window(cx) {
                                     logging::log("ERROR", &format!("Failed to open AI: {}", e));
+                                    self.toast_manager.push(
+                                        components::toast::Toast::error(
+                                            format!("Failed to open AI: {}", e),
+                                            &self.theme,
+                                        )
+                                        .duration_ms(Some(5000)),
+                                    );
+                                    cx.notify();
                                 } else {
                                     ai::set_ai_input(cx, &message, false);
                                 }
@@ -751,6 +775,14 @@
                                 logging::log("EXEC", &format!("Browser URL captured: {}", url));
                                 if let Err(e) = ai::open_ai_window(cx) {
                                     logging::log("ERROR", &format!("Failed to open AI: {}", e));
+                                    self.toast_manager.push(
+                                        components::toast::Toast::error(
+                                            format!("Failed to open AI: {}", e),
+                                            &self.theme,
+                                        )
+                                        .duration_ms(Some(5000)),
+                                    );
+                                    cx.notify();
                                 } else {
                                     ai::set_ai_input(cx, &message, false);
                                 }
@@ -795,6 +827,13 @@
                         );
                         if let Err(e) = ai::open_ai_window(cx) {
                             logging::log("ERROR", &format!("Failed to open AI: {}", e));
+                            self.toast_manager.push(
+                                components::toast::Toast::error(
+                                    format!("Failed to open AI: {}", e),
+                                    &self.theme,
+                                )
+                                .duration_ms(Some(5000)),
+                            );
                         }
                         cx.notify();
                     }
diff --git a/src/app_impl/execution_scripts.rs b/src/app_impl/execution_scripts.rs
index ac99cc20952af2f8c39e301b7740e55cec8f394e..c600ea068d33505d342de9240203aa15e7090f84
--- a/src/app_impl/execution_scripts.rs
+++ b/src/app_impl/execution_scripts.rs
@@ -1,5 +1,20 @@
 use super::*;
 
+const NO_MAIN_WINDOW_BUILTINS: &[&str] = &[
+    "builtin-ai-chat",
+    "builtin-open-ai",
+    "builtin-notes",
+    "builtin-open-notes",
+    "builtin-new-note",
+    "builtin-search-notes",
+    "builtin-quick-capture",
+    "builtin-new-conversation",
+];
+
+fn builtin_needs_main_window_for_command_id(identifier: &str) -> bool {
+    !NO_MAIN_WINDOW_BUILTINS.contains(&identifier)
+}
+
 impl ScriptListApp {
     pub(crate) fn execute_scriptlet(&mut self, scriptlet: &scripts::Scriptlet, cx: &mut Context<Self>) {
         logging::log(
@@ -316,7 +331,9 @@
         // Builtins that open their own windows and don't need main window
         const NO_MAIN_WINDOW_BUILTINS: &[&str] = &[
             "builtin-ai-chat",
+            "builtin-open-ai",
             "builtin-notes",
+            "builtin-open-notes",
             "builtin-new-note",
             "builtin-search-notes",
             "builtin-quick-capture",


thinking
**Removing duplicate local constants**
file update
M /Users/johnlindquist/dev/script-kit-gpui/src/app_impl/execution_scripts.rs
@@ -330,14 +330,2 @@
 
-        // Builtins that open their own windows and don't need main window
-        const NO_MAIN_WINDOW_BUILTINS: &[&str] = &[
-            "builtin-ai-chat",
-            "builtin-open-ai",
-            "builtin-notes",
-            "builtin-open-notes",
-            "builtin-new-note",
-            "builtin-search-notes",
-            "builtin-quick-capture",
-            "builtin-new-conversation",
-        ];
-
         // Parse command ID format: "type/identifier"
apply_patch(auto_approved=true) exited 0 in 17ms:
Success. Updated the following files:
M src/app_impl/execution_scripts.rs
file update:
diff --git a/src/app_execute/builtin_execution.rs b/src/app_execute/builtin_execution.rs
index ea07c5b2c4e5ef82ea1337d249f517425db711fa..0f764c65a6e69513eed92f89b3a7722fc8ca1378
--- a/src/app_execute/builtin_execution.rs
+++ b/src/app_execute/builtin_execution.rs
@@ -633,6 +633,14 @@
                                 );
                                 if let Err(e) = ai::open_ai_window(cx) {
                                     logging::log("ERROR", &format!("Failed to open AI: {}", e));
+                                    self.toast_manager.push(
+                                        components::toast::Toast::error(
+                                            format!("Failed to open AI: {}", e),
+                                            &self.theme,
+                                        )
+                                        .duration_ms(Some(5000)),
+                                    );
+                                    cx.notify();
                                 } else {
                                     // Set input with the screenshot context
                                     ai::set_ai_input_with_image(cx, &message, &base64_data, false);
@@ -676,6 +684,14 @@
                                 );
                                 if let Err(e) = ai::open_ai_window(cx) {
                                     logging::log("ERROR", &format!("Failed to open AI: {}", e));
+                                    self.toast_manager.push(
+                                        components::toast::Toast::error(
+                                            format!("Failed to open AI: {}", e),
+                                            &self.theme,
+                                        )
+                                        .duration_ms(Some(5000)),
+                                    );
+                                    cx.notify();
                                 } else {
                                     ai::set_ai_input_with_image(cx, &message, &base64_data, false);
                                 }
@@ -708,6 +724,14 @@
                                 );
                                 if let Err(e) = ai::open_ai_window(cx) {
                                     logging::log("ERROR", &format!("Failed to open AI: {}", e));
+                                    self.toast_manager.push(
+                                        components::toast::Toast::error(
+                                            format!("Failed to open AI: {}", e),
+                                            &self.theme,
+                                        )
+                                        .duration_ms(Some(5000)),
+                                    );
+                                    cx.notify();
                                 } else {
                                     ai::set_ai_input(cx, &message, false);
                                 }
@@ -751,6 +775,14 @@
                                 logging::log("EXEC", &format!("Browser URL captured: {}", url));
                                 if let Err(e) = ai::open_ai_window(cx) {
                                     logging::log("ERROR", &format!("Failed to open AI: {}", e));
+                                    self.toast_manager.push(
+                                        components::toast::Toast::error(
+                                            format!("Failed to open AI: {}", e),
+                                            &self.theme,
+                                        )
+                                        .duration_ms(Some(5000)),
+                                    );
+                                    cx.notify();
                                 } else {
                                     ai::set_ai_input(cx, &message, false);
                                 }
@@ -795,6 +827,13 @@
                         );
                         if let Err(e) = ai::open_ai_window(cx) {
                             logging::log("ERROR", &format!("Failed to open AI: {}", e));
+                            self.toast_manager.push(
+                                components::toast::Toast::error(
+                                    format!("Failed to open AI: {}", e),
+                                    &self.theme,
+                                )
+                                .duration_ms(Some(5000)),
+                            );
                         }
                         cx.notify();
                     }
diff --git a/src/app_impl/execution_scripts.rs b/src/app_impl/execution_scripts.rs
index ac99cc20952af2f8c39e301b7740e55cec8f394e..5b1681c2ea8770bf59fbf48dccb5ed7dd7752bb7
--- a/src/app_impl/execution_scripts.rs
+++ b/src/app_impl/execution_scripts.rs
@@ -1,5 +1,20 @@
 use super::*;
 
+const NO_MAIN_WINDOW_BUILTINS: &[&str] = &[
+    "builtin-ai-chat",
+    "builtin-open-ai",
+    "builtin-notes",
+    "builtin-open-notes",
+    "builtin-new-note",
+    "builtin-search-notes",
+    "builtin-quick-capture",
+    "builtin-new-conversation",
+];
+
+fn builtin_needs_main_window_for_command_id(identifier: &str) -> bool {
+    !NO_MAIN_WINDOW_BUILTINS.contains(&identifier)
+}
+
 impl ScriptListApp {
     pub(crate) fn execute_scriptlet(&mut self, scriptlet: &scripts::Scriptlet, cx: &mut Context<Self>) {
         logging::log(
@@ -312,16 +327,6 @@
             "EXEC",
             &format!("Executing by command ID or path: {}", command_id),
         );
-
-        // Builtins that open their own windows and don't need main window
-        const NO_MAIN_WINDOW_BUILTINS: &[&str] = &[
-            "builtin-ai-chat",
-            "builtin-notes",
-            "builtin-new-note",
-            "builtin-search-notes",
-            "builtin-quick-capture",
-            "builtin-new-conversation",
-        ];
 
         // Parse command ID format: "type/identifier"
         if let Some((cmd_type, identifier)) = command_id.split_once('/') {

file update:
diff --git a/src/app_execute/builtin_execution.rs b/src/app_execute/builtin_execution.rs
index ea07c5b2c4e5ef82ea1337d249f517425db711fa..0f764c65a6e69513eed92f89b3a7722fc8ca1378
--- a/src/app_execute/builtin_execution.rs
+++ b/src/app_execute/builtin_execution.rs
@@ -633,6 +633,14 @@
                                 );
                                 if let Err(e) = ai::open_ai_window(cx) {
                                     logging::log("ERROR", &format!("Failed to open AI: {}", e));
+                                    self.toast_manager.push(
+                                        components::toast::Toast::error(
+                                            format!("Failed to open AI: {}", e),
+                                            &self.theme,
+                                        )
+                                        .duration_ms(Some(5000)),
+                                    );
+                                    cx.notify();
                                 } else {
                                     // Set input with the screenshot context
                                     ai::set_ai_input_with_image(cx, &message, &base64_data, false);
@@ -676,6 +684,14 @@
                                 );
                                 if let Err(e) = ai::open_ai_window(cx) {
                                     logging::log("ERROR", &format!("Failed to open AI: {}", e));
+                                    self.toast_manager.push(
+                                        components::toast::Toast::error(
+                                            format!("Failed to open AI: {}", e),
+                                            &self.theme,
+                                        )
+                                        .duration_ms(Some(5000)),
+                                    );
+                                    cx.notify();
                                 } else {
                                     ai::set_ai_input_with_image(cx, &message, &base64_data, false);
                                 }
@@ -708,6 +724,14 @@
                                 );
                                 if let Err(e) = ai::open_ai_window(cx) {
                                     logging::log("ERROR", &format!("Failed to open AI: {}", e));
+                                    self.toast_manager.push(
+                                        components::toast::Toast::error(
+                                            format!("Failed to open AI: {}", e),
+                                            &self.theme,
+                                        )
+                                        .duration_ms(Some(5000)),
+                                    );
+                                    cx.notify();
                                 } else {
                                     ai::set_ai_input(cx, &message, false);
                                 }
@@ -751,6 +775,14 @@
                                 logging::log("EXEC", &format!("Browser URL captured: {}", url));
                                 if let Err(e) = ai::open_ai_window(cx) {
                                     logging::log("ERROR", &format!("Failed to open AI: {}", e));
+                                    self.toast_manager.push(
+                                        components::toast::Toast::error(
+                                            format!("Failed to open AI: {}", e),
+                                            &self.theme,
+                                        )
+                                        .duration_ms(Some(5000)),
+                                    );
+                                    cx.notify();
                                 } else {
                                     ai::set_ai_input(cx, &message, false);
                                 }
@@ -795,6 +827,13 @@
                         );
                         if let Err(e) = ai::open_ai_window(cx) {
                             logging::log("ERROR", &format!("Failed to open AI: {}", e));
+                            self.toast_manager.push(
+                                components::toast::Toast::error(
+                                    format!("Failed to open AI: {}", e),
+                                    &self.theme,
+                                )
+                                .duration_ms(Some(5000)),
+                            );
                         }
                         cx.notify();
                     }
diff --git a/src/app_impl/execution_scripts.rs b/src/app_impl/execution_scripts.rs
index ac99cc20952af2f8c39e301b7740e55cec8f394e..5b1681c2ea8770bf59fbf48dccb5ed7dd7752bb7
--- a/src/app_impl/execution_scripts.rs
+++ b/src/app_impl/execution_scripts.rs
@@ -1,5 +1,20 @@
 use super::*;
 
+const NO_MAIN_WINDOW_BUILTINS: &[&str] = &[
+    "builtin-ai-chat",
+    "builtin-open-ai",
+    "builtin-notes",
+    "builtin-open-notes",
+    "builtin-new-note",
+    "builtin-search-notes",
+    "builtin-quick-capture",
+    "builtin-new-conversation",
+];
+
+fn builtin_needs_main_window_for_command_id(identifier: &str) -> bool {
+    !NO_MAIN_WINDOW_BUILTINS.contains(&identifier)
+}
+
 impl ScriptListApp {
     pub(crate) fn execute_scriptlet(&mut self, scriptlet: &scripts::Scriptlet, cx: &mut Context<Self>) {
         logging::log(
@@ -312,16 +327,6 @@
             "EXEC",
             &format!("Executing by command ID or path: {}", command_id),
         );
-
-        // Builtins that open their own windows and don't need main window
-        const NO_MAIN_WINDOW_BUILTINS: &[&str] = &[
-            "builtin-ai-chat",
-            "builtin-notes",
-            "builtin-new-note",
-            "builtin-search-notes",
-            "builtin-quick-capture",
-            "builtin-new-conversation",
-        ];
 
         // Parse command ID format: "type/identifier"
         if let Some((cmd_type, identifier)) = command_id.split_once('/') {


thinking
**Replacing usage line**
file update
M /Users/johnlindquist/dev/script-kit-gpui/src/app_impl/execution_scripts.rs
@@ -359,3 +359,4 @@
                         // Check if this builtin opens its own window
-                        let needs_main_window = !NO_MAIN_WINDOW_BUILTINS.contains(&identifier);
+                        let needs_main_window =
+                            builtin_needs_main_window_for_command_id(identifier);
                         logging::log(
apply_patch(auto_approved=true) exited 0 in 16ms:
Success. Updated the following files:
M src/app_impl/execution_scripts.rs
file update:
diff --git a/src/app_execute/builtin_execution.rs b/src/app_execute/builtin_execution.rs
index ea07c5b2c4e5ef82ea1337d249f517425db711fa..0f764c65a6e69513eed92f89b3a7722fc8ca1378
--- a/src/app_execute/builtin_execution.rs
+++ b/src/app_execute/builtin_execution.rs
@@ -633,6 +633,14 @@
                                 );
                                 if let Err(e) = ai::open_ai_window(cx) {
                                     logging::log("ERROR", &format!("Failed to open AI: {}", e));
+                                    self.toast_manager.push(
+                                        components::toast::Toast::error(
+                                            format!("Failed to open AI: {}", e),
+                                            &self.theme,
+                                        )
+                                        .duration_ms(Some(5000)),
+                                    );
+                                    cx.notify();
                                 } else {
                                     // Set input with the screenshot context
                                     ai::set_ai_input_with_image(cx, &message, &base64_data, false);
@@ -676,6 +684,14 @@
                                 );
                                 if let Err(e) = ai::open_ai_window(cx) {
                                     logging::log("ERROR", &format!("Failed to open AI: {}", e));
+                                    self.toast_manager.push(
+                                        components::toast::Toast::error(
+                                            format!("Failed to open AI: {}", e),
+                                            &self.theme,
+                                        )
+                                        .duration_ms(Some(5000)),
+                                    );
+                                    cx.notify();
                                 } else {
                                     ai::set_ai_input_with_image(cx, &message, &base64_data, false);
                                 }
@@ -708,6 +724,14 @@
                                 );
                                 if let Err(e) = ai::open_ai_window(cx) {
                                     logging::log("ERROR", &format!("Failed to open AI: {}", e));
+                                    self.toast_manager.push(
+                                        components::toast::Toast::error(
+                                            format!("Failed to open AI: {}", e),
+                                            &self.theme,
+                                        )
+                                        .duration_ms(Some(5000)),
+                                    );
+                                    cx.notify();
                                 } else {
                                     ai::set_ai_input(cx, &message, false);
                                 }
@@ -751,6 +775,14 @@
                                 logging::log("EXEC", &format!("Browser URL captured: {}", url));
                                 if let Err(e) = ai::open_ai_window(cx) {
                                     logging::log("ERROR", &format!("Failed to open AI: {}", e));
+                                    self.toast_manager.push(
+                                        components::toast::Toast::error(
+                                            format!("Failed to open AI: {}", e),
+                                            &self.theme,
+                                        )
+                                        .duration_ms(Some(5000)),
+                                    );
+                                    cx.notify();
                                 } else {
                                     ai::set_ai_input(cx, &message, false);
                                 }
@@ -795,6 +827,13 @@
                         );
                         if let Err(e) = ai::open_ai_window(cx) {
                             logging::log("ERROR", &format!("Failed to open AI: {}", e));
+                            self.toast_manager.push(
+                                components::toast::Toast::error(
+                                    format!("Failed to open AI: {}", e),
+                                    &self.theme,
+                                )
+                                .duration_ms(Some(5000)),
+                            );
                         }
                         cx.notify();
                     }
diff --git a/src/app_impl/execution_scripts.rs b/src/app_impl/execution_scripts.rs
index ac99cc20952af2f8c39e301b7740e55cec8f394e..a27f38f60ec909da2162fa0db9fae150367016cc
--- a/src/app_impl/execution_scripts.rs
+++ b/src/app_impl/execution_scripts.rs
@@ -1,5 +1,20 @@
 use super::*;
 
+const NO_MAIN_WINDOW_BUILTINS: &[&str] = &[
+    "builtin-ai-chat",
+    "builtin-open-ai",
+    "builtin-notes",
+    "builtin-open-notes",
+    "builtin-new-note",
+    "builtin-search-notes",
+    "builtin-quick-capture",
+    "builtin-new-conversation",
+];
+
+fn builtin_needs_main_window_for_command_id(identifier: &str) -> bool {
+    !NO_MAIN_WINDOW_BUILTINS.contains(&identifier)
+}
+
 impl ScriptListApp {
     pub(crate) fn execute_scriptlet(&mut self, scriptlet: &scripts::Scriptlet, cx: &mut Context<Self>) {
         logging::log(
@@ -312,16 +327,6 @@
             "EXEC",
             &format!("Executing by command ID or path: {}", command_id),
         );
-
-        // Builtins that open their own windows and don't need main window
-        const NO_MAIN_WINDOW_BUILTINS: &[&str] = &[
-            "builtin-ai-chat",
-            "builtin-notes",
-            "builtin-new-note",
-            "builtin-search-notes",
-            "builtin-quick-capture",
-            "builtin-new-conversation",
-        ];
 
         // Parse command ID format: "type/identifier"
         if let Some((cmd_type, identifier)) = command_id.split_once('/') {
@@ -352,7 +357,8 @@
                         logging::log("EXEC", &format!("Executing builtin: {}", identifier));
                         self.execute_builtin(entry, cx);
                         // Check if this builtin opens its own window
-                        let needs_main_window = !NO_MAIN_WINDOW_BUILTINS.contains(&identifier);
+                        let needs_main_window =
+                            builtin_needs_main_window_for_command_id(identifier);
                         logging::log(
                             "EXEC",
                             &format!(

file update:
diff --git a/src/app_execute/builtin_execution.rs b/src/app_execute/builtin_execution.rs
index ea07c5b2c4e5ef82ea1337d249f517425db711fa..0f764c65a6e69513eed92f89b3a7722fc8ca1378
--- a/src/app_execute/builtin_execution.rs
+++ b/src/app_execute/builtin_execution.rs
@@ -633,6 +633,14 @@
                                 );
                                 if let Err(e) = ai::open_ai_window(cx) {
                                     logging::log("ERROR", &format!("Failed to open AI: {}", e));
+                                    self.toast_manager.push(
+                                        components::toast::Toast::error(
+                                            format!("Failed to open AI: {}", e),
+                                            &self.theme,
+                                        )
+                                        .duration_ms(Some(5000)),
+                                    );
+                                    cx.notify();
                                 } else {
                                     // Set input with the screenshot context
                                     ai::set_ai_input_with_image(cx, &message, &base64_data, false);
@@ -676,6 +684,14 @@
                                 );
                                 if let Err(e) = ai::open_ai_window(cx) {
                                     logging::log("ERROR", &format!("Failed to open AI: {}", e));
+                                    self.toast_manager.push(
+                                        components::toast::Toast::error(
+                                            format!("Failed to open AI: {}", e),
+                                            &self.theme,
+                                        )
+                                        .duration_ms(Some(5000)),
+                                    );
+                                    cx.notify();
                                 } else {
                                     ai::set_ai_input_with_image(cx, &message, &base64_data, false);
                                 }
@@ -708,6 +724,14 @@
                                 );
                                 if let Err(e) = ai::open_ai_window(cx) {
                                     logging::log("ERROR", &format!("Failed to open AI: {}", e));
+                                    self.toast_manager.push(
+                                        components::toast::Toast::error(
+                                            format!("Failed to open AI: {}", e),
+                                            &self.theme,
+                                        )
+                                        .duration_ms(Some(5000)),
+                                    );
+                                    cx.notify();
                                 } else {
                                     ai::set_ai_input(cx, &message, false);
                                 }
@@ -751,6 +775,14 @@
                                 logging::log("EXEC", &format!("Browser URL captured: {}", url));
                                 if let Err(e) = ai::open_ai_window(cx) {
                                     logging::log("ERROR", &format!("Failed to open AI: {}", e));
+                                    self.toast_manager.push(
+                                        components::toast::Toast::error(
+                                            format!("Failed to open AI: {}", e),
+                                            &self.theme,
+                                        )
+                                        .duration_ms(Some(5000)),
+                                    );
+                                    cx.notify();
                                 } else {
                                     ai::set_ai_input(cx, &message, false);
                                 }
@@ -795,6 +827,13 @@
                         );
                         if let Err(e) = ai::open_ai_window(cx) {
                             logging::log("ERROR", &format!("Failed to open AI: {}", e));
+                            self.toast_manager.push(
+                                components::toast::Toast::error(
+                                    format!("Failed to open AI: {}", e),
+                                    &self.theme,
+                                )
+                                .duration_ms(Some(5000)),
+                            );
                         }
                         cx.notify();
                     }
diff --git a/src/app_impl/execution_scripts.rs b/src/app_impl/execution_scripts.rs
index ac99cc20952af2f8c39e301b7740e55cec8f394e..a27f38f60ec909da2162fa0db9fae150367016cc
--- a/src/app_impl/execution_scripts.rs
+++ b/src/app_impl/execution_scripts.rs
@@ -1,5 +1,20 @@
 use super::*;
 
+const NO_MAIN_WINDOW_BUILTINS: &[&str] = &[
+    "builtin-ai-chat",
+    "builtin-open-ai",
+    "builtin-notes",
+    "builtin-open-notes",
+    "builtin-new-note",
+    "builtin-search-notes",
+    "builtin-quick-capture",
+    "builtin-new-conversation",
+];
+
+fn builtin_needs_main_window_for_command_id(identifier: &str) -> bool {
+    !NO_MAIN_WINDOW_BUILTINS.contains(&identifier)
+}
+
 impl ScriptListApp {
     pub(crate) fn execute_scriptlet(&mut self, scriptlet: &scripts::Scriptlet, cx: &mut Context<Self>) {
         logging::log(
@@ -312,16 +327,6 @@
             "EXEC",
             &format!("Executing by command ID or path: {}", command_id),
         );
-
-        // Builtins that open their own windows and don't need main window
-        const NO_MAIN_WINDOW_BUILTINS: &[&str] = &[
-            "builtin-ai-chat",
-            "builtin-notes",
-            "builtin-new-note",
-            "builtin-search-notes",
-            "builtin-quick-capture",
-            "builtin-new-conversation",
-        ];
 
         // Parse command ID format: "type/identifier"
         if let Some((cmd_type, identifier)) = command_id.split_once('/') {
@@ -352,7 +357,8 @@
                         logging::log("EXEC", &format!("Executing builtin: {}", identifier));
                         self.execute_builtin(entry, cx);
                         // Check if this builtin opens its own window
-                        let needs_main_window = !NO_MAIN_WINDOW_BUILTINS.contains(&identifier);
+                        let needs_main_window =
+                            builtin_needs_main_window_for_command_id(identifier);
                         logging::log(
                             "EXEC",
                             &format!(


thinking
**Adding tests after implementation**
file update
M /Users/johnlindquist/dev/script-kit-gpui/src/app_impl/execution_scripts.rs
@@ -17,2 +17,18 @@
 
+#[cfg(test)]
+mod builtin_command_window_visibility_tests {
+    use super::builtin_needs_main_window_for_command_id;
+
+    #[test]
+    fn test_builtin_needs_main_window_false_for_open_ai_and_open_notes() {
+        assert!(!builtin_needs_main_window_for_command_id("builtin-open-ai"));
+        assert!(!builtin_needs_main_window_for_command_id("builtin-open-notes"));
+    }
+
+    #[test]
+    fn test_builtin_needs_main_window_true_for_unlisted_builtin() {
+        assert!(builtin_needs_main_window_for_command_id("builtin-refresh-scripts"));
+    }
+}
+
 impl ScriptListApp {
apply_patch(auto_approved=true) exited 0 in 17ms:
Success. Updated the following files:
M src/app_impl/execution_scripts.rs
file update:
diff --git a/src/app_execute/builtin_execution.rs b/src/app_execute/builtin_execution.rs
index ea07c5b2c4e5ef82ea1337d249f517425db711fa..0f764c65a6e69513eed92f89b3a7722fc8ca1378
--- a/src/app_execute/builtin_execution.rs
+++ b/src/app_execute/builtin_execution.rs
@@ -633,6 +633,14 @@
                                 );
                                 if let Err(e) = ai::open_ai_window(cx) {
                                     logging::log("ERROR", &format!("Failed to open AI: {}", e));
+                                    self.toast_manager.push(
+                                        components::toast::Toast::error(
+                                            format!("Failed to open AI: {}", e),
+                                            &self.theme,
+                                        )
+                                        .duration_ms(Some(5000)),
+                                    );
+                                    cx.notify();
                                 } else {
                                     // Set input with the screenshot context
                                     ai::set_ai_input_with_image(cx, &message, &base64_data, false);
@@ -676,6 +684,14 @@
                                 );
                                 if let Err(e) = ai::open_ai_window(cx) {
                                     logging::log("ERROR", &format!("Failed to open AI: {}", e));
+                                    self.toast_manager.push(
+                                        components::toast::Toast::error(
+                                            format!("Failed to open AI: {}", e),
+                                            &self.theme,
+                                        )
+                                        .duration_ms(Some(5000)),
+                                    );
+                                    cx.notify();
                                 } else {
                                     ai::set_ai_input_with_image(cx, &message, &base64_data, false);
                                 }
@@ -708,6 +724,14 @@
                                 );
                                 if let Err(e) = ai::open_ai_window(cx) {
                                     logging::log("ERROR", &format!("Failed to open AI: {}", e));
+                                    self.toast_manager.push(
+                                        components::toast::Toast::error(
+                                            format!("Failed to open AI: {}", e),
+                                            &self.theme,
+                                        )
+                                        .duration_ms(Some(5000)),
+                                    );
+                                    cx.notify();
                                 } else {
                                     ai::set_ai_input(cx, &message, false);
                                 }
@@ -751,6 +775,14 @@
                                 logging::log("EXEC", &format!("Browser URL captured: {}", url));
                                 if let Err(e) = ai::open_ai_window(cx) {
                                     logging::log("ERROR", &format!("Failed to open AI: {}", e));
+                                    self.toast_manager.push(
+                                        components::toast::Toast::error(
+                                            format!("Failed to open AI: {}", e),
+                                            &self.theme,
+                                        )
+                                        .duration_ms(Some(5000)),
+                                    );
+                                    cx.notify();
                                 } else {
                                     ai::set_ai_input(cx, &message, false);
                                 }
@@ -795,6 +827,13 @@
                         );
                         if let Err(e) = ai::open_ai_window(cx) {
                             logging::log("ERROR", &format!("Failed to open AI: {}", e));
+                            self.toast_manager.push(
+                                components::toast::Toast::error(
+                                    format!("Failed to open AI: {}", e),
+                                    &self.theme,
+                                )
+                                .duration_ms(Some(5000)),
+                            );
                         }
                         cx.notify();
                     }
diff --git a/src/app_impl/execution_scripts.rs b/src/app_impl/execution_scripts.rs
index ac99cc20952af2f8c39e301b7740e55cec8f394e..0f68c29b620a7bf207a81f1ea167f9a8310f71e4
--- a/src/app_impl/execution_scripts.rs
+++ b/src/app_impl/execution_scripts.rs
@@ -1,5 +1,36 @@
 use super::*;
 
+const NO_MAIN_WINDOW_BUILTINS: &[&str] = &[
+    "builtin-ai-chat",
+    "builtin-open-ai",
+    "builtin-notes",
+    "builtin-open-notes",
+    "builtin-new-note",
+    "builtin-search-notes",
+    "builtin-quick-capture",
+    "builtin-new-conversation",
+];
+
+fn builtin_needs_main_window_for_command_id(identifier: &str) -> bool {
+    !NO_MAIN_WINDOW_BUILTINS.contains(&identifier)
+}
+
+#[cfg(test)]
+mod builtin_command_window_visibility_tests {
+    use super::builtin_needs_main_window_for_command_id;
+
+    #[test]
+    fn test_builtin_needs_main_window_false_for_open_ai_and_open_notes() {
+        assert!(!builtin_needs_main_window_for_command_id("builtin-open-ai"));
+        assert!(!builtin_needs_main_window_for_command_id("builtin-open-notes"));
+    }
+
+    #[test]
+    fn test_builtin_needs_main_window_true_for_unlisted_builtin() {
+        assert!(builtin_needs_main_window_for_command_id("builtin-refresh-scripts"));
+    }
+}
+
 impl ScriptListApp {
     pub(crate) fn execute_scriptlet(&mut self, scriptlet: &scripts::Scriptlet, cx: &mut Context<Self>) {
         logging::log(
@@ -312,16 +343,6 @@
             "EXEC",
             &format!("Executing by command ID or path: {}", command_id),
         );
-
-        // Builtins that open their own windows and don't need main window
-        const NO_MAIN_WINDOW_BUILTINS: &[&str] = &[
-            "builtin-ai-chat",
-            "builtin-notes",
-            "builtin-new-note",
-            "builtin-search-notes",
-            "builtin-quick-capture",
-            "builtin-new-conversation",
-        ];
 
         // Parse command ID format: "type/identifier"
         if let Some((cmd_type, identifier)) = command_id.split_once('/') {
@@ -352,7 +373,8 @@
                         logging::log("EXEC", &format!("Executing builtin: {}", identifier));
                         self.execute_builtin(entry, cx);
                         // Check if this builtin opens its own window
-                        let needs_main_window = !NO_MAIN_WINDOW_BUILTINS.contains(&identifier);
+                        let needs_main_window =
+                            builtin_needs_main_window_for_command_id(identifier);
                         logging::log(
                             "EXEC",
                             &format!(

file update:
diff --git a/src/app_execute/builtin_execution.rs b/src/app_execute/builtin_execution.rs
index ea07c5b2c4e5ef82ea1337d249f517425db711fa..0f764c65a6e69513eed92f89b3a7722fc8ca1378
--- a/src/app_execute/builtin_execution.rs
+++ b/src/app_execute/builtin_execution.rs
@@ -633,6 +633,14 @@
                                 );
                                 if let Err(e) = ai::open_ai_window(cx) {
                                     logging::log("ERROR", &format!("Failed to open AI: {}", e));
+                                    self.toast_manager.push(
+                                        components::toast::Toast::error(
+                                            format!("Failed to open AI: {}", e),
+                                            &self.theme,
+                                        )
+                                        .duration_ms(Some(5000)),
+                                    );
+                                    cx.notify();
                                 } else {
                                     // Set input with the screenshot context
                                     ai::set_ai_input_with_image(cx, &message, &base64_data, false);
@@ -676,6 +684,14 @@
                                 );
                                 if let Err(e) = ai::open_ai_window(cx) {
                                     logging::log("ERROR", &format!("Failed to open AI: {}", e));
+                                    self.toast_manager.push(
+                                        components::toast::Toast::error(
+                                            format!("Failed to open AI: {}", e),
+                                            &self.theme,
+                                        )
+                                        .duration_ms(Some(5000)),
+                                    );
+                                    cx.notify();
                                 } else {
                                     ai::set_ai_input_with_image(cx, &message, &base64_data, false);
                                 }
@@ -708,6 +724,14 @@
                                 );
                                 if let Err(e) = ai::open_ai_window(cx) {
                                     logging::log("ERROR", &format!("Failed to open AI: {}", e));
+                                    self.toast_manager.push(
+                                        components::toast::Toast::error(
+                                            format!("Failed to open AI: {}", e),
+                                            &self.theme,
+                                        )
+                                        .duration_ms(Some(5000)),
+                                    );
+                                    cx.notify();
                                 } else {
                                     ai::set_ai_input(cx, &message, false);
                                 }
@@ -751,6 +775,14 @@
                                 logging::log("EXEC", &format!("Browser URL captured: {}", url));
                                 if let Err(e) = ai::open_ai_window(cx) {
                                     logging::log("ERROR", &format!("Failed to open AI: {}", e));
+                                    self.toast_manager.push(
+                                        components::toast::Toast::error(
+                                            format!("Failed to open AI: {}", e),
+                                            &self.theme,
+                                        )
+                                        .duration_ms(Some(5000)),
+                                    );
+                                    cx.notify();
                                 } else {
                                     ai::set_ai_input(cx, &message, false);
                                 }
@@ -795,6 +827,13 @@
                         );
                         if let Err(e) = ai::open_ai_window(cx) {
                             logging::log("ERROR", &format!("Failed to open AI: {}", e));
+                            self.toast_manager.push(
+                                components::toast::Toast::error(
+                                    format!("Failed to open AI: {}", e),
+                                    &self.theme,
+                                )
+                                .duration_ms(Some(5000)),
+                            );
                         }
                         cx.notify();
                     }
diff --git a/src/app_impl/execution_scripts.rs b/src/app_impl/execution_scripts.rs
index ac99cc20952af2f8c39e301b7740e55cec8f394e..0f68c29b620a7bf207a81f1ea167f9a8310f71e4
--- a/src/app_impl/execution_scripts.rs
+++ b/src/app_impl/execution_scripts.rs
@@ -1,5 +1,36 @@
 use super::*;
 
+const NO_MAIN_WINDOW_BUILTINS: &[&str] = &[
+    "builtin-ai-chat",
+    "builtin-open-ai",
+    "builtin-notes",
+    "builtin-open-notes",
+    "builtin-new-note",
+    "builtin-search-notes",
+    "builtin-quick-capture",
+    "builtin-new-conversation",
+];
+
+fn builtin_needs_main_window_for_command_id(identifier: &str) -> bool {
+    !NO_MAIN_WINDOW_BUILTINS.contains(&identifier)
+}
+
+#[cfg(test)]
+mod builtin_command_window_visibility_tests {
+    use super::builtin_needs_main_window_for_command_id;
+
+    #[test]
+    fn test_builtin_needs_main_window_false_for_open_ai_and_open_notes() {
+        assert!(!builtin_needs_main_window_for_command_id("builtin-open-ai"));
+        assert!(!builtin_needs_main_window_for_command_id("builtin-open-notes"));
+    }
+
+    #[test]
+    fn test_builtin_needs_main_window_true_for_unlisted_builtin() {
+        assert!(builtin_needs_main_window_for_command_id("builtin-refresh-scripts"));
+    }
+}
+
 impl ScriptListApp {
     pub(crate) fn execute_scriptlet(&mut self, scriptlet: &scripts::Scriptlet, cx: &mut Context<Self>) {
         logging::log(
@@ -312,16 +343,6 @@
             "EXEC",
             &format!("Executing by command ID or path: {}", command_id),
         );
-
-        // Builtins that open their own windows and don't need main window
-        const NO_MAIN_WINDOW_BUILTINS: &[&str] = &[
-            "builtin-ai-chat",
-            "builtin-notes",
-            "builtin-new-note",
-            "builtin-search-notes",
-            "builtin-quick-capture",
-            "builtin-new-conversation",
-        ];
 
         // Parse command ID format: "type/identifier"
         if let Some((cmd_type, identifier)) = command_id.split_once('/') {
@@ -352,7 +373,8 @@
                         logging::log("EXEC", &format!("Executing builtin: {}", identifier));
                         self.execute_builtin(entry, cx);
                         // Check if this builtin opens its own window
-                        let needs_main_window = !NO_MAIN_WINDOW_BUILTINS.contains(&identifier);
+                        let needs_main_window =
+                            builtin_needs_main_window_for_command_id(identifier);
                         logging::log(
                             "EXEC",
                             &format!(


thinking
**Planning AI error message helper**
exec
/bin/zsh -lc 'rg -n "format!'"\\(\\\"Failed to open AI:\" src/app_execute/builtin_execution.rs" in /Users/johnlindquist/dev/script-kit-gpui succeeded in 50ms:
289:                                        format!("Failed to open AI: {}", e),
555:                                    format!("Failed to open AI: {}", e),
635:                                    logging::log("ERROR", &format!("Failed to open AI: {}", e));
638:                                            format!("Failed to open AI: {}", e),
686:                                    logging::log("ERROR", &format!("Failed to open AI: {}", e));
689:                                            format!("Failed to open AI: {}", e),
726:                                    logging::log("ERROR", &format!("Failed to open AI: {}", e));
729:                                            format!("Failed to open AI: {}", e),
777:                                    logging::log("ERROR", &format!("Failed to open AI: {}", e));
780:                                            format!("Failed to open AI: {}", e),
829:                            logging::log("ERROR", &format!("Failed to open AI: {}", e));
832:                                    format!("Failed to open AI: {}", e),
file update:
diff --git a/src/app_execute/builtin_execution.rs b/src/app_execute/builtin_execution.rs
index ea07c5b2c4e5ef82ea1337d249f517425db711fa..0f764c65a6e69513eed92f89b3a7722fc8ca1378
--- a/src/app_execute/builtin_execution.rs
+++ b/src/app_execute/builtin_execution.rs
@@ -633,6 +633,14 @@
                                 );
                                 if let Err(e) = ai::open_ai_window(cx) {
                                     logging::log("ERROR", &format!("Failed to open AI: {}", e));
+                                    self.toast_manager.push(
+                                        components::toast::Toast::error(
+                                            format!("Failed to open AI: {}", e),
+                                            &self.theme,
+                                        )
+                                        .duration_ms(Some(5000)),
+                                    );
+                                    cx.notify();
                                 } else {
                                     // Set input with the screenshot context
                                     ai::set_ai_input_with_image(cx, &message, &base64_data, false);
@@ -676,6 +684,14 @@
                                 );
                                 if let Err(e) = ai::open_ai_window(cx) {
                                     logging::log("ERROR", &format!("Failed to open AI: {}", e));
+                                    self.toast_manager.push(
+                                        components::toast::Toast::error(
+                                            format!("Failed to open AI: {}", e),
+                                            &self.theme,
+                                        )
+                                        .duration_ms(Some(5000)),
+                                    );
+                                    cx.notify();
                                 } else {
                                     ai::set_ai_input_with_image(cx, &message, &base64_data, false);
                                 }
@@ -708,6 +724,14 @@
                                 );
                                 if let Err(e) = ai::open_ai_window(cx) {
                                     logging::log("ERROR", &format!("Failed to open AI: {}", e));
+                                    self.toast_manager.push(
+                                        components::toast::Toast::error(
+                                            format!("Failed to open AI: {}", e),
+                                            &self.theme,
+                                        )
+                                        .duration_ms(Some(5000)),
+                                    );
+                                    cx.notify();
                                 } else {
                                     ai::set_ai_input(cx, &message, false);
                                 }
@@ -751,6 +775,14 @@
                                 logging::log("EXEC", &format!("Browser URL captured: {}", url));
                                 if let Err(e) = ai::open_ai_window(cx) {
                                     logging::log("ERROR", &format!("Failed to open AI: {}", e));
+                                    self.toast_manager.push(
+                                        components::toast::Toast::error(
+                                            format!("Failed to open AI: {}", e),
+                                            &self.theme,
+                                        )
+                                        .duration_ms(Some(5000)),
+                                    );
+                                    cx.notify();
                                 } else {
                                     ai::set_ai_input(cx, &message, false);
                                 }
@@ -795,6 +827,13 @@
                         );
                         if let Err(e) = ai::open_ai_window(cx) {
                             logging::log("ERROR", &format!("Failed to open AI: {}", e));
+                            self.toast_manager.push(
+                                components::toast::Toast::error(
+                                    format!("Failed to open AI: {}", e),
+                                    &self.theme,
+                                )
+                                .duration_ms(Some(5000)),
+                            );
                         }
                         cx.notify();
                     }
diff --git a/src/app_impl/execution_scripts.rs b/src/app_impl/execution_scripts.rs
index ac99cc20952af2f8c39e301b7740e55cec8f394e..0f68c29b620a7bf207a81f1ea167f9a8310f71e4
--- a/src/app_impl/execution_scripts.rs
+++ b/src/app_impl/execution_scripts.rs
@@ -1,5 +1,36 @@
 use super::*;
 
+const NO_MAIN_WINDOW_BUILTINS: &[&str] = &[
+    "builtin-ai-chat",
+    "builtin-open-ai",
+    "builtin-notes",
+    "builtin-open-notes",
+    "builtin-new-note",
+    "builtin-search-notes",
+    "builtin-quick-capture",
+    "builtin-new-conversation",
+];
+
+fn builtin_needs_main_window_for_command_id(identifier: &str) -> bool {
+    !NO_MAIN_WINDOW_BUILTINS.contains(&identifier)
+}
+
+#[cfg(test)]
+mod builtin_command_window_visibility_tests {
+    use super::builtin_needs_main_window_for_command_id;
+
+    #[test]
+    fn test_builtin_needs_main_window_false_for_open_ai_and_open_notes() {
+        assert!(!builtin_needs_main_window_for_command_id("builtin-open-ai"));
+        assert!(!builtin_needs_main_window_for_command_id("builtin-open-notes"));
+    }
+
+    #[test]
+    fn test_builtin_needs_main_window_true_for_unlisted_builtin() {
+        assert!(builtin_needs_main_window_for_command_id("builtin-refresh-scripts"));
+    }
+}
+
 impl ScriptListApp {
     pub(crate) fn execute_scriptlet(&mut self, scriptlet: &scripts::Scriptlet, cx: &mut Context<Self>) {
         logging::log(
@@ -312,16 +343,6 @@
             "EXEC",
             &format!("Executing by command ID or path: {}", command_id),
         );
-
-        // Builtins that open their own windows and don't need main window
-        const NO_MAIN_WINDOW_BUILTINS: &[&str] = &[
-            "builtin-ai-chat",
-            "builtin-notes",
-            "builtin-new-note",
-            "builtin-search-notes",
-            "builtin-quick-capture",
-            "builtin-new-conversation",
-        ];
 
         // Parse command ID format: "type/identifier"
         if let Some((cmd_type, identifier)) = command_id.split_once('/') {
@@ -352,7 +373,8 @@
                         logging::log("EXEC", &format!("Executing builtin: {}", identifier));
                         self.execute_builtin(entry, cx);
                         // Check if this builtin opens its own window
-                        let needs_main_window = !NO_MAIN_WINDOW_BUILTINS.contains(&identifier);
+                        let needs_main_window =
+                            builtin_needs_main_window_for_command_id(identifier);
                         logging::log(
                             "EXEC",
                             &format!(


thinking
**Planning toast replacement helper**
exec
/bin/zsh -lc 'tail -n 60 src/app_execute/builtin_execution.rs | nl -ba' in /Users/johnlindquist/dev/script-kit-gpui succeeded in 52ms:
     1	                        if process_count == 0 {
     2	                            self.show_hud(
     3	                                "No running scripts. Process report copied.".to_string(),
     4	                                Some(2200),
     5	                                cx,
     6	                            );
     7	                        } else {
     8	                            self.show_hud(
     9	                                format!(
    10	                                    "{} running script process(es). Details copied.",
    11	                                    process_count
    12	                                ),
    13	                                Some(2600),
    14	                                cx,
    15	                            );
    16	                        }
    17	                    }
    18	                    UtilityCommandType::StopAllProcesses => {
    19	                        let process_count = crate::process_manager::PROCESS_MANAGER.active_count();
    20	                        logging::log(
file update:
diff --git a/src/app_execute/builtin_execution.rs b/src/app_execute/builtin_execution.rs
index ea07c5b2c4e5ef82ea1337d249f517425db711fa..0f764c65a6e69513eed92f89b3a7722fc8ca1378
--- a/src/app_execute/builtin_execution.rs
+++ b/src/app_execute/builtin_execution.rs
@@ -633,6 +633,14 @@
                                 );
                                 if let Err(e) = ai::open_ai_window(cx) {
                                     logging::log("ERROR", &format!("Failed to open AI: {}", e));
+                                    self.toast_manager.push(
+                                        components::toast::Toast::error(
+                                            format!("Failed to open AI: {}", e),
+                                            &self.theme,
+                                        )
+                                        .duration_ms(Some(5000)),
+                                    );
+                                    cx.notify();
                                 } else {
                                     // Set input with the screenshot context
                                     ai::set_ai_input_with_image(cx, &message, &base64_data, false);
@@ -676,6 +684,14 @@
                                 );
                                 if let Err(e) = ai::open_ai_window(cx) {
                                     logging::log("ERROR", &format!("Failed to open AI: {}", e));
+                                    self.toast_manager.push(
+                                        components::toast::Toast::error(
+                                            format!("Failed to open AI: {}", e),
+                                            &self.theme,
+                                        )
+                                        .duration_ms(Some(5000)),
+                                    );
+                                    cx.notify();
                                 } else {
                                     ai::set_ai_input_with_image(cx, &message, &base64_data, false);
                                 }
@@ -708,6 +724,14 @@
                                 );
                                 if let Err(e) = ai::open_ai_window(cx) {
                                     logging::log("ERROR", &format!("Failed to open AI: {}", e));
+                                    self.toast_manager.push(
+                                        components::toast::Toast::error(
+                                            format!("Failed to open AI: {}", e),
+                                            &self.theme,
+                                        )
+                                        .duration_ms(Some(5000)),
+                                    );
+                                    cx.notify();
                                 } else {
                                     ai::set_ai_input(cx, &message, false);
                                 }
@@ -751,6 +775,14 @@
                                 logging::log("EXEC", &format!("Browser URL captured: {}", url));
                                 if let Err(e) = ai::open_ai_window(cx) {
                                     logging::log("ERROR", &format!("Failed to open AI: {}", e));
+                                    self.toast_manager.push(
+                                        components::toast::Toast::error(
+                                            format!("Failed to open AI: {}", e),
+                                            &self.theme,
+                                        )
+                                        .duration_ms(Some(5000)),
+                                    );
+                                    cx.notify();
                                 } else {
                                     ai::set_ai_input(cx, &message, false);
                                 }
@@ -795,6 +827,13 @@
                         );
                         if let Err(e) = ai::open_ai_window(cx) {
                             logging::log("ERROR", &format!("Failed to open AI: {}", e));
+                            self.toast_manager.push(
+                                components::toast::Toast::error(
+                                    format!("Failed to open AI: {}", e),
+                                    &self.theme,
+                                )
+                                .duration_ms(Some(5000)),
+                            );
                         }
                         cx.notify();
                     }
diff --git a/src/app_impl/execution_scripts.rs b/src/app_impl/execution_scripts.rs
index ac99cc20952af2f8c39e301b7740e55cec8f394e..0f68c29b620a7bf207a81f1ea167f9a8310f71e4
--- a/src/app_impl/execution_scripts.rs
+++ b/src/app_impl/execution_scripts.rs
@@ -1,5 +1,36 @@
 use super::*;
 
+const NO_MAIN_WINDOW_BUILTINS: &[&str] = &[
+    "builtin-ai-chat",
+    "builtin-open-ai",
+    "builtin-notes",
+    "builtin-open-notes",
+    "builtin-new-note",
+    "builtin-search-notes",
+    "builtin-quick-capture",
+    "builtin-new-conversation",
+];
+
+fn builtin_needs_main_window_for_command_id(identifier: &str) -> bool {
+    !NO_MAIN_WINDOW_BUILTINS.contains(&identifier)
+}
+
+#[cfg(test)]
+mod builtin_command_window_visibility_tests {
+    use super::builtin_needs_main_window_for_command_id;
+
+    #[test]
+    fn test_builtin_needs_main_window_false_for_open_ai_and_open_notes() {
+        assert!(!builtin_needs_main_window_for_command_id("builtin-open-ai"));
+        assert!(!builtin_needs_main_window_for_command_id("builtin-open-notes"));
+    }
+
+    #[test]
+    fn test_builtin_needs_main_window_true_for_unlisted_builtin() {
+        assert!(builtin_needs_main_window_for_command_id("builtin-refresh-scripts"));
+    }
+}
+
 impl ScriptListApp {
     pub(crate) fn execute_scriptlet(&mut self, scriptlet: &scripts::Scriptlet, cx: &mut Context<Self>) {
         logging::log(
@@ -312,16 +343,6 @@
             "EXEC",
             &format!("Executing by command ID or path: {}", command_id),
         );
-
-        // Builtins that open their own windows and don't need main window
-        const NO_MAIN_WINDOW_BUILTINS: &[&str] = &[
-            "builtin-ai-chat",
-            "builtin-notes",
-            "builtin-new-note",
-            "builtin-search-notes",
-            "builtin-quick-capture",
-            "builtin-new-conversation",
-        ];
 
         // Parse command ID format: "type/identifier"
         if let Some((cmd_type, identifier)) = command_id.split_once('/') {
@@ -352,7 +373,8 @@
                         logging::log("EXEC", &format!("Executing builtin: {}", identifier));
                         self.execute_builtin(entry, cx);
                         // Check if this builtin opens its own window
-                        let needs_main_window = !NO_MAIN_WINDOW_BUILTINS.contains(&identifier);
+                        let needs_main_window =
+                            builtin_needs_main_window_for_command_id(identifier);
                         logging::log(
                             "EXEC",
                             &format!(


thinking
**Adding initial file reading helper**
codex
I‚Äôm adding a tiny pure helper plus unit test in `builtin_execution.rs` so the new AI-error feedback message path has direct test coverage too, then I‚Äôll run scoped checks.

thinking
**Applying patch**
file update
M /Users/johnlindquist/dev/script-kit-gpui/src/app_execute/builtin_execution.rs
@@ -1 +1,5 @@
+fn ai_open_failure_message(error: impl std::fmt::Display) -> String {
+    format!("Failed to open AI: {}", error)
+}
+
 impl ScriptListApp {
apply_patch(auto_approved=true) exited 0 in 16ms:
Success. Updated the following files:
M src/app_execute/builtin_execution.rs
file update:
diff --git a/src/app_execute/builtin_execution.rs b/src/app_execute/builtin_execution.rs
index ea07c5b2c4e5ef82ea1337d249f517425db711fa..3d5229e4d62e19ba3e3576603ed09332d9803c0f
--- a/src/app_execute/builtin_execution.rs
+++ b/src/app_execute/builtin_execution.rs
@@ -1,3 +1,7 @@
+fn ai_open_failure_message(error: impl std::fmt::Display) -> String {
+    format!("Failed to open AI: {}", error)
+}
+
 impl ScriptListApp {
     fn system_action_feedback_message(
         &self,
@@ -633,6 +637,14 @@
                                 );
                                 if let Err(e) = ai::open_ai_window(cx) {
                                     logging::log("ERROR", &format!("Failed to open AI: {}", e));
+                                    self.toast_manager.push(
+                                        components::toast::Toast::error(
+                                            format!("Failed to open AI: {}", e),
+                                            &self.theme,
+                                        )
+                                        .duration_ms(Some(5000)),
+                                    );
+                                    cx.notify();
                                 } else {
                                     // Set input with the screenshot context
                                     ai::set_ai_input_with_image(cx, &message, &base64_data, false);
@@ -676,6 +688,14 @@
                                 );
                                 if let Err(e) = ai::open_ai_window(cx) {
                                     logging::log("ERROR", &format!("Failed to open AI: {}", e));
+                                    self.toast_manager.push(
+                                        components::toast::Toast::error(
+                                            format!("Failed to open AI: {}", e),
+                                            &self.theme,
+                                        )
+                                        .duration_ms(Some(5000)),
+                                    );
+                                    cx.notify();
                                 } else {
                                     ai::set_ai_input_with_image(cx, &message, &base64_data, false);
                                 }
@@ -708,6 +728,14 @@
                                 );
                                 if let Err(e) = ai::open_ai_window(cx) {
                                     logging::log("ERROR", &format!("Failed to open AI: {}", e));
+                                    self.toast_manager.push(
+                                        components::toast::Toast::error(
+                                            format!("Failed to open AI: {}", e),
+                                            &self.theme,
+                                        )
+                                        .duration_ms(Some(5000)),
+                                    );
+                                    cx.notify();
                                 } else {
                                     ai::set_ai_input(cx, &message, false);
                                 }
@@ -751,6 +779,14 @@
                                 logging::log("EXEC", &format!("Browser URL captured: {}", url));
                                 if let Err(e) = ai::open_ai_window(cx) {
                                     logging::log("ERROR", &format!("Failed to open AI: {}", e));
+                                    self.toast_manager.push(
+                                        components::toast::Toast::error(
+                                            format!("Failed to open AI: {}", e),
+                                            &self.theme,
+                                        )
+                                        .duration_ms(Some(5000)),
+                                    );
+                                    cx.notify();
                                 } else {
                                     ai::set_ai_input(cx, &message, false);
                                 }
@@ -795,6 +831,13 @@
                         );
                         if let Err(e) = ai::open_ai_window(cx) {
                             logging::log("ERROR", &format!("Failed to open AI: {}", e));
+                            self.toast_manager.push(
+                                components::toast::Toast::error(
+                                    format!("Failed to open AI: {}", e),
+                                    &self.theme,
+                                )
+                                .duration_ms(Some(5000)),
+                            );
                         }
                         cx.notify();
                     }
diff --git a/src/app_impl/execution_scripts.rs b/src/app_impl/execution_scripts.rs
index ac99cc20952af2f8c39e301b7740e55cec8f394e..0f68c29b620a7bf207a81f1ea167f9a8310f71e4
--- a/src/app_impl/execution_scripts.rs
+++ b/src/app_impl/execution_scripts.rs
@@ -1,5 +1,36 @@
 use super::*;
 
+const NO_MAIN_WINDOW_BUILTINS: &[&str] = &[
+    "builtin-ai-chat",
+    "builtin-open-ai",
+    "builtin-notes",
+    "builtin-open-notes",
+    "builtin-new-note",
+    "builtin-search-notes",
+    "builtin-quick-capture",
+    "builtin-new-conversation",
+];
+
+fn builtin_needs_main_window_for_command_id(identifier: &str) -> bool {
+    !NO_MAIN_WINDOW_BUILTINS.contains(&identifier)
+}
+
+#[cfg(test)]
+mod builtin_command_window_visibility_tests {
+    use super::builtin_needs_main_window_for_command_id;
+
+    #[test]
+    fn test_builtin_needs_main_window_false_for_open_ai_and_open_notes() {
+        assert!(!builtin_needs_main_window_for_command_id("builtin-open-ai"));
+        assert!(!builtin_needs_main_window_for_command_id("builtin-open-notes"));
+    }
+
+    #[test]
+    fn test_builtin_needs_main_window_true_for_unlisted_builtin() {
+        assert!(builtin_needs_main_window_for_command_id("builtin-refresh-scripts"));
+    }
+}
+
 impl ScriptListApp {
     pub(crate) fn execute_scriptlet(&mut self, scriptlet: &scripts::Scriptlet, cx: &mut Context<Self>) {
         logging::log(
@@ -312,16 +343,6 @@
             "EXEC",
             &format!("Executing by command ID or path: {}", command_id),
         );
-
-        // Builtins that open their own windows and don't need main window
-        const NO_MAIN_WINDOW_BUILTINS: &[&str] = &[
-            "builtin-ai-chat",
-            "builtin-notes",
-            "builtin-new-note",
-            "builtin-search-notes",
-            "builtin-quick-capture",
-            "builtin-new-conversation",
-        ];
 
         // Parse command ID format: "type/identifier"
         if let Some((cmd_type, identifier)) = command_id.split_once('/') {
@@ -352,7 +373,8 @@
                         logging::log("EXEC", &format!("Executing builtin: {}", identifier));
                         self.execute_builtin(entry, cx);
                         // Check if this builtin opens its own window
-                        let needs_main_window = !NO_MAIN_WINDOW_BUILTINS.contains(&identifier);
+                        let needs_main_window =
+                            builtin_needs_main_window_for_command_id(identifier);
                         logging::log(
                             "EXEC",
                             &format!(

file update:
diff --git a/src/app_execute/builtin_execution.rs b/src/app_execute/builtin_execution.rs
index ea07c5b2c4e5ef82ea1337d249f517425db711fa..3d5229e4d62e19ba3e3576603ed09332d9803c0f
--- a/src/app_execute/builtin_execution.rs
+++ b/src/app_execute/builtin_execution.rs
@@ -1,3 +1,7 @@
+fn ai_open_failure_message(error: impl std::fmt::Display) -> String {
+    format!("Failed to open AI: {}", error)
+}
+
 impl ScriptListApp {
     fn system_action_feedback_message(
         &self,
@@ -633,6 +637,14 @@
                                 );
                                 if let Err(e) = ai::open_ai_window(cx) {
                                     logging::log("ERROR", &format!("Failed to open AI: {}", e));
+                                    self.toast_manager.push(
+                                        components::toast::Toast::error(
+                                            format!("Failed to open AI: {}", e),
+                                            &self.theme,
+                                        )
+                                        .duration_ms(Some(5000)),
+                                    );
+                                    cx.notify();
                                 } else {
                                     // Set input with the screenshot context
                                     ai::set_ai_input_with_image(cx, &message, &base64_data, false);
@@ -676,6 +688,14 @@
                                 );
                                 if let Err(e) = ai::open_ai_window(cx) {
                                     logging::log("ERROR", &format!("Failed to open AI: {}", e));
+                                    self.toast_manager.push(
+                                        components::toast::Toast::error(
+                                            format!("Failed to open AI: {}", e),
+                                            &self.theme,
+                                        )
+                                        .duration_ms(Some(5000)),
+                                    );
+                                    cx.notify();
                                 } else {
                                     ai::set_ai_input_with_image(cx, &message, &base64_data, false);
                                 }
@@ -708,6 +728,14 @@
                                 );
                                 if let Err(e) = ai::open_ai_window(cx) {
                                     logging::log("ERROR", &format!("Failed to open AI: {}", e));
+                                    self.toast_manager.push(
+                                        components::toast::Toast::error(
+                                            format!("Failed to open AI: {}", e),
+                                            &self.theme,
+                                        )
+                                        .duration_ms(Some(5000)),
+                                    );
+                                    cx.notify();
                                 } else {
                                     ai::set_ai_input(cx, &message, false);
                                 }
@@ -751,6 +779,14 @@
                                 logging::log("EXEC", &format!("Browser URL captured: {}", url));
                                 if let Err(e) = ai::open_ai_window(cx) {
                                     logging::log("ERROR", &format!("Failed to open AI: {}", e));
+                                    self.toast_manager.push(
+                                        components::toast::Toast::error(
+                                            format!("Failed to open AI: {}", e),
+                                            &self.theme,
+                                        )
+                                        .duration_ms(Some(5000)),
+                                    );
+                                    cx.notify();
                                 } else {
                                     ai::set_ai_input(cx, &message, false);
                                 }
@@ -795,6 +831,13 @@
                         );
                         if let Err(e) = ai::open_ai_window(cx) {
                             logging::log("ERROR", &format!("Failed to open AI: {}", e));
+                            self.toast_manager.push(
+                                components::toast::Toast::error(
+                                    format!("Failed to open AI: {}", e),
+                                    &self.theme,
+                                )
+                                .duration_ms(Some(5000)),
+                            );
                         }
                         cx.notify();
                     }
diff --git a/src/app_impl/execution_scripts.rs b/src/app_impl/execution_scripts.rs
index ac99cc20952af2f8c39e301b7740e55cec8f394e..0f68c29b620a7bf207a81f1ea167f9a8310f71e4
--- a/src/app_impl/execution_scripts.rs
+++ b/src/app_impl/execution_scripts.rs
@@ -1,5 +1,36 @@
 use super::*;
 
+const NO_MAIN_WINDOW_BUILTINS: &[&str] = &[
+    "builtin-ai-chat",
+    "builtin-open-ai",
+    "builtin-notes",
+    "builtin-open-notes",
+    "builtin-new-note",
+    "builtin-search-notes",
+    "builtin-quick-capture",
+    "builtin-new-conversation",
+];
+
+fn builtin_needs_main_window_for_command_id(identifier: &str) -> bool {
+    !NO_MAIN_WINDOW_BUILTINS.contains(&identifier)
+}
+
+#[cfg(test)]
+mod builtin_command_window_visibility_tests {
+    use super::builtin_needs_main_window_for_command_id;
+
+    #[test]
+    fn test_builtin_needs_main_window_false_for_open_ai_and_open_notes() {
+        assert!(!builtin_needs_main_window_for_command_id("builtin-open-ai"));
+        assert!(!builtin_needs_main_window_for_command_id("builtin-open-notes"));
+    }
+
+    #[test]
+    fn test_builtin_needs_main_window_true_for_unlisted_builtin() {
+        assert!(builtin_needs_main_window_for_command_id("builtin-refresh-scripts"));
+    }
+}
+
 impl ScriptListApp {
     pub(crate) fn execute_scriptlet(&mut self, scriptlet: &scripts::Scriptlet, cx: &mut Context<Self>) {
         logging::log(
@@ -312,16 +343,6 @@
             "EXEC",
             &format!("Executing by command ID or path: {}", command_id),
         );
-
-        // Builtins that open their own windows and don't need main window
-        const NO_MAIN_WINDOW_BUILTINS: &[&str] = &[
-            "builtin-ai-chat",
-            "builtin-notes",
-            "builtin-new-note",
-            "builtin-search-notes",
-            "builtin-quick-capture",
-            "builtin-new-conversation",
-        ];
 
         // Parse command ID format: "type/identifier"
         if let Some((cmd_type, identifier)) = command_id.split_once('/') {
@@ -352,7 +373,8 @@
                         logging::log("EXEC", &format!("Executing builtin: {}", identifier));
                         self.execute_builtin(entry, cx);
                         // Check if this builtin opens its own window
-                        let needs_main_window = !NO_MAIN_WINDOW_BUILTINS.contains(&identifier);
+                        let needs_main_window =
+                            builtin_needs_main_window_for_command_id(identifier);
                         logging::log(
                             "EXEC",
                             &format!(


thinking
**Replacing toast format calls**
exec
/bin/zsh -lc "sed -i '' 's/format"'!("Failed to open AI: {}", e)/ai_open_failure_message(e)/g'"' src/app_execute/builtin_execution.rs && rg -n \"Failed to open AI|ai_open_failure_message\" src/app_execute/builtin_execution.rs" in /Users/johnlindquist/dev/script-kit-gpui succeeded in 52ms:
1:fn ai_open_failure_message(error: impl std::fmt::Display) -> String {
2:    format!("Failed to open AI: {}", error)
289:                            logging::log("ERROR", &format!("Failed to open AI window: {}", e));
293:                                        ai_open_failure_message(e),
559:                                    ai_open_failure_message(e),
639:                                    logging::log("ERROR", &ai_open_failure_message(e));
642:                                            ai_open_failure_message(e),
690:                                    logging::log("ERROR", &ai_open_failure_message(e));
693:                                            ai_open_failure_message(e),
730:                                    logging::log("ERROR", &ai_open_failure_message(e));
733:                                            ai_open_failure_message(e),
781:                                    logging::log("ERROR", &ai_open_failure_message(e));
784:                                            ai_open_failure_message(e),
833:                            logging::log("ERROR", &ai_open_failure_message(e));
836:                                    ai_open_failure_message(e),
file update:
diff --git a/src/app_execute/builtin_execution.rs b/src/app_execute/builtin_execution.rs
index ea07c5b2c4e5ef82ea1337d249f517425db711fa..3427b1626067b9fb088f8f7145202f52b3b32fae
--- a/src/app_execute/builtin_execution.rs
+++ b/src/app_execute/builtin_execution.rs
@@ -1,3 +1,7 @@
+fn ai_open_failure_message(error: impl std::fmt::Display) -> String {
+    format!("Failed to open AI: {}", error)
+}
+
 impl ScriptListApp {
     fn system_action_feedback_message(
         &self,
@@ -286,7 +290,7 @@
                             let _ = this.update(cx, |this, cx| {
                                 this.toast_manager.push(
                                     components::toast::Toast::error(
-                                        format!("Failed to open AI: {}", e),
+                                        ai_open_failure_message(e),
                                         &this.theme,
                                     )
                                     .duration_ms(Some(5000)),
@@ -552,7 +556,7 @@
                             logging::log("ERROR", &format!("AI command failed: {}", e));
                             self.toast_manager.push(
                                 components::toast::Toast::error(
-                                    format!("Failed to open AI: {}", e),
+                                    ai_open_failure_message(e),
                                     &self.theme,
                                 )
                                 .duration_ms(Some(5000)),
@@ -632,7 +636,15 @@
                                     ),
                                 );
                                 if let Err(e) = ai::open_ai_window(cx) {
-                                    logging::log("ERROR", &format!("Failed to open AI: {}", e));
+                                    logging::log("ERROR", &ai_open_failure_message(e));
+                                    self.toast_manager.push(
+                                        components::toast::Toast::error(
+                                            ai_open_failure_message(e),
+                                            &self.theme,
+                                        )
+                                        .duration_ms(Some(5000)),
+                                    );
+                                    cx.notify();
                                 } else {
                                     // Set input with the screenshot context
                                     ai::set_ai_input_with_image(cx, &message, &base64_data, false);
@@ -675,7 +687,15 @@
                                     ),
                                 );
                                 if let Err(e) = ai::open_ai_window(cx) {
-                                    logging::log("ERROR", &format!("Failed to open AI: {}", e));
+                                    logging::log("ERROR", &ai_open_failure_message(e));
+                                    self.toast_manager.push(
+                                        components::toast::Toast::error(
+                                            ai_open_failure_message(e),
+                                            &self.theme,
+                                        )
+                                        .duration_ms(Some(5000)),
+                                    );
+                                    cx.notify();
                                 } else {
                                     ai::set_ai_input_with_image(cx, &message, &base64_data, false);
                                 }
@@ -707,7 +727,15 @@
                                     &format!("Selected text captured: {} chars", text.len()),
                                 );
                                 if let Err(e) = ai::open_ai_window(cx) {
-                                    logging::log("ERROR", &format!("Failed to open AI: {}", e));
+                                    logging::log("ERROR", &ai_open_failure_message(e));
+                                    self.toast_manager.push(
+                                        components::toast::Toast::error(
+                                            ai_open_failure_message(e),
+                                            &self.theme,
+                                        )
+                                        .duration_ms(Some(5000)),
+                                    );
+                                    cx.notify();
                                 } else {
                                     ai::set_ai_input(cx, &message, false);
                                 }
@@ -750,7 +778,15 @@
                                 );
                                 logging::log("EXEC", &format!("Browser URL captured: {}", url));
                                 if let Err(e) = ai::open_ai_window(cx) {
-                                    logging::log("ERROR", &format!("Failed to open AI: {}", e));
+                                    logging::log("ERROR", &ai_open_failure_message(e));
+                                    self.toast_manager.push(
+                                        components::toast::Toast::error(
+                                            ai_open_failure_message(e),
+                                            &self.theme,
+                                        )
+                                        .duration_ms(Some(5000)),
+                                    );
+                                    cx.notify();
                                 } else {
                                     ai::set_ai_input(cx, &message, false);
                                 }
@@ -794,7 +830,14 @@
                             .duration_ms(Some(3000)),
                         );
                         if let Err(e) = ai::open_ai_window(cx) {
-                            logging::log("ERROR", &format!("Failed to open AI: {}", e));
+                            logging::log("ERROR", &ai_open_failure_message(e));
+                            self.toast_manager.push(
+                                components::toast::Toast::error(
+                                    ai_open_failure_message(e),
+                                    &self.theme,
+                                )
+                                .duration_ms(Some(5000)),
+                            );
                         }
                         cx.notify();
                     }
diff --git a/src/app_impl/execution_scripts.rs b/src/app_impl/execution_scripts.rs
index ac99cc20952af2f8c39e301b7740e55cec8f394e..0f68c29b620a7bf207a81f1ea167f9a8310f71e4
--- a/src/app_impl/execution_scripts.rs
+++ b/src/app_impl/execution_scripts.rs
@@ -1,5 +1,36 @@
 use super::*;
 
+const NO_MAIN_WINDOW_BUILTINS: &[&str] = &[
+    "builtin-ai-chat",
+    "builtin-open-ai",
+    "builtin-notes",
+    "builtin-open-notes",
+    "builtin-new-note",
+    "builtin-search-notes",
+    "builtin-quick-capture",
+    "builtin-new-conversation",
+];
+
+fn builtin_needs_main_window_for_command_id(identifier: &str) -> bool {
+    !NO_MAIN_WINDOW_BUILTINS.contains(&identifier)
+}
+
+#[cfg(test)]
+mod builtin_command_window_visibility_tests {
+    use super::builtin_needs_main_window_for_command_id;
+
+    #[test]
+    fn test_builtin_needs_main_window_false_for_open_ai_and_open_notes() {
+        assert!(!builtin_needs_main_window_for_command_id("builtin-open-ai"));
+        assert!(!builtin_needs_main_window_for_command_id("builtin-open-notes"));
+    }
+
+    #[test]
+    fn test_builtin_needs_main_window_true_for_unlisted_builtin() {
+        assert!(builtin_needs_main_window_for_command_id("builtin-refresh-scripts"));
+    }
+}
+
 impl ScriptListApp {
     pub(crate) fn execute_scriptlet(&mut self, scriptlet: &scripts::Scriptlet, cx: &mut Context<Self>) {
         logging::log(
@@ -312,16 +343,6 @@
             "EXEC",
             &format!("Executing by command ID or path: {}", command_id),
         );
-
-        // Builtins that open their own windows and don't need main window
-        const NO_MAIN_WINDOW_BUILTINS: &[&str] = &[
-            "builtin-ai-chat",
-            "builtin-notes",
-            "builtin-new-note",
-            "builtin-search-notes",
-            "builtin-quick-capture",
-            "builtin-new-conversation",
-        ];
 
         // Parse command ID format: "type/identifier"
         if let Some((cmd_type, identifier)) = command_id.split_once('/') {
@@ -352,7 +373,8 @@
                         logging::log("EXEC", &format!("Executing builtin: {}", identifier));
                         self.execute_builtin(entry, cx);
                         // Check if this builtin opens its own window
-                        let needs_main_window = !NO_MAIN_WINDOW_BUILTINS.contains(&identifier);
+                        let needs_main_window =
+                            builtin_needs_main_window_for_command_id(identifier);
                         logging::log(
                             "EXEC",
                             &format!(


thinking
**Adding tests for logging helper**
file update
M /Users/johnlindquist/dev/script-kit-gpui/src/app_execute/builtin_execution.rs
@@ -1215 +1215,14 @@
 }
+
+#[cfg(test)]
+mod builtin_execution_ai_feedback_tests {
+    use super::ai_open_failure_message;
+
+    #[test]
+    fn test_ai_open_failure_message_includes_error_details() {
+        assert_eq!(
+            ai_open_failure_message("window init failed"),
+            "Failed to open AI: window init failed"
+        );
+    }
+}
apply_patch(auto_approved=true) exited 0 in 16ms:
Success. Updated the following files:
M src/app_execute/builtin_execution.rs
file update:
diff --git a/src/app_execute/builtin_execution.rs b/src/app_execute/builtin_execution.rs
index ea07c5b2c4e5ef82ea1337d249f517425db711fa..7aec3d989171034264f550717466ea395568100d
--- a/src/app_execute/builtin_execution.rs
+++ b/src/app_execute/builtin_execution.rs
@@ -1,3 +1,7 @@
+fn ai_open_failure_message(error: impl std::fmt::Display) -> String {
+    format!("Failed to open AI: {}", error)
+}
+
 impl ScriptListApp {
     fn system_action_feedback_message(
         &self,
@@ -286,7 +290,7 @@
                             let _ = this.update(cx, |this, cx| {
                                 this.toast_manager.push(
                                     components::toast::Toast::error(
-                                        format!("Failed to open AI: {}", e),
+                                        ai_open_failure_message(e),
                                         &this.theme,
                                     )
                                     .duration_ms(Some(5000)),
@@ -552,7 +556,7 @@
                             logging::log("ERROR", &format!("AI command failed: {}", e));
                             self.toast_manager.push(
                                 components::toast::Toast::error(
-                                    format!("Failed to open AI: {}", e),
+                                    ai_open_failure_message(e),
                                     &self.theme,
                                 )
                                 .duration_ms(Some(5000)),
@@ -632,7 +636,15 @@
                                     ),
                                 );
                                 if let Err(e) = ai::open_ai_window(cx) {
-                                    logging::log("ERROR", &format!("Failed to open AI: {}", e));
+                                    logging::log("ERROR", &ai_open_failure_message(e));
+                                    self.toast_manager.push(
+                                        components::toast::Toast::error(
+                                            ai_open_failure_message(e),
+                                            &self.theme,
+                                        )
+                                        .duration_ms(Some(5000)),
+                                    );
+                                    cx.notify();
                                 } else {
                                     // Set input with the screenshot context
                                     ai::set_ai_input_with_image(cx, &message, &base64_data, false);
@@ -675,7 +687,15 @@
                                     ),
                                 );
                                 if let Err(e) = ai::open_ai_window(cx) {
-                                    logging::log("ERROR", &format!("Failed to open AI: {}", e));
+                                    logging::log("ERROR", &ai_open_failure_message(e));
+                                    self.toast_manager.push(
+                                        components::toast::Toast::error(
+                                            ai_open_failure_message(e),
+                                            &self.theme,
+                                        )
+                                        .duration_ms(Some(5000)),
+                                    );
+                                    cx.notify();
                                 } else {
                                     ai::set_ai_input_with_image(cx, &message, &base64_data, false);
                                 }
@@ -707,7 +727,15 @@
                                     &format!("Selected text captured: {} chars", text.len()),
                                 );
                                 if let Err(e) = ai::open_ai_window(cx) {
-                                    logging::log("ERROR", &format!("Failed to open AI: {}", e));
+                                    logging::log("ERROR", &ai_open_failure_message(e));
+                                    self.toast_manager.push(
+                                        components::toast::Toast::error(
+                                            ai_open_failure_message(e),
+                                            &self.theme,
+                                        )
+                                        .duration_ms(Some(5000)),
+                                    );
+                                    cx.notify();
                                 } else {
                                     ai::set_ai_input(cx, &message, false);
                                 }
@@ -750,7 +778,15 @@
                                 );
                                 logging::log("EXEC", &format!("Browser URL captured: {}", url));
                                 if let Err(e) = ai::open_ai_window(cx) {
-                                    logging::log("ERROR", &format!("Failed to open AI: {}", e));
+                                    logging::log("ERROR", &ai_open_failure_message(e));
+                                    self.toast_manager.push(
+                                        components::toast::Toast::error(
+                                            ai_open_failure_message(e),
+                                            &self.theme,
+                                        )
+                                        .duration_ms(Some(5000)),
+                                    );
+                                    cx.notify();
                                 } else {
                                     ai::set_ai_input(cx, &message, false);
                                 }
@@ -794,7 +830,14 @@
                             .duration_ms(Some(3000)),
                         );
                         if let Err(e) = ai::open_ai_window(cx) {
-                            logging::log("ERROR", &format!("Failed to open AI: {}", e));
+                            logging::log("ERROR", &ai_open_failure_message(e));
+                            self.toast_manager.push(
+                                components::toast::Toast::error(
+                                    ai_open_failure_message(e),
+                                    &self.theme,
+                                )
+                                .duration_ms(Some(5000)),
+                            );
                         }
                         cx.notify();
                     }
@@ -1170,3 +1213,16 @@
         }
     }
 }
+
+#[cfg(test)]
+mod builtin_execution_ai_feedback_tests {
+    use super::ai_open_failure_message;
+
+    #[test]
+    fn test_ai_open_failure_message_includes_error_details() {
+        assert_eq!(
+            ai_open_failure_message("window init failed"),
+            "Failed to open AI: window init failed"
+        );
+    }
+}
diff --git a/src/app_impl/execution_scripts.rs b/src/app_impl/execution_scripts.rs
index ac99cc20952af2f8c39e301b7740e55cec8f394e..0f68c29b620a7bf207a81f1ea167f9a8310f71e4
--- a/src/app_impl/execution_scripts.rs
+++ b/src/app_impl/execution_scripts.rs
@@ -1,5 +1,36 @@
 use super::*;
 
+const NO_MAIN_WINDOW_BUILTINS: &[&str] = &[
+    "builtin-ai-chat",
+    "builtin-open-ai",
+    "builtin-notes",
+    "builtin-open-notes",
+    "builtin-new-note",
+    "builtin-search-notes",
+    "builtin-quick-capture",
+    "builtin-new-conversation",
+];
+
+fn builtin_needs_main_window_for_command_id(identifier: &str) -> bool {
+    !NO_MAIN_WINDOW_BUILTINS.contains(&identifier)
+}
+
+#[cfg(test)]
+mod builtin_command_window_visibility_tests {
+    use super::builtin_needs_main_window_for_command_id;
+
+    #[test]
+    fn test_builtin_needs_main_window_false_for_open_ai_and_open_notes() {
+        assert!(!builtin_needs_main_window_for_command_id("builtin-open-ai"));
+        assert!(!builtin_needs_main_window_for_command_id("builtin-open-notes"));
+    }
+
+    #[test]
+    fn test_builtin_needs_main_window_true_for_unlisted_builtin() {
+        assert!(builtin_needs_main_window_for_command_id("builtin-refresh-scripts"));
+    }
+}
+
 impl ScriptListApp {
     pub(crate) fn execute_scriptlet(&mut self, scriptlet: &scripts::Scriptlet, cx: &mut Context<Self>) {
         logging::log(
@@ -312,16 +343,6 @@
             "EXEC",
             &format!("Executing by command ID or path: {}", command_id),
         );
-
-        // Builtins that open their own windows and don't need main window
-        const NO_MAIN_WINDOW_BUILTINS: &[&str] = &[
-            "builtin-ai-chat",
-            "builtin-notes",
-            "builtin-new-note",
-            "builtin-search-notes",
-            "builtin-quick-capture",
-            "builtin-new-conversation",
-        ];
 
         // Parse command ID format: "type/identifier"
         if let Some((cmd_type, identifier)) = command_id.split_once('/') {
@@ -352,7 +373,8 @@
                         logging::log("EXEC", &format!("Executing builtin: {}", identifier));
                         self.execute_builtin(entry, cx);
                         // Check if this builtin opens its own window
-                        let needs_main_window = !NO_MAIN_WINDOW_BUILTINS.contains(&identifier);
+                        let needs_main_window =
+                            builtin_needs_main_window_for_command_id(identifier);
                         logging::log(
                             "EXEC",
                             &format!(

file update:
diff --git a/src/app_execute/builtin_execution.rs b/src/app_execute/builtin_execution.rs
index ea07c5b2c4e5ef82ea1337d249f517425db711fa..7aec3d989171034264f550717466ea395568100d
--- a/src/app_execute/builtin_execution.rs
+++ b/src/app_execute/builtin_execution.rs
@@ -1,3 +1,7 @@
+fn ai_open_failure_message(error: impl std::fmt::Display) -> String {
+    format!("Failed to open AI: {}", error)
+}
+
 impl ScriptListApp {
     fn system_action_feedback_message(
         &self,
@@ -286,7 +290,7 @@
                             let _ = this.update(cx, |this, cx| {
                                 this.toast_manager.push(
                                     components::toast::Toast::error(
-                                        format!("Failed to open AI: {}", e),
+                                        ai_open_failure_message(e),
                                         &this.theme,
                                     )
                                     .duration_ms(Some(5000)),
@@ -552,7 +556,7 @@
                             logging::log("ERROR", &format!("AI command failed: {}", e));
                             self.toast_manager.push(
                                 components::toast::Toast::error(
-                                    format!("Failed to open AI: {}", e),
+                                    ai_open_failure_message(e),
                                     &self.theme,
                                 )
                                 .duration_ms(Some(5000)),
@@ -632,7 +636,15 @@
                                     ),
                                 );
                                 if let Err(e) = ai::open_ai_window(cx) {
-                                    logging::log("ERROR", &format!("Failed to open AI: {}", e));
+                                    logging::log("ERROR", &ai_open_failure_message(e));
+                                    self.toast_manager.push(
+                                        components::toast::Toast::error(
+                                            ai_open_failure_message(e),
+                                            &self.theme,
+                                        )
+                                        .duration_ms(Some(5000)),
+                                    );
+                                    cx.notify();
                                 } else {
                                     // Set input with the screenshot context
                                     ai::set_ai_input_with_image(cx, &message, &base64_data, false);
@@ -675,7 +687,15 @@
                                     ),
                                 );
                                 if let Err(e) = ai::open_ai_window(cx) {
-                                    logging::log("ERROR", &format!("Failed to open AI: {}", e));
+                                    logging::log("ERROR", &ai_open_failure_message(e));
+                                    self.toast_manager.push(
+                                        components::toast::Toast::error(
+                                            ai_open_failure_message(e),
+                                            &self.theme,
+                                        )
+                                        .duration_ms(Some(5000)),
+                                    );
+                                    cx.notify();
                                 } else {
                                     ai::set_ai_input_with_image(cx, &message, &base64_data, false);
                                 }
@@ -707,7 +727,15 @@
                                     &format!("Selected text captured: {} chars", text.len()),
                                 );
                                 if let Err(e) = ai::open_ai_window(cx) {
-                                    logging::log("ERROR", &format!("Failed to open AI: {}", e));
+                                    logging::log("ERROR", &ai_open_failure_message(e));
+                                    self.toast_manager.push(
+                                        components::toast::Toast::error(
+                                            ai_open_failure_message(e),
+                                            &self.theme,
+                                        )
+                                        .duration_ms(Some(5000)),
+                                    );
+                                    cx.notify();
                                 } else {
                                     ai::set_ai_input(cx, &message, false);
                                 }
@@ -750,7 +778,15 @@
                                 );
                                 logging::log("EXEC", &format!("Browser URL captured: {}", url));
                                 if let Err(e) = ai::open_ai_window(cx) {
-                                    logging::log("ERROR", &format!("Failed to open AI: {}", e));
+                                    logging::log("ERROR", &ai_open_failure_message(e));
+                                    self.toast_manager.push(
+                                        components::toast::Toast::error(
+                                            ai_open_failure_message(e),
+                                            &self.theme,
+                                        )
+                                        .duration_ms(Some(5000)),
+                                    );
+                                    cx.notify();
                                 } else {
                                     ai::set_ai_input(cx, &message, false);
                                 }
@@ -794,7 +830,14 @@
                             .duration_ms(Some(3000)),
                         );
                         if let Err(e) = ai::open_ai_window(cx) {
-                            logging::log("ERROR", &format!("Failed to open AI: {}", e));
+                            logging::log("ERROR", &ai_open_failure_message(e));
+                            self.toast_manager.push(
+                                components::toast::Toast::error(
+                                    ai_open_failure_message(e),
+                                    &self.theme,
+                                )
+                                .duration_ms(Some(5000)),
+                            );
                         }
                         cx.notify();
                     }
@@ -1170,3 +1213,16 @@
         }
     }
 }
+
+#[cfg(test)]
+mod builtin_execution_ai_feedback_tests {
+    use super::ai_open_failure_message;
+
+    #[test]
+    fn test_ai_open_failure_message_includes_error_details() {
+        assert_eq!(
+            ai_open_failure_message("window init failed"),
+            "Failed to open AI: window init failed"
+        );
+    }
+}
diff --git a/src/app_impl/execution_scripts.rs b/src/app_impl/execution_scripts.rs
index ac99cc20952af2f8c39e301b7740e55cec8f394e..0f68c29b620a7bf207a81f1ea167f9a8310f71e4
--- a/src/app_impl/execution_scripts.rs
+++ b/src/app_impl/execution_scripts.rs
@@ -1,5 +1,36 @@
 use super::*;
 
+const NO_MAIN_WINDOW_BUILTINS: &[&str] = &[
+    "builtin-ai-chat",
+    "builtin-open-ai",
+    "builtin-notes",
+    "builtin-open-notes",
+    "builtin-new-note",
+    "builtin-search-notes",
+    "builtin-quick-capture",
+    "builtin-new-conversation",
+];
+
+fn builtin_needs_main_window_for_command_id(identifier: &str) -> bool {
+    !NO_MAIN_WINDOW_BUILTINS.contains(&identifier)
+}
+
+#[cfg(test)]
+mod builtin_command_window_visibility_tests {
+    use super::builtin_needs_main_window_for_command_id;
+
+    #[test]
+    fn test_builtin_needs_main_window_false_for_open_ai_and_open_notes() {
+        assert!(!builtin_needs_main_window_for_command_id("builtin-open-ai"));
+        assert!(!builtin_needs_main_window_for_command_id("builtin-open-notes"));
+    }
+
+    #[test]
+    fn test_builtin_needs_main_window_true_for_unlisted_builtin() {
+        assert!(builtin_needs_main_window_for_command_id("builtin-refresh-scripts"));
+    }
+}
+
 impl ScriptListApp {
     pub(crate) fn execute_scriptlet(&mut self, scriptlet: &scripts::Scriptlet, cx: &mut Context<Self>) {
         logging::log(
@@ -312,16 +343,6 @@
             "EXEC",
             &format!("Executing by command ID or path: {}", command_id),
         );
-
-        // Builtins that open their own windows and don't need main window
-        const NO_MAIN_WINDOW_BUILTINS: &[&str] = &[
-            "builtin-ai-chat",
-            "builtin-notes",
-            "builtin-new-note",
-            "builtin-search-notes",
-            "builtin-quick-capture",
-            "builtin-new-conversation",
-        ];
 
         // Parse command ID format: "type/identifier"
         if let Some((cmd_type, identifier)) = command_id.split_once('/') {
@@ -352,7 +373,8 @@
                         logging::log("EXEC", &format!("Executing builtin: {}", identifier));
                         self.execute_builtin(entry, cx);
                         // Check if this builtin opens its own window
-                        let needs_main_window = !NO_MAIN_WINDOW_BUILTINS.contains(&identifier);
+                        let needs_main_window =
+                            builtin_needs_main_window_for_command_id(identifier);
                         logging::log(
                             "EXEC",
                             &format!(


thinking
**Inspecting modified test sections**
exec
/bin/zsh -lc "nl -ba src/app_execute/builtin_execution.rs | sed -n '1,40p'; echo '---'; nl -ba src/app_execute/builtin_execution.rs | sed -n '600,860p'; echo '---'; tail -n 40 src/app_execute/builtin_execution.rs | nl -ba; echo '---'; nl -ba src/app_impl/execution_scripts.rs | sed -n '1,80p'; echo '---'; tail -n 60 src/app_impl/execution_scripts.rs | nl -ba" in /Users/johnlindquist/dev/script-kit-gpui succeeded in 51ms:
     1	fn ai_open_failure_message(error: impl std::fmt::Display) -> String {
     2	    format!("Failed to open AI: {}", error)
     3	}
     4	
     5	impl ScriptListApp {
     6	    fn system_action_feedback_message(
     7	        &self,
     8	        action_type: &builtins::SystemActionType,
     9	    ) -> Option<String> {
    10	        let dark_mode_enabled = if matches!(action_type, builtins::SystemActionType::ToggleDarkMode)
    11	        {
    12	            system_actions::is_dark_mode().ok()
    13	        } else {
    14	            None
    15	        };
    16	
    17	        builtins::system_action_hud_message(*action_type, dark_mode_enabled)
    18	    }
    19	
    20	    fn execute_builtin(&mut self, entry: &builtins::BuiltInEntry, cx: &mut Context<Self>) {
file update:
diff --git a/src/app_execute/builtin_execution.rs b/src/app_execute/builtin_execution.rs
index ea07c5b2c4e5ef82ea1337d249f517425db711fa..7aec3d989171034264f550717466ea395568100d
--- a/src/app_execute/builtin_execution.rs
+++ b/src/app_execute/builtin_execution.rs
@@ -1,3 +1,7 @@
+fn ai_open_failure_message(error: impl std::fmt::Display) -> String {
+    format!("Failed to open AI: {}", error)
+}
+
 impl ScriptListApp {
     fn system_action_feedback_message(
         &self,
@@ -286,7 +290,7 @@
                             let _ = this.update(cx, |this, cx| {
                                 this.toast_manager.push(
                                     components::toast::Toast::error(
-                                        format!("Failed to open AI: {}", e),
+                                        ai_open_failure_message(e),
                                         &this.theme,
                                     )
                                     .duration_ms(Some(5000)),
@@ -552,7 +556,7 @@
                             logging::log("ERROR", &format!("AI command failed: {}", e));
                             self.toast_manager.push(
                                 components::toast::Toast::error(
-                                    format!("Failed to open AI: {}", e),
+                                    ai_open_failure_message(e),
                                     &self.theme,
                                 )
                                 .duration_ms(Some(5000)),
@@ -632,7 +636,15 @@
                                     ),
                                 );
                                 if let Err(e) = ai::open_ai_window(cx) {
-                                    logging::log("ERROR", &format!("Failed to open AI: {}", e));
+                                    logging::log("ERROR", &ai_open_failure_message(e));
+                                    self.toast_manager.push(
+                                        components::toast::Toast::error(
+                                            ai_open_failure_message(e),
+                                            &self.theme,
+                                        )
+                                        .duration_ms(Some(5000)),
+                                    );
+                                    cx.notify();
                                 } else {
                                     // Set input with the screenshot context
                                     ai::set_ai_input_with_image(cx, &message, &base64_data, false);
@@ -675,7 +687,15 @@
                                     ),
                                 );
                                 if let Err(e) = ai::open_ai_window(cx) {
-                                    logging::log("ERROR", &format!("Failed to open AI: {}", e));
+                                    logging::log("ERROR", &ai_open_failure_message(e));
+                                    self.toast_manager.push(
+                                        components::toast::Toast::error(
+                                            ai_open_failure_message(e),
+                                            &self.theme,
+                                        )
+                                        .duration_ms(Some(5000)),
+                                    );
+                                    cx.notify();
                                 } else {
                                     ai::set_ai_input_with_image(cx, &message, &base64_data, false);
                                 }
@@ -707,7 +727,15 @@
                                     &format!("Selected text captured: {} chars", text.len()),
                                 );
                                 if let Err(e) = ai::open_ai_window(cx) {
-                                    logging::log("ERROR", &format!("Failed to open AI: {}", e));
+                                    logging::log("ERROR", &ai_open_failure_message(e));
+                                    self.toast_manager.push(
+                                        components::toast::Toast::error(
+                                            ai_open_failure_message(e),
+                                            &self.theme,
+                                        )
+                                        .duration_ms(Some(5000)),
+                                    );
+                                    cx.notify();
                                 } else {
                                     ai::set_ai_input(cx, &message, false);
                                 }
@@ -750,7 +778,15 @@
                                 );
                                 logging::log("EXEC", &format!("Browser URL captured: {}", url));
                                 if let Err(e) = ai::open_ai_window(cx) {
-                                    logging::log("ERROR", &format!("Failed to open AI: {}", e));
+                                    logging::log("ERROR", &ai_open_failure_message(e));
+                                    self.toast_manager.push(
+                                        components::toast::Toast::error(
+                                            ai_open_failure_message(e),
+                                            &self.theme,
+                                        )
+                                        .duration_ms(Some(5000)),
+                                    );
+                                    cx.notify();
                                 } else {
                                     ai::set_ai_input(cx, &message, false);
                                 }
@@ -794,7 +830,14 @@
                             .duration_ms(Some(3000)),
                         );
                         if let Err(e) = ai::open_ai_window(cx) {
-                            logging::log("ERROR", &format!("Failed to open AI: {}", e));
+                            logging::log("ERROR", &ai_open_failure_message(e));
+                            self.toast_manager.push(
+                                components::toast::Toast::error(
+                                    ai_open_failure_message(e),
+                                    &self.theme,
+                                )
+                                .duration_ms(Some(5000)),
+                            );
                         }
                         cx.notify();
                     }
@@ -1170,3 +1213,16 @@
         }
     }
 }
+
+#[cfg(test)]
+mod builtin_execution_ai_feedback_tests {
+    use super::ai_open_failure_message;
+
+    #[test]
+    fn test_ai_open_failure_message_includes_error_details() {
+        assert_eq!(
+            ai_open_failure_message("window init failed"),
+            "Failed to open AI: window init failed"
+        );
+    }
+}
diff --git a/src/app_impl/execution_scripts.rs b/src/app_impl/execution_scripts.rs
index ac99cc20952af2f8c39e301b7740e55cec8f394e..0f68c29b620a7bf207a81f1ea167f9a8310f71e4
--- a/src/app_impl/execution_scripts.rs
+++ b/src/app_impl/execution_scripts.rs
@@ -1,5 +1,36 @@
 use super::*;
 
+const NO_MAIN_WINDOW_BUILTINS: &[&str] = &[
+    "builtin-ai-chat",
+    "builtin-open-ai",
+    "builtin-notes",
+    "builtin-open-notes",
+    "builtin-new-note",
+    "builtin-search-notes",
+    "builtin-quick-capture",
+    "builtin-new-conversation",
+];
+
+fn builtin_needs_main_window_for_command_id(identifier: &str) -> bool {
+    !NO_MAIN_WINDOW_BUILTINS.contains(&identifier)
+}
+
+#[cfg(test)]
+mod builtin_command_window_visibility_tests {
+    use super::builtin_needs_main_window_for_command_id;
+
+    #[test]
+    fn test_builtin_needs_main_window_false_for_open_ai_and_open_notes() {
+        assert!(!builtin_needs_main_window_for_command_id("builtin-open-ai"));
+        assert!(!builtin_needs_main_window_for_command_id("builtin-open-notes"));
+    }
+
+    #[test]
+    fn test_builtin_needs_main_window_true_for_unlisted_builtin() {
+        assert!(builtin_needs_main_window_for_command_id("builtin-refresh-scripts"));
+    }
+}
+
 impl ScriptListApp {
     pub(crate) fn execute_scriptlet(&mut self, scriptlet: &scripts::Scriptlet, cx: &mut Context<Self>) {
         logging::log(
@@ -312,16 +343,6 @@
             "EXEC",
             &format!("Executing by command ID or path: {}", command_id),
         );
-
-        // Builtins that open their own windows and don't need main window
-        const NO_MAIN_WINDOW_BUILTINS: &[&str] = &[
-            "builtin-ai-chat",
-            "builtin-notes",
-            "builtin-new-note",
-            "builtin-search-notes",
-            "builtin-quick-capture",
-            "builtin-new-conversation",
-        ];
 
         // Parse command ID format: "type/identifier"
         if let Some((cmd_type, identifier)) = command_id.split_once('/') {
@@ -352,7 +373,8 @@
                         logging::log("EXEC", &format!("Executing builtin: {}", identifier));
                         self.execute_builtin(entry, cx);
                         // Check if this builtin opens its own window
-                        let needs_main_window = !NO_MAIN_WINDOW_BUILTINS.contains(&identifier);
+                        let needs_main_window =
+                            builtin_needs_main_window_for_command_id(identifier);
                         logging::log(
                             "EXEC",
                             &format!(


thinking
**Verifying code modifications near line 559**
exec
/bin/zsh -lc "nl -ba src/app_execute/builtin_execution.rs | sed -n '530,610p'" in /Users/johnlindquist/dev/script-kit-gpui succeeded in 51ms:
   530	                            format!("Notes command failed: {}", e),
   531	                            &self.theme,
   532	                        )
   533	                        .duration_ms(Some(5000)),
   534	                    );
   535	                    cx.notify();
   536	                }
   537	            }
   538	
   539	            // =========================================================================
   540	            // AI Commands
   541	            // =========================================================================
   542	            builtins::BuiltInFeature::AiCommand(cmd_type) => {
   543	                logging::log("EXEC", &format!("Executing AI command: {:?}", cmd_type));
   544	
   545	                use builtins::AiCommandType;
   546	
   547	                // All AI commands: reset state, hide main window
   548	                script_kit_gpui::set_main_window_visible(false);
   549	                self.reset_to_script_list(cx);
file update:
diff --git a/src/app_execute/builtin_execution.rs b/src/app_execute/builtin_execution.rs
index ea07c5b2c4e5ef82ea1337d249f517425db711fa..7aec3d989171034264f550717466ea395568100d
--- a/src/app_execute/builtin_execution.rs
+++ b/src/app_execute/builtin_execution.rs
@@ -1,3 +1,7 @@
+fn ai_open_failure_message(error: impl std::fmt::Display) -> String {
+    format!("Failed to open AI: {}", error)
+}
+
 impl ScriptListApp {
     fn system_action_feedback_message(
         &self,
@@ -286,7 +290,7 @@
                             let _ = this.update(cx, |this, cx| {
                                 this.toast_manager.push(
                                     components::toast::Toast::error(
-                                        format!("Failed to open AI: {}", e),
+                                        ai_open_failure_message(e),
                                         &this.theme,
                                     )
                                     .duration_ms(Some(5000)),
@@ -552,7 +556,7 @@
                             logging::log("ERROR", &format!("AI command failed: {}", e));
                             self.toast_manager.push(
                                 components::toast::Toast::error(
-                                    format!("Failed to open AI: {}", e),
+                                    ai_open_failure_message(e),
                                     &self.theme,
                                 )
                                 .duration_ms(Some(5000)),
@@ -632,7 +636,15 @@
                                     ),
                                 );
                                 if let Err(e) = ai::open_ai_window(cx) {
-                                    logging::log("ERROR", &format!("Failed to open AI: {}", e));
+                                    logging::log("ERROR", &ai_open_failure_message(e));
+                                    self.toast_manager.push(
+                                        components::toast::Toast::error(
+                                            ai_open_failure_message(e),
+                                            &self.theme,
+                                        )
+                                        .duration_ms(Some(5000)),
+                                    );
+                                    cx.notify();
                                 } else {
                                     // Set input with the screenshot context
                                     ai::set_ai_input_with_image(cx, &message, &base64_data, false);
@@ -675,7 +687,15 @@
                                     ),
                                 );
                                 if let Err(e) = ai::open_ai_window(cx) {
-                                    logging::log("ERROR", &format!("Failed to open AI: {}", e));
+                                    logging::log("ERROR", &ai_open_failure_message(e));
+                                    self.toast_manager.push(
+                                        components::toast::Toast::error(
+                                            ai_open_failure_message(e),
+                                            &self.theme,
+                                        )
+                                        .duration_ms(Some(5000)),
+                                    );
+                                    cx.notify();
                                 } else {
                                     ai::set_ai_input_with_image(cx, &message, &base64_data, false);
                                 }
@@ -707,7 +727,15 @@
                                     &format!("Selected text captured: {} chars", text.len()),
                                 );
                                 if let Err(e) = ai::open_ai_window(cx) {
-                                    logging::log("ERROR", &format!("Failed to open AI: {}", e));
+                                    logging::log("ERROR", &ai_open_failure_message(e));
+                                    self.toast_manager.push(
+                                        components::toast::Toast::error(
+                                            ai_open_failure_message(e),
+                                            &self.theme,
+                                        )
+                                        .duration_ms(Some(5000)),
+                                    );
+                                    cx.notify();
                                 } else {
                                     ai::set_ai_input(cx, &message, false);
                                 }
@@ -750,7 +778,15 @@
                                 );
                                 logging::log("EXEC", &format!("Browser URL captured: {}", url));
                                 if let Err(e) = ai::open_ai_window(cx) {
-                                    logging::log("ERROR", &format!("Failed to open AI: {}", e));
+                                    logging::log("ERROR", &ai_open_failure_message(e));
+                                    self.toast_manager.push(
+                                        components::toast::Toast::error(
+                                            ai_open_failure_message(e),
+                                            &self.theme,
+                                        )
+                                        .duration_ms(Some(5000)),
+                                    );
+                                    cx.notify();
                                 } else {
                                     ai::set_ai_input(cx, &message, false);
                                 }
@@ -794,7 +830,14 @@
                             .duration_ms(Some(3000)),
                         );
                         if let Err(e) = ai::open_ai_window(cx) {
-                            logging::log("ERROR", &format!("Failed to open AI: {}", e));
+                            logging::log("ERROR", &ai_open_failure_message(e));
+                            self.toast_manager.push(
+                                components::toast::Toast::error(
+                                    ai_open_failure_message(e),
+                                    &self.theme,
+                                )
+                                .duration_ms(Some(5000)),
+                            );
                         }
                         cx.notify();
                     }
@@ -1170,3 +1213,16 @@
         }
     }
 }
+
+#[cfg(test)]
+mod builtin_execution_ai_feedback_tests {
+    use super::ai_open_failure_message;
+
+    #[test]
+    fn test_ai_open_failure_message_includes_error_details() {
+        assert_eq!(
+            ai_open_failure_message("window init failed"),
+            "Failed to open AI: window init failed"
+        );
+    }
+}
diff --git a/src/app_impl/execution_scripts.rs b/src/app_impl/execution_scripts.rs
index ac99cc20952af2f8c39e301b7740e55cec8f394e..0f68c29b620a7bf207a81f1ea167f9a8310f71e4
--- a/src/app_impl/execution_scripts.rs
+++ b/src/app_impl/execution_scripts.rs
@@ -1,5 +1,36 @@
 use super::*;
 
+const NO_MAIN_WINDOW_BUILTINS: &[&str] = &[
+    "builtin-ai-chat",
+    "builtin-open-ai",
+    "builtin-notes",
+    "builtin-open-notes",
+    "builtin-new-note",
+    "builtin-search-notes",
+    "builtin-quick-capture",
+    "builtin-new-conversation",
+];
+
+fn builtin_needs_main_window_for_command_id(identifier: &str) -> bool {
+    !NO_MAIN_WINDOW_BUILTINS.contains(&identifier)
+}
+
+#[cfg(test)]
+mod builtin_command_window_visibility_tests {
+    use super::builtin_needs_main_window_for_command_id;
+
+    #[test]
+    fn test_builtin_needs_main_window_false_for_open_ai_and_open_notes() {
+        assert!(!builtin_needs_main_window_for_command_id("builtin-open-ai"));
+        assert!(!builtin_needs_main_window_for_command_id("builtin-open-notes"));
+    }
+
+    #[test]
+    fn test_builtin_needs_main_window_true_for_unlisted_builtin() {
+        assert!(builtin_needs_main_window_for_command_id("builtin-refresh-scripts"));
+    }
+}
+
 impl ScriptListApp {
     pub(crate) fn execute_scriptlet(&mut self, scriptlet: &scripts::Scriptlet, cx: &mut Context<Self>) {
         logging::log(
@@ -312,16 +343,6 @@
             "EXEC",
             &format!("Executing by command ID or path: {}", command_id),
         );
-
-        // Builtins that open their own windows and don't need main window
-        const NO_MAIN_WINDOW_BUILTINS: &[&str] = &[
-            "builtin-ai-chat",
-            "builtin-notes",
-            "builtin-new-note",
-            "builtin-search-notes",
-            "builtin-quick-capture",
-            "builtin-new-conversation",
-        ];
 
         // Parse command ID format: "type/identifier"
         if let Some((cmd_type, identifier)) = command_id.split_once('/') {
@@ -352,7 +373,8 @@
                         logging::log("EXEC", &format!("Executing builtin: {}", identifier));
                         self.execute_builtin(entry, cx);
                         // Check if this builtin opens its own window
-                        let needs_main_window = !NO_MAIN_WINDOW_BUILTINS.contains(&identifier);
+                        let needs_main_window =
+                            builtin_needs_main_window_for_command_id(identifier);
                         logging::log(
                             "EXEC",
                             &format!(


thinking
**Planning targeted tests and lint**
codex
Edits are in place. I‚Äôm now running scoped verification for this crate: two focused unit-test filters for the new coverage, then `cargo check` and `cargo clippy --all-targets -- -D warnings` scoped to the package.

thinking
**Planning resilient command execution**
exec
/bin/zsh -lc 'cargo test -p script-kit-gpui builtin_execution_ai_feedback_tests' in /Users/johnlindquist/dev/script-kit-gpui exited 101 in 18.75s:
   Compiling script-kit-gpui v0.1.0 (/Users/johnlindquist/dev/script-kit-gpui)
error[E0761]: file for module `tests` found at both "src/protocol/message/tests.rs" and "src/protocol/message/tests/mod.rs"
  --> src/protocol/message/mod.rs:87:1
   |
87 | mod tests;
   | ^^^^^^^^^^
   |
   = help: delete or rename one of them to remove the ambiguity

error[E0761]: file for module `tests` found at both "src/designs/core/tests.rs" and "src/designs/core/tests/mod.rs"
 --> src/designs/core/part_04.rs:2:1
  |
2 | mod tests;
  | ^^^^^^^^^^
  |
  = help: delete or rename one of them to remove the ambiguity

warning: glob import doesn't reexport anything with visibility `pub(in crate::prompts)` because no imported item is public enough
  --> src/prompts/div/mod.rs:32:16
   |
file update:
diff --git a/src/app_execute/builtin_execution.rs b/src/app_execute/builtin_execution.rs
index ea07c5b2c4e5ef82ea1337d249f517425db711fa..7aec3d989171034264f550717466ea395568100d
--- a/src/app_execute/builtin_execution.rs
+++ b/src/app_execute/builtin_execution.rs
@@ -1,3 +1,7 @@
+fn ai_open_failure_message(error: impl std::fmt::Display) -> String {
+    format!("Failed to open AI: {}", error)
+}
+
 impl ScriptListApp {
     fn system_action_feedback_message(
         &self,
@@ -286,7 +290,7 @@
                             let _ = this.update(cx, |this, cx| {
                                 this.toast_manager.push(
                                     components::toast::Toast::error(
-                                        format!("Failed to open AI: {}", e),
+                                        ai_open_failure_message(e),
                                         &this.theme,
                                     )
                                     .duration_ms(Some(5000)),
@@ -552,7 +556,7 @@
                             logging::log("ERROR", &format!("AI command failed: {}", e));
                             self.toast_manager.push(
                                 components::toast::Toast::error(
-                                    format!("Failed to open AI: {}", e),
+                                    ai_open_failure_message(e),
                                     &self.theme,
                                 )
                                 .duration_ms(Some(5000)),
@@ -632,7 +636,15 @@
                                     ),
                                 );
                                 if let Err(e) = ai::open_ai_window(cx) {
-                                    logging::log("ERROR", &format!("Failed to open AI: {}", e));
+                                    logging::log("ERROR", &ai_open_failure_message(e));
+                                    self.toast_manager.push(
+                                        components::toast::Toast::error(
+                                            ai_open_failure_message(e),
+                                            &self.theme,
+                                        )
+                                        .duration_ms(Some(5000)),
+                                    );
+                                    cx.notify();
                                 } else {
                                     // Set input with the screenshot context
                                     ai::set_ai_input_with_image(cx, &message, &base64_data, false);
@@ -675,7 +687,15 @@
                                     ),
                                 );
                                 if let Err(e) = ai::open_ai_window(cx) {
-                                    logging::log("ERROR", &format!("Failed to open AI: {}", e));
+                                    logging::log("ERROR", &ai_open_failure_message(e));
+                                    self.toast_manager.push(
+                                        components::toast::Toast::error(
+                                            ai_open_failure_message(e),
+                                            &self.theme,
+                                        )
+                                        .duration_ms(Some(5000)),
+                                    );
+                                    cx.notify();
                                 } else {
                                     ai::set_ai_input_with_image(cx, &message, &base64_data, false);
                                 }
@@ -707,7 +727,15 @@
                                     &format!("Selected text captured: {} chars", text.len()),
                                 );
                                 if let Err(e) = ai::open_ai_window(cx) {
-                                    logging::log("ERROR", &format!("Failed to open AI: {}", e));
+                                    logging::log("ERROR", &ai_open_failure_message(e));
+                                    self.toast_manager.push(
+                                        components::toast::Toast::error(
+                                            ai_open_failure_message(e),
+                                            &self.theme,
+                                        )
+                                        .duration_ms(Some(5000)),
+                                    );
+                                    cx.notify();
                                 } else {
                                     ai::set_ai_input(cx, &message, false);
                                 }
@@ -750,7 +778,15 @@
                                 );
                                 logging::log("EXEC", &format!("Browser URL captured: {}", url));
                                 if let Err(e) = ai::open_ai_window(cx) {
-                                    logging::log("ERROR", &format!("Failed to open AI: {}", e));
+                                    logging::log("ERROR", &ai_open_failure_message(e));
+                                    self.toast_manager.push(
+                                        components::toast::Toast::error(
+                                            ai_open_failure_message(e),
+                                            &self.theme,
+                                        )
+                                        .duration_ms(Some(5000)),
+                                    );
+                                    cx.notify();
                                 } else {
                                     ai::set_ai_input(cx, &message, false);
                                 }
@@ -794,7 +830,14 @@
                             .duration_ms(Some(3000)),
                         );
                         if let Err(e) = ai::open_ai_window(cx) {
-                            logging::log("ERROR", &format!("Failed to open AI: {}", e));
+                            logging::log("ERROR", &ai_open_failure_message(e));
+                            self.toast_manager.push(
+                                components::toast::Toast::error(
+                                    ai_open_failure_message(e),
+                                    &self.theme,
+                                )
+                                .duration_ms(Some(5000)),
+                            );
                         }
                         cx.notify();
                     }
@@ -1170,3 +1213,16 @@
         }
     }
 }
+
+#[cfg(test)]
+mod builtin_execution_ai_feedback_tests {
+    use super::ai_open_failure_message;
+
+    #[test]
+    fn test_ai_open_failure_message_includes_error_details() {
+        assert_eq!(
+            ai_open_failure_message("window init failed"),
+            "Failed to open AI: window init failed"
+        );
+    }
+}
diff --git a/src/app_impl/execution_scripts.rs b/src/app_impl/execution_scripts.rs
index ac99cc20952af2f8c39e301b7740e55cec8f394e..0f68c29b620a7bf207a81f1ea167f9a8310f71e4
--- a/src/app_impl/execution_scripts.rs
+++ b/src/app_impl/execution_scripts.rs
@@ -1,5 +1,36 @@
 use super::*;
 
+const NO_MAIN_WINDOW_BUILTINS: &[&str] = &[
+    "builtin-ai-chat",
+    "builtin-open-ai",
+    "builtin-notes",
+    "builtin-open-notes",
+    "builtin-new-note",
+    "builtin-search-notes",
+    "builtin-quick-capture",
+    "builtin-new-conversation",
+];
+
+fn builtin_needs_main_window_for_command_id(identifier: &str) -> bool {
+    !NO_MAIN_WINDOW_BUILTINS.contains(&identifier)
+}
+
+#[cfg(test)]
+mod builtin_command_window_visibility_tests {
+    use super::builtin_needs_main_window_for_command_id;
+
+    #[test]
+    fn test_builtin_needs_main_window_false_for_open_ai_and_open_notes() {
+        assert!(!builtin_needs_main_window_for_command_id("builtin-open-ai"));
+        assert!(!builtin_needs_main_window_for_command_id("builtin-open-notes"));
+    }
+
+    #[test]
+    fn test_builtin_needs_main_window_true_for_unlisted_builtin() {
+        assert!(builtin_needs_main_window_for_command_id("builtin-refresh-scripts"));
+    }
+}
+
 impl ScriptListApp {
     pub(crate) fn execute_scriptlet(&mut self, scriptlet: &scripts::Scriptlet, cx: &mut Context<Self>) {
         logging::log(
@@ -312,16 +343,6 @@
             "EXEC",
             &format!("Executing by command ID or path: {}", command_id),
         );
-
-        // Builtins that open their own windows and don't need main window
-        const NO_MAIN_WINDOW_BUILTINS: &[&str] = &[
-            "builtin-ai-chat",
-            "builtin-notes",
-            "builtin-new-note",
-            "builtin-search-notes",
-            "builtin-quick-capture",
-            "builtin-new-conversation",
-        ];
 
         // Parse command ID format: "type/identifier"
         if let Some((cmd_type, identifier)) = command_id.split_once('/') {
@@ -352,7 +373,8 @@
                         logging::log("EXEC", &format!("Executing builtin: {}", identifier));
                         self.execute_builtin(entry, cx);
                         // Check if this builtin opens its own window
-                        let needs_main_window = !NO_MAIN_WINDOW_BUILTINS.contains(&identifier);
+                        let needs_main_window =
+                            builtin_needs_main_window_for_command_id(identifier);
                         logging::log(
                             "EXEC",
                             &format!(


thinking
**Refining test command to avoid unrelated compile errors**
codex
The first `cargo test` attempt hit unrelated, in-flight workspace breakages (module/test tree conflicts and clipboard/type changes outside this task). I‚Äôm rerunning tests scoped to the binary target to isolate only the unit tests in our touched files.

thinking
**Running targeted binary tests**
exec
/bin/zsh -lc 'cargo test -p script-kit-gpui --bin script-kit-gpui builtin_execution_ai_feedback_tests' in /Users/johnlindquist/dev/script-kit-gpui exited 101 in 10.27s:
   Compiling script-kit-gpui v0.1.0 (/Users/johnlindquist/dev/script-kit-gpui)
warning: glob import doesn't reexport anything with visibility `pub(in crate::prompts)` because no imported item is public enough
  --> src/prompts/div/mod.rs:32:16
   |
32 | pub(super) use inline::*;
   |                ^^^^^^^^^
   |
note: the most public imported item is `pub(self)`
  --> src/prompts/div/mod.rs:32:16
   |
32 | pub(super) use inline::*;
   |                ^^^^^^^^^
   = help: reduce the glob import's visibility or increase visibility of imported items
   = note: `#[warn(unused_imports)]` (part of `#[warn(unused)]`) on by default

warning: glob import doesn't reexport anything with visibility `pub(in crate::prompts)` because no imported item is public enough
  --> src/prompts/div/mod.rs:34:16
   |
34 | pub(super) use render_html::*;
   |                ^^^^^^^^^^^^^^
file update:
diff --git a/src/app_execute/builtin_execution.rs b/src/app_execute/builtin_execution.rs
index ea07c5b2c4e5ef82ea1337d249f517425db711fa..7aec3d989171034264f550717466ea395568100d
--- a/src/app_execute/builtin_execution.rs
+++ b/src/app_execute/builtin_execution.rs
@@ -1,3 +1,7 @@
+fn ai_open_failure_message(error: impl std::fmt::Display) -> String {
+    format!("Failed to open AI: {}", error)
+}
+
 impl ScriptListApp {
     fn system_action_feedback_message(
         &self,
@@ -286,7 +290,7 @@
                             let _ = this.update(cx, |this, cx| {
                                 this.toast_manager.push(
                                     components::toast::Toast::error(
-                                        format!("Failed to open AI: {}", e),
+                                        ai_open_failure_message(e),
                                         &this.theme,
                                     )
                                     .duration_ms(Some(5000)),
@@ -552,7 +556,7 @@
                             logging::log("ERROR", &format!("AI command failed: {}", e));
                             self.toast_manager.push(
                                 components::toast::Toast::error(
-                                    format!("Failed to open AI: {}", e),
+                                    ai_open_failure_message(e),
                                     &self.theme,
                                 )
                                 .duration_ms(Some(5000)),
@@ -632,7 +636,15 @@
                                     ),
                                 );
                                 if let Err(e) = ai::open_ai_window(cx) {
-                                    logging::log("ERROR", &format!("Failed to open AI: {}", e));
+                                    logging::log("ERROR", &ai_open_failure_message(e));
+                                    self.toast_manager.push(
+                                        components::toast::Toast::error(
+                                            ai_open_failure_message(e),
+                                            &self.theme,
+                                        )
+                                        .duration_ms(Some(5000)),
+                                    );
+                                    cx.notify();
                                 } else {
                                     // Set input with the screenshot context
                                     ai::set_ai_input_with_image(cx, &message, &base64_data, false);
@@ -675,7 +687,15 @@
                                     ),
                                 );
                                 if let Err(e) = ai::open_ai_window(cx) {
-                                    logging::log("ERROR", &format!("Failed to open AI: {}", e));
+                                    logging::log("ERROR", &ai_open_failure_message(e));
+                                    self.toast_manager.push(
+                                        components::toast::Toast::error(
+                                            ai_open_failure_message(e),
+                                            &self.theme,
+                                        )
+                                        .duration_ms(Some(5000)),
+                                    );
+                                    cx.notify();
                                 } else {
                                     ai::set_ai_input_with_image(cx, &message, &base64_data, false);
                                 }
@@ -707,7 +727,15 @@
                                     &format!("Selected text captured: {} chars", text.len()),
                                 );
                                 if let Err(e) = ai::open_ai_window(cx) {
-                                    logging::log("ERROR", &format!("Failed to open AI: {}", e));
+                                    logging::log("ERROR", &ai_open_failure_message(e));
+                                    self.toast_manager.push(
+                                        components::toast::Toast::error(
+                                            ai_open_failure_message(e),
+                                            &self.theme,
+                                        )
+                                        .duration_ms(Some(5000)),
+                                    );
+                                    cx.notify();
                                 } else {
                                     ai::set_ai_input(cx, &message, false);
                                 }
@@ -750,7 +778,15 @@
                                 );
                                 logging::log("EXEC", &format!("Browser URL captured: {}", url));
                                 if let Err(e) = ai::open_ai_window(cx) {
-                                    logging::log("ERROR", &format!("Failed to open AI: {}", e));
+                                    logging::log("ERROR", &ai_open_failure_message(e));
+                                    self.toast_manager.push(
+                                        components::toast::Toast::error(
+                                            ai_open_failure_message(e),
+                                            &self.theme,
+                                        )
+                                        .duration_ms(Some(5000)),
+                                    );
+                                    cx.notify();
                                 } else {
                                     ai::set_ai_input(cx, &message, false);
                                 }
@@ -794,7 +830,14 @@
                             .duration_ms(Some(3000)),
                         );
                         if let Err(e) = ai::open_ai_window(cx) {
-                            logging::log("ERROR", &format!("Failed to open AI: {}", e));
+                            logging::log("ERROR", &ai_open_failure_message(e));
+                            self.toast_manager.push(
+                                components::toast::Toast::error(
+                                    ai_open_failure_message(e),
+                                    &self.theme,
+                                )
+                                .duration_ms(Some(5000)),
+                            );
                         }
                         cx.notify();
                     }
@@ -1170,3 +1213,16 @@
         }
     }
 }
+
+#[cfg(test)]
+mod builtin_execution_ai_feedback_tests {
+    use super::ai_open_failure_message;
+
+    #[test]
+    fn test_ai_open_failure_message_includes_error_details() {
+        assert_eq!(
+            ai_open_failure_message("window init failed"),
+            "Failed to open AI: window init failed"
+        );
+    }
+}
diff --git a/src/app_impl/execution_scripts.rs b/src/app_impl/execution_scripts.rs
index ac99cc20952af2f8c39e301b7740e55cec8f394e..0f68c29b620a7bf207a81f1ea167f9a8310f71e4
--- a/src/app_impl/execution_scripts.rs
+++ b/src/app_impl/execution_scripts.rs
@@ -1,5 +1,36 @@
 use super::*;
 
+const NO_MAIN_WINDOW_BUILTINS: &[&str] = &[
+    "builtin-ai-chat",
+    "builtin-open-ai",
+    "builtin-notes",
+    "builtin-open-notes",
+    "builtin-new-note",
+    "builtin-search-notes",
+    "builtin-quick-capture",
+    "builtin-new-conversation",
+];
+
+fn builtin_needs_main_window_for_command_id(identifier: &str) -> bool {
+    !NO_MAIN_WINDOW_BUILTINS.contains(&identifier)
+}
+
+#[cfg(test)]
+mod builtin_command_window_visibility_tests {
+    use super::builtin_needs_main_window_for_command_id;
+
+    #[test]
+    fn test_builtin_needs_main_window_false_for_open_ai_and_open_notes() {
+        assert!(!builtin_needs_main_window_for_command_id("builtin-open-ai"));
+        assert!(!builtin_needs_main_window_for_command_id("builtin-open-notes"));
+    }
+
+    #[test]
+    fn test_builtin_needs_main_window_true_for_unlisted_builtin() {
+        assert!(builtin_needs_main_window_for_command_id("builtin-refresh-scripts"));
+    }
+}
+
 impl ScriptListApp {
     pub(crate) fn execute_scriptlet(&mut self, scriptlet: &scripts::Scriptlet, cx: &mut Context<Self>) {
         logging::log(
@@ -312,16 +343,6 @@
             "EXEC",
             &format!("Executing by command ID or path: {}", command_id),
         );
-
-        // Builtins that open their own windows and don't need main window
-        const NO_MAIN_WINDOW_BUILTINS: &[&str] = &[
-            "builtin-ai-chat",
-            "builtin-notes",
-            "builtin-new-note",
-            "builtin-search-notes",
-            "builtin-quick-capture",
-            "builtin-new-conversation",
-        ];
 
         // Parse command ID format: "type/identifier"
         if let Some((cmd_type, identifier)) = command_id.split_once('/') {
@@ -352,7 +373,8 @@
                         logging::log("EXEC", &format!("Executing builtin: {}", identifier));
                         self.execute_builtin(entry, cx);
                         // Check if this builtin opens its own window
-                        let needs_main_window = !NO_MAIN_WINDOW_BUILTINS.contains(&identifier);
+                        let needs_main_window =
+                            builtin_needs_main_window_for_command_id(identifier);
                         logging::log(
                             "EXEC",
                             &format!(


thinking
**Running scoped check and clippy despite failures**
exec
/bin/zsh -lc 'cargo check -p script-kit-gpui' in /Users/johnlindquist/dev/script-kit-gpui exited 101 in 9.53s:
    Checking script-kit-gpui v0.1.0 (/Users/johnlindquist/dev/script-kit-gpui)
warning: glob import doesn't reexport anything with visibility `pub(in crate::prompts)` because no imported item is public enough
  --> src/prompts/div/mod.rs:32:16
   |
32 | pub(super) use inline::*;
   |                ^^^^^^^^^
   |
note: the most public imported item is `pub(self)`
  --> src/prompts/div/mod.rs:32:16
   |
32 | pub(super) use inline::*;
   |                ^^^^^^^^^
   = help: reduce the glob import's visibility or increase visibility of imported items
   = note: `#[warn(unused_imports)]` (part of `#[warn(unused)]`) on by default

warning: glob import doesn't reexport anything with visibility `pub(in crate::prompts)` because no imported item is public enough
  --> src/prompts/div/mod.rs:34:16
   |
34 | pub(super) use render_html::*;
   |                ^^^^^^^^^^^^^^
file update:
diff --git a/src/app_execute/builtin_execution.rs b/src/app_execute/builtin_execution.rs
index ea07c5b2c4e5ef82ea1337d249f517425db711fa..7aec3d989171034264f550717466ea395568100d
--- a/src/app_execute/builtin_execution.rs
+++ b/src/app_execute/builtin_execution.rs
@@ -1,3 +1,7 @@
+fn ai_open_failure_message(error: impl std::fmt::Display) -> String {
+    format!("Failed to open AI: {}", error)
+}
+
 impl ScriptListApp {
     fn system_action_feedback_message(
         &self,
@@ -286,7 +290,7 @@
                             let _ = this.update(cx, |this, cx| {
                                 this.toast_manager.push(
                                     components::toast::Toast::error(
-                                        format!("Failed to open AI: {}", e),
+                                        ai_open_failure_message(e),
                                         &this.theme,
                                     )
                                     .duration_ms(Some(5000)),
@@ -552,7 +556,7 @@
                             logging::log("ERROR", &format!("AI command failed: {}", e));
                             self.toast_manager.push(
                                 components::toast::Toast::error(
-                                    format!("Failed to open AI: {}", e),
+                                    ai_open_failure_message(e),
                                     &self.theme,
                                 )
                                 .duration_ms(Some(5000)),
@@ -632,7 +636,15 @@
                                     ),
                                 );
                                 if let Err(e) = ai::open_ai_window(cx) {
-                                    logging::log("ERROR", &format!("Failed to open AI: {}", e));
+                                    logging::log("ERROR", &ai_open_failure_message(e));
+                                    self.toast_manager.push(
+                                        components::toast::Toast::error(
+                                            ai_open_failure_message(e),
+                                            &self.theme,
+                                        )
+                                        .duration_ms(Some(5000)),
+                                    );
+                                    cx.notify();
                                 } else {
                                     // Set input with the screenshot context
                                     ai::set_ai_input_with_image(cx, &message, &base64_data, false);
@@ -675,7 +687,15 @@
                                     ),
                                 );
                                 if let Err(e) = ai::open_ai_window(cx) {
-                                    logging::log("ERROR", &format!("Failed to open AI: {}", e));
+                                    logging::log("ERROR", &ai_open_failure_message(e));
+                                    self.toast_manager.push(
+                                        components::toast::Toast::error(
+                                            ai_open_failure_message(e),
+                                            &self.theme,
+                                        )
+                                        .duration_ms(Some(5000)),
+                                    );
+                                    cx.notify();
                                 } else {
                                     ai::set_ai_input_with_image(cx, &message, &base64_data, false);
                                 }
@@ -707,7 +727,15 @@
                                     &format!("Selected text captured: {} chars", text.len()),
                                 );
                                 if let Err(e) = ai::open_ai_window(cx) {
-                                    logging::log("ERROR", &format!("Failed to open AI: {}", e));
+                                    logging::log("ERROR", &ai_open_failure_message(e));
+                                    self.toast_manager.push(
+                                        components::toast::Toast::error(
+                                            ai_open_failure_message(e),
+                                            &self.theme,
+                                        )
+                                        .duration_ms(Some(5000)),
+                                    );
+                                    cx.notify();
                                 } else {
                                     ai::set_ai_input(cx, &message, false);
                                 }
@@ -750,7 +778,15 @@
                                 );
                                 logging::log("EXEC", &format!("Browser URL captured: {}", url));
                                 if let Err(e) = ai::open_ai_window(cx) {
-                                    logging::log("ERROR", &format!("Failed to open AI: {}", e));
+                                    logging::log("ERROR", &ai_open_failure_message(e));
+                                    self.toast_manager.push(
+                                        components::toast::Toast::error(
+                                            ai_open_failure_message(e),
+                                            &self.theme,
+                                        )
+                                        .duration_ms(Some(5000)),
+                                    );
+                                    cx.notify();
                                 } else {
                                     ai::set_ai_input(cx, &message, false);
                                 }
@@ -794,7 +830,14 @@
                             .duration_ms(Some(3000)),
                         );
                         if let Err(e) = ai::open_ai_window(cx) {
-                            logging::log("ERROR", &format!("Failed to open AI: {}", e));
+                            logging::log("ERROR", &ai_open_failure_message(e));
+                            self.toast_manager.push(
+                                components::toast::Toast::error(
+                                    ai_open_failure_message(e),
+                                    &self.theme,
+                                )
+                                .duration_ms(Some(5000)),
+                            );
                         }
                         cx.notify();
                     }
@@ -1170,3 +1213,16 @@
         }
     }
 }
+
+#[cfg(test)]
+mod builtin_execution_ai_feedback_tests {
+    use super::ai_open_failure_message;
+
+    #[test]
+    fn test_ai_open_failure_message_includes_error_details() {
+        assert_eq!(
+            ai_open_failure_message("window init failed"),
+            "Failed to open AI: window init failed"
+        );
+    }
+}
diff --git a/src/app_impl/execution_scripts.rs b/src/app_impl/execution_scripts.rs
index ac99cc20952af2f8c39e301b7740e55cec8f394e..0f68c29b620a7bf207a81f1ea167f9a8310f71e4
--- a/src/app_impl/execution_scripts.rs
+++ b/src/app_impl/execution_scripts.rs
@@ -1,5 +1,36 @@
 use super::*;
 
+const NO_MAIN_WINDOW_BUILTINS: &[&str] = &[
+    "builtin-ai-chat",
+    "builtin-open-ai",
+    "builtin-notes",
+    "builtin-open-notes",
+    "builtin-new-note",
+    "builtin-search-notes",
+    "builtin-quick-capture",
+    "builtin-new-conversation",
+];
+
+fn builtin_needs_main_window_for_command_id(identifier: &str) -> bool {
+    !NO_MAIN_WINDOW_BUILTINS.contains(&identifier)
+}
+
+#[cfg(test)]
+mod builtin_command_window_visibility_tests {
+    use super::builtin_needs_main_window_for_command_id;
+
+    #[test]
+    fn test_builtin_needs_main_window_false_for_open_ai_and_open_notes() {
+        assert!(!builtin_needs_main_window_for_command_id("builtin-open-ai"));
+        assert!(!builtin_needs_main_window_for_command_id("builtin-open-notes"));
+    }
+
+    #[test]
+    fn test_builtin_needs_main_window_true_for_unlisted_builtin() {
+        assert!(builtin_needs_main_window_for_command_id("builtin-refresh-scripts"));
+    }
+}
+
 impl ScriptListApp {
     pub(crate) fn execute_scriptlet(&mut self, scriptlet: &scripts::Scriptlet, cx: &mut Context<Self>) {
         logging::log(
@@ -312,16 +343,6 @@
             "EXEC",
             &format!("Executing by command ID or path: {}", command_id),
         );
-
-        // Builtins that open their own windows and don't need main window
-        const NO_MAIN_WINDOW_BUILTINS: &[&str] = &[
-            "builtin-ai-chat",
-            "builtin-notes",
-            "builtin-new-note",
-            "builtin-search-notes",
-            "builtin-quick-capture",
-            "builtin-new-conversation",
-        ];
 
         // Parse command ID format: "type/identifier"
         if let Some((cmd_type, identifier)) = command_id.split_once('/') {
@@ -352,7 +373,8 @@
                         logging::log("EXEC", &format!("Executing builtin: {}", identifier));
                         self.execute_builtin(entry, cx);
                         // Check if this builtin opens its own window
-                        let needs_main_window = !NO_MAIN_WINDOW_BUILTINS.contains(&identifier);
+                        let needs_main_window =
+                            builtin_needs_main_window_for_command_id(identifier);
                         logging::log(
                             "EXEC",
                             &format!(


thinking
**Running lint checks**
exec
/bin/zsh -lc 'cargo clippy -p script-kit-gpui --all-targets -- -D warnings' in /Users/johnlindquist/dev/script-kit-gpui exited 101 in 18.30s:
    Checking script-kit-gpui v0.1.0 (/Users/johnlindquist/dev/script-kit-gpui)
error[E0761]: file for module `tests` found at both "src/protocol/message/tests.rs" and "src/protocol/message/tests/mod.rs"
  --> src/protocol/message/mod.rs:87:1
   |
87 | mod tests;
   | ^^^^^^^^^^
   |
   = help: delete or rename one of them to remove the ambiguity

error[E0761]: file for module `tests` found at both "src/designs/core/tests.rs" and "src/designs/core/tests/mod.rs"
 --> src/designs/core/part_04.rs:2:1
  |
2 | mod tests;
  | ^^^^^^^^^^
  |
  = help: delete or rename one of them to remove the ambiguity

error: glob import doesn't reexport anything with visibility `pub(in crate::prompts)` because no imported item is public enough
  --> src/prompts/div/mod.rs:32:16
   |
file update:
diff --git a/src/app_execute/builtin_execution.rs b/src/app_execute/builtin_execution.rs
index ea07c5b2c4e5ef82ea1337d249f517425db711fa..7aec3d989171034264f550717466ea395568100d
--- a/src/app_execute/builtin_execution.rs
+++ b/src/app_execute/builtin_execution.rs
@@ -1,3 +1,7 @@
+fn ai_open_failure_message(error: impl std::fmt::Display) -> String {
+    format!("Failed to open AI: {}", error)
+}
+
 impl ScriptListApp {
     fn system_action_feedback_message(
         &self,
@@ -286,7 +290,7 @@
                             let _ = this.update(cx, |this, cx| {
                                 this.toast_manager.push(
                                     components::toast::Toast::error(
-                                        format!("Failed to open AI: {}", e),
+                                        ai_open_failure_message(e),
                                         &this.theme,
                                     )
                                     .duration_ms(Some(5000)),
@@ -552,7 +556,7 @@
                             logging::log("ERROR", &format!("AI command failed: {}", e));
                             self.toast_manager.push(
                                 components::toast::Toast::error(
-                                    format!("Failed to open AI: {}", e),
+                                    ai_open_failure_message(e),
                                     &self.theme,
                                 )
                                 .duration_ms(Some(5000)),
@@ -632,7 +636,15 @@
                                     ),
                                 );
                                 if let Err(e) = ai::open_ai_window(cx) {
-                                    logging::log("ERROR", &format!("Failed to open AI: {}", e));
+                                    logging::log("ERROR", &ai_open_failure_message(e));
+                                    self.toast_manager.push(
+                                        components::toast::Toast::error(
+                                            ai_open_failure_message(e),
+                                            &self.theme,
+                                        )
+                                        .duration_ms(Some(5000)),
+                                    );
+                                    cx.notify();
                                 } else {
                                     // Set input with the screenshot context
                                     ai::set_ai_input_with_image(cx, &message, &base64_data, false);
@@ -675,7 +687,15 @@
                                     ),
                                 );
                                 if let Err(e) = ai::open_ai_window(cx) {
-                                    logging::log("ERROR", &format!("Failed to open AI: {}", e));
+                                    logging::log("ERROR", &ai_open_failure_message(e));
+                                    self.toast_manager.push(
+                                        components::toast::Toast::error(
+                                            ai_open_failure_message(e),
+                                            &self.theme,
+                                        )
+                                        .duration_ms(Some(5000)),
+                                    );
+                                    cx.notify();
                                 } else {
                                     ai::set_ai_input_with_image(cx, &message, &base64_data, false);
                                 }
@@ -707,7 +727,15 @@
                                     &format!("Selected text captured: {} chars", text.len()),
                                 );
                                 if let Err(e) = ai::open_ai_window(cx) {
-                                    logging::log("ERROR", &format!("Failed to open AI: {}", e));
+                                    logging::log("ERROR", &ai_open_failure_message(e));
+                                    self.toast_manager.push(
+                                        components::toast::Toast::error(
+                                            ai_open_failure_message(e),
+                                            &self.theme,
+                                        )
+                                        .duration_ms(Some(5000)),
+                                    );
+                                    cx.notify();
                                 } else {
                                     ai::set_ai_input(cx, &message, false);
                                 }
@@ -750,7 +778,15 @@
                                 );
                                 logging::log("EXEC", &format!("Browser URL captured: {}", url));
                                 if let Err(e) = ai::open_ai_window(cx) {
-                                    logging::log("ERROR", &format!("Failed to open AI: {}", e));
+                                    logging::log("ERROR", &ai_open_failure_message(e));
+                                    self.toast_manager.push(
+                                        components::toast::Toast::error(
+                                            ai_open_failure_message(e),
+                                            &self.theme,
+                                        )
+                                        .duration_ms(Some(5000)),
+                                    );
+                                    cx.notify();
                                 } else {
                                     ai::set_ai_input(cx, &message, false);
                                 }
@@ -794,7 +830,14 @@
                             .duration_ms(Some(3000)),
                         );
                         if let Err(e) = ai::open_ai_window(cx) {
-                            logging::log("ERROR", &format!("Failed to open AI: {}", e));
+                            logging::log("ERROR", &ai_open_failure_message(e));
+                            self.toast_manager.push(
+                                components::toast::Toast::error(
+                                    ai_open_failure_message(e),
+                                    &self.theme,
+                                )
+                                .duration_ms(Some(5000)),
+                            );
                         }
                         cx.notify();
                     }
@@ -1170,3 +1213,16 @@
         }
     }
 }
+
+#[cfg(test)]
+mod builtin_execution_ai_feedback_tests {
+    use super::ai_open_failure_message;
+
+    #[test]
+    fn test_ai_open_failure_message_includes_error_details() {
+        assert_eq!(
+            ai_open_failure_message("window init failed"),
+            "Failed to open AI: window init failed"
+        );
+    }
+}
diff --git a/src/app_impl/execution_scripts.rs b/src/app_impl/execution_scripts.rs
index ac99cc20952af2f8c39e301b7740e55cec8f394e..0f68c29b620a7bf207a81f1ea167f9a8310f71e4
--- a/src/app_impl/execution_scripts.rs
+++ b/src/app_impl/execution_scripts.rs
@@ -1,5 +1,36 @@
 use super::*;
 
+const NO_MAIN_WINDOW_BUILTINS: &[&str] = &[
+    "builtin-ai-chat",
+    "builtin-open-ai",
+    "builtin-notes",
+    "builtin-open-notes",
+    "builtin-new-note",
+    "builtin-search-notes",
+    "builtin-quick-capture",
+    "builtin-new-conversation",
+];
+
+fn builtin_needs_main_window_for_command_id(identifier: &str) -> bool {
+    !NO_MAIN_WINDOW_BUILTINS.contains(&identifier)
+}
+
+#[cfg(test)]
+mod builtin_command_window_visibility_tests {
+    use super::builtin_needs_main_window_for_command_id;
+
+    #[test]
+    fn test_builtin_needs_main_window_false_for_open_ai_and_open_notes() {
+        assert!(!builtin_needs_main_window_for_command_id("builtin-open-ai"));
+        assert!(!builtin_needs_main_window_for_command_id("builtin-open-notes"));
+    }
+
+    #[test]
+    fn test_builtin_needs_main_window_true_for_unlisted_builtin() {
+        assert!(builtin_needs_main_window_for_command_id("builtin-refresh-scripts"));
+    }
+}
+
 impl ScriptListApp {
     pub(crate) fn execute_scriptlet(&mut self, scriptlet: &scripts::Scriptlet, cx: &mut Context<Self>) {
         logging::log(
@@ -312,16 +343,6 @@
             "EXEC",
             &format!("Executing by command ID or path: {}", command_id),
         );
-
-        // Builtins that open their own windows and don't need main window
-        const NO_MAIN_WINDOW_BUILTINS: &[&str] = &[
-            "builtin-ai-chat",
-            "builtin-notes",
-            "builtin-new-note",
-            "builtin-search-notes",
-            "builtin-quick-capture",
-            "builtin-new-conversation",
-        ];
 
         // Parse command ID format: "type/identifier"
         if let Some((cmd_type, identifier)) = command_id.split_once('/') {
@@ -352,7 +373,8 @@
                         logging::log("EXEC", &format!("Executing builtin: {}", identifier));
                         self.execute_builtin(entry, cx);
                         // Check if this builtin opens its own window
-                        let needs_main_window = !NO_MAIN_WINDOW_BUILTINS.contains(&identifier);
+                        let needs_main_window =
+                            builtin_needs_main_window_for_command_id(identifier);
                         logging::log(
                             "EXEC",
                             &format!(


thinking
**Verifying syntax with local diffs**
exec
/bin/zsh -lc 'git status --short src/app_execute/builtin_execution.rs src/app_impl/execution_scripts.rs && git diff -- src/app_execute/builtin_execution.rs src/app_impl/execution_scripts.rs' in /Users/johnlindquist/dev/script-kit-gpui succeeded in 51ms:
 M src/app_execute/builtin_execution.rs
 M src/app_impl/execution_scripts.rs
diff --git a/src/app_execute/builtin_execution.rs b/src/app_execute/builtin_execution.rs
index ea07c5b..7aec3d9 100644
--- a/src/app_execute/builtin_execution.rs
+++ b/src/app_execute/builtin_execution.rs
@@ -1,3 +1,7 @@
+fn ai_open_failure_message(error: impl std::fmt::Display) -> String {
+    format!("Failed to open AI: {}", error)
+}
+
 impl ScriptListApp {
     fn system_action_feedback_message(
         &self,
@@ -286,7 +290,7 @@ impl ScriptListApp {
                             let _ = this.update(cx, |this, cx| {
                                 this.toast_manager.push(
                                     components::toast::Toast::error(
-                                        format!("Failed to open AI: {}", e),
+                                        ai_open_failure_message(e),
file update:
diff --git a/src/app_execute/builtin_execution.rs b/src/app_execute/builtin_execution.rs
index ea07c5b2c4e5ef82ea1337d249f517425db711fa..7aec3d989171034264f550717466ea395568100d
--- a/src/app_execute/builtin_execution.rs
+++ b/src/app_execute/builtin_execution.rs
@@ -1,3 +1,7 @@
+fn ai_open_failure_message(error: impl std::fmt::Display) -> String {
+    format!("Failed to open AI: {}", error)
+}
+
 impl ScriptListApp {
     fn system_action_feedback_message(
         &self,
@@ -286,7 +290,7 @@
                             let _ = this.update(cx, |this, cx| {
                                 this.toast_manager.push(
                                     components::toast::Toast::error(
-                                        format!("Failed to open AI: {}", e),
+                                        ai_open_failure_message(e),
                                         &this.theme,
                                     )
                                     .duration_ms(Some(5000)),
@@ -552,7 +556,7 @@
                             logging::log("ERROR", &format!("AI command failed: {}", e));
                             self.toast_manager.push(
                                 components::toast::Toast::error(
-                                    format!("Failed to open AI: {}", e),
+                                    ai_open_failure_message(e),
                                     &self.theme,
                                 )
                                 .duration_ms(Some(5000)),
@@ -632,7 +636,15 @@
                                     ),
                                 );
                                 if let Err(e) = ai::open_ai_window(cx) {
-                                    logging::log("ERROR", &format!("Failed to open AI: {}", e));
+                                    logging::log("ERROR", &ai_open_failure_message(e));
+                                    self.toast_manager.push(
+                                        components::toast::Toast::error(
+                                            ai_open_failure_message(e),
+                                            &self.theme,
+                                        )
+                                        .duration_ms(Some(5000)),
+                                    );
+                                    cx.notify();
                                 } else {
                                     // Set input with the screenshot context
                                     ai::set_ai_input_with_image(cx, &message, &base64_data, false);
@@ -675,7 +687,15 @@
                                     ),
                                 );
                                 if let Err(e) = ai::open_ai_window(cx) {
-                                    logging::log("ERROR", &format!("Failed to open AI: {}", e));
+                                    logging::log("ERROR", &ai_open_failure_message(e));
+                                    self.toast_manager.push(
+                                        components::toast::Toast::error(
+                                            ai_open_failure_message(e),
+                                            &self.theme,
+                                        )
+                                        .duration_ms(Some(5000)),
+                                    );
+                                    cx.notify();
                                 } else {
                                     ai::set_ai_input_with_image(cx, &message, &base64_data, false);
                                 }
@@ -707,7 +727,15 @@
                                     &format!("Selected text captured: {} chars", text.len()),
                                 );
                                 if let Err(e) = ai::open_ai_window(cx) {
-                                    logging::log("ERROR", &format!("Failed to open AI: {}", e));
+                                    logging::log("ERROR", &ai_open_failure_message(e));
+                                    self.toast_manager.push(
+                                        components::toast::Toast::error(
+                                            ai_open_failure_message(e),
+                                            &self.theme,
+                                        )
+                                        .duration_ms(Some(5000)),
+                                    );
+                                    cx.notify();
                                 } else {
                                     ai::set_ai_input(cx, &message, false);
                                 }
@@ -750,7 +778,15 @@
                                 );
                                 logging::log("EXEC", &format!("Browser URL captured: {}", url));
                                 if let Err(e) = ai::open_ai_window(cx) {
-                                    logging::log("ERROR", &format!("Failed to open AI: {}", e));
+                                    logging::log("ERROR", &ai_open_failure_message(e));
+                                    self.toast_manager.push(
+                                        components::toast::Toast::error(
+                                            ai_open_failure_message(e),
+                                            &self.theme,
+                                        )
+                                        .duration_ms(Some(5000)),
+                                    );
+                                    cx.notify();
                                 } else {
                                     ai::set_ai_input(cx, &message, false);
                                 }
@@ -794,7 +830,14 @@
                             .duration_ms(Some(3000)),
                         );
                         if let Err(e) = ai::open_ai_window(cx) {
-                            logging::log("ERROR", &format!("Failed to open AI: {}", e));
+                            logging::log("ERROR", &ai_open_failure_message(e));
+                            self.toast_manager.push(
+                                components::toast::Toast::error(
+                                    ai_open_failure_message(e),
+                                    &self.theme,
+                                )
+                                .duration_ms(Some(5000)),
+                            );
                         }
                         cx.notify();
                     }
@@ -1170,3 +1213,16 @@
         }
     }
 }
+
+#[cfg(test)]
+mod builtin_execution_ai_feedback_tests {
+    use super::ai_open_failure_message;
+
+    #[test]
+    fn test_ai_open_failure_message_includes_error_details() {
+        assert_eq!(
+            ai_open_failure_message("window init failed"),
+            "Failed to open AI: window init failed"
+        );
+    }
+}
diff --git a/src/app_impl/execution_scripts.rs b/src/app_impl/execution_scripts.rs
index ac99cc20952af2f8c39e301b7740e55cec8f394e..0f68c29b620a7bf207a81f1ea167f9a8310f71e4
--- a/src/app_impl/execution_scripts.rs
+++ b/src/app_impl/execution_scripts.rs
@@ -1,5 +1,36 @@
 use super::*;
 
+const NO_MAIN_WINDOW_BUILTINS: &[&str] = &[
+    "builtin-ai-chat",
+    "builtin-open-ai",
+    "builtin-notes",
+    "builtin-open-notes",
+    "builtin-new-note",
+    "builtin-search-notes",
+    "builtin-quick-capture",
+    "builtin-new-conversation",
+];
+
+fn builtin_needs_main_window_for_command_id(identifier: &str) -> bool {
+    !NO_MAIN_WINDOW_BUILTINS.contains(&identifier)
+}
+
+#[cfg(test)]
+mod builtin_command_window_visibility_tests {
+    use super::builtin_needs_main_window_for_command_id;
+
+    #[test]
+    fn test_builtin_needs_main_window_false_for_open_ai_and_open_notes() {
+        assert!(!builtin_needs_main_window_for_command_id("builtin-open-ai"));
+        assert!(!builtin_needs_main_window_for_command_id("builtin-open-notes"));
+    }
+
+    #[test]
+    fn test_builtin_needs_main_window_true_for_unlisted_builtin() {
+        assert!(builtin_needs_main_window_for_command_id("builtin-refresh-scripts"));
+    }
+}
+
 impl ScriptListApp {
     pub(crate) fn execute_scriptlet(&mut self, scriptlet: &scripts::Scriptlet, cx: &mut Context<Self>) {
         logging::log(
@@ -312,16 +343,6 @@
             "EXEC",
             &format!("Executing by command ID or path: {}", command_id),
         );
-
-        // Builtins that open their own windows and don't need main window
-        const NO_MAIN_WINDOW_BUILTINS: &[&str] = &[
-            "builtin-ai-chat",
-            "builtin-notes",
-            "builtin-new-note",
-            "builtin-search-notes",
-            "builtin-quick-capture",
-            "builtin-new-conversation",
-        ];
 
         // Parse command ID format: "type/identifier"
         if let Some((cmd_type, identifier)) = command_id.split_once('/') {
@@ -352,7 +373,8 @@
                         logging::log("EXEC", &format!("Executing builtin: {}", identifier));
                         self.execute_builtin(entry, cx);
                         // Check if this builtin opens its own window
-                        let needs_main_window = !NO_MAIN_WINDOW_BUILTINS.contains(&identifier);
+                        let needs_main_window =
+                            builtin_needs_main_window_for_command_id(identifier);
                         logging::log(
                             "EXEC",
                             &format!(


thinking
**Planning targeted rustfmt run**
exec
/bin/zsh -lc 'rustfmt src/app_execute/builtin_execution.rs src/app_impl/execution_scripts.rs' in /Users/johnlindquist/dev/script-kit-gpui exited 1 in 51ms:
error: `async move` blocks are only allowed in Rust 2018 or later
  --> /Users/johnlindquist/dev/script-kit-gpui/src/app_execute/builtin_execution.rs:44:22
   |
44 |             cx.spawn(async move |this, cx| {
   |                      ^^^^^-^^^^
   |                           |
   |                           help: missing `,`

error: `async move` blocks are only allowed in Rust 2018 or later
   --> /Users/johnlindquist/dev/script-kit-gpui/src/app_execute/builtin_execution.rs:281:26
    |
281 |                 cx.spawn(async move |this, cx| {
    |                          ^^^^^-^^^^
    |                               |
    |                               help: missing `,`

file update:
diff --git a/src/app_execute/builtin_execution.rs b/src/app_execute/builtin_execution.rs
index ea07c5b2c4e5ef82ea1337d249f517425db711fa..7aec3d989171034264f550717466ea395568100d
--- a/src/app_execute/builtin_execution.rs
+++ b/src/app_execute/builtin_execution.rs
@@ -1,3 +1,7 @@
+fn ai_open_failure_message(error: impl std::fmt::Display) -> String {
+    format!("Failed to open AI: {}", error)
+}
+
 impl ScriptListApp {
     fn system_action_feedback_message(
         &self,
@@ -286,7 +290,7 @@
                             let _ = this.update(cx, |this, cx| {
                                 this.toast_manager.push(
                                     components::toast::Toast::error(
-                                        format!("Failed to open AI: {}", e),
+                                        ai_open_failure_message(e),
                                         &this.theme,
                                     )
                                     .duration_ms(Some(5000)),
@@ -552,7 +556,7 @@
                             logging::log("ERROR", &format!("AI command failed: {}", e));
                             self.toast_manager.push(
                                 components::toast::Toast::error(
-                                    format!("Failed to open AI: {}", e),
+                                    ai_open_failure_message(e),
                                     &self.theme,
                                 )
                                 .duration_ms(Some(5000)),
@@ -632,7 +636,15 @@
                                     ),
                                 );
                                 if let Err(e) = ai::open_ai_window(cx) {
-                                    logging::log("ERROR", &format!("Failed to open AI: {}", e));
+                                    logging::log("ERROR", &ai_open_failure_message(e));
+                                    self.toast_manager.push(
+                                        components::toast::Toast::error(
+                                            ai_open_failure_message(e),
+                                            &self.theme,
+                                        )
+                                        .duration_ms(Some(5000)),
+                                    );
+                                    cx.notify();
                                 } else {
                                     // Set input with the screenshot context
                                     ai::set_ai_input_with_image(cx, &message, &base64_data, false);
@@ -675,7 +687,15 @@
                                     ),
                                 );
                                 if let Err(e) = ai::open_ai_window(cx) {
-                                    logging::log("ERROR", &format!("Failed to open AI: {}", e));
+                                    logging::log("ERROR", &ai_open_failure_message(e));
+                                    self.toast_manager.push(
+                                        components::toast::Toast::error(
+                                            ai_open_failure_message(e),
+                                            &self.theme,
+                                        )
+                                        .duration_ms(Some(5000)),
+                                    );
+                                    cx.notify();
                                 } else {
                                     ai::set_ai_input_with_image(cx, &message, &base64_data, false);
                                 }
@@ -707,7 +727,15 @@
                                     &format!("Selected text captured: {} chars", text.len()),
                                 );
                                 if let Err(e) = ai::open_ai_window(cx) {
-                                    logging::log("ERROR", &format!("Failed to open AI: {}", e));
+                                    logging::log("ERROR", &ai_open_failure_message(e));
+                                    self.toast_manager.push(
+                                        components::toast::Toast::error(
+                                            ai_open_failure_message(e),
+                                            &self.theme,
+                                        )
+                                        .duration_ms(Some(5000)),
+                                    );
+                                    cx.notify();
                                 } else {
                                     ai::set_ai_input(cx, &message, false);
                                 }
@@ -750,7 +778,15 @@
                                 );
                                 logging::log("EXEC", &format!("Browser URL captured: {}", url));
                                 if let Err(e) = ai::open_ai_window(cx) {
-                                    logging::log("ERROR", &format!("Failed to open AI: {}", e));
+                                    logging::log("ERROR", &ai_open_failure_message(e));
+                                    self.toast_manager.push(
+                                        components::toast::Toast::error(
+                                            ai_open_failure_message(e),
+                                            &self.theme,
+                                        )
+                                        .duration_ms(Some(5000)),
+                                    );
+                                    cx.notify();
                                 } else {
                                     ai::set_ai_input(cx, &message, false);
                                 }
@@ -794,7 +830,14 @@
                             .duration_ms(Some(3000)),
                         );
                         if let Err(e) = ai::open_ai_window(cx) {
-                            logging::log("ERROR", &format!("Failed to open AI: {}", e));
+                            logging::log("ERROR", &ai_open_failure_message(e));
+                            self.toast_manager.push(
+                                components::toast::Toast::error(
+                                    ai_open_failure_message(e),
+                                    &self.theme,
+                                )
+                                .duration_ms(Some(5000)),
+                            );
                         }
                         cx.notify();
                     }
@@ -1170,3 +1213,16 @@
         }
     }
 }
+
+#[cfg(test)]
+mod builtin_execution_ai_feedback_tests {
+    use super::ai_open_failure_message;
+
+    #[test]
+    fn test_ai_open_failure_message_includes_error_details() {
+        assert_eq!(
+            ai_open_failure_message("window init failed"),
+            "Failed to open AI: window init failed"
+        );
+    }
+}
diff --git a/src/app_impl/execution_scripts.rs b/src/app_impl/execution_scripts.rs
index ac99cc20952af2f8c39e301b7740e55cec8f394e..f801a9367f6c50f5c615f60651f1836289ded064
--- a/src/app_impl/execution_scripts.rs
+++ b/src/app_impl/execution_scripts.rs
@@ -1,7 +1,46 @@
 use super::*;
 
+const NO_MAIN_WINDOW_BUILTINS: &[&str] = &[
+    "builtin-ai-chat",
+    "builtin-open-ai",
+    "builtin-notes",
+    "builtin-open-notes",
+    "builtin-new-note",
+    "builtin-search-notes",
+    "builtin-quick-capture",
+    "builtin-new-conversation",
+];
+
+fn builtin_needs_main_window_for_command_id(identifier: &str) -> bool {
+    !NO_MAIN_WINDOW_BUILTINS.contains(&identifier)
+}
+
+#[cfg(test)]
+mod builtin_command_window_visibility_tests {
+    use super::builtin_needs_main_window_for_command_id;
+
+    #[test]
+    fn test_builtin_needs_main_window_false_for_open_ai_and_open_notes() {
+        assert!(!builtin_needs_main_window_for_command_id("builtin-open-ai"));
+        assert!(!builtin_needs_main_window_for_command_id(
+            "builtin-open-notes"
+        ));
+    }
+
+    #[test]
+    fn test_builtin_needs_main_window_true_for_unlisted_builtin() {
+        assert!(builtin_needs_main_window_for_command_id(
+            "builtin-refresh-scripts"
+        ));
+    }
+}
+
 impl ScriptListApp {
-    pub(crate) fn execute_scriptlet(&mut self, scriptlet: &scripts::Scriptlet, cx: &mut Context<Self>) {
+    pub(crate) fn execute_scriptlet(
+        &mut self,
+        scriptlet: &scripts::Scriptlet,
+        cx: &mut Context<Self>,
+    ) {
         logging::log(
             "EXEC",
             &format!(
@@ -313,16 +352,6 @@
             &format!("Executing by command ID or path: {}", command_id),
         );
 
-        // Builtins that open their own windows and don't need main window
-        const NO_MAIN_WINDOW_BUILTINS: &[&str] = &[
-            "builtin-ai-chat",
-            "builtin-notes",
-            "builtin-new-note",
-            "builtin-search-notes",
-            "builtin-quick-capture",
-            "builtin-new-conversation",
-        ];
-
         // Parse command ID format: "type/identifier"
         if let Some((cmd_type, identifier)) = command_id.split_once('/') {
             match cmd_type {
@@ -352,7 +381,8 @@
                         logging::log("EXEC", &format!("Executing builtin: {}", identifier));
                         self.execute_builtin(entry, cx);
                         // Check if this builtin opens its own window
-                        let needs_main_window = !NO_MAIN_WINDOW_BUILTINS.contains(&identifier);
+                        let needs_main_window =
+                            builtin_needs_main_window_for_command_id(identifier);
                         logging::log(
                             "EXEC",
                             &format!(
@@ -418,5 +448,4 @@
         self.execute_script_by_path(command_id, cx);
         true
     }
-
 }


thinking
**Retrying rustfmt with edition 2021**
exec
/bin/zsh -lc 'rustfmt --edition 2021 src/app_execute/builtin_execution.rs src/app_impl/execution_scripts.rs' in /Users/johnlindquist/dev/script-kit-gpui succeeded in 51ms:

file update:
diff --git a/src/app_execute/builtin_execution.rs b/src/app_execute/builtin_execution.rs
index ea07c5b2c4e5ef82ea1337d249f517425db711fa..3e9923aa9e6a77375357296e6184eeacf53d258b
--- a/src/app_execute/builtin_execution.rs
+++ b/src/app_execute/builtin_execution.rs
@@ -1,3 +1,7 @@
+fn ai_open_failure_message(error: impl std::fmt::Display) -> String {
+    format!("Failed to open AI: {}", error)
+}
+
 impl ScriptListApp {
     fn system_action_feedback_message(
         &self,
@@ -286,7 +290,7 @@
                             let _ = this.update(cx, |this, cx| {
                                 this.toast_manager.push(
                                     components::toast::Toast::error(
-                                        format!("Failed to open AI: {}", e),
+                                        ai_open_failure_message(e),
                                         &this.theme,
                                     )
                                     .duration_ms(Some(5000)),
@@ -501,7 +505,6 @@
             // =========================================================================
             // Notes Commands
             // =========================================================================
-
             builtins::BuiltInFeature::NotesCommand(cmd_type) => {
                 logging::log("EXEC", &format!("Executing notes command: {:?}", cmd_type));
 
@@ -552,7 +555,7 @@
                             logging::log("ERROR", &format!("AI command failed: {}", e));
                             self.toast_manager.push(
                                 components::toast::Toast::error(
-                                    format!("Failed to open AI: {}", e),
+                                    ai_open_failure_message(e),
                                     &self.theme,
                                 )
                                 .duration_ms(Some(5000)),
@@ -632,7 +635,15 @@
                                     ),
                                 );
                                 if let Err(e) = ai::open_ai_window(cx) {
-                                    logging::log("ERROR", &format!("Failed to open AI: {}", e));
+                                    logging::log("ERROR", &ai_open_failure_message(e));
+                                    self.toast_manager.push(
+                                        components::toast::Toast::error(
+                                            ai_open_failure_message(e),
+                                            &self.theme,
+                                        )
+                                        .duration_ms(Some(5000)),
+                                    );
+                                    cx.notify();
                                 } else {
                                     // Set input with the screenshot context
                                     ai::set_ai_input_with_image(cx, &message, &base64_data, false);
@@ -675,7 +686,15 @@
                                     ),
                                 );
                                 if let Err(e) = ai::open_ai_window(cx) {
-                                    logging::log("ERROR", &format!("Failed to open AI: {}", e));
+                                    logging::log("ERROR", &ai_open_failure_message(e));
+                                    self.toast_manager.push(
+                                        components::toast::Toast::error(
+                                            ai_open_failure_message(e),
+                                            &self.theme,
+                                        )
+                                        .duration_ms(Some(5000)),
+                                    );
+                                    cx.notify();
                                 } else {
                                     ai::set_ai_input_with_image(cx, &message, &base64_data, false);
                                 }
@@ -707,7 +726,15 @@
                                     &format!("Selected text captured: {} chars", text.len()),
                                 );
                                 if let Err(e) = ai::open_ai_window(cx) {
-                                    logging::log("ERROR", &format!("Failed to open AI: {}", e));
+                                    logging::log("ERROR", &ai_open_failure_message(e));
+                                    self.toast_manager.push(
+                                        components::toast::Toast::error(
+                                            ai_open_failure_message(e),
+                                            &self.theme,
+                                        )
+                                        .duration_ms(Some(5000)),
+                                    );
+                                    cx.notify();
                                 } else {
                                     ai::set_ai_input(cx, &message, false);
                                 }
@@ -750,7 +777,15 @@
                                 );
                                 logging::log("EXEC", &format!("Browser URL captured: {}", url));
                                 if let Err(e) = ai::open_ai_window(cx) {
-                                    logging::log("ERROR", &format!("Failed to open AI: {}", e));
+                                    logging::log("ERROR", &ai_open_failure_message(e));
+                                    self.toast_manager.push(
+                                        components::toast::Toast::error(
+                                            ai_open_failure_message(e),
+                                            &self.theme,
+                                        )
+                                        .duration_ms(Some(5000)),
+                                    );
+                                    cx.notify();
                                 } else {
                                     ai::set_ai_input(cx, &message, false);
                                 }
@@ -794,7 +829,14 @@
                             .duration_ms(Some(3000)),
                         );
                         if let Err(e) = ai::open_ai_window(cx) {
-                            logging::log("ERROR", &format!("Failed to open AI: {}", e));
+                            logging::log("ERROR", &ai_open_failure_message(e));
+                            self.toast_manager.push(
+                                components::toast::Toast::error(
+                                    ai_open_failure_message(e),
+                                    &self.theme,
+                                )
+                                .duration_ms(Some(5000)),
+                            );
                         }
                         cx.notify();
                     }
@@ -864,7 +906,6 @@
             // =========================================================================
             // Permission Commands
             // =========================================================================
-
             builtins::BuiltInFeature::PermissionCommand(cmd_type) => {
                 logging::log(
                     "EXEC",
@@ -1054,8 +1095,7 @@
                         self.pending_filter_sync = true;
                         self.pending_placeholder = Some("Search themes...".to_string());
                         // Start at the currently active theme
-                        let start_index =
-                            theme::presets::find_current_preset_index(&self.theme);
+                        let start_index = theme::presets::find_current_preset_index(&self.theme);
                         self.current_view = AppView::ThemeChooserView {
                             filter: String::new(),
                             selected_index: start_index,
@@ -1138,7 +1178,11 @@
                         );
 
                         if process_count == 0 {
-                            self.show_hud("No running scripts to stop.".to_string(), Some(2200), cx);
+                            self.show_hud(
+                                "No running scripts to stop.".to_string(),
+                                Some(2200),
+                                cx,
+                            );
                         } else {
                             crate::process_manager::PROCESS_MANAGER.kill_all_processes();
                             self.show_hud(
@@ -1166,7 +1210,19 @@
                 self.opened_from_main_menu = true;
                 self.open_file_search(String::new(), cx);
             }
+        }
+    }
+}
+
+#[cfg(test)]
+mod builtin_execution_ai_feedback_tests {
+    use super::ai_open_failure_message;
 
-        }
+    #[test]
+    fn test_ai_open_failure_message_includes_error_details() {
+        assert_eq!(
+            ai_open_failure_message("window init failed"),
+            "Failed to open AI: window init failed"
+        );
     }
 }
diff --git a/src/app_impl/execution_scripts.rs b/src/app_impl/execution_scripts.rs
index ac99cc20952af2f8c39e301b7740e55cec8f394e..f801a9367f6c50f5c615f60651f1836289ded064
--- a/src/app_impl/execution_scripts.rs
+++ b/src/app_impl/execution_scripts.rs
@@ -1,7 +1,46 @@
 use super::*;
 
+const NO_MAIN_WINDOW_BUILTINS: &[&str] = &[
+    "builtin-ai-chat",
+    "builtin-open-ai",
+    "builtin-notes",
+    "builtin-open-notes",
+    "builtin-new-note",
+    "builtin-search-notes",
+    "builtin-quick-capture",
+    "builtin-new-conversation",
+];
+
+fn builtin_needs_main_window_for_command_id(identifier: &str) -> bool {
+    !NO_MAIN_WINDOW_BUILTINS.contains(&identifier)
+}
+
+#[cfg(test)]
+mod builtin_command_window_visibility_tests {
+    use super::builtin_needs_main_window_for_command_id;
+
+    #[test]
+    fn test_builtin_needs_main_window_false_for_open_ai_and_open_notes() {
+        assert!(!builtin_needs_main_window_for_command_id("builtin-open-ai"));
+        assert!(!builtin_needs_main_window_for_command_id(
+            "builtin-open-notes"
+        ));
+    }
+
+    #[test]
+    fn test_builtin_needs_main_window_true_for_unlisted_builtin() {
+        assert!(builtin_needs_main_window_for_command_id(
+            "builtin-refresh-scripts"
+        ));
+    }
+}
+
 impl ScriptListApp {
-    pub(crate) fn execute_scriptlet(&mut self, scriptlet: &scripts::Scriptlet, cx: &mut Context<Self>) {
+    pub(crate) fn execute_scriptlet(
+        &mut self,
+        scriptlet: &scripts::Scriptlet,
+        cx: &mut Context<Self>,
+    ) {
         logging::log(
             "EXEC",
             &format!(
@@ -313,16 +352,6 @@
             &format!("Executing by command ID or path: {}", command_id),
         );
 
-        // Builtins that open their own windows and don't need main window
-        const NO_MAIN_WINDOW_BUILTINS: &[&str] = &[
-            "builtin-ai-chat",
-            "builtin-notes",
-            "builtin-new-note",
-            "builtin-search-notes",
-            "builtin-quick-capture",
-            "builtin-new-conversation",
-        ];
-
         // Parse command ID format: "type/identifier"
         if let Some((cmd_type, identifier)) = command_id.split_once('/') {
             match cmd_type {
@@ -352,7 +381,8 @@
                         logging::log("EXEC", &format!("Executing builtin: {}", identifier));
                         self.execute_builtin(entry, cx);
                         // Check if this builtin opens its own window
-                        let needs_main_window = !NO_MAIN_WINDOW_BUILTINS.contains(&identifier);
+                        let needs_main_window =
+                            builtin_needs_main_window_for_command_id(identifier);
                         logging::log(
                             "EXEC",
                             &format!(
@@ -418,5 +448,4 @@
         self.execute_script_by_path(command_id, cx);
         true
     }
-
 }


thinking
**Verifying recent format changes**
codex
I ran `rustfmt` on the two changed files (`--edition 2021`) to keep the patch clean. Next I‚Äôm doing a final diff review and then I‚Äôll update swarm status/release claims with verification results and known blockers from unrelated compile breakages.
exec
/bin/zsh -lc 'git diff -- src/app_execute/builtin_execution.rs src/app_impl/execution_scripts.rs' in /Users/johnlindquist/dev/script-kit-gpui succeeded in 51ms:
diff --git a/src/app_execute/builtin_execution.rs b/src/app_execute/builtin_execution.rs
index ea07c5b..3e9923a 100644
--- a/src/app_execute/builtin_execution.rs
+++ b/src/app_execute/builtin_execution.rs
@@ -1,3 +1,7 @@
+fn ai_open_failure_message(error: impl std::fmt::Display) -> String {
+    format!("Failed to open AI: {}", error)
+}
+
 impl ScriptListApp {
     fn system_action_feedback_message(
         &self,
@@ -286,7 +290,7 @@ impl ScriptListApp {
                             let _ = this.update(cx, |this, cx| {
                                 this.toast_manager.push(
                                     components::toast::Toast::error(
-                                        format!("Failed to open AI: {}", e),
+                                        ai_open_failure_message(e),
                                         &this.theme,
                                     )
file update:
diff --git a/src/app_execute/builtin_execution.rs b/src/app_execute/builtin_execution.rs
index ea07c5b2c4e5ef82ea1337d249f517425db711fa..3e9923aa9e6a77375357296e6184eeacf53d258b
--- a/src/app_execute/builtin_execution.rs
+++ b/src/app_execute/builtin_execution.rs
@@ -1,3 +1,7 @@
+fn ai_open_failure_message(error: impl std::fmt::Display) -> String {
+    format!("Failed to open AI: {}", error)
+}
+
 impl ScriptListApp {
     fn system_action_feedback_message(
         &self,
@@ -286,7 +290,7 @@
                             let _ = this.update(cx, |this, cx| {
                                 this.toast_manager.push(
                                     components::toast::Toast::error(
-                                        format!("Failed to open AI: {}", e),
+                                        ai_open_failure_message(e),
                                         &this.theme,
                                     )
                                     .duration_ms(Some(5000)),
@@ -501,7 +505,6 @@
             // =========================================================================
             // Notes Commands
             // =========================================================================
-
             builtins::BuiltInFeature::NotesCommand(cmd_type) => {
                 logging::log("EXEC", &format!("Executing notes command: {:?}", cmd_type));
 
@@ -552,7 +555,7 @@
                             logging::log("ERROR", &format!("AI command failed: {}", e));
                             self.toast_manager.push(
                                 components::toast::Toast::error(
-                                    format!("Failed to open AI: {}", e),
+                                    ai_open_failure_message(e),
                                     &self.theme,
                                 )
                                 .duration_ms(Some(5000)),
@@ -632,7 +635,15 @@
                                     ),
                                 );
                                 if let Err(e) = ai::open_ai_window(cx) {
-                                    logging::log("ERROR", &format!("Failed to open AI: {}", e));
+                                    logging::log("ERROR", &ai_open_failure_message(e));
+                                    self.toast_manager.push(
+                                        components::toast::Toast::error(
+                                            ai_open_failure_message(e),
+                                            &self.theme,
+                                        )
+                                        .duration_ms(Some(5000)),
+                                    );
+                                    cx.notify();
                                 } else {
                                     // Set input with the screenshot context
                                     ai::set_ai_input_with_image(cx, &message, &base64_data, false);
@@ -675,7 +686,15 @@
                                     ),
                                 );
                                 if let Err(e) = ai::open_ai_window(cx) {
-                                    logging::log("ERROR", &format!("Failed to open AI: {}", e));
+                                    logging::log("ERROR", &ai_open_failure_message(e));
+                                    self.toast_manager.push(
+                                        components::toast::Toast::error(
+                                            ai_open_failure_message(e),
+                                            &self.theme,
+                                        )
+                                        .duration_ms(Some(5000)),
+                                    );
+                                    cx.notify();
                                 } else {
                                     ai::set_ai_input_with_image(cx, &message, &base64_data, false);
                                 }
@@ -707,7 +726,15 @@
                                     &format!("Selected text captured: {} chars", text.len()),
                                 );
                                 if let Err(e) = ai::open_ai_window(cx) {
-                                    logging::log("ERROR", &format!("Failed to open AI: {}", e));
+                                    logging::log("ERROR", &ai_open_failure_message(e));
+                                    self.toast_manager.push(
+                                        components::toast::Toast::error(
+                                            ai_open_failure_message(e),
+                                            &self.theme,
+                                        )
+                                        .duration_ms(Some(5000)),
+                                    );
+                                    cx.notify();
                                 } else {
                                     ai::set_ai_input(cx, &message, false);
                                 }
@@ -750,7 +777,15 @@
                                 );
                                 logging::log("EXEC", &format!("Browser URL captured: {}", url));
                                 if let Err(e) = ai::open_ai_window(cx) {
-                                    logging::log("ERROR", &format!("Failed to open AI: {}", e));
+                                    logging::log("ERROR", &ai_open_failure_message(e));
+                                    self.toast_manager.push(
+                                        components::toast::Toast::error(
+                                            ai_open_failure_message(e),
+                                            &self.theme,
+                                        )
+                                        .duration_ms(Some(5000)),
+                                    );
+                                    cx.notify();
                                 } else {
                                     ai::set_ai_input(cx, &message, false);
                                 }
@@ -794,7 +829,14 @@
                             .duration_ms(Some(3000)),
                         );
                         if let Err(e) = ai::open_ai_window(cx) {
-                            logging::log("ERROR", &format!("Failed to open AI: {}", e));
+                            logging::log("ERROR", &ai_open_failure_message(e));
+                            self.toast_manager.push(
+                                components::toast::Toast::error(
+                                    ai_open_failure_message(e),
+                                    &self.theme,
+                                )
+                                .duration_ms(Some(5000)),
+                            );
                         }
                         cx.notify();
                     }
@@ -864,7 +906,6 @@
             // =========================================================================
             // Permission Commands
             // =========================================================================
-
             builtins::BuiltInFeature::PermissionCommand(cmd_type) => {
                 logging::log(
                     "EXEC",
@@ -1054,8 +1095,7 @@
                         self.pending_filter_sync = true;
                         self.pending_placeholder = Some("Search themes...".to_string());
                         // Start at the currently active theme
-                        let start_index =
-                            theme::presets::find_current_preset_index(&self.theme);
+                        let start_index = theme::presets::find_current_preset_index(&self.theme);
                         self.current_view = AppView::ThemeChooserView {
                             filter: String::new(),
                             selected_index: start_index,
@@ -1138,7 +1178,11 @@
                         );
 
                         if process_count == 0 {
-                            self.show_hud("No running scripts to stop.".to_string(), Some(2200), cx);
+                            self.show_hud(
+                                "No running scripts to stop.".to_string(),
+                                Some(2200),
+                                cx,
+                            );
                         } else {
                             crate::process_manager::PROCESS_MANAGER.kill_all_processes();
                             self.show_hud(
@@ -1166,7 +1210,19 @@
                 self.opened_from_main_menu = true;
                 self.open_file_search(String::new(), cx);
             }
+        }
+    }
+}
+
+#[cfg(test)]
+mod builtin_execution_ai_feedback_tests {
+    use super::ai_open_failure_message;
 
-        }
+    #[test]
+    fn test_ai_open_failure_message_includes_error_details() {
+        assert_eq!(
+            ai_open_failure_message("window init failed"),
+            "Failed to open AI: window init failed"
+        );
     }
 }
diff --git a/src/app_impl/execution_scripts.rs b/src/app_impl/execution_scripts.rs
index ac99cc20952af2f8c39e301b7740e55cec8f394e..f801a9367f6c50f5c615f60651f1836289ded064
--- a/src/app_impl/execution_scripts.rs
+++ b/src/app_impl/execution_scripts.rs
@@ -1,7 +1,46 @@
 use super::*;
 
+const NO_MAIN_WINDOW_BUILTINS: &[&str] = &[
+    "builtin-ai-chat",
+    "builtin-open-ai",
+    "builtin-notes",
+    "builtin-open-notes",
+    "builtin-new-note",
+    "builtin-search-notes",
+    "builtin-quick-capture",
+    "builtin-new-conversation",
+];
+
+fn builtin_needs_main_window_for_command_id(identifier: &str) -> bool {
+    !NO_MAIN_WINDOW_BUILTINS.contains(&identifier)
+}
+
+#[cfg(test)]
+mod builtin_command_window_visibility_tests {
+    use super::builtin_needs_main_window_for_command_id;
+
+    #[test]
+    fn test_builtin_needs_main_window_false_for_open_ai_and_open_notes() {
+        assert!(!builtin_needs_main_window_for_command_id("builtin-open-ai"));
+        assert!(!builtin_needs_main_window_for_command_id(
+            "builtin-open-notes"
+        ));
+    }
+
+    #[test]
+    fn test_builtin_needs_main_window_true_for_unlisted_builtin() {
+        assert!(builtin_needs_main_window_for_command_id(
+            "builtin-refresh-scripts"
+        ));
+    }
+}
+
 impl ScriptListApp {
-    pub(crate) fn execute_scriptlet(&mut self, scriptlet: &scripts::Scriptlet, cx: &mut Context<Self>) {
+    pub(crate) fn execute_scriptlet(
+        &mut self,
+        scriptlet: &scripts::Scriptlet,
+        cx: &mut Context<Self>,
+    ) {
         logging::log(
             "EXEC",
             &format!(
@@ -313,16 +352,6 @@
             &format!("Executing by command ID or path: {}", command_id),
         );
 
-        // Builtins that open their own windows and don't need main window
-        const NO_MAIN_WINDOW_BUILTINS: &[&str] = &[
-            "builtin-ai-chat",
-            "builtin-notes",
-            "builtin-new-note",
-            "builtin-search-notes",
-            "builtin-quick-capture",
-            "builtin-new-conversation",
-        ];
-
         // Parse command ID format: "type/identifier"
         if let Some((cmd_type, identifier)) = command_id.split_once('/') {
             match cmd_type {
@@ -352,7 +381,8 @@
                         logging::log("EXEC", &format!("Executing builtin: {}", identifier));
                         self.execute_builtin(entry, cx);
                         // Check if this builtin opens its own window
-                        let needs_main_window = !NO_MAIN_WINDOW_BUILTINS.contains(&identifier);
+                        let needs_main_window =
+                            builtin_needs_main_window_for_command_id(identifier);
                         logging::log(
                             "EXEC",
                             &format!(
@@ -418,5 +448,4 @@
         self.execute_script_by_path(command_id, cx);
         true
     }
-
 }


thinking
**Reverting unrelated rustfmt changes**
file update
M /Users/johnlindquist/dev/script-kit-gpui/src/app_execute/builtin_execution.rs
@@ -507,2 +507,3 @@
             // =========================================================================
+
             builtins::BuiltInFeature::NotesCommand(cmd_type) => {
@@ -908,2 +909,3 @@
             // =========================================================================
+
             builtins::BuiltInFeature::PermissionCommand(cmd_type) => {
@@ -1097,3 +1099,4 @@
                         // Start at the currently active theme
-                        let start_index = theme::presets::find_current_preset_index(&self.theme);
+                        let start_index =
+                            theme::presets::find_current_preset_index(&self.theme);
                         self.current_view = AppView::ThemeChooserView {
@@ -1180,7 +1183,3 @@
                         if process_count == 0 {
-                            self.show_hud(
-                                "No running scripts to stop.".to_string(),
-                                Some(2200),
-                                cx,
-                            );
+                            self.show_hud("No running scripts to stop.".to_string(), Some(2200), cx);
                         } else {
@@ -1212,2 +1211,3 @@
             }
+
         }
apply_patch(auto_approved=true) exited 0 in 18ms:
Success. Updated the following files:
M src/app_execute/builtin_execution.rs
file update:
diff --git a/src/app_execute/builtin_execution.rs b/src/app_execute/builtin_execution.rs
index ea07c5b2c4e5ef82ea1337d249f517425db711fa..7aec3d989171034264f550717466ea395568100d
--- a/src/app_execute/builtin_execution.rs
+++ b/src/app_execute/builtin_execution.rs
@@ -1,3 +1,7 @@
+fn ai_open_failure_message(error: impl std::fmt::Display) -> String {
+    format!("Failed to open AI: {}", error)
+}
+
 impl ScriptListApp {
     fn system_action_feedback_message(
         &self,
@@ -286,7 +290,7 @@
                             let _ = this.update(cx, |this, cx| {
                                 this.toast_manager.push(
                                     components::toast::Toast::error(
-                                        format!("Failed to open AI: {}", e),
+                                        ai_open_failure_message(e),
                                         &this.theme,
                                     )
                                     .duration_ms(Some(5000)),
@@ -552,7 +556,7 @@
                             logging::log("ERROR", &format!("AI command failed: {}", e));
                             self.toast_manager.push(
                                 components::toast::Toast::error(
-                                    format!("Failed to open AI: {}", e),
+                                    ai_open_failure_message(e),
                                     &self.theme,
                                 )
                                 .duration_ms(Some(5000)),
@@ -632,7 +636,15 @@
                                     ),
                                 );
                                 if let Err(e) = ai::open_ai_window(cx) {
-                                    logging::log("ERROR", &format!("Failed to open AI: {}", e));
+                                    logging::log("ERROR", &ai_open_failure_message(e));
+                                    self.toast_manager.push(
+                                        components::toast::Toast::error(
+                                            ai_open_failure_message(e),
+                                            &self.theme,
+                                        )
+                                        .duration_ms(Some(5000)),
+                                    );
+                                    cx.notify();
                                 } else {
                                     // Set input with the screenshot context
                                     ai::set_ai_input_with_image(cx, &message, &base64_data, false);
@@ -675,7 +687,15 @@
                                     ),
                                 );
                                 if let Err(e) = ai::open_ai_window(cx) {
-                                    logging::log("ERROR", &format!("Failed to open AI: {}", e));
+                                    logging::log("ERROR", &ai_open_failure_message(e));
+                                    self.toast_manager.push(
+                                        components::toast::Toast::error(
+                                            ai_open_failure_message(e),
+                                            &self.theme,
+                                        )
+                                        .duration_ms(Some(5000)),
+                                    );
+                                    cx.notify();
                                 } else {
                                     ai::set_ai_input_with_image(cx, &message, &base64_data, false);
                                 }
@@ -707,7 +727,15 @@
                                     &format!("Selected text captured: {} chars", text.len()),
                                 );
                                 if let Err(e) = ai::open_ai_window(cx) {
-                                    logging::log("ERROR", &format!("Failed to open AI: {}", e));
+                                    logging::log("ERROR", &ai_open_failure_message(e));
+                                    self.toast_manager.push(
+                                        components::toast::Toast::error(
+                                            ai_open_failure_message(e),
+                                            &self.theme,
+                                        )
+                                        .duration_ms(Some(5000)),
+                                    );
+                                    cx.notify();
                                 } else {
                                     ai::set_ai_input(cx, &message, false);
                                 }
@@ -750,7 +778,15 @@
                                 );
                                 logging::log("EXEC", &format!("Browser URL captured: {}", url));
                                 if let Err(e) = ai::open_ai_window(cx) {
-                                    logging::log("ERROR", &format!("Failed to open AI: {}", e));
+                                    logging::log("ERROR", &ai_open_failure_message(e));
+                                    self.toast_manager.push(
+                                        components::toast::Toast::error(
+                                            ai_open_failure_message(e),
+                                            &self.theme,
+                                        )
+                                        .duration_ms(Some(5000)),
+                                    );
+                                    cx.notify();
                                 } else {
                                     ai::set_ai_input(cx, &message, false);
                                 }
@@ -794,7 +830,14 @@
                             .duration_ms(Some(3000)),
                         );
                         if let Err(e) = ai::open_ai_window(cx) {
-                            logging::log("ERROR", &format!("Failed to open AI: {}", e));
+                            logging::log("ERROR", &ai_open_failure_message(e));
+                            self.toast_manager.push(
+                                components::toast::Toast::error(
+                                    ai_open_failure_message(e),
+                                    &self.theme,
+                                )
+                                .duration_ms(Some(5000)),
+                            );
                         }
                         cx.notify();
                     }
@@ -1170,3 +1213,16 @@
         }
     }
 }
+
+#[cfg(test)]
+mod builtin_execution_ai_feedback_tests {
+    use super::ai_open_failure_message;
+
+    #[test]
+    fn test_ai_open_failure_message_includes_error_details() {
+        assert_eq!(
+            ai_open_failure_message("window init failed"),
+            "Failed to open AI: window init failed"
+        );
+    }
+}
diff --git a/src/app_impl/execution_scripts.rs b/src/app_impl/execution_scripts.rs
index ac99cc20952af2f8c39e301b7740e55cec8f394e..f801a9367f6c50f5c615f60651f1836289ded064
--- a/src/app_impl/execution_scripts.rs
+++ b/src/app_impl/execution_scripts.rs
@@ -1,7 +1,46 @@
 use super::*;
 
+const NO_MAIN_WINDOW_BUILTINS: &[&str] = &[
+    "builtin-ai-chat",
+    "builtin-open-ai",
+    "builtin-notes",
+    "builtin-open-notes",
+    "builtin-new-note",
+    "builtin-search-notes",
+    "builtin-quick-capture",
+    "builtin-new-conversation",
+];
+
+fn builtin_needs_main_window_for_command_id(identifier: &str) -> bool {
+    !NO_MAIN_WINDOW_BUILTINS.contains(&identifier)
+}
+
+#[cfg(test)]
+mod builtin_command_window_visibility_tests {
+    use super::builtin_needs_main_window_for_command_id;
+
+    #[test]
+    fn test_builtin_needs_main_window_false_for_open_ai_and_open_notes() {
+        assert!(!builtin_needs_main_window_for_command_id("builtin-open-ai"));
+        assert!(!builtin_needs_main_window_for_command_id(
+            "builtin-open-notes"
+        ));
+    }
+
+    #[test]
+    fn test_builtin_needs_main_window_true_for_unlisted_builtin() {
+        assert!(builtin_needs_main_window_for_command_id(
+            "builtin-refresh-scripts"
+        ));
+    }
+}
+
 impl ScriptListApp {
-    pub(crate) fn execute_scriptlet(&mut self, scriptlet: &scripts::Scriptlet, cx: &mut Context<Self>) {
+    pub(crate) fn execute_scriptlet(
+        &mut self,
+        scriptlet: &scripts::Scriptlet,
+        cx: &mut Context<Self>,
+    ) {
         logging::log(
             "EXEC",
             &format!(
@@ -313,16 +352,6 @@
             &format!("Executing by command ID or path: {}", command_id),
         );
 
-        // Builtins that open their own windows and don't need main window
-        const NO_MAIN_WINDOW_BUILTINS: &[&str] = &[
-            "builtin-ai-chat",
-            "builtin-notes",
-            "builtin-new-note",
-            "builtin-search-notes",
-            "builtin-quick-capture",
-            "builtin-new-conversation",
-        ];
-
         // Parse command ID format: "type/identifier"
         if let Some((cmd_type, identifier)) = command_id.split_once('/') {
             match cmd_type {
@@ -352,7 +381,8 @@
                         logging::log("EXEC", &format!("Executing builtin: {}", identifier));
                         self.execute_builtin(entry, cx);
                         // Check if this builtin opens its own window
-                        let needs_main_window = !NO_MAIN_WINDOW_BUILTINS.contains(&identifier);
+                        let needs_main_window =
+                            builtin_needs_main_window_for_command_id(identifier);
                         logging::log(
                             "EXEC",
                             &format!(
@@ -418,5 +448,4 @@
         self.execute_script_by_path(command_id, cx);
         true
     }
-
 }

file update:
diff --git a/src/app_execute/builtin_execution.rs b/src/app_execute/builtin_execution.rs
index ea07c5b2c4e5ef82ea1337d249f517425db711fa..7aec3d989171034264f550717466ea395568100d
--- a/src/app_execute/builtin_execution.rs
+++ b/src/app_execute/builtin_execution.rs
@@ -1,3 +1,7 @@
+fn ai_open_failure_message(error: impl std::fmt::Display) -> String {
+    format!("Failed to open AI: {}", error)
+}
+
 impl ScriptListApp {
     fn system_action_feedback_message(
         &self,
@@ -286,7 +290,7 @@
                             let _ = this.update(cx, |this, cx| {
                                 this.toast_manager.push(
                                     components::toast::Toast::error(
-                                        format!("Failed to open AI: {}", e),
+                                        ai_open_failure_message(e),
                                         &this.theme,
                                     )
                                     .duration_ms(Some(5000)),
@@ -552,7 +556,7 @@
                             logging::log("ERROR", &format!("AI command failed: {}", e));
                             self.toast_manager.push(
                                 components::toast::Toast::error(
-                                    format!("Failed to open AI: {}", e),
+                                    ai_open_failure_message(e),
                                     &self.theme,
                                 )
                                 .duration_ms(Some(5000)),
@@ -632,7 +636,15 @@
                                     ),
                                 );
                                 if let Err(e) = ai::open_ai_window(cx) {
-                                    logging::log("ERROR", &format!("Failed to open AI: {}", e));
+                                    logging::log("ERROR", &ai_open_failure_message(e));
+                                    self.toast_manager.push(
+                                        components::toast::Toast::error(
+                                            ai_open_failure_message(e),
+                                            &self.theme,
+                                        )
+                                        .duration_ms(Some(5000)),
+                                    );
+                                    cx.notify();
                                 } else {
                                     // Set input with the screenshot context
                                     ai::set_ai_input_with_image(cx, &message, &base64_data, false);
@@ -675,7 +687,15 @@
                                     ),
                                 );
                                 if let Err(e) = ai::open_ai_window(cx) {
-                                    logging::log("ERROR", &format!("Failed to open AI: {}", e));
+                                    logging::log("ERROR", &ai_open_failure_message(e));
+                                    self.toast_manager.push(
+                                        components::toast::Toast::error(
+                                            ai_open_failure_message(e),
+                                            &self.theme,
+                                        )
+                                        .duration_ms(Some(5000)),
+                                    );
+                                    cx.notify();
                                 } else {
                                     ai::set_ai_input_with_image(cx, &message, &base64_data, false);
                                 }
@@ -707,7 +727,15 @@
                                     &format!("Selected text captured: {} chars", text.len()),
                                 );
                                 if let Err(e) = ai::open_ai_window(cx) {
-                                    logging::log("ERROR", &format!("Failed to open AI: {}", e));
+                                    logging::log("ERROR", &ai_open_failure_message(e));
+                                    self.toast_manager.push(
+                                        components::toast::Toast::error(
+                                            ai_open_failure_message(e),
+                                            &self.theme,
+                                        )
+                                        .duration_ms(Some(5000)),
+                                    );
+                                    cx.notify();
                                 } else {
                                     ai::set_ai_input(cx, &message, false);
                                 }
@@ -750,7 +778,15 @@
                                 );
                                 logging::log("EXEC", &format!("Browser URL captured: {}", url));
                                 if let Err(e) = ai::open_ai_window(cx) {
-                                    logging::log("ERROR", &format!("Failed to open AI: {}", e));
+                                    logging::log("ERROR", &ai_open_failure_message(e));
+                                    self.toast_manager.push(
+                                        components::toast::Toast::error(
+                                            ai_open_failure_message(e),
+                                            &self.theme,
+                                        )
+                                        .duration_ms(Some(5000)),
+                                    );
+                                    cx.notify();
                                 } else {
                                     ai::set_ai_input(cx, &message, false);
                                 }
@@ -794,7 +830,14 @@
                             .duration_ms(Some(3000)),
                         );
                         if let Err(e) = ai::open_ai_window(cx) {
-                            logging::log("ERROR", &format!("Failed to open AI: {}", e));
+                            logging::log("ERROR", &ai_open_failure_message(e));
+                            self.toast_manager.push(
+                                components::toast::Toast::error(
+                                    ai_open_failure_message(e),
+                                    &self.theme,
+                                )
+                                .duration_ms(Some(5000)),
+                            );
                         }
                         cx.notify();
                     }
@@ -1170,3 +1213,16 @@
         }
     }
 }
+
+#[cfg(test)]
+mod builtin_execution_ai_feedback_tests {
+    use super::ai_open_failure_message;
+
+    #[test]
+    fn test_ai_open_failure_message_includes_error_details() {
+        assert_eq!(
+            ai_open_failure_message("window init failed"),
+            "Failed to open AI: window init failed"
+        );
+    }
+}
diff --git a/src/app_impl/execution_scripts.rs b/src/app_impl/execution_scripts.rs
index ac99cc20952af2f8c39e301b7740e55cec8f394e..f801a9367f6c50f5c615f60651f1836289ded064
--- a/src/app_impl/execution_scripts.rs
+++ b/src/app_impl/execution_scripts.rs
@@ -1,7 +1,46 @@
 use super::*;
 
+const NO_MAIN_WINDOW_BUILTINS: &[&str] = &[
+    "builtin-ai-chat",
+    "builtin-open-ai",
+    "builtin-notes",
+    "builtin-open-notes",
+    "builtin-new-note",
+    "builtin-search-notes",
+    "builtin-quick-capture",
+    "builtin-new-conversation",
+];
+
+fn builtin_needs_main_window_for_command_id(identifier: &str) -> bool {
+    !NO_MAIN_WINDOW_BUILTINS.contains(&identifier)
+}
+
+#[cfg(test)]
+mod builtin_command_window_visibility_tests {
+    use super::builtin_needs_main_window_for_command_id;
+
+    #[test]
+    fn test_builtin_needs_main_window_false_for_open_ai_and_open_notes() {
+        assert!(!builtin_needs_main_window_for_command_id("builtin-open-ai"));
+        assert!(!builtin_needs_main_window_for_command_id(
+            "builtin-open-notes"
+        ));
+    }
+
+    #[test]
+    fn test_builtin_needs_main_window_true_for_unlisted_builtin() {
+        assert!(builtin_needs_main_window_for_command_id(
+            "builtin-refresh-scripts"
+        ));
+    }
+}
+
 impl ScriptListApp {
-    pub(crate) fn execute_scriptlet(&mut self, scriptlet: &scripts::Scriptlet, cx: &mut Context<Self>) {
+    pub(crate) fn execute_scriptlet(
+        &mut self,
+        scriptlet: &scripts::Scriptlet,
+        cx: &mut Context<Self>,
+    ) {
         logging::log(
             "EXEC",
             &format!(
@@ -313,16 +352,6 @@
             &format!("Executing by command ID or path: {}", command_id),
         );
 
-        // Builtins that open their own windows and don't need main window
-        const NO_MAIN_WINDOW_BUILTINS: &[&str] = &[
-            "builtin-ai-chat",
-            "builtin-notes",
-            "builtin-new-note",
-            "builtin-search-notes",
-            "builtin-quick-capture",
-            "builtin-new-conversation",
-        ];
-
         // Parse command ID format: "type/identifier"
         if let Some((cmd_type, identifier)) = command_id.split_once('/') {
             match cmd_type {
@@ -352,7 +381,8 @@
                         logging::log("EXEC", &format!("Executing builtin: {}", identifier));
                         self.execute_builtin(entry, cx);
                         // Check if this builtin opens its own window
-                        let needs_main_window = !NO_MAIN_WINDOW_BUILTINS.contains(&identifier);
+                        let needs_main_window =
+                            builtin_needs_main_window_for_command_id(identifier);
                         logging::log(
                             "EXEC",
                             &format!(
@@ -418,5 +448,4 @@
         self.execute_script_by_path(command_id, cx);
         true
     }
-
 }


thinking
**Restoring function signature and formatting**
file update
M /Users/johnlindquist/dev/script-kit-gpui/src/app_impl/execution_scripts.rs
@@ -38,7 +38,3 @@
 impl ScriptListApp {
-    pub(crate) fn execute_scriptlet(
-        &mut self,
-        scriptlet: &scripts::Scriptlet,
-        cx: &mut Context<Self>,
-    ) {
+    pub(crate) fn execute_scriptlet(&mut self, scriptlet: &scripts::Scriptlet, cx: &mut Context<Self>) {
         logging::log(
@@ -450,2 +446,3 @@
     }
+
 }
apply_patch(auto_approved=true) exited 0 in 17ms:
Success. Updated the following files:
M src/app_impl/execution_scripts.rs
file update:
diff --git a/src/app_execute/builtin_execution.rs b/src/app_execute/builtin_execution.rs
index ea07c5b2c4e5ef82ea1337d249f517425db711fa..7aec3d989171034264f550717466ea395568100d
--- a/src/app_execute/builtin_execution.rs
+++ b/src/app_execute/builtin_execution.rs
@@ -1,3 +1,7 @@
+fn ai_open_failure_message(error: impl std::fmt::Display) -> String {
+    format!("Failed to open AI: {}", error)
+}
+
 impl ScriptListApp {
     fn system_action_feedback_message(
         &self,
@@ -286,7 +290,7 @@
                             let _ = this.update(cx, |this, cx| {
                                 this.toast_manager.push(
                                     components::toast::Toast::error(
-                                        format!("Failed to open AI: {}", e),
+                                        ai_open_failure_message(e),
                                         &this.theme,
                                     )
                                     .duration_ms(Some(5000)),
@@ -552,7 +556,7 @@
                             logging::log("ERROR", &format!("AI command failed: {}", e));
                             self.toast_manager.push(
                                 components::toast::Toast::error(
-                                    format!("Failed to open AI: {}", e),
+                                    ai_open_failure_message(e),
                                     &self.theme,
                                 )
                                 .duration_ms(Some(5000)),
@@ -632,7 +636,15 @@
                                     ),
                                 );
                                 if let Err(e) = ai::open_ai_window(cx) {
-                                    logging::log("ERROR", &format!("Failed to open AI: {}", e));
+                                    logging::log("ERROR", &ai_open_failure_message(e));
+                                    self.toast_manager.push(
+                                        components::toast::Toast::error(
+                                            ai_open_failure_message(e),
+                                            &self.theme,
+                                        )
+                                        .duration_ms(Some(5000)),
+                                    );
+                                    cx.notify();
                                 } else {
                                     // Set input with the screenshot context
                                     ai::set_ai_input_with_image(cx, &message, &base64_data, false);
@@ -675,7 +687,15 @@
                                     ),
                                 );
                                 if let Err(e) = ai::open_ai_window(cx) {
-                                    logging::log("ERROR", &format!("Failed to open AI: {}", e));
+                                    logging::log("ERROR", &ai_open_failure_message(e));
+                                    self.toast_manager.push(
+                                        components::toast::Toast::error(
+                                            ai_open_failure_message(e),
+                                            &self.theme,
+                                        )
+                                        .duration_ms(Some(5000)),
+                                    );
+                                    cx.notify();
                                 } else {
                                     ai::set_ai_input_with_image(cx, &message, &base64_data, false);
                                 }
@@ -707,7 +727,15 @@
                                     &format!("Selected text captured: {} chars", text.len()),
                                 );
                                 if let Err(e) = ai::open_ai_window(cx) {
-                                    logging::log("ERROR", &format!("Failed to open AI: {}", e));
+                                    logging::log("ERROR", &ai_open_failure_message(e));
+                                    self.toast_manager.push(
+                                        components::toast::Toast::error(
+                                            ai_open_failure_message(e),
+                                            &self.theme,
+                                        )
+                                        .duration_ms(Some(5000)),
+                                    );
+                                    cx.notify();
                                 } else {
                                     ai::set_ai_input(cx, &message, false);
                                 }
@@ -750,7 +778,15 @@
                                 );
                                 logging::log("EXEC", &format!("Browser URL captured: {}", url));
                                 if let Err(e) = ai::open_ai_window(cx) {
-                                    logging::log("ERROR", &format!("Failed to open AI: {}", e));
+                                    logging::log("ERROR", &ai_open_failure_message(e));
+                                    self.toast_manager.push(
+                                        components::toast::Toast::error(
+                                            ai_open_failure_message(e),
+                                            &self.theme,
+                                        )
+                                        .duration_ms(Some(5000)),
+                                    );
+                                    cx.notify();
                                 } else {
                                     ai::set_ai_input(cx, &message, false);
                                 }
@@ -794,7 +830,14 @@
                             .duration_ms(Some(3000)),
                         );
                         if let Err(e) = ai::open_ai_window(cx) {
-                            logging::log("ERROR", &format!("Failed to open AI: {}", e));
+                            logging::log("ERROR", &ai_open_failure_message(e));
+                            self.toast_manager.push(
+                                components::toast::Toast::error(
+                                    ai_open_failure_message(e),
+                                    &self.theme,
+                                )
+                                .duration_ms(Some(5000)),
+                            );
                         }
                         cx.notify();
                     }
@@ -1170,3 +1213,16 @@
         }
     }
 }
+
+#[cfg(test)]
+mod builtin_execution_ai_feedback_tests {
+    use super::ai_open_failure_message;
+
+    #[test]
+    fn test_ai_open_failure_message_includes_error_details() {
+        assert_eq!(
+            ai_open_failure_message("window init failed"),
+            "Failed to open AI: window init failed"
+        );
+    }
+}
diff --git a/src/app_impl/execution_scripts.rs b/src/app_impl/execution_scripts.rs
index ac99cc20952af2f8c39e301b7740e55cec8f394e..d870c647daaa9030713a2e74635d580b8dda93c4
--- a/src/app_impl/execution_scripts.rs
+++ b/src/app_impl/execution_scripts.rs
@@ -1,5 +1,40 @@
 use super::*;
 
+const NO_MAIN_WINDOW_BUILTINS: &[&str] = &[
+    "builtin-ai-chat",
+    "builtin-open-ai",
+    "builtin-notes",
+    "builtin-open-notes",
+    "builtin-new-note",
+    "builtin-search-notes",
+    "builtin-quick-capture",
+    "builtin-new-conversation",
+];
+
+fn builtin_needs_main_window_for_command_id(identifier: &str) -> bool {
+    !NO_MAIN_WINDOW_BUILTINS.contains(&identifier)
+}
+
+#[cfg(test)]
+mod builtin_command_window_visibility_tests {
+    use super::builtin_needs_main_window_for_command_id;
+
+    #[test]
+    fn test_builtin_needs_main_window_false_for_open_ai_and_open_notes() {
+        assert!(!builtin_needs_main_window_for_command_id("builtin-open-ai"));
+        assert!(!builtin_needs_main_window_for_command_id(
+            "builtin-open-notes"
+        ));
+    }
+
+    #[test]
+    fn test_builtin_needs_main_window_true_for_unlisted_builtin() {
+        assert!(builtin_needs_main_window_for_command_id(
+            "builtin-refresh-scripts"
+        ));
+    }
+}
+
 impl ScriptListApp {
     pub(crate) fn execute_scriptlet(&mut self, scriptlet: &scripts::Scriptlet, cx: &mut Context<Self>) {
         logging::log(
@@ -312,16 +347,6 @@
             "EXEC",
             &format!("Executing by command ID or path: {}", command_id),
         );
-
-        // Builtins that open their own windows and don't need main window
-        const NO_MAIN_WINDOW_BUILTINS: &[&str] = &[
-            "builtin-ai-chat",
-            "builtin-notes",
-            "builtin-new-note",
-            "builtin-search-notes",
-            "builtin-quick-capture",
-            "builtin-new-conversation",
-        ];
 
         // Parse command ID format: "type/identifier"
         if let Some((cmd_type, identifier)) = command_id.split_once('/') {
@@ -352,7 +377,8 @@
                         logging::log("EXEC", &format!("Executing builtin: {}", identifier));
                         self.execute_builtin(entry, cx);
                         // Check if this builtin opens its own window
-                        let needs_main_window = !NO_MAIN_WINDOW_BUILTINS.contains(&identifier);
+                        let needs_main_window =
+                            builtin_needs_main_window_for_command_id(identifier);
                         logging::log(
                             "EXEC",
                             &format!(

file update:
diff --git a/src/app_execute/builtin_execution.rs b/src/app_execute/builtin_execution.rs
index ea07c5b2c4e5ef82ea1337d249f517425db711fa..7aec3d989171034264f550717466ea395568100d
--- a/src/app_execute/builtin_execution.rs
+++ b/src/app_execute/builtin_execution.rs
@@ -1,3 +1,7 @@
+fn ai_open_failure_message(error: impl std::fmt::Display) -> String {
+    format!("Failed to open AI: {}", error)
+}
+
 impl ScriptListApp {
     fn system_action_feedback_message(
         &self,
@@ -286,7 +290,7 @@
                             let _ = this.update(cx, |this, cx| {
                                 this.toast_manager.push(
                                     components::toast::Toast::error(
-                                        format!("Failed to open AI: {}", e),
+                                        ai_open_failure_message(e),
                                         &this.theme,
                                     )
                                     .duration_ms(Some(5000)),
@@ -552,7 +556,7 @@
                             logging::log("ERROR", &format!("AI command failed: {}", e));
                             self.toast_manager.push(
                                 components::toast::Toast::error(
-                                    format!("Failed to open AI: {}", e),
+                                    ai_open_failure_message(e),
                                     &self.theme,
                                 )
                                 .duration_ms(Some(5000)),
@@ -632,7 +636,15 @@
                                     ),
                                 );
                                 if let Err(e) = ai::open_ai_window(cx) {
-                                    logging::log("ERROR", &format!("Failed to open AI: {}", e));
+                                    logging::log("ERROR", &ai_open_failure_message(e));
+                                    self.toast_manager.push(
+                                        components::toast::Toast::error(
+                                            ai_open_failure_message(e),
+                                            &self.theme,
+                                        )
+                                        .duration_ms(Some(5000)),
+                                    );
+                                    cx.notify();
                                 } else {
                                     // Set input with the screenshot context
                                     ai::set_ai_input_with_image(cx, &message, &base64_data, false);
@@ -675,7 +687,15 @@
                                     ),
                                 );
                                 if let Err(e) = ai::open_ai_window(cx) {
-                                    logging::log("ERROR", &format!("Failed to open AI: {}", e));
+                                    logging::log("ERROR", &ai_open_failure_message(e));
+                                    self.toast_manager.push(
+                                        components::toast::Toast::error(
+                                            ai_open_failure_message(e),
+                                            &self.theme,
+                                        )
+                                        .duration_ms(Some(5000)),
+                                    );
+                                    cx.notify();
                                 } else {
                                     ai::set_ai_input_with_image(cx, &message, &base64_data, false);
                                 }
@@ -707,7 +727,15 @@
                                     &format!("Selected text captured: {} chars", text.len()),
                                 );
                                 if let Err(e) = ai::open_ai_window(cx) {
-                                    logging::log("ERROR", &format!("Failed to open AI: {}", e));
+                                    logging::log("ERROR", &ai_open_failure_message(e));
+                                    self.toast_manager.push(
+                                        components::toast::Toast::error(
+                                            ai_open_failure_message(e),
+                                            &self.theme,
+                                        )
+                                        .duration_ms(Some(5000)),
+                                    );
+                                    cx.notify();
                                 } else {
                                     ai::set_ai_input(cx, &message, false);
                                 }
@@ -750,7 +778,15 @@
                                 );
                                 logging::log("EXEC", &format!("Browser URL captured: {}", url));
                                 if let Err(e) = ai::open_ai_window(cx) {
-                                    logging::log("ERROR", &format!("Failed to open AI: {}", e));
+                                    logging::log("ERROR", &ai_open_failure_message(e));
+                                    self.toast_manager.push(
+                                        components::toast::Toast::error(
+                                            ai_open_failure_message(e),
+                                            &self.theme,
+                                        )
+                                        .duration_ms(Some(5000)),
+                                    );
+                                    cx.notify();
                                 } else {
                                     ai::set_ai_input(cx, &message, false);
                                 }
@@ -794,7 +830,14 @@
                             .duration_ms(Some(3000)),
                         );
                         if let Err(e) = ai::open_ai_window(cx) {
-                            logging::log("ERROR", &format!("Failed to open AI: {}", e));
+                            logging::log("ERROR", &ai_open_failure_message(e));
+                            self.toast_manager.push(
+                                components::toast::Toast::error(
+                                    ai_open_failure_message(e),
+                                    &self.theme,
+                                )
+                                .duration_ms(Some(5000)),
+                            );
                         }
                         cx.notify();
                     }
@@ -1170,3 +1213,16 @@
         }
     }
 }
+
+#[cfg(test)]
+mod builtin_execution_ai_feedback_tests {
+    use super::ai_open_failure_message;
+
+    #[test]
+    fn test_ai_open_failure_message_includes_error_details() {
+        assert_eq!(
+            ai_open_failure_message("window init failed"),
+            "Failed to open AI: window init failed"
+        );
+    }
+}
diff --git a/src/app_impl/execution_scripts.rs b/src/app_impl/execution_scripts.rs
index ac99cc20952af2f8c39e301b7740e55cec8f394e..d870c647daaa9030713a2e74635d580b8dda93c4
--- a/src/app_impl/execution_scripts.rs
+++ b/src/app_impl/execution_scripts.rs
@@ -1,5 +1,40 @@
 use super::*;
 
+const NO_MAIN_WINDOW_BUILTINS: &[&str] = &[
+    "builtin-ai-chat",
+    "builtin-open-ai",
+    "builtin-notes",
+    "builtin-open-notes",
+    "builtin-new-note",
+    "builtin-search-notes",
+    "builtin-quick-capture",
+    "builtin-new-conversation",
+];
+
+fn builtin_needs_main_window_for_command_id(identifier: &str) -> bool {
+    !NO_MAIN_WINDOW_BUILTINS.contains(&identifier)
+}
+
+#[cfg(test)]
+mod builtin_command_window_visibility_tests {
+    use super::builtin_needs_main_window_for_command_id;
+
+    #[test]
+    fn test_builtin_needs_main_window_false_for_open_ai_and_open_notes() {
+        assert!(!builtin_needs_main_window_for_command_id("builtin-open-ai"));
+        assert!(!builtin_needs_main_window_for_command_id(
+            "builtin-open-notes"
+        ));
+    }
+
+    #[test]
+    fn test_builtin_needs_main_window_true_for_unlisted_builtin() {
+        assert!(builtin_needs_main_window_for_command_id(
+            "builtin-refresh-scripts"
+        ));
+    }
+}
+
 impl ScriptListApp {
     pub(crate) fn execute_scriptlet(&mut self, scriptlet: &scripts::Scriptlet, cx: &mut Context<Self>) {
         logging::log(
@@ -312,16 +347,6 @@
             "EXEC",
             &format!("Executing by command ID or path: {}", command_id),
         );
-
-        // Builtins that open their own windows and don't need main window
-        const NO_MAIN_WINDOW_BUILTINS: &[&str] = &[
-            "builtin-ai-chat",
-            "builtin-notes",
-            "builtin-new-note",
-            "builtin-search-notes",
-            "builtin-quick-capture",
-            "builtin-new-conversation",
-        ];
 
         // Parse command ID format: "type/identifier"
         if let Some((cmd_type, identifier)) = command_id.split_once('/') {
@@ -352,7 +377,8 @@
                         logging::log("EXEC", &format!("Executing builtin: {}", identifier));
                         self.execute_builtin(entry, cx);
                         // Check if this builtin opens its own window
-                        let needs_main_window = !NO_MAIN_WINDOW_BUILTINS.contains(&identifier);
+                        let needs_main_window =
+                            builtin_needs_main_window_for_command_id(identifier);
                         logging::log(
                             "EXEC",
                             &format!(

exec
/bin/zsh -lc 'git diff -- src/app_execute/builtin_execution.rs src/app_impl/execution_scripts.rs' in /Users/johnlindquist/dev/script-kit-gpui succeeded in 51ms:
diff --git a/src/app_execute/builtin_execution.rs b/src/app_execute/builtin_execution.rs
index ea07c5b..7aec3d9 100644
--- a/src/app_execute/builtin_execution.rs
+++ b/src/app_execute/builtin_execution.rs
@@ -1,3 +1,7 @@
+fn ai_open_failure_message(error: impl std::fmt::Display) -> String {
+    format!("Failed to open AI: {}", error)
+}
+
 impl ScriptListApp {
     fn system_action_feedback_message(
         &self,
@@ -286,7 +290,7 @@ impl ScriptListApp {
                             let _ = this.update(cx, |this, cx| {
                                 this.toast_manager.push(
                                     components::toast::Toast::error(
-                                        format!("Failed to open AI: {}", e),
+                                        ai_open_failure_message(e),
                                         &this.theme,
                                     )
file update:
diff --git a/src/app_execute/builtin_execution.rs b/src/app_execute/builtin_execution.rs
index ea07c5b2c4e5ef82ea1337d249f517425db711fa..7aec3d989171034264f550717466ea395568100d
--- a/src/app_execute/builtin_execution.rs
+++ b/src/app_execute/builtin_execution.rs
@@ -1,3 +1,7 @@
+fn ai_open_failure_message(error: impl std::fmt::Display) -> String {
+    format!("Failed to open AI: {}", error)
+}
+
 impl ScriptListApp {
     fn system_action_feedback_message(
         &self,
@@ -286,7 +290,7 @@
                             let _ = this.update(cx, |this, cx| {
                                 this.toast_manager.push(
                                     components::toast::Toast::error(
-                                        format!("Failed to open AI: {}", e),
+                                        ai_open_failure_message(e),
                                         &this.theme,
                                     )
                                     .duration_ms(Some(5000)),
@@ -552,7 +556,7 @@
                             logging::log("ERROR", &format!("AI command failed: {}", e));
                             self.toast_manager.push(
                                 components::toast::Toast::error(
-                                    format!("Failed to open AI: {}", e),
+                                    ai_open_failure_message(e),
                                     &self.theme,
                                 )
                                 .duration_ms(Some(5000)),
@@ -632,7 +636,15 @@
                                     ),
                                 );
                                 if let Err(e) = ai::open_ai_window(cx) {
-                                    logging::log("ERROR", &format!("Failed to open AI: {}", e));
+                                    logging::log("ERROR", &ai_open_failure_message(e));
+                                    self.toast_manager.push(
+                                        components::toast::Toast::error(
+                                            ai_open_failure_message(e),
+                                            &self.theme,
+                                        )
+                                        .duration_ms(Some(5000)),
+                                    );
+                                    cx.notify();
                                 } else {
                                     // Set input with the screenshot context
                                     ai::set_ai_input_with_image(cx, &message, &base64_data, false);
@@ -675,7 +687,15 @@
                                     ),
                                 );
                                 if let Err(e) = ai::open_ai_window(cx) {
-                                    logging::log("ERROR", &format!("Failed to open AI: {}", e));
+                                    logging::log("ERROR", &ai_open_failure_message(e));
+                                    self.toast_manager.push(
+                                        components::toast::Toast::error(
+                                            ai_open_failure_message(e),
+                                            &self.theme,
+                                        )
+                                        .duration_ms(Some(5000)),
+                                    );
+                                    cx.notify();
                                 } else {
                                     ai::set_ai_input_with_image(cx, &message, &base64_data, false);
                                 }
@@ -707,7 +727,15 @@
                                     &format!("Selected text captured: {} chars", text.len()),
                                 );
                                 if let Err(e) = ai::open_ai_window(cx) {
-                                    logging::log("ERROR", &format!("Failed to open AI: {}", e));
+                                    logging::log("ERROR", &ai_open_failure_message(e));
+                                    self.toast_manager.push(
+                                        components::toast::Toast::error(
+                                            ai_open_failure_message(e),
+                                            &self.theme,
+                                        )
+                                        .duration_ms(Some(5000)),
+                                    );
+                                    cx.notify();
                                 } else {
                                     ai::set_ai_input(cx, &message, false);
                                 }
@@ -750,7 +778,15 @@
                                 );
                                 logging::log("EXEC", &format!("Browser URL captured: {}", url));
                                 if let Err(e) = ai::open_ai_window(cx) {
-                                    logging::log("ERROR", &format!("Failed to open AI: {}", e));
+                                    logging::log("ERROR", &ai_open_failure_message(e));
+                                    self.toast_manager.push(
+                                        components::toast::Toast::error(
+                                            ai_open_failure_message(e),
+                                            &self.theme,
+                                        )
+                                        .duration_ms(Some(5000)),
+                                    );
+                                    cx.notify();
                                 } else {
                                     ai::set_ai_input(cx, &message, false);
                                 }
@@ -794,7 +830,14 @@
                             .duration_ms(Some(3000)),
                         );
                         if let Err(e) = ai::open_ai_window(cx) {
-                            logging::log("ERROR", &format!("Failed to open AI: {}", e));
+                            logging::log("ERROR", &ai_open_failure_message(e));
+                            self.toast_manager.push(
+                                components::toast::Toast::error(
+                                    ai_open_failure_message(e),
+                                    &self.theme,
+                                )
+                                .duration_ms(Some(5000)),
+                            );
                         }
                         cx.notify();
                     }
@@ -1170,3 +1213,16 @@
         }
     }
 }
+
+#[cfg(test)]
+mod builtin_execution_ai_feedback_tests {
+    use super::ai_open_failure_message;
+
+    #[test]
+    fn test_ai_open_failure_message_includes_error_details() {
+        assert_eq!(
+            ai_open_failure_message("window init failed"),
+            "Failed to open AI: window init failed"
+        );
+    }
+}
diff --git a/src/app_impl/execution_scripts.rs b/src/app_impl/execution_scripts.rs
index ac99cc20952af2f8c39e301b7740e55cec8f394e..d870c647daaa9030713a2e74635d580b8dda93c4
--- a/src/app_impl/execution_scripts.rs
+++ b/src/app_impl/execution_scripts.rs
@@ -1,5 +1,40 @@
 use super::*;
 
+const NO_MAIN_WINDOW_BUILTINS: &[&str] = &[
+    "builtin-ai-chat",
+    "builtin-open-ai",
+    "builtin-notes",
+    "builtin-open-notes",
+    "builtin-new-note",
+    "builtin-search-notes",
+    "builtin-quick-capture",
+    "builtin-new-conversation",
+];
+
+fn builtin_needs_main_window_for_command_id(identifier: &str) -> bool {
+    !NO_MAIN_WINDOW_BUILTINS.contains(&identifier)
+}
+
+#[cfg(test)]
+mod builtin_command_window_visibility_tests {
+    use super::builtin_needs_main_window_for_command_id;
+
+    #[test]
+    fn test_builtin_needs_main_window_false_for_open_ai_and_open_notes() {
+        assert!(!builtin_needs_main_window_for_command_id("builtin-open-ai"));
+        assert!(!builtin_needs_main_window_for_command_id(
+            "builtin-open-notes"
+        ));
+    }
+
+    #[test]
+    fn test_builtin_needs_main_window_true_for_unlisted_builtin() {
+        assert!(builtin_needs_main_window_for_command_id(
+            "builtin-refresh-scripts"
+        ));
+    }
+}
+
 impl ScriptListApp {
     pub(crate) fn execute_scriptlet(&mut self, scriptlet: &scripts::Scriptlet, cx: &mut Context<Self>) {
         logging::log(
@@ -312,16 +347,6 @@
             "EXEC",
             &format!("Executing by command ID or path: {}", command_id),
         );
-
-        // Builtins that open their own windows and don't need main window
-        const NO_MAIN_WINDOW_BUILTINS: &[&str] = &[
-            "builtin-ai-chat",
-            "builtin-notes",
-            "builtin-new-note",
-            "builtin-search-notes",
-            "builtin-quick-capture",
-            "builtin-new-conversation",
-        ];
 
         // Parse command ID format: "type/identifier"
         if let Some((cmd_type, identifier)) = command_id.split_once('/') {
@@ -352,7 +377,8 @@
                         logging::log("EXEC", &format!("Executing builtin: {}", identifier));
                         self.execute_builtin(entry, cx);
                         // Check if this builtin opens its own window
-                        let needs_main_window = !NO_MAIN_WINDOW_BUILTINS.contains(&identifier);
+                        let needs_main_window =
+                            builtin_needs_main_window_for_command_id(identifier);
                         logging::log(
                             "EXEC",
                             &format!(


thinking
**Fixing error value move by using references**
exec
/bin/zsh -lc "sed -i '' 's/ai_open_failure_message(e)/ai_open_failure_message(\\&e)/g' src/app_execute/builtin_execution.rs && rg -n \"ai_open_failure_message\\(\" src/app_execute/builtin_execution.rs" in /Users/johnlindquist/dev/script-kit-gpui succeeded in 51ms:
1:fn ai_open_failure_message(error: impl std::fmt::Display) -> String {
293:                                        ai_open_failure_message(&e),
559:                                    ai_open_failure_message(&e),
639:                                    logging::log("ERROR", &ai_open_failure_message(&e));
642:                                            ai_open_failure_message(&e),
690:                                    logging::log("ERROR", &ai_open_failure_message(&e));
693:                                            ai_open_failure_message(&e),
730:                                    logging::log("ERROR", &ai_open_failure_message(&e));
733:                                            ai_open_failure_message(&e),
781:                                    logging::log("ERROR", &ai_open_failure_message(&e));
784:                                            ai_open_failure_message(&e),
833:                            logging::log("ERROR", &ai_open_failure_message(&e));
836:                                    ai_open_failure_message(&e),
1224:            ai_open_failure_message("window init failed"),
file update:
diff --git a/src/app_execute/builtin_execution.rs b/src/app_execute/builtin_execution.rs
index ea07c5b2c4e5ef82ea1337d249f517425db711fa..1b9154a32957bc59ee518ecc530a5c1d5b7a354d
--- a/src/app_execute/builtin_execution.rs
+++ b/src/app_execute/builtin_execution.rs
@@ -1,3 +1,7 @@
+fn ai_open_failure_message(error: impl std::fmt::Display) -> String {
+    format!("Failed to open AI: {}", error)
+}
+
 impl ScriptListApp {
     fn system_action_feedback_message(
         &self,
@@ -286,7 +290,7 @@
                             let _ = this.update(cx, |this, cx| {
                                 this.toast_manager.push(
                                     components::toast::Toast::error(
-                                        format!("Failed to open AI: {}", e),
+                                        ai_open_failure_message(&e),
                                         &this.theme,
                                     )
                                     .duration_ms(Some(5000)),
@@ -552,7 +556,7 @@
                             logging::log("ERROR", &format!("AI command failed: {}", e));
                             self.toast_manager.push(
                                 components::toast::Toast::error(
-                                    format!("Failed to open AI: {}", e),
+                                    ai_open_failure_message(&e),
                                     &self.theme,
                                 )
                                 .duration_ms(Some(5000)),
@@ -632,7 +636,15 @@
                                     ),
                                 );
                                 if let Err(e) = ai::open_ai_window(cx) {
-                                    logging::log("ERROR", &format!("Failed to open AI: {}", e));
+                                    logging::log("ERROR", &ai_open_failure_message(&e));
+                                    self.toast_manager.push(
+                                        components::toast::Toast::error(
+                                            ai_open_failure_message(&e),
+                                            &self.theme,
+                                        )
+                                        .duration_ms(Some(5000)),
+                                    );
+                                    cx.notify();
                                 } else {
                                     // Set input with the screenshot context
                                     ai::set_ai_input_with_image(cx, &message, &base64_data, false);
@@ -675,7 +687,15 @@
                                     ),
                                 );
                                 if let Err(e) = ai::open_ai_window(cx) {
-                                    logging::log("ERROR", &format!("Failed to open AI: {}", e));
+                                    logging::log("ERROR", &ai_open_failure_message(&e));
+                                    self.toast_manager.push(
+                                        components::toast::Toast::error(
+                                            ai_open_failure_message(&e),
+                                            &self.theme,
+                                        )
+                                        .duration_ms(Some(5000)),
+                                    );
+                                    cx.notify();
                                 } else {
                                     ai::set_ai_input_with_image(cx, &message, &base64_data, false);
                                 }
@@ -707,7 +727,15 @@
                                     &format!("Selected text captured: {} chars", text.len()),
                                 );
                                 if let Err(e) = ai::open_ai_window(cx) {
-                                    logging::log("ERROR", &format!("Failed to open AI: {}", e));
+                                    logging::log("ERROR", &ai_open_failure_message(&e));
+                                    self.toast_manager.push(
+                                        components::toast::Toast::error(
+                                            ai_open_failure_message(&e),
+                                            &self.theme,
+                                        )
+                                        .duration_ms(Some(5000)),
+                                    );
+                                    cx.notify();
                                 } else {
                                     ai::set_ai_input(cx, &message, false);
                                 }
@@ -750,7 +778,15 @@
                                 );
                                 logging::log("EXEC", &format!("Browser URL captured: {}", url));
                                 if let Err(e) = ai::open_ai_window(cx) {
-                                    logging::log("ERROR", &format!("Failed to open AI: {}", e));
+                                    logging::log("ERROR", &ai_open_failure_message(&e));
+                                    self.toast_manager.push(
+                                        components::toast::Toast::error(
+                                            ai_open_failure_message(&e),
+                                            &self.theme,
+                                        )
+                                        .duration_ms(Some(5000)),
+                                    );
+                                    cx.notify();
                                 } else {
                                     ai::set_ai_input(cx, &message, false);
                                 }
@@ -794,7 +830,14 @@
                             .duration_ms(Some(3000)),
                         );
                         if let Err(e) = ai::open_ai_window(cx) {
-                            logging::log("ERROR", &format!("Failed to open AI: {}", e));
+                            logging::log("ERROR", &ai_open_failure_message(&e));
+                            self.toast_manager.push(
+                                components::toast::Toast::error(
+                                    ai_open_failure_message(&e),
+                                    &self.theme,
+                                )
+                                .duration_ms(Some(5000)),
+                            );
                         }
                         cx.notify();
                     }
@@ -1170,3 +1213,16 @@
         }
     }
 }
+
+#[cfg(test)]
+mod builtin_execution_ai_feedback_tests {
+    use super::ai_open_failure_message;
+
+    #[test]
+    fn test_ai_open_failure_message_includes_error_details() {
+        assert_eq!(
+            ai_open_failure_message("window init failed"),
+            "Failed to open AI: window init failed"
+        );
+    }
+}
diff --git a/src/app_impl/execution_scripts.rs b/src/app_impl/execution_scripts.rs
index ac99cc20952af2f8c39e301b7740e55cec8f394e..d870c647daaa9030713a2e74635d580b8dda93c4
--- a/src/app_impl/execution_scripts.rs
+++ b/src/app_impl/execution_scripts.rs
@@ -1,5 +1,40 @@
 use super::*;
 
+const NO_MAIN_WINDOW_BUILTINS: &[&str] = &[
+    "builtin-ai-chat",
+    "builtin-open-ai",
+    "builtin-notes",
+    "builtin-open-notes",
+    "builtin-new-note",
+    "builtin-search-notes",
+    "builtin-quick-capture",
+    "builtin-new-conversation",
+];
+
+fn builtin_needs_main_window_for_command_id(identifier: &str) -> bool {
+    !NO_MAIN_WINDOW_BUILTINS.contains(&identifier)
+}
+
+#[cfg(test)]
+mod builtin_command_window_visibility_tests {
+    use super::builtin_needs_main_window_for_command_id;
+
+    #[test]
+    fn test_builtin_needs_main_window_false_for_open_ai_and_open_notes() {
+        assert!(!builtin_needs_main_window_for_command_id("builtin-open-ai"));
+        assert!(!builtin_needs_main_window_for_command_id(
+            "builtin-open-notes"
+        ));
+    }
+
+    #[test]
+    fn test_builtin_needs_main_window_true_for_unlisted_builtin() {
+        assert!(builtin_needs_main_window_for_command_id(
+            "builtin-refresh-scripts"
+        ));
+    }
+}
+
 impl ScriptListApp {
     pub(crate) fn execute_scriptlet(&mut self, scriptlet: &scripts::Scriptlet, cx: &mut Context<Self>) {
         logging::log(
@@ -312,16 +347,6 @@
             "EXEC",
             &format!("Executing by command ID or path: {}", command_id),
         );
-
-        // Builtins that open their own windows and don't need main window
-        const NO_MAIN_WINDOW_BUILTINS: &[&str] = &[
-            "builtin-ai-chat",
-            "builtin-notes",
-            "builtin-new-note",
-            "builtin-search-notes",
-            "builtin-quick-capture",
-            "builtin-new-conversation",
-        ];
 
         // Parse command ID format: "type/identifier"
         if let Some((cmd_type, identifier)) = command_id.split_once('/') {
@@ -352,7 +377,8 @@
                         logging::log("EXEC", &format!("Executing builtin: {}", identifier));
                         self.execute_builtin(entry, cx);
                         // Check if this builtin opens its own window
-                        let needs_main_window = !NO_MAIN_WINDOW_BUILTINS.contains(&identifier);
+                        let needs_main_window =
+                            builtin_needs_main_window_for_command_id(identifier);
                         logging::log(
                             "EXEC",
                             &format!(


thinking
**Confirming type check results**
exec
/bin/zsh -lc 'cargo check -p script-kit-gpui' in /Users/johnlindquist/dev/script-kit-gpui exited 101 in 9.68s:
    Checking script-kit-gpui v0.1.0 (/Users/johnlindquist/dev/script-kit-gpui)
warning: glob import doesn't reexport anything with visibility `pub(in crate::prompts)` because no imported item is public enough
  --> src/prompts/div/mod.rs:32:16
   |
32 | pub(super) use inline::*;
   |                ^^^^^^^^^
   |
note: the most public imported item is `pub(self)`
  --> src/prompts/div/mod.rs:32:16
   |
32 | pub(super) use inline::*;
   |                ^^^^^^^^^
   = help: reduce the glob import's visibility or increase visibility of imported items
   = note: `#[warn(unused_imports)]` (part of `#[warn(unused)]`) on by default

warning: glob import doesn't reexport anything with visibility `pub(in crate::prompts)` because no imported item is public enough
  --> src/prompts/div/mod.rs:34:16
   |
34 | pub(super) use render_html::*;
   |                ^^^^^^^^^^^^^^
file update:
diff --git a/src/app_execute/builtin_execution.rs b/src/app_execute/builtin_execution.rs
index ea07c5b2c4e5ef82ea1337d249f517425db711fa..1b9154a32957bc59ee518ecc530a5c1d5b7a354d
--- a/src/app_execute/builtin_execution.rs
+++ b/src/app_execute/builtin_execution.rs
@@ -1,3 +1,7 @@
+fn ai_open_failure_message(error: impl std::fmt::Display) -> String {
+    format!("Failed to open AI: {}", error)
+}
+
 impl ScriptListApp {
     fn system_action_feedback_message(
         &self,
@@ -286,7 +290,7 @@
                             let _ = this.update(cx, |this, cx| {
                                 this.toast_manager.push(
                                     components::toast::Toast::error(
-                                        format!("Failed to open AI: {}", e),
+                                        ai_open_failure_message(&e),
                                         &this.theme,
                                     )
                                     .duration_ms(Some(5000)),
@@ -552,7 +556,7 @@
                             logging::log("ERROR", &format!("AI command failed: {}", e));
                             self.toast_manager.push(
                                 components::toast::Toast::error(
-                                    format!("Failed to open AI: {}", e),
+                                    ai_open_failure_message(&e),
                                     &self.theme,
                                 )
                                 .duration_ms(Some(5000)),
@@ -632,7 +636,15 @@
                                     ),
                                 );
                                 if let Err(e) = ai::open_ai_window(cx) {
-                                    logging::log("ERROR", &format!("Failed to open AI: {}", e));
+                                    logging::log("ERROR", &ai_open_failure_message(&e));
+                                    self.toast_manager.push(
+                                        components::toast::Toast::error(
+                                            ai_open_failure_message(&e),
+                                            &self.theme,
+                                        )
+                                        .duration_ms(Some(5000)),
+                                    );
+                                    cx.notify();
                                 } else {
                                     // Set input with the screenshot context
                                     ai::set_ai_input_with_image(cx, &message, &base64_data, false);
@@ -675,7 +687,15 @@
                                     ),
                                 );
                                 if let Err(e) = ai::open_ai_window(cx) {
-                                    logging::log("ERROR", &format!("Failed to open AI: {}", e));
+                                    logging::log("ERROR", &ai_open_failure_message(&e));
+                                    self.toast_manager.push(
+                                        components::toast::Toast::error(
+                                            ai_open_failure_message(&e),
+                                            &self.theme,
+                                        )
+                                        .duration_ms(Some(5000)),
+                                    );
+                                    cx.notify();
                                 } else {
                                     ai::set_ai_input_with_image(cx, &message, &base64_data, false);
                                 }
@@ -707,7 +727,15 @@
                                     &format!("Selected text captured: {} chars", text.len()),
                                 );
                                 if let Err(e) = ai::open_ai_window(cx) {
-                                    logging::log("ERROR", &format!("Failed to open AI: {}", e));
+                                    logging::log("ERROR", &ai_open_failure_message(&e));
+                                    self.toast_manager.push(
+                                        components::toast::Toast::error(
+                                            ai_open_failure_message(&e),
+                                            &self.theme,
+                                        )
+                                        .duration_ms(Some(5000)),
+                                    );
+                                    cx.notify();
                                 } else {
                                     ai::set_ai_input(cx, &message, false);
                                 }
@@ -750,7 +778,15 @@
                                 );
                                 logging::log("EXEC", &format!("Browser URL captured: {}", url));
                                 if let Err(e) = ai::open_ai_window(cx) {
-                                    logging::log("ERROR", &format!("Failed to open AI: {}", e));
+                                    logging::log("ERROR", &ai_open_failure_message(&e));
+                                    self.toast_manager.push(
+                                        components::toast::Toast::error(
+                                            ai_open_failure_message(&e),
+                                            &self.theme,
+                                        )
+                                        .duration_ms(Some(5000)),
+                                    );
+                                    cx.notify();
                                 } else {
                                     ai::set_ai_input(cx, &message, false);
                                 }
@@ -794,7 +830,14 @@
                             .duration_ms(Some(3000)),
                         );
                         if let Err(e) = ai::open_ai_window(cx) {
-                            logging::log("ERROR", &format!("Failed to open AI: {}", e));
+                            logging::log("ERROR", &ai_open_failure_message(&e));
+                            self.toast_manager.push(
+                                components::toast::Toast::error(
+                                    ai_open_failure_message(&e),
+                                    &self.theme,
+                                )
+                                .duration_ms(Some(5000)),
+                            );
                         }
                         cx.notify();
                     }
@@ -1170,3 +1213,16 @@
         }
     }
 }
+
+#[cfg(test)]
+mod builtin_execution_ai_feedback_tests {
+    use super::ai_open_failure_message;
+
+    #[test]
+    fn test_ai_open_failure_message_includes_error_details() {
+        assert_eq!(
+            ai_open_failure_message("window init failed"),
+            "Failed to open AI: window init failed"
+        );
+    }
+}
diff --git a/src/app_impl/execution_scripts.rs b/src/app_impl/execution_scripts.rs
index ac99cc20952af2f8c39e301b7740e55cec8f394e..d870c647daaa9030713a2e74635d580b8dda93c4
--- a/src/app_impl/execution_scripts.rs
+++ b/src/app_impl/execution_scripts.rs
@@ -1,5 +1,40 @@
 use super::*;
 
+const NO_MAIN_WINDOW_BUILTINS: &[&str] = &[
+    "builtin-ai-chat",
+    "builtin-open-ai",
+    "builtin-notes",
+    "builtin-open-notes",
+    "builtin-new-note",
+    "builtin-search-notes",
+    "builtin-quick-capture",
+    "builtin-new-conversation",
+];
+
+fn builtin_needs_main_window_for_command_id(identifier: &str) -> bool {
+    !NO_MAIN_WINDOW_BUILTINS.contains(&identifier)
+}
+
+#[cfg(test)]
+mod builtin_command_window_visibility_tests {
+    use super::builtin_needs_main_window_for_command_id;
+
+    #[test]
+    fn test_builtin_needs_main_window_false_for_open_ai_and_open_notes() {
+        assert!(!builtin_needs_main_window_for_command_id("builtin-open-ai"));
+        assert!(!builtin_needs_main_window_for_command_id(
+            "builtin-open-notes"
+        ));
+    }
+
+    #[test]
+    fn test_builtin_needs_main_window_true_for_unlisted_builtin() {
+        assert!(builtin_needs_main_window_for_command_id(
+            "builtin-refresh-scripts"
+        ));
+    }
+}
+
 impl ScriptListApp {
     pub(crate) fn execute_scriptlet(&mut self, scriptlet: &scripts::Scriptlet, cx: &mut Context<Self>) {
         logging::log(
@@ -312,16 +347,6 @@
             "EXEC",
             &format!("Executing by command ID or path: {}", command_id),
         );
-
-        // Builtins that open their own windows and don't need main window
-        const NO_MAIN_WINDOW_BUILTINS: &[&str] = &[
-            "builtin-ai-chat",
-            "builtin-notes",
-            "builtin-new-note",
-            "builtin-search-notes",
-            "builtin-quick-capture",
-            "builtin-new-conversation",
-        ];
 
         // Parse command ID format: "type/identifier"
         if let Some((cmd_type, identifier)) = command_id.split_once('/') {
@@ -352,7 +377,8 @@
                         logging::log("EXEC", &format!("Executing builtin: {}", identifier));
                         self.execute_builtin(entry, cx);
                         // Check if this builtin opens its own window
-                        let needs_main_window = !NO_MAIN_WINDOW_BUILTINS.contains(&identifier);
+                        let needs_main_window =
+                            builtin_needs_main_window_for_command_id(identifier);
                         logging::log(
                             "EXEC",
                             &format!(


thinking
**Rerunning lint checks**
exec
/bin/zsh -lc 'cargo clippy -p script-kit-gpui --all-targets -- -D warnings' in /Users/johnlindquist/dev/script-kit-gpui exited 101 in 18.30s:
    Checking script-kit-gpui v0.1.0 (/Users/johnlindquist/dev/script-kit-gpui)
error[E0761]: file for module `tests` found at both "src/protocol/message/tests.rs" and "src/protocol/message/tests/mod.rs"
  --> src/protocol/message/mod.rs:87:1
   |
87 | mod tests;
   | ^^^^^^^^^^
   |
   = help: delete or rename one of them to remove the ambiguity

error[E0761]: file for module `tests` found at both "src/designs/core/tests.rs" and "src/designs/core/tests/mod.rs"
 --> src/designs/core/part_04.rs:2:1
  |
2 | mod tests;
  | ^^^^^^^^^^
  |
  = help: delete or rename one of them to remove the ambiguity

error: glob import doesn't reexport anything with visibility `pub(in crate::prompts)` because no imported item is public enough
  --> src/prompts/div/mod.rs:32:16
   |
file update:
diff --git a/src/app_execute/builtin_execution.rs b/src/app_execute/builtin_execution.rs
index ea07c5b2c4e5ef82ea1337d249f517425db711fa..1b9154a32957bc59ee518ecc530a5c1d5b7a354d
--- a/src/app_execute/builtin_execution.rs
+++ b/src/app_execute/builtin_execution.rs
@@ -1,3 +1,7 @@
+fn ai_open_failure_message(error: impl std::fmt::Display) -> String {
+    format!("Failed to open AI: {}", error)
+}
+
 impl ScriptListApp {
     fn system_action_feedback_message(
         &self,
@@ -286,7 +290,7 @@
                             let _ = this.update(cx, |this, cx| {
                                 this.toast_manager.push(
                                     components::toast::Toast::error(
-                                        format!("Failed to open AI: {}", e),
+                                        ai_open_failure_message(&e),
                                         &this.theme,
                                     )
                                     .duration_ms(Some(5000)),
@@ -552,7 +556,7 @@
                             logging::log("ERROR", &format!("AI command failed: {}", e));
                             self.toast_manager.push(
                                 components::toast::Toast::error(
-                                    format!("Failed to open AI: {}", e),
+                                    ai_open_failure_message(&e),
                                     &self.theme,
                                 )
                                 .duration_ms(Some(5000)),
@@ -632,7 +636,15 @@
                                     ),
                                 );
                                 if let Err(e) = ai::open_ai_window(cx) {
-                                    logging::log("ERROR", &format!("Failed to open AI: {}", e));
+                                    logging::log("ERROR", &ai_open_failure_message(&e));
+                                    self.toast_manager.push(
+                                        components::toast::Toast::error(
+                                            ai_open_failure_message(&e),
+                                            &self.theme,
+                                        )
+                                        .duration_ms(Some(5000)),
+                                    );
+                                    cx.notify();
                                 } else {
                                     // Set input with the screenshot context
                                     ai::set_ai_input_with_image(cx, &message, &base64_data, false);
@@ -675,7 +687,15 @@
                                     ),
                                 );
                                 if let Err(e) = ai::open_ai_window(cx) {
-                                    logging::log("ERROR", &format!("Failed to open AI: {}", e));
+                                    logging::log("ERROR", &ai_open_failure_message(&e));
+                                    self.toast_manager.push(
+                                        components::toast::Toast::error(
+                                            ai_open_failure_message(&e),
+                                            &self.theme,
+                                        )
+                                        .duration_ms(Some(5000)),
+                                    );
+                                    cx.notify();
                                 } else {
                                     ai::set_ai_input_with_image(cx, &message, &base64_data, false);
                                 }
@@ -707,7 +727,15 @@
                                     &format!("Selected text captured: {} chars", text.len()),
                                 );
                                 if let Err(e) = ai::open_ai_window(cx) {
-                                    logging::log("ERROR", &format!("Failed to open AI: {}", e));
+                                    logging::log("ERROR", &ai_open_failure_message(&e));
+                                    self.toast_manager.push(
+                                        components::toast::Toast::error(
+                                            ai_open_failure_message(&e),
+                                            &self.theme,
+                                        )
+                                        .duration_ms(Some(5000)),
+                                    );
+                                    cx.notify();
                                 } else {
                                     ai::set_ai_input(cx, &message, false);
                                 }
@@ -750,7 +778,15 @@
                                 );
                                 logging::log("EXEC", &format!("Browser URL captured: {}", url));
                                 if let Err(e) = ai::open_ai_window(cx) {
-                                    logging::log("ERROR", &format!("Failed to open AI: {}", e));
+                                    logging::log("ERROR", &ai_open_failure_message(&e));
+                                    self.toast_manager.push(
+                                        components::toast::Toast::error(
+                                            ai_open_failure_message(&e),
+                                            &self.theme,
+                                        )
+                                        .duration_ms(Some(5000)),
+                                    );
+                                    cx.notify();
                                 } else {
                                     ai::set_ai_input(cx, &message, false);
                                 }
@@ -794,7 +830,14 @@
                             .duration_ms(Some(3000)),
                         );
                         if let Err(e) = ai::open_ai_window(cx) {
-                            logging::log("ERROR", &format!("Failed to open AI: {}", e));
+                            logging::log("ERROR", &ai_open_failure_message(&e));
+                            self.toast_manager.push(
+                                components::toast::Toast::error(
+                                    ai_open_failure_message(&e),
+                                    &self.theme,
+                                )
+                                .duration_ms(Some(5000)),
+                            );
                         }
                         cx.notify();
                     }
@@ -1170,3 +1213,16 @@
         }
     }
 }
+
+#[cfg(test)]
+mod builtin_execution_ai_feedback_tests {
+    use super::ai_open_failure_message;
+
+    #[test]
+    fn test_ai_open_failure_message_includes_error_details() {
+        assert_eq!(
+            ai_open_failure_message("window init failed"),
+            "Failed to open AI: window init failed"
+        );
+    }
+}
diff --git a/src/app_impl/execution_scripts.rs b/src/app_impl/execution_scripts.rs
index ac99cc20952af2f8c39e301b7740e55cec8f394e..d870c647daaa9030713a2e74635d580b8dda93c4
--- a/src/app_impl/execution_scripts.rs
+++ b/src/app_impl/execution_scripts.rs
@@ -1,5 +1,40 @@
 use super::*;
 
+const NO_MAIN_WINDOW_BUILTINS: &[&str] = &[
+    "builtin-ai-chat",
+    "builtin-open-ai",
+    "builtin-notes",
+    "builtin-open-notes",
+    "builtin-new-note",
+    "builtin-search-notes",
+    "builtin-quick-capture",
+    "builtin-new-conversation",
+];
+
+fn builtin_needs_main_window_for_command_id(identifier: &str) -> bool {
+    !NO_MAIN_WINDOW_BUILTINS.contains(&identifier)
+}
+
+#[cfg(test)]
+mod builtin_command_window_visibility_tests {
+    use super::builtin_needs_main_window_for_command_id;
+
+    #[test]
+    fn test_builtin_needs_main_window_false_for_open_ai_and_open_notes() {
+        assert!(!builtin_needs_main_window_for_command_id("builtin-open-ai"));
+        assert!(!builtin_needs_main_window_for_command_id(
+            "builtin-open-notes"
+        ));
+    }
+
+    #[test]
+    fn test_builtin_needs_main_window_true_for_unlisted_builtin() {
+        assert!(builtin_needs_main_window_for_command_id(
+            "builtin-refresh-scripts"
+        ));
+    }
+}
+
 impl ScriptListApp {
     pub(crate) fn execute_scriptlet(&mut self, scriptlet: &scripts::Scriptlet, cx: &mut Context<Self>) {
         logging::log(
@@ -312,16 +347,6 @@
             "EXEC",
             &format!("Executing by command ID or path: {}", command_id),
         );
-
-        // Builtins that open their own windows and don't need main window
-        const NO_MAIN_WINDOW_BUILTINS: &[&str] = &[
-            "builtin-ai-chat",
-            "builtin-notes",
-            "builtin-new-note",
-            "builtin-search-notes",
-            "builtin-quick-capture",
-            "builtin-new-conversation",
-        ];
 
         // Parse command ID format: "type/identifier"
         if let Some((cmd_type, identifier)) = command_id.split_once('/') {
@@ -352,7 +377,8 @@
                         logging::log("EXEC", &format!("Executing builtin: {}", identifier));
                         self.execute_builtin(entry, cx);
                         // Check if this builtin opens its own window
-                        let needs_main_window = !NO_MAIN_WINDOW_BUILTINS.contains(&identifier);
+                        let needs_main_window =
+                            builtin_needs_main_window_for_command_id(identifier);
                         logging::log(
                             "EXEC",
                             &format!(


thinking
**Updating swarm status as done despite unrelated verification failures**
exec
/bin/zsh -lc '~/.claude/bin/swarm.ts update --id codex-fix-ai-feedback --status done --notes "Implemented AI command failure toasts in builtin_execution.rs and added builtin-open-ai/builtin-open-notes no-main-window handling + unit tests; cargo check/clippy attempted but blocked by unrelated workspace compile errors in clipboard_history/actions tests" && ~/.claude/bin/swarm.ts release --id codex-fix-ai-feedback src/app_execute/builtin_execution.rs src/app_impl/execution_scripts.rs && ~/.claude/bin/swarm.ts status' in /Users/johnlindquist/dev/script-kit-gpui succeeded in 50ms:
Updated: codex-fix-ai-feedback
Released for codex-fix-ai-feedback: src/app_execute/builtin_execution.rs, src/app_impl/execution_scripts.rs
Repo: /Users/johnlindquist/dev/script-kit-gpui
Updated: 2026-02-07T23:46:21.592Z

Active agents (2):
codex-fix-editor-feedback [in_progress] codex/gpt-5.3-codex/exec
  task: MEDIUM FIX: edit_script / edit_scriptlet launch failures are log-only. In src/app_actions/handle_action.rs - if launchi‚Ä¶
  scope: src/app_actions/*.rs
  claims(1): src/app_actions/handle_action.rs
  notes: Claiming handle_action editor launch feedback flow; moving success HUD to async completion

codex-fix-notes-feedback [in_progress] codex/gpt-5.3-codex/exec
  task: MEDIUM FIX: Silent no-op paths when selected note is missing or stale. In src/notes/window/notes_actions.rs:94,101,121,‚Ä¶
  scope: src/notes/window/notes_actions.rs,src/notes/window/notes.rs,src/notes/window/panels.rs
  claims(3): src/notes/window/notes_actions.rs, src/notes/window/notes.rs, src/notes/window/panels.rs
  notes: Inspecting note actions for stale selected-note early returns; will add user feedback and run check+clippy.

Inactive agents (214):
- codex-accessibility [done] done. exit=0. final=.ai/logs/codex-accessibility.final.md. See final message file.
file update:
diff --git a/src/app_execute/builtin_execution.rs b/src/app_execute/builtin_execution.rs
index ea07c5b2c4e5ef82ea1337d249f517425db711fa..1b9154a32957bc59ee518ecc530a5c1d5b7a354d
--- a/src/app_execute/builtin_execution.rs
+++ b/src/app_execute/builtin_execution.rs
@@ -1,3 +1,7 @@
+fn ai_open_failure_message(error: impl std::fmt::Display) -> String {
+    format!("Failed to open AI: {}", error)
+}
+
 impl ScriptListApp {
     fn system_action_feedback_message(
         &self,
@@ -286,7 +290,7 @@
                             let _ = this.update(cx, |this, cx| {
                                 this.toast_manager.push(
                                     components::toast::Toast::error(
-                                        format!("Failed to open AI: {}", e),
+                                        ai_open_failure_message(&e),
                                         &this.theme,
                                     )
                                     .duration_ms(Some(5000)),
@@ -552,7 +556,7 @@
                             logging::log("ERROR", &format!("AI command failed: {}", e));
                             self.toast_manager.push(
                                 components::toast::Toast::error(
-                                    format!("Failed to open AI: {}", e),
+                                    ai_open_failure_message(&e),
                                     &self.theme,
                                 )
                                 .duration_ms(Some(5000)),
@@ -632,7 +636,15 @@
                                     ),
                                 );
                                 if let Err(e) = ai::open_ai_window(cx) {
-                                    logging::log("ERROR", &format!("Failed to open AI: {}", e));
+                                    logging::log("ERROR", &ai_open_failure_message(&e));
+                                    self.toast_manager.push(
+                                        components::toast::Toast::error(
+                                            ai_open_failure_message(&e),
+                                            &self.theme,
+                                        )
+                                        .duration_ms(Some(5000)),
+                                    );
+                                    cx.notify();
                                 } else {
                                     // Set input with the screenshot context
                                     ai::set_ai_input_with_image(cx, &message, &base64_data, false);
@@ -675,7 +687,15 @@
                                     ),
                                 );
                                 if let Err(e) = ai::open_ai_window(cx) {
-                                    logging::log("ERROR", &format!("Failed to open AI: {}", e));
+                                    logging::log("ERROR", &ai_open_failure_message(&e));
+                                    self.toast_manager.push(
+                                        components::toast::Toast::error(
+                                            ai_open_failure_message(&e),
+                                            &self.theme,
+                                        )
+                                        .duration_ms(Some(5000)),
+                                    );
+                                    cx.notify();
                                 } else {
                                     ai::set_ai_input_with_image(cx, &message, &base64_data, false);
                                 }
@@ -707,7 +727,15 @@
                                     &format!("Selected text captured: {} chars", text.len()),
                                 );
                                 if let Err(e) = ai::open_ai_window(cx) {
-                                    logging::log("ERROR", &format!("Failed to open AI: {}", e));
+                                    logging::log("ERROR", &ai_open_failure_message(&e));
+                                    self.toast_manager.push(
+                                        components::toast::Toast::error(
+                                            ai_open_failure_message(&e),
+                                            &self.theme,
+                                        )
+                                        .duration_ms(Some(5000)),
+                                    );
+                                    cx.notify();
                                 } else {
                                     ai::set_ai_input(cx, &message, false);
                                 }
@@ -750,7 +778,15 @@
                                 );
                                 logging::log("EXEC", &format!("Browser URL captured: {}", url));
                                 if let Err(e) = ai::open_ai_window(cx) {
-                                    logging::log("ERROR", &format!("Failed to open AI: {}", e));
+                                    logging::log("ERROR", &ai_open_failure_message(&e));
+                                    self.toast_manager.push(
+                                        components::toast::Toast::error(
+                                            ai_open_failure_message(&e),
+                                            &self.theme,
+                                        )
+                                        .duration_ms(Some(5000)),
+                                    );
+                                    cx.notify();
                                 } else {
                                     ai::set_ai_input(cx, &message, false);
                                 }
@@ -794,7 +830,14 @@
                             .duration_ms(Some(3000)),
                         );
                         if let Err(e) = ai::open_ai_window(cx) {
-                            logging::log("ERROR", &format!("Failed to open AI: {}", e));
+                            logging::log("ERROR", &ai_open_failure_message(&e));
+                            self.toast_manager.push(
+                                components::toast::Toast::error(
+                                    ai_open_failure_message(&e),
+                                    &self.theme,
+                                )
+                                .duration_ms(Some(5000)),
+                            );
                         }
                         cx.notify();
                     }
@@ -1170,3 +1213,16 @@
         }
     }
 }
+
+#[cfg(test)]
+mod builtin_execution_ai_feedback_tests {
+    use super::ai_open_failure_message;
+
+    #[test]
+    fn test_ai_open_failure_message_includes_error_details() {
+        assert_eq!(
+            ai_open_failure_message("window init failed"),
+            "Failed to open AI: window init failed"
+        );
+    }
+}
diff --git a/src/app_impl/execution_scripts.rs b/src/app_impl/execution_scripts.rs
index ac99cc20952af2f8c39e301b7740e55cec8f394e..d870c647daaa9030713a2e74635d580b8dda93c4
--- a/src/app_impl/execution_scripts.rs
+++ b/src/app_impl/execution_scripts.rs
@@ -1,5 +1,40 @@
 use super::*;
 
+const NO_MAIN_WINDOW_BUILTINS: &[&str] = &[
+    "builtin-ai-chat",
+    "builtin-open-ai",
+    "builtin-notes",
+    "builtin-open-notes",
+    "builtin-new-note",
+    "builtin-search-notes",
+    "builtin-quick-capture",
+    "builtin-new-conversation",
+];
+
+fn builtin_needs_main_window_for_command_id(identifier: &str) -> bool {
+    !NO_MAIN_WINDOW_BUILTINS.contains(&identifier)
+}
+
+#[cfg(test)]
+mod builtin_command_window_visibility_tests {
+    use super::builtin_needs_main_window_for_command_id;
+
+    #[test]
+    fn test_builtin_needs_main_window_false_for_open_ai_and_open_notes() {
+        assert!(!builtin_needs_main_window_for_command_id("builtin-open-ai"));
+        assert!(!builtin_needs_main_window_for_command_id(
+            "builtin-open-notes"
+        ));
+    }
+
+    #[test]
+    fn test_builtin_needs_main_window_true_for_unlisted_builtin() {
+        assert!(builtin_needs_main_window_for_command_id(
+            "builtin-refresh-scripts"
+        ));
+    }
+}
+
 impl ScriptListApp {
     pub(crate) fn execute_scriptlet(&mut self, scriptlet: &scripts::Scriptlet, cx: &mut Context<Self>) {
         logging::log(
@@ -312,16 +347,6 @@
             "EXEC",
             &format!("Executing by command ID or path: {}", command_id),
         );
-
-        // Builtins that open their own windows and don't need main window
-        const NO_MAIN_WINDOW_BUILTINS: &[&str] = &[
-            "builtin-ai-chat",
-            "builtin-notes",
-            "builtin-new-note",
-            "builtin-search-notes",
-            "builtin-quick-capture",
-            "builtin-new-conversation",
-        ];
 
         // Parse command ID format: "type/identifier"
         if let Some((cmd_type, identifier)) = command_id.split_once('/') {
@@ -352,7 +377,8 @@
                         logging::log("EXEC", &format!("Executing builtin: {}", identifier));
                         self.execute_builtin(entry, cx);
                         // Check if this builtin opens its own window
-                        let needs_main_window = !NO_MAIN_WINDOW_BUILTINS.contains(&identifier);
+                        let needs_main_window =
+                            builtin_needs_main_window_for_command_id(identifier);
                         logging::log(
                             "EXEC",
                             &format!(


thinking
**Planning final summary details**
exec
/bin/zsh -lc 'rg -n "fn ai_open_failure_message|AiCommandType::SendScreenToAi|AiCommandType::SendFocusedWindowToAi|AiCommandType::SendSelectedTextToAi|AiCommandType::SendBrowserTabToAi|AiCommandType::CreateAiPreset|builtin_execution_ai_feedback_tests|NO_MAIN_WINDOW_BUILTINS|builtin_needs_main_window_for_command_id|builtin_command_window_visibility_tests|needs_main_window =" src/app_execute/builtin_execution.rs src/app_impl/execution_scripts.rs' in /Users/johnlindquist/dev/script-kit-gpui succeeded in 51ms:
src/app_impl/execution_scripts.rs:3:const NO_MAIN_WINDOW_BUILTINS: &[&str] = &[
src/app_impl/execution_scripts.rs:14:fn builtin_needs_main_window_for_command_id(identifier: &str) -> bool {
src/app_impl/execution_scripts.rs:15:    !NO_MAIN_WINDOW_BUILTINS.contains(&identifier)
src/app_impl/execution_scripts.rs:19:mod builtin_command_window_visibility_tests {
src/app_impl/execution_scripts.rs:20:    use super::builtin_needs_main_window_for_command_id;
src/app_impl/execution_scripts.rs:24:        assert!(!builtin_needs_main_window_for_command_id("builtin-open-ai"));
src/app_impl/execution_scripts.rs:25:        assert!(!builtin_needs_main_window_for_command_id(
src/app_impl/execution_scripts.rs:32:        assert!(builtin_needs_main_window_for_command_id(
src/app_impl/execution_scripts.rs:380:                        let needs_main_window =
src/app_impl/execution_scripts.rs:381:                            builtin_needs_main_window_for_command_id(identifier);
src/app_execute/builtin_execution.rs:1:fn ai_open_failure_message(error: impl std::fmt::Display) -> String {
src/app_execute/builtin_execution.rs:617:                    AiCommandType::SendScreenToAi => {
src/app_execute/builtin_execution.rs:667:                    AiCommandType::SendFocusedWindowToAi => {
src/app_execute/builtin_execution.rs:717:                    AiCommandType::SendSelectedTextToAi => {
src/app_execute/builtin_execution.rs:771:                    AiCommandType::SendBrowserTabToAi => {
src/app_execute/builtin_execution.rs:821:                    AiCommandType::CreateAiPreset
src/app_execute/builtin_execution.rs:1218:mod builtin_execution_ai_feedback_tests {
file update:
diff --git a/src/app_execute/builtin_execution.rs b/src/app_execute/builtin_execution.rs
index ea07c5b2c4e5ef82ea1337d249f517425db711fa..1b9154a32957bc59ee518ecc530a5c1d5b7a354d
--- a/src/app_execute/builtin_execution.rs
+++ b/src/app_execute/builtin_execution.rs
@@ -1,3 +1,7 @@
+fn ai_open_failure_message(error: impl std::fmt::Display) -> String {
+    format!("Failed to open AI: {}", error)
+}
+
 impl ScriptListApp {
     fn system_action_feedback_message(
         &self,
@@ -286,7 +290,7 @@
                             let _ = this.update(cx, |this, cx| {
                                 this.toast_manager.push(
                                     components::toast::Toast::error(
-                                        format!("Failed to open AI: {}", e),
+                                        ai_open_failure_message(&e),
                                         &this.theme,
                                     )
                                     .duration_ms(Some(5000)),
@@ -552,7 +556,7 @@
                             logging::log("ERROR", &format!("AI command failed: {}", e));
                             self.toast_manager.push(
                                 components::toast::Toast::error(
-                                    format!("Failed to open AI: {}", e),
+                                    ai_open_failure_message(&e),
                                     &self.theme,
                                 )
                                 .duration_ms(Some(5000)),
@@ -632,7 +636,15 @@
                                     ),
                                 );
                                 if let Err(e) = ai::open_ai_window(cx) {
-                                    logging::log("ERROR", &format!("Failed to open AI: {}", e));
+                                    logging::log("ERROR", &ai_open_failure_message(&e));
+                                    self.toast_manager.push(
+                                        components::toast::Toast::error(
+                                            ai_open_failure_message(&e),
+                                            &self.theme,
+                                        )
+                                        .duration_ms(Some(5000)),
+                                    );
+                                    cx.notify();
                                 } else {
                                     // Set input with the screenshot context
                                     ai::set_ai_input_with_image(cx, &message, &base64_data, false);
@@ -675,7 +687,15 @@
                                     ),
                                 );
                                 if let Err(e) = ai::open_ai_window(cx) {
-                                    logging::log("ERROR", &format!("Failed to open AI: {}", e));
+                                    logging::log("ERROR", &ai_open_failure_message(&e));
+                                    self.toast_manager.push(
+                                        components::toast::Toast::error(
+                                            ai_open_failure_message(&e),
+                                            &self.theme,
+                                        )
+                                        .duration_ms(Some(5000)),
+                                    );
+                                    cx.notify();
                                 } else {
                                     ai::set_ai_input_with_image(cx, &message, &base64_data, false);
                                 }
@@ -707,7 +727,15 @@
                                     &format!("Selected text captured: {} chars", text.len()),
                                 );
                                 if let Err(e) = ai::open_ai_window(cx) {
-                                    logging::log("ERROR", &format!("Failed to open AI: {}", e));
+                                    logging::log("ERROR", &ai_open_failure_message(&e));
+                                    self.toast_manager.push(
+                                        components::toast::Toast::error(
+                                            ai_open_failure_message(&e),
+                                            &self.theme,
+                                        )
+                                        .duration_ms(Some(5000)),
+                                    );
+                                    cx.notify();
                                 } else {
                                     ai::set_ai_input(cx, &message, false);
                                 }
@@ -750,7 +778,15 @@
                                 );
                                 logging::log("EXEC", &format!("Browser URL captured: {}", url));
                                 if let Err(e) = ai::open_ai_window(cx) {
-                                    logging::log("ERROR", &format!("Failed to open AI: {}", e));
+                                    logging::log("ERROR", &ai_open_failure_message(&e));
+                                    self.toast_manager.push(
+                                        components::toast::Toast::error(
+                                            ai_open_failure_message(&e),
+                                            &self.theme,
+                                        )
+                                        .duration_ms(Some(5000)),
+                                    );
+                                    cx.notify();
                                 } else {
                                     ai::set_ai_input(cx, &message, false);
                                 }
@@ -794,7 +830,14 @@
                             .duration_ms(Some(3000)),
                         );
                         if let Err(e) = ai::open_ai_window(cx) {
-                            logging::log("ERROR", &format!("Failed to open AI: {}", e));
+                            logging::log("ERROR", &ai_open_failure_message(&e));
+                            self.toast_manager.push(
+                                components::toast::Toast::error(
+                                    ai_open_failure_message(&e),
+                                    &self.theme,
+                                )
+                                .duration_ms(Some(5000)),
+                            );
                         }
                         cx.notify();
                     }
@@ -1170,3 +1213,16 @@
         }
     }
 }
+
+#[cfg(test)]
+mod builtin_execution_ai_feedback_tests {
+    use super::ai_open_failure_message;
+
+    #[test]
+    fn test_ai_open_failure_message_includes_error_details() {
+        assert_eq!(
+            ai_open_failure_message("window init failed"),
+            "Failed to open AI: window init failed"
+        );
+    }
+}
diff --git a/src/app_impl/execution_scripts.rs b/src/app_impl/execution_scripts.rs
index ac99cc20952af2f8c39e301b7740e55cec8f394e..d870c647daaa9030713a2e74635d580b8dda93c4
--- a/src/app_impl/execution_scripts.rs
+++ b/src/app_impl/execution_scripts.rs
@@ -1,5 +1,40 @@
 use super::*;
 
+const NO_MAIN_WINDOW_BUILTINS: &[&str] = &[
+    "builtin-ai-chat",
+    "builtin-open-ai",
+    "builtin-notes",
+    "builtin-open-notes",
+    "builtin-new-note",
+    "builtin-search-notes",
+    "builtin-quick-capture",
+    "builtin-new-conversation",
+];
+
+fn builtin_needs_main_window_for_command_id(identifier: &str) -> bool {
+    !NO_MAIN_WINDOW_BUILTINS.contains(&identifier)
+}
+
+#[cfg(test)]
+mod builtin_command_window_visibility_tests {
+    use super::builtin_needs_main_window_for_command_id;
+
+    #[test]
+    fn test_builtin_needs_main_window_false_for_open_ai_and_open_notes() {
+        assert!(!builtin_needs_main_window_for_command_id("builtin-open-ai"));
+        assert!(!builtin_needs_main_window_for_command_id(
+            "builtin-open-notes"
+        ));
+    }
+
+    #[test]
+    fn test_builtin_needs_main_window_true_for_unlisted_builtin() {
+        assert!(builtin_needs_main_window_for_command_id(
+            "builtin-refresh-scripts"
+        ));
+    }
+}
+
 impl ScriptListApp {
     pub(crate) fn execute_scriptlet(&mut self, scriptlet: &scripts::Scriptlet, cx: &mut Context<Self>) {
         logging::log(
@@ -312,16 +347,6 @@
             "EXEC",
             &format!("Executing by command ID or path: {}", command_id),
         );
-
-        // Builtins that open their own windows and don't need main window
-        const NO_MAIN_WINDOW_BUILTINS: &[&str] = &[
-            "builtin-ai-chat",
-            "builtin-notes",
-            "builtin-new-note",
-            "builtin-search-notes",
-            "builtin-quick-capture",
-            "builtin-new-conversation",
-        ];
 
         // Parse command ID format: "type/identifier"
         if let Some((cmd_type, identifier)) = command_id.split_once('/') {
@@ -352,7 +377,8 @@
                         logging::log("EXEC", &format!("Executing builtin: {}", identifier));
                         self.execute_builtin(entry, cx);
                         // Check if this builtin opens its own window
-                        let needs_main_window = !NO_MAIN_WINDOW_BUILTINS.contains(&identifier);
+                        let needs_main_window =
+                            builtin_needs_main_window_for_command_id(identifier);
                         logging::log(
                             "EXEC",
                             &format!(


thinking
**Checking modified files**
exec
/bin/zsh -lc 'git status --short src/app_execute/builtin_execution.rs src/app_impl/execution_scripts.rs' in /Users/johnlindquist/dev/script-kit-gpui succeeded in 51ms:
 M src/app_execute/builtin_execution.rs
 M src/app_impl/execution_scripts.rs
file update:
diff --git a/src/app_execute/builtin_execution.rs b/src/app_execute/builtin_execution.rs
index ea07c5b2c4e5ef82ea1337d249f517425db711fa..1b9154a32957bc59ee518ecc530a5c1d5b7a354d
--- a/src/app_execute/builtin_execution.rs
+++ b/src/app_execute/builtin_execution.rs
@@ -1,3 +1,7 @@
+fn ai_open_failure_message(error: impl std::fmt::Display) -> String {
+    format!("Failed to open AI: {}", error)
+}
+
 impl ScriptListApp {
     fn system_action_feedback_message(
         &self,
@@ -286,7 +290,7 @@
                             let _ = this.update(cx, |this, cx| {
                                 this.toast_manager.push(
                                     components::toast::Toast::error(
-                                        format!("Failed to open AI: {}", e),
+                                        ai_open_failure_message(&e),
                                         &this.theme,
                                     )
                                     .duration_ms(Some(5000)),
@@ -552,7 +556,7 @@
                             logging::log("ERROR", &format!("AI command failed: {}", e));
                             self.toast_manager.push(
                                 components::toast::Toast::error(
-                                    format!("Failed to open AI: {}", e),
+                                    ai_open_failure_message(&e),
                                     &self.theme,
                                 )
                                 .duration_ms(Some(5000)),
@@ -632,7 +636,15 @@
                                     ),
                                 );
                                 if let Err(e) = ai::open_ai_window(cx) {
-                                    logging::log("ERROR", &format!("Failed to open AI: {}", e));
+                                    logging::log("ERROR", &ai_open_failure_message(&e));
+                                    self.toast_manager.push(
+                                        components::toast::Toast::error(
+                                            ai_open_failure_message(&e),
+                                            &self.theme,
+                                        )
+                                        .duration_ms(Some(5000)),
+                                    );
+                                    cx.notify();
                                 } else {
                                     // Set input with the screenshot context
                                     ai::set_ai_input_with_image(cx, &message, &base64_data, false);
@@ -675,7 +687,15 @@
                                     ),
                                 );
                                 if let Err(e) = ai::open_ai_window(cx) {
-                                    logging::log("ERROR", &format!("Failed to open AI: {}", e));
+                                    logging::log("ERROR", &ai_open_failure_message(&e));
+                                    self.toast_manager.push(
+                                        components::toast::Toast::error(
+                                            ai_open_failure_message(&e),
+                                            &self.theme,
+                                        )
+                                        .duration_ms(Some(5000)),
+                                    );
+                                    cx.notify();
                                 } else {
                                     ai::set_ai_input_with_image(cx, &message, &base64_data, false);
                                 }
@@ -707,7 +727,15 @@
                                     &format!("Selected text captured: {} chars", text.len()),
                                 );
                                 if let Err(e) = ai::open_ai_window(cx) {
-                                    logging::log("ERROR", &format!("Failed to open AI: {}", e));
+                                    logging::log("ERROR", &ai_open_failure_message(&e));
+                                    self.toast_manager.push(
+                                        components::toast::Toast::error(
+                                            ai_open_failure_message(&e),
+                                            &self.theme,
+                                        )
+                                        .duration_ms(Some(5000)),
+                                    );
+                                    cx.notify();
                                 } else {
                                     ai::set_ai_input(cx, &message, false);
                                 }
@@ -750,7 +778,15 @@
                                 );
                                 logging::log("EXEC", &format!("Browser URL captured: {}", url));
                                 if let Err(e) = ai::open_ai_window(cx) {
-                                    logging::log("ERROR", &format!("Failed to open AI: {}", e));
+                                    logging::log("ERROR", &ai_open_failure_message(&e));
+                                    self.toast_manager.push(
+                                        components::toast::Toast::error(
+                                            ai_open_failure_message(&e),
+                                            &self.theme,
+                                        )
+                                        .duration_ms(Some(5000)),
+                                    );
+                                    cx.notify();
                                 } else {
                                     ai::set_ai_input(cx, &message, false);
                                 }
@@ -794,7 +830,14 @@
                             .duration_ms(Some(3000)),
                         );
                         if let Err(e) = ai::open_ai_window(cx) {
-                            logging::log("ERROR", &format!("Failed to open AI: {}", e));
+                            logging::log("ERROR", &ai_open_failure_message(&e));
+                            self.toast_manager.push(
+                                components::toast::Toast::error(
+                                    ai_open_failure_message(&e),
+                                    &self.theme,
+                                )
+                                .duration_ms(Some(5000)),
+                            );
                         }
                         cx.notify();
                     }
@@ -1170,3 +1213,16 @@
         }
     }
 }
+
+#[cfg(test)]
+mod builtin_execution_ai_feedback_tests {
+    use super::ai_open_failure_message;
+
+    #[test]
+    fn test_ai_open_failure_message_includes_error_details() {
+        assert_eq!(
+            ai_open_failure_message("window init failed"),
+            "Failed to open AI: window init failed"
+        );
+    }
+}
diff --git a/src/app_impl/execution_scripts.rs b/src/app_impl/execution_scripts.rs
index ac99cc20952af2f8c39e301b7740e55cec8f394e..d870c647daaa9030713a2e74635d580b8dda93c4
--- a/src/app_impl/execution_scripts.rs
+++ b/src/app_impl/execution_scripts.rs
@@ -1,5 +1,40 @@
 use super::*;
 
+const NO_MAIN_WINDOW_BUILTINS: &[&str] = &[
+    "builtin-ai-chat",
+    "builtin-open-ai",
+    "builtin-notes",
+    "builtin-open-notes",
+    "builtin-new-note",
+    "builtin-search-notes",
+    "builtin-quick-capture",
+    "builtin-new-conversation",
+];
+
+fn builtin_needs_main_window_for_command_id(identifier: &str) -> bool {
+    !NO_MAIN_WINDOW_BUILTINS.contains(&identifier)
+}
+
+#[cfg(test)]
+mod builtin_command_window_visibility_tests {
+    use super::builtin_needs_main_window_for_command_id;
+
+    #[test]
+    fn test_builtin_needs_main_window_false_for_open_ai_and_open_notes() {
+        assert!(!builtin_needs_main_window_for_command_id("builtin-open-ai"));
+        assert!(!builtin_needs_main_window_for_command_id(
+            "builtin-open-notes"
+        ));
+    }
+
+    #[test]
+    fn test_builtin_needs_main_window_true_for_unlisted_builtin() {
+        assert!(builtin_needs_main_window_for_command_id(
+            "builtin-refresh-scripts"
+        ));
+    }
+}
+
 impl ScriptListApp {
     pub(crate) fn execute_scriptlet(&mut self, scriptlet: &scripts::Scriptlet, cx: &mut Context<Self>) {
         logging::log(
@@ -312,16 +347,6 @@
             "EXEC",
             &format!("Executing by command ID or path: {}", command_id),
         );
-
-        // Builtins that open their own windows and don't need main window
-        const NO_MAIN_WINDOW_BUILTINS: &[&str] = &[
-            "builtin-ai-chat",
-            "builtin-notes",
-            "builtin-new-note",
-            "builtin-search-notes",
-            "builtin-quick-capture",
-            "builtin-new-conversation",
-        ];
 
         // Parse command ID format: "type/identifier"
         if let Some((cmd_type, identifier)) = command_id.split_once('/') {
@@ -352,7 +377,8 @@
                         logging::log("EXEC", &format!("Executing builtin: {}", identifier));
                         self.execute_builtin(entry, cx);
                         // Check if this builtin opens its own window
-                        let needs_main_window = !NO_MAIN_WINDOW_BUILTINS.contains(&identifier);
+                        let needs_main_window =
+                            builtin_needs_main_window_for_command_id(identifier);
                         logging::log(
                             "EXEC",
                             &format!(


thinking
**Summarizing final deliverables and blockers**
codex
Implemented the requested fixes in the two scoped files.

**Changed files**
1. `src/app_execute/builtin_execution.rs`
- Added user-visible error toasts for AI window-open failures in the previously log-only AI command paths:
  - `AiCommandType::SendScreenToAi` at `src/app_execute/builtin_execution.rs:617`
  - `AiCommandType::SendFocusedWindowToAi` at `src/app_execute/builtin_execution.rs:667`
  - `AiCommandType::SendSelectedTextToAi` at `src/app_execute/builtin_execution.rs:717`
  - `AiCommandType::SendBrowserTabToAi` at `src/app_execute/builtin_execution.rs:771`
  - `AiCommandType::CreateAiPreset | ImportAiPresets | SearchAiPresets` at `src/app_execute/builtin_execution.rs:821`
- Added helper `ai_open_failure_message(...)` at `src/app_execute/builtin_execution.rs:1`.
- Added unit test module `builtin_execution_ai_feedback_tests` at `src/app_execute/builtin_execution.rs:1218`.

2. `src/app_impl/execution_scripts.rs`
- Added `builtin-open-ai` and `builtin-open-notes` to no-main-window handling via:
  - `NO_MAIN_WINDOW_BUILTINS` at `src/app_impl/execution_scripts.rs:3`
  - `builtin_needs_main_window_for_command_id(...)` at `src/app_impl/execution_scripts.rs:14`
  - call site update in `execute_by_command_id_or_path` at `src/app_impl/execution_scripts.rs:380`
- Added unit test module `builtin_command_window_visibility_tests` at `src/app_impl/execution_scripts.rs:19`.

**How to test**
1. Requested verification commands (run, currently failing due unrelated parallel changes):
- `cargo check -p script-kit-gpui`
- `cargo clippy -p script-kit-gpui --all-targets -- -D warnings`

2. Targeted unit test filters for this change:
- `cargo test -p script-kit-gpui --bin script-kit-gpui builtin_execution_ai_feedback_tests`
- `cargo test -p script-kit-gpui --bin script-kit-gpui builtin_command_window_visibility_tests`

**Verification status**
- I ran:
  - `cargo check -p script-kit-gpui`
  - `cargo clippy -p script-kit-gpui --all-targets -- -D warnings`
  - targeted `cargo test` filters
- All were blocked by unrelated workspace errors outside this task scope (examples):
  - duplicate `mod tests` resolution conflicts in `src/protocol/message/mod.rs` and `src/designs/core/part_04.rs`
  - clipboard model/match errors in `src/clipboard_history/*` (missing `source_app_*` fields, non-exhaustive `ContentType` matches)
  - unrelated actions test/import failures in `src/actions/*`

**Risks / known gaps**
1. Runtime validation is limited because workspace compilation is currently broken outside these files.
2. The added unit tests are in place but cannot execute until the unrelated compile errors are resolved.

Commits made: none.
file update:
diff --git a/src/app_execute/builtin_execution.rs b/src/app_execute/builtin_execution.rs
index ea07c5b2c4e5ef82ea1337d249f517425db711fa..1b9154a32957bc59ee518ecc530a5c1d5b7a354d
--- a/src/app_execute/builtin_execution.rs
+++ b/src/app_execute/builtin_execution.rs
@@ -1,3 +1,7 @@
+fn ai_open_failure_message(error: impl std::fmt::Display) -> String {
+    format!("Failed to open AI: {}", error)
+}
+
 impl ScriptListApp {
     fn system_action_feedback_message(
         &self,
@@ -286,7 +290,7 @@
                             let _ = this.update(cx, |this, cx| {
                                 this.toast_manager.push(
                                     components::toast::Toast::error(
-                                        format!("Failed to open AI: {}", e),
+                                        ai_open_failure_message(&e),
                                         &this.theme,
                                     )
                                     .duration_ms(Some(5000)),
@@ -552,7 +556,7 @@
                             logging::log("ERROR", &format!("AI command failed: {}", e));
                             self.toast_manager.push(
                                 components::toast::Toast::error(
-                                    format!("Failed to open AI: {}", e),
+                                    ai_open_failure_message(&e),
                                     &self.theme,
                                 )
                                 .duration_ms(Some(5000)),
@@ -632,7 +636,15 @@
                                     ),
                                 );
                                 if let Err(e) = ai::open_ai_window(cx) {
-                                    logging::log("ERROR", &format!("Failed to open AI: {}", e));
+                                    logging::log("ERROR", &ai_open_failure_message(&e));
+                                    self.toast_manager.push(
+                                        components::toast::Toast::error(
+                                            ai_open_failure_message(&e),
+                                            &self.theme,
+                                        )
+                                        .duration_ms(Some(5000)),
+                                    );
+                                    cx.notify();
                                 } else {
                                     // Set input with the screenshot context
                                     ai::set_ai_input_with_image(cx, &message, &base64_data, false);
@@ -675,7 +687,15 @@
                                     ),
                                 );
                                 if let Err(e) = ai::open_ai_window(cx) {
-                                    logging::log("ERROR", &format!("Failed to open AI: {}", e));
+                                    logging::log("ERROR", &ai_open_failure_message(&e));
+                                    self.toast_manager.push(
+                                        components::toast::Toast::error(
+                                            ai_open_failure_message(&e),
+                                            &self.theme,
+                                        )
+                                        .duration_ms(Some(5000)),
+                                    );
+                                    cx.notify();
                                 } else {
                                     ai::set_ai_input_with_image(cx, &message, &base64_data, false);
                                 }
@@ -707,7 +727,15 @@
                                     &format!("Selected text captured: {} chars", text.len()),
                                 );
                                 if let Err(e) = ai::open_ai_window(cx) {
-                                    logging::log("ERROR", &format!("Failed to open AI: {}", e));
+                                    logging::log("ERROR", &ai_open_failure_message(&e));
+                                    self.toast_manager.push(
+                                        components::toast::Toast::error(
+                                            ai_open_failure_message(&e),
+                                            &self.theme,
+                                        )
+                                        .duration_ms(Some(5000)),
+                                    );
+                                    cx.notify();
                                 } else {
                                     ai::set_ai_input(cx, &message, false);
                                 }
@@ -750,7 +778,15 @@
                                 );
                                 logging::log("EXEC", &format!("Browser URL captured: {}", url));
                                 if let Err(e) = ai::open_ai_window(cx) {
-                                    logging::log("ERROR", &format!("Failed to open AI: {}", e));
+                                    logging::log("ERROR", &ai_open_failure_message(&e));
+                                    self.toast_manager.push(
+                                        components::toast::Toast::error(
+                                            ai_open_failure_message(&e),
+                                            &self.theme,
+                                        )
+                                        .duration_ms(Some(5000)),
+                                    );
+                                    cx.notify();
                                 } else {
                                     ai::set_ai_input(cx, &message, false);
                                 }
@@ -794,7 +830,14 @@
                             .duration_ms(Some(3000)),
                         );
                         if let Err(e) = ai::open_ai_window(cx) {
-                            logging::log("ERROR", &format!("Failed to open AI: {}", e));
+                            logging::log("ERROR", &ai_open_failure_message(&e));
+                            self.toast_manager.push(
+                                components::toast::Toast::error(
+                                    ai_open_failure_message(&e),
+                                    &self.theme,
+                                )
+                                .duration_ms(Some(5000)),
+                            );
                         }
                         cx.notify();
                     }
@@ -1170,3 +1213,16 @@
         }
     }
 }
+
+#[cfg(test)]
+mod builtin_execution_ai_feedback_tests {
+    use super::ai_open_failure_message;
+
+    #[test]
+    fn test_ai_open_failure_message_includes_error_details() {
+        assert_eq!(
+            ai_open_failure_message("window init failed"),
+            "Failed to open AI: window init failed"
+        );
+    }
+}
diff --git a/src/app_impl/execution_scripts.rs b/src/app_impl/execution_scripts.rs
index ac99cc20952af2f8c39e301b7740e55cec8f394e..d870c647daaa9030713a2e74635d580b8dda93c4
--- a/src/app_impl/execution_scripts.rs
+++ b/src/app_impl/execution_scripts.rs
@@ -1,5 +1,40 @@
 use super::*;
 
+const NO_MAIN_WINDOW_BUILTINS: &[&str] = &[
+    "builtin-ai-chat",
+    "builtin-open-ai",
+    "builtin-notes",
+    "builtin-open-notes",
+    "builtin-new-note",
+    "builtin-search-notes",
+    "builtin-quick-capture",
+    "builtin-new-conversation",
+];
+
+fn builtin_needs_main_window_for_command_id(identifier: &str) -> bool {
+    !NO_MAIN_WINDOW_BUILTINS.contains(&identifier)
+}
+
+#[cfg(test)]
+mod builtin_command_window_visibility_tests {
+    use super::builtin_needs_main_window_for_command_id;
+
+    #[test]
+    fn test_builtin_needs_main_window_false_for_open_ai_and_open_notes() {
+        assert!(!builtin_needs_main_window_for_command_id("builtin-open-ai"));
+        assert!(!builtin_needs_main_window_for_command_id(
+            "builtin-open-notes"
+        ));
+    }
+
+    #[test]
+    fn test_builtin_needs_main_window_true_for_unlisted_builtin() {
+        assert!(builtin_needs_main_window_for_command_id(
+            "builtin-refresh-scripts"
+        ));
+    }
+}
+
 impl ScriptListApp {
     pub(crate) fn execute_scriptlet(&mut self, scriptlet: &scripts::Scriptlet, cx: &mut Context<Self>) {
         logging::log(
@@ -312,16 +347,6 @@
             "EXEC",
             &format!("Executing by command ID or path: {}", command_id),
         );
-
-        // Builtins that open their own windows and don't need main window
-        const NO_MAIN_WINDOW_BUILTINS: &[&str] = &[
-            "builtin-ai-chat",
-            "builtin-notes",
-            "builtin-new-note",
-            "builtin-search-notes",
-            "builtin-quick-capture",
-            "builtin-new-conversation",
-        ];
 
         // Parse command ID format: "type/identifier"
         if let Some((cmd_type, identifier)) = command_id.split_once('/') {
@@ -352,7 +377,8 @@
                         logging::log("EXEC", &format!("Executing builtin: {}", identifier));
                         self.execute_builtin(entry, cx);
                         // Check if this builtin opens its own window
-                        let needs_main_window = !NO_MAIN_WINDOW_BUILTINS.contains(&identifier);
+                        let needs_main_window =
+                            builtin_needs_main_window_for_command_id(identifier);
                         logging::log(
                             "EXEC",
                             &format!(

tokens used
152,507
Implemented the requested fixes in the two scoped files.

**Changed files**
1. `src/app_execute/builtin_execution.rs`
- Added user-visible error toasts for AI window-open failures in the previously log-only AI command paths:
  - `AiCommandType::SendScreenToAi` at `src/app_execute/builtin_execution.rs:617`
  - `AiCommandType::SendFocusedWindowToAi` at `src/app_execute/builtin_execution.rs:667`
  - `AiCommandType::SendSelectedTextToAi` at `src/app_execute/builtin_execution.rs:717`
  - `AiCommandType::SendBrowserTabToAi` at `src/app_execute/builtin_execution.rs:771`
  - `AiCommandType::CreateAiPreset | ImportAiPresets | SearchAiPresets` at `src/app_execute/builtin_execution.rs:821`
- Added helper `ai_open_failure_message(...)` at `src/app_execute/builtin_execution.rs:1`.
- Added unit test module `builtin_execution_ai_feedback_tests` at `src/app_execute/builtin_execution.rs:1218`.

2. `src/app_impl/execution_scripts.rs`
- Added `builtin-open-ai` and `builtin-open-notes` to no-main-window handling via:
  - `NO_MAIN_WINDOW_BUILTINS` at `src/app_impl/execution_scripts.rs:3`
  - `builtin_needs_main_window_for_command_id(...)` at `src/app_impl/execution_scripts.rs:14`
  - call site update in `execute_by_command_id_or_path` at `src/app_impl/execution_scripts.rs:380`
- Added unit test module `builtin_command_window_visibility_tests` at `src/app_impl/execution_scripts.rs:19`.

**How to test**
1. Requested verification commands (run, currently failing due unrelated parallel changes):
- `cargo check -p script-kit-gpui`
- `cargo clippy -p script-kit-gpui --all-targets -- -D warnings`

2. Targeted unit test filters for this change:
- `cargo test -p script-kit-gpui --bin script-kit-gpui builtin_execution_ai_feedback_tests`
- `cargo test -p script-kit-gpui --bin script-kit-gpui builtin_command_window_visibility_tests`

**Verification status**
- I ran:
  - `cargo check -p script-kit-gpui`
  - `cargo clippy -p script-kit-gpui --all-targets -- -D warnings`
  - targeted `cargo test` filters
- All were blocked by unrelated workspace errors outside this task scope (examples):
  - duplicate `mod tests` resolution conflicts in `src/protocol/message/mod.rs` and `src/designs/core/part_04.rs`
  - clipboard model/match errors in `src/clipboard_history/*` (missing `source_app_*` fields, non-exhaustive `ContentType` matches)
  - unrelated actions test/import failures in `src/actions/*`

**Risks / known gaps**
1. Runtime validation is limited because workspace compilation is currently broken outside these files.
2. The added unit tests are in place but cannot execute until the unrelated compile errors are resolved.

Commits made: none.


==== exit @ 2026-02-07T23:46:45.489Z code=0 status=done ====
