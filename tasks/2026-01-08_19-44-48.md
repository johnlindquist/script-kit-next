Here’s a set of window-management commands that are actually worth adding (high utility, realistic with macOS Accessibility / AX), plus concrete implementation notes mapped to your Rust files.

I’m focusing on commands that (a) feel “instant” in use, (b) don’t require fragile hacks, and (c) fit your existing architecture (window ops queue + enhanced bounds/display detection).

---

## The next 10 commands I’d add (in priority order)

### 1) Horizontal thirds + two‑thirds (with cycling)

**Why:** This is the biggest bang-for-buck after halves/quadrants. People want IDE + docs + terminal layouts constantly.

**Commands**

* Tile: Left Third / Center Third / Right Third
* Tile: Left Two‑Thirds / Right Two‑Thirds
* Cycle Thirds (keep pressing → L → C → R → L …)
* Cycle Two‑Thirds (keep pressing → L2/3 ↔ R2/3)

**Implementation sketch**

* Use the **visible frame** (exclude menu bar + dock) from `window_control_enhanced/`.
* Compute target rects from the frame:

  * `third_w = frame.w / 3`
  * left third: `x=frame.x`, center: `x=frame.x + third_w`, right: `x=frame.x + 2*third_w`
  * two-thirds: `w=2*third_w`, left: `x=frame.x`, right: `x=frame.x + third_w`
* Add an optional **gap** (like 8–16 px) so tiled windows don’t touch.
* Add a “cycle” variant that decides next position based on the current window rect (compare normalized `x` / `w` against expected slots with a tolerance).

**Where to change**

* `src/window_control.rs`: add operations + rect math + AX apply
* `src/system_actions.rs`: expose commands
* `src/window_control_enhanced/`: ensure you can reliably get visible frame for the window’s display

---

### 2) Move window to next/previous display (two modes)

**Why:** “Move to next monitor” is table-stakes; people expect it.

**Commands**

* Move to Next Display (preserve relative position)
* Move to Next Display (center on new display)
* Move to Previous Display (same two variants)

**Implementation sketch**

1. Determine which display the window is “on”:

   * Choose the display with the **largest intersection area** between `window_rect` and each display’s visible frame. (This avoids weirdness when a window straddles monitors.)
2. Pick next display (cyclic order). The order can be:

   * “System order” (NSScreen order) or
   * spatial order (sort by x then y); pick one and keep it consistent.
3. Compute new rect:

   * **Preserve-relative**: normalize window rect inside current visible frame:

     * `nx = (x - frame.x) / frame.w`, `ny = (y - frame.y) / frame.h`
     * `nw = w / frame.w`, `nh = h / frame.h`
     * new rect on target frame: `x2 = frame2.x + nx*frame2.w`, etc.
     * Clamp to frame2.
   * **Center**: keep size, center within frame2, clamp.

**Where to change**

* `src/window_control.rs`: new `MoveToDisplay{Next,Prev}` or `MoveToDisplay(display_id, mode)`
* `src/window_control_enhanced/`: display enumeration + visible frame + intersection logic
* `src/system_actions.rs`: add actions + menu labels

---

### 3) Cycle windows within the same app (next/prev)

**Why:** This solves “no window cycling”. It’s also much easier than global alt-tab replacements.

**Commands**

* Focus Next Window (same app)
* Focus Previous Window (same app)
* Focus Last Window (same app) (toggle between two most recent)

**Implementation sketch**

* Get the focused app PID.
* Enumerate that app’s windows:

  * Usually via AX on the app element (e.g., `kAXWindowsAttribute`).
* Filter to “real” windows:

  * skip minimized, skip tiny utility windows if you can detect them, skip windows without standard role/subrole (best-effort).
* Decide ordering:

  * Best: keep your own MRU list (update whenever your tool focuses a window).
  * Acceptable: use the AX window list order (often front-to-back).
* Focus by setting the window’s `kAXMainAttribute` / `kAXFocusedAttribute` (depending on your current focus implementation).

**Where to change**

* `src/window_manager.rs`: add `list_windows_for_pid(pid)` + filtering
* `src/window_state.rs`: optional MRU tracking (even “last focused window id” is already useful)
* `src/window_control.rs`: `focus_window(window_handle)`
* `src/system_actions.rs`: expose actions

---

### 4) “Toggle Maximize” that actually restores

**Why:** Maximize without a restore toggle is half a feature. People want a “zoom” that doesn’t enter macOS full screen.

**Commands**

* Toggle Maximize (visible frame)
* Toggle Maximize (current display only, keep on same monitor)

**Implementation sketch**

* If window is “close enough” to visible frame (within tolerance), restore to last stored bounds.
* Otherwise:

  * Store current bounds in `window_state`
  * Set bounds = visible frame (minus optional gap)

**Where to change**

* `src/window_state.rs`: persist `last_non_maximized_bounds` per window
* `src/window_control.rs`: logic + AX set position/size
* `src/system_actions.rs`: action

---

### 5) Swap focused window with last-focused window

**Why:** In tiling workflows, swap is faster than re-tiling two windows manually.

**Commands**

* Swap With Last Window
* Swap With Selected Window (optional later)

**Implementation sketch**

* Track last focused window handle in `window_state`.
* On swap:

  * Read rect A (focused), rect B (last)
  * Apply rects swapped
  * Optionally refocus original focused window

**Where to change**

* `src/window_state.rs`: store `last_focused_window`
* `src/window_control.rs`: `get_bounds`, `set_bounds`
* `src/system_actions.rs`: action

---

### 6) Nudge window (move by steps) + resize by edges

**Why:** Once you add gaps and thirds, you need fine control without the mouse.

**Commands**

* Nudge Left/Right/Up/Down (small step)
* Nudge Left/Right/Up/Down (big step)
* Resize: Expand Left / Shrink Left / Expand Right / … (edges)

**Implementation sketch**

* Nudge: `x += dx`, `y += dy`, clamp to visible frame.
* Resize edge: adjust `x/w` or `y/h` depending on edge; clamp min size; clamp to frame.
* Steps should be constants configurable later (e.g., 10px and 50px).

**Where to change**

* `src/window_resize.rs`: likely the right home for edge-resize ops
* `src/window_control.rs`: nudge op + clamp helper
* `src/system_actions.rs`: actions

---

### 7) Center window (no resize) + “Center & Resize to …”

**Why:** It’s a “make it sane” button. Also good before presenting/sharing.

**Commands**

* Center Window
* Center + 70% size (or “Large / Medium / Small” presets)

**Implementation sketch**

* Center: `x = frame.x + (frame.w - w)/2`, `y = frame.y + (frame.h - h)/2`
* Preset sizes: `w = frame.w * 0.7`, `h = frame.h * 0.8`, then center.

**Where to change**

* `src/window_control.rs`: simple rect ops
* `src/system_actions.rs`: actions

---

### 8) “Move to edge” without resizing

**Why:** Sometimes you like your window size but want it parked left/right/top/bottom instantly.

**Commands**

* Move to Left Edge / Right Edge / Top / Bottom
* Move to Top-Left / Top-Right / Bottom-Left / Bottom-Right (no resize)

**Implementation sketch**

* Keep size, set position to edge, clamp into visible frame.

**Where to change**

* `src/window_control.rs`, `src/system_actions.rs`

---

### 9) Smart two-window split (focused + last window)

**Why:** This makes “I want these two windows side-by-side” a single command.

**Commands**

* Split Focused + Last Window (Left/Right)
* Split Focused + Last Window (Top/Bottom)

**Implementation sketch**

* Get focused A, last-focused B (or second-most-recent in same space if you can).
* Apply two half-rects on the current display visible frame.
* Assign A left, B right (or A top, B bottom). (Optionally invert.)

**Where to change**

* `src/window_state.rs`: last-focused tracking
* `src/window_control.rs`: multi-window operation (apply two sets)
* `src/system_actions.rs`: action

---

### 10) Layout slots (micro “grouping” without building a full layout engine)

**Why:** Real “window groups” gets complicated fast. Slots are the pragmatic version.

**Commands**

* Save Layout Slot 1 (store bounds for the focused window, or all windows on display)
* Restore Layout Slot 1

**Reality check**

* Fully restoring “all windows” reliably across app restarts is hard because window identity is messy.
* But restoring in the same session is very doable and still valuable.

**Implementation sketch**

* Slot contains:

  * For “focused-only”: `{window_id -> rect_normalized_to_display}`
  * For “all windows on current display”: list windows + normalized rects
* Restore by recomputing rects onto current display frames.

**Where to change**

* `src/window_state.rs`: store layout slots (in-memory + optional persistence)
* `src/window_manager.rs`: enumerate windows on display
* `src/window_control.rs`: restore application

---

## What I would *not* prioritize (or would gate behind “experimental”)

### Move window between Spaces / desktops

It’s not reliably supported via AX in a clean, stable way. You can fake it by triggering system shortcuts (Ctrl+←/→) and dragging/mission-control style behaviors, but it’s fragile and user-setting-dependent. If you do it, label it “best effort” and expect support headaches.

### “Always on top”

Not a standard AX capability. Some apps implement their own; you can’t count on it system-wide.

### Perfect global window cycling like Alt‑Tab

Doable-ish, but it spirals into edge cases: minimized windows, hidden apps, transient panels, full-screen spaces, etc. Start with same-app cycling first.

---

## Concrete code-architecture suggestions (so this doesn’t get messy)

### A) Standardize rect math in one place

Create (or centralize) helpers like:

* `visible_frame_for_window(window_rect) -> frame`
* `clamp_rect_to_frame(rect, frame, min_size)`
* `rect_is_close(rect, target, tolerance)`
* `normalize(rect, frame) -> (nx, ny, nw, nh)`
* `denormalize(nrect, frame2) -> rect2`

Good home: `src/window_control_enhanced/` (since it already owns display/bounds correctness).

### B) Add “mode” variants rather than exploding the enum

Instead of 20 one-off ops, do things like:

* `Tile(LayoutPreset)` where `LayoutPreset` includes Thirds, TwoThirds, Halves, Quadrants, etc.
* `MoveToDisplay(Direction, MoveMode)` where `MoveMode` = PreserveRelative | Center
* `Nudge(StepSize, Direction)`
  This keeps `window_control.rs` readable and makes `system_actions.rs` the place where you define “Left Third”, “Center Third”, etc.

### C) Track just enough state to unlock good UX

Minimum viable state that pays off immediately:

* `last_focused_window`
* `last_bounds_before_maximize` per window
* optional: per-window “last tile slot” to make cycling layouts predictable

Good home: `src/window_state.rs`.

---

## A sane implementation order (so you ship value fast)

1. Thirds + two-thirds (plus cycle)
2. Move to next/prev display (preserve-relative)
3. Toggle maximize/restore
4. Same-app window cycling
5. Nudge + edge resize
6. Swap windows
7. Smart two-window split
8. Layout slots (optional)

If you do just the first 4, the project stops feeling “basic” immediately.

---

If you want, paste (or summarize) how `WindowOperation` / your current tiling enum is structured in `src/window_control.rs`, and I’ll propose a clean set of enum variants + function signatures that won’t balloon as you add more layouts.
