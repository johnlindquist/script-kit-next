Below is a straight, “what will bite you in production” review of the hotkey + CGEventTap stack as it exists in these 3 files, plus concrete fixes and design recommendations.

## Biggest risks to fix first (in priority order)

1. **Your CGEventTap callback ignores “tap disabled” events.**
   When a tap is disabled (timeout/unresponsive or user/system disabling taps), macOS sends a special event type to your callback and expects you to re‑enable the tap. The Quartz docs explicitly call this out and say you can re‑enable by calling `CGEventTapEnable`.
   Right now you:

   * ignore `_event_type`
   * still try to parse the “event” as a key event (likely garbage)
   * never re-enable
     Result: **monitor silently stops**, and you may generate bogus triggers.

2. **You’re checking the wrong permission for your current tap mode.**
   You’re using `kCGEventTapOptionListenOnly` (passive listener). Apple’s guidance since TCC hardening is: **listen-only interception maps to Input Monitoring**, while taps that *modify/filter* map to Accessibility. ([Apple Developer][1])
   Your code only checks Accessibility. That’s a UX trap: users can “fix” the wrong thing and still not get events.

3. **You log typed characters (debug logs). That’s a privacy landmine.**
   `keyboard_monitor.rs` logs `character = ?key_event.character`. Even if it’s “debug”, it will end up in crash logs / user logs / support bundles. For an app that captures global keystrokes, **never log raw keystrokes** (not even in debug builds unless you gate it behind an explicit “diagnostic mode” with scary UI).

4. **Hotkey registration is split-brain (static startup registration vs “dynamic manager”).**
   `start_hotkey_listener()` registers script shortcuts into a local `HashMap`, while `ScriptHotkeyManager` is a separate global singleton that needs explicit init and has its own manager instance. If both are used in the same process, you’ll eventually get conflicts, stale state, or thread-affinity problems.

5. **Potential double-fire for Notes/AI hotkeys if handlers are ever set.**
   `dispatch_notes_hotkey()` and `dispatch_ai_hotkey()` both:

   * send to the channel, and
   * optionally call a registered handler
     If you ever set a handler *and* run the poller, you can trigger the action twice.

---

## 1) Global hotkey management (crate choice, conflicts, layouts)

### Is `global-hotkey` a good choice?

For a cross-platform Rust desktop app, **it’s a reasonable choice**: it’s used in the Tauri ecosystem and provides a unified API for register/unregister and event receiving. You also get structured errors like `AlreadyRegistered`. ([Docs.rs][2])

If you were macOS-only and wanted maximum control, you could go “native” (Carbon/Quartz directly), but realistically: **your current problems aren’t crate choice—they’re conflict UX + lifecycle/threading**.

### How do we handle hotkey conflicts with other apps?

On macOS you generally **cannot pre-enumerate** all system/app hotkeys reliably. The only sane approach:

* Attempt `register()`.
* If it fails, treat it as a conflict and show a UI error.
* Store “unregistered due to conflict” state and keep the app running.

Your best hook is the error. `global-hotkey` exposes `Error::AlreadyRegistered` (and other failure variants). ([Docs.rs][2])

**Actionable change:** don’t collapse errors into opaque `anyhow!("Failed to register hotkey: {}", e)` when you can pattern-match and display a better message.

### Should we provide conflict detection UI?

Yes. If you let users customize hotkeys (main toggle + scripts), you need:

* A “Press keys…” recorder UI
* Immediate “works / conflicts” feedback
* A clear way to revert to defaults

Without that, users will think the app is broken.

### A macOS Sequoia (15) gotcha (sandboxed apps)

There’s a real-world report that in **macOS Sequoia**, sandboxed apps may fail to register hotkeys that only use Shift/Option modifiers, requiring at least one “strong” modifier (e.g., Command/Control). ([Apple Developer][3])
If you distribute sandboxed, bake this into validation:

* “Shift+Option+K” → likely unreliable
* “Cmd+Shift+K” → good

### International keyboard layouts

Global hotkeys should be treated as **physical keys** (key codes), not characters. On non‑US layouts, a key labeled “;” may not exist or may move. The correct UX is:

* user presses the shortcut
* you store key code + modifiers
* you **display** it using the current layout for that user (localized symbol)

Your current config parsing uses string key names like `"Semicolon"`, which is okay internally but not good for a “press to set” UX.

---

## 2) CGEventTap audit (correctness, reliability, safety)

### ListenOnly: sufficient or do you need to modify events?

* **ListenOnly is the right default** for *detection*. It’s safer (less likely to break system input), and doesn’t let you accidentally “eat” input.
* You only need an active filter (`kCGEventTapOptionDefault`) if you truly must block/modify events *in-flight*. Quartz explicitly distinguishes passive vs active taps.

For text expansion, you can usually do:

* detect `:date`
* then synthesize backspaces + insert expansion (pasteboard or synthetic events)
  without needing to block the original keystrokes.

If you later want “perfect” UX (no flicker, no transient trigger text), **then** consider active filtering—but be ready for:

* stronger permissions
* more compatibility headaches
* higher risk of being disabled for “unresponsiveness”

### You must handle “tap disabled” events

Quartz docs: if a tap becomes unresponsive or user disables event taps, the system passes a disabled event to your callback, and taps can be re-enabled with `CGEventTapEnable`.
The Assistive Apps guide also calls out the timeout/user-input disable reasons. ([Late Night Software Ltd.][4])

**What you should do:**

* In the callback, check `_event_type`.
* If it’s `TapDisabledByTimeout` or `TapDisabledByUserInput`, re-enable and return immediately.

**Important implementation detail:** your callback currently can’t call `event_tap.enable()` because the tap doesn’t exist when you define the closure.

A practical pattern is:

* Create an `Arc<Mutex<Option<CFMachPortRef>>>` (or whatever handle your wrapper can expose)
* Capture that in the closure
* After creating the tap, store the port handle into it
* In the callback, if disabled event arrives, call `CGEventTapEnable(port, true)` via FFI

Also: even if you re-enable, if your callback is slow, it will just get disabled again. Which leads to…

### Performance + responsiveness: keep callback tiny

Even Apple’s docs imply the tap can be disabled if “unresponsive.”
You are currently doing:

* Unicode extraction
* `String::from_utf16`
* allocations
* logging
* calling arbitrary user callback

That’s a lot for a function that might run for **every keystroke in the system**.

**Better structure:**

* Callback does *minimal decoding* (or none)
* Push an event into a lock-free/bounded channel (try_send, drop on overflow)
* Return immediately
* A worker (still on your monitor thread) does decoding + trigger matching

### You’re truncating characters to 4 UTF‑16 code units

`buffer: [u16; 4]` is not safe for:

* many emoji
* composed characters
* some IME outputs

Even if your triggers are ASCII today, truncation can break correctness in weird ways (e.g., you capture “:” but then mis-handle the next code point).

Use a larger buffer (32/64) or dynamically allocate based on the reported length.

### Stop using a 100ms “polling run loop”

Your event-loop uses `CFRunLoop::run_in_mode(..., 100ms, ...)` in a loop. That wakes 10×/sec forever.

Since you already store the run loop and call `stop()`, you can simply:

* add the source
* call `CFRunLoop::run()` (or equivalent)
* stop the run loop from `stop()`

It’s simpler and avoids the periodic wakeups.

### Remove the `unsafe impl Send for KeyboardMonitor`

This is a red flag. If `CFRunLoop` isn’t `Send`, the safe approach is:

* keep run loop operations on the run loop thread
* signal stop via a channel/run-loop source/timer rather than calling methods across threads

It’s doable and it removes an entire class of “works until it doesn’t” bugs.

---

## 3) Permissions (graceful UX + runtime changes)

### You need to treat permissions as “state”, not just a start-time check

Right now:

* `start()` checks only Accessibility and either starts or returns an error.

In reality you need:

* **Input Monitoring** for listen-only keystroke observation ([Apple Developer][1])
* **Accessibility** if you inject/modifiy input or need AX APIs

**UX that works:**

* A status panel: “Keyboard monitoring: Enabled/Disabled”
* If disabled: show which permission is missing and a “Open System Settings” button
* Don’t hard-fail the whole app—only disable the features that need it

### Detecting permission revocation at runtime

Permissions can be revoked while the app is running. Signals you can use:

* periodic preflight checks (Input Monitoring + Accessibility)
* tap stops receiving events
* tap creation fails (Quartz says `CGEventTapCreate` can return NULL if monitoring isn’t permitted for requested events).

When detected:

* disable expansion features
* show a non-blocking banner/toast
* offer a “Fix Permissions” action

---

## 4) Text expansion trigger detection (algorithm + false positives)

You didn’t include the trigger matching code, but you *can* design this cleanly without scanning huge buffers.

### A good baseline algorithm

Maintain a rolling buffer of the last N “typed characters” (N = max trigger length + a bit). Update it per keystroke.

Handle:

* **Backspace/delete**: remove from buffer
* **Cursor movement / mouse click**: invalidate buffer (you’re no longer in a linear stream)
* **Auto-repeat**: typically ignore repeats except for backspace

Match strategy:

* Only attempt matching when the buffer ends with a valid “terminator” (space, enter, punctuation) *or* when the buffer ends with your trigger prefix completion.
* Use a fast multi-pattern matcher (Aho–Corasick) for literal triggers; it’s ideal for many short strings.

### Avoid false positives

Rules that reduce “why did it expand there?” complaints:

* Require a boundary before the trigger (start of field, whitespace, punctuation)
* Require a boundary after the trigger (space, enter, punctuation) unless user sets “expand immediately”
* Allow per-snippet toggles (“expand immediately”, “require delimiter”)

### Regex triggers?

You can support them, but:

* compile once (startup/config load)
* **never run regex on every keystroke**
  Run regex only when:
* the last char is a delimiter, or
* a cheap prefix check says “this might match”

### Password fields / secure entry

Two separate concerns:

1. **Secure event input blocks interception entirely.**
   Apple’s TN2150 explains the system “stops passing keyboard events to any intercept process whenever any process has enabled secure event input.”
   That means: sometimes you simply won’t receive keystrokes. This is not fixable and should not be “worked around”.

2. Even when you do receive events, you should **proactively disable expansion** in secure text fields / password managers. Best practice is:

* default denylist of apps / bundle IDs
* optionally detect focused element role via Accessibility APIs (if you already have AX permission)

**UX you want:** show an indicator like “Secure Keyboard Entry active — expansions paused” instead of acting flaky.

---

## 5) Performance: what matters and how to make it cheap

### Where you’re paying today

In `keyboard_monitor.rs`, per keypress you potentially do:

* FFI call
* UTF‑16 → `String` allocation
* logging formatting
* callback work

That adds up fast.

### Make it cheap

* **Stop allocating per keystroke**: represent character as `Option<char>` (or small fixed buffer) and only allocate when needed.
* **Drop logs** or gate them behind an explicit runtime flag that is OFF in normal builds.
* **Do minimal work in callback** and push to a channel.
* **Debounce expansions** (e.g., don’t allow multiple expansions within 50–100ms) so you don’t cascade when an app sends duplicate events.

### Measuring

Don’t guess. Add signposts/timing counters around:

* callback duration
* trigger matching duration
* injection duration
  Then validate with Instruments.

---

## 6) Cross-app compatibility (Karabiner, BetterTouchTool, etc.)

### Secure Input will “randomly” disable your expansion

This is the #1 support ticket you’ll get. Treat it as a first-class state (see TN2150).

### Karabiner / remappers

Remappers can:

* change which key code you see
* inject synthetic events that you might mistake for user typing

Mitigations:

* tag your own injected events (event source user data) and ignore them in the tap callback
* consider offering a “tap location” option (HID vs session) if you see remapper-related weirdness

### BetterTouchTool and other hotkey tools

Expect conflicts. Your registration UI must handle it (AlreadyRegistered, etc.). ([Docs.rs][2])
Do not attempt to “steal” hotkeys—just fail gracefully and let the user choose.

---

## Concrete code-level recommendations (based on your current files)

### Hotkey side (`hotkeys.rs`, `hotkey_pollers.rs`)

* **Unify** into *one* hotkey subsystem:

  * one owner thread for `GlobalHotKeyManager`
  * a command channel for (register/unregister/update)
  * an event channel for “hotkey fired”
* Replace `send_blocking` for the main hotkey with `try_send` + drop (or coalesce) if channel is full. Blocking inside the hotkey thread is unnecessary risk.
* Decide: **either** “channel-driven Notes/AI” **or** “handler-driven Notes/AI”. Not both.

### Keyboard monitor (`keyboard_monitor.rs`)

* Handle tap disabled events and re-enable. Quartz explicitly supports this re-enable flow.
* Stop logging raw typed characters.
* Increase unicode buffer size; avoid per-keystroke allocations.
* Replace the 100ms run loop “spin” with a true run loop run + stop signal.
* Remove `unsafe impl Send` by avoiding cross-thread use of `CFRunLoop` wrapper types.

---

## Bottom line

* **`global-hotkey` is fine**. Your real needs are: conflict UX, validation, and a single coherent lifecycle/threading model.
* **CGEventTap is viable**, but only if you:

  * handle disabled events and re-enable
  * treat Secure Input as “expansion paused” (expected behavior)
  * keep the callback extremely lightweight
* **Permissions UX must distinguish Input Monitoring vs Accessibility**, otherwise users will get stuck in “I enabled the thing you told me, and it still doesn’t work.”

If you want, I can propose a concrete “HotkeyService + KeyboardService” module layout (structs, channels, thread ownership) that drops the current duplication and removes the unsafe `Send` entirely—without changing how your UI code consumes events.

[1]: https://developer.apple.com/videos/play/wwdc2019/701/?utm_source=chatgpt.com "Advances in macOS Security - WWDC19 - Videos - Apple Developer"
[2]: https://docs.rs/global-hotkey/latest/src/global_hotkey/error.rs.html?utm_source=chatgpt.com "error.rs - source"
[3]: https://developer.apple.com/forums/thread/763878?utm_source=chatgpt.com "[macOS Sequoia] Using RegisterEventHotkey with option ..."
[4]: https://forum.latenightsw.com/uploads/short-url/bx3PJs6gEcu6quDvl8GHgzJeRG2.pdf "Assistive Application Programming Guide.pages"
