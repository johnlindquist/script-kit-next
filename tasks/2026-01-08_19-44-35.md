You’ve got **two real bugs** here, and they combine into the exact “dialog closes, nothing happens” symptom.

## What’s actually breaking

### 1) You close the popup **before** executing the action (and the close likely clears the path)

In the Enter handler:

```rust
if should_close {
  this.close_actions_popup(...);   // <-- very likely clears file_search_actions_path
}
this.handle_action(action_id, cx); // <-- now file_search_actions_path is None
```

Most file actions (`open_file`, `open_directory`, `quick_look`, `copy_filename`, etc.) **only work if** `file_search_actions_path` is still `Some(_)`. If it gets cleared during close, they silently no-op (exactly what users report).

### 2) `reveal_in_finder` and `copy_path` are matched in the “script list” branch first

Even if the path survives, `reveal_in_finder`/`copy_path` hit the earlier match arms that do:

* `get_selected_result()` (script list context)
* if `None`, set `"No item selected"`
* **never** consult `file_search_actions_path`
* so file search actions for those IDs never execute

### 3) Unconditional view reset in `handle_action()` is a footgun

This line at the top:

```rust
self.current_view = AppView::ScriptList;
```

…means anything inside `handle_action()` that relies on “what view am I in?” or selection state can easily target the wrong thing. It also breaks your FileSearch keystroke interceptor logic if any action doesn’t close the popup (since the interceptor exits unless `current_view` is `FileSearchView`).

Even if it’s not the primary cause of “nothing happens”, it’s making this fragile.

---

## Minimal, high-confidence fix

### A) Preserve `file_search_actions_path` across `close_actions_popup()` in the Enter handler

**File: `src/app_impl.rs`** (inside the `if key == "enter"` block)

Replace:

```rust
if should_close {
    this.close_actions_popup(
        ActionsDialogHost::FileSearch,
        window,
        cx,
    );
}

this.handle_action(action_id, cx);
```

With:

```rust
// close_actions_popup may clear file_search_actions_path.
// Snapshot it so file actions still have a target.
let fs_path = this.file_search_actions_path.clone();

if should_close {
    this.close_actions_popup(
        ActionsDialogHost::FileSearch,
        window,
        cx,
    );
}

// Restore only for this immediate execution path.
if fs_path.is_some() {
    this.file_search_actions_path = fs_path;
}

this.handle_action(action_id, cx);
```

This alone should make `open_file`, `open_directory`, `quick_look`, `open_with`, `show_info`, `copy_filename` start working again (because they stop seeing `None`).

---

### B) In `handle_action()`, make `reveal_in_finder` and `copy_path` check file-search context **first**

**File: `src/app_actions.rs`**

#### Fix `reveal_in_finder`

Replace your current `"reveal_in_finder" => { ... }` arm with this pattern:

```rust
"reveal_in_finder" => {
    logging::log("UI", "Reveal in Finder action");

    // File Search context first
    if let Some(path) = self.file_search_actions_path.take() {
        logging::log("UI", &format!("Reveal in Finder (file search): {}", path));
        self.reveal_in_finder(std::path::Path::new(&path));
        self.last_output = Some(SharedString::from("Revealed in Finder"));
    } else if let Some(result) = self.get_selected_result() {
        // Script list context (existing logic)
        let path_opt = match result {
            scripts::SearchResult::Script(m) => Some(m.script.path.clone()),
            scripts::SearchResult::App(m) => Some(m.app.path.clone()),
            scripts::SearchResult::Agent(m) => Some(m.agent.path.clone()),
            scripts::SearchResult::Scriptlet(_) => {
                self.last_output = Some(SharedString::from("Cannot reveal scriptlets in Finder"));
                None
            }
            scripts::SearchResult::BuiltIn(_) => {
                self.last_output = Some(SharedString::from("Cannot reveal built-in features"));
                None
            }
            scripts::SearchResult::Window(_) => {
                self.last_output = Some(SharedString::from("Cannot reveal windows in Finder"));
                None
            }
            scripts::SearchResult::Fallback(_) => {
                self.last_output = Some(SharedString::from(
                    "Cannot reveal fallback commands in Finder",
                ));
                None
            }
        };

        if let Some(path) = path_opt {
            self.reveal_in_finder(&path);
            self.last_output = Some(SharedString::from("Revealed in Finder"));
            self.hide_main_and_reset(cx);
        }
    } else {
        self.last_output = Some(SharedString::from("No item selected"));
    }
}
```

#### Fix `copy_path`

Same structure:

```rust
"copy_path" => {
    logging::log("UI", "Copy path action");

    // File Search context first
    if let Some(path) = self.file_search_actions_path.take() {
        logging::log("UI", &format!("Copy path (file search): {}", path));

        #[cfg(target_os = "macos")]
        {
            match self.pbcopy(&path) {
                Ok(_) => {
                    logging::log("UI", &format!("Copied path to clipboard: {}", path));
                    self.last_output = Some(SharedString::from(format!("Copied: {}", path)));
                }
                Err(e) => {
                    logging::log("ERROR", &format!("pbcopy failed: {}", e));
                    self.last_output = Some(SharedString::from("Failed to copy path"));
                }
            }
        }

        #[cfg(not(target_os = "macos"))]
        {
            use arboard::Clipboard;
            match Clipboard::new().and_then(|mut c| c.set_text(&path)) {
                Ok(_) => {
                    logging::log("UI", &format!("Copied path to clipboard: {}", path));
                    self.last_output = Some(SharedString::from(format!("Copied: {}", path)));
                }
                Err(e) => {
                    logging::log("ERROR", &format!("Failed to copy path: {}", e));
                    self.last_output = Some(SharedString::from("Failed to copy path"));
                }
            }
        }
    } else if let Some(result) = self.get_selected_result() {
        // Script list context (keep your existing logic as-is)
        // ...
    } else {
        self.last_output = Some(SharedString::from("No item selected"));
    }
}
```

After this change, you can delete the `_ => { ... }` fallback special-casing for `copy_path` and `reveal_in_finder` if you want (it’ll be dead code), but it’s not required to fix the bug.

---

## Strongly recommended hardening (prevents the next regression)

### C) Don’t force `current_view = ScriptList` at the top of `handle_action()`

At minimum, gate it:

```rust
// Only force ScriptList when we are NOT coming from FileSearchView.
// FileSearch has its own selection model and interceptor.
if !matches!(self.current_view, AppView::FileSearchView { .. }) {
    self.current_view = AppView::ScriptList;
}
self.pending_focus = Some(FocusTarget::MainFilter);
```

This avoids:

* actions targeting the wrong selection (script list selection vs file selection)
* breaking the file-search interceptor if any action leaves the popup open

---

## Add one log that will save you hours later

For every file-search-only action (`open_file`, `quick_look`, etc.), don’t silently do nothing when the path is `None`. Log it and give a `last_output`.

Example:

```rust
"quick_look" => {
    if let Some(path) = self.file_search_actions_path.take() {
        logging::log("UI", &format!("Quick Look: {}", path));
        let _ = crate::file_search::quick_look(&path);
    } else {
        logging::log("ERROR", "quick_look failed: file_search_actions_path is None");
        self.last_output = Some(SharedString::from("No file selected"));
    }
}
```

Right now your “silent failure” is why this looked like nothing was happening.

---

## Sanity tests (fast)

After patching:

1. File Search → select a file → Cmd+K → **Open** → Enter
   ✅ file opens
2. Same flow → **Copy Path** → Enter → `pbpaste`
   ✅ exact selected file path
3. Same flow → **Show in Finder** → Enter
   ✅ Finder reveals selected file
4. Same flow → **Quick Look** → Enter
   ✅ Quick Look opens

If any of these still fail, the very next thing to check is `close_actions_popup()` (whether it does more than clearing `file_search_actions_path`, like tearing down state needed by the OS calls). But with the snapshot/restore in the interceptor, it becomes much harder for that to break execution.

If you want the clean “never rely on global state” version after the hotfix, the right design is: **pass the target path into the action execution call** (or store it in the ActionsDialog selection), and make `handle_action` take an `ActionContext { target_path: Option<String>, ... }`. That removes this entire class of bugs.
