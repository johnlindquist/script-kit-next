Here’s the direction I’d take to make an **App Shell** that actually pays off (less duplication, consistent focus + chrome, and no performance cliffs), while staying compatible with your current “single giant `ScriptListApp` with a big match” reality.

## The shape that will work in GPUI

### 1) Make the shell a *frame + chrome*, not another “app”

Keep `AppShell` **presentational** and keep **state/lifecycle** in the window root (`ScriptListApp`) or a small controller struct it owns.

**Why:** if `AppShell` is constructed inside `render()` and it “owns” focus handles / allocations / internal caches, you’ll recreate them constantly and fight focus thrash and perf regressions.

So:

* `ScriptListApp` owns *stable* things (focus handles, key routing policy, cached computed style).
* `AppShell` takes those by reference (or cheap clones if GPUI types are cheap clones) and returns elements.

---

## The big architectural tweak: Views return a `ShellSpec`

Instead of each prompt rendering its own header/footer, each prompt returns a spec:

```rust
pub struct ShellSpec<T> {
    pub header: Option<HeaderSpec<T>>,
    pub footer: Option<FooterSpec>,
    pub content: gpui::AnyElement,
    pub chrome: ChromeSpec,         // vibrancy/bg/shadow/radius/padding/divider behavior
    pub focus_policy: FocusPolicy,  // where focus should land when this view becomes active
    pub keymap: KeymapSpec,         // optional per-view bindings / overrides
}
```

Then your root render becomes dead simple:

```rust
impl Render for ScriptListApp {
    fn render(&mut self, window: &mut Window, cx: &mut Context<Self>) -> impl IntoElement {
        let spec = match self.current_view {
            AppView::ScriptList => self.script_list_spec(cx),
            AppView::ArgPrompt { .. } => self.arg_prompt_spec(cx),
            // ...
        };

        AppShell::render(spec, &self.shell_runtime, window, cx)
    }
}
```

That one change is what stops the “every prompt is a snowflake” problem.

---

## Key Questions (direct answers)

### 1) Should AppShell own the focus handle, or receive it as a parameter?

**Receive it (or receive a small `ShellFocus` bundle). Don’t have AppShell create/own focus handles unless AppShell is a persistent View.**

Practical rule:

* **Focus handles should be created once per window** and stored in your root state (or `ShellRuntime`).
* AppShell should *use* them (track focus, optionally request focus) but not “manufacture” them on demand.

I’d introduce:

```rust
pub struct ShellFocus {
    pub shell: FocusHandle,         // root / track_focus target
    pub header_input: FocusHandle,  // if header has input
    pub content: FocusHandle,       // optional: list/editor/etc.
}
```

And keep it inside `ScriptListApp` as `self.shell_focus`.

**Avoid doing “focus enforcement” inside `render()`**. Focus changes should happen:

* when `current_view` changes
* when the window is shown
* when an overlay opens/closes

Meaning: you set a flag like `pending_focus: Option<FocusTarget>` on transitions, then consume it in an event/hook that runs once (or via a “defer”/post-render mechanism you already use). Re-focusing every render is exactly how you get cursor jumps and jitter.

---

### 2) Should the shell handle keyboard events (global shortcuts like Cmd+K)?

**Yes, but only as a routing layer. It should not own the business logic.**

What works well:

* Shell registers a **root key handler** for:

  * Esc (close/cancel/back)
  * Cmd+K / Cmd+P / Cmd+Shift+P (command palette/actions)
  * Cmd+Enter (run)
  * Cmd+, (settings)
* Shell converts keystrokes into **typed actions** (enums), then calls back into the app to handle them.

Example:

```rust
pub enum ShellAction {
    Cancel,
    Run,
    OpenActions,
    FocusSearch,
    Next,
    Prev,
}
```

Then:

* `ScriptListApp` decides what `Cancel` means in each `AppView` (close panel vs back to script list vs close overlay).
* Prompt views can override or add bindings in the `ShellSpec.keymap` (e.g., editor prompt treats Tab differently).

**Priority order I’d enforce:**

1. Active overlay (actions dialog, confirm modal) gets first crack
2. Content view gets second crack (editor/list/prompt)
3. Shell gets last crack (global)

This keeps “global” shortcuts from breaking prompts.

---

### 3) How to handle prompts that need no header (e.g., HUD notifications)?

You want two related knobs:

1. `header: None`
2. `chrome.mode: ChromeMode`

I’d define:

```rust
pub enum ChromeMode {
    FullFrame,     // rounded bg + shadow + padding + optional header/footer
    MinimalFrame,  // rounded bg + shadow, but no divider/padding is tighter
    ContentOnly,   // no bg/shadow; just pass-through layout (rare)
}
```

HUD notifications typically want **MinimalFrame**:

* no header
* no divider
* no footer
* reduced padding
* maybe different radius/shadow

So you can still reuse vibrancy + shape + theming without dragging in the “launcher chrome”.

---

### 4) Should divider be optional/configurable?

**Yes. Make it default-on only when it makes sense.**

Rule of thumb:

* If there is a header and the content is “list/editor region”, default to divider ON.
* If header is absent, divider is OFF.
* If a prompt is visually self-contained and already has a strong separation (rare), allow OFF.

Implementation:

```rust
pub enum DividerSpec {
    None,
    Hairline,
    // optionally: Gradient or Thick, but keep it simple unless design demands it
}
```

And put it in `ChromeSpec`.

---

### 5) Should shell emit layout measurements for debug grid overlay?

**Only in debug builds / behind a feature flag. And don’t rely on runtime measurement if you can avoid it.**

If your header/footer have known fixed heights (or “token heights”), you can compute the regions cheaply without expensive measurement hooks:

* header height = `HEADER_HEIGHT` if present
* footer height = `FOOTER_HEIGHT` if present
* content rect = window rect minus those

If you truly need measured layout (because header can wrap, or footers can grow), do it behind:

* `#[cfg(debug_assertions)]` or `--features shell_debug_overlay`

And keep it off in release. Debug overlays can accidentally become a perf tax if they introduce extra layout passes or extra element trees.

---

## One important correction to your proposed config design

Your sample uses:

```rust
pub on_change: Option<Box<dyn Fn(String)>>
pub on_click: Box<dyn Fn()>
```

In a performance-critical immediate-mode UI, **that’s a trap**:

* `Box<dyn Fn…>` allocates (often per render)
* dyn dispatch + heap churn
* hard to keep “stable identity” across frames (can affect diffing/reconciliation depending on GPUI internals)

### Better options (pick one)

#### Option A: Use GPUI listeners/callback types

If GPUI exposes a cheap cloneable callback type (or you can wrap it), do:

* `on_click: Callback<()>`
* `on_change: Callback<SharedString>`

…and build those callbacks with `cx.listener(...)` from the calling view.

#### Option B: Use actions instead of closures (my preference for this app)

Make configs data-only and let them emit an enum action:

```rust
pub enum HeaderAction {
    Submit,
    OpenActions,
    TogglePreview,
    // ...
}

pub struct ButtonSpec {
    pub label: SharedString,
    pub shortcut: Option<SharedString>,
    pub action: HeaderAction,
}
```

Then Shell just does `cx.emit(action)` (or calls a handler) and your root view routes it.

This gives you:

* zero allocation configs
* consistent keyboard + click behavior (same action)
* easier testing

Given your app already has “actions dialog overlay” and lots of key handling, **actions unify everything**.

---

## Focus management: what “centralized” should mean

Centralized doesn’t mean “shell micromanages focus every render”.

Centralized should mean:

* There is **one place** that decides “when view X is active, focus goes to Y”
* Views can request a focus target in their `ShellSpec` (`focus_policy`)
* The root applies it **once per transition**

Example policies:

```rust
pub enum FocusPolicy {
    Preserve,               // don’t steal focus on view swap
    HeaderInput,
    Content,
    Explicit(FocusHandle),
}
```

Then each spec chooses the right one:

* Script list: `HeaderInput` (search)
* Arg prompt: `HeaderInput`
* Editor prompt: `Content` (editor)
* HUD notification: `Preserve` (don’t steal)

This alone will delete most of your current “~100 lines of focus checks”.

---

## Vibrancy / transparency: unify without repainting the world

Unify the expensive style computations too.

### Do this

* Put “theme-derived computed style” in a cached struct stored in your root or shell runtime:

```rust
pub struct ShellStyleCache {
    pub last_theme_revision: u64,
    pub frame_bg: Rgba,
    pub shadow: SmallVec<[Shadow; 2]>,
    pub radius: Px,
    // ...
}
```

Recompute only when theme revision changes (or when opacity settings change).

### Don’t do this

* recompute hex → rgba, build shadow vecs, etc. inside every prompt render branch

Even if each is “small”, it adds up in a 60fps list and makes profiling annoying.

---

## Concrete module layout I’d ship

```
src/app_shell/
  mod.rs                // public exports
  shell.rs              // AppShell::render + core frame layout
  chrome.rs             // ChromeSpec, DividerSpec, ChromeMode
  header.rs             // HeaderSpec, InputSpec, ButtonSpec + renderer
  footer.rs             // FooterSpec + renderer
  focus.rs              // ShellFocus, FocusPolicy, focus application helper
  keymap.rs             // ShellAction, KeymapSpec, routing helper
  style.rs              // style cache + theme->style conversion
  README.md             // usage patterns + examples
```

This keeps “what it looks like” separated from “what it does”.

---

## Migration plan that won’t blow up your app

1. **Introduce AppShell frame only**

   * background, shadow, radius, padding
   * content slot
   * no header/footer yet
     This gives immediate vibrancy unification.

2. **Introduce Header renderer**

   * migrate *only* ScriptList header first
   * delete the duplicated header code there

3. **Add Footer renderer**

   * start with hints/shortcuts (cheap and high value)

4. **Convert one prompt at a time to return `ShellSpec`**

   * ArgPrompt, PathPrompt, EditorPrompt first (most duplicated header work)
   * keep the big match for now; just change each branch to build a spec

5. **Centralize focus transitions**

   * remove per-view focus enforcement
   * apply `FocusPolicy` once on `current_view` changes

6. **Centralize global key routing**

   * shell registers keys → emits `ShellAction`
   * root routes based on current view / overlays

This is incremental and keeps you shippable at each step.

---

## Bottom line recommendations (the “tell it like it is” version)

* **Don’t let `AppShell` own focus handles** unless you make it a persistent View. Pass stable handles in from the window root.
* **Do put global keyboard routing in the shell**, but route to actions and keep business logic in the app.
* **Support headerless prompts via a `ChromeMode`**, not by forcing every view into the same shape.
* **Make the divider optional**, default based on header presence.
* **Debug layout measurement is fine, but only behind debug/feature flags**—and prefer deterministic sizing over measurement hooks.

If you want, I can also sketch the exact `ShellSpec` + `HeaderSpec` types in a way that avoids heap allocations (SmallVec, shared strings, action enums) and plugs cleanly into GPUI’s listener/action patterns.
