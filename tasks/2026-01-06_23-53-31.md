You’re on the right track, but there are a few “this will bite you immediately” issues in the proposed API, and a couple of strategic choices that will save you a lot of work (and bugs) if you bake them in now.

## The biggest fixes to make before you start coding

### 1) Don’t invent a second Lucide enum

You already have a Lucide-ish enum: `gpui_component::IconName`. Duplicating it as `LucideIcon` creates churn (and you still have to keep the file-name mapping in sync).

**Do this instead:**

* Make your unified type store the existing enum for Lucide:

  * `IconRef::Lucide(gpui_component::IconName)`
* Provide conversions so call sites stay clean:

  * `impl From<gpui_component::IconName> for IconRef { ... }`
  * `impl From<EmbeddedIcon> for IconRef { ... }`

This alone fixes your “two IconName enums conflict” problem because your custom icons stop being named `IconName`. Rename your local `IconName` to `EmbeddedIcon` (or `AppIcon`, `DesignIcon`, etc.). Also note: gpui-component explicitly supports making your own icon enum via `IconNamed` if you want it. ([longbridge.github.io][1])

### 2) Your `IconRef::render(...) -> impl IntoElement` won’t compile as written

In Rust, `match` arms returning different element types can’t unify under `impl Trait` unless they’re actually the same concrete type.

**Fix:** return a type-erased element (GPUI has `AnyElement` patterns; if your codebase already uses one, use that), or make `IconView` do the type-erasure at the boundary.

Practical rule:

* **Vector icons** (`Icon`) and **raster icons** (`img`) are different element types → you need an “erased” return type somewhere.

### 3) Treat icons as two classes: “tintable vectors” vs “full-color images”

You’re trying to apply one styling model (color, weight, filled, opacity) to everything. That’s fine as an API, but **the behavior needs to be defined**:

* **Lucide / Embedded SVG / SF Symbols**: generally “tintable” (monochrome / template-style)
* **App icons / remote logos / PNG/JPG**: generally **full-color** and should **not** be tinted by default

Also, GPUI/Zed currently has limitations around rendering multi-color SVG via `svg()` — it tends to rely on `text_color(...)` and becomes monochrome; and “original SVG colors” are an active pain point. ([GitHub][2])
So: if you want “logos from scripts” to actually look like logos, plan to render them as images (or rasterize SVG yourself) rather than relying on `svg()` tinting.

### 4) Lean on gpui-component where it already solves problems

You’re about to rebuild functionality gpui-component already gives you:

* `Icon` supports size, color, rotation, and can render from a custom SVG path in assets. ([longbridge.github.io][1])
* `img(...)` / Image component supports URLs, local files, SVG sources, and has patterns for fallback/loading. ([longbridge.github.io][3])

Your unified system should primarily be a *routing layer*:

* If it’s a Lucide/asset SVG → render via `gpui_component::Icon`
* If it’s a URL/file/image bytes → render via `img(...)` (or gpui-component Image wrapper)
* Only custom-build the parts gpui-component doesn’t cover: **SF Symbols** + **app bundle icons** + **policy/caching glue**.

---

## A tighter `IconRef` that fits GPUI realities

Here’s the shape I’d aim for (conceptually):

* **Identity** (where the icon comes from)
* **Style** (how to render/tint/size it)
* **Resolution** (some sources need loading/caching)

### Suggested `IconRef` variants (practical, not academic)

* `Lucide(gpui_component::IconName)`
* `SFSymbol(SharedString)` (macOS only, resolves to an image)
* `Embedded(EmbeddedIcon)` (your curated app icons, probably asset SVG paths unless you truly need binary embedding)
* `AssetSvg(SharedString)` (for “any svg in assets by path”)
* `File(PathBuf)` (for scripts, probably restricted)
* `Url(SharedString)` (for scripts, probably gated)
* `AppBundleId(SharedString)` or `AppPath(PathBuf)` (macOS)
* `InlineSvg(SharedString)` (only if you really need it; otherwise encourage file/url)

**Key idea:** You want at least one variant that is “arbitrary svg by path” and one variant that is “arbitrary image source”. This prevents you from constantly changing enums as new needs appear.

### Style model tweak: split “color intent” from “raw u32”

Instead of `Option<u32>`, I’d strongly consider:

* `IconColor::Inherit` (default)
* `IconColor::Token(ThemeColorToken)` (primary, muted, danger, etc.)
* `IconColor::Fixed(Color)` (hex)
* `IconColor::None` (explicit “don’t tint”, useful for app icons)

Because “scripts pass a hex” is fine, but *most of your UI should use tokens* so it auto-themes.

---

## SF Symbols integration: what I’d do

### Should you bundle anything?

No. Use the system API.

* `NSImage(systemSymbolName:accessibilityDescription:)` is **macOS 11.0+**. ([Apple Developer][4])
* `NSImage.SymbolConfiguration` (size/weight/scale config) is also **macOS 11.0+**. ([Apple Developer][5])

If you want SF Symbols, the clean line is: **minimum macOS 11** (or “feature works only on macOS 11+ with fallback elsewhere”).

Also: Apple treats “system-provided images and symbols” as licensed under Apple’s SDK terms, and explicitly restricts using them in **app icons, logos, or trademark use**. 
So bundling/exporting/repackaging SF Symbols is exactly the kind of thing you don’t want to do casually.

### Rendering approach

For SF Symbols, you’re not “rendering an SVG”, you’re **asking AppKit for an `NSImage`**, configuring it, then converting to a GPU texture / GPUI image element.

Two practical points:

* Cache by **(name, size, weight, scale, appearance?)**
* Prefer the OS to handle template rendering; don’t manually recolor unless you must (you’ll fight light/dark/contrast behaviors)

### Listing SF Symbols

There is **no public “list all symbols” API** you can rely on. So don’t build your UX around “we can enumerate everything”.

Instead, for an icon picker:

* Provide a search field where the user types a symbol name
* Live preview by attempting to load that name
* Add a curated “popular symbols” list you maintain

---

## Caching: what to cache, and how big

### What’s worth caching

* **App bundle icons** (expensive lookup + image decode + texture upload)
* **URL images** (network + decode + texture upload)
* **File images** (decode + texture upload)

What’s usually *not* worth caching yourself:

* Lucide/asset SVG via `Icon` — it’s cheap enough and/or already handled in your asset pipeline, unless profiling proves otherwise.

### Cache sizing: give yourself a real budget

A single RGBA texture is roughly:

`size_px * size_px * 4 bytes`

Examples:

* 32×32 ≈ 4 KB
* 64×64 ≈ 16 KB
* 128×128 ≈ 64 KB
* 256×256 ≈ 256 KB

If you cache 300 app icons at 64px: ~4.8 MB just for raw pixels (plus overhead).
If you cache 300 at 128px: ~19.2 MB (plus overhead).

**Practical starting point:**

* **32 MB** raster icon budget (app icons + remote icons)
* LRU eviction by “estimated bytes”
* Separate “negative cache” so failures don’t spam the OS/network repeatedly

Then you tune after profiling.

### Don’t key the cache on color unless you truly need to

If you tint vector icons at draw time, you don’t want a separate cached texture per color.
For raster icons, if you support tinting, treat tinted as a separate cached output — but default behavior should be “no tint” for app icons.

---

## Animated icons (Lottie): tell it like it is

Don’t do this in your base icon system right now.

* It expands scope massively (timing, invalidation, frame generation, GPU uploads).
* GPUI itself has had limitations around animated image frames historically (multi-frame formats not fully supported). ([GitHub][6])

If you want animation, start with what you can do cheaply:

* A “spinner” icon where you rotate a normal vector icon over time (your UI loop handles the rotation)
* Leave Lottie as a separate feature module later

---

## Fallback strategy: define it as a first-class behavior

You don’t want every call site to invent its own fallback.

Do it centrally with a predictable policy:

* `SFSymbol("gear")`:

  * if macOS 11+ and symbol exists → render
  * else → fallback to `Lucide(IconName::Settings)` or `Embedded(Gear)`
* `App(bundle_id)`:

  * if app found → render
  * else → fallback to `Lucide(IconName::AppWindow)` (or whatever)
* `Url(...)`:

  * show placeholder while loading
  * if fails → fallback icon and mark negative cache for N minutes

Make sure failures don’t continuously retry every render. That’s where “negative cache with TTL” matters.

---

## Scripts and custom icon sets: yes, but with guardrails

### What I would allow by default

* `lucide:trash`
* `sf:gear` (macOS only)
* `app:com.apple.finder`
* `file:relative/path.svg` (relative to the script directory only)
* `data:<svg…>` (only if you trust the script)

### What I would NOT enable by default

* Arbitrary remote URLs, because:

  * privacy/tracking (every list render can phone home)
  * performance variability
  * security surface (even SVG is a minefield if you ever allow references)

Instead:

* Put “remote icons” behind a user setting: “Allow network icons from scripts”
* Enforce `https` only
* Add a small disk cache + ETag/If-Modified-Since if you go that route

### “Custom icon sets”

Yes, but make it explicit:

* Users register icon packs in settings (trusted paths)
* Scripts can reference `set:<pack>:<name>`
* Scripts do **not** get to globally install packs without user consent

That prevents a script from polluting the namespace or spoofing UI affordances.

---

## Icon search / browser: what’s realistic

### Lucide / Embedded

Easy:

* enumerate `gpui_component::IconName` (whatever curated set you ship)
* enumerate `EmbeddedIcon`
* provide fuzzy search and preview

Lucide naming also has aliases (“edit-2” vs “pen”, etc.), so accept aliases in parsing/search if you want a good UX. ([Lucide][7])

### SF Symbols

Don’t promise a full catalog unless you’re willing to ship/maintain a symbol-name database and deal with licensing ambiguity.
Instead:

* searchable input + preview
* curated “common” list

---

## Direct answers to your Key Questions

### 1) Bundle SF Symbols font, or require macOS 11+?

Require **macOS 11+** for SF Symbols rendering via AppKit APIs. That’s the clean line, and the APIs you need are macOS 11+. ([Apple Developer][4])
Also, Apple’s SDK terms around “system-provided images and symbols” include restrictions (not for app icons/logos/trademark use). 
So: don’t bundle the font/assets; rely on the OS and fall back elsewhere.

### 2) How large should the icon cache be?

Start with **32 MB for raster icons** (app icons + remote/file images), LRU by estimated bytes. Then profile.
If you’re showing big grids/previews a lot, bump to 64 MB.

### 3) Support animated icons (Lottie)?

Not in the unified icon system initially. Do a rotating spinner icon if you need motion. Multi-frame/animated image support is not something I’d bet your icon architecture on. ([GitHub][6])

### 4) How to handle icon fallbacks?

Make it central and deterministic:

* source-specific fallback (SF → Lucide, App → Embedded, URL → placeholder → fallback)
* negative caching with TTL to avoid repeated failures

### 5) Should scripts be able to define custom icon sets?

Yes, but only via **user-registered packs** or script-local files. Remote icons should be opt-in and constrained.

---

## One last “don’t skip this” migration detail

Because you’re already using gpui-component heavily, the fastest migration is:

1. Build `IconRef` + `IconStyle` + `IconView`
2. Add `impl From<gpui_component::IconName> for IconRef`
3. Update shared components (`Button`, list items, menus) to accept `impl Into<IconRef>` (or `IconRef` directly)
4. Keep the actual renderers thin wrappers around:

   * `gpui_component::Icon` for tintable vectors ([longbridge.github.io][1])
   * `img(...)` / Image component for images and URLs ([longbridge.github.io][3])
5. Only then add SF Symbols + app icon loader/caches

That gets you “one icon API everywhere” quickly without rewriting your world.

If you want, I can sketch a concrete `icons/mod.rs` layout (types + conversions + parser + fallback policy + cache keys) that matches GPUI/gpui-component idioms you’re already using.

[1]: https://longbridge.github.io/gpui-component/docs/components/icon "Icon | GPUI Component"
[2]: https://github.com/zed-industries/zed/discussions/45880 "Support color in SVG · zed-industries zed · Discussion #45880 · GitHub"
[3]: https://longbridge.github.io/gpui-component/docs/components/image "Image | GPUI Component"
[4]: https://developer.apple.com/documentation/appkit/nsimage/init%28systemsymbolname%3Aaccessibilitydescription%3A%29?language=objc&utm_source=chatgpt.com "imageWithSystemSymbolName:accessibilityDescription:"
[5]: https://developer.apple.com/documentation/appkit/nsimage/symbolconfiguration?utm_source=chatgpt.com "NSImage.SymbolConfiguration"
[6]: https://github.com/zed-industries/zed/issues/9993?utm_source=chatgpt.com "GPUI: Support for Animated Images with Multiple Frames"
[7]: https://lucide.dev/guide/advanced/aliased-names?utm_source=chatgpt.com "Aliased Names"
