Here’s the clean way to make the **actions window’s shortcuts work even when the main window has focus**:

## What “fixed” should mean

When the **Cmd+K actions popup is visible**:

* Any shortcut shown in that popup (e.g. `⌘1`, `⌘⇧P`, etc.) should trigger the corresponding action **even if the main window is the focused window**.
* Those shortcuts should **win over** whatever the main window would normally do with the same keystroke.
* The main window’s own key handlers (script list navigation, etc.) should **not steal** keys while the actions popup is open.

This is a routing + priority problem, not a “register more shortcuts” problem.

---

## The core problem (in one sentence)

Your shortcut matching is currently tied to **window focus / local context**, so when the actions popup is visible but not focused, its context isn’t active and the main window consumes the keystrokes first.

---

## The fix pattern

Treat the actions popup as a **modal/overlay shortcut context**:

1. When the actions popup becomes visible, **push an overlay context** like `ShortcutContext::ActionsDialog` onto the global context stack.
2. Register (or re-register) all shortcuts visible in the popup under that context.
3. When a key is pressed anywhere, match shortcuts using **overlay contexts first**, then fall back to the normal main-window contexts.
4. Ensure main-window “widget key handlers” (like script list navigation) **bail out early** when the actions popup is visible.

That’s it. Everything else is implementation detail.

---

## File-by-file implementation blueprint

Below is what you should change in the files you listed. I’m using Rust-ish pseudocode shaped like what these modules usually look like; you’ll adapt names to your actual types.

---

# 1) `src/shortcuts/context.rs` — add an overlay/modal layer

### Goal

Allow a context to be active **without focus**, and always have it checked first.

### Minimal structure that works

```rust
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub enum ShortcutContext {
    Global,
    MainWindow,
    ScriptList,
    // ...
    ActionsDialog, // <-- add this
}

#[derive(Default, Debug)]
pub struct ContextStack {
    base: Vec<ShortcutContext>,      // focus-driven (existing behavior)
    overlays: Vec<ShortcutContext>,  // modal overlays (new)
}

impl ContextStack {
    // existing push/pop for base contexts
    pub fn push(&mut self, ctx: ShortcutContext) {
        if self.base.last().copied() != Some(ctx) {
            self.base.push(ctx);
        }
    }

    pub fn pop(&mut self, ctx: ShortcutContext) {
        if self.base.last().copied() == Some(ctx) {
            self.base.pop();
        }
    }

    // NEW: overlays
    pub fn push_overlay(&mut self, ctx: ShortcutContext) {
        if !self.overlays.contains(&ctx) {
            self.overlays.push(ctx);
        }
    }

    pub fn pop_overlay(&mut self, ctx: ShortcutContext) {
        self.overlays.retain(|c| *c != ctx);
    }

    pub fn has_overlay(&self, ctx: ShortcutContext) -> bool {
        self.overlays.contains(&ctx)
    }

    /// Iteration order matters: overlays first (top-most wins), then base stack.
    pub fn iter_priority(&self) -> impl Iterator<Item = ShortcutContext> + '_ {
        self.overlays
            .iter()
            .rev()
            .copied()
            .chain(self.base.iter().rev().copied())
    }
}
```

**Non-negotiable detail:** matching must use `iter_priority()`, not the base stack alone.

---

# 2) `src/shortcuts/registry.rs` — make matching consult overlays first

### Goal

When actions dialog is open, its shortcuts beat main window shortcuts.

If you already have something like `match_shortcut(event, &context_stack)`, update it so it iterates contexts using `iter_priority()`.

Example:

```rust
impl ShortcutRegistry {
    pub fn match_event(
        &self,
        event: &KeyEvent,
        ctx_stack: &ContextStack,
    ) -> Option<RegisteredAction> {
        for ctx in ctx_stack.iter_priority() {
            if let Some(hit) = self.match_in_context(event, ctx) {
                return Some(hit);
            }
        }
        None
    }

    // Strongly recommended for dynamic contexts:
    pub fn clear_context(&mut self, ctx: ShortcutContext) {
        self.bindings.retain(|binding| binding.context != ctx);
    }
}
```

If you don’t add `clear_context`, you’ll end up with **stale popup shortcuts** that keep firing after the popup is closed.

---

# 3) `src/actions/dialog.rs` — push/pop overlay context + register popup shortcuts

### Goal

When the actions popup is visible, the app’s global shortcut system “knows” it.

You need two things here:

## A) Overlay context lifecycle

When dialog opens/closes:

```rust
impl ActionsDialog {
    pub fn set_visible(
        &mut self,
        visible: bool,
        ctx_stack: &mut ContextStack,
        shortcuts: &mut ShortcutRegistry,
    ) {
        if self.visible == visible {
            return;
        }
        self.visible = visible;

        if visible {
            ctx_stack.push_overlay(ShortcutContext::ActionsDialog);
            self.register_visible_shortcuts(shortcuts);
        } else {
            ctx_stack.pop_overlay(ShortcutContext::ActionsDialog);
            shortcuts.clear_context(ShortcutContext::ActionsDialog);
        }
    }
}
```

## B) Register the shortcuts shown in the popup under `ActionsDialog`

This is the thing that actually makes the shortcuts work while the main window has focus:

```rust
impl ActionsDialog {
    fn register_visible_shortcuts(&self, shortcuts: &mut ShortcutRegistry) {
        shortcuts.clear_context(ShortcutContext::ActionsDialog);

        for item in &self.items {
            if let Some(sc) = &item.shortcut {
                shortcuts.register(
                    ShortcutContext::ActionsDialog,
                    sc.clone(),
                    item.action_id, // or closure / command enum
                );
            }
        }
    }

    // If items change while visible (filtering, selection context, etc.)
    pub fn on_items_changed(&mut self, shortcuts: &mut ShortcutRegistry) {
        if self.visible {
            self.register_visible_shortcuts(shortcuts);
        }
    }
}
```

**Important:** do NOT register these as “Global” shortcuts, or they’ll be active all the time.

---

# 4) `src/app_actions.rs` — route key events through the registry *before* widget handlers

### Goal

Centralize “who gets the keystroke” and make the actions dialog win when open.

In whatever top-level key handler exists (often something like `handle_key_event()`):

```rust
pub fn handle_key_event(&mut self, event: &KeyEvent) -> bool {
    // If actions popup is visible, make sure its context is active (overlay) already.
    // (Ideally handled in dialog.rs open/close; this is just defensive.)

    if let Some(hit) = self.shortcuts.match_event(event, &self.shortcut_context_stack) {
        self.dispatch_action(hit.action);
        return true; // CONSUME: don't let script list/editor also act
    }

    false
}
```

Then ensure your UI event flow calls this **early** (before the script list, editor, etc. do their own key handling).

If your current flow is reversed (widget handles first, then global shortcuts), you’ll keep losing keys to the main window.

---

# 5) `src/render_script_list.rs` — don’t steal keys while the popup is visible

### Goal

Prevent script list navigation/selection handlers from consuming keys meant for the actions dialog.

At the start of your script-list key handler:

```rust
pub fn handle_key(&mut self, event: &KeyEvent, app: &AppState) -> bool {
    if app.actions_dialog.visible() {
        return false; // let the global handler / actions dialog handle it
    }

    // existing script list key handling...
}
```

This is the “stop stepping on the modal overlay” rule.

---

## One extra thing you’ll probably need (but didn’t list)

If the actions popup shows shortcuts that depend on *current selection / current app state* (very likely), you must re-register popup shortcuts when that state changes while the popup is open.

Where that lives depends on your architecture (maybe `src/actions/builders.rs` or wherever the items are rebuilt). The rule is simple:

* If the popup contents change and the popup is visible → call `register_visible_shortcuts()` again.

Otherwise you’ll press a shortcut shown in the UI and trigger an old action mapping.

---

## Quick verification checklist

1. Open main window, make sure script list is focused.
2. Open actions popup (Cmd+K).
3. Without clicking the popup (so main window still has focus), press a shortcut shown inside the popup.

   * Expected: the popup’s action fires.
   * Expected: script list does **not** also react.
4. Close popup.
5. Press the same shortcut again.

   * Expected: it does **not** trigger the popup action anymore.

If step 5 fails, you forgot to `clear_context(ActionsDialog)` on close.

---

## The blunt truth

If you don’t add a real notion of **modal/overlay shortcut context** (or equivalent priority layer), you’ll keep chasing edge cases forever. This is one of those situations where the correct fix is structural, not incremental.

If you paste the actual contents of the relevant modules (especially `shortcuts/context.rs`, `shortcuts/registry.rs`, and your top-level key event handler), I can rewrite the above into exact diffs that match your concrete types and naming.
