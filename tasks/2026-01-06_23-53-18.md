You can get **tiling, moving/resizing, focus cycling, window state changes, and solid multi‑monitor support** with *public* macOS APIs (Accessibility + AppKit).

But **moving other apps’ windows between Spaces is the outlier**: there is no supported public API for it, AppleScript doesn’t expose it, and “real” solutions typically rely on **private WindowServer/Dock SPI** (often via Dock injection) with real fragility and, in some cases, SIP compromises. ([macscripter.net][1])

Below is the practical way to ship this bundle without painting yourself into a corner.

---

## 0) Reality check: what’s actually doable

### ✅ Reliable (ship it)

* **Enumerate windows** + bounds + minimized/focused + app identity (AX + NSRunningApplication)
* **Focus / raise / cycle windows** (AXRaise + NSRunningApplication.activate)
* **Move / resize / tile** (AXPosition + AXSize)
* **Minimize / close / fullscreen toggle** (AX attributes/buttons/actions)
* **Multi‑monitor move + tile on specific display** (NSScreen visible frames + coordinate conversion)

### ⚠️ “Best effort” (works often, but expect edge cases)

* “Maximize” semantics (green button behavior differs per app; better to implement “maximize = fill visible frame” yourself)
* Non‑resizable windows and special panels (dialogs, sheets, Electron quirks)

### ❌ Not really supported (plan for optional backend)

* **Move windows between Spaces** (especially for third‑party apps) without private APIs or external tooling ([macscripter.net][1])

That should directly shape your architecture: **Spaces is a separate backend with an “unsupported” default**, while everything else is first‑class.

---

## 1) Architectural recommendation: “Backends + capabilities”, not one monolith

Create a thin “public” API (your `WindowManager` / `SpaceManager` traits) and plug in backends at runtime:

### Core idea

* **AX backend**: all window queries + move/resize/focus/state (this is your workhorse)
* **Spaces backend**: optional, can be:

  * `Unsupported` (default)
  * `ExternalTool` (e.g., yabai if installed/configured)
  * `PrivateSPI` (if you ever choose to go there, gated behind compile + runtime flags)

Expose **capabilities** so the UI/SDK can degrade gracefully instead of failing mysteriously:

```rust
#[derive(Debug, Clone, Copy)]
pub struct WindowCapabilities {
    pub can_move: bool,
    pub can_resize: bool,
    pub can_minimize: bool,
    pub can_close: bool,
    pub can_fullscreen: bool,
    pub supports_space_move: bool, // almost always false unless optional backend
}
```

Your `EnhancedWindowInfo` should carry `can_move/can_resize` computed from Accessibility **settable checks**. Apple provides `AXUIElementIsAttributeSettable` specifically for this. ([Apple Developer][2])

---

## 2) Coordinate system: lock this down early (or you’ll suffer)

### The key gotcha

Accessibility window positioning uses **top-left global screen coordinates**: `kAXPositionAttribute` is “top-left corner”, and **(0,0) is top-left of the screen**.

But AppKit’s `NSScreen.visibleFrame` is in AppKit’s coordinate system (bottom-left origin).

### Practical approach

* Internally, standardize your `WindowBounds` to **AX coordinates** (top-left origin, y grows downward). That matches what you set/get via AX.
* Build `DisplayInfo.visible_bounds` in that same AX coordinate space by:

  1. Getting `NSScreen.visibleFrame` (because it **already excludes dock + menu bar**). ([Apple Developer][3])
  2. Converting it into AX space using the main screen height “flip” transform (and using global screen coordinates, not per-screen local coords).

This avoids “dock math” and respects left/right/bottom docks automatically via `visibleFrame`. ([Apple Developer][3])

---

## 3) Window tiling/positioning that won’t fight macOS

### Use `visibleFrame`, not raw display bounds

`NSScreen.visibleFrame` is the correct base rectangle for tiling because it excludes menu bar + dock. ([Apple Developer][3])

### Add padding/gap now (people will ask)

Even if you default to 0, define:

* `outer_margin` (space between window and screen edge)
* `inner_gap` (space between tiled windows)

It makes your tiling feel like Rectangle/Magnet and prevents “exact edge” weirdness.

### Clamp to constraints

Before setting a size, attempt to read:

* `kAXMinSizeAttribute`, `kAXMaxSizeAttribute` (if available)
* then clamp your requested bounds
  This reduces failures on apps with strict minimum sizes.

### Order of operations matters

A lot of apps behave better if you:

1. Set size
2. Then set position
   …instead of position then size.

---

## 4) Focus switching and cycling: ditch AppleScript if you can

AppleScript focus often triggers Automation permissions and is slower/flakier. If you already have AX:

**Recommended focus algorithm**

1. Get target window AX element
2. Activate owning app via `NSRunningApplication.activateWithOptions`
3. Perform `kAXRaiseAction` on the window (and/or set focused window attribute)

This is typically faster and avoids AppleScript prompts.

**Cycle windows**

* If cycling within an app: get that app’s `kAXWindowsAttribute`, find focused, pick next, raise it.
* If cycling globally: keep your own MRU list (best UX), otherwise sort by z-order-ish heuristics.

Stage Manager can affect “which windows show when switching apps” (there’s even a Stage Manager setting for showing windows “All at Once” vs “One at a Time”). So always do a direct raise on the specific window you want, not just “activate app”. ([Apple Support][4])

---

## 5) Window state actions: make them deterministic

Don’t conflate macOS’s “green button” behavior with your “maximize”.

### Suggested semantics

* **Maximize**: set bounds = display.visible_bounds (your deterministic maximize)
* **AlmostMaximize**: 90–95% of visible_bounds centered (good with Stage Manager)
* **Fullscreen**: toggle AX fullscreen attribute/button
* **Minimize**: set minimized attribute or press minimize button
* **Close**: press close button

This gives users predictable outcomes across apps, instead of “sometimes it zooms, sometimes it goes fullscreen”.

---

## 6) Multi-monitor: pick the display by overlap, not by “center point”

For `display_id`:

* Compute intersection area between window rect and each display’s visible rect
* Take the display with the largest overlap

This avoids the “window mostly on left display but considered on right” problem (this is a real class of bugs).

For “move to display”:

* Preserve relative position within the source display’s visible rect
* Apply that relative position to target display’s visible rect
* Clamp so the window remains fully visible (or at least keep title bar visible)

Also define “adjacent display” ordering by `visible_bounds.x` (left-to-right), with tie-breaker on y.

---

## 7) Spaces: what you should actually do

### AppleScript “move window to Space” is not a real solution

There’s no native AppleScript API to assign a window to an arbitrary Space. Most “solutions” are hacks like “drag window while pressing ctrl+number”, which is not something you can reliably automate at scale. ([Stack Overflow][5])

### Private CGS/SkyLight SPI: high risk, often not enough by itself

The critical detail: the privileged WindowServer connection that can do “real” global window manipulation is effectively owned by **Dock**, and historically solutions involved **code injection into Dock**. ([cocoadev.github.io][6])

Tools like yabai call this out explicitly: to control spaces reliably they inject a “scripting addition” into Dock and require (partial) SIP disable for those features. ([GitHub][7])

So if Script Kit is meant to be a normal, user-friendly app, you probably **cannot** make “move other apps’ windows to space X” a dependable, default feature.

### What I recommend

Implement `SpaceManager` as **optional**:

1. **Default: Unsupported**

* `get_all_spaces()` returns empty or basic info (maybe just “current space index unknown”)
* `move_window_to_space` returns a clear “Not supported on this system” error

2. **Optional integration: External backend**

* If a user has yabai configured, Script Kit can *call it*.
* You gain robust Spaces support **without** you owning the Dock injection mess.
* You still must detect “is it available + configured” and report clear capability flags.

3. **If you still want private SPI**

* Gate behind:

  * compile-time feature flag
  * runtime “I accept breakage risk” setting
* Use runtime symbol lookup (`dlsym`) and never crash if missing.
* Expect it to break on macOS updates.

That gives you a clean product story:

* “Tiling, moving, resizing, focus, multi-monitor: built-in.”
* “Spaces: advanced mode / requires external tooling / experimental.”

---

## 8) Answers to your Key Questions

### 1) CGS private APIs vs AppleScript for Spaces?

**Neither is “safe”.** AppleScript can’t really do it natively; it devolves into brittle UI hacks. ([Reddit][8])
Private SPI can work but often assumes Dock-level privilege/injection; you inherit breakage risk and possibly SIP-related constraints. ([cocoadev.github.io][6])

**Recommendation:** ship Spaces as an optional backend (external tool integration first; private SPI only as “experimental”).

### 2) Windows that can’t be resized?

Detect it via `AXUIElementIsAttributeSettable` for `kAXSizeAttribute` (and `kAXPositionAttribute` for move). ([Apple Developer][2])
If `can_resize=false`, do:

* move-only (center, move to display, etc.)
* state actions (minimize/close/fullscreen) if available
* for “maximize”, either fail with a clear error or try “zoom/fullscreen button press” fallback

### 3) Should tiling respect dock position?

Yes, automatically, by using `NSScreen.visibleFrame` (it excludes dock + menu bar). ([Apple Developer][3])
Don’t re-implement dock detection; it’s a swamp.

### 4) Stage Manager enabled?

Don’t try to outsmart it. Assume:

* You can still resize/move windows.
* Stage Manager may regroup/reposition and has settings that affect how windows appear when switching apps (“All at Once” vs “One at a Time”). ([Apple Support][4])

Practical moves:

* Provide “AlmostMaximize” and “Center” presets (these feel better under Stage Manager)
* Always “raise specific window” when focusing/cycling (don’t rely on app activation alone)

### 5) Persist window positions/layouts?

**Not by default.** Automatic persistence tends to:

* fight user intent
* break when window IDs change
* break under Stage Manager / fullscreen spaces
* get weird across monitor changes

**Recommendation:**

* Provide explicit “Save Layout” / “Apply Layout” commands (scriptable)
* Store layouts keyed by bundle_id + display configuration hash
* Make it opt-in and “best effort”, not automatic

---

## 9) What to build next (high leverage order)

1. **Coordinate foundation**

* Define `WindowBounds` coordinate system (AX top-left)
* Implement AppKit↔AX conversion
* Implement `DisplayInfo` with AX-space visible bounds

2. **AX capability detection**

* `can_move/can_resize` via `AXUIElementIsAttributeSettable` ([Apple Developer][2])
* min/max size clamping if available

3. **Tiling + move/resize**

* `WindowPosition` → bounds_on_display(display.visible_bounds)
* `move_window(window_id, position)` (focused window convenience)

4. **State actions**

* minimize/close/fullscreen toggle via AX buttons/attributes

5. **Focus + cycling**

* replace AppleScript focus with NSRunningApplication + AXRaise
* app-local cycling first (best UX)

6. **Spaces backend scaffold**

* `SpaceManager` exists but defaults to Unsupported
* Add external integration later (or experimental SPI)

---

If you want, I can write the **exact Rust module skeleton** (traits, structs, conversion helpers, and the AX implementations for move/resize/focus/minimize/close/fullscreen), wired to your existing `window_control.rs` style—without touching Spaces yet—so Bundle 44 ships a big chunk of value immediately.

[1]: https://www.macscripter.net/t/script-for-moving-apps-to-different-spaces/75634?utm_source=chatgpt.com "Script For Moving Apps To **Different** Spaces - AppleScript"
[2]: https://developer.apple.com/documentation/applicationservices/1459972-axuielementisattributesettable?language=objc&utm_source=chatgpt.com "AXUIElementIsAttributeSettable"
[3]: https://developer.apple.com/documentation/AppKit/NSScreen/visibleFrame?utm_source=chatgpt.com "visibleFrame | Apple Developer Documentation"
[4]: https://support.apple.com/guide/mac-help/use-stage-manager-mchl534ba392/mac "Organize your Mac desktop with Stage Manager - Apple Support"
[5]: https://stackoverflow.com/questions/9775268/how-to-move-a-window-to-a-certain-desktop-with-applescript?utm_source=chatgpt.com "How to move a window to a certain desktop with AppleScript?"
[6]: https://cocoadev.github.io/HowtoControlOtherAppsWindows/ "HowtoControlOtherAppsWindows - CocoaDev"
[7]: https://github.com/koekeishiya/yabai/wiki/Disabling-System-Integrity-Protection "Disabling System Integrity Protection · asmvik/yabai Wiki · GitHub"
[8]: https://www.reddit.com/r/applescript/comments/1dx67gj/script_to_move_windows_between_desktop_spaces/?utm_source=chatgpt.com "Script to move windows between desktop spaces?"
