Below is how I’d ship this so it’s **centralized, deterministic, conflict-aware, customizable, and discoverable**, without turning the codebase into a pile of special cases.

## Decisions on your 5 key questions

### 1) Should scripts be able to override built-in shortcuts?

**Not implicitly.** Scripts can *declare* a shortcut, but they should not be allowed to silently steal core UI bindings.

**Recommended policy**

* **Built-ins win by default** in any context where they’re active.
* Script shortcuts are accepted as *candidates*, but if they conflict with an active built-in binding they become:

  * **Disabled with a warning**, or
  * **“Needs user resolution”** (preferred; show in the cheat sheet/settings).
* If a user *explicitly* assigns a script shortcut to a conflicting chord, that user override is respected (and the conflicting built-in becomes disabled/overridden in that overlapping context, per user intent).

This keeps the app predictable and prevents “I installed a script and now Cmd+K does something else” moments.

### 2) How to handle shortcuts that conflict with macOS system shortcuts?

You can’t solve this perfectly because users can remap system shortcuts and some combos never reach the app. So:

**Do two things:**

1. **Ship sane defaults** that avoid the biggest landmines:

   * macOS: ⌘Q, ⌘W, ⌘H, ⌘M, ⌘Tab, ⌘Space, ⌘⌥Esc, etc.
   * Windows: Alt+F4, Win+*, Ctrl+Alt+Del (obviously), etc.
2. **Warn (don’t block) user choices**:

   * If the user picks a known OS-reserved chord, show “May not work; reserved by the OS”.
   * For **global hotkeys**, you *will* get definitive registration errors—surface that clearly and keep the previous binding active.

### 3) Should there be a shortcut recording mode for customization?

**Yes.** Without it, customization is “power users only,” and you’ll never get consistency.

**Recording UX that works**

* Click a binding → it enters “Recording…” mode.
* Next non-modifier keystroke becomes the shortcut.
* Ignore pure modifier presses.
* **Esc** cancels recording.
* **Backspace/Delete** clears/disables the binding.
* Show both:

  * Display form (⌘⇧K / Ctrl+Shift+K)
  * Canonical string (“cmd+shift+k”)

### 4) How to persist user-customized shortcuts?

Use a **stable ID → shortcut string** map. Do not store by name. Names change.

**Recommended storage shape**

* `shortcuts.overrides: { [binding_id: string]: string | null }`

  * string = override value (e.g. `"cmd+k"`)
  * null = disabled (intentional)

You can store this in whatever config system you already have (file, config.ts export, json, etc.). The important part is the **data model**, not the file format.

### 5) Should shortcuts work when window is hidden (global hotkeys)?

Split the world cleanly:

* **In-app shortcuts**: only when app is focused / relevant view is active.
* **Global shortcuts**: OS-level registration; work when hidden/unfocused.

For script shortcuts:

* Default to **in-app only**.
* Allow scripts to request “global,” but require **explicit user enablement** (or a settings toggle), otherwise you’ll spam the OS with registrations and create conflicts.

## Fix the biggest architectural trap in your proposal: context overlap

Right now, `ShortcutContext::Global => true` means anything labeled “Global” will match everywhere—including when a text field/editor is focused. That will absolutely break editing/navigation.

### Use an ordered “context stack”, not a boolean “is_active”

Instead of `context_active(ctx) -> bool`, compute an ordered list of active contexts from most-specific to least, and search in that order.

Example:

* If actions dialog open:

  * `[ActionsDialog, Global]` (modal; underlying views don’t participate)
* If editor prompt focused:

  * `[Editor, AnyPrompt, Global]`
* If script list focused:

  * `[ScriptList, MainMenu, Global]`

Then `find_match` is deterministic:

1. Try bindings in `ActionsDialog`
2. Then `Editor`
3. …
4. Finally `Global`

This eliminates the “Global eats arrow keys in editor” class of bugs.

**Rule of thumb**

* Navigation keys like Up/Down/Enter/Escape should almost never be truly “Global.”
* They should be tied to the view that owns them (ScriptList, ActionsDialog, Terminal, etc.).

## Determinism: don’t iterate HashMaps for matching

Your `find_match` iterates `HashMap`s. HashMap iteration order is not stable; if two bindings collide, behavior becomes nondeterministic across runs.

**Make matching deterministic**

* Store bindings in a `Vec<ShortcutBinding>` in registration order (or use `IndexMap`).
* Keep a `HashMap<id, index>` for lookups.
* Optionally build an index for O(1) lookup:

  * `HashMap<(ShortcutContext, Shortcut), Vec<BindingId>>`

Even with a few hundred bindings it’s fine, but determinism matters more than speed here.

## Normalize keys properly (punctuation will bite you)

You currently treat `key` as a lowercase string. That’s fine, but you need canonicalization because GPUI key names and human strings won’t match 1:1.

### Add key normalization in both parse and match

You want one canonical key vocabulary internally: e.g.

* `enter`, `escape`, `tab`, `space`
* `up`, `down`, `left`, `right`
* `semicolon`, `slash`, `comma`, `period`
* `f1`…`f24`
* `a`…`z`, `0`…`9`

Also accept common synonyms in parsing (`esc`, `return`, `arrowup`, `;`, `/`, etc.).

### Don’t try to be clever with “cmd+?”

On US keyboards “?” implies Shift+Slash. But keyboard layouts differ, and GPUI likely gives you physical-ish key identifiers, not post-layout glyphs.

**Recommended**

* Support `cmd+slash` and `cmd+shift+slash`
* Accept `cmd+/` as a synonym for `cmd+slash`
* Avoid treating `?` as canonical.

## Display format: platform-aware

Your `display()` is mac-centric. That’s good for mac, but Windows/Linux need “Ctrl+Shift+K” style.

**Do this**

* Keep one canonical internal string format (for persistence): `cmd+shift+k`
* Provide `display_for_platform(platform)`:

  * macOS: glyphs (⌘⌥⇧⌃)
  * Win/Linux: text (Ctrl, Alt, Shift, Super if needed)

Also: consider using “Mod” as user-facing docs (“Mod+K”) but still serialize as `cmd+k` if you want.

## Conflicts: define what “conflict” means

You’ll run into three different “problem types”:

### A) Hard conflict (ambiguous at runtime)

Two bindings are both active in the **same context layer** and share the same shortcut.

Example: two ActionsDialog bindings both on `enter`.

**Policy**

* Disallow by default (except if one is explicitly “hidden/disabled”).
* If it happens, show it prominently in settings and pick a deterministic winner (by priority + registration order) so app doesn’t behave randomly.

### B) Shadowing (intentional override by specificity)

A more specific context uses the same shortcut as a less specific context.

Example: `enter` in ScriptList runs selection; `enter` in Editor submits prompt. This is fine if contexts are mutually exclusive or ordered.

**Policy**

* Don’t treat as an error; treat as “shadowed in X contexts.”
* Cheat sheet can show context grouping so this is understandable.

### C) Unreachable (OS reserved / hotkey registration failed)

Only applies to global hotkeys (definitive) and some in-app shortcuts (best-effort warning).

**Policy**

* Global hotkey: mark binding as “inactive: registration failed” and show the OS error.
* In-app: warning only.

## Priority model that stays sane

You need a single place to answer: “Which binding wins if multiple match?”

I’d use this order:

1. **User override** (highest)
2. **Built-in** (core UX)
3. **Script default** (lowest)

…and then the **context stack order** decides which contexts are searched first.

If you really want scripts to override built-ins, make that an explicit setting:

* `scripts_can_shadow_builtins: false` (default)
* But honestly, I’d avoid it.

## Unify “in-app shortcuts” and “global hotkeys” without pretending they’re the same

They should share the same **Shortcut** type and registry, but have different activation:

Add:

```rust
pub enum ShortcutScope {
    App,        // GPUI key events when focused
    Global,     // OS-registered hotkey
}
```

Then each binding has:

* `scope`
* `context` (for App scope; Global can ignore context or treat as Global only)

This lets you:

* Keep one cheat sheet
* Keep one conflict detector
* Still register global hotkeys through Bundle 10’s system

## A practical config model

Even if your config lives in TS today, the Rust side wants a clean structure:

```rust
#[derive(Default, Deserialize)]
pub struct ShortcutConfig {
    /// binding_id -> Some("cmd+k") override, or None to disable
    pub overrides: std::collections::HashMap<String, Option<String>>,
}
```

On load:

* For each `(id, Some(str))` → parse and apply override
* For each `(id, None)` → disable
* Invalid strings → keep old/default and surface an error (don’t silently ignore)

## Cheat sheet: include conflicts + disabled + overridden status

Your cheat sheet renderer should show:

* Category header
* Each binding row:

  * Name
  * Shortcut keycap
  * Context badge (ScriptList / Editor / Global)
  * Status: Default / Overridden / Disabled / Conflict

This turns “discovery gap” into a feature.

## Minimal changes to your proposed types that will save you later

### 1) Make parsing return a Result with errors

You’ll want to tell users *why* their shortcut didn’t load.

```rust
pub enum ShortcutParseError {
    Empty,
    MissingKey,
    UnknownToken(String),
    UnknownKey(String),
}
```

### 2) Canonicalize modifier meaning

Right now you have `cmd` meaning “platform accelerator,” and also `ctrl`. That’s fine, but be explicit in naming internally:

* `primary` instead of `cmd` (still parse `cmd`, `meta`, `mod`, `super`)
* Keep `ctrl` as literal control key (esp. on macOS)

### 3) Don’t store bindings in separate maps

Instead:

```rust
pub enum BindingSource { Builtin, Script }

pub struct ShortcutBinding {
  pub id: String,
  pub source: BindingSource,
  pub name: String,
  pub default: Shortcut,
  pub context: ShortcutContext,
  pub scope: ShortcutScope,
  pub category: ShortcutCategory,
  pub customizable: bool,
}
```

Keep one registry list, and apply overrides/disabled on top.

## Implementation notes specific to your current code

### Migrating inline handlers

You’ll do this in two passes:

1. **Introduce registry + match path** without deleting existing matches:

* On KeyDown:

  * Try registry match
  * If none, fall back to existing inline match logic
* This lets you incrementally migrate bindings safely.

2. Move each inline match case into a registered binding + action handler entry:

* Keep action execution in one place (`execute_shortcut_action`).

### Be careful with text input

Even with contexts, you should adopt one rule:

* If the focused element is a text input/editor and the keystroke has **no command-ish modifiers**, prefer text handling.

This avoids breaking typing when your view contexts are coarse.

---

## Direct answers, summarized

* **Scripts overriding built-ins:** No by default; require user override to take precedence.
* **macOS system shortcuts:** avoid in defaults; warn on user selection; global hotkey registration errors are definitive and must be surfaced.
* **Shortcut recording:** yes, essential; implement proper capture/cancel/clear behaviors.
* **Persistence:** `binding_id -> string|null` map; stable ids; load+watch; surface parse errors.
* **Hidden window behavior:** only global hotkeys should work when hidden; script globals must be opt-in.

If you implement just two changes from all of this, make them:

1. **Context stack (ordered) instead of boolean is_active**
2. **Deterministic storage/indexing (no HashMap iteration for matching)**

Those two prevent most “shortcut system” bugs that drive users crazy.
