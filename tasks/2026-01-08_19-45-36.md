Below is a concrete UX + implementation plan you can hand to an engineer (or implement yourself) that fixes the four problems you listed and maps cleanly onto the files in your bundle.

---

## 1) The modal should behave like a small state machine

Right now the biggest UX issue is ambiguity: “am I recording?”, “did it capture?”, “why can’t I save?”. The clean fix is to make recording explicitly stateful and reflect that state visually + in the button enable/disable logic.

### Recommended states

Use an enum in `shortcut_recorder.rs` and drive the whole UI off it:

* **Idle**: not recording, nothing captured yet (or showing current binding if editing)
* **Recording**: listening for key presses
* **Captured(Shortcut)**: a valid shortcut is captured (save enabled)
* **Invalid(reason)**: something was captured but it’s not allowed (save disabled)
* **Conflict { captured, conflicts }**: captured is valid, but collides (save disabled OR gated behind “Replace”)

This eliminates “unclear recording state”, “limited feedback”, and “modifier-only prevention” as UX problems because they become first-class states.

---

## 2) UX layout that solves the core problems

### A. Recorder panel (centerpiece)

Make the recorder panel look and behave like an input control:

**Idle**

* Big placeholder text: “Click here, then press your shortcut”
* Secondary hint: “Esc cancels • Backspace clears”
* Button: “Start recording” (or auto-start when modal opens, but still show a clear “Listening…” indicator)

**Recording**

* Strong visual cue: “Listening…” with an animated dot/outline
* Instruction: “Hold modifiers, then press a key”
* Live preview: show currently-held modifiers as “chips” (e.g., `Cmd` `Shift`) even before the main key is pressed

**Captured**

* Show the final combo prominently as chips: `Cmd` `Shift` `K`
* Subtext: “Press a different shortcut to replace” (optional, but it makes iteration fast)
* Save enabled

**Invalid**

* Show the captured chips if you have them (helps users learn)
* Error message that tells them what to do:

  * “Shortcut must include a non-modifier key.”
  * “That key can’t be used for shortcuts.”
* Save disabled

**Conflict**

* Show captured chips
* Show a conflict callout listing what it conflicts with:

  * “Already used by: Open Command Palette (Global)”
  * or “Used by script: ‘Deploy staging’”
* Provide explicit resolution:

  * **Choose another shortcut** (returns to Recording)
  * **Replace existing** (only if you allow that)
  * If you don’t allow replacement: say so plainly and keep Save disabled

### B. “Existing shortcuts” section (small, but high-value)

A compact list in the modal (right side or below) solves “no conflict detection UI” and “show existing shortcuts”:

* Show current assignment for the script (if editing)
* Show top conflicts first when conflict exists
* Optionally show a searchable list of all shortcuts (nice-to-have)

This is the `persistence.rs` / registry integration work.

---

## 3) Validation rules that feel fair

These rules should be enforced in `src/hotkeys.rs` (authoritative) and mirrored in the recorder UI for immediate feedback.

### Must-have validation

1. **Not modifier-only**

   * Reject: `Cmd`, `Ctrl`, `Alt`, `Shift` alone
2. **Has exactly one “main key”**

   * Main key is a non-modifier (letters, numbers, F-keys, etc.)
3. **Disallow a small set of unusable keys**

   * Examples: `Fn` (often not capturable), sometimes `CapsLock` (depends), etc.
4. **Optional but recommended**: require at least one modifier for letter keys

   * Prevents accidental single-letter shortcuts that hijack typing.
   * You can still allow function keys without modifiers.

### UX messaging examples (keep it blunt)

* “Press a non-modifier key (like K) while holding Cmd/Ctrl.”
* “Single-letter shortcuts aren’t allowed. Add Cmd, Ctrl, Alt, or Shift.”

---

## 4) Conflict detection that returns UI-ready details

Conflict detection is not just “true/false”. The UI needs:

* what it conflicts with,
* who owns it (script vs built-in action),
* where it applies (global vs context),
* whether it’s a hard block or a warning.

### `src/shortcuts/registry.rs`: add a conflict API

**Goal:** the recorder calls one function and gets structured results.

Example shape (adjust names to your codebase):

```rust
// registry.rs
#[derive(Clone, Debug)]
pub struct ShortcutBindingInfo {
    pub id: BindingId,
    pub shortcut: Shortcut,
    pub scope: ShortcutScope,      // Global, App, ScriptOnly, etc.
    pub context: ShortcutContext,  // if you have routing contexts
    pub owner: ShortcutOwner,      // BuiltInAction / Script(id)
    pub label: String,             // "Open Command Palette" / script name
}

#[derive(Clone, Debug)]
pub enum ConflictSeverity {
    Block, // cannot save
    Warn,  // allowed if you choose to allow overlaps
}

#[derive(Clone, Debug)]
pub struct ShortcutConflict {
    pub severity: ConflictSeverity,
    pub existing: ShortcutBindingInfo,
}

impl ShortcutRegistry {
    pub fn find_conflicts(
        &self,
        candidate: &Shortcut,
        candidate_scope: ShortcutScope,
        candidate_context: ShortcutContext,
        candidate_owner: ShortcutOwner,
    ) -> Vec<ShortcutConflict> {
        // 1) normalize candidate
        // 2) look up existing bindings by normalized accelerator
        // 3) decide severity based on scope/context overlap rules
    }
}
```

### Conflict rules (keep them predictable)

A sane baseline:

* **Global vs anything**: **Block**
* **Same context + same scope**: **Block**
* **Different contexts that truly don’t overlap**: allow (or Warn)
* If you don’t have a strong context model yet: keep it simple and **Block** on any duplicate.

The key is: the registry decides, not the UI. The UI just renders what it’s told.

---

## 5) Persistence should expose “what’s already taken”

You called this out explicitly: `src/shortcuts/persistence.rs` should “show existing shortcuts”.

That means persistence needs to expose either:

* all stored bindings (for listing), or
* enough for registry to build a full in-memory index with labels.

### Minimal change that unlocks the UI

Add a method that returns a list the UI can consume:

```rust
// persistence.rs
pub fn list_bindings(&self) -> Vec<PersistedBinding> {
    // return all bindings (script id/action id, shortcut, scope/context)
}
```

Then the modal can show:

* “Currently assigned: …”
* “Other shortcuts: …”

If script names live elsewhere, pass labels in from the caller or add a lightweight resolver.

---

## 6) `src/hotkeys.rs`: validation before saving must be the single source of truth

Even if the recorder prevents invalid shortcuts, `hotkeys.rs` must enforce it too (so you don’t accept invalid shortcuts from other entry points, migrations, config edits, etc.).

Recommended pattern:

```rust
pub enum HotkeyValidationError {
    ModifierOnly,
    DisallowedKey,
    MissingModifierForTextKey,
    Conflict(Vec<ShortcutConflict>),
}

pub fn validate_and_register_shortcut(
    registry: &ShortcutRegistry,
    binding: &ProposedBinding,
) -> Result<(), HotkeyValidationError> {
    // 1) validate shape (modifier-only, allowed keys, etc.)
    // 2) registry.find_conflicts(...)
    // 3) if conflicts -> return Conflict(...)
    // 4) otherwise register
}
```

The UI can map these errors to:

* inline error text (Invalid)
* inline conflict list (Conflict)

---

## 7) `src/components/shortcut_recorder.rs`: implementation details that matter

### A. Capture behavior that feels responsive

* Start recording when the recorder area is clicked (and visibly focused)
* While recording:

  * track held modifiers in real time
  * only “finalize” when a non-modifier key is pressed
* Ignore pure modifier presses as a final result, but still show them as “held”

### B. Keyboard controls

* `Esc`: cancel / close modal
* `Backspace` or `Delete`: clear recorded shortcut (back to Idle)
* `Enter`: Save if valid + no blocking conflicts

### C. Don’t require the user to click “Start” repeatedly

Once they’ve recorded something, pressing a new combo should just replace the captured combo (fast iteration).

### D. Immediate conflict feedback

On capture:

1. run local validation → Invalid if needed
2. if valid, call `registry.find_conflicts(...)`
3. if conflicts → Conflict state
4. else → Captured state

---

## 8) Definition of done (practical acceptance criteria)

You’ll know this is actually fixed when:

* Users see **“Listening…”** the moment recording begins (no ambiguity).
* Pressing `Cmd` alone results in **clear inline error** and disabled Save.
* Captured shortcut is shown as **readable chips** (not just a raw string).
* If a shortcut is already used, the modal **immediately shows who uses it**, and Save is blocked (or gated behind Replace if you support that).
* There is a way to see **existing shortcuts** from inside the modal without leaving the flow.
* `hotkeys.rs` rejects invalid shortcuts even if they somehow bypass the UI.

---

## 9) Test plan you should actually run

### Unit tests

* `Shortcut::is_modifier_only()` returns true for each modifier key alone
* normalization makes `Cmd+Shift+K` equal regardless of press order
* registry conflict detection:

  * same shortcut → conflict
  * different shortcut → no conflict
  * global vs local rules behave as expected

### Manual QA checklist (fast)

1. Open modal → it’s obvious where to press keys
2. Record `Cmd` only → error shown, cannot save
3. Record valid combo → chips show, can save
4. Record a combo that is already used → conflict details show
5. Clear → returns to Idle
6. Record again without closing → works

---

If you paste the contents of the files you listed (or drop the repo in), I can turn this into a concrete patch: actual enums, function signatures matched to your existing types, and the UI rendering wired up to the new conflict API.
