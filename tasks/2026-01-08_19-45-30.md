You don’t fix this by tweaking four separate call sites. You fix it by making **one** preview component that owns:

* the container (background, padding, rounding, border)
* typography (font + size)
* syntax highlighting (and its theme mapping)
* overflow behavior (scroll vs wrap)
* opacity (applied the same way everywhere)

Then every context (script list, clipboard history, file search, arg prompts) renders *content*, not *styling*.

Below is a concrete refactor plan that matches the files you listed and directly addresses your 4 “Key Problems”.

---

## The one rule

**No view is allowed to hand-roll a preview container.**
All preview rendering goes through one shared function/component in `src/ui_foundation.rs`.

That’s how you eliminate “almost the same but slightly different” forever.

---

## 1) `src/ui_foundation.rs`: create the shared preview component

### A. Define a content model (so callers don’t do formatting)

Make the preview API accept a small enum so each caller just passes “what to show”:

```rust
pub enum PreviewContent<'a> {
    Empty { placeholder: &'a str },
    PlainText { text: &'a str },
    Code {
        language: Option<SyntaxLanguage>, // whatever your syntax module uses
        text: &'a str,
    },
    Error { message: &'a str },
}
```

### B. Define options (so you can standardize + still tweak safely)

```rust
pub struct PreviewPanelOptions {
    pub id_source: &'static str,   // stable scroll state per context
    pub min_height: f32,
    pub max_height: f32,
    pub padding: f32,
    pub rounding: f32,
    pub wrap_lines: bool,          // plain text + code wrapping policy
    pub show_line_numbers: bool,   // optional (if supported)
    pub opacity: f32,              // 0.0..=1.0 from settings
}
```

### C. Centralize style derivation from theme (no callers touching colors)

Add a helper that converts your app theme into “preview tokens”:

```rust
pub struct PreviewPanelStyle {
    pub bg: egui::Color32,
    pub border: egui::Color32,
    pub text: egui::Color32,
    pub code_bg: egui::Color32,
    pub mono_font: egui::FontId,
}
```

**Important:** apply opacity here, once, consistently.

If you’re on egui, a safe pattern is multiplying the full RGBA (premultiplied-friendly):

```rust
fn apply_opacity(c: egui::Color32, opacity: f32) -> egui::Color32 {
    c.linear_multiply(opacity.clamp(0.0, 1.0))
}
```

Then build:

* preview background
* code background (can be same as bg, just slightly different)
* border
* text

…and apply `opacity` to the ones that should fade.

### D. Implement the container + overflow once

You want:

* consistent padding/rounding/border
* vertical scrolling always works for long content
* horizontal overflow handled either by wrapping or horizontal scroll

A reliable default:

* Use `ScrollArea::both()` if you do **not** wrap
* Use `ScrollArea::vertical()` if you **do** wrap

Also: always disable auto-shrink so the content area doesn’t collapse differently in different contexts.

Pseudo-structure (egui-flavored):

```rust
pub fn preview_panel(
    ui: &mut egui::Ui,
    theme: &Theme,
    opts: &PreviewPanelOptions,
    content: PreviewContent<'_>,
) -> egui::Response {
    let style = preview_style_from_theme(ui, theme, opts.opacity);

    let frame = egui::Frame::none()
        .fill(style.bg)
        .stroke(egui::Stroke::new(1.0, style.border))
        .rounding(egui::Rounding::same(opts.rounding))
        .inner_margin(egui::Margin::same(opts.padding));

    frame.show(ui, |ui| {
        ui.set_min_height(opts.min_height);

        // Clamp height so huge previews don’t explode layouts:
        let available = ui.available_height().min(opts.max_height);
        ui.set_max_height(available);

        let scroll = if opts.wrap_lines {
            egui::ScrollArea::vertical()
        } else {
            egui::ScrollArea::both()
        };

        scroll
            .id_source(opts.id_source)
            .auto_shrink([false, false])
            .show(ui, |ui| {
                match content {
                    PreviewContent::Empty { placeholder } => {
                        ui.add(egui::Label::new(
                            egui::RichText::new(placeholder).italics().color(style.text),
                        ));
                    }
                    PreviewContent::PlainText { text } => {
                        ui.add(
                            egui::Label::new(egui::RichText::new(text).font(style.mono_font.clone()))
                                .wrap(opts.wrap_lines),
                        );
                    }
                    PreviewContent::Code { language, text } => {
                        // See syntax.rs section: produce a LayoutJob with theme-aware colors
                        let job = crate::syntax::highlight_job(ui.ctx(), theme, language, text, &style);
                        ui.label(job);
                    }
                    PreviewContent::Error { message } => {
                        ui.add(egui::Label::new(
                            egui::RichText::new(message).color(theme.colors.error_text),
                        ));
                    }
                }
            });
    }).response
}
```

This one function kills:

* inconsistent padding/background/fonts
* overflow bugs from ad hoc layout
* opacity inconsistencies

---

## 2) `src/syntax.rs`: make syntax highlighting theme-aware and preview-aware

Right now your biggest risk is: **some previews don’t respect theme colors** because syntax highlighting is probably hard-coded or using a different theme mapping.

Fix that by having syntax highlighting take a theme-derived “syntax palette” (or pass `PreviewPanelStyle` in).

What you want exported:

```rust
pub fn highlight_job(
    ctx: &egui::Context,
    theme: &Theme,
    language: Option<SyntaxLanguage>,
    text: &str,
    preview_style: &PreviewPanelStyle,
) -> egui::text::LayoutJob
```

Where `Theme -> SyntaxTheme` mapping happens **inside** syntax:

* normal text uses `preview_style.text`
* background is handled by container (don’t bake bg into every span unless you must)
* keywords/strings/comments pulled from theme tokens (or derived from accent colors)

If your highlighter currently sets its own background, stop doing that; let the preview container own background so every context looks identical.

Also: make sure the font used for highlighted code is the same `mono_font` you use for plain previews.

---

## 3) `src/app_render.rs`: unify `render_preview_panel()` around the shared component

This file should no longer decide padding/colors/fonts. It should:

1. Determine **what content** is being previewed (text/code/error/empty)
2. Determine the **options** (min/max height, wrap, opacity, id)
3. Call `ui_foundation::preview_panel(...)`

So `render_preview_panel()` becomes a thin adapter:

* gets preview text from state
* gets preview language (if known)
* passes opacity from settings
* sets a consistent `id_source` like `"main_preview_panel"`

This is the first place you enforce “one way to preview”.

---

## 4) `src/render_script_list.rs`: script list must call the same component

The script list preview often drifts because it’s “special”: it’s near a list, it might use a smaller panel, etc.

Don’t style it locally. Decide only:

* what to preview (selected script content / metadata / empty)
* options: maybe smaller `max_height`, maybe wrap preference

Example decision points that are legitimate per-context differences:

* `opts.max_height` (because script list view might be shorter)
* `opts.id_source` (so scroll state doesn’t leak across contexts)
* whether to wrap lines (I’d default: **no wrap** for code, wrap for plain text)

Everything else must be identical.

---

## 5) `src/render_builtins.rs`: clipboard/file search previews also call the same component

Built-ins are where theming tends to break because they frequently embed custom containers.

Refactor them to:

* keep their header/metadata UI (file name, clipboard timestamp, etc.)
* then call `preview_panel()` for the content area

If clipboard preview shows mixed content:

* if it’s detected as code → use `PreviewContent::Code`
* else → `PlainText`
* if too large / binary → `Error` or `Empty` placeholder explaining why

---

## Opacity handling: make it impossible to “forget”

Right now you have “Preview opacity setting not applied uniformly”.

The blunt fix:

* **preview opacity is only applied in `ui_foundation::preview_style_from_theme()`**
* no other file touches alpha for preview UI

That way any new preview context automatically respects opacity.

Also decide explicitly: what does opacity affect?

* Usually: background + border + maybe selection highlight
* Usually **not**: text alpha (otherwise readability tanks)

So apply opacity to container colors, not text colors.

---

## Overflow behavior: pick a single standard

This is the part that causes the most “it works here but not there”.

A sane default:

* **Code:** no wrap + `ScrollArea::both()`
  (horizontal scrolling is expected for code)
* **Plain text:** wrap + `ScrollArea::vertical()`
  (better reading, no sideways scrolling)

If you must support toggling wrap:

* keep the behavior consistent everywhere by using the same setting in options

Also add a consistent max height so giant previews don’t destroy layouts:

* `max_height = ui.available_height().min(SOME_CONSTANT)` or per-context constant

---

## What to change in each file (exact responsibilities)

### `src/ui_foundation.rs`

* Add `PreviewContent`, `PreviewPanelOptions`, `PreviewPanelStyle`
* Add `preview_panel(ui, theme, opts, content)` function
* Add `preview_style_from_theme(ui, theme, opacity)` (the *only* place opacity is applied)

### `src/syntax.rs`

* Add `highlight_job(ctx, theme, language, text, preview_style)` that:

  * uses theme tokens
  * uses mono font consistently
  * does not fight the container background

### `src/app_render.rs`

* Replace current `render_preview_panel()` internals with:

  * content selection + options
  * call `ui_foundation::preview_panel`

### `src/render_script_list.rs`

* Delete any local preview container styling
* Build `PreviewContent` from selection
* Call shared preview component

### `src/render_builtins.rs`

* Same as script list: keep header UI if needed, but preview content uses shared component

---

## Acceptance checklist (so you know you’re actually done)

You’re done when all of these are true:

1. **Padding/rounding/border** look identical in:

   * main script list preview
   * clipboard history preview
   * file search preview
   * arg prompt preview
2. Changing theme changes preview colors **everywhere** (no “one view still dark”).
3. Preview opacity slider affects **every** preview container the same way.
4. Extremely long content:

   * does not overflow outside the preview panel
   * can always be scrolled
   * never makes the whole page unusable
5. Syntax highlighted code uses the same base font and baseline size everywhere.

---

## If you want the fastest path

Do it in this order to avoid thrash:

1. Build `ui_foundation::preview_panel()` with placeholder text only (no syntax yet).
2. Switch **one** context (main `render_preview_panel()`) to use it.
3. Switch script list + built-ins to use it.
4. Only then wire `syntax.rs` highlighting through the shared preview.

This avoids debugging “theme + scroll + highlight” in four contexts simultaneously.

---

If you paste the current `render_preview_panel()` plus one example preview implementation from `render_script_list.rs` and one from `render_builtins.rs`, I can turn this into a concrete diff-level rewrite with consistent sizing/scroll IDs and a clean theme mapping.
