Here’s a concrete, “don’t-get-cute” implementation blueprint that fixes the three root causes you listed (stale display detection, boundary edge cases, and coordinate confusion) and maps cleanly onto the files you called out.

The key move: **pick one authoritative coordinate space for detection and math**, and do **exactly one** conversion at the boundary where you talk to GPUI / your windowing layer.

---

## The rules that make this reliable

### Rule 1: Detect display using macOS screen coordinates only

On macOS, you can get both:

* the **mouse position** in global screen coordinates, and
* each display’s **frame** and **visibleFrame** (work area excluding menu bar + dock)

…in the same coordinate system (AppKit’s screen space). If you do detection in that space, you avoid *most* retina/scale and y-flip disasters.

**Use:**

* `mouseLocation` (global point)
* `NSScreen.frame` (full display)
* `NSScreen.visibleFrame` (safe/work area)

### Rule 2: Use half‑open bounds to avoid “boundary belongs to both monitors”

When the cursor sits exactly on a boundary, inclusive comparisons (`<=`) will often say it’s “inside” both screens. That leads to “first match wins” → wrong monitor.

Use **half-open** containment:

* `x ∈ [min_x, max_x)`
* `y ∈ [min_y, max_y)`

That guarantees a point hits *at most one* display.

### Rule 3: If no display contains the point, pick the nearest display

This happens with:

* tiny float rounding,
* weird arrangements,
* transient values during display reconfiguration.

Fallback: clamp the point into each display rect and choose the smallest squared distance.

### Rule 4: Do not cache display info across “show”

Caching is exactly how you get “stale display detection.” Displays change when:

* monitors connect/disconnect,
* spaces/fullscreen transitions,
* arrangement changes,
* scaling changes.

If you must cache, cache with **invalidation** (macOS “screen parameters changed” notification) or **a very short TTL**. Otherwise: just re-query at show-time.

---

## What to change, file by file

## 1) `src/window_control_enhanced/display.rs`

### Add/ensure these are true:

* `Display` carries:

  * `frame` (full bounds)
  * `visible_frame` (work area bounds)
  * stable `id` (if you have one)
  * `is_primary` (optional)

### Implement robust selection:

```rust
/// Point + Rect in macOS screen coordinates (origin bottom-left, y-up),
/// using logical "points" (AppKit), not raw device pixels.
#[derive(Clone, Copy, Debug)]
pub struct Point {
    pub x: f64,
    pub y: f64,
}

#[derive(Clone, Copy, Debug)]
pub struct Rect {
    pub x: f64,
    pub y: f64,
    pub w: f64,
    pub h: f64,
}

impl Rect {
    #[inline] pub fn min_x(self) -> f64 { self.x }
    #[inline] pub fn max_x(self) -> f64 { self.x + self.w }
    #[inline] pub fn min_y(self) -> f64 { self.y }
    #[inline] pub fn max_y(self) -> f64 { self.y + self.h }

    /// Half-open containment avoids "two displays contain the boundary point".
    pub fn contains_half_open(self, p: Point) -> bool {
        p.x >= self.min_x() && p.x < self.max_x() &&
        p.y >= self.min_y() && p.y < self.max_y()
    }

    pub fn clamp_point(self, p: Point) -> Point {
        let cx = p.x.max(self.min_x()).min(self.max_x());
        let cy = p.y.max(self.min_y()).min(self.max_y());
        Point { x: cx, y: cy }
    }
}

#[derive(Clone, Debug)]
pub struct Display {
    pub frame: Rect,
    pub visible_frame: Rect,
    // pub id: u32, // if you have it
    // pub scale_factor: f64, // optional but useful
}

impl Display {
    pub fn contains_point(&self, p: Point) -> bool {
        self.frame.contains_half_open(p)
    }
}

/// Prefer "contains", fallback to nearest.
pub fn display_for_point(displays: &[Display], p: Point) -> Option<Display> {
    if displays.is_empty() {
        return None;
    }

    if let Some(d) = displays.iter().find(|d| d.contains_point(p)) {
        return Some(d.clone());
    }

    // Fallback: nearest display by squared distance to clamped point.
    let mut best = None;
    let mut best_dist2 = f64::INFINITY;

    for d in displays {
        let cp = d.frame.clamp_point(p);
        let dx = p.x - cp.x;
        let dy = p.y - cp.y;
        let dist2 = dx*dx + dy*dy;
        if dist2 < best_dist2 {
            best_dist2 = dist2;
            best = Some(d.clone());
        }
    }

    best
}
```

### Make sure you use `visible_frame` for placement

**Detection uses `frame`.**
**Placement clamps into `visible_frame`.**

That’s how you account for menu bar + dock without guessing.

---

## 2) `src/platform.rs`

### Fix the “stale display detection” at the source

You need a single function that returns **the mouse position “right now”**, and another that returns **displays “right now.”**

The most important part: **do not derive the target display from the current window or from a cached “current display.”** Always derive it from the mouse.

What you want conceptually:

```rust
pub fn mouse_position_screen() -> Point {
    // macOS: return mouse location in AppKit global screen coordinates (points).
}

pub fn displays_screen() -> Vec<Display> {
    // macOS: enumerate NSScreen.screens and pull frame + visibleFrame
}

pub fn display_under_mouse() -> Option<Display> {
    let p = mouse_position_screen();
    let displays = displays_screen();
    display_for_point(&displays, p)
}
```

### Why AppKit, not CGDisplay, for this layer

If you mix:

* CGEvent location (often treated like pixels),
* CGDisplayBounds (device pixels),
* NSScreen frame (points),

…you will eventually get “works on my monitor” bugs, especially with mixed retina/non-retina displays.

If you can, keep the entire detection & work-area math in AppKit coordinates, then convert once for GPUI.

---

## 3) `src/window_control_enhanced/coords.rs`

### Make coordinate transforms explicit and one-way

Your bundle already identified the confusion: macOS detection is “bottom-left, y-up” while GPUI expects “top-left, y-down”.

The fix is to codify it into **named functions** and stop doing ad-hoc flips in random call sites.

A practical approach:

* Keep **mac space** for:

  * mouse position,
  * display frames,
  * window target rect calculations.

* Convert to **gpui space** only at the final boundary where you call “set window bounds/position.”

If GPUI’s “global” origin is the **top-left of the primary display** (common), you can flip using the primary display height.

```rust
pub fn mac_point_to_gpui_global(p: Point, primary_height: f64) -> Point {
    Point { x: p.x, y: primary_height - p.y }
}

/// mac rect is bottom-left origin; gpui rect is top-left origin.
/// Convert by flipping using the rect's top edge.
pub fn mac_rect_to_gpui_global(r: Rect, primary_height: f64) -> Rect {
    Rect {
        x: r.x,
        y: primary_height - (r.y + r.h),
        w: r.w,
        h: r.h,
    }
}
```

**Important:** don’t guess `primary_height`. Fetch it from the primary display’s `frame.h` in the same coordinate space you used for everything else.

If GPUI expects a different global origin (some systems use a virtual-desktop top-left), you still keep the same idea — you just change the constant used for the y flip (use the global desktop max_y).

---

## 4) `src/window_control_enhanced/bounds.rs`

### Centralize “place near cursor but inside visible frame”

You want a single function that takes:

* desired window size (w/h),
* display `visible_frame`,
* optional anchor point (mouse),
* and returns a mac-space rect that is guaranteed fully visible.

Example:

```rust
pub fn clamp_rect_into(container: Rect, mut r: Rect) -> Rect {
    // Horizontal clamp
    if r.w > container.w { r.w = container.w; } // optional: or keep and accept overflow
    if r.x < container.x { r.x = container.x; }
    if r.x + r.w > container.x + container.w {
        r.x = (container.x + container.w) - r.w;
    }

    // Vertical clamp (mac space y-up, r.y is bottom)
    if r.h > container.h { r.h = container.h; }
    if r.y < container.y { r.y = container.y; }
    if r.y + r.h > container.y + container.h {
        r.y = (container.y + container.h) - r.h;
    }

    r
}

/// Example: place window centered on mouse, then clamp into visible frame.
pub fn window_rect_on_display_near_point(
    visible: Rect,
    mouse: Point,
    size_w: f64,
    size_h: f64,
) -> Rect {
    let desired = Rect {
        x: mouse.x - size_w / 2.0,
        y: mouse.y - size_h / 2.0,
        w: size_w,
        h: size_h,
    };

    clamp_rect_into(visible, desired)
}
```

If you don’t want “center on cursor,” you can instead anchor top-left near cursor, etc. The crucial part is: **the clamp must happen against `visible_frame`, not `frame`.**

---

## 5) `src/window_manager.rs`

### The behavioral change: don’t decide display from the window

Window managers often do something like:

* “what monitor is the window on now?” → use that for the next show

That is exactly how you end up showing on the wrong display after the user moved the mouse.

Instead:

* At the moment you are about to show/focus, do:

  1. `display = display_under_mouse()`
  2. compute target rect in mac coords using `display.visible_frame`
  3. convert to gpui coords once
  4. apply position/bounds
  5. then show/focus

Also: if you have a `WindowOps` queue, **bounds must be applied before show** to avoid a visible “teleport” flash.

---

## 6) `src/panel.rs`

### Make “show panel” always go through the mouse-display placement

This is where you enforce the policy:

* Panel show should ignore any “last display” unless you *explicitly* have a feature for “remember last position.”
* “Mouse display wins” should be the default.

Pseudo-flow:

```rust
pub fn show(&mut self) {
    // 1) fetch mouse + displays now (no cache)
    // 2) pick display under mouse
    // 3) compute desired rect inside display.visible_frame
    // 4) convert if needed
    // 5) set bounds
    // 6) show/focus
}
```

If you can show the window hidden first:

* set frame while hidden
* then make key and order front

That removes flicker.

---

## Edge cases you should explicitly handle

1. **Cursor exactly on a display boundary**
   Fixed by half-open containment.

2. **Displays with negative coordinates** (left-of / below primary)
   Works fine if you don’t assume `x>=0` / `y>=0`.

3. **Different scaling factors per display**
   Keep detection/placement in AppKit “points” (logical units).
   If your final “set position” API takes physical pixels, convert using the *target display’s* scale factor, not the primary’s.

4. **Mouse position not contained in any display**
   Use nearest-display fallback.

5. **Dock moved to left/right/bottom, menu bar on different screen**
   Never hardcode. Always place inside `visibleFrame`.

---

## Minimal test plan that will catch regressions fast

### Unit tests (pure Rust, no macOS calls)

Create fake display layouts and validate:

* containment is half-open
* boundary points map correctly
* nearest-display fallback works
* y-flip transforms roundtrip

Example layouts to test:

* secondary monitor to the left (negative x)
* secondary monitor above (positive y mac-space)
* mixed sizes (ultrawide next to normal)

### Manual “truth test” (takes 2 minutes)

Add temporary logging around show:

* mouse point
* selected display frame/visibleFrame
* computed window rect (mac)
* computed window rect (gpui)

Then:

* put cursor in each corner of each display
* trigger show
* verify panel appears on that display and fully inside work area

If any of those four logs look inconsistent (mouse says it’s on Display A but selected is B), your detection math is still mixed-space somewhere.

---

If you paste the current implementations of the four “Required Fixes” files (`platform.rs`, `display.rs`, `window_manager.rs`, `panel.rs`), I can give you a surgical, line-by-line rewrite that matches your existing structs and avoids guesswork about your current coordinate types and GPUI calls.
