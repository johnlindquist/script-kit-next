You fix this by making one rule non‑negotiable:

**The only thing allowed to identify an action at execution time is its `ActionId`.**
Indexes are *presentation*, not identity.

Right now your bundle description screams the classic failure mode: the UI highlights row *N*, but the executor runs “whatever is currently at index N” after some async rebuild/filter/sync. That’s how you get “wrong action executed” even though the UI looked correct.

Below is a concrete, code-oriented hardening plan organized exactly by the files you listed, with drop‑in patterns you can implement even if your UI framework differs.

---

## What you must guarantee (invariants)

1. **Identity is stable**
   Every action has a stable `ActionId` that does not depend on list position, sorting, filtering, or rebuild order.

2. **Selection is anchored to identity**
   UI state stores `selected_action_id` as the primary selection.
   `selected_index` is derived from it (or kept as a cached value but always re-synced).

3. **Execution uses captured identity**
   When the user hits Enter / clicks / uses a shortcut, you capture the `ActionId` *at that moment* and execute by `ActionId`.
   Never: `actions[selected_index]` at execution time.

4. **Async results can’t apply out of order**
   Rebuilds must be generation-guarded (or cancelled) so stale async results don’t overwrite the list/selection.

5. **No mid-trigger mutation**
   During the “trigger” path (key handling → decide what to run → dispatch), the action list/selection must be treated as a snapshot.

---

## src/actions/types.rs — make `ActionId` a real identity type

If you don’t already have a strong ID type, add one. It needs `Clone + Eq + Hash + Debug`.

```rust
#[derive(Clone, PartialEq, Eq, Hash, Debug)]
pub struct ActionId(pub String);

// Optional helpers
impl ActionId {
    pub fn new(s: impl Into<String>) -> Self { Self(s.into()) }
}
```

And your action type must carry it:

```rust
pub struct ActionItem {
    pub id: ActionId,
    pub title: String,
    // ... whatever you need to execute
}
```

If you already have `ActionId`, the key requirement is: **it must not be derived from index** and **it must be comparable/hashable**.

---

## src/actions/builders.rs — IDs must be unique and stable

### 1) Generate stable IDs with namespaces

Use a predictable scheme:

* Built-in actions: `"builtin:<action_name>"`
* Commands: `"cmd:<command_name>"`
* Scripts: `"script:<canonical_path_or_uuid>"`
* Dynamic “open file X”: `"file:<canonical_path>"`

**Do not** use display title alone; titles collide.

Example:

```rust
fn builtin(id: &str, title: &str /* ... */) -> ActionItem {
    ActionItem {
        id: ActionId::new(format!("builtin:{id}")),
        title: title.to_string(),
        // ...
    }
}

fn script_action(script_path: &Path) -> ActionItem {
    // Canonicalize if you can; otherwise use a normalized absolute path.
    let key = script_path.to_string_lossy().replace('\\', "/");
    ActionItem {
        id: ActionId::new(format!("script:{key}")),
        title: script_path.file_stem().unwrap_or_default().to_string_lossy().to_string(),
        // ...
    }
}
```

### 2) Enforce uniqueness (hard)

At the end of building the list, detect duplicates. In debug, **panic**. In release, **log error + de-dup** (or refuse to show duplicates). Don’t silently allow duplicates; that just moves the bug.

```rust
use std::collections::HashSet;

fn assert_unique_ids(actions: &[ActionItem]) {
    let mut seen = HashSet::new();
    for a in actions {
        if !seen.insert(a.id.clone()) {
            // Debug: explode so you fix it
            debug_assert!(false, "Duplicate action id: {:?}", a.id);
            // Release: log
            log::error!("Duplicate action id: {:?}", a.id);
        }
    }
}
```

Call this once per build.

---

## src/actions/dialog.rs — fix selection drift by anchoring to ID

### Store `selected_id` as the source of truth

Whatever your dialog state struct is, it should have:

* `selected_id: Option<ActionId>`
* `selected_index: usize` (optional cache)
* `actions: Vec<ActionItem>`

### Add a single `sync_selection()` function and call it aggressively

Call it:

* after rebuilding/filtering `actions`
* before rendering highlight
* before executing

```rust
impl ActionsDialogState {
    fn sync_selection(&mut self) {
        if self.actions.is_empty() {
            self.selected_id = None;
            self.selected_index = 0;
            return;
        }

        // Try to keep same ID selected
        if let Some(id) = self.selected_id.clone() {
            if let Some(idx) = self.actions.iter().position(|a| a.id == id) {
                self.selected_index = idx;
                return;
            }
        }

        // Fallback: clamp index and re-anchor ID
        self.selected_index = self.selected_index.min(self.actions.len() - 1);
        self.selected_id = Some(self.actions[self.selected_index].id.clone());
    }

    fn move_selection(&mut self, delta: isize) {
        if self.actions.is_empty() { return; }
        let len = self.actions.len() as isize;
        let cur = self.selected_index as isize;
        let next = (cur + delta).clamp(0, len - 1) as usize;
        self.selected_index = next;
        self.selected_id = Some(self.actions[next].id.clone());
    }
}
```

### On “Enter”, capture the ID and dispatch that

This is the single most important line of defense.

```rust
fn on_confirm(&mut self, app: &mut App) {
    self.sync_selection();
    let Some(id) = self.selected_id.clone() else { return; };
    app.execute_action_by_id(id);
}
```

**Never** do: `let action = self.actions[self.selected_index].clone();` *after* any async boundary.

---

## src/actions/window.rs — stop async timing bugs with generations

If your action list is rebuilt async (common if you’re filtering, searching, indexing scripts, etc.), you need a generation number.

State:

```rust
pub struct ActionsWindowState {
    pub generation: u64,
    pub pending_generation: u64,
    // ...
}
```

Workflow:

* Each time the query/filter changes: `generation += 1; let gen = generation; spawn_build(gen, query)`
* When build returns: **only apply if `gen == generation`**

```rust
fn start_rebuild(&mut self /* ... */) {
    self.generation += 1;
    let gen = self.generation;
    let query = self.query.clone();
    spawn_build_actions(gen, query);
}

fn on_build_result(&mut self, gen: u64, actions: Vec<ActionItem>) {
    if gen != self.generation {
        // Stale result. Drop it on the floor.
        return;
    }
    self.actions = actions;
    self.dialog.sync_selection();
}
```

This alone eliminates an entire class of “I hit Enter but list changed underneath me” failures.

---

## src/app_actions.rs — execute by ID, not by index

You need one canonical execution entrypoint:

```rust
impl App {
    pub fn execute_action_by_id(&mut self, id: ActionId) {
        // If you have a registry:
        if let Some(action) = self.action_registry.get(&id) {
            action.run(self);
            return;
        }

        // Or if your list is the source of truth:
        if let Some(action) = self.actions.iter().find(|a| a.id == id) {
            action.run(self);
            return;
        }

        log::warn!("Action not found for id {:?}", id);
        // Optional: surface a toast/message instead of failing silently.
    }
}
```

Then **delete/ban** any code path that does:

* “selected_index → actions[index] → run”
* “shortcut → index → run”

If you keep those around, the bug will come back.

---

## src/shortcuts/registry.rs — shortcuts must map to `ActionId`

Shortcut dispatch must become:

* key chord → `ActionId`
* then `execute_action_by_id(id)`

Not:

* key chord → index into current list

Example shape:

```rust
pub struct ShortcutRegistry {
    map: std::collections::HashMap<KeyChord, ActionId>,
}

impl ShortcutRegistry {
    pub fn action_for(&self, chord: &KeyChord) -> Option<ActionId> {
        self.map.get(chord).cloned()
    }
}
```

And in the handler:

```rust
if let Some(id) = shortcuts.action_for(&chord) {
    app.execute_action_by_id(id);
}
```

---

## src/render_script_list.rs — “lock state during action execution” the right way

The safest pattern is:

1. In the UI thread, **take a snapshot of the intended `ActionId`** (and any args).
2. Close/hide the actions window.
3. Execute using the snapshot.

You typically **do not** want to hold a mutex across the whole execution (that can deadlock if actions touch UI state). You only need to prevent mutation *during the decision*.

If you truly have re-entrancy issues (execution can trigger list rebuild which re-enters render), add an execution flag:

```rust
pub struct ActionsWindowState {
    is_executing: bool,
    // ...
}
```

Usage:

* Set `is_executing = true` immediately before dispatch
* While true: ignore selection changes, ignore async rebuild applies, or just don’t render the window at all
* Reset when the action finishes (if sync) or immediately after you’ve queued it (if async) and the window is already closed

The core point: **no code should be able to change “what will run” after you’ve captured the `ActionId`.**

---

## Quick sanity checks you should add (cheap and effective)

1. **Render-time assertion**
   After `sync_selection()`, assert selected index matches selected id:

```rust
debug_assert!(
    self.selected_id.as_ref().map(|id| id == &self.actions[self.selected_index].id).unwrap_or(true),
    "Selection drift: index/id mismatch"
);
```

2. **Trigger logging**
   Log `(selected_index, selected_id, title, generation)` at Enter.
   If the wrong action runs, those logs will show whether the executor ignored the ID.

3. **Duplicate ID panic in debug**
   If you ever had non-unique IDs, you’ve already lost. Catch it early.

---

## Minimal “this will probably fix it today” checklist

If you want the smallest set of changes that removes the wrong-action execution class:

* ✅ Make `execute_action_by_id(ActionId)` exist and route *everything* through it (`app_actions.rs`)
* ✅ Ensure the actions window stores `selected_id` and uses it on Enter (`dialog.rs`)
* ✅ Ensure builders generate unique stable IDs and assert uniqueness (`builders.rs`)
* ✅ Add generation-guard to async rebuilds (`window.rs`)

Everything else is reinforcement.

---

If you paste the contents of those Rust files (or upload them), I can turn this into an exact patch/diff that matches your codebase’s real structs and async model.
