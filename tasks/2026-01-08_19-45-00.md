You’re fighting three problems that usually come as a package in text expanders:

1. **Your matcher’s “what was typed” model drifts from what the focused app actually contains** (navigation keys, IME/composition, modifier‑generated characters, paste, etc.).
2. **Your replacement isn’t atomic** (selection/backspace + injection gets interleaved with the user’s next keystrokes, or runs before the last char lands).
3. **You’re counting “characters” differently across matcher/selection/injection** (bytes vs Rust `char` vs *grapheme clusters* → emoji/combining marks).

The fix is to make the pipeline consistent and transactional:

* **Matcher** tracks the *exact inserted text* (prefer text events) as a rolling buffer of **grapheme clusters** and produces a `MatchInfo` that includes **how many graphemes to remove**.
* **Manager** serializes expansions with an **injection guard** so your own synthetic events don’t re-trigger matching, and so you don’t start two expansions at once.
* **Injector** replaces in the most reliable way: **delete N graphemes** (usually backspace) and then **paste** the expansion (clipboard‑based) to avoid Unicode/keycode weirdness and to be fast.
* **Snippet renderer** outputs `(text, caret_position)` so the injector can put the cursor where templates want it.

Below is a concrete blueprint for each required file, with implementation patterns that directly address your three failure modes.

---

## `src/expand_matcher.rs` — make trigger detection accurate and deletion-length correct

### What to change

1. **Track recent input as graphemes**, not bytes or `char`s.
2. **Update buffer only from “text inserted” events when possible.** If you’re currently building text from keycodes, you’ll always lose accuracy for IME and modifier-generated characters.
3. **Clear buffer aggressively** on any event that likely changes caret position or context:

   * arrow keys, home/end, page up/down
   * mouse click focus change (if you can observe)
   * selection shortcuts (Shift+Arrow, Cmd/Ctrl+A, etc.)
   * “dead key” / compose sequences if you can detect them

### A robust buffer representation

You want **both**:

* the full rolling `String` (so `ends_with(trigger)` is simple)
* a mapping of grapheme boundaries (so you can compute “delete N graphemes” correctly)

Pattern:

```rust
use unicode_segmentation::UnicodeSegmentation;

#[derive(Debug, Clone)]
pub struct TextBuffer {
    text: String,
    // grapheme boundary offsets into `text` in bytes, including 0 and text.len()
    boundaries: Vec<usize>,
    max_graphemes: usize,
}

impl TextBuffer {
    pub fn new(max_graphemes: usize) -> Self {
        Self { text: String::new(), boundaries: vec![0], max_graphemes }
    }

    pub fn clear(&mut self) {
        self.text.clear();
        self.boundaries.clear();
        self.boundaries.push(0);
    }

    pub fn push_text(&mut self, inserted: &str) {
        // Append grapheme by grapheme so boundaries stay correct.
        for g in inserted.graphemes(true) {
            let start = self.text.len();
            self.text.push_str(g);
            self.boundaries.push(self.text.len());

            // Enforce rolling max by dropping leading graphemes
            if self.grapheme_len() > self.max_graphemes {
                self.drop_front_graphemes(self.grapheme_len() - self.max_graphemes);
            }
        }
    }

    pub fn backspace(&mut self, graphemes: usize) {
        for _ in 0..graphemes {
            if self.grapheme_len() == 0 { break; }
            self.boundaries.pop();
            let new_len = *self.boundaries.last().unwrap_or(&0);
            self.text.truncate(new_len);
            if self.boundaries.is_empty() { self.boundaries.push(0); }
        }
    }

    pub fn grapheme_len(&self) -> usize {
        self.boundaries.len().saturating_sub(1)
    }

    fn drop_front_graphemes(&mut self, count: usize) {
        if count == 0 || self.grapheme_len() == 0 { return; }
        let drop = count.min(self.grapheme_len());
        let byte_start = self.boundaries[drop];
        self.text.drain(..byte_start);

        // Rebuild boundaries from scratch (simple + correct; buffer is small)
        self.boundaries.clear();
        self.boundaries.push(0);
        let mut acc = 0usize;
        for g in self.text.graphemes(true) {
            acc += g.len();
            self.boundaries.push(acc);
        }
    }

    pub fn as_str(&self) -> &str { &self.text }
}
```

### Trigger indexing (fast enough without overengineering)

Avoid scanning all triggers each keystroke if you have many.

A simple, effective index: group triggers by their **last char** (or last byte if ASCII-only triggers).

```rust
use std::collections::HashMap;

#[derive(Debug, Clone)]
pub struct TriggerEntry {
    pub trigger: String,
    pub trigger_graphemes: usize,
    pub id: String, // or whatever identifies the snippet
    pub require_boundary_before: bool,
}

pub struct TriggerIndex {
    by_last_char: HashMap<char, Vec<TriggerEntry>>,
}

impl TriggerIndex {
    pub fn new(mut triggers: Vec<TriggerEntry>) -> Self {
        // Longest match wins → sort descending by grapheme length
        triggers.sort_by_key(|t| std::cmp::Reverse(t.trigger_graphemes));
        let mut by_last_char: HashMap<char, Vec<TriggerEntry>> = HashMap::new();

        for t in triggers {
            if let Some(last) = t.trigger.chars().last() {
                by_last_char.entry(last).or_default().push(t);
            }
        }

        Self { by_last_char }
    }
}
```

### Match result must include deletion length

This is what the manager/injector needs:

```rust
#[derive(Debug, Clone)]
pub struct MatchInfo {
    pub snippet_id: String,
    pub trigger: String,
    pub delete_graphemes: usize,  // IMPORTANT
}
```

### Boundary check that prevents mid-word accidental expansions

If your triggers already include `;;` you can keep this permissive, but it’s still useful for plain-word triggers.

```rust
fn is_boundary_char(c: char) -> bool {
    c.is_whitespace() || c.is_ascii_punctuation()
}

fn boundary_before_ok(buffer: &str, trigger: &str) -> bool {
    let start = buffer.len().saturating_sub(trigger.len());
    if start == 0 { return true; }
    buffer[..start].chars().last().map(is_boundary_char).unwrap_or(true)
}
```

### Putting it together: match tail only

```rust
pub struct ExpandMatcher {
    buf: TextBuffer,
    triggers: TriggerIndex,
}

impl ExpandMatcher {
    pub fn ingest_text(&mut self, inserted: &str) -> Option<MatchInfo> {
        self.buf.push_text(inserted);
        self.try_match()
    }

    pub fn ingest_backspace(&mut self) {
        self.buf.backspace(1);
    }

    pub fn clear(&mut self) {
        self.buf.clear();
    }

    fn try_match(&self) -> Option<MatchInfo> {
        let s = self.buf.as_str();
        let last = s.chars().last()?;

        let candidates = self.triggers.by_last_char.get(&last)?;
        for t in candidates {
            if s.ends_with(&t.trigger) {
                if t.require_boundary_before && !boundary_before_ok(s, &t.trigger) {
                    continue;
                }
                return Some(MatchInfo {
                    snippet_id: t.id.clone(),
                    trigger: t.trigger.clone(),
                    delete_graphemes: t.trigger_graphemes,
                });
            }
        }
        None
    }
}
```

**Key win:** `delete_graphemes` is now correct even for Unicode triggers, and you can keep the buffer small (64–256 graphemes) so rebuilding boundaries isn’t expensive.

---

## `src/expand_manager.rs` — make replacement transactional and immune to your own injected events

### What to change

1. Add an **injection guard** so the matcher ignores events produced by the injector.
2. Ensure only **one expansion runs at a time** (fast typing otherwise overlaps).
3. Clear the matcher buffer after a successful expansion, and usually after *any* navigation/editing event that breaks context.
4. If timing is a problem, trigger on the *best signal you have* that text is in the app:

   * ideal: “text inserted” event
   * acceptable: key-up for the last character
   * fallback: key-down + micro-debounce (tiny delay) before delete/paste (implementation detail in your event loop)

### Injection guard (RAII)

```rust
use std::sync::{Arc, atomic::{AtomicBool, Ordering}};

pub struct InjectionGuard {
    flag: Arc<AtomicBool>,
}

impl InjectionGuard {
    pub fn new(flag: Arc<AtomicBool>) -> Option<Self> {
        // prevents re-entrancy
        if flag.swap(true, Ordering::SeqCst) {
            return None;
        }
        Some(Self { flag })
    }
}

impl Drop for InjectionGuard {
    fn drop(&mut self) {
        self.flag.store(false, Ordering::SeqCst);
    }
}
```

### Manager flow

* Receive event
* If injecting → ignore for matching
* Update matcher
* If match → render snippet → injector replaces → clear matcher

Pseudocode shape:

```rust
pub struct ExpandManager<I: TextInjector> {
    matcher: ExpandMatcher,
    injector: I,
    injecting: Arc<AtomicBool>,
    // snippet store, config, etc.
}

impl<I: TextInjector> ExpandManager<I> {
    pub fn handle_event(&mut self, event: InputEvent) {
        if self.injecting.load(Ordering::Relaxed) {
            return;
        }

        // 1) Update matcher based on event type
        let maybe_match = match event {
            InputEvent::TextInserted(ref s) => self.matcher.ingest_text(s),
            InputEvent::Backspace => { self.matcher.ingest_backspace(); None }
            InputEvent::NavigationOrSelection => { self.matcher.clear(); None }
            InputEvent::Paste(ref s) => self.matcher.ingest_text(s), // treat as insertion
            _ => None,
        };

        // 2) If we matched a trigger, perform expansion
        if let Some(mi) = maybe_match {
            self.expand(mi);
        }
    }

    fn expand(&mut self, mi: MatchInfo) {
        let Some(_guard) = InjectionGuard::new(self.injecting.clone()) else {
            return;
        };

        let snippet = match self.lookup_snippet(&mi.snippet_id) {
            Some(s) => s,
            None => { self.matcher.clear(); return; }
        };

        let rendered = match snippet.render(/* ctx */) {
            Ok(r) => r,
            Err(_) => { self.matcher.clear(); return; }
        };

        // Replace the trigger with rendered text
        if self.injector.replace_recent_text(mi.delete_graphemes, &rendered.text, rendered.caret_grapheme_index).is_ok() {
            self.matcher.clear();
        } else {
            // Failing safe: clear buffer so we don't chain bad state
            self.matcher.clear();
        }
    }
}
```

**Important behavioral choice:** If expansion starts, don’t try to be clever buffering the user’s additional keystrokes. Instead, make replacement *fast* (paste) so overlap is rare, and ignore injected events so you don’t spiral.

---

## `src/text_injector.rs` — delete precisely, inject fast, and stop Unicode from breaking you

### What to change

1. Implement a single high-level operation like:

   * `replace_recent_text(delete_graphemes, text, caret_pos)`
2. Prefer **paste injection** (clipboard-based) over typing char-by-char.
3. Deletion should be **N backspaces** (simple, reliable) or **shift-select-left N then paste** (useful if backspace behaves oddly in some apps).
4. Ensure modifier keys don’t “stick” (shift/alt/cmd states).
5. Restore clipboard after paste.

### Recommended replacement strategy

Order of operations (fastest + most reliable in real apps):

1. **Release modifiers** (at least Shift) to avoid selecting/uppercasing by accident.
2. **Backspace N graphemes** (for ASCII triggers this is perfect; for Unicode triggers it’s still usually fine).
3. **Paste** the expansion text.
4. **Move caret** to desired position (optional) by left-arrow repeats.

### Interface

```rust
pub trait TextInjector {
    fn replace_recent_text(
        &mut self,
        delete_graphemes: usize,
        text: &str,
        caret_grapheme_index: Option<usize>, // caret position from start of inserted text
    ) -> Result<(), InjectorError>;
}
```

### Caret positioning in graphemes

If caret position is `Some(idx_from_start)`:

* Let `total = grapheme_count(text)`
* After paste caret is at end → move left `total - idx_from_start`

```rust
use unicode_segmentation::UnicodeSegmentation;

fn grapheme_count(s: &str) -> usize {
    s.graphemes(true).count()
}
```

### Clipboard paste with restore (core idea)

Your actual clipboard code will differ by platform, but the logic should be:

* read clipboard → save
* write expansion text to clipboard
* send paste shortcut
* restore clipboard

Do this even on failure (RAII guard). This is what prevents “Unicode broke injection” and is also what makes injection extremely fast (less overlap with user typing).

### Artifact prevention

Artifacts usually happen from:

* deleting the wrong length (byte/char mismatch)
* injecting before the last trigger char actually appears in the app
* modifier keys still down (Shift makes selection; Alt changes characters)

Your manager should already reduce timing risk by triggering on the most reliable input event (text insertion / key-up). Your injector should:

* avoid per-character typing,
* and avoid selection logic that depends on app-specific selection semantics unless you must.

---

## `src/snippet.rs` — render templates deterministically and return caret intent

### What to change

1. Rendering should produce **(final_text, caret_position)** where caret position is an index in **graphemes**.
2. Make variable substitution strict and predictable:

   * unknown variables: leave literal or replace with empty (choose one and stick to it)
   * escaping: support `\{{` or similar so users can write literal braces
3. Handle a **cursor marker** (common patterns: `{{cursor}}`, `$CURSOR`, or `|`) so the injector knows where to put caret.

### Output type

```rust
#[derive(Debug, Clone)]
pub struct RenderedSnippet {
    pub text: String,
    pub caret_grapheme_index: Option<usize>,
}
```

### Cursor marker handling (simple + effective)

Example: support `{{cursor}}`. While rendering:

* when you hit `{{cursor}}`, record `caret = current_out_grapheme_len`
* do not emit any text for the marker

```rust
use unicode_segmentation::UnicodeSegmentation;

fn out_graphemes_len(out: &str) -> usize {
    out.graphemes(true).count()
}
```

### Minimal template substitution approach

If you don’t want to pull in a full templating engine:

* scan for `{{...}}`
* for each token:

  * if `cursor` → record caret
  * else resolve variable → append value

This keeps behavior controlled and avoids surprise escaping rules.

**Critical:** compute caret position in **graphemes**, not bytes.

---

## The integration contract that makes this solid

If you implement just one “law” across the project, make it this:

> **Matcher outputs deletion length in graphemes. Snippet outputs caret position in graphemes. Injector deletes and moves caret using graphemes.**

That’s what stops the Unicode/special-character bugs and the “selected wrong amount” artifacts.

---

## Test plan that will actually catch the bugs you’re seeing

### Unit tests

* **ExpandMatcher**

  * simple ASCII trigger at end
  * longest-match wins (`;;e` vs `;;email`)
  * boundary-before required for word triggers
  * backspace removes correctly
  * paste insertion works
  * navigation clears buffer

* **Snippet renderer**

  * `{{cursor}}` produces correct caret index
  * variables substitute correctly
  * cursor marker removed from output
  * Unicode text preserves caret correctness (emoji before cursor)

### Integration tests (mock injector)

* Feed events to manager:

  * type trigger → ensure injector called with `delete_graphemes == trigger_graphemes`
  * ensure manager ignores injected events when `injecting` flag is set
  * ensure matcher cleared after expansion

### Manual QA matrix (this matters)

Test expansions in:

* a “simple” text field (Notes-like)
* a browser input
* an IDE/editor
* a terminal (often weird)
* an app with IME/composition (or at least emoji picker)

Try:

* very fast typing after trigger
* triggers that include punctuation
* expansions containing emoji, combining marks, newlines, tabs

---

## If you want an exact diff, here’s what I need from you

Paste the current contents of:

* `src/expand_manager.rs`
* `src/expand_matcher.rs`
* `src/text_injector.rs`
* `src/snippet.rs`

…and I’ll rewrite them into an actual patch that preserves your existing types/events/platform code while applying the logic above.
