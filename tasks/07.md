Here’s the straight review, with the biggest risks first and concrete changes you can make without turning this into a science project.

## The 3 biggest issues in your current code

### 1) You’re caching *full* image payloads in memory (multiple ways)

Right now `refresh_entry_cache()` pulls `content` for the newest **500** entries and keeps it in memory (`Vec<ClipboardEntry>`). For image entries, `content` is a **base64 string of a PNG** (often megabytes). That means:

* **Startup** can allocate hundreds of MB to multiple GB depending on recent images.
* Every `add_entry()` triggers a full refresh: **you re-read and re-allocate those big base64 strings on every clipboard event**.
* Pagination isn’t helping as much as it should, because the cache refresh still loads “fat rows”.

This is the single biggest scalability and memory foot-gun in the repo.

**Fix direction (high priority):**

* Stop caching full `content` for image entries (and ideally don’t even select it for list pages).
* Split “entry metadata” from “payload” (image bytes / big text), and only fetch payload on-demand.

I’ll give specific schema/query changes further down.

---

### 2) Your timestamp is only seconds-resolution (ordering bugs are inevitable)

You write `timestamp = chrono::Utc::now().timestamp()` which is seconds. With a 500ms poll interval, it’s trivial to capture multiple items within one second. Your ordering is:

```sql
ORDER BY pinned DESC, timestamp DESC
```

If two entries land in the same second, ordering becomes ambiguous and can appear “wrong” in UI and cache. Also, dedup “move to top” becomes flaky when events are clustered.

**Fix direction (high priority):**

* Store **milliseconds** (`timestamp_millis()`) as INTEGER.
* Migrate old rows (`timestamp = timestamp * 1000`).

---

### 3) You can silently lose entries on transient DB errors

In `clipboard_monitor_loop()` you set `last_text = Some(text)` and `last_image_hash = Some(hash)` even if `add_entry()` fails. That means a temporary “database is locked” can permanently drop that clipboard item.

**Fix direction (high priority):**

* Only update `last_*` after a successful persistence (or implement a bounded retry/backoff).
* Also set a SQLite `busy_timeout` to reduce lock errors.

---

## 1) Polling vs Observer (and whether 500ms is “right”)

### Is 500ms the right polling interval?

500ms is a reasonable “it works everywhere” baseline, but it’s not the real question.

The real cost isn’t the timer — it’s that **you read clipboard contents every tick** (`get_text()` + `get_image()`), which can trigger expensive conversions in the OS clipboard subsystem.

Also, macOS is increasingly hostile to background pasteboard reads; Apple has previewed pasteboard privacy behavior that can alert users when apps read the pasteboard programmatically, and added APIs to detect types without reading content. If you keep reading full contents on a tight loop, you’re setting yourself up for user-visible pain. ([Michael Tsai][1])

### Should you use a native clipboard observer instead?

* **Windows:** yes, native notifications exist (best option).
* **Linux X11:** selection/clipboard change can be observed (varies by stack); Wayland is trickier.
* **macOS:** there’s no clean “push” callback for general pasteboard changes; most apps poll `changeCount`. That’s still polling, but **you only fetch contents when it actually changed**.

**Pragmatic recommendation:**

* Keep your cross-platform fallback polling, but change it to:

  1. poll a **cheap “change counter / sequence number”** (platform-specific),
  2. only then read clipboard content once per change.
* On macOS specifically, follow the “special/transient types” conventions (more below).

### How do you handle rapid clipboard changes?

With pure polling, you can’t guarantee capturing every intermediate state. If the user copies 3 times in <500ms, you’ll store the last one. That’s just physics.

You have three realistic options:

1. **Accept it** (most clipboard managers do; it’s fine for humans).
2. **Poll faster** (250ms) *but still imperfect* and more CPU/power.
3. **Event-driven where possible** (Windows), and on macOS do `changeCount` polling at a reasonable interval.

### What about transient clipboard content?

On macOS, there are established pasteboard types that mark content as transient or sensitive. Clipboard history apps typically ignore:

* `org.nspasteboard.TransientType`
* `org.nspasteboard.ConcealedType`
* `org.nspasteboard.AutoGeneratedType` ([GitHub][2])

This is exactly the ecosystem “play nice” guidance described on NSPasteboard.org. ([NSPasteboard.org][3])
Raycast explicitly calls out ignoring “transitive and sensitive information” and allowing users to configure apps to ignore. ([Raycast][4])

**Your current blocker:** `arboard` doesn’t expose pasteboard type metadata (at least not in your code), so you can’t respect these types today. If you want real parity with Raycast/Maccy/etc on macOS, you’ll likely need a macOS-specific clipboard layer (ObjC/Swift bridge) that can inspect types and skip sensitive/transient.

---

## 2) Image handling (base64-in-SQLite vs files, large images, conversion)

### Is base64 in SQLite efficient for images?

It’s simple, but not efficient:

* **Base64 adds ~33% size overhead**
* Storing as **TEXT** forces large allocations and copies in Rust `String`
* Your list queries and caches currently pull those strings constantly

For a handful of screenshots, it’s fine. For “real clipboard manager usage”, it will bite.

### Should you store images as files instead?

There are two sane architectures:

#### A) Keep images in SQLite, but store as BLOB and don’t pull them in list pages

* `content` becomes BLOB for images (raw PNG bytes)
* For list/paging queries, select metadata only
* When the UI needs the preview, fetch the blob for that single id

Pros: atomic, simpler backup story, one datastore
Cons: SQLite file can still get huge; vacuum behavior matters; reading blobs still allocates unless you stream

#### B) Content-addressable file store + SQLite metadata (my recommendation)

* Store image bytes at: `~/.sk/kit/clipboard-images/<sha256>.png`
* DB `history` row references `blob_key` (hash), plus width/height/size/mime
* Dedup becomes natural: multiple history rows can point to same file

Pros: DB stays small and fast; easy to prune old blobs; you can store thumbnails separately; avoids giant TEXT allocations
Cons: more moving parts; need garbage collection of orphan files

Given your current *in-memory entry cache* approach, you almost certainly want **B**.

### How do you handle very large images?

You need hard limits, because “one 8K screenshot” can blow your RAM if you decode/cache it.

Recommendations:

* Add `max_image_bytes` and/or `max_pixels` config. If exceeded:

  * store only a **downscaled thumbnail**, or
  * store nothing and log “skipped large image”, or
  * store but never pre-decode/cache, only decode on explicit user action.
* Store **thumbnail** separately (either in DB as small BLOB or as a small file). UI should almost never need the full-resolution image.

### What about image format conversion?

Your code currently stores **PNG** (`encode_image_as_png`) and legacy RGBA; it does **not** store JPEG despite what the high-level description implied.

PNG is great for screenshots; it can be awful for photos. A practical strategy:

* Encode to PNG first.
* If PNG exceeds a size threshold (say >2–5MB), re-encode lossy (JPEG/WebP) for storage/preview.
* Keep original only if the user explicitly wants “lossless”.

This is a product decision. But you need *some* policy, because “store every raw screenshot forever” doesn’t scale.

---

## 3) SQLite storage review (schema, indexes, growth, vacuuming)

### Your current schema vs the one in the prompt

The prompt shows `app_name`, `created_at`, etc. Your **actual code** schema is:

* `id TEXT PRIMARY KEY`
* `content TEXT NOT NULL`
* `content_hash TEXT`
* `content_type TEXT`
* `timestamp INTEGER`
* `pinned INTEGER`
* `ocr_text TEXT`

That’s reasonable for a v1.

### Indexes

You already have:

* `idx_timestamp (timestamp DESC)`
* `idx_pinned_timestamp (pinned DESC, timestamp DESC)`
* `idx_dedup (content_type, content_hash)`

This matches your primary access patterns.

Two important upgrades:

1. **Make dedup enforceable**
   Right now dedup is “best effort”; concurrent inserts can still create duplicates because `idx_dedup` isn’t unique.

Make it a **UNIQUE** index and use upsert:

* `CREATE UNIQUE INDEX ... ON history(content_type, content_hash);`
* `INSERT ... ON CONFLICT(content_type, content_hash) DO UPDATE SET timestamp = excluded.timestamp;`

2. **Full-text search**
   If you want fast search over text + OCR, add an FTS5 table. Otherwise you end up with slow `LIKE` scans.

### Database growth & compaction

You do:

* retention prune (great)
* incremental vacuum after prune
* WAL checkpoint every 10 prune cycles (good idea)

But there’s a gotcha: `PRAGMA auto_vacuum = INCREMENTAL;` only truly takes effect after a **VACUUM** on an existing database. Without that, `incremental_vacuum` may not reclaim anything meaningful.

**Add a one-time migration path:**

* detect if auto_vacuum isn’t incremental
* run a VACUUM once (maybe behind a “maintenance” flag so you don’t freeze UI unexpectedly)

Also: set a `busy_timeout` so you don’t drop entries on lock contention.

---

## 4) Caching review (what to keep, what to change)

### Is 100 entries the right cache size?

Your code actually caches:

* **500 entries** (`MAX_CACHED_ENTRIES`)
* **100 decoded images** (`MAX_IMAGE_CACHE_ENTRIES`)

“Right size” depends on *what* you cache. Caching 500 **text previews** is fine. Caching 500 **full image payloads** is not.

### Should you use LRU eviction?

Yes, but for two different things:

1. **Entry list cache** (metadata)

* Keep a simple fixed-size vec of lightweight metadata:

  * id, timestamp_ms, pinned, content_type, preview_text (truncated), width/height for images, maybe byte_size
* No need for LRU; newest-first + pinned-first is your ordering.

2. **Decoded image cache** (thumbnails)

* Use LRU, but ideally by **memory budget**, not “number of images”.
* Your current “100 images” assumption (1–4MB each) is wildly wrong for modern screens. A single 4K RGBA frame is ~32MB.
* If you can’t do weighted LRU quickly, just cap decoded images to something like 10–30 and make them thumbnails.

### Cache synchronization

Refreshing the entire cache from SQLite after every write is expensive and amplifies the image problem.

Better:

* On `add_entry()` success:

  * if it was a new id → push to top in memory
  * if dedup updated existing id → move that item to top
  * trim vec to max
* On pin/unpin/remove → update in memory and reorder

SQLite remains the source of truth; cache becomes a fast mirror updated incrementally.

---

## 5) OCR integration (sync vs async, on-device ML, failures, languages)

### When should OCR be performed?

**Async.** Always.

Synchronous OCR in the polling thread will:

* block clipboard capture
* increase missed events
* spike CPU usage at random times

Do:

* write entry first (fast)
* enqueue OCR job with entry id + image reference
* worker thread/process does OCR and calls `update_ocr_text(id, text)`

Raycast on Windows explicitly exposes “Automatic Text Recognition” as a setting, and “Visual information” too, which is the right product shape: OCR is valuable but optional. ([Raycast Manual][5])

### On-device ML (Apple Vision)?

If you’re shipping on macOS, yes — it’s typically faster and higher quality than bundling Tesseract, and avoids shipping huge language packs. Cross-platform, you’ll likely need:

* macOS: Vision
* Windows: Windows OCR
* Linux: Tesseract (optional)

### OCR failures

Store status so you don’t loop forever:

* `ocr_status` enum (`pending`, `done`, `failed`)
* `ocr_error` text (optional)

### Multi-language support

Don’t auto-do “all languages”. It’s slower and worse.

* Provide a setting for OCR languages (or “auto-detect” where supported)
* Allow per-entry retry

---

## 6) Privacy & security audit

Clipboard history is a security liability by definition. You need explicit product choices.

### Exclude password manager entries?

Yes — by default.

On macOS, the ecosystem convention is to mark sensitive or transient pasteboard content so clipboard managers can ignore it. ([GitHub][2])
Raycast explicitly says it ignores sensitive/transient info by default and lets users add ignored apps. ([Raycast][4])

**Actionable path:**

* macOS native layer: inspect pasteboard types, skip transient/concealed/autogenerated
* Add a user-facing ignore list by app (terminal, password managers, etc.)

### “Secure (concealed) clipboard”

If you can detect `org.nspasteboard.ConcealedType`, do one of:

* don’t store it at all (safest)
* store but **never show plaintext** and never write to disk unencrypted (complex)

### Should entries auto-expire?

You already have retention days; keep it.
Also consider:

* max total entries (e.g., 10k) OR max DB size
* per-entry TTL for unpinned items (especially images)

### Encryption at rest

If you want parity with top-tier tools, “optional encryption at rest” is the serious move. Raycast’s clipboard marketing claims the history is “fully encrypted” and “can only be read by you.” ([Raycast][6])

If you don’t want to do full SQLCipher:

* encrypt payload fields yourself (AES-GCM)
* store key in OS keychain
* set filesystem permissions on the DB and blob directory to user-only

### macOS pasteboard privacy trend

macOS has been experimenting with pasteboard privacy prompts and adding APIs to detect pasteboard patterns without reading content. ([Michael Tsai][1])
A background loop that reads clipboard contents repeatedly is the kind of thing that will get users angry fast if it triggers system warnings/prompts. Even if this doesn’t hit you today, architecting for “only read on change, and only when needed” is future-proofing you’ll be glad you did.

---

## 7) Performance analysis: scaling to 10,000+ entries

SQLite can handle 10k rows easily. Your bottlenecks are:

1. **Payload size** (images as base64 text)
2. **Repeated full-cache refresh** (500 rows loaded every insert)
3. **Decoded image memory** (RenderImage of full-res)

To scale cleanly:

* Store metadata in the `history` list query:

  * id, timestamp_ms, pinned, content_type, text_preview, width, height, byte_size, maybe source_app
* Fetch payload only when:

  * user opens detail view
  * user copies the item
  * UI needs thumbnail (and use a stored thumbnail)
* Use FTS5 for text + OCR search.
* Move writes onto a single “history service” thread:

  * monitor thread captures change → sends to service via channel
  * service handles dedup, DB write, incremental cache update, OCR queue
  * avoids cross-thread DB lock fights and makes behavior deterministic

### UI: virtual scrolling

Yes. Don’t load 10k items into a Vec in UI.
You already have pagination functions; just make sure those page queries don’t fetch megabyte payloads.

---

## 8) Feature parity vs Raycast / Paste / 1Password

### Raycast clipboard history (reference features)

Raycast advertises/supports:

* types: text, images, colors, links ([Raycast][6])
* pinning entries ([Raycast][6])
* ignores sensitive/transient info by default + ignore apps ([Raycast][4])
* on Windows: text recognition setting + disabled apps list + tracks files/links/colors ([Raycast Manual][5])

**What you’re missing (compared to that bar):**

* content-type richness (links/colors/files)
* ignore-apps + transient/concealed handling (macOS)
* “don’t load payload on list view”
* OCR toggle + searchable OCR via FTS
* encryption-at-rest story (if you want the “trust me” tier)

### Paste (the dedicated clipboard product bar)

Paste emphasizes:

* syncing across Mac/iPhone/iPad
* “privacy by design” with data staying on device / private iCloud
* “infinite history”, search, organization, sharing pinboards, and custom exclusion rules for sensitive apps ([Paste][7])

You probably don’t need all that for Script Kit, but the two ideas worth copying are:

* **rules/exclusions for sensitive apps**
* **organization primitives** (pinboards/tags) if your users want more than “recent list”

### 1Password clipboard handling

1Password focuses on reducing clipboard exposure by automatically clearing copied secrets after ~90 seconds (configurable). ([1Password][8])
That helps, but it doesn’t prevent a clipboard history tool from recording the secret in that 90-second window — which is why respecting concealed/transient conventions is important.

---

## A practical roadmap (do this in order)

### Phase 1 — Stop the bleeding (memory + correctness)

1. Switch to `timestamp_ms` everywhere (migration).
2. Add `busy_timeout` and don’t advance `last_*` if DB write failed.
3. Remove image payload from entry cache and list queries.

### Phase 2 — Make images sane

4. Store thumbnails separately; decode/cache thumbnails only.
5. Add max image size/pixels config; skip or downscale huge images.
6. Consider file-backed blob store keyed by hash.

### Phase 3 — Parity + polish

7. Add macOS pasteboard type detection and ignore transient/concealed/autogenerated.
8. Add ignore-app list (all platforms where feasible).
9. Add FTS5 for fast search over text + OCR.
10. Add optional encryption at rest.

---

## URLs (sources)

```text
https://www.raycast.com/core-features/clipboard-history
https://manual.raycast.com/windows/clipboard-history
https://www.raycast.com/changelog/page/9
https://github.com/p0deje/Maccy
https://nspasteboard.org/
https://support.1password.com/copy-passwords/
https://pasteapp.io/
https://mjtsai.com/blog/2025/05/12/pasteboard-privacy-preview-in-macos-15-4/
```

[1]: https://mjtsai.com/blog/2025/05/12/pasteboard-privacy-preview-in-macos-15-4/ "Michael Tsai - Blog  -  Pasteboard Privacy Preview in macOS 15.4"
[2]: https://github.com/p0deje/Maccy "GitHub - p0deje/Maccy: Lightweight clipboard manager for macOS"
[3]: https://nspasteboard.org/ "Identifying and Handling Transient or Special Data on the Clipboard | NSPasteboard.org"
[4]: https://www.raycast.com/changelog/page/9 "Raycast - macOS Changelog"
[5]: https://manual.raycast.com/windows/clipboard-history "Clipboard History"
[6]: https://www.raycast.com/core-features/clipboard-history "Clipboard History for Mac | Raycast"
[7]: https://pasteapp.io/ "Paste – The Best Clipboard Manager for Mac, iPhone, and iPad"
[8]: https://support.1password.com/copy-passwords/ "Copy and fill passwords into apps that don't work with 1Password | 1Password Support"
