Here’s the pragmatic way to get to a unified notification system **without** over-building it, while still leaving room for the features you want (stacking, actions, history, scripts, macOS system notifications).

## 0) The uncomfortable truth: you’re re‑implementing things you already have

Your “Problems” list says:

* **No Actions**
* **No Persistence**
* **No Stacking**
* **No Unique / Replace / Manual management**

…but `gpui-component`’s **Notification** already supports:

* action buttons (`.action(...)`)
* clickable notifications (`.on_click(...)`)
* persistent notifications (`.autohide(false)`)
* unique IDs you can replace/update/dismiss (`.id::<T>()`, `.id1::<T>(...)`, and `window.remove_notification::<T>()`) ([Longbridge][1])

So the fastest win is: **stop treating “ToastManager” as the system**, and instead make it a thin compatibility layer while you migrate to a unified service.

Also: GPUI Component expects you to render the notification layer via `Root::render_notification_layer(...)` (same idea as dialog/sheet layers). ([Longbridge][1])

## 1) Fix the core model: split “what happened” from “how it’s delivered”

Your proposed `Notification` type is solid, but two changes will save you pain:

### A. Don’t bake delivery into a single `NotificationStyle`

In reality you’ll want rules like:

* “If the window is hidden, **upgrade** toast → system notification (if allowed)”
* “If DND is on, **suppress** toast but still log history”
* “If urgent error, **also** show dialog”

So make delivery a policy/routing decision.

**Practical tweak:**

```rust
pub enum NotificationChannel {
    InAppToast,
    InAppHud,
    InAppBanner,
    InAppInline,
    System,     // macOS Notification Center
    Dialog,     // blocking
}

pub struct Notification {
    pub id: NotificationId,
    pub content: NotificationContent,
    pub behavior: NotificationBehavior,
    pub actions: Vec<NotificationAction>,
    pub source: NotificationSource,
    pub created_at: Instant,

    // NEW:
    pub channels: Vec<NotificationChannel>, // requested targets
    pub group_key: Option<String>,          // grouping/collapse
    pub dedupe_key: Option<String>,         // "same notification" collapsing
}
```

You can keep `NotificationStyle` if you prefer, but you’ll eventually end up with a second layer anyway (routing rules).

### B. Replace “replace_existing: bool” with “replace_key”

“Replace everything from the same script” is too blunt. A single script might want:

* one progress notification per task
* plus separate completion toast
* plus separate “warning: missing env var”

So prefer:

```rust
pub struct NotificationBehavior {
    pub duration: Option<Duration>,
    pub dismissable: bool,
    pub replace_key: Option<String>, // replaces only matching key
    pub sound: Option<NotificationSound>,
    pub priority: NotificationPriority,
}
```

Then your script API can do `replace: true` by setting `replace_key = Some(script_path)` *by default*, but still allow overrides.

## 2) Don’t use a static `Mutex<NotificationService>` in GPUI land

GPUI’s `App` and the state it owns live on the **UI thread**; it’s explicitly not `Send`. Globals in GPUI are meant to live inside the `App` as a “Global” singleton. ([Zed][2])

So instead of:

```rust
static SERVICE: OnceLock<Mutex<NotificationService>>
```

use GPUI globals:

* `cx.set_global(NotificationService::new())`
* `cx.update_global::<NotificationService, _>(...)`

That avoids lock contention and prevents you from accidentally calling UI-affecting code from the wrong thread.

This pattern also lines up with how GPUI expects async → UI updates to flow (spawn async, then update state on the main thread). ([Zed][2])

## 3) Use GPUI’s executor timer for auto-dismiss (don’t roll your own timing thread)

Zed’s GPUI async patterns show using the background executor’s timer:

```rust
cx.background_executor().timer(DURATION).await;
```

…then updating UI state. ([Zed][3])

So your auto-dismiss should be:

* schedule a task per notification
* when timer fires, `cx.update_global(...)` to dismiss if still present

This also makes “pause timers while window hidden” easy (see below).

## 4) Rendering strategy: don’t rewrite Toast UI first

### Toast renderer: map to `gpui-component::notification::Notification`

This immediately gives you:

* stacking (it’s a notification list at top-right)
* actions
* autohide control
* unique IDs / manual remove
* custom content

…all from a library you’re already using. ([Longbridge][1])

**Implementation approach:**

* Your `NotificationService::notify(...)` routes `InAppToast` → `window.push_notification(...)`.
* Use `NotificationType::{Info, Success, Warning, Error}` mapping.
* Use `.autohide(false)` if `duration == None`.

### HUD renderer: keep your current HUD manager (for now)

Just treat HUD as a channel and route to your existing overlay entity. (This is a migration tactic, not the end state.)

### Banner renderer: reserve for “attention but not blocking”

Think:

* “Update available”
* “Connection lost; retry?”
* “Script requires permission”
  It should be persistent or long-duration and show actions.

### Dialog renderer: treat as *rare*

Only for:

* destructive confirmation
* fatal errors that require immediate user choice

If you overuse dialogs, users will hate you.

### System notification: macOS integration

You have two realistic options:

1. **Simple, fast:** `mac-notification-sys`
   It can deliver notifications and set the delivering application bundle id. The README shows `set_application(...)` and `send_notification(...)`. ([GitHub][4])
   Downside: its own TODO list admits missing pieces (like timeout/auto-close) and it’s basically a wrapper around older macOS notification APIs. ([GitHub][4])
   It’s still fine for “Script finished” / “Reminder” style notifications.

2. **Modern + actions:** `objc2-user-notifications` (UserNotifications / `UNUserNotificationCenter`)
   That crate exists specifically for bindings to the UserNotifications framework. ([Docs.rs][5])
   More work, but it’s the path if you want interactive actions in Notification Center.

Also remember: macOS local notifications can be delivered even when your app isn’t running once scheduled. ([Apple Developer][6])

## 5) Stacking + collapse: pick a default that prevents spam

### Recommendation for Script Kit

**Show at most 3 toasts at once**.
Everything beyond that should collapse.

Why 3?

* Script Kit is a launcher/runner; scripts can spam output.
* If you let 10 stack, you’ll bury the UI and train users to ignore notifications.

**Collapse behavior:**

* Keep the 3 newest visible.
* Replace the rest with a single compact “overflow toast”:

  * “7 more notifications (click to open Notification History)”
* Alternatively: group by `source` (script path) and show:

  * “my-script.ts — 5 events (last: ‘File copied’)”

### Dedupe behavior (critical)

If 10 identical notifications arrive, don’t show 10. Show 1 with a counter:

* “Build completed (×10)”

This is what your `dedupe_key` is for.

### Rate limiting (also critical)

Add a per-source throttle, e.g.:

* max 1 toast / 250ms per script
* always store in history
* only surface the “latest” toast if spammy

## 6) Persistence rules that won’t surprise users

### Active vs History

You want two distinct stores:

* **Active**: currently visible / actionable notifications
* **History**: last N notifications (for review)

You already planned this; it’s correct.

### Persist across window hide/show?

Yes — **but with nuance**:

* **Persistent notifications** (duration = None): keep them active across hide/show.
* **Auto-dismiss notifications**: either

  * **pause** their timers while the window is hidden, or
  * allow them to expire but ensure they are in history.

I recommend:

* pause timers while hidden
* and for “high/urgent” also push a system notification

This prevents “I missed it because I switched apps for 5 seconds.”

## 7) When scripts notify while the window is hidden

This is the most important behavior decision you’ll make.

### Recommendation (simple + sane)

When Script Kit window is hidden/minimized:

* **Low/Normal priority** → record to history, optionally show nothing immediately
* **High priority** → show system notification (if enabled), record to history
* **Urgent** → system notification + (when app returns) banner/dialog depending on type

This avoids punishing users with constant system spam, while still surfacing important stuff.

Also: for progress notifications from scripts:

* don’t system-notify every progress tick
* only system-notify on completion/failure if hidden

## 8) Deep-linking from system notifications back into Script Kit

Yes, do it. Otherwise system notifications are dead ends.

### Practical behavior

Clicking a system notification should:

* bring Script Kit to foreground
* open the Notification History view
* optionally focus the specific notification (by id)

On macOS, you can store identifiers in the notification payload/userInfo with `UNUserNotificationCenter` (modern path). With simpler wrappers you may be limited, but you can still deep-link by encoding info in a URL or by keeping a “last notification clicked” state when the app activates.

Even a basic “Open History” is better than nothing.

## 9) Do Not Disturb mode

Yes, add it — because scripts will spam and users will blame you.

### What DND should actually do

DND should control **delivery**, not storage:

* suppress in-app toast/HUD/banner (optional)
* suppress sounds
* suppress system notifications
* still write to history

### Include:

* quick toggle (command palette)
* “Snooze 1h / until tomorrow”
* per-source mute (“mute this script”)

Do *not* overcomplicate with OS Focus integration early. Just ship app-level DND first.

## Direct answers to your Key Questions

1. **How many toasts should stack before collapsing?**
   **3 visible max**. Everything else groups/dedupes into an overflow indicator + history. This prevents notification spam from ruining the UI.

2. **Should notifications persist across window hide/show?**
   **Persistent + progress: yes.** Auto-dismiss: pause timers while hidden (or at least ensure history captures them). Don’t drop important events just because the window wasn’t visible.

3. **How to handle script notifications when window is hidden?**
   Route by priority: Low/Normal → history-only; High/Urgent → system notification + history; progress updates → only completion/failure system-notify.

4. **Should system notifications deep-link back to Script Kit?**
   **Yes.** At minimum: open the app + Notification History. Ideally: highlight the specific notification/run.

5. **Should there be a "Do Not Disturb" mode?**
   **Yes.** Make it suppress delivery (toasts/sounds/system), not suppress history.

## What I would implement first (fastest path to value)

1. **Introduce `NotificationService` as a GPUI Global** (no mutex, UI-thread-owned). ([Zed][2])
2. **Route Toast → gpui-component Notification** (instant actions + persistence + stacking). ([Longbridge][1])
3. **Route HUD → existing HUD manager** (compat layer).
4. **Add History storage + a simple history panel** (even read-only).
5. **Add script protocol `notify` with:**

   * basic toast/hud
   * progress handle
   * actions (return value)
6. **Add macOS system notifications (basic)**

   * start with `mac-notification-sys`
   * later upgrade to `objc2-user-notifications` if you want action buttons in Notification Center ([GitHub][4])

---

URLs

* [https://longbridge.github.io/gpui-component/docs/components/notification](https://longbridge.github.io/gpui-component/docs/components/notification)
* [https://longbridge.github.io/gpui-component/docs/root](https://longbridge.github.io/gpui-component/docs/root)
* [https://zed.dev/docs/development/glossary](https://zed.dev/docs/development/glossary)
* [https://zed.dev/blog/zed-decoded-async-rust](https://zed.dev/blog/zed-decoded-async-rust)
* [https://github.com/h4llow3En/mac-notification-sys](https://github.com/h4llow3En/mac-notification-sys)
* [https://docs.rs/objc2-user-notifications/](https://docs.rs/objc2-user-notifications/)
* [https://developer.apple.com/library/archive/documentation/NetworkingInternet/Conceptual/RemoteNotificationsPG/SchedulingandHandlingLocalNotifications.html](https://developer.apple.com/library/archive/documentation/NetworkingInternet/Conceptual/RemoteNotificationsPG/SchedulingandHandlingLocalNotifications.html)

[1]: https://longbridge.github.io/gpui-component/docs/components/notification "Notification | GPUI Component"
[2]: https://zed.dev/docs/development/glossary "Glossary | Zed Code Editor Documentation"
[3]: https://zed.dev/blog/zed-decoded-async-rust?utm_source=chatgpt.com "Async Rust — Zed's Blog"
[4]: https://github.com/h4llow3En/mac-notification-sys "GitHub - h4llow3En/mac-notification-sys: ✉️ A simple wrapper to deliver or schedule macOS Notifications in Rust"
[5]: https://docs.rs/objc2-user-notifications/?utm_source=chatgpt.com "objc2_user_notifications - Rust"
[6]: https://developer.apple.com/library/archive/documentation/NetworkingInternet/Conceptual/RemoteNotificationsPG/SchedulingandHandlingLocalNotifications.html?utm_source=chatgpt.com "Scheduling and Handling Local Notifications"
