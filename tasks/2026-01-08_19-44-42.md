Here’s the fastest path to making `./dev.sh` feel snappy:

* **Stop triggering runs for non-code noise** (docs, logs, DB files, editor temp files).
* **Stop re-running `build.rs` when anything in the repo changes** (this is a *huge* hidden tax).
* **Use a “fast dev” Cargo profile** with reduced debuginfo (often the biggest compile/link win for iteration).
* **Limit what `cargo watch` watches** (and don’t watch local deps/workspace members unless you really mean to).

Below are drop-in changes you can apply right now.

---

## 1) `dev.sh` rewrite: narrow watches, ignore aggressively, faster debounce

Key behaviors worth leaning on:

* `cargo watch` supports `-w/--watch`, `-i/--ignore`, and `-d/--delay` (debounce). ([Arch Manual Pages][1])
* If you use `-w`, it **disables auto-watching local dependencies** (often a lot of extra filesystem churn). ([Arch Manual Pages][1])
* Default debounce is **0.5s**; lowering it makes refresh feel faster. ([Arch Manual Pages][1])
* If you’re getting repeat triggers, `--why` tells you what file caused it. ([Arch Manual Pages][1])

Replace your `dev.sh` with this (or copy the relevant pieces):

```bash
#!/usr/bin/env bash
set -euo pipefail

# Project root = directory containing this script
ROOT="$(cd -- "$(dirname -- "${BASH_SOURCE[0]}")" && pwd)"
cd "$ROOT"

# ---- Tunables (override via env) ----
PROFILE="${PROFILE:-dev-fast}"     # see Cargo.toml section below
DELAY="${DELAY:-0.2}"              # cargo-watch default is 0.5s; 0.2 feels snappier
FEATURES="${FEATURES:-}"           # e.g. "foo,bar"
BIN="${BIN:-}"                     # e.g. "my-server-bin"
ARGS="${ARGS:-}"                   # e.g. "--port 3000"
WHY="${WHY:-0}"                    # set WHY=1 to debug triggers

# If your program writes files inside the repo (sqlite, logs, etc) and causes loops,
# consider turning this on:
WATCH_WHEN_IDLE="${WATCH_WHEN_IDLE:-0}"  # set to 1 to ignore events while commands run

# ---- Watch list: keep this tight ----
WATCH_PATHS=(
  "Cargo.toml"
  "Cargo.lock"
  "build.rs"
  "src"
  # Add ONLY what truly needs to trigger a restart:
  # ".env"
  # "migrations"
  # "templates"
  # "static"
)

# ---- Ignore list: kill noisy churn ----
IGNORE_PATTERNS=(
  # cargo-watch already ignores target/ and .git/ by default, but keep explicit if you want.
  "target/**"
  ".git/**"

  # Editor/OS junk
  "**/.DS_Store"
  "**/*.sw?"
  "**/*.sw?x"
  "**/*~"
  "**/#*#"
  "**/.#*"

  # Docs / non-runtime files
  "**/*.md"

  # Common noisy runtime outputs (adjust to your repo!)
  "**/*.log"
  "**/*.sqlite"
  "**/*.sqlite3"
  "**/*.db"
  "**/*.db-*"
  "**/*.db-journal/**"

  # If you have JS tooling around:
  "**/node_modules/**"
  "**/dist/**"
)

# ---- Preconditions ----
if ! command -v cargo >/dev/null 2>&1; then
  echo "error: cargo is not on PATH"
  exit 1
fi

if ! cargo watch --version >/dev/null 2>&1; then
  echo "error: cargo-watch is not installed (try: cargo install cargo-watch --locked)"
  exit 1
fi

# ---- Build cargo-watch argument vector safely ----
cmd=(cargo watch)

# Debounce: makes rebuilds feel more immediate when lowered, but don’t go to 0 unless you enjoy thrash.
cmd+=(-d "$DELAY")

# Only watch exactly what we specify (this also disables local-deps auto-watching).
for p in "${WATCH_PATHS[@]}"; do
  cmd+=(-w "$p")
done

# Ignore noise
for pat in "${IGNORE_PATTERNS[@]}"; do
  cmd+=(-i "$pat")
done

# Optional flags
if [[ "$WHY" == "1" ]]; then
  cmd+=(--why)
fi
if [[ "$WATCH_WHEN_IDLE" == "1" ]]; then
  cmd+=(--watch-when-idle)
fi

# Features (applied to the cargo subcommand)
if [[ -n "$FEATURES" ]]; then
  cmd+=(--features "$FEATURES")
fi

# Build the cargo subcommand executed on changes
cargo_run=("run" "--profile" "$PROFILE")

if [[ -n "$BIN" ]]; then
  cargo_run+=("--bin" "$BIN")
fi

# Pass args to your program after `--`
# shellcheck disable=SC2206
if [[ -n "$ARGS" ]]; then
  cargo_run+=("--" $ARGS)
fi

cmd+=(-x "$(printf '%s ' "${cargo_run[@]}" | sed -e 's/[[:space:]]*$//')")

echo "Running: ${cmd[*]}"
exec "${cmd[@]}"
```

Why this helps:

* You stop restarting on garbage file changes.
* You stop watching more of the workspace than necessary.
* You get a faster perceived feedback loop by reducing debounce.

---

## 2) `Cargo.toml`: add a fast dev profile (reduced debuginfo)

Rust’s default `dev` profile already has incremental compilation enabled (`incremental = true`) and uses many codegen units. ([Rust Documentation][2])
So if “cold start” and “rebuild” still feel slow, **debuginfo is usually the easiest win** (it affects compile + link time). Cargo supports multiple debuginfo levels. ([Rust Documentation][2])

Add this to your `Cargo.toml`:

```toml
# Faster iteration profile: less debuginfo, keep incremental on.
[profile.dev-fast]
inherits = "dev"
debug = 1              # less than default "full" debuginfo, usually faster to compile/link
incremental = true     # should already be true in dev, but make it explicit

# Optional: also reduce debuginfo for dependencies (often helps link time a bit).
[profile.dev-fast.package."*"]
debug = 0
```

Notes (tell-it-like-it-is):

* `debug = 1` is a solid compromise: backtraces still work decently, build times often drop.
* If your MSRV is new enough, you can go even leaner with `debug = "line-tables-only"` (fastest while keeping file/line in backtraces). ([Rust Documentation][2])
* Your normal `dev` profile stays untouched, so you can switch back any time (`PROFILE=dev ./dev.sh`).

Then the `dev.sh` above uses `--profile dev-fast` by default.

---

## 3) `build.rs`: stop it from re-running on every random file change

This is the silent killer.

Cargo’s default behavior: **if your build script doesn’t emit any `rerun-if-*` directives, Cargo will re-run it when *any* file in the package changes**. ([Rust Documentation][3])
That means touching `DEV.md`, editing a template, updating a JSON fixture… can cause `build.rs` to re-run, which can trigger rebuild work you didn’t expect.

### Minimal safe fix

At the top of `build.rs`, do this:

```rust
use std::path::Path;

fn main() {
    // If you don't print any rerun-if directives, Cargo re-runs build.rs for *any*
    // change in the package. Narrow it. :contentReference[oaicite:8]{index=8}
    println!("cargo:rerun-if-changed=build.rs");

    // If build.rs *actually* depends on other inputs, list them explicitly:
    // println!("cargo:rerun-if-changed=schemas/");
    // println!("cargo:rerun-if-changed=proto/");
    // println!("cargo:rerun-if-changed=some/config/file");

    // If you read env vars in build.rs, include them:
    // println!("cargo:rerun-if-env-changed=MY_BUILD_FLAG");

    // Example: if you embed git info, only do this when .git exists.
    if Path::new(".git/HEAD").exists() {
        println!("cargo:rerun-if-changed=.git/HEAD");
    }

    // ...rest of your build script...
}
```

Also: **don’t write generated artifacts into `src/`** or other watched directories. Build script outputs should go to `OUT_DIR`. ([Rust Documentation][3])
If you generate Rust code today into `src/generated.rs`, that can create rebuild loops and makes watch behavior worse.

If you want, paste your current `build.rs` and I’ll point out exactly which inputs to list and which work can be cached/skipped.

---

## 4) Add a `.ignore` file (optional but clean)

`cargo watch` respects `.ignore` files by default (same syntax as `.gitignore`). ([Arch Manual Pages][1])
This is often better than piling `-i` flags into scripts, especially if multiple dev commands exist.

Example `.ignore`:

```gitignore
# runtime junk
*.log
*.sqlite
*.sqlite3
*.db
*.db-*
**/*.db-journal/**

# editor junk
.DS_Store
*.sw?
*.sw?x
*~
#*#
.#*
```

---

## 5) Quick way to find what’s still triggering rebuilds

Run:

* `WHY=1 ./dev.sh`

That uses `cargo watch --why` to show which paths triggered the run. ([Arch Manual Pages][1])
Then you either:

* tighten `WATCH_PATHS`, or
* add an ignore pattern (prefer `.ignore` if it’s generally useful).

---

## Blunt expectations

* You can’t fully “fix” Rust rebuild cascades if you’re editing a module used everywhere; that’s the dependency graph doing its job.
* But you *can* stop **unrelated file edits** from causing rebuilds/restarts, and you *can* make the rebuilds you do need cheaper (less debuginfo, fewer build.rs reruns).
* If you’re developing inside Docker on macOS/Windows with bind mounts, compile speed can be dominated by filesystem overhead. In that case, putting `target/` (or `CARGO_TARGET_DIR`) on a container-local filesystem is often night-and-day. (cargo-watch’s docs even call this out.) ([GitHub][4])

---

```text
URLs
- https://man.archlinux.org/man/extra/cargo-watch/cargo-watch.1.en
- https://doc.rust-lang.org/cargo/reference/build-scripts.html
- https://doc.rust-lang.org/cargo/reference/profiles.html
- https://github.com/watchexec/cargo-watch
```

[1]: https://man.archlinux.org/man/extra/cargo-watch/cargo-watch.1.en "cargo-watch(1) — Arch manual pages"
[2]: https://doc.rust-lang.org/cargo/reference/profiles.html "Profiles - The Cargo Book"
[3]: https://doc.rust-lang.org/cargo/reference/build-scripts.html "Build Scripts - The Cargo Book"
[4]: https://github.com/watchexec/cargo-watch "GitHub - watchexec/cargo-watch: Watches over your Cargo project's source."
