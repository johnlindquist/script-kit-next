Here’s how to fix the three find/replace problems **without fighting GPUI’s state model**. I’m going to be blunt: almost all “my find box resets / highlights don’t show / replace-all freezes” bugs in GPUI-style UI come from (1) rebuilding stateful controls in `render`, (2) mixing index spaces (bytes vs chars vs line/col), and (3) doing N edits instead of one.

---

## What’s probably happening

### 1) Find state not persisting

You’re likely creating the find/replace `TextInput`/`InputState` **inside `render()` or on every `ShowEditor`**, so it starts fresh each time. GPUI Component explicitly calls out that **stateful components need their `Entity<…>` held in the view struct** or you’ll lose internal state (cursor, selection, value, etc.). ([Longbridge][1])

### 2) Match highlighting not rendering

Most common causes:

* You compute match ranges in **byte offsets** but apply them as **char offsets** (or vice versa).
* You apply “find highlight” *before* syntax highlighting, then syntax highlighting overwrites your styles.
* You store matches in editor state, but your text rendering code never reads them (or reads stale matches).

### 3) Replace-all freezes on large files

You’re probably doing something like:

* Find a match → replace → recompute layout → recompute syntax highlight → repeat N times.

That will absolutely hang on large buffers.

The correct pattern is:

* Compute all match ranges once
* Replace **from the end backwards** so earlier ranges don’t shift
* Apply **one** buffer update (or one transaction)
* Ideally do the heavy work off the immediate UI path (GPUI uses `spawn_in` for this pattern) ([Docs.rs][2])

---

## Fix `src/editor.rs`: make find/replace persistent and authoritative

### A. Create a real `FindReplaceState` and keep it on the editor struct

You need a single source of truth that survives re-renders:

```rust
#[derive(Clone, Debug, Default)]
pub struct FindReplaceState {
    pub open: bool,
    pub query: String,
    pub replacement: String,

    pub case_sensitive: bool,

    // IMPORTANT: pick ONE index space and stick to it:
    // - if your buffer is Ropey: store CHAR ranges
    // - if your buffer is String/&str slicing: store BYTE ranges
    pub matches: Vec<std::ops::Range<usize>>,
    pub active: usize,

    // used to avoid resetting active match during replace
    pub replacing: bool,

    // mark dirty to recompute matches when needed
    pub dirty: bool,
}
```

**Rule:** `FindReplaceState` lives with the editor/document, not with the toolbar UI.

---

### B. Don’t rebuild the find/replace inputs in `render()`

Create them once (typically in `new(...)`) and store them:

```rust
pub struct EditorView {
    editor: Entity<InputState>,        // your main text input
    find_input: Entity<InputState>,    // single line
    replace_input: Entity<InputState>, // single line
    find: FindReplaceState,
    _subs: Vec<Subscription>,
}
```

This is the exact “hold the Entity” rule from gpui-component docs. ([Longbridge][1])

Then subscribe once:

* On find input change → update `find.query`, set `dirty = true`
* On replace input change → update `find.replacement`

---

### C. Recompute matches in one place, and do it in the *same index space* you render with

#### If your backing store is Ropey

Ropey’s edits and slicing are in **char indices**, and it provides conversions between byte/char/line. ([cessen.github.io][3])
So if your matcher yields **byte** ranges (common with Aho-Corasick), convert once:

* store matches as byte ranges **or** char ranges, but don’t mix.
* if you store char ranges, convert `byte -> char` using `rope.byte_to_char(...)`. ([cessen.github.io][3])

#### Matcher choice

For plain text find (not regex), `aho-corasick` is a strong option and is used by gpui-component’s own search panel. ([Docs.rs][2])
If you only support a single pattern, it’s still fine.

---

### D. Replace next + replace all: do minimal buffer updates

#### Replace next

* Ensure matches are up-to-date.
* Replace just the active match.
* Mark `replacing = true` so that when you recompute matches you don’t reset `active` back to 0 (gpui-component uses exactly this idea). ([Docs.rs][2])

#### Replace all (this is the big freeze fix)

Do it like gpui-component does:

* take a snapshot of match ranges
* replace **from the end backwards**
* write the final result back once ([Docs.rs][2])

If you’re using Ropey, the “reverse replace” pattern is literally what their search panel does. ([Docs.rs][2])

---

## Fix `src/prompt_handler.rs`: stop nuking editor state on `ShowEditor`

Your find state resets when you:

* create a brand new editor view/entity whenever the prompt changes, or
* reinitialize inputs and call `default_value("")` / `set_value("")` / etc.

What to do:

### Option 1 (best): keep one editor entity alive per “open editor session”

In the handler, cache the editor entity and only update the document content when needed.

### Option 2: if you must recreate the editor, explicitly restore find state after

Order matters:

1. set editor buffer text
2. restore `find.query` and `find.replacement` into the find/replace inputs
3. mark matches dirty and recompute once

If you do it the other way around, your “text changed” listener will wipe match state.

---

## Fix `src/syntax.rs`: apply find highlights *after* syntect, without clobbering syntax styles

Syntect styles already include foreground/background/font style. ([Docs.rs][4])
And syntect has `StyleModifier` designed to change only one aspect (like background) while keeping the rest. ([Docs.rs][5])

### Correct pipeline

1. Produce syntax-highlighted spans (from syntect)
2. Overlay find highlighting by modifying only the background on spans that intersect matches
3. Render final spans

If you do syntax highlighting after find overlay, you’ll erase your match backgrounds.

### Common “why isn’t it showing?” bug

Your find overlay is probably setting:

* foreground color only (hard to notice), or
* a background that equals the theme background, or
* background alpha is 0.

Syntect’s `Style` has a `background` field, so you can set a visible one. ([Docs.rs][4])

---

## The two invariants you need to enforce

1. **Stateful UI elements must be stored, not rebuilt.**
   If your find/replace inputs are created in `render()`, you will keep losing text/cursor state. ([Longbridge][1])

2. **Pick one index space and never mix it.**
   If you use Ropey, convert byte ranges to char ranges using Ropey’s conversion functions (`byte_to_char`, etc.). ([cessen.github.io][3])

---

## Quick verification checklist

* Open find, type query, close find UI, reopen → query still there.
* Edit text while find UI open → matches update and highlight stays visible.
* Replace Next keeps stepping through matches (doesn’t jump back to first match).
* Replace All on a large file does **one** buffer update and doesn’t hang. (Reverse-order replace + one commit.) ([Docs.rs][2])

---

## If you want, I can turn this into an exact patch

To produce an exact diff for `src/editor.rs`, `src/prompt_handler.rs`, and `src/syntax.rs`, I need the actual file contents. Right now I can only give you the correct architecture and the failure modes to hunt.

[1]: https://longbridge.github.io/gpui-component/docs/getting-started?utm_source=chatgpt.com "Getting Started | GPUI Component"
[2]: https://docs.rs/crate/gpui-component/latest/source/src/input/search.rs "gpui-component 0.5.0 - Docs.rs"
[3]: https://cessen.github.io/ropey/ropey/struct.Rope.html?utm_source=chatgpt.com "ropey::Rope - Rust"
[4]: https://docs.rs/syntect/latest/syntect/highlighting/struct.Style.html?utm_source=chatgpt.com "Style in syntect::highlighting - Rust"
[5]: https://docs.rs/syntect/latest/syntect/highlighting/struct.StyleModifier.html?utm_source=chatgpt.com "StyleModifier in syntect::highlighting - Rust"
