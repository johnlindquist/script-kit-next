Below is a straight audit of what you have, what’s solid, what’s risky, and what I’d change first. I’m going to be blunt where it matters (data loss, UI jank, lifecycle leaks), and practical on the rest.

---

## 1) Secondary window management audit

### What’s good

* **Single-instance window** via a global handle is the right direction. A separate notes window should behave like a “tool window” you can toggle.
* **Root wrapper pattern** with `gpui-component::Root` is consistent and keeps the Notes UI isolated.
* **Theme sync on open** (`gpui_component::init` + `sync_gpui_component_theme`) is the right approach in principle.
* **Focus on open** is handled intentionally (activate app, hide main window, focus editor).

### What will bite you

#### A. Your global handle becomes stale when the window closes itself

You close the window from inside Notes via Cmd+W:

```rust
"w" => window.remove_window();
```

…but you **do not clear** `NOTES_WINDOW` when the user closes it that way (or clicks the red traffic light). That means:

* `is_notes_window_open()` can return `true` even when it’s gone.
* The next toggle will hit the “invalid handle” path (sometimes) and recreate.
* Any background task holding `Entity<NotesApp>` may keep trying to update a dead entity.

**Fix**: you need a **window-closed hook** that clears the global handle (and cancels per-window tasks). If gpui doesn’t give you an explicit “on_close” callback, you can still solve it by:

* storing a `WindowId` and validating it, or
* storing a controller object that you explicitly tear down on `remove_window()`, and also on any internal close path.

At minimum: route all “close window” actions through a single function that also clears the global.

#### B. The theme watcher task likely leaks across open/close

You `spawn(async move { loop { ... }})` and `.detach()` it every time you open the Notes window. That task:

* runs forever (even after closing Notes)
* holds an `Entity<NotesApp>` clone, which can keep the entity alive longer than intended
* will attempt updates after the window is gone (best case: harmless errors; worst: subtle leaks and logs)

**Fix**: make the theme watcher **global singleton** (one watcher for the app), and broadcast theme updates (or just call `sync_gpui_component_theme` once and let views re-render). Or if it must be per-window, you need a cancellation token tied to window lifetime.

#### C. Lock scope is wider than it needs to be

In `open_notes_window`, you lock `NOTES_WINDOW` and then do a bunch of work (hide main window, open window, focus, configure floating panel, spawn watcher). That’s not catastrophic (this is likely on a single UI thread), but it’s still cleaner and safer to:

* lock only to check/set the handle
* do everything else outside the lock

### Is `OnceLock<Mutex<Option<WindowHandle>>>` the right pattern?

**It’s acceptable**, but it’s incomplete unless you fix lifecycle cleanup.

If you want the pattern to age well, I’d replace the `Option<WindowHandle<Root>>` with a small controller struct:

```rust
struct NotesWindowController {
    handle: gpui::WindowHandle<Root>,
    notes_app: Entity<NotesApp>,
    // maybe: cancel tokens, “main was visible” flag, etc.
}
static NOTES_WINDOW: OnceLock<Mutex<Option<NotesWindowController>>> = OnceLock::new();
```

That makes it possible to:

* clear everything on close
* run targeted updates (create note, quick capture) without plumbing temporary holders

### Window state persistence

Right now you explicitly disable macOS restoration (`setRestorable:false`), so **you need your own persistence** if you want stable behavior.

Persist at least:

* window bounds (x/y/w/h) and display ID if you can
* `auto_sizing_enabled`
* last selected note id
* last view mode (AllNotes vs Trash)

Persist on:

* window close
* manual resize (when you detect it)
* note selection change

Restore on open:

* use persisted bounds if valid; otherwise fall back to “top-right near mouse”

### Should secondary windows share state with the main app?

* **Theme**: yes (you already do).
* **Notes content**: the DB should be the source of truth. Don’t mirror giant note bodies into a global shared state unless you need cross-window live updates.
* **Lightweight metadata** (selected note id, last used sort, etc.): yes, share via a small persisted state model.

If you ever add “quick capture from main window” that creates/updates notes, you’ll want either:

* an event bus that tells Notes window “reload metadata / refresh list”
* or a shared `NotesStore` model entity that owns caching and DB operations

### Focus management between windows

You’re doing the right things to force focus on macOS:

* `cx.activate(true)`
* `window.activate_window()`
* focus editor InputState

But there are 2 UX gaps:

1. When Notes opens and you hide the main window, you don’t track whether the main window was previously visible and should be restored when Notes closes. That’s a choice, but Raycast-style tools typically restore focus to what was previously active.
2. Your browse panel likely doesn’t focus the search input by default (more on that below), which makes Cmd+P feel “dead” until you click.

---

## 2) SQLite review (thread safety, migrations, query efficiency)

### Connection handling: thread-safe enough, but UI-blocking

You’re using:

```rust
static NOTES_DB: OnceLock<Arc<Mutex<Connection>>> = OnceLock::new();
```

This is **functionally thread-safe** (single connection guarded by a mutex), but it has two practical issues:

1. **All DB operations are blocking** and can run on the UI thread (you call `save_note()` directly inside `on_editor_change`). That will stutter typing, especially with:

* large notes
* FTS triggers
* spinning disks / slow IO

2. **Write-amplification**: you write on every change event. That’s the bigger issue than mutex contention.

**Recommendation**: keep rusqlite, but move DB IO off the render/event path.

* simplest: debounce saves and run them in a background task/thread
* better: a single DB worker thread that serializes all commands (no Mutex needed)

### The biggest performance bug: saving on every keystroke

`on_editor_change` calls `storage::save_note(note)` for every `InputEvent::Change`.

That will murder performance as notes grow, and will also churn your FTS table via triggers.

**Fix** (minimum viable):

* Mark the note dirty on change
* Start/refresh a short debounce timer (e.g., 250–500ms)
* Save once after user pauses typing
* Also save immediately on blur/close

### FTS5: yes, but your query as written is probably wrong

In `search_notes`:

```sql
ORDER BY rank
```

Unless you have a `rank` column/function wired up, this is likely to fail at runtime. In FTS5, you typically do:

```sql
ORDER BY bm25(fts)
```

or define your own ranking.

Also: when creating an external-content FTS table (`content='notes'`), you should rebuild it at least once if notes might already exist:

```sql
INSERT INTO notes_fts(notes_fts) VALUES('rebuild');
```

Otherwise, older rows that existed before FTS creation won’t be searchable.

### Your triggers update FTS even when only metadata changes

Your `notes_au` trigger fires on every UPDATE, including pin/deleted/sort changes. That means toggling pin causes a delete+insert into FTS for unchanged content.

**Better**: restrict the trigger to title/content only:

```sql
CREATE TRIGGER ... AFTER UPDATE OF title, content ON notes BEGIN ...
```

### Timestamp storage as RFC3339 TEXT: risky for comparisons

You compare timestamps in SQL (prune):

```sql
deleted_at < ?1
```

If you store variable-format RFC3339 strings (sometimes with fractional seconds, sometimes not), lexicographic comparisons can be wrong.

**Safer options**:

* store `created_at_ms`, `updated_at_ms`, `deleted_at_ms` as `INTEGER` (epoch millis)
* or force a fixed RFC3339 format with consistent fractional digits (e.g., millis always)

### Migrations

Right now initialization is `CREATE TABLE IF NOT EXISTS ...`. That’s fine until you need to change schema.

Use either:

* `PRAGMA user_version` and apply incremental migrations, or
* a migration crate (refinery, sqlx migrations) if you already have infrastructure

Given you’re using rusqlite, `user_version` is totally fine and lightweight.

### Async SQLite library?

You don’t need to jump to an async sqlite crate unless you already have an async runtime and want to integrate deeply. For a desktop UI:

* **blocking DB on a worker thread** is usually the cleanest and simplest.

### FTS5 the right choice?

Yes, if:

* you want content search
* you accept maintaining an index (more disk and some write cost)

If you expect only tiny note sets (<200), you could skip it, but Raycast parity implies FTS is correct.

---

## 3) Markdown editing review

### Current state: formatting buttons don’t actually format

Your formatting toolbar calls:

```rust
this.insert_formatting("**", "**", cx);
```

But `insert_formatting` currently **does not update** the editor state. It builds `formatted` and discards it.

So the toolbar and Cmd+B/Cmd+I shortcuts are effectively no-ops.

**Fix**: implement insertion around current selection. You already use:

* `state.set_value(...)`
* `state.set_selection(start, end, ...)`

So implement:

1. read current value
2. read current selection range
3. splice prefix/suffix around selection
4. set value + set new selection

If InputState doesn’t expose selection read APIs, you’ll need to track selection yourself (or add methods upstream).

### Auto-resize is based on newline count only (not visual lines)

You resize based on:

```rust
content_string.lines().count()
```

This misses the most common case: **long lines wrapping** due to window width. Raycast-like auto-grow should respond to actual rendered height, not just newline count.

If GPUI doesn’t expose text layout height, you have three options:

* Accept that auto-sizing is approximate and only based on newlines (cheap but imperfect)
* Measure text with a layout API if available (best)
* Drop auto-grow and keep a fixed-height editor with scroll (most robust, most “native” feeling)

If you keep it, at least update height when:

* selecting a different note (you currently don’t)
* window width changes (wrap changes)

### Export duplicates titles

Because you derive `note.title` from the first line of `note.content`, your Markdown export does this:

```rust
"# {}\n\n{}", note.title, note.content
```

That can duplicate the title line.

Either:

* treat `content` as the body without the title, or
* export only `note.content` for markdown, or
* store title separately as a first-class field and don’t derive it from content continuously

### Markdown AST / preview / syntax highlighting

* **AST**: only worth it when you do preview rendering, backlinks, heading navigation, etc. For now, string-based editing is fine.
* **Preview mode**: good next step for Raycast parity. Parse markdown (pulldown-cmark) → render in GPUI (or HTML in a webview-like component if you have one).
* **Syntax highlighting**: hard to do well in a plain Input. If you want real highlighting, you may need a richer text editor component (tree-sitter, syntect, etc.) or a dedicated code/markdown editor widget.

### Templates

Templates are a nice-to-have. Keep it simple: per-note “new note template” config or a small set of built-ins.

---

## 4) Actions panel (Cmd+K) UX + extensibility

### What’s strong

* Your actions panel is the most polished piece. Uniform list virtualization, stable search input positioning, keyboard routing—this is Raycast-like.

### Problems / mismatches

* Your header docs mention actions like Delete, but the enum doesn’t include Delete. Either add it or update docs.
* “Copy Note As…” currently just calls `copy_note_as_markdown()` (not a chooser).
* “Export…” uses HTML and copies to clipboard only; not really export.

### Should actions be extensible?

If you foresee plugins or “commands”, design now:

* define an `ActionDescriptor { id, label, keys, enabled, handler }`
* build the panel from a list of descriptors
* keep `NotesAction` enum for core actions, and allow additional actions to be appended

If you don’t foresee that: static enum is fine and simpler.

### Keyboard navigation handling

Your approach (NotesApp routes keydowns to the panel) works, but it’s brittle over time. It’s easy to miss edge keys (delete, cmd+backspace, IME input).

If GPUI supports letting the focused component handle text input directly, that’s usually better. If not, your approach is acceptable—just plan to harden it:

* handle `Delete` key too
* handle non-ASCII / IME composition if relevant
* add fuzzy matching (Raycast uses fuzzy search, not contains)

---

## 5) Browse panel (Cmd+P) review

### Biggest UX issue: search probably doesn’t work until you click

When you open the browse panel, you focus the panel:

```rust
let panel_focus_handle = browse_panel.read(cx).focus_handle(cx);
window.focus(&panel_focus_handle, cx);
```

But you never focus the search input’s `InputState`.

So users hit Cmd+P and type… and nothing happens unless the input is already focused by some internal behavior. This will feel broken.

**Fix**: add a `focus_search(window, cx)` method on `BrowsePanel` and call it after creation, or programmatically focus `search_state` inside `BrowsePanel::new`/first render.

### No virtualization

Browse panel renders all rows in a loop. For many notes, this will become slow. You already have a good virtualization pattern in actions panel (`uniform_list`). Reuse it here.

### Pin toggling doesn’t resort the list

You toggle `is_pinned` and save, but you don’t re-sort `self.notes`. Users expect pinned notes to jump to the top immediately (Raycast does).

### Search only filters by title

That’s fine for v1, but Raycast-like “Browse Notes” search should hit content too. You already have FTS—use it.

* either call `storage::search_notes(query)` when query is non-empty
* or keep title-filtering for instant feedback and add “press Enter to search content” (not as good)

### Trash flow is incomplete in UI

You have a `Trash` view mode and restore/permanent delete actions in the editor UI, but there’s no discoverable way to enter Trash (no action, no button). That’s an unfinished loop.

---

## Specific code areas you flagged

### 1) `update_window_height()` (auto-sizing)

Current issues:

* only reacts to newline count (not wrapping)
* doesn’t resize when selecting a different note
* can disable auto-sizing due to “manual resize detection” when the system adjusts size slightly
* debug log prints the same height for “last” and “current” after you overwrite it

If you keep auto-sizing:

* recalc on note selection
* recalc when window width changes
* debounce resizes (avoid frequent `window.resize` churn)

### 2) Sidebar toggle logic

Sidebar is removed, but there are remnants: `search_state`, `render_search`, etc. Clean this up or finish the integration. Dead UI state tends to rot quickly.

### 3) Note list rendering

Actions panel is virtualized well. Browse panel should be too. Also consider “metadata-only load” from DB for the list.

### 4) Trash/restore flow

Soft delete is fine as a model. UX needs:

* a visible way to enter Trash
* a confirmation or undo affordance for delete
* pruning policy clarity (you have prune; make it discoverable)

---

## 6) Performance profile (startup time, memory, big note sets)

### The current hot spots

1. **DB writes per keystroke** (and FTS trigger churn) — biggest issue.
2. **Loading full note content for all notes on startup** — big memory and slow open when notes grow.
3. **Recomputing char_count by iterating content** for every note list item — O(total content size).
4. **Line counting and title extraction** on every change — O(note size) repeated.

### Practical fixes (in order)

1. **Debounce saving** (and ideally do it off the UI thread)
2. **Load metadata only for list**, lazy-load full content for the selected note

   * store `title`, `updated_at`, maybe a short preview in DB for list
3. **Compute counts in SQL** (`LENGTH(content)`), or store counts in DB and update on save
4. **Reduce FTS updates** to only when title/content changes (trigger restriction)
5. **Use WAL mode** (PRAGMA journal_mode=WAL) for smoother writes
6. **Cancel background tasks** when window closes (theme watcher)

---

## “Native feel” UX assessment vs Raycast / Apple Notes / Obsidian quick capture

### Where it matches Raycast well

* Cmd+K action palette style is very Raycast-like.
* Minimal chrome (hover reveal) is consistent with Raycast’s “tool window” vibe.
* Separate floating window with a dedicated hotkey is a good pattern.

### Where it currently doesn’t feel native (and why)

* **Potential data loss** when no note is selected: the editor lets you type but nothing is saved. That’s not acceptable in a notes app.
* **Browse panel typing likely doesn’t work immediately** unless the search input is focused.
* **Auto-resize will feel “random”** because it ignores wrapping and doesn’t update on note selection.
* **Export behavior** is “copy to clipboard” and duplicates title; users expect either file export or clean clipboard copy.

### Compared to Apple Notes

Apple Notes is less “command palette” and more “document app”. Your approach is fine for a quick-capture tool, but you need:

* robust autosave behavior (debounced, reliable)
* no-surprises editing (don’t let users type into nothing)

### Compared to Obsidian quick capture

Obsidian users will ask for:

* plain markdown files
* folder structure
* search across vault
  If you’re intentionally building Raycast parity, SQLite is fine—but consider offering export-to-file later.

---

## What I would do next (a tight, high-impact checklist)

### Must-fix (correctness / data safety)

* **Auto-create a note when typing with no selection** (or create a first note on open).
* **Clear the global window handle on any close path** (Cmd+W, traffic light, toggle close).
* **Stop leaking the theme watcher task** across window sessions.

### Must-fix (performance)

* **Debounce saving** (and preferably move DB writes off the UI thread).
* Fix FTS search `ORDER BY` and rebuild FTS for existing data.

### Should-fix (UX polish)

* Focus the browse panel search input by default.
* Re-sort notes immediately on pin toggle.
* Fix markdown export duplication and make “Copy Note As…” actually choose formats.

### Later

* Lazy-load note content (metadata list + selected note content)
* Virtualize browse list
* Preview mode / syntax highlighting if you decide it’s worth the complexity

---

If you want one guiding principle: **treat “typing into Notes” as sacred**. The window should never accept input that isn’t persisted to a real note, and persistence should never hitch the UI. Everything else is secondary.
