<previous-analyses>
This refactor has **already been done** — commit `9d2111b2` ("refactor(executor): dedupe runtime fallback chain") is the most recent commit, and the code already contains:

1. **`RuntimeAttempt` struct** (line 574) with `name`, `label`, `cmd`, `args`
2. **`run_fallback_chain<T>()`** generic helper (line 581) that iterates attempts, logs, runs the closure, and returns `Option<T>`
3. **`execute_script_interactive`** (line 622) using `run_fallback_chain` with `spawn_script`
4. **`execute_script`** (line 772) using `run_fallback_chain` with `run_command`

All three Oracle tasks are already implemented. Here's the summary:

- `agent-core-fallback-abstraction` scope:`src/executor/runner.rs` — **Already done**: `RuntimeAttempt` struct + `run_fallback_chain<T>()` generic at lines 574-618
- `agent-refactor-execute_script_interactive` scope:`src/executor/runner.rs` — **Already done**: builds `Vec<RuntimeAttempt>`, calls `run_fallback_chain(spawn_script)` at line 675
- `agent-refactor-execute_script_blocking` scope:`src/executor/runner.rs` — **Already done**: builds attempts, calls `run_fallback_chain(run_command)` at line 832

NEXT_AREA: `execute_script()` stderr-vs-stdout return semantics — currently returns stderr when stdout is empty even on success (see `run_command` at line 857+).
---
Looking at the Oracle analysis, here are the extracted swarm tasks:

- `submit-callback-helper` scope:`src/prompt_handler/mod.rs` — Extract shared submit callback closure used by 7 identical prompt handlers
- `window-prep-dedup` scope:`src/prompt_handler/mod.rs` — Extract window reset + visibility check block from 3 prompt handlers
- `sdk-actions-shortcuts-helper` scope:`src/prompt_handler/mod.rs` — Extract SDK actions + shortcut registry rebuild from ShowArg and SetActions

NEXT_AREA: Standardize `try_send` error handling across state/layout/ai/chat/confirm behind a single `send_response_or_log()` helper

Want me to dispatch these to a codex-swarm, or implement them sequentially?
---
Looking at this, I'll extract the swarm tasks in the requested format:

- `on-close-callback-factory` scope:`src/app_impl/actions_toggle.rs` — Extract identical set_on_close callback into shared factory method
- `spawn-open-actions-window` scope:`src/app_impl/actions_toggle.rs` — Extract spawn/open_actions_window block into shared helper
- `actions-popup-preamble` scope:`src/app_impl/actions_toggle.rs` — Extract 4-line popup open preamble into begin helper method

NEXT_AREA: ActionsWindow auto-close `focus_lost` path vs `on_close` callback ordering — race between `platform::activate_main_window()` and focus restoration on popup dismiss.

Want me to dispatch these to a codex-swarm, or implement them sequentially?
---
</previous-analyses>

Do NOT repeat items already covered above. Find something new.
## Target Code

FEATURE: `ensure_tsconfig_paths` in setup/mod.rs parses user's tsconfig.json and panics via `.unwrap()` if `compilerOptions` or `paths` has an unexpected JSON type
FILES: src/setup/mod.rs
SMELL: Three `.unwrap()` calls on `as_object_mut()` (lines 965, 996, 998) in production code will panic if a user's tsconfig.json has malformed `compilerOptions` or `paths` fields (e.g., a string instead of an object), violating the project's no-unwrap-in-production rule

## Task: error handling fix: find missing guards, unchecked returns, brittle parsing, swallowed errors — write the corrected code with proper error handling

## CONTEXT: You are generating work orders for a codex-swarm

Your output will be handed DIRECTLY to a `/codex-swarm` dispatcher that spawns parallel Codex AI agents (GPT-5.3) to implement your recommendations. Each task you write becomes a worker that edits real files autonomously. The workers have NO context beyond what you write in the task description — they cannot ask questions.

## Output Format — SWARM TASK LIST

Output 1-4 tasks. For each task, output this EXACT structure:

### Task N: `<worker-id>`

**Scope:** `<glob pattern for files this worker should touch>`

**Task:**
<2-4 paragraphs briefing a senior engineer. Be EXHAUSTIVE — the worker has zero context beyond this text.>

<Paragraph 1: What is wrong, which specific files/functions/lines are involved, and what the fix should accomplish.>

<Paragraph 2: The exact implementation — what code to change, what the replacement should look like, what patterns to follow from the existing codebase. Include function signatures, variable names, types.>

<Paragraph 3: Edge cases and constraints — what NOT to break, what to watch out for, how to verify the fix works.>

## Rules

- Worker IDs must be short kebab-case: `fix-fts-trigger`, `add-search-debounce`, `rm-dead-exports`
- Scope must be a glob: `src/notes/storage.rs`, `src/auth/**/*.ts`, `src/menu_bar/*.rs`
- Each worker should own at most ~10 files. If a fix spans more, split into multiple tasks
- Task descriptions must be SELF-CONTAINED — include file paths, function names, current buggy code snippets, and what the corrected code should look like
- Do NOT suggest adding documentation, comments, or docstrings — only functional code changes
- Do NOT suggest adding logging unless it fixes an actual bug
- Prioritize by impact: bugs > security > performance > cleanup
- Maximum 4 tasks per iteration — fewer is better if they're high-quality
- End with: NEXT_AREA: <suggest one unexplored area for future analysis>
