Good — no unwrap in hotkey_pollers. But it has 42 `logging::log` calls and a 215-line deeply-nested `start_listening` function. Now I have everything I need to write the work orders. Let me verify line 287 has the `.unwrap_or(true)` which is the only near-unwrap.

Now I have a comprehensive analysis. Here are the findings and work orders:

---

### Task 1: `migrate-process-manager-logging`

**Scope:** `src/process_manager/mod.rs`

**Task:**
The file `src/process_manager/mod.rs` contains 27 `logging::log("PROC", &format!(...))` calls and zero `tracing` macro usage, violating CLAUDE.md rule #4: "Use `tracing::{info,warn,error,debug,trace}` for all new/modified code." The file also has a module-level `#![allow(dead_code)]` suppression (line 4), a leftover `// --- merged from part_000.rs ---` comment (line 14), and a leftover `// --- merged from part_001.rs ---` comment (line 448). The `use crate::logging;` import (line 15) should be removed once all calls are migrated.

Replace every `logging::log("PROC", &format!("...", args))` call with the appropriate `tracing` macro using structured fields. Use `tracing::info!` for success/normal operations, `tracing::warn!` for failures that are handled gracefully, and `tracing::debug!` for verbose operational details. For example, line 74-77 `logging::log("PROC", &format!("Writing main PID {} to {:?}", pid, self.main_pid_path))` becomes `tracing::info!(pid, path = ?self.main_pid_path, "writing main PID")`. Line 109 `logging::log("PROC", &format!("Failed to remove main PID file: {}", e))` becomes `tracing::warn!(%e, "failed to remove main PID file")`. Line 164 `logging::log("PROC", &format!("Failed to persist active PIDs: {}", e))` becomes `tracing::warn!(%e, "failed to persist active PIDs")`. Also remove the `#![allow(dead_code)]` on line 4, delete both `// --- merged from part_*.rs ---` comments (lines 14 and 448), delete the `// =====` banner comment (lines 449-451), and remove `use crate::logging;` from line 15. Add `use tracing;` is not needed — tracing macros are available without an explicit import in this codebase. Verify with `cargo check && cargo clippy --all-targets -- -D warnings && cargo test`.

Do NOT modify anything in the `#[cfg(test)] mod tests` block — tests may use `unwrap()`/`expect()` freely. Do NOT change any function signatures or control flow — only replace logging calls and remove dead comments/attributes. If removing `#![allow(dead_code)]` causes compiler warnings about unused methods, add `#[allow(dead_code)]` to those specific methods instead of keeping the blanket module suppression.

---

### Task 2: `flatten-hotkey-poller-nesting`

**Scope:** `src/hotkey_pollers.rs`

**Task:**
The `HotkeyPoller::start_listening` method (lines 22-239) is a 217-line function with 6+ levels of nesting (async closure → while loop → if/else → cx.update → window.update → nested if/else). The "show" branch alone (lines 120-224) contains 100+ lines of deeply nested code inside `cx.update(move |cx| { window_clone.update(cx, |view, win, ctx| { ... }) })`. This makes the function extremely hard to read and modify. Extract the hide and show logic into separate helper methods on `HotkeyPoller` or as free functions in the same file.

Create two helper functions: `fn handle_hotkey_hide(window: WindowHandle<ScriptListApp>, cx: &mut App)` and `fn handle_hotkey_show(window: WindowHandle<ScriptListApp>, cx: &mut App)`. Move lines 64-119 (the `is_visible` true branch) into `handle_hotkey_hide`, and lines 120-224 (the else branch) into `handle_hotkey_show`. The main `start_listening` method's while loop body should become: early-return on notes/ai open, check visibility, call the appropriate helper. Each helper should contain the `cx.update()` and `window.update()` calls that are currently inline. Keep all `logging::log` calls exactly as they are — do NOT migrate logging in this task (that's a separate future task). Keep all `#[allow(dead_code)]` attributes as they are.

Verify with `cargo check && cargo clippy --all-targets -- -D warnings && cargo test`. Do NOT change any behavior — this is a pure refactor. The `ScriptHotkeyPoller`, `NotesHotkeyPoller`, `AiHotkeyPoller` structs and the `start_hotkey_event_handler` function should remain untouched. The only file to modify is `src/hotkey_pollers.rs`.

---

### Task 3: `process-kill-use-libc`

**Scope:** `src/process_manager/mod.rs`

**Task:**
The `kill_process` method (lines 281-320) spawns a child process via `Command::new("kill").args(["-9", &negative_pgid]).output()` to send SIGKILL to a process group. This is inefficient (forks a shell process) and fragile (depends on the `kill` binary being in PATH). On Unix systems, use `libc::kill()` directly, which is the standard approach in Rust for sending signals. The non-Unix branch (lines 313-319) just logs a message — keep that as-is.

Replace the Unix `#[cfg(unix)]` block in `kill_process` with a direct `libc::kill` call. The implementation should be: `let pgid = -(pid as i32); let ret = unsafe { libc::kill(pgid, libc::SIGKILL) };`. Then check the return value: if `ret == 0`, log success; if `ret == -1`, check `std::io::Error::last_os_error()` — if the error kind is `ErrorKind::NotFound` (ESRCH, errno 3), log that the process already exited; otherwise log the error. Use `tracing::info!` for success, `tracing::debug!` for already-exited, and `tracing::warn!` for actual failures (since this task runs after the logging migration task, use tracing macros). Example: `tracing::info!(pid, "killed process group")` on success, `tracing::debug!(pid, "process already exited")` for ESRCH, `tracing::warn!(pid, %err, "failed to kill process group")` for other errors. Add `use std::io::ErrorKind;` if needed. The crate already depends on `libc` (check `Cargo.toml`). Also remove `use std::process::Command;` from the imports (line 22) if it's no longer used anywhere in the file after this change.

Verify with `cargo check && cargo clippy --all-targets -- -D warnings && cargo test`. Do NOT modify the test module. Ensure the non-Unix `#[cfg(not(unix))]` block still compiles. The function signature `pub fn kill_process(&self, pid: u32)` must not change.

---

### Task 4: `process-manager-permission-constants`

**Scope:** `src/process_manager/mod.rs`

**Task:**
The file contains three occurrences of Unix file permission magic numbers: `0o700` (line 85, directory permissions) and `0o600` (lines 94 and 411, file permissions). These are used inside `#[cfg(unix)]` blocks for `Permissions::from_mode()`. While common in Unix programming, named constants make the intent clearer and prevent copy-paste errors. The same permission values appear in two different functions (`write_main_pid` and `persist_active_pids`) without any shared constant.

Add two constants at the top of the `impl ProcessManager` block (after line 47): `const DIR_PERMISSIONS: u32 = 0o700;` and `const FILE_PERMISSIONS: u32 = 0o600;`. Replace `Permissions::from_mode(0o700)` on line 85 with `Permissions::from_mode(Self::DIR_PERMISSIONS)`. Replace `Permissions::from_mode(0o600)` on lines 94 and 411 with `Permissions::from_mode(Self::FILE_PERMISSIONS)`. These are associated constants on `ProcessManager`, keeping them scoped to the struct rather than polluting the module namespace.

Verify with `cargo check && cargo clippy --all-targets -- -D warnings && cargo test`. Do NOT change any logic or behavior. The constants should be private (no `pub`). Do NOT add comments or docstrings to the constants — the names are self-explanatory. Do NOT modify the test module.

---

NEXT_AREA: `src/main_entry/app_run_setup.rs` — a 2147-line file that is the body of a single function included via `include!()` into `main.rs`. Contains 247 `logging::log()` calls, deep nesting, and no function extraction. This is likely the single largest code quality issue in the codebase and would benefit from being broken into named helper functions within a proper module.
