The model log is minimal. The NEXT_AREA was cut off, but based on the analysis context, `src/main_entry/app_run_setup.rs` (2147 lines) is the natural next area — we already identified it as a large file earlier.

Here are Oracle's findings, formatted as the swarm task list:

---

## Oracle GPT-5.2 Pro Analysis Results — 4 Swarm Tasks

### Task 1: `clipboard-monitor-image-blob-cache`

**Scope:** `src/clipboard_history/monitor.rs`

**Task:**
The clipboard monitor does unnecessary heavy work on the "same image copied again" path: `capture_clipboard_content` calls `encode_image_as_blob(&image_data)` even when `compute_image_hash` says the image content is identical. That forces RGBA→PNG compression, SHA-256, and blob disk I/O on every repeat copy — the hot path that should be cheap.

Fix by caching the blob key alongside the last image hash. Replace `last_image_hash: &mut Option<u64>` with a small struct like `LastImageState { hash: u64, blob_key: String }`. On new image: compute hash; if different, run `encode_image_as_blob` once; call `add_entry`; **only after successful `add_entry`** update the cached hash/blob-key. On same image: if you have a cached blob key, call `add_entry(&blob_key, ContentType::Image)` and **skip** `encode_image_as_blob` entirely.

Preserve retry semantics: DB failure should not advance the cached state; encode failure may keep the hash but must not create a bogus cached blob key. Verify with `cargo check && cargo clippy --all-targets -- -D warnings && cargo test`.

### Task 2: `clipboard-blobstore-io-safety`

**Scope:** `src/clipboard_history/{image,blob_store}.rs`

**Task:**
The blob decode path does redundant disk work: `decode_to_render_image` for `blob:` content checks dimensions via `get_blob_dimensions` (which loads the blob) and then loads the same blob again to decode it — a double read per decode. Separately, `store_blob` writes directly to the final `{hash}.png` path; a crash mid-write can leave a corrupted blob that will be reused forever.

In `image.rs`, refactor so a blob is loaded once per operation. Add internal helpers like `fn png_dims_from_bytes(png: &[u8]) -> Option<(u32,u32)>` and `fn decode_png_bytes_to_render_image(png: &[u8]) -> Option<Arc<RenderImage>>`. Keep the public API stable. In `blob_store.rs`, make `store_blob` atomic: write to a temp file, then `rename` to `{hash}.png`. If destination exists, delete temp and return Ok (idempotent). Never leave partially-written blobs.

Run `cargo check && cargo clippy --all-targets -- -D warnings && cargo test`.

### Task 3: `file-search-limit-and-stderr-safety`

**Scope:** `src/file_search/**/*.rs`

**Task:**
Three concrete issues: (1) `list_directory(dir_path: &str, _limit: usize)` ignores its limit parameter, doing full directory scans even when callers want a small result set; (2) `mdfind` invocations pipe stderr but never drain it, which can hang if stderr fills; (3) `terminal_working_directory` can return empty string for a relative file path with no parent, causing `cd ""` behavior.

Fix without changing external API: make `list_directory` respect `limit` (remove underscore, clamp to `0..=MAX_DIRECTORY_ENTRIES`, truncate after sorting). For `mdfind`, set `stderr(Stdio::null())`. Fix `terminal_working_directory` to fall back to `"."`. Then split `mod.rs` into semantic submodules: `mdfind.rs`, `directory.rs`, `os_open.rs`. Keep `crate::file_search::*` exports stable via re-exports from `mod.rs`.

Verify with `cargo check && cargo clippy --all-targets -- -D warnings && cargo test`.

### Task 4: `handle-action-dispatch-refactor`

**Scope:** `src/app_actions/**/*.rs`

**Task:**
`handle_action` is ~2000+ lines with deeply nested control flow, duplicated "do X then show HUD then hide window" patterns, and inconsistent `cx.notify()` calls. Uses `logging::log` instead of `tracing::{info,warn,error,debug,trace}`.

Decompose into focused handler functions in new semantic files under `src/app_actions/` (no `part_*.rs`). Keep entry point small (<300 lines), delegating to category handlers (clipboard actions, file-search actions, script actions, etc.). Extract shared HUD duration constants (`HUD_SHORT_MS`, `HUD_LONG_MS`) instead of magic `Some(1500)`, `Some(2000)`, `Some(3000)`. Centralize confirm-dialog boilerplate. Replace `logging::log(...)` with `tracing` macros.

Audit every early-return branch: if it mutates UI-relevant state, ensure `cx.notify()` is called. Verify with `cargo check && cargo clippy --all-targets -- -D warnings && cargo test`.

---

**NEXT_AREA:** `src/main_entry/app_run_setup.rs` — 2147 lines, likely contains setup logic that could benefit from similar decomposition and audit.
