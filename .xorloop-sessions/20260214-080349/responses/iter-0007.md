Oracle's analysis is thorough and aligns well with my own reading of the code. Here are the **4 swarm tasks** based on the combined analysis:

---

### Task 1: `dedup-positioning-bounds`

**Scope:** `src/platform/positioning.rs`

**Task:**
In `src/platform/positioning.rs`, the functions `calculate_eye_line_bounds_on_mouse_display` and `calculate_centered_bounds_on_mouse_display` are 80% identical. They duplicate the same pipeline: get displays → log banner → log displays → select display for mouse → compute origin → clamp → log final bounds → return. The only real difference is the Y-offset calculation: eye-line uses `visible.origin_y + visible.height * 0.14`, centered uses `visible.origin_y + (visible.height - window_height) / 2.0`. Additionally, the eye-line fallback uses hardcoded `point(px(381.0), px(246.0))` which ignores `window_size` — a real bug for non-default window sizes — while the centered fallback correctly computes centering within `1512.0 x 982.0`.

Create a named constant `EYE_LINE_Y_RATIO: f64 = 0.14` and fallback constants `FALLBACK_VISIBLE_WIDTH: f64 = 1512.0` and `FALLBACK_VISIBLE_HEIGHT: f64 = 982.0`. Add a private enum `enum MouseDisplayPlacement { EyeLine, Centered }`. Add a helper `fn log_positioning_banner(title_line: &str)` that emits the decorative box-drawing log lines. Add a helper `fn fallback_display_bounds() -> VisibleDisplayBounds` that returns a `VisibleDisplayBounds` with both `frame` and `visible_area` set to the fallback constants. Extract a private function `fn calculate_bounds_on_mouse_display(window_size: gpui::Size<Pixels>, placement: MouseDisplayPlacement) -> Bounds<Pixels>` that does the full pipeline: get displays, log banner based on placement, log displays, select display with `unwrap_or_else(fallback_display_bounds)`, compute `origin_x` as center horizontal, compute `origin_y` based on placement variant, clamp, log final bounds, return. Then rewrite the two public functions as one-line delegates to `calculate_bounds_on_mouse_display`. Keep all existing log messages and the `"POSITION"` log target.

IMPORTANT: This file is `include!()`-ed into `src/platform/mod.rs`, so all symbols from `mod.rs`'s other includes are in scope — you can reference `logging`, `DisplayBounds`, `VisibleDisplayBounds`, `get_macos_visible_displays`, `select_display_for_mouse`, `log_available_displays`, `clamp_to_visible`, `display_edges`, `point`, `px`, `Bounds`, `Pixels` directly without imports. The existing `use gpui::{point, px, Bounds, Pixels};` at line 115 and `fn display_edges`, `fn log_available_displays`, `fn select_display_for_mouse` are all in the same file. The project requires `cargo check && cargo clippy --all-targets -- -D warnings && cargo test` to pass. Never use `.unwrap()` in production code — use `?` or graceful handling.

### Task 2: `dedup-vibrancy-config`

**Scope:** `src/platform/secondary_window_config.rs`

**Task:**
In `src/platform/secondary_window_config.rs`, the functions `configure_actions_popup_window` and `configure_secondary_window_vibrancy` duplicate the same vibrancy configuration sequence: clear window appearance to nil, set backgroundColor to windowBackgroundColor, set opaque false, set hasShadow true, recursively configure NSVisualEffectViews, and emit appearance/material log messages. The only differences are: (1) `configure_actions_popup_window` also sets popup-specific window flags (setMovable, setMovableByWindowBackground, setLevel, setAnimationBehavior, setRestorable, setFrameAutosaveName) and uses `"ACTIONS"` as the log target, while (2) `configure_secondary_window_vibrancy` uses `"PANEL"` and accepts a `window_name` parameter.

Extract a `#[cfg(target_os = "macos")] unsafe fn configure_window_vibrancy_common(window: id, log_target: &str, window_name: &str, is_dark: bool)` that performs the shared vibrancy steps: clear appearance to nil with log, set backgroundColor to windowBackgroundColor with log, set opaque false, set hasShadow true, get contentView and if non-null call `configure_visual_effect_views_recursive` and log the count with material name, then log the final vibrancy summary. Then rewrite `configure_actions_popup_window` to do the null check, set the popup-specific flags (setMovable false, setMovableByWindowBackground false, setLevel NS_FLOATING_WINDOW_LEVEL, setAnimationBehavior 2i64, setRestorable false, setFrameAutosaveName empty), then call `configure_window_vibrancy_common(window, "ACTIONS", "Actions popup", is_dark)`. Rewrite `configure_secondary_window_vibrancy` to do the null check then call `configure_window_vibrancy_common(window, "PANEL", window_name, is_dark)`. Keep all non-macOS stubs unchanged.

This file is `include!()`-ed into `src/platform/mod.rs` — all symbols from other includes are in scope (logging, id, nil, class, msg_send, NS_FLOATING_WINDOW_LEVEL, configure_visual_effect_views_recursive). The project requires `cargo check && cargo clippy --all-targets -- -D warnings && cargo test` to pass. Never use `.unwrap()` in production code.

### Task 3: `dedup-screenshot-encode`

**Scope:** `src/platform/screenshots_window_open.rs`

**Task:**
In `src/platform/screenshots_window_open.rs`, the functions `capture_app_screenshot` and `capture_window_by_title` both duplicate the same capture-scale-encode pipeline: call `window.capture_image()`, get width/height, if not hi_dpi then resize by dividing dimensions by 2 using `image::imageops::resize` with `Lanczos3`, then create a `PngEncoder` and call `write_image`. This same pattern also appears in `capture_focused_window_screenshot` and `capture_screen_screenshot` in `ai_commands.rs` (but those are in a different include file and should NOT be touched by this worker).

Extract a private helper function `fn capture_and_encode_png(window: &xcap::Window, hi_dpi: bool) -> Result<(Vec<u8>, u32, u32), Box<dyn std::error::Error + Send + Sync>>` that: captures the image, gets original dimensions, if hi_dpi keeps them as-is else divides both by 2 (using `.max(1)` to avoid zero-size), resizes with Lanczos3, logs the scaling with `tracing::debug!`, encodes to PNG in memory, and returns `(png_data, width, height)`. Add a named constant `const DOWNSCALE_DIVISOR: u32 = 2;` inside the helper. Then replace the duplicated capture/scale/encode blocks in both `capture_app_screenshot` and `capture_window_by_title` with a call to `capture_and_encode_png(&window, hi_dpi)?`. Keep all existing `tracing::debug!` calls that log context before/after the capture (app_name, title, file_size) in the caller functions — only extract the image processing pipeline itself.

This file is `include!()`-ed into `src/platform/mod.rs`. The `use image::codecs::png::PngEncoder; use image::ImageEncoder; use xcap::Window;` imports should be moved to the helper or kept at the function level (the helper needs them). The project requires `cargo check && cargo clippy --all-targets -- -D warnings && cargo test` to pass.

### Task 4: `name-appkit-constants`

**Scope:** `src/platform/app_window_management.rs, src/platform/vibrancy_swizzle_materials.rs, src/platform/secondary_window_config.rs`

**Task:**
Multiple files in `src/platform/` use raw numeric literals for AppKit enum values without named constants. In `app_window_management.rs`: `setActivationPolicy: 1i64` (accessory), `setActivationPolicy: 0i64` (regular), `setAnimationBehavior: 2i64` (none), and `NSMinYEdge` as `1` in `show_share_sheet`. In `vibrancy_swizzle_materials.rs`: atomic statics initialized with raw `11`, `0`, `3` for material index, blending mode, and appearance index defaults. In `secondary_window_config.rs`: `setAnimationBehavior: 2i64` is also used.

In `app_window_management.rs`, add three `#[cfg(target_os = "macos")]` constants at the top of the file (after the existing `NS_WINDOW_COLLECTION_BEHAVIOR_CAN_JOIN_ALL_SPACES`): `const NS_APPLICATION_ACTIVATION_POLICY_REGULAR: i64 = 0;`, `const NS_APPLICATION_ACTIVATION_POLICY_ACCESSORY: i64 = 1;`, `const NS_WINDOW_ANIMATION_BEHAVIOR_NONE: i64 = 2;`. Replace the `1i64` in `configure_as_accessory_app` and `set_accessory_app_mode` with `NS_APPLICATION_ACTIVATION_POLICY_ACCESSORY`. Replace the `0i64` in `set_regular_app_mode` with `NS_APPLICATION_ACTIVATION_POLICY_REGULAR`. Replace the `2i64` in `configure_as_floating_panel` with `NS_WINDOW_ANIMATION_BEHAVIOR_NONE`. In `vibrancy_swizzle_materials.rs`, add `const DEFAULT_MATERIAL_INDEX: usize = 11;`, `const DEFAULT_BLENDING_MODE: usize = 0;`, `const DEFAULT_APPEARANCE_INDEX: usize = 3;` (all `#[cfg(target_os = "macos")]`) near the statics, and use them in the `AtomicUsize::new()` calls. In `secondary_window_config.rs`, the `setAnimationBehavior: 2i64` should reference the same constant (since all files are `include!()`-ed into `mod.rs`, `NS_WINDOW_ANIMATION_BEHAVIOR_NONE` will be in scope).

These files are all `include!()`-ed into `src/platform/mod.rs` so they share scope — constants defined in one are visible in all others. The project requires `cargo check && cargo clippy --all-targets -- -D warnings && cargo test` to pass.

---

NEXT_AREA: `src/platform/ai_commands.rs` — `capture_screen_screenshot` and `capture_focused_window_screenshot` duplicate the same scale-and-encode pipeline as `screenshots_window_open.rs`, and `get_focused_browser_tab_url` has a large match arm that could be a lookup table.
