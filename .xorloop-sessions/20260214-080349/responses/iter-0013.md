Now I have the full picture of the `render_keydown.rs` issue. Line 14 uses `let key = event.keystroke.key.as_str();` while the correct pattern (used everywhere else in the codebase including `notes/window/keyboard.rs` and all `render_builtins`) is `let key = event.keystroke.key.to_lowercase();` followed by matching on the lowercased string. The file matches both variants for some keys (line 25: `"tab" | "Tab"`, line 47: `"enter" | "return" | "Enter"`) but only matches lowercase for escape (7 locations).

Now I have enough data. Let me formulate the swarm tasks based on Oracle's analysis plus my verification findings.

Here are the swarm tasks based on Oracle's analysis and my verification:

---

### Task 1: `ai-keydown-lowercase-keys`

**Scope:** `src/ai/window/render_keydown.rs`

**Task:**
The file `src/ai/window/render_keydown.rs` uses `let key = event.keystroke.key.as_str();` (line 14) to read the keyboard key, then checks against hardcoded string literals. This is inconsistent with every other keyboard handler in the codebase — `src/notes/window/keyboard.rs` (line 12), `src/ai/window/command_bar.rs` (line 275), and all 10 files in `src/render_builtins/` all use `.to_lowercase()` before matching. The current code matches both variants for some keys (`"tab" | "Tab"` on line 25, `"enter" | "return" | "Enter"` on line 47, `"up" | "arrowup"` on line 35) but only matches `"escape"` (never `"Escape"`) at 7 locations (lines 155, 167, 273, 291, 302, 309, 316, 323). If GPUI ever delivers the capitalized `"Escape"` keystroke, none of these handlers will fire and the AI window will become unresponsive to the Escape key.

Change line 14 from `let key = event.keystroke.key.as_str();` to `let key = event.keystroke.key.to_lowercase();` and then change `let key_str_ref = key.as_str();` (you'll need a binding since `to_lowercase()` returns `String`). Then update the match arm on line 24 to use `key.as_str()` and simplify all match arms to only use the lowercase variant. Specifically: line 25 becomes just `"tab"`, line 35 becomes `"up" | "arrowup"`, line 41 becomes `"down" | "arrowdown"`, line 47 becomes `"enter" | "return"` (drop `"Enter"`), line 155 stays `"escape"`. All the `if key == "escape"` checks on lines 167, 273, 291, 302, 309, 316, 323 stay as-is since they already use the lowercase form. The `if (key == "up" || key == "arrowup")` on line 281 stays fine. The match block starting at line 175 (platform modifier keys like `"k"`, `"n"`, `"f"`, etc.) stays unchanged since those are already lowercase.

After the change, verify: `cargo check && cargo clippy --all-targets -- -D warnings && cargo test`. The key behavioral requirement is that all keyboard variants (e.g., `"Escape"` and `"escape"`, `"Tab"` and `"tab"`) are handled uniformly via lowercasing, matching the pattern used in `src/notes/window/keyboard.rs` and `src/render_builtins/*.rs`.

---

### Task 2: `migrate-exec-logging-to-tracing`

**Scope:** `src/execute_script/mod.rs`

**Task:**
The file `src/execute_script/mod.rs` has 63 calls to `logging::log(category, message)` and 0 direct `tracing::` macro calls. The project's CLAUDE.md rule #4 mandates: "Use `tracing::{info,warn,error,debug,trace}` for all new/modified code. Do not introduce new `log::info!` / `log::warn!` usage." The `logging::log()` function (defined in `src/logging/mod.rs` at line 976) internally calls tracing macros but also has two side-effects: (1) `add_to_buffer()` which appends to a legacy UI display buffer, and (2) `write_to_capture()` which writes JSONL to a capture file. Since this is a consistency migration aligning with project rules, replace all 63 `logging::log()` calls with direct `tracing::` macro calls using structured fields instead of `format!()` string interpolation. The level mapping from `logging::log`'s `legacy_level_for_category` is: `"ERROR"` → `tracing::error!`, `"WARN"`/`"WARNING"` → `tracing::warn!`, `"DEBUG"` → `tracing::debug!`, `"TRACE"` → `tracing::trace!`, everything else (including `"EXEC"`) → `tracing::info!`.

For each call, follow the executor-style pattern of structured fields + static message string. For example, replace `logging::log("EXEC", &format!("Starting interactive execution: {}", script.name))` with `tracing::info!(category = "EXEC", script_name = %script.name, "Starting interactive execution")`. Replace `logging::log("ERROR", &format!("Failed to get displays: {}", e))` with `tracing::error!(category = "ERROR", error = %e, "Failed to get displays")`. Replace `logging::log("WARN", &format!("Unhandled message type: {}", type_name))` with `tracing::warn!(category = "WARN", message_type = %type_name, "Unhandled message type")`. For simple string-only calls like `logging::log("EXEC", "Writer thread exiting")`, replace with `tracing::info!(category = "EXEC", "Writer thread exiting")`. Use `%` for Display types (errors, strings, IDs), `?` for Debug types (structs, enums, Options), and bare values for numeric types. Remove all `format!()` calls that were only used for the logging message — extract their interpolated values into structured tracing fields instead.

After the migration, the file should have 0 `logging::log(` calls and 0 `format!` calls used solely for log messages. The `use crate::logging;` import can be removed if no other `logging::` usages remain. Do NOT remove the `logging` module itself — other files still use it. Verify with: `cargo check && cargo clippy --all-targets -- -D warnings && cargo test`. Be aware this removes the legacy buffer and capture file side-effects for these 63 log sites — this is intentional.

---

### Task 3: `migrate-executor-logging-to-tracing`

**Scope:** `src/executor/runner.rs, src/executor/scriptlet.rs, src/executor/selected_text.rs`

**Task:**
Three files in `src/executor/` use `logging::log()` instead of direct `tracing::` macros, violating CLAUDE.md rule #4: `runner.rs` (44 calls), `scriptlet.rs` (13 calls), `selected_text.rs` (14 calls) = 71 total calls. Apply the same migration pattern as Task 2. The level mapping: `"ERROR"` → `tracing::error!`, `"WARN"`/`"WARNING"` → `tracing::warn!`, `"DEBUG"` → `tracing::debug!`, `"TRACE"` → `tracing::trace!`, everything else → `tracing::info!`.

For each `logging::log()` call, convert to the appropriate tracing macro with structured fields. Follow the pattern: `logging::log("EXEC", &format!("key={}, value={}", k, v))` becomes `tracing::info!(category = "EXEC", key = %k, value = %v, "message")`. Simple calls like `logging::log("EXEC", "message")` become `tracing::info!(category = "EXEC", "message")`. Use `%` for Display types, `?` for Debug types, bare for numerics. In `selected_text.rs`, the file already has excellent structured logging patterns like `debug!(request_id = %request_id, text_len = text.len(), "Handling SetSelectedText")` — this is the gold standard to follow (but note: these may be in newer code that was already migrated). Convert only the remaining `logging::log()` calls.

After migration, all three files should have 0 `logging::log(` calls. Remove the `use crate::logging;` import from each file if it becomes unused. Verify: `cargo check && cargo clippy --all-targets -- -D warnings && cargo test`. Do NOT modify `src/executor/mod.rs` or any test files.

---

### Task 4: `migrate-prompt-handler-logging`

**Scope:** `src/prompt_handler/mod.rs`

**Task:**
The file `src/prompt_handler/mod.rs` has 96 `logging::log()` calls — the highest count of any single file in the codebase — and 0 direct `tracing::` macro calls, violating CLAUDE.md rule #4. This is the prompt message handler that processes all JSONL messages from script processes, making it one of the most critical runtime paths. Apply the same logging migration.

For each `logging::log()` call, replace with the corresponding tracing macro using structured fields. The level mapping: `"ERROR"` → `tracing::error!`, `"WARN"`/`"WARNING"` → `tracing::warn!`, `"DEBUG"` → `tracing::debug!`, `"TRACE"` → `tracing::trace!`, everything else (including `"PROMPT"`, `"MSG"`, `"EXEC"`) → `tracing::info!`. Convert `format!()` interpolations into structured tracing fields. Example: `logging::log("PROMPT", &format!("Handling message type: {}", msg_type))` becomes `tracing::info!(category = "PROMPT", msg_type = %msg_type, "Handling message type")`. For error cases: `logging::log("ERROR", &format!("Parse failed: {}", e))` becomes `tracing::error!(category = "ERROR", error = %e, "Parse failed")`.

After migration, the file should have 0 `logging::log(` calls. Remove `use crate::logging;` if no other `logging::` usages remain. This file is heavily exercised by existing tests — run `cargo check && cargo clippy --all-targets -- -D warnings && cargo test` and ensure all tests still pass. The behavioral change (loss of legacy buffer/capture side-effects) is intentional and consistent with the project direction.

---

NEXT_AREA: `src/app_impl/` — contains 15+ files with a combined ~400+ `logging::log()` calls (startup.rs alone has 40, prompt_ai.rs has 28, shortcut_recorder.rs has 25), representing the single largest concentration of legacy logging in the codebase and the next priority for migration to tracing macros.
