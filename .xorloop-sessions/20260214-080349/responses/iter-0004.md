All three issues confirmed in the code. Here are the Oracle-generated swarm tasks:

---

### Task 1: `scrollbar-fade`

**Scope:** `src/{app_navigation,main_sections,app_impl,render_script_list,components}/**/*.rs`

**Task:**
The scrollbar visibility is currently driven by a binary `is_scrolling` flag that flips to `false` after a 1000ms idle timer, which makes the thumb opacity jump from the "visible" value straight to 0.0 with no transition. Replace `is_scrolling: bool` with a smooth, time-based visibility value (use `crate::transitions::Opacity`) so the thumb fades out over ~250ms instead of snapping invisible.

Implement this by adding new state to `ScriptListApp` (in `src/main_sections/app_state.rs` and initializers in `src/app_impl/startup*.rs`): `scrollbar_visibility: crate::transitions::Opacity` (init to `Opacity::INVISIBLE`) plus a `scrollbar_fade_gen: u64` (init 0) to cancel stale timers/animations; keep `last_scroll_time: Option<Instant>` as the source of truth. Rework `trigger_scroll_activity` (in `src/app_navigation/impl_scroll.rs`) to: (1) set `last_scroll_time = Some(now)`; (2) set `scrollbar_visibility = Opacity::VISIBLE`; (3) increment `scrollbar_fade_gen`; (4) spawn a task that waits the idle delay (1000ms), then animates `Opacity::VISIBLE -> Opacity::INVISIBLE` over `DURATION_MEDIUM + 50ms` using `ease_in_quad(t)` and `Opacity::lerp`. During the animation loop, tick at ~16ms, call `cx.notify()` after each render-affecting mutation, and bail out early if `scrollbar_fade_gen` changed (new scroll activity) or if `last_scroll_time` indicates the user became active again. Do not `unwrap()` on `cx.update` results; follow the existing `unwrap_or(Ok(false)).unwrap_or(false)` style to exit cleanly when the entity/window is gone.

Update the `Scrollbar` API (in `src/components/scrollbar.rs`) to accept a float visibility factor instead of `is_visible: Option<bool>` (replace with `visibility: Option<f32>` and a builder `visibility_opacity(f32)` that clamps 0..1). In `render`, multiply theme opacities by this factor. Update call sites (e.g. `src/render_script_list/mod.rs`) to pass the animated value (`.visibility_opacity(self.scrollbar_visibility.value())`). Ensure all scroll-driven code paths call `trigger_scroll_activity` so the scrollbar appears consistently.

### Task 2: `footer-surface-theme-token`

**Scope:** `src/components/prompt_footer.rs`

**Task:**
`footer_surface_rgba` returns a hardcoded light-mode surface color (`0xf0eeefff`), which ignores the active theme and breaks visual consistency for non-default themes. Replace the hardcoded surface with a theme token-derived surface, so light mode uses `theme.colors.background.*` rather than a fixed RGBA constant.

Concretely: extend `PromptFooterColors` to carry a dedicated surface token (e.g. `surface: u32`) sourced from the theme in `PromptFooterColors::from_theme` (prefer `theme.colors.background.main` or the closest existing "panel/footer surface" token in the theme module), and rework `footer_surface_rgba` to use `(colors.surface << 8) | 0xFF` in light mode. Update the unit tests in this file to assert the new behavior (no more constant gray). Run `cargo check && cargo clippy --all-targets -- -D warnings && cargo test`.

### Task 3: `disabled-item-cursor`

**Scope:** `src/components/unified_list_item/render.rs`

**Task:**
`UnifiedListItem` currently sets `.cursor_pointer()` unconditionally on the main interactive container (line 169), even when `state.is_disabled` is true. This makes disabled rows feel clickable, which is a UX papercut inconsistent with the component's own disabled text styling (line 131 already checks `is_disabled` for text color).

Fix this by making cursor conditional: only apply `.cursor_pointer()` when `!state.is_disabled`; otherwise use `.cursor_default()`. Hover styling at line 192-193 already correctly skips disabled items. After implementing, run `cargo check && cargo clippy --all-targets -- -D warnings && cargo test`.

---

NEXT_AREA: `src/components/prompt_header/` â€” PromptHeader actions/search mode crossfade animation using the transitions module
