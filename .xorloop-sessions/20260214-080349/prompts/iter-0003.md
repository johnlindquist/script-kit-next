<project-conventions>
# Script Kit GPUI

Rust (GPUI app shell) + TypeScript (bun script runner) + SDK. Backwards-compatible rewrite of Script Kit.

## Scope Rules

- Do ONLY what is explicitly requested. No unrequested changes, refactors, or "improvements."
- If you notice something worth improving, mention it at the end — do not implement it.
- Stay within the boundaries of the task. A docs request is not a code change.

## Verification Gate (Mandatory)

Every code change must pass before reporting success:

```bash
cargo check && cargo clippy --all-targets -- -D warnings && cargo test
```

After the gate passes, verify the change actually works:
- **Logic changes**: check logs with `SCRIPT_KIT_AI_LOG=1`
- **UI changes**: capture screenshot AND read the PNG to confirm visually
- **Never** report success without running verification

## Build & Test

| Action | Command |
|--------|---------|
| Check | `cargo check` |
| Lint | `cargo clippy --all-targets -- -D warnings` |
| Test | `cargo test` |
| Test (system) | `cargo test --features system-tests` |
| Test (slow) | `cargo test --features slow-tests` |
| Run | `echo '{"type":"show"}' \| SCRIPT_KIT_AI_LOG=1 ./target/debug/script-kit-gpui 2>&1` |
| Bundle | `cargo bundle --release` |

## Coding Conventions

### Rust
- Use `?` or graceful error handling — never `unwrap()` in unsafe/ObjC code
- After any render-affecting mutation: `cx.notify()`
- Use `theme.colors.*` — never hardcode `rgb(0x...)`
- Keyboard keys — match both variants:
  ```rust
  match key.as_str() {
    "up" | "arrowup" => ...,
    "down" | "arrowdown" => ...,
    "enter" | "Enter" => ...,
    "escape" | "Escape" => ...,
    _ => {}
  }
  ```

### UI Testing
- **Never** pass scripts as CLI args — use stdin JSON protocol
- Always use `SCRIPT_KIT_AI_LOG=1` for compact log output
- After screenshots, **read the PNG file** to verify

## Architecture Quick Ref

- Built-in commands: `BuiltInFeature` enum → `get_builtin_entries()` → `execute_builtin()` → `AppView` variant → render
- Non-dismissable views: add to `is_dismissable_view()` in `app_impl.rs`
- Vibrancy: prompts should NOT set opaque bg — let vibrancy show through from Root
- Render wrappers: `render_prompts/other.rs` wraps prompt entities, `prompts/*.rs` are inner components
- Protocol: bidirectional JSONL over stdin/stdout between bun scripts and Rust app — see `docs/PROTOCOL.md`

## Consistency Rules (Non-Negotiable)

These rules exist because mixed patterns break both human navigation and AI agent effectiveness.

### 1) No `part_*.rs` files
- Do NOT create or extend `part_000.rs`, `part_001.rs`, etc.
- Do NOT use `include!("part_*.rs")` for hand-written code.
- If a module is too large, split into a directory module with named files:
  - `mod.rs` is a facade that does `mod foo; mod bar;` and `pub use ...;`
  - Filenames must be semantic (`model.rs`, `render.rs`, `storage.rs`), never numeric.

### 2) Tests have only two homes (pick the right one)
- Unit tests live next to code
</project-conventions>

<recent-commits>
140b0041 chore(app_execute): remove orphan builtin feature files
d8fd5552 chore(system_actions): prune unused system action APIs
508e8f08 fix(designs-core): restore tests after core split
4acd9b66 refactor(designs): complete separator and icon variation module split
243a32b6 refactor(designs): split core parts into semantic modules
1ad7f5d7 fix(calculator): fix clippy lint in format_value
b36e821f Revert "fix(designs): remove dead code and unused imports"
d6eb7a62 refactor(designs): split retro terminal parts module
375a2d22 refactor(designs): split traits tokens into semantic modules
9c439f67 fix(designs): remove dead code and unused imports
992acfce feat(calculator): add inline calculator UI and grouped list integration
8d8f5973 feat(calculator): add inline expression evaluation state
a26fc071 fix(clipboard_history): remove expect from image cache cap
9a0589a7 fix(db_worker): warn on dropped db request replies
cfc29255 fix(clipboard-history): avoid unwrap in get_connection
</recent-commits>

These commits were ALREADY MADE — do NOT suggest changes that duplicate this work.

<previous-iterations>
Here are the extracted swarm tasks:

- `core-split` scope:`src/designs/core*` — Split core/parts.rs into variant, tokens, render, metadata, match_reason modules; fix broken tests
- `traits-split` scope:`src/designs/traits*` — Split traits/parts.rs into colors, spacing, typography, visual, tokens modules; downgrade to pub(crate)
- `retro-terminal-split` scope:`src/designs/retro_terminal*` — Split retro_terminal/parts.rs into constants, colors, renderer, window, render modules
- `variations-split` scope:`src/designs/separator_variations*,src/designs/icon_variations*` — Split both variation parts.rs into semantic modules; remove DesignVariant import hack

NEXT_AREA: `src/list_item/` — audit for `pub` leakage and forbidden `.unwrap()`/`.expect()` in non-test code
---


Here are the validated swarm tasks:

- `system-actions-prune` scope:`src/system_actions/mod.rs` — Delete 12+ dead functions, AppInfo struct, and their tests from system_actions
- `rm-orphan-feature-files` scope:`src/app_execute/builtin_execution/feature_*.rs` — Delete 3 orphaned feature files never compiled or referenced

NEXT_AREA: `src/editor/mod.rs` — has 11 `#[allow(dead_code)]` annotations worth auditing for genuinely unused methods

Want me to execute these as a swarm, or run them sequentially?
---
</previous-iterations>

These areas were ALREADY addressed in earlier iterations. Do NOT re-analyze them. Find something completely different.

## Target Code

I found the issue. Let me verify the specific wasteful re-encoding path in `monitor.rs`.

In `monitor.rs` lines 311-328, when the "same image is copied again" (OS detected a change but the content hash matches), the code calls `encode_image_as_blob(&image_data)` again. This re-encodes the full RGBA image to PNG and writes it through `store_blob()` — doing expensive PNG compression every time, even though `store_blob()` will skip the write (content-addressed). The text path at lines 256-265 doesn't have this problem because `add_entry()` only hashes the string — but for images, the caller re-encodes raw pixels to PNG just to get the same `blob:` key.

FEATURE: Clipboard monitor re-encodes images on every duplicate clipboard change, doing expensive PNG compression needlessly when the content hash already matches
FILES: src/clipboard_history/monitor.rs, src/clipboard_history/image.rs, src/clipboard_history/blob_store.rs, src/clipboard_history/cache.rs
SMELL: `capture_clipboard_content` re-runs full `encode_image_as_blob` (RGBA→PNG compression + SHA-256 + disk I/O) on the "same image copied again" path (monitor.rs:318) even though the image hash already confirmed the content is identical — the blob key should be cached alongside `last_image_hash` to skip re-encoding

## Task: code quality: find magic numbers, deeply nested conditionals, 500+ line functions, unclear control flow — rewrite with named constants, early returns, and extracted helpers

## CONTEXT: You are generating work orders for a codex-swarm

This is a large codebase primarily written by AI agents. Different agents made different choices, leading to inconsistencies, duplicated patterns, mixed conventions, and rough edges throughout. Your job is to find real quality issues and generate precise work orders to fix them.

Your output will be handed DIRECTLY to a `/codex-swarm` dispatcher that spawns parallel Codex AI agents (GPT-5.3) to implement your recommendations. Each task you write becomes a worker that edits real files autonomously. The workers have NO context beyond what you write in the task description — they cannot ask questions.

If a CLAUDE.md or project-conventions block was provided above, the workers MUST follow those rules. Include relevant conventions in each task description.

## Output Format — SWARM TASK LIST

Output 1-4 tasks. For each task, output this EXACT structure:

### Task N: `<worker-id>`

**Scope:** `<glob pattern for files this worker should touch>`

**Task:**
<2-4 paragraphs briefing a senior engineer. Be EXHAUSTIVE — the worker has zero context beyond this text.>

<Paragraph 1: What is wrong, which specific files/functions/lines are involved, and what the fix should accomplish.>

<Paragraph 2: The exact implementation — what code to change, what the replacement should look like, what patterns to follow from the existing codebase. Include function signatures, variable names, types.>

<Paragraph 3: Edge cases and constraints — what NOT to break, what to watch out for, how to verify the fix works.>

## Rules

- Worker IDs must be short kebab-case: `fix-fts-trigger`, `add-search-debounce`, `rm-dead-exports`
- Scope must be a glob: `src/notes/storage.rs`, `src/auth/**/*.ts`, `src/menu_bar/*.rs`
- Each worker should own at most ~10 files. If a fix spans more, split into multiple tasks
- Task descriptions must be SELF-CONTAINED — include file paths, function names, current buggy code snippets, and what the corrected code should look like
- Do NOT suggest adding documentation, comments, or docstrings — only functional code changes
- Do NOT suggest adding logging unless it fixes an actual bug
- Prioritize by impact: bugs > security > performance > cleanup
- Maximum 4 tasks per iteration — fewer is better if they're high-quality
- End with: NEXT_AREA: <suggest one unexplored area for future analysis>
