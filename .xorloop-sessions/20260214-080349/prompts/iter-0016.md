<project-conventions>
# Script Kit GPUI

Rust (GPUI app shell) + TypeScript (bun script runner) + SDK. Backwards-compatible rewrite of Script Kit.

## Scope Rules

- Do ONLY what is explicitly requested. No unrequested changes, refactors, or "improvements."
- If you notice something worth improving, mention it at the end — do not implement it.
- Stay within the boundaries of the task. A docs request is not a code change.

## Verification Gate (Mandatory)

Every code change must pass before reporting success:

```bash
cargo check && cargo clippy --all-targets -- -D warnings && cargo test
```

After the gate passes, verify the change actually works:
- **Logic changes**: check logs with `SCRIPT_KIT_AI_LOG=1`
- **UI changes**: capture screenshot AND read the PNG to confirm visually
- **Never** report success without running verification

## Build & Test

| Action | Command |
|--------|---------|
| Check | `cargo check` |
| Lint | `cargo clippy --all-targets -- -D warnings` |
| Test | `cargo test` |
| Test (system) | `cargo test --features system-tests` |
| Test (slow) | `cargo test --features slow-tests` |
| Run | `echo '{"type":"show"}' \| SCRIPT_KIT_AI_LOG=1 ./target/debug/script-kit-gpui 2>&1` |
| Bundle | `cargo bundle --release` |

## Coding Conventions

### Rust
- Use `?` or graceful error handling — never `unwrap()` in unsafe/ObjC code
- After any render-affecting mutation: `cx.notify()`
- Use `theme.colors.*` — never hardcode `rgb(0x...)`
- Keyboard keys — match both variants:
  ```rust
  match key.as_str() {
    "up" | "arrowup" => ...,
    "down" | "arrowdown" => ...,
    "enter" | "Enter" => ...,
    "escape" | "Escape" => ...,
    _ => {}
  }
  ```

### UI Testing
- **Never** pass scripts as CLI args — use stdin JSON protocol
- Always use `SCRIPT_KIT_AI_LOG=1` for compact log output
- After screenshots, **read the PNG file** to verify

## Architecture Quick Ref

- Built-in commands: `BuiltInFeature` enum → `get_builtin_entries()` → `execute_builtin()` → `AppView` variant → render
- Non-dismissable views: add to `is_dismissable_view()` in `app_impl.rs`
- Vibrancy: prompts should NOT set opaque bg — let vibrancy show through from Root
- Render wrappers: `render_prompts/other.rs` wraps prompt entities, `prompts/*.rs` are inner components
- Protocol: bidirectional JSONL over stdin/stdout between bun scripts and Rust app — see `docs/PROTOCOL.md`

## Consistency Rules (Non-Negotiable)

These rules exist because mixed patterns break both human navigation and AI agent effectiveness.

### 1) No `part_*.rs` files
- Do NOT create or extend `part_000.rs`, `part_001.rs`, etc.
- Do NOT use `include!("part_*.rs")` for hand-written code.
- If a module is too large, split into a directory module with named files:
  - `mod.rs` is a facade that does `mod foo; mod bar;` and `pub use ...;`
  - Filenames must be semantic (`model.rs`, `render.rs`, `storage.rs`), never numeric.

### 2) Tests have only two homes (pick the right one)
- Unit tests live next to code
</project-conventions>

<recent-commits>
dd8b1227 refactor(process-manager): centralize permission mode constants
ff6f4beb test(prompt_footer): update light mode RGBA expectation
5922698a fix(process_manager): use libc kill for unix process groups
2ff76cc3 refactor(hotkeys): extract hide/show handlers from main poller loop
5dafad62 test(actions): ignore dialog runtime path tests on macOS
a99f3acf refactor(process_manager): migrate PROC logs to tracing
7e3e5df4 test(actions): align dialog assertion fixtures with current ids
827f3dd2 fix(actions): update dialog action test expectations
de5d4e93 test(dialog): align validation assertions with current actions
a86dcfbb test(actions): align dialog assertions with current behavior
bca670e1 test(actions): align dialog validation assertions with builders
bbad54d0 test(actions): update semantic dialog assertions in modules 9-46
ed8aedef test(actions): align dialog validation tests 5 and 7
3bd0a2f5 refactor(window): remove dead enhanced control module
a2fb8347 refactor(panel): prune dead panel configuration code
</recent-commits>

These commits were ALREADY MADE — do NOT suggest changes that duplicate this work.

<previous-iterations>


Here are the swarm tasks:

- `ai-keydown-lowercase-keys` scope:`src/ai/window/render_keydown.rs` — Normalize keystroke to lowercase matching codebase-wide keyboard pattern
- `migrate-exec-logging-to-tracing` scope:`src/execute_script/mod.rs` — Replace 63 logging::log calls with structured tracing macros
- `migrate-executor-logging-to-tracing` scope:`src/executor/runner.rs, src/executor/scriptlet.rs, src/executor/selected_text.rs` — Replace 71 logging::log calls with structured tracing macros
- `migrate-prompt-handler-logging` scope:`src/prompt_handler/mod.rs` — Replace 96 logging::log calls with structured tracing macros

NEXT_AREA: `src/app_impl/` logging migration — likely has significant `logging::log()` usage not yet audited
---


Here are the swarm tasks:

- `panel-prune-dead-code` scope:`src/panel.rs` — Delete dead types/fns hidden by blanket `#![allow(dead_code)]` and prune orphaned tests
- `remove-window-control-enhanced` scope:`src/window_control_enhanced/**, src/lib.rs, Cargo.toml, CODEMAP.md` — Delete dead feature-gated module and all references

NEXT_AREA: `src/app_launcher/` — `db_cache.rs`, `icon_cache.rs`, `scanning.rs`, and `core_types.rs` all have `#[allow(dead_code)]` suppressions and may contain orphaned types/functions from earlier architectural iterations.

Want me to execute these as a swarm?
---


Here are the extracted tasks:

- `migrate-process-manager-logging` scope:`src/process_manager/mod.rs` — Replace 27 `logging::log` calls with `tracing` macros, remove dead comments/attributes
- `flatten-hotkey-poller-nesting` scope:`src/hotkey_pollers.rs` — Extract hide/show branches from 217-line nested `start_listening` into helper functions
- `process-kill-use-libc` scope:`src/process_manager/mod.rs` — Replace `Command::new("kill")` with direct `libc::kill()` for process group signals
- `process-manager-permission-constants` scope:`src/process_manager/mod.rs` — Extract `0o700`/`0o600` magic numbers into named associated constants

NEXT_AREA: `src/main_entry/app_run_setup.rs` — 2147-line single-function `include!()` body with 247 `logging::log()` calls and deep nesting

Want me to spin up workers to execute these tasks?
---
</previous-iterations>

These areas were ALREADY addressed in earlier iterations. Do NOT re-analyze them. Find something completely different.

## Target Code

Confirmed: `.with_transition()` is **never called** outside of its own definition and docs. Every `Toast::new(...)` gets `AppearTransition::visible()` and the elaborate transition system (560 lines) goes completely unused.

FEATURE: Toast notifications have a full animation transition system (opacity fade + slide offset) wired into the renderer but never driven — toasts pop in/out instantly with no smooth appear/dismiss animation
FILES: src/transitions/mod.rs, src/components/toast/model.rs, src/components/toast/render.rs, src/toast_manager/mod.rs
SMELL: `AppearTransition` with hidden/visible/dismissed states and Lerp interpolation is implemented and plumbed into toast rendering (render.rs:49-51), but every `Toast::new()` defaults to `visible()` and no caller ever sets `hidden()` or uses `with_transition()`, so the entire 560-line transitions module is dead code and toasts appear/disappear abruptly with zero animation

## Task: UX polish: find UI inconsistencies, missing keyboard shortcuts, broken focus management, hardcoded colors instead of theme tokens, missing cx.notify() after mutations — fix them

## CONTEXT: You are generating work orders for a codex-swarm

This is a large codebase primarily written by AI agents. Different agents made different choices, leading to inconsistencies, duplicated patterns, mixed conventions, and rough edges throughout. Your job is to find real quality issues and generate precise work orders to fix them.

Your output will be handed DIRECTLY to a `/codex-swarm` dispatcher that spawns parallel Codex AI agents (GPT-5.3) to implement your recommendations. Each task you write becomes a worker that edits real files autonomously. The workers have NO context beyond what you write in the task description — they cannot ask questions.

If a CLAUDE.md or project-conventions block was provided above, the workers MUST follow those rules. Include relevant conventions in each task description.

## Output Format — SWARM TASK LIST

Output 1-4 tasks. For each task, output this EXACT structure:

### Task N: `<worker-id>`

**Scope:** `<glob pattern for files this worker should touch>`

**Task:**
<2-4 paragraphs briefing a senior engineer. Be EXHAUSTIVE — the worker has zero context beyond this text.>

<Paragraph 1: What is wrong, which specific files/functions/lines are involved, and what the fix should accomplish.>

<Paragraph 2: The exact implementation — what code to change, what the replacement should look like, what patterns to follow from the existing codebase. Include function signatures, variable names, types.>

<Paragraph 3: Edge cases and constraints — what NOT to break, what to watch out for, how to verify the fix works.>

## Rules

- Worker IDs must be short kebab-case: `fix-fts-trigger`, `add-search-debounce`, `rm-dead-exports`
- Scope must be a glob: `src/notes/storage.rs`, `src/auth/**/*.ts`, `src/menu_bar/*.rs`
- Each worker should own at most ~10 files. If a fix spans more, split into multiple tasks
- Task descriptions must be SELF-CONTAINED — include file paths, function names, current buggy code snippets, and what the corrected code should look like
- Do NOT suggest adding documentation, comments, or docstrings — only functional code changes
- Do NOT suggest adding logging unless it fixes an actual bug
- Prioritize by impact: bugs > security > performance > cleanup
- Maximum 4 tasks per iteration — fewer is better if they're high-quality
- End with: NEXT_AREA: <suggest one unexplored area for future analysis>
