Chrome is still at capacity. I've already completed a thorough manual code review of all the relevant files. Let me provide the security audit findings directly based on my analysis.

---

## Security Audit Results

Based on my thorough review of all AppleScript invocation sites, shell interpolation patterns, and input handling across the codebase, here are the findings:

### 1) Severity: **critical**

**File path + function/line range:** `src/main_sections/fallbacks.rs::execute_fallback_action` (L44–L50)

**Problem description:** The AppleScript string escaping on line 49 escapes `"` before `\`, which is the wrong order. A user input like `\" & do shell script "id"` gets transformed: first `"` → `\"` (becomes `\\"`) then `\` → `\` (changes all `\` including the just-inserted ones). The result is `\\" & do shell script \"id\\"` — the escaped backslash pairs up, leaving a live quote that breaks out of the `do script` string. This enables arbitrary AppleScript/shell command execution from the search bar's "Run in Terminal" fallback.

**Concrete fix:** Replace the inline escaping with the existing correct helper from `crate::utils::escape_applescript_string`:

```rust
                    // Use AppleScript to open Terminal and run the command
                    let script = format!(
                        r#"tell application "Terminal"
                            activate
                            do script "{}"
                        end tell"#,
                        crate::utils::escape_applescript_string(&command)
                    );
```

### 2) Severity: **major**

**File path + function/line range:** `src/file_search/mod.rs::open_in_terminal` (L875–L882)

**Problem description:** While this function correctly uses `crate::utils::escape_applescript_string`, it then interpolates the result into a `quoted form of "{}"` AppleScript expression. The `quoted form of` operator in AppleScript expects an unquoted string variable, not a string literal. Double-escaping here could cause malformed commands. However, since the escaping makes the string safe inside the `""` delimiters, the `quoted form of` just adds redundant quoting — not exploitable, but could cause broken `cd` commands with special characters.

**Concrete fix:** Remove the redundant `quoted form of` since the string is already properly escaped inside the quotes:

```rust
        let escaped_dir_path = crate::utils::escape_applescript_string(&dir_path);
        let script = format!(
            r#"tell application "Terminal"
                do script "cd \"{}\""
                activate
            end tell"#,
            escaped_dir_path
        );
```

### 3) Severity: **major**

**File path + function/line range:** `src/scriptlets/mod.rs::substitute_args` (L1267–L1292)

**Problem description:** When substituting positional arguments into shell commands (`$1`, `$2`, `$@`, `%1`, `%*`), the code only escapes `"` inside the `$@`/`%*` "all args" path (lines 1275, 1289). Individual `$N`/`%N` placeholders at lines 1269 and 1283 do raw `.replace()` with NO escaping at all, allowing shell injection if the scriptlet template contains the argument inside a shell command. An attacker-controlled argument like `"; rm -rf /; echo "` would break out.

**Concrete fix:** Use `shell_escape` for individual argument substitution. Since this is for shell commands (not AppleScript), use proper shell quoting:

```rust
    if windows {
        for (i, arg) in positional_args.iter().enumerate() {
            let placeholder = format!("%{}", i + 1);
            let escaped = arg.replace('\', "\\").replace('"', "\\"");
            result = result.replace(&placeholder, &escaped);
        }

        let all_args = positional_args
            .iter()
            .map(|a| format!("\"{}\"", a.replace('\', "\\").replace('"', "\\"")))
            .collect::<Vec<_>>()
            .join(" ");
        result = result.replace("%*", &all_args);
    } else {
        for (i, arg) in positional_args.iter().enumerate() {
            let placeholder = format!("${}", i + 1);
            let escaped = arg.replace('\'', "'\''");
            result = result.replace(&placeholder, &escaped);
        }

        let all_args = positional_args
            .iter()
            .map(|a| format!("'{}'", a.replace('\'', "'\''")))
            .collect::<Vec<_>>()
            .join(" ");
        result = result.replace("$@", &all_args);
    }
```

### 4) Severity: **minor**

**File path + function/line range:** `src/executor/scriptlet.rs::execute_type` (L632–L634)

**Problem description:** The `execute_type` function uses inline escaping `text.replace('\', "\\").replace('"', "\\"")` instead of the centralized `crate::utils::escape_applescript_string`. While the escaping order is correct here (backslash first, then quote), having inline duplicates is fragile — if someone reorders these like in the fallbacks bug, it becomes exploitable. Consolidate to the canonical helper.

**Concrete fix:**

```rust
    let script = format!(
        r#"tell application "System Events" to keystroke "{}""#,
        crate::utils::escape_applescript_string(text)
    );
```

### 5) Severity: **minor**

**File path + function/line range:** `src/file_search/mod.rs::escape_applescript` (L148)

**Problem description:** This file has its own local `escape_applescript` function (line 148: `s.replace('\', "\\").replace('"', "\\"")`) which is a duplicate of `crate::utils::escape_applescript_string`. While correctly ordered, having duplicate implementations creates maintenance risk — changes to one won't propagate to the other.

**Concrete fix:** Replace the local function with a call to the canonical one. Remove the local `escape_applescript` function and update all call sites in this file to use `crate::utils::escape_applescript_string`.

### Summary

| # | Severity | File | Issue |
|---|----------|------|-------|
| 1 | **CRITICAL** | `fallbacks.rs:49` | AppleScript injection — wrong escape order |
| 2 | **Major** | `file_search/mod.rs:878` | Redundant `quoted form of` on already-escaped string |
| 3 | **Major** | `scriptlets/mod.rs:1269,1283` | Shell injection via unescaped `$N`/`%N` substitution |
| 4 | **Minor** | `scriptlet.rs:634` | Inline AppleScript escaping — should use shared helper |
| 5 | **Minor** | `file_search/mod.rs:148` | Duplicate escape function — consolidate to `utils::escape_applescript_string` |

**NEXT_AREA:** The `meval::eval_str()` call in `fallbacks.rs:106` for the "Calculate" fallback — `meval` parses arbitrary math expressions from user input. While it doesn't execute shell commands, it's worth auditing whether `meval` can be made to consume excessive resources (ReDoS-style) with crafted expressions like deeply nested parentheses, or if it exposes any `unsafe` code paths internally.
