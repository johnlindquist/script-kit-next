Chrome is still saturated. Let me proceed with my own analysis based on the code I've read, and present the findings directly. I have enough information to provide a thorough security audit.

Here are the security findings for the secrets/encryption system and related code:

---

### 1) Severity: **critical**

**File path + function/line range:** `src/secrets.rs::derive_passphrase` (L125–L132)
**Problem description:** The passphrase is derived by concatenating the machine hostname with a hardcoded constant `com.scriptkit.secrets`. Both values are publicly discoverable — hostname via `hostname` command, mDNS, or network traffic. Any user or attacker with read access to `~/.scriptkit/secrets.age` can decrypt all stored API keys (OPENAI, ANTHROPIC, VERCEL, etc.) offline in seconds.
**Concrete fix:** Use macOS Keychain to store a randomly-generated passphrase, falling back to a machine-unique secret derived from the hardware UUID (which requires root to read on modern macOS). This makes the passphrase unavailable to other non-root users and not recoverable from the encrypted file alone.

```rust
/// Derive a machine-specific passphrase using Keychain-stored random key,
/// falling back to hardware UUID + app salt via PBKDF2.
fn derive_passphrase() -> SecretString {
    // Try to load existing passphrase from Keychain
    let service = "com.scriptkit.secrets";
    let account = "encryption-passphrase";

    let keyring = keyring::Entry::new(service, account);
    if let Ok(entry) = &keyring {
        if let Ok(stored) = entry.get_password() {
            if !stored.is_empty() {
                return SecretString::from(stored);
            }
        }
    }

    // Generate a new random passphrase and store it in Keychain
    use rand::Rng;
    let mut rng = rand::rng();
    let random_bytes: [u8; 32] = rng.random();
    let new_passphrase = data_encoding::BASE64.encode(&random_bytes);

    if let Ok(entry) = &keyring {
        if entry.set_password(&new_passphrase).is_ok() {
            return SecretString::from(new_passphrase);
        }
    }

    // Final fallback: use IOPlatformUUID (hardware-unique, not publicly visible)
    let hw_uuid = get_hardware_uuid().unwrap_or_else(|| "unknown-hw".to_string());
    SecretString::from(format!("{}:{}:hw-fallback", hw_uuid, service))
}

#[cfg(target_os = "macos")]
fn get_hardware_uuid() -> Option<String> {
    let output = std::process::Command::new("ioreg")
        .args(["-rd1", "-c", "IOPlatformExpertDevice"])
        .output()
        .ok()?;
    let stdout = String::from_utf8_lossy(&output.stdout);
    for line in stdout.lines() {
        if line.contains("IOPlatformUUID") {
            if let Some(uuid) = line.split('"').nth(3) {
                return Some(uuid.to_string());
            }
        }
    }
    None
}

#[cfg(not(target_os = "macos"))]
fn get_hardware_uuid() -> Option<String> {
    // On Linux, read /etc/machine-id
    std::fs::read_to_string("/etc/machine-id")
        .ok()
        .map(|s| s.trim().to_string())
        .filter(|s| !s.is_empty())
}
```

---

### 2) Severity: **major**

**File path + function/line range:** `src/secrets.rs::secrets_path` (L116–L119)
**Problem description:** Uses `.expect()` which panics the entire app if the home directory can't be determined. This violates the project's "no unwrap/expect in production code" rule. While rare, this can happen in sandboxed environments, cron jobs, or containers.
**Concrete fix:**

```rust
fn secrets_path() -> Option<PathBuf> {
    dirs::home_dir().map(|home| home.join(".scriptkit").join("secrets.age"))
}
```

This requires updating all callers to handle `None`, e.g. in `load_secrets_from_disk`:

```rust
fn load_secrets_from_disk() -> HashMap<String, SecretEntry> {
    let path = match secrets_path() {
        Some(p) => p,
        None => {
            logging::log("SECRETS", "Could not determine home directory");
            return HashMap::new();
        }
    };
    // ... rest unchanged
}
```

And in `save_secrets`:

```rust
fn save_secrets(secrets: &HashMap<String, SecretEntry>) -> Result<(), String> {
    let path = secrets_path().ok_or("Could not determine home directory")?;
    // ... rest unchanged
}
```

---

### 3) Severity: **major**

**File path + function/line range:** `src/secrets.rs::get_cached_secrets` (L77) and `update_cache` (L90)
**Problem description:** Both functions call `.expect()` on the mutex lock, which panics on a poisoned mutex. If any thread panics while holding the secrets cache lock (e.g., during a malformed JSON parse), every subsequent secret access crashes the entire application. This is exploitable by corrupting the secrets file.
**Concrete fix:**

```rust
fn get_cached_secrets() -> HashMap<String, SecretEntry> {
    let mut guard = match secrets_cache().lock() {
        Ok(g) => g,
        Err(poisoned) => {
            logging::log("SECRETS", "Cache lock was poisoned, recovering");
            poisoned.into_inner()
        }
    };
    if let Some(ref secrets) = *guard {
        return secrets.clone();
    }

    let secrets = load_secrets_from_disk();
    *guard = Some(secrets.clone());
    secrets
}

fn update_cache(secrets: HashMap<String, SecretEntry>) {
    let mut guard = match secrets_cache().lock() {
        Ok(g) => g,
        Err(poisoned) => {
            logging::log("SECRETS", "Cache lock was poisoned, recovering");
            poisoned.into_inner()
        }
    };
    *guard = Some(secrets);
}
```

---

### 4) Severity: **major**

**File path + function/line range:** `src/secrets.rs::load_secrets_from_disk` (L139–L222)
**Problem description:** The `decrypted` Vec is read from the age decryptor with `read_to_end` but has no size limit. A maliciously crafted `.age` file could expand to gigabytes of data after decryption, causing OOM. Additionally, the decrypted plaintext containing all API keys stays in memory on the heap with no zeroization on drop.
**Concrete fix:**

```rust
fn load_secrets_from_disk() -> HashMap<String, SecretEntry> {
    let path = match secrets_path() {
        Some(p) => p,
        None => return HashMap::new(),
    };

    if !path.exists() {
        return HashMap::new();
    }

    let encrypted_data = match fs::read(&path) {
        Ok(data) => data,
        Err(e) => {
            logging::log("SECRETS", &format!("Failed to read secrets file: {}", e));
            return HashMap::new();
        }
    };

    if encrypted_data.is_empty() {
        return HashMap::new();
    }

    // Reject unreasonably large encrypted files (10 MB limit)
    const MAX_ENCRYPTED_SIZE: usize = 10 * 1024 * 1024;
    if encrypted_data.len() > MAX_ENCRYPTED_SIZE {
        logging::log(
            "SECRETS",
            &format!(
                "Secrets file too large ({} bytes), refusing to decrypt",
                encrypted_data.len()
            ),
        );
        return HashMap::new();
    }

    let passphrase = derive_passphrase();
    let identity = age::scrypt::Identity::new(passphrase);

    let decryptor = match age::Decryptor::new(&encrypted_data[..]) {
        Ok(d) => d,
        Err(e) => {
            logging::log("SECRETS", &format!("Failed to create decryptor: {}", e));
            return HashMap::new();
        }
    };

    if !decryptor.is_scrypt() {
        logging::log("SECRETS", "Secrets file is not passphrase-encrypted");
        return HashMap::new();
    }

    let mut reader = match decryptor.decrypt(iter::once(&identity as &dyn age::Identity)) {
        Ok(r) => r,
        Err(e) => {
            logging::log("SECRETS", &format!("Failed to decrypt secrets: {}", e));
            return HashMap::new();
        }
    };

    // Limit decrypted output to 10 MB to prevent OOM from malicious files
    let mut decrypted = Vec::new();
    match reader.take(MAX_ENCRYPTED_SIZE as u64).read_to_end(&mut decrypted) {
        Ok(_) => {}
        Err(e) => {
            logging::log("SECRETS", &format!("Failed to read decrypted data: {}", e));
            return HashMap::new();
        }
    }

    // Try to parse as new format first
    if let Ok(secrets) = serde_json::from_slice::<HashMap<String, SecretEntry>>(&decrypted) {
        return secrets;
    }

    // Fall back to old format and migrate
    if let Ok(old_secrets) = serde_json::from_slice::<HashMap<String, String>>(&decrypted) {
        let now = Utc::now();
        let migrated: HashMap<String, SecretEntry> = old_secrets
            .into_iter()
            .map(|(key, value)| {
                (
                    key,
                    SecretEntry {
                        value,
                        modified_at: now,
                    },
                )
            })
            .collect();
        return migrated;
    }

    logging::log("SECRETS", "Failed to parse secrets JSON in any format");
    HashMap::new()
}
```

---

### 5) Severity: **major**

**File path + function/line range:** `src/app_impl/selection_fallback.rs::execute_builtin_fallback_inline` (L331–L333)
**Problem description:** The `OpenUrl` handler passes user-controlled input directly to `open::that()` without scheme validation. The `is_url()` check accepts `file://` URLs (see detection.rs:78), so a user typing `file:///etc/passwd` in the search bar would open that file. More critically, on macOS `open::that` with a crafted URL can launch arbitrary applications via custom URL schemes (e.g., `ssh://`, `vnc://`, `smb://` etc.), enabling SSRF or unwanted network connections.
**Concrete fix:**

```rust
FallbackResult::OpenUrl { url } => {
    logging::log("FALLBACK", &format!("OpenUrl: {}", url));
    // Only allow http/https URLs from user input
    if url.starts_with("http://") || url.starts_with("https://") {
        let _ = open::that(&url);
    } else {
        logging::log(
            "FALLBACK",
            &format!("Blocked non-HTTP URL scheme: {}", url),
        );
    }
}
```

Apply the same fix in `src/main_sections/fallbacks.rs` at line 96:

```rust
FallbackResult::OpenUrl { url } => {
    logging::log("FALLBACK", &format!("OpenUrl: {}", url));
    if url.starts_with("http://") || url.starts_with("https://") {
        if let Err(e) = open::that(&url) {
            logging::log("FALLBACK", &format!("Failed to open URL: {}", e));
        } else {
            logging::log("FALLBACK", "URL opened in browser");
        }
    } else {
        logging::log(
            "FALLBACK",
            &format!("Blocked non-HTTP URL scheme: {}", url),
        );
    }
}
```

---

### 6) Severity: **major**

**File path + function/line range:** `src/main_sections/fallbacks.rs::execute_fallback_action` (L44–L49)
**Problem description:** The `RunTerminal` handler on macOS builds an AppleScript string with the command using backslash-then-double-quote replacement in the wrong order (escapes `"` first, then `\`, which re-corrupts already-escaped quotes). This is the *same class* of bug as the previously reported finding but in a *different code path* — `execute_fallback_action` in `main_sections/fallbacks.rs` (the original report was about `execute_fallback_action` in the same file but this is a second instance with a different escape order that is also wrong: it escapes `"` before `\`).
**Concrete fix:**

```rust
FallbackResult::RunTerminal { command } => {
    logging::log("FALLBACK", &format!("RunTerminal: {}", command));
    #[cfg(target_os = "macos")]
    {
        // Escape backslashes FIRST, then double quotes
        let escaped = command.replace('\', "\\").replace('"', "\\"");
        let script = format!(
            r#"tell application "Terminal"
                activate
                do script "{}"
            end tell"#,
            escaped
        );
        match std::process::Command::new("osascript")
            .arg("-e")
            .arg(&script)
            .spawn()
        {
            Ok(_) => logging::log("FALLBACK", "Opened Terminal with command"),
            Err(e) => {
                logging::log("FALLBACK", &format!("Failed to open Terminal: {}", e))
            }
        }
    }
}
```

---

### 7) Severity: **minor**

**File path + function/line range:** `src/ai/config.rs::read_key_env_or_keyring` (L187–L203)
**Problem description:** The function logs "Found API key in environment variable: SCRIPT_KIT_OPENAI_API_KEY" — while it doesn't log the key value itself, it confirms the presence of specific env vars. This is a minor info leak but acceptable. However, in `DetectedKeys::from_environment()` the API keys are stored as owned `String` values inside the struct without any protection, meaning they persist in heap memory indefinitely. If the process memory is dumped (core dump, debugging), all keys are in plaintext.
**Concrete fix:** While full memory protection requires `secrecy::SecretString`, a pragmatic fix is to ensure the `DetectedKeys` struct drops keys when no longer needed. At minimum, implement `Drop` to zeroize:

```rust
impl Drop for DetectedKeys {
    fn drop(&mut self) {
        if let Some(ref mut k) = self.openai {
            k.zeroize();
        }
        if let Some(ref mut k) = self.anthropic {
            k.zeroize();
        }
        if let Some(ref mut k) = self.google {
            k.zeroize();
        }
        if let Some(ref mut k) = self.groq {
            k.zeroize();
        }
        if let Some(ref mut k) = self.openrouter {
            k.zeroize();
        }
        if let Some(ref mut k) = self.vercel {
            k.zeroize();
        }
    }
}
```

Add `use zeroize::Zeroize;` at the top and `zeroize` to Cargo.toml dependencies.

---

### 8) Severity: **minor**

**File path + function/line range:** `src/secrets.rs::save_secrets` (L225–L281)  
**Problem description:** The `save_secrets` function writes the entire secrets file non-atomically on non-Unix platforms (line 273: `fs::write`). Even on Unix (lines 258–268), it opens with `truncate(true)` which clears the file before writing — if the process crashes between truncation and write completion, all secrets are lost with no backup or recovery mechanism.
**Concrete fix:**

```rust
fn save_secrets(secrets: &HashMap<String, SecretEntry>) -> Result<(), String> {
    let path = secrets_path().ok_or("Could not determine home directory")?;

    if let Some(parent) = path.parent() {
        fs::create_dir_all(parent)
            .map_err(|e| format!("Failed to create secrets directory: {}", e))?;
    }

    let json =
        serde_json::to_vec(secrets).map_err(|e| format!("Failed to serialize secrets: {}", e))?;

    let passphrase = derive_passphrase();
    let encryptor = age::Encryptor::with_user_passphrase(passphrase);

    let mut encrypted = vec![];
    let mut writer = encryptor
        .wrap_output(&mut encrypted)
        .map_err(|e| format!("Failed to create encryption writer: {}", e))?;

    writer
        .write_all(&json)
        .map_err(|e| format!("Failed to write encrypted data: {}", e))?;

    writer
        .finish()
        .map_err(|e| format!("Failed to finish encryption: {}", e))?;

    // Atomic write: write to temp file, then rename
    let tmp_path = path.with_extension("age.tmp");

    #[cfg(unix)]
    {
        use std::fs::OpenOptions;
        use std::os::unix::fs::OpenOptionsExt;

        OpenOptions::new()
            .write(true)
            .create(true)
            .truncate(true)
            .mode(0o600)
            .open(&tmp_path)
            .and_then(|mut file| file.write_all(&encrypted))
            .map_err(|e| format!("Failed to write temp secrets file: {}", e))?;
    }

    #[cfg(not(unix))]
    {
        fs::write(&tmp_path, &encrypted)
            .map_err(|e| format!("Failed to write temp secrets file: {}", e))?;
    }

    fs::rename(&tmp_path, &path)
        .map_err(|e| format!("Failed to rename temp secrets file: {}", e))?;

    logging::log(
        "SECRETS",
        &format!("Saved {} secrets to {:?}", secrets.len(), path),
    );
    Ok(())
}
```

---

### 9) Severity: **minor**

**File path + function/line range:** `src/fallbacks/builtins.rs::get_subtitle` (L204–L224)
**Problem description:** The `get_subtitle` method truncates input at byte offset 37 (`&input[..37]`) which can panic on multi-byte UTF-8 characters if the 37th byte falls in the middle of a character. This is a crash bug triggered by user input containing emoji or CJK characters.
**Concrete fix:**

```rust
pub fn get_subtitle(&self, input: &str) -> String {
    let truncated = if input.chars().count() > 40 {
        let end: String = input.chars().take(37).collect();
        format!("{}...", end)
    } else {
        input.to_string()
    };

    match &self.action {
        FallbackAction::RunInTerminal => format!("Run '{}'", truncated),
        FallbackAction::AddToNotes => format!("Add '{}'", truncated),
        FallbackAction::CopyToClipboard => format!("Copy '{}'", truncated),
        FallbackAction::SearchUrl { .. } => format!("Search for '{}'", truncated),
        FallbackAction::OpenUrl => format!("Open {}", truncated),
        FallbackAction::Calculate => format!("Calculate {}", truncated),
        FallbackAction::OpenFile => format!("Open {}", truncated),
        FallbackAction::SearchFiles => format!("Search files for '{}'", truncated),
        FallbackAction::ExecuteBuiltin { .. } => {
            format!("Run command with '{}'", truncated)
        }
    }
}
```

---

### 10) Severity: **minor**

**File path + function/line range:** `src/scripts/input_detection/detection.rs::is_code_snippet` (L245–L253)
**Problem description:** Two `Regex::new()` calls are compiled on every invocation of `is_code_snippet()`, which is called for every keystroke in the search bar. While not a security issue per se, the unanchored function-call regex `\w+\s*\([^)]*\)` can cause catastrophic backtracking on adversarial input strings with many nested parentheses, freezing the UI thread (ReDoS).
**Concrete fix:**

```rust
static FUNC_CALL_REGEX: LazyLock<Regex> = LazyLock::new(|| {
    Regex::new(r"[a-zA-Z_]\w{0,100}\s{0,10}\([^)]{0,200}\)").expect("Invalid func call regex")
});

pub fn is_code_snippet(input: &str) -> bool {
    let trimmed = input.trim();

    if trimmed.is_empty() {
        return false;
    }

    let lower = trimmed.to_lowercase();

    for keyword in CODE_KEYWORDS {
        if lower.contains(keyword) {
            return true;
        }
    }

    if lower.contains(" = ") && !lower.contains("==") {
        return true;
    }

    FUNC_CALL_REGEX.is_match(trimmed)
}
```

---

**NEXT_AREA:** `src/stdin_commands/mod.rs` and the JSONL protocol message parsing — deserializing untrusted JSON from stdin scripts that could contain oversized payloads, unexpected types, or path traversal in file-path fields.
