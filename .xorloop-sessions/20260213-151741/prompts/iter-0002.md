<previous-analyses>
Looking at this analysis, here are the extracted swarm tasks:

- `watcher-core` scope:`src/watcher/{mod.rs,generic.rs}` — Create shared generic Watcher engine with WatcherSpec/EventSink traits and fix Drop stop-signal bug
- `config-theme-migration` scope:`src/watcher/specs/*.rs` — Migrate ConfigWatcher and ThemeWatcher to SingleFileReloadSpec over generic
- `script-migration` scope:`src/watcher/specs/script.rs` — Migrate ScriptWatcher to generic, fix discover_kit_watch_paths running only once
- `app-migration` scope:`src/watcher/specs/app.rs` — Migrate AppWatcher to generic, fix missing ~/Applications dir at startup

NEXT_AREA: Restart correctness — what state must be recomputed per supervisor attempt, and which directories/files can be permanently missed if created while a watcher is down.
---
</previous-analyses>

Do NOT repeat items already covered above. Find something new.
## Target Code

Now I have the full picture. The `prompt_handler/mod.rs` is the worst one because it slices user chat messages — the highest probability of multibyte input. But the pattern is repeated across 5+ production files.

FEATURE: `prompt_handler::handle_ai_chat_request` truncates user chat messages using byte-offset slicing (`&message[..30]`) which panics on multibyte UTF-8 input like emoji or CJK characters
FILES: src/prompt_handler/mod.rs, src/executor/errors.rs, src/prompts/chat/render_turns.rs, src/designs/compact.rs, src/fallbacks/builtins.rs
SMELL: Six production call sites use `&str[..N]` after checking `str.len() > N` — but `len()` counts bytes not chars, so any multibyte character (emoji, CJK, accented) spanning the cut boundary causes a panic at runtime

## Task: error handling fix: find missing guards, unchecked returns, brittle parsing, swallowed errors — write the corrected code with proper error handling

## CONTEXT: You are generating work orders for a codex-swarm

Your output will be handed DIRECTLY to a `/codex-swarm` dispatcher that spawns parallel Codex AI agents (GPT-5.3) to implement your recommendations. Each task you write becomes a worker that edits real files autonomously. The workers have NO context beyond what you write in the task description — they cannot ask questions.

## Output Format — SWARM TASK LIST

Output 1-4 tasks. For each task, output this EXACT structure:

### Task N: `<worker-id>`

**Scope:** `<glob pattern for files this worker should touch>`

**Task:**
<2-4 paragraphs briefing a senior engineer. Be EXHAUSTIVE — the worker has zero context beyond this text.>

<Paragraph 1: What is wrong, which specific files/functions/lines are involved, and what the fix should accomplish.>

<Paragraph 2: The exact implementation — what code to change, what the replacement should look like, what patterns to follow from the existing codebase. Include function signatures, variable names, types.>

<Paragraph 3: Edge cases and constraints — what NOT to break, what to watch out for, how to verify the fix works.>

## Rules

- Worker IDs must be short kebab-case: `fix-fts-trigger`, `add-search-debounce`, `rm-dead-exports`
- Scope must be a glob: `src/notes/storage.rs`, `src/auth/**/*.ts`, `src/menu_bar/*.rs`
- Each worker should own at most ~10 files. If a fix spans more, split into multiple tasks
- Task descriptions must be SELF-CONTAINED — include file paths, function names, current buggy code snippets, and what the corrected code should look like
- Do NOT suggest adding documentation, comments, or docstrings — only functional code changes
- Do NOT suggest adding logging unless it fixes an actual bug
- Prioritize by impact: bugs > security > performance > cleanup
- Maximum 4 tasks per iteration — fewer is better if they're high-quality
- End with: NEXT_AREA: <suggest one unexplored area for future analysis>
