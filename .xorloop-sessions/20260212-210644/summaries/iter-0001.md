- **Blocking I/O on UI thread is the critical issue**: synchronous disk reads, JSON parsing, and `osascript` process spawns in the Quicklinks flow freeze the app; must move to background executor via `cx.spawn()`.

- **Redundant work dominates the major findings**: double `osascript` spawns, double string escaping, chained `.replace()` allocations, full-buffer JSON I/O, and unconditional writes on no-op deletes/updates all create unnecessary CPU and memory pressure.

- **Minor wins center on avoiding repeated allocations**: short-circuit `expand_url` for non-placeholder links, return indices instead of labels from AppleScript, cache `quicklinks_path()` with `OnceLock`, and memoize `get_builtin_entries()` to stop per-keystroke rebuilds.

NEXT_SEED: Profile `get_builtin_entries()` call frequency per keystroke/render cycle and determine optimal caching/memoization layer for the picker/search pipeline.
