<previous-analyses>
- **Unbounded file reads and malformed JSON** can cause OOM/DoS or permanently brick frecency data; fix with file size caps (5 MiB), quarantine-and-reset on parse errors, and skip-deserializing the derived `score` field.
- **Symlink attacks and permission leaks** in the save path due to deterministic temp filenames and default permissions; fix with `tempfile::NamedTempFile` (O_EXCL) and 0o600 permissions, plus fsync before rename.
- **Unbounded growth and input quirks** from no entry count cap, no key validation, future timestamp pinning, and integer overflow in pruning; fix with MAX_ENTRIES/MAX_KEY_BYTES limits, timestamp clamping, and saturating arithmetic.

NEXT_SEED: Script execution pipeline — command injection, unsafe env var exposure, and filesystem permission assumptions in script launching and built-in command handling.
---
- **Critical thread-safety gap**: `apply_default_cursor()` is public and callable from any thread, but AppKit's `[NSCursor set]` requires the main thread — leads to undefined behavior. Also missing autorelease pools and using panicking `class!()` macro instead of fallible `Class::get()`.

- **Cursor claims lack window scoping and lifecycle cleanup**: Components call `claim_cursor_pointer()` unconditionally without checking window type (NSPanel vs normal), and there's no cursor reset on panel hide/close/deactivate — leaving a sticky pointer cursor (UI spoofing vector).

- **API over-exposure and missing optimization**: `claim_cursor_pointer()` and `apply_default_cursor()` are fully `pub` (should be `pub(crate)` or capability-gated), no caching means redundant AppKit calls on every mouse move, and the binary arrow/pointer model can't express I-beam for text regions.

NEXT_SEED: Popup root wiring and NSPanel window lifecycle hooks — verifying main-thread guarantees, cursor resets on hide/close/deactivate, and event-propagation contract integrity.
---
Here's the summary:

- **Critical DB/UI thread blocking**: FTS triggers fire unnecessarily on every upsert (not just content changes), and synchronous SQLite writes plus per-keystroke queries block the render loop, causing UI jank.
- **Redundant per-frame computation**: Full-buffer scans for stats, lowercase content matching, and markdown re-parsing happen every render frame instead of being cached and invalidated on change.
- **Excessive allocations in hot paths**: Unnecessary string clones on keystrokes, double allocations from `NoteId::as_str()`, per-comparison `to_lowercase()` in sorts, and full-content clones for delete/restore waste memory in tight loops.

NEXT_SEED: CommandBar action filtering and ranking performance — whether it loads full note content or metadata-only rows, and virtualization of action list rendering.
---
</previous-analyses>

Do NOT repeat items already covered above. Find something new.
## Feature Under Review

FEATURE: KeywordMatcher buffers typed keystrokes in a rolling VecDeque and fires text-expansion triggers (e.g. `:sig`, `!today`, `addr,,`) the instant a registered keyword's suffix is fully typed, using a last-char index for O(1) candidate lookup.
FILES: src/keyword_matcher/mod.rs, src/keystroke_logger.rs, src/text_injector.rs, src/scriptlets/mod.rs

## Analysis Category

documentation gaps: find undocumented public APIs, missing README sections, stale comments

## Instructions

1. Analyze the feature described above through the lens of: documentation gaps
2. Be specific: reference actual file paths, function names, line ranges
3. Output a prioritized checklist of actionable improvements
4. For each item: severity (critical/major/minor), file path, concrete fix description
5. End with: NEXT_AREA: <suggest one unexplored area for future analysis>
