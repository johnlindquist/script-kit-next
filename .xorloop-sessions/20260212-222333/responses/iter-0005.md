Here's the full GPT-5.2 Pro performance analysis of the notes module:

---

## Notes Module Performance Analysis — 14 Findings

### Critical (4)

1. **FTS trigger fires on every UPSERT, not just content changes** — `storage.rs::init_notes_db` / `save_note`. The `AFTER UPDATE OF title, content` trigger fires whenever those columns are *mentioned* in SQL, not when values change. Pin/sort/restore all trigger FTS reindex. **Fix:** Use `WHEN OLD.title <> NEW.title OR OLD.content <> NEW.content` guard.

2. **Synchronous SQLite write in render loop** — `render.rs::render` calls `save_current_note()` inline when debounce expires. Blocks UI thread on disk I/O. **Fix:** Spawn background thread, drain result next frame with revision check.

3. **DB query per search keystroke on UI thread** — `notes.rs::on_search_change` runs `search_notes()` or `get_all_notes()` synchronously on every keypress. **Fix:** 150ms debounce + background thread + apply-latest semantics.

4. **O(total_content_bytes) scan every render frame** — `render_ui.rs::render_search` computes `result_count` by calling `to_lowercase().contains()` on every note's full content per frame. **Fix:** Use `self.notes.len()` (results are already filtered).

### Major (8)

5. **Repeated full-buffer scans in render** — `get_character_count()`, `get_word_count()`, `get_reading_time()`, `get_cursor_line_info()`, `get_selection_stats()` each scan the entire editor buffer every frame. **Fix:** Cache stats on editor change, read cached values in render.

6. **Unnecessary content clone on every keystroke** — `on_editor_change` clones the content string when calling `note.set_content(content_string.clone())`. **Fix:** Move the string instead of cloning.

7. **Heavy per-note work when opening switcher** — `open_browse_panel` iterates all notes calling `char_count()` (full content scan), `preview()`, `strip_markdown_for_preview()`. **Fix:** Cache preview/char_count in Note struct, or query metadata-only from DB.

8. **`NoteId::as_str()` allocates a fresh String** — called in hot loops with `.to_string()` on top (double alloc). **Fix:** Use `NoteId::to_string()` directly or parse+compare by value.

9. **Delete/restore clones entire Note including content** — `delete_selected_note` / `restore_note` clone instead of moving. **Fix:** Use `Vec::remove()` + move.

10. **O(n) linear scans for selected note every frame** — `selected_note_title`, `is_current_note_pinned`, date lookups all scan the full list. **Fix:** Track `selected_index: Option<usize>` or maintain `HashMap<NoteId, usize>`.

11. **Empty trash = N individual DELETE statements** — `empty_trash` loops calling `delete_note_permanently()` per note. **Fix:** Single `DELETE FROM notes WHERE deleted_at IS NOT NULL` in a transaction.

12. **Markdown preview regenerated every render frame** — `render_editor_body` parses markdown + highlights code blocks every frame; even cache hits deep-clone. **Fix:** Cache parsed blocks keyed by content revision; use `Arc<[CodeLine]>` for zero-cost cache hits.

### Minor (2)

13. **Alphabetical sort allocates per comparison** — `apply_sort` calls `to_lowercase()` inside the comparator (O(n log n) allocs). **Fix:** Use `sort_by_cached_key`.

14. **No LIMIT on FTS results** — `search_notes` loads unlimited full-content results. **Fix:** Add `LIMIT 200` to the FTS query.

---

**NEXT_AREA:** CommandBar / actions infrastructure performance — action filtering, ranking, virtualization, and whether it can consume metadata-only note rows without loading full content.
