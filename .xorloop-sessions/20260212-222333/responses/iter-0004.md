Here's the full Oracle (GPT-5.2 Pro) security audit of the platform cursor management feature. All findings are **new** — not repeating prior analyses:

---

## Security Audit: Platform Cursor Management

### Prioritized Findings

| # | Severity | File | Issue |
|---|----------|------|-------|
| 1 | **CRITICAL** | `cursor.rs:27-44,61-70` | **No main-thread enforcement on AppKit FFI calls** — `apply_default_cursor()` is safe+public, callable from any thread. AppKit's `[NSCursor set]` off the main thread is undefined behavior (crash/corruption). Fix: add `debug_assert!(is_main_thread())` + release guard, or require a main-thread token parameter. |
| 2 | **MAJOR** | `cursor.rs:32,41` | **`class!(NSCursor)` panics if class not found** — DoS in headless/test/early-startup contexts. Fix: use `Class::get("NSCursor")` with early-return instead. |
| 3 | **MAJOR** | `cursor.rs:31-34,40-43` | **No autorelease pool around ObjC message sends** — leaks or lifecycle weirdness if called without an active pool. Fix: wrap in `autoreleasepool { ... }`. |
| 4 | **MAJOR** | `button/component.rs:330-338`, `footer_button.rs:158-164`, `prompt_footer.rs:389-396` | **Cursor bypass not gated to NSPanel windows** — components discard `_window` param and call `claim_cursor_pointer()` unconditionally. If root handler runs in a normal window, these become an accidental cursor override. Fix: pass `window` to `claim_cursor_pointer(window)`, check if it's a non-activating panel internally. |
| 5 | **MAJOR** | `cursor.rs:51-72`, `mod.rs:28` | **Globally-public cursor API enables UI redress** — `claim_cursor_pointer()` and `apply_default_cursor()` are `pub`, callable from anywhere. Fix: make `pub(crate)` minimum, or introduce a `CursorScope` capability object passed down from the popup root. |
| 6 | **MAJOR** | `cursor.rs:51-72` | **No cursor reset on lifecycle edges** — panel hide/close/deactivate while hovered leaves a sticky pointing-hand cursor (UI spoofing). Fix: add `force_arrow_cursor_and_clear_claim()` called from window hide/close/deactivation hooks. |
| 7 | **MINOR** | `cursor.rs:23-72` | **No cursor-state caching → redundant AppKit calls on every mouse move** — performance/DoS footgun on the hottest path. Fix: track `LAST_APPLIED: Cell<Option<CursorKind>>`, skip `[NSCursor set]` when unchanged. |
| 8 | **MINOR** | `cursor.rs:46-72` | **Binary cursor model (arrow vs pointer) forces arrow over text/editable regions** — subtle UI-trust issue. Fix: evolve to `CursorKind` enum with I-beam support and priority rules. |

### NEXT_AREA

**Audit the popup root wiring and window lifecycle hooks** — where `apply_default_cursor()` is actually called, how the non-activating `NSPanel` is created/shown/hidden. Confirms: (1) main-thread guarantees are enforced in practice, (2) cursor resets on hide/close/deactivate, (3) no event-propagation bypasses the "inner claims → root applies once" contract.
