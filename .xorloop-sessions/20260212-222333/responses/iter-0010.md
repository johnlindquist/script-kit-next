Here's the full security audit from GPT-5.2 Pro on the scheduler feature:

---

## Security Audit: Script Scheduling System

### Critical Findings (4)

**1. Auto-run on drop — no allowlist/consent gate**
- **Files**: `src/main_entry/preflight.rs:218-234`, `src/scripts/scheduling.rs:56-69`
- Any `.ts`/`.js` file with `// cron:` or `// schedule:` metadata self-authorizes for execution. No explicit enable toggle or user approval.
- **Fix**: Treat in-file schedule metadata as a *declaration*, not activation. Require UI approval on first discovery. Deny-by-default for new scripts.
- **Attack**: User clones a script pack → one file has `// schedule: every day at 2pm` → executes silently to exfiltrate data.

**2. Full environment inheritance — secret exposure**
- **Files**: `src/main_entry/runtime_watchers_scheduler.rs:241-248`, `src/main_entry/app_run_setup.rs:1102-1109`
- Spawned `bun` processes inherit all parent env vars (API keys, tokens, credentials). No `.env_clear()` or allowlist.
- **Fix**: Use `Command::new(...).env_clear()` then selectively pass safe keys. Add per-script permission model if feasible.
- **Attack**: Scheduled script reads `AWS_SECRET_ACCESS_KEY` from env and exfiltrates.

**3. Unbounded output capture → OOM + log-based secret exposure**
- **Files**: `runtime_watchers_scheduler.rs:246-269`, `app_run_setup.rs:1107-1127`
- `wait_with_output()` buffers entire stdout/stderr in memory. No size cap. Failed stderr gets logged in full.
- **Fix**: Stream with `BufRead`, cap at N KB. Truncate logged output. Use rotating per-run artifact files.
- **Attack**: Script prints infinitely → app OOMs. Or prints auth token to stderr → persisted in logs.

**4. No concurrency limiting → process explosion DoS**
- **Files**: `src/scheduler/mod.rs:240-281`, `runtime_watchers_scheduler.rs:241-277`, `app_run_setup.rs:1102-1130`
- No global concurrency cap, no per-script mutual exclusion, no timeout/kill for hung scripts.
- **Fix**: Add global `Semaphore`, per-script `HashSet<PathBuf>` running guard, and execution timeouts.
- **Attack**: 500 scripts all due at same minute → 500 bun processes spawned simultaneously.

### Major Findings (5)

**5. Stale schedules never removed** — `remove_script` exists but is `#[allow(dead_code)]`. Re-scans only add, never prune. Deleted scripts keep running until restart.

**6. Symlink traversal / no containment** — `register_scheduled_scripts` follows symlinks without canonicalization. Symlinks can point outside scripts dir.

**7. TOCTOU race** — Scheduler stores path only. No integrity check (inode/hash/mtime) at execution time. File can be swapped between due-check and spawn.

**8. Full-file reads for metadata** — `read_to_string` loads entire files even though only first 30 lines are needed. Multi-GB file → OOM on metadata scan.

**9. Bun runtime substitution** — Resolves bun via `BUN_PATH` env var / PATH fallback instead of bundled absolute path. Attacker can set `BUN_PATH` to trojan binary.

### Minor Findings (2)

**10. Lossy path conversion** — `to_string_lossy()` before execution can alter non-UTF8 filenames. Pass `&Path` directly to `cmd.arg()`.

**11. Cron re-parse failure loops** — Failed parse doesn't update `next_run`, causing the script to be re-queued every 30s indefinitely.

---

**NEXT_AREA**: Audit the non-scheduler **JSONL stdin/stdout bridge** — message parsing, capability boundaries, file/path validation, and whether scripts can trigger privileged app actions via protocol messages ("confused deputy" risks).
