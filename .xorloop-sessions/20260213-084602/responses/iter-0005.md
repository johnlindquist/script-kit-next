This is the critical finding. Line 137-138: `TerminalHandle::with_command` takes the command string and writes it directly to the PTY stdin as `format!("{}
", cmd)`. This means it's **typed into an interactive shell**, so the shell will parse it. The `build_terminal_command` in `execution_scripts.rs` does properly quote the path argument using `quote_terminal_arg`, which is good.

Now I have a complete picture. Let me write up the swarm tasks for the Oracle. Since Oracle is busy, I'll produce the analysis directly.

Here are the swarm tasks extracted from the analysis:

---

### Task 1: `harden-agent-build-terminal-cmd`

**Scope:** `src/agents/executor.rs`

**Task:**
In `src/agents/executor.rs`, the function `build_terminal_command()` at line 490 constructs terminal execution arguments from `agent.path` without calling `validate_agent_markdown_path()`. Every other executor function (`execute_agent` at line 314, `explain_agent` at line 407, `dry_run_agent` at line 448) validates the agent path through canonicalization, parent-dir rejection, extension check, and kit-root containment. `build_terminal_command` bypasses all of these, and it also uses `.unwrap_or("mdflow")` which violates the project's no-unwrap-in-production rule. Although the function currently has no callers outside tests, it is `pub` and re-exported from `src/agents/mod.rs` line 89, making it a ticking time bomb for any future integration.

Change the function signature from `pub fn build_terminal_command(agent: &Agent) -> (String, Vec<String>)` to `pub fn build_terminal_command(agent: &Agent) -> Result<(String, Vec<String>)>`. Inside the function: (1) Call `validate_agent_markdown_path(&agent.path)?` to get a `canonical_agent_path`, identical to how `execute_agent` does it at line 323. (2) Replace `get_mdflow_command().unwrap_or("mdflow")` with `get_mdflow_command().context("mdflow not found...")?`. (3) Use the canonical path in the args vector instead of `agent.path.to_string_lossy()`. (4) Apply `apply_agent_environment_allowlist` is NOT needed here since this function only returns args, not a Command — but the path validation IS critical.

Update the test `test_build_terminal_command` at line 600 to: create a tempdir mimicking the kit agents directory structure (like `test_validate_agent_markdown_path_accepts_file_inside_kit_agents_dir` does), write a real `.md` file, set the agent path to that file, and call `build_terminal_command(&agent).expect(...)`. Also add a test that verifies a path with `..` segments is rejected. Do NOT change any other function in this file. Run `cargo check && cargo clippy --all-targets -- -D warnings && cargo test` to verify.

---

### Task 2: `clipboard-restore-race-fix`

**Scope:** `src/selected_text.rs`

**Task:**
In `src/selected_text.rs`, the function `set_via_clipboard_fallback()` at line 210 has a TOCTOU race condition in the clipboard save/restore cycle. The function saves the clipboard at line 214, sets new text at line 222, simulates Cmd+V at line 229, waits 50ms at line 232, then restores the original clipboard at line 238 after only 100ms. The problem: if the target application hasn't consumed the paste yet (some apps like Electron, VS Code, or Terminal are slower), the clipboard gets restored to the original text before the paste event is processed, resulting in the wrong text being pasted. The 50ms delay is insufficient for slow apps. Additionally, if the function errors between setting the clipboard (line 222) and the restore (line 238), the user's clipboard is permanently overwritten.

Fix this by: (1) Increasing the post-paste delay from 50ms to 150ms (line 232: change `Duration::from_millis(50)` to `Duration::from_millis(150)`). (2) Wrapping the paste+restore logic in a pattern that ensures clipboard restoration happens even on error. Specifically, after `clipboard.set_text(text)` succeeds at line 222, the rest of the function should use a helper closure or explicit error handling that always attempts restore before returning. Replace lines 229-243 with a pattern like: `let paste_result = simulate_paste_with_cg(); thread::sleep(Duration::from_millis(150));` then unconditionally restore, then return `paste_result`. This ensures `simulate_paste_with_cg()` errors don't prevent clipboard restoration. (3) Keep the 100ms pre-restore delay at line 237. Do NOT change the overall function architecture or add new dependencies.

Edge cases: The `original` may be `None` if clipboard was empty — this is already handled. Do not change behavior for `simulate_paste_with_cg` itself. Run `cargo check && cargo clippy --all-targets -- -D warnings && cargo test` to verify. System tests require `--features system-tests` and manual interaction, so just verify compilation.

---

### Task 3: `pty-env-inheritance-scrub`

**Scope:** `src/terminal/pty/lifecycle.rs`

**Task:**
In `src/terminal/pty/lifecycle.rs`, the function `spawn_internal()` at line 37 uses `portable_pty::CommandBuilder::new(cmd)` which by default inherits the FULL parent process environment. Lines 64-78 then explicitly set TERM, COLORTERM, CLICOLOR_FORCE, HOME, USER, PATH, and SHELL — but these are ADDITIVE, not replacing the inherited environment. This means every environment variable from the Script Kit GUI process (which may include SCRIPT_KIT_*, API keys, internal tokens, debug flags, etc.) leaks into the PTY child shell. This is a security issue because scriptlets run in this PTY, and untrusted scriptlet code has access to the full GUI process environment.

Fix this by calling `command.env_clear()` immediately after `CommandBuilder::new(cmd)` on line 57, BEFORE setting the individual environment variables on lines 64-78. The `portable_pty::CommandBuilder` supports `env_clear()` (check docs — if it doesn't exist, use the `env` method with an explicit allowlist). After `env_clear()`, re-add the existing vars (TERM, COLORTERM, CLICOLOR_FORCE, HOME, USER, PATH, SHELL) exactly as they are now. Additionally add TMPDIR and LANG to the allowlist — these are needed for correct locale and temp file behavior. The pattern should match `SAFE_AGENT_ENV_VARS` from `src/agents/executor.rs` line 32 as closely as reasonable for a PTY context.

Verify that `PtyManager::new()`, `PtyManager::with_size()`, `PtyManager::with_command()`, and `PtyManager::with_command_and_size()` all flow through `spawn_internal()` so the fix covers all entry points. Run `cargo check && cargo clippy --all-targets -- -D warnings && cargo test` to verify. Check that existing PTY tests still pass — the tests create PTYs and verify they work, so they'll catch if essential env vars are missing.

---

### Task 4: `runner-env-scrub-script-spawn`

**Scope:** `src/executor/runner.rs`

**Task:**
In `src/executor/runner.rs`, the function `spawn_script()` at line 663 creates a `Command::new(&executable)` and calls `.spawn()` at line 687 without any environment scrubbing. The command inherits ALL environment variables from the Script Kit GUI process. Script Kit is a desktop app that may hold sensitive state in env vars (API keys for AI providers, internal tokens, debug flags, paths to credentials). Every user script spawned via this function — including scripts from untrusted sources — gets full access to the parent process environment. Similarly, `run_command()` at line 865 has the same issue.

For `spawn_script()`: After `Command::new(&executable)` on line 672, add `command.env_clear()` then re-add only safe environment variables. Use a const allowlist similar to `SAFE_AGENT_ENV_VARS` in `src/agents/executor.rs` but extended for script execution needs: `PATH`, `HOME`, `TMPDIR`, `USER`, `LANG`, `TERM`, `SHELL`, `XDG_RUNTIME_DIR`, `SCRIPT_KIT_*` (the SDK needs SCRIPT_KIT env vars to function). Pattern: `command.env_clear(); for key in SAFE_SCRIPT_ENV_VARS { if let Some(val) = std::env::var_os(key) { command.env(key, val); } }`. Also forward any env var starting with `SCRIPT_KIT` since those are the app's own protocol vars that scripts need. Add the const `SAFE_SCRIPT_ENV_VARS` near the top of the file alongside the existing constants. For `run_command()`, apply the same pattern — it's used as a fallback for non-interactive execution.

Do NOT change `find_executable()`, `ProcessHandle`, `ScriptSession`, or any other function. The `SCRIPT_KIT_*` prefix forwarding is critical — without it, the SDK preload won't work (it reads `SCRIPT_KIT_PATH` etc.). Run `cargo check && cargo clippy --all-targets -- -D warnings && cargo test` to verify.

---

NEXT_AREA: `src/clipboard_history/monitor.rs` and `src/clipboard_history/clipboard.rs` — clipboard monitoring and entry retrieval: audit for pastejacking (malicious clipboard content injection), blob store path traversal in image handling, and OCR data exfiltration via clipboard change detection
