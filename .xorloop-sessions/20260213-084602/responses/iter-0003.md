I now have enough information. Let me analyze all the security gaps I've found and produce the swarm task list. Since Oracle is unavailable, I'll do the analysis directly.

Based on my thorough code review, here are the **new, previously uncovered** security vulnerabilities I found:

---

## Swarm Task List

### Task 1: `env-scrub-type-submit-osascript`

**Scope:** `src/executor/scriptlet.rs`

**Task:**
In `src/executor/scriptlet.rs`, the functions `execute_type()` (line 786), `execute_submit()` (line 818), and the osascript call inside `execute_submit` all spawn `Command::new("osascript")` **without calling `apply_scriptlet_environment_allowlist()`**. This is the same class of vulnerability as the already-identified `execute_open`/`execute_edit` gap, but these three additional callsites were missed. The `execute_type` function on line 797 does `Command::new("osascript").arg("-e").arg(&script).output()`, and `execute_submit` on line 831 does the same thing — both inherit the full parent process environment, leaking tokens and credentials to an osascript subprocess that runs untrusted scriptlet content.

The fix: in `execute_type()`, change the `Command::new("osascript")` block (around line 797) to create a mutable `cmd`, call `apply_scriptlet_environment_allowlist(&mut cmd)`, then run `.output()`. Specifically, replace:
```rust
let output = Command::new("osascript")
    .arg("-e")
    .arg(&script)
    .output()
    .map_err(|e| format!("Failed to type text: {}", e))?;
```
with:
```rust
let mut cmd = Command::new("osascript");
cmd.arg("-e").arg(&script);
apply_scriptlet_environment_allowlist(&mut cmd);
let output = cmd.output().map_err(|e| format!("Failed to type text: {}", e))?;
```
Apply the identical pattern to the `Command::new("osascript")` call in `execute_submit()` around line 831. Both `execute_open` and `execute_edit` need the same treatment (apply `apply_scriptlet_environment_allowlist` before `.output()`).

Do NOT change any function signatures, do NOT modify `apply_scriptlet_environment_allowlist` itself, and do NOT touch any test code. Verify that `cargo check && cargo clippy --all-targets -- -D warnings && cargo test` all pass after the change. The pattern to follow is exactly what `execute_applescript()` (line 580-604) and `execute_shell_scriptlet()` (line 430-469) already do.

---

### Task 2: `quicklink-query-url-encode`

**Scope:** `src/quicklinks/mod.rs`

**Task:**
In `src/quicklinks/mod.rs`, the `expand_url()` function on line 42 does a raw string replacement: `url_template.replace(QUERY_PLACEHOLDER, query)`. The query string is user-provided text from an AppleScript dialog prompt. This raw replacement means special URL characters in the query (spaces, `&`, `#`, `=`, etc.) are injected verbatim into the URL. For example, a query like `foo&bar=baz#fragment` would break the URL structure and could lead to parameter injection or URL hijacking. The caller in `builtin_execution.rs` line 580-584 then passes the expanded URL to `open::that(&expanded_url)` which hands it to the OS `open` command, which interprets it as a URL. A malicious query could inject extra URL parameters, redirect to a different fragment, or with certain URL schemes trigger unintended behavior.

The fix: URL-encode the query before substituting it into the template. Add a dependency-free percent-encoding of the query. Replace the `expand_url` function body:
```rust
pub fn expand_url(url_template: &str, query: &str) -> String {
    let encoded: String = query.bytes().map(|b| match b {
        b'A'..=b'Z' | b'a'..=b'z' | b'0'..=b'9' | b'-' | b'_' | b'.' | b'~' => {
            (b as char).to_string()
        }
        _ => format!("%{:02X}", b),
    }).collect();
    url_template.replace(QUERY_PLACEHOLDER, &encoded)
}
```
This uses RFC 3986 unreserved characters for the safe set. Update the existing test `test_expand_url_replaces_query_placeholder` to expect `rust%20gpui` instead of `rust gpui`. Add a new test: `test_expand_url_percent_encodes_special_chars` that verifies `expand_url("https://example.com?q={query}", "a&b=c#d")` returns `"https://example.com?q=a%26b%3Dc%23d"`.

Do NOT add any new crate dependencies. Do NOT change the `Quicklink` struct or any other function. Verify the tests pass with `cargo test`.

---

### Task 3: `scrub-system-actions-env`

**Scope:** `src/system_actions/mod.rs`

**Task:**
In `src/system_actions/mod.rs`, the `run_applescript()` function (line 23) and `run_applescript_with_output()` (line 43) spawn `Command::new("osascript")` without clearing the environment. Similarly, `get_bundle_id_from_path()` (line 393) spawns `Command::new("mdls")` without clearing the environment, and `open_system_settings_url()` (line 610) spawns `Command::new("open")` without clearing environment. While these particular functions execute only hardcoded (not user-controlled) AppleScript/commands, they still unnecessarily leak the full parent-process environment (including any API keys, tokens) to child processes. The security principle of least privilege says subprocesses should only receive the env vars they need.

The fix: Create a small private helper in `system_actions/mod.rs` that scrubs the environment for these system commands. At the top of the file (after the imports), add:
```rust
const SYSTEM_CMD_ENV_VARS: [&str; 5] = ["PATH", "HOME", "TMPDIR", "USER", "LANG"];

fn scrub_command_env(cmd: &mut Command) {
    cmd.env_clear();
    for key in SYSTEM_CMD_ENV_VARS {
        if let Some(val) = std::env::var_os(key) {
            cmd.env(key, val);
        }
    }
}
```
Then modify `run_applescript()` to build `let mut cmd = Command::new("osascript"); cmd.arg("-e").arg(script); scrub_command_env(&mut cmd);` and use `cmd.output()`. Apply the same pattern to `run_applescript_with_output()`, `get_bundle_id_from_path()`, and `open_system_settings_url()`. Also apply to `open_system_preferences_main()` which spawns `Command::new("open")`.

Do NOT change any function signatures, do NOT touch the tests module, do NOT modify any AppleScript content. Ensure `cargo check && cargo clippy --all-targets -- -D warnings && cargo test` all pass.

---

### Task 4: `pid-file-permissions`

**Scope:** `src/process_manager/mod.rs`

**Task:**
In `src/process_manager/mod.rs`, the `write_main_pid()` method (line 72) creates the PID file at `~/.scriptkit/script-kit.pid` using `File::create()` which on Unix defaults to mode 0o666 (minus umask, typically 0o644). The `persist_active_pids()` method (line 376) creates `active-bun-pids.json` via `OpenOptions::new().write(true).create(true)` with the same default permissions. Both files are world-readable by default, which means any local user can read the PID and script paths of running Script Kit processes, enabling targeted process kills or information disclosure about what scripts are running. The PID file should be owner-only (0o600) since it contains process management data.

The fix: After creating each file, immediately set permissions to 0o600. In `write_main_pid()`, after `let mut file = File::create(&self.main_pid_path)?;`, add:
```rust
#[cfg(unix)]
{
    use std::os::unix::fs::PermissionsExt;
    let perms = std::fs::Permissions::from_mode(0o600);
    file.set_permissions(perms)?;
}
```
In `persist_active_pids()`, after `let mut file = OpenOptions::new()...open(&self.active_pids_path)?;`, add the same permission-setting block. Additionally, in `write_main_pid()`, the `create_dir_all(parent)` call should also set the directory to 0o700. After `fs::create_dir_all(parent)?;`, add:
```rust
#[cfg(unix)]
{
    use std::os::unix::fs::PermissionsExt;
    let perms = std::fs::Permissions::from_mode(0o700);
    let _ = fs::set_permissions(parent, perms);
}
```

Do NOT change any function signatures. Do NOT modify test code. Verify with `cargo check && cargo clippy --all-targets -- -D warnings && cargo test`.

---

NEXT_AREA: `src/config/editor.rs` — config.ts write operations (`enable_claude_code_safely`, `recover_from_backup`) handle user-writable config files with backup/restore but may have TOCTOU races between read-validate-write, and the bun validation subprocess inherits full environment
