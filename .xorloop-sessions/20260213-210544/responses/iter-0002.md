Good — vibrancy.rs gets them via `use super::*` from `notes/window.rs`. Now I have the full picture. Let me write the final swarm task output.

Here are the swarm tasks based on Oracle's analysis combined with my codebase investigation:

---

### Task 1: `theme-command-bar-colors`

**Scope:** `src/terminal/command_bar_ui/render.rs`

**Task:**
The file `src/terminal/command_bar_ui/render.rs` has 7 hardcoded `rgba(0x...)` values for popup shadows (lines 13, 15, 26), keycap backgrounds (lines 42, 44), and keycap borders (lines 48, 50). The same file already correctly uses `rgb(self.theme.colors.*)` for text colors and `rgba((self.theme.colors.accent.selected_subtle << 8) | alpha)` for selection/hover backgrounds (lines 79-87). The project rule is: "Use `theme.colors.*` — never hardcode `rgb(0x...)`". Fix all 7 hardcoded color values to use theme-derived colors.

For popup shadows in `create_popup_shadow()` (lines 10-32): replace the hardcoded black `rgba(0x00000080)`, `rgba(0x00000040)`, and `rgba(0x00000020)` with theme-derived shadow color. Use `self.theme.get_drop_shadow().color` (a `u32` RGB value) as the base, then apply the same alpha values via bit-packing: `rgba((shadow_rgb << 8) | alpha)`. Keep `is_dark` for alpha selection: primary shadow alpha `0x80` dark / `0x40` light, secondary shadow alpha always `0x20`. Keep all shadow geometry (offset, blur_radius, spread_radius) unchanged. For keycap bg/border in `render_keycap()` (lines 40-67): use `self.theme.colors.accent.selected_subtle` as the overlay base (same pattern already used at lines 79-87 for selected_bg/hover_bg). Replace keycap_bg: `rgba((overlay_base << 8) | if is_dark { 0x18 } else { 0x10 })`. Replace keycap_border: `rgba((overlay_base << 8) | 0x20)` (same alpha both modes, the base color already flips). Keep keycap_text as-is (already theme-derived).

Do NOT modify any shadow geometry, do NOT change any text colors (they're already correct), and do NOT change the selected_bg/hover_bg logic (lines 79-87). Run `cargo check && cargo clippy --all-targets -- -D warnings && cargo test` to verify. The `self.theme` field is `Arc<theme::Theme>` so `self.theme.get_drop_shadow()` is available.

---

### Task 2: `unify-modal-overlay-bg`

**Scope:** `src/notes/browse_panel.rs, src/notes/window.rs, src/notes/window/vibrancy.rs, src/ai/window/theme_helpers.rs`

**Task:**
There is a canonical helper `modal_overlay_bg(theme: &Theme, opacity: u8) -> Rgba` in `src/theme/helpers.rs` (line 245), re-exported via `src/theme/prelude.rs` (line 7) and `src/theme/mod.rs` (line 41). It has `#[allow(dead_code)]` because nobody uses it. Instead, 3 modules each implement their own private `get_modal_overlay_background()`: (1) `src/notes/window/vibrancy.rs` lines 54-61 uses constants from parent module, (2) `src/notes/browse_panel.rs` lines 405-412 duplicates the same logic with its own constants at lines 82-84, (3) `src/ai/window/theme_helpers.rs` lines 197-206 uses different hardcoded colors (`0x0B122080` / `0xF8FAFC80`) instead of the standard black/white at 50%. All should use the canonical helper.

In `src/notes/window/vibrancy.rs`: replace the body of `get_modal_overlay_background()` with `let sk_theme = crate::theme::get_cached_theme(); crate::theme::modal_overlay_bg(&sk_theme, 0x80)`. In `src/notes/browse_panel.rs`: delete the constants `MODAL_OVERLAY_DARK` and `MODAL_OVERLAY_LIGHT` at lines 82-84, delete the function `get_modal_overlay_background()` at lines 405-412, and replace all call sites (like line 452) with `{ let sk_theme = crate::theme::get_cached_theme(); crate::theme::modal_overlay_bg(&sk_theme, 0x80) }`. In `src/ai/window/theme_helpers.rs`: replace the body of `get_modal_overlay_background()` (lines 197-206) with `let sk_theme = crate::theme::get_cached_theme(); crate::theme::modal_overlay_bg(&sk_theme, 0x80)`. In `src/notes/window.rs`: delete the constants `MODAL_OVERLAY_DARK` (line 169) and `MODAL_OVERLAY_LIGHT` (line 172) since they'll no longer be used by the vibrancy submodule. Remove the `#[allow(dead_code)]` from `modal_overlay_bg` in `src/theme/helpers.rs` if it exists.

The AI window currently uses different hardcoded colors (`0x0B1220` / `0xF8FAFC`) — switching to the canonical black/white helper is intentional normalization. After edits, verify no remaining references to the deleted constants with grep. Run `cargo check && cargo clippy --all-targets -- -D warnings && cargo test`.

---

### Task 3: `theme-toggle-knob`

**Scope:** `src/render_builtins/theme_chooser.rs`

**Task:**
In `src/render_builtins/theme_chooser.rs` line 870, the vibrancy toggle switch knob uses a hardcoded `.bg(rgb(0xffffff))` (always white). The project rule is "Use `theme.colors.*` — never hardcode `rgb(0x...)`". This file already computes `text_primary` (line 141, from `self.theme.colors.text.primary`) and `text_on_accent` (line 150, from `self.theme.colors.text.on_accent`) and uses them extensively throughout the file for text colors.

Replace the single `.bg(rgb(0xffffff))` at line 870 with theme-derived knob colors that maintain contrast against the track. The toggle has two states: ON (vibrancy enabled, accent-colored track) and OFF (vibrancy disabled, neutral track). Replace `.bg(rgb(0xffffff))` with `.when(vibrancy_enabled, |d| d.bg(rgb(text_on_accent))).when(!vibrancy_enabled, |d| d.bg(rgb(text_primary)))`. The variables `vibrancy_enabled`, `text_on_accent`, and `text_primary` are already in scope at that point in the render function — do NOT recompute them.

Do NOT modify any other line in this file. The only change is replacing the single `.bg(rgb(0xffffff))` on line 870. Run `cargo check && cargo clippy --all-targets -- -D warnings && cargo test` to verify. Note: in light mode the knob will become dark (since `text_primary` is dark in light themes) — this is correct and theme-consistent.

---

### Task 4: `theme-preview-badges`

**Scope:** `src/app_render/preview_panel.rs`

**Task:**
In `src/app_render/preview_panel.rs` lines 176-190, the light-mode badge background and border use hardcoded `rgba(0x0000000Cu32)` (line 177) and `rgba(0x00000018u32)` (line 187), while the dark-mode branch correctly uses theme-derived `rgba((ui_border << 8) | alpha)`. The project rule is "Use `theme.colors.*` — never hardcode `rgb(0x...)`". The hardcoded values assume black base for light mode overlays.

Replace the hardcoded light-mode badge colors with theme-derived base color. Use `self.theme.colors.ui.border` as the base for light mode too (consistent with dark mode), preserving the same alpha values. Before the badge_bg assignment, no new variable is needed — just use `ui_border` which is already computed earlier in the function. Replace `rgba(0x0000000Cu32)` with `rgba((ui_border << 8) | 0x0C)` on line 177. Replace `rgba(0x00000018u32)` with `rgba((ui_border << 8) | 0x18)` on line 187. This makes both light and dark mode consistently derive from `ui_border`, just with different alphas — light mode keeps `0x0C`/`0x18` (very subtle), dark mode keeps `0x60`/`0x40`.

Verify `ui_border` is a `u32` already in scope — search for `let ui_border` earlier in the function. Do NOT change the dark-mode branches (they're already correct). Do NOT change badge_text or accent_badge colors. Run `cargo check && cargo clippy --all-targets -- -D warnings && cargo test` to verify.

---

NEXT_AREA: `create_box_shadows` / shadow computation — at least 3 divergent shadow creation patterns across modules (`app_shell/style.rs` uses inline Hsla, `ai/window/theme_helpers.rs` has a 40-line RGB→HSL conversion, `notes/actions_panel.rs` uses named constants, `terminal/command_bar_ui` uses hardcoded rgba) — could be unified into a shared shadow builder utility
