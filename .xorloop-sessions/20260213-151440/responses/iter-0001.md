Oracle is still processing. Given I've already read the full file and understand the exact duplication, let me provide you the swarm task list now based on my own analysis. I'll update if Oracle returns anything materially different.

Here's the analysis and swarm task list:

---

## DRY Analysis: `src/app_launcher/db_cache.rs`

**Finding 1:** `load_apps_from_db()` (L118-195) and `load_apps_from_db_with_icons()` (L202-279) are **byte-for-byte identical** except for the span name string. The second is `#[allow(dead_code)]` and never called anywhere.

**Finding 2:** The `get_apps_db()` + `db.lock()` boilerplate (get `Arc<Mutex<Connection>>`, match-error-return-default) is repeated in 5 functions: `load_apps_from_db`, `load_apps_from_db_with_icons`, `save_app_to_db`, `app_needs_update`, `get_apps_db_stats`.

**Finding 3:** `app_needs_update` is also `#[allow(dead_code)]` and never called.

---

## SWARM TASK LIST

### Task 1: `rm-dead-clone-fn`

**Scope:** `src/app_launcher/db_cache.rs`

**Task:**
In `src/app_launcher/db_cache.rs`, the function `load_apps_from_db_with_icons()` (lines 197-279) is a complete copy-paste clone of `load_apps_from_db()` (lines 114-195). They have identical SQL (`SELECT bundle_id, name, path, icon_blob FROM apps ORDER BY name COLLATE NOCASE`), identical row mapping, identical icon decoding via `decode_png_to_render_image_with_bgra_conversion`, identical iteration/filtering, and identical logging. `load_apps_from_db_with_icons` is `#[allow(dead_code)]` and has zero call sites anywhere in the codebase. Similarly, `app_needs_update` (lines 324-351) is `#[allow(dead_code)]` and has zero call sites. Both should be deleted entirely.

Delete the entire `load_apps_from_db_with_icons()` function (lines 197-279, including the doc comments starting at line 197 and the `#[allow(dead_code)]` attribute on line 201). Also delete the entire `app_needs_update()` function (lines 324-351, including the doc comments starting at line 324 and the `#[allow(dead_code)]` attribute on line 327). Do not leave any blank comment markers like `// removed` — just delete the lines entirely.

After the deletion, verify the file still compiles by running `cargo check`. No other files reference these two functions (confirmed via grep), so no call sites need updating. The remaining functions `load_apps_from_db`, `save_app_to_db`, and `get_apps_db_stats` must remain untouched by this task.

### Task 2: `extract-db-conn-helper`

**Scope:** `src/app_launcher/db_cache.rs`

**Task:**
In `src/app_launcher/db_cache.rs`, the pattern `get_apps_db()` → match error → `db.lock()` → match error is repeated in every function that touches the database: `load_apps_from_db` (lines 122-136), `save_app_to_db` (lines 283-297), and `get_apps_db_stats` (lines 355-363). Each repeats the same ~14 lines: call `get_apps_db()`, match `Ok`/`Err`, log warning, return default; call `db.lock()`, match `Ok`/`Err`, log error, return default. This boilerplate should be extracted into a single helper function.

Create a new private helper function `fn with_apps_db<T>(default: T, f: impl FnOnce(&Connection) -> T) -> T` at the top of the SQLite Cache Operations section (after line 113). The implementation should: (1) call `get_apps_db()`, on error log `warn!(error = %e, "Failed to get apps database")` and return `default`, (2) call `db.lock()`, on error log `error!(error = %e, "Failed to lock apps database")` and return `default`, (3) call `f(&conn)` and return its result. Then refactor the three remaining DB functions (`load_apps_from_db`, `save_app_to_db`, `get_apps_db_stats`) to use this helper. For `load_apps_from_db`, call `with_apps_db(Vec::new(), |conn| { ... })`. For `save_app_to_db`, call `with_apps_db((), |conn| { ... })`. For `get_apps_db_stats`, call `with_apps_db((0, 0), |conn| { ... })`. Move the body logic (everything after the lock guard acquisition) into the closure.

**Important constraints:** (1) `save_app_to_db` currently logs the `app.name` in its error messages — the new helper uses generic messages, which is acceptable since the tracing span context will identify the caller. (2) Do NOT change any SQL queries, row mapping, or business logic — only extract the connection-acquisition boilerplate. (3) The helper must use `tracing::{warn, error}` not `log::*`. (4) No `unwrap()` or `expect()` in the helper. (5) Verify with `cargo check && cargo clippy --all-targets -- -D warnings && cargo test`.

---

NEXT_AREA: `src/app_launcher/scanning.rs` — the `scan_and_cache_apps()` function likely has similar patterns worth auditing (icon extraction, app filtering, batch DB writes) that could benefit from shared helpers with `db_cache.rs`.
