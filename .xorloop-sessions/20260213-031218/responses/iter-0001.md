Here's the full GPT-5.2 Pro performance analysis of the menu bar module:

---

## Performance Review: Menu Bar Module (12 items)

### Critical (3)

1. **`src/menu_bar/mod.rs` — `get_ax_attribute` (~305–401)**
   Every attribute read creates a new `CString` → `CFString`, calls `AXUIElementCopyAttributeValue`, then frees. `kAXErrorNoValue` allocates an `anyhow::Error` even when "no value" is expected (e.g., missing shortcuts on leaf items). This happens in tight loops.
   **Fix:** Return `Result<Option<CFTypeRef>>` — `Ok(None)` for no-value, only `Err` for real failures. Stop allocating on the common "missing" path.

2. **`src/menu_bar/mod.rs` + `src/menu_executor/mod.rs` — `try_create_cf_string`**
   Constant attribute names (`"AXTitle"`, `"AXChildren"`, `"AXPress"`) are re-created as CFStrings on every call — unnecessary FFI churn in hot paths.
   **Fix:** Use `OnceLock`/`LazyLock` to create these once at startup. Accept `CFStringRef` instead of `&str` in helpers.

3. **`src/menu_bar/mod.rs` — `parse_menu_item` / `parse_submenu_children` (~434–534)**
   Multiple separate AX calls per element (title, role, enabled, shortcuts, children) = many cross-process round-trips.
   **Fix:** Use `AXUIElementCopyMultipleAttributeValues` to batch-fetch attributes in one call per element.

### Major (6)

4. **`is_menu_separator` + `parse_menu_item` (~408–480)** — Redundant AX calls: separator detection fetches title/role, then `parse_menu_item` fetches title again. Fold separator detection into a single attribute fetch.

5. **`parse_submenu_children` (~481–534)** — `get_ax_children()` on leaf nodes allocates errors. `children` Vec grows without capacity hints. Pre-allocate with `Vec::with_capacity(count)`.

6. **`src/frontmost_app_tracker/mod.rs` — `get_cached_menu_items` (~149–153)** — Deep `.clone()` of entire `Vec<MenuBarItem>` while holding read lock. **Fix:** Store behind `Arc` so reads are a cheap `Arc::clone()`. Drop old tree after releasing lock.

7. **`fetch_menu_items_async` (~429–533)** — Every app activation spawns a new OS thread for full AX scan. Rapid alt-tabbing = many concurrent wasted scans. **Fix:** Single "menu scan worker" thread with channel; debounce + coalesce to only scan the latest request.

8. **`src/menu_executor/mod.rs` — `find_menu_item_by_title` (~351–371)** — Linear scan converting every child title to a Rust `String` just to compare. **Fix:** Index-path execution via `CFArrayGetValueAtIndex`, or compare `CFString`s directly without Rust `String` allocation.

9. **`src/menu_cache/mod.rs` — `get_cached_menu` / `set_cached_menu` (~92–155)** — SQLite `Mutex<Connection>` held during `serde_json` (de)serialization. **Fix:** Serialize/deserialize outside the lock.

10. **`src/menu_cache/mod.rs` — cache eviction (~156–230)** — Pruning utilities exist but are never called. Unbounded cache growth over time. **Fix:** Call `prune_old_cache_entries` at startup; use `app_version` for invalidation; consult persisted cache before AX scanning.

### Minor (2)

11. **`src/menu_executor/mod.rs` — `open_menu_at_element` (~372–405)** — Hard-coded `sleep(50ms)` per intermediate menu. **Fix:** Bounded poll with 5–10ms retry intervals, break early when menu appears.

12. **Various** — `path_so_far.push(clone)` allocates even on success; no `Vec::with_capacity`; unconditional logging in `get_menu_bar_owner_pid`. Minor allocations that matter after big fixes.

---

**No heavy regex usage found** in these modules.

**NEXT_AREA:** Profile the menu item lookup/search layer — how the parsed tree is indexed and queried for user commands — since that often becomes the next O(n^2) hotspot after AX scanning is optimized.
