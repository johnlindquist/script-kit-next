Here's the full GPT-5.2 Pro performance analysis of the window tiling system:

---

## Window Tiling Performance Analysis (GPT-5.2 Pro)

### 1) CRITICAL — Full `list_windows()` on every cache miss
**File:** `src/window_control/mod.rs` — `move_window`, `resize_window`, `set_window_bounds`, `minimize_window`, `maximize_window`, `tile_window`, `close_window`, `focus_window`, `move_to_adjacent_display` (~L862–L1183)

Every window operation does `get_cached_window(id)` → miss → `list_windows()` (full AX crawl of all apps × all windows). Worse, `list_windows()` clears the cache first, causing follow-on misses (thrash). **O(apps × windows) per miss.**

**Fix:** Targeted refresh using the `(pid << 16) | index` encoding — on miss, create AXUIElement for just that PID's windows instead of enumerating the entire system.

### 2) MAJOR — 3+ synchronous AX calls per window in `list_windows()`
**File:** `src/window_control/mod.rs::list_windows` (~L543–L670)

Each window triggers separate cross-process AX queries for AXTitle, AXPosition, AXSize. Scales poorly with many windows.

**Fix:** Batch attribute reads per window (macOS AX supports multi-attribute copy). Make bounds lazy — fetch position/size only when actually tiling/moving.

### 3) MAJOR — CFStringRef re-created for every AX attribute name
**File:** `src/window_control/mod.rs::try_create_cf_string` (~L245–L256)

Constant strings like `"AXWindows"`, `"AXTitle"`, `"AXPosition"` get `CString` + `CFStringCreateWithCString` + `CFRelease` on every single AX call. Multiplies across all windows.

**Fix:** Use `OnceLock`/`LazyLock` static `CFStringRef`s for the ~10 attribute name constants.

### 4) MAJOR — Cache thrash: clear-all + per-window mutex lock/unlock
**File:** `src/window_control/mod.rs::clear_window_cache` (~L494–L514), `cache_window` (~L473–L481)

`list_windows()` clears cache (O(N) releases), then locks mutex once per insertion (N lock/unlock cycles).

**Fix:** Lock once, build HashMap in local scope, swap in. Or use generation-based eviction instead of clear+rebuild.

### 5) MAJOR — Per-title `Vec<i8>` allocation in hot loop
**File:** `src/window_control/mod.rs::cf_string_to_string` (~L257–L285)

Allocates `Vec<i8>` sized `(len * 4 + 1)` per window title. Classic allocation churn.

**Fix:** Try `CFStringGetCStringPtr` first (zero-alloc fast path). Otherwise use `thread_local!` reusable buffer.

### 6) MINOR — O(app_count) PID→app scan
**File:** `src/window_control/mod.rs::get_app_name_for_pid` (~L819–L861), `focus_window` (~L1074–L1112)

Both linearly scan `NSWorkspace.runningApplications` to find a PID.

**Fix:** Use `NSRunningApplication(withProcessIdentifier:)` for direct PID lookup.

### 7) MAJOR — All AX work is synchronous, likely on UI thread
**File:** All public window ops in `src/window_control/mod.rs` (~L543–L1183)

AX calls are cross-process and can stall unpredictably. If called from GPUI action handlers, this blocks the main thread.

**Fix:** Move all AX + window enumeration to a dedicated worker thread. UI triggers enqueue requests, worker returns results asynchronously.

### 8) MINOR — Display bounds re-queried on every operation
**File:** `src/window_control/mod.rs::get_all_display_bounds` (~L1184–L1236), `get_visible_display_bounds` (~L1237–L1327)

Every tile/maximize/move-display call iterates `NSScreen.screens`.

**Fix:** Cache display bounds; invalidate on display-configuration-change notification.

### Positive finding
No AX calls appear inside GPUI `render()` paths — the separation is clean.

---

**NEXT_AREA:** Correctness & safety of window identity + AXUIElement lifetime (stale IDs, cache invalidation strategy, and CF retain/release ownership across refreshes)
