Here's the full GPT-5.2 Pro analysis of the `app_navigation` module's performance:

---

## Performance Analysis: `app_navigation` Module

### 1. **[CRITICAL] Unbounded timer-task spawning on every navigation event**
- **File:** `src/app_navigation/impl_scroll.rs`
- **Hot path:** `set_selected_index()` → `trigger_scroll_activity()` (every up/down/page key); also `handle_scroll_wheel()` → `trigger_scroll_activity()`
- **Problem:** `trigger_scroll_activity()` always does `cx.spawn(Timer::after(1000ms)...).detach()` with no "already running" guard. Holding an arrow key spawns **N detached tasks** per second — classic "timer thundering herd" causing UI-thread churn during peak input.
- **Fix:** Convert to a **single debounced fade task** — add `scroll_fade_task_running: bool`, spawn only if not already running, loop inside the task checking `last_scroll_time.elapsed()`.

### 2. **[MAJOR] Redundant `cx.notify()` calls per keystroke**
- **Files:** `impl_movement.rs` (`set_selected_index`), `impl_scroll.rs` (`trigger_scroll_activity`, `handle_scroll_wheel`)
- **Problem:** `set_selected_index()` calls `trigger_scroll_activity(cx)` (which calls `cx.notify()`) then calls `cx.notify()` **again**. Same pattern in `handle_scroll_wheel()`. Two invalidations per user event.
- **Fix:** Guarantee **one notify per user event** — either remove it from callers or from `trigger_scroll_activity()`.

### 3. **[MAJOR] Repeated linear scans + O(n²) over long key holds**
- **Files:** `impl_movement.rs`, `impl_scroll.rs` (`move_selection_by`), `helpers.rs`
- **Problem:** Every navigation call does `.position()` or `.rposition()` over `grouped_items` to find first/last selectable item. `move_selection_by()` does **both** per call. Page up/down walks slices counting selectables. Over long key-hold sequences → O(n²) total.
- **Fix:** Build a cached `selectable_indices: Vec<usize>` when grouped results change. Navigation becomes rank ± 1 (O(1)), page moves become rank ± PAGE_SIZE, first/last are index lookups.

### 4. **[MAJOR] Redundant full scan in page-down path**
- **Files:** `impl_movement.rs`, `helpers.rs`
- **Problem:** `move_selection_page_down()` computes `last_selectable` via `.rposition()`, then calls `page_down_target_index()` which does `.rposition()` **again**.
- **Fix:** Pass `last_selectable` as a parameter to the helper, or inline the logic.

### 5. **[MINOR→MAJOR] Unconditional cursor-hide on every navigation**
- **File:** `impl_movement.rs`
- **Problem:** `enter_keyboard_mode()` always calls `hide_mouse_cursor(cx)` per keystroke, even when already in keyboard mode with cursor already hidden. If that's a platform call, it's expensive.
- **Fix:** Guard with `if self.input_mode != InputMode::Keyboard || self.hovered_index.is_some()`.

### 6. **[MINOR] `validate_selection_bounds()` multiple passes + eager cache clearing**
- **File:** `impl_scroll.rs`
- **Problem:** Calls `validated_selection_index()` (scan), then `grouped_items.iter().any()` (full pass), then always clears `cached_fallbacks` even if selection is valid.
- **Fix:** Reuse the selectable_indices cache; only clear fallbacks on actual transitions.

### 7. **[MINOR] Instrumentation in high-frequency paths**
- **File:** `impl_scroll.rs`
- **Problem:** `tracing::debug!()` on every wheel event; `ScrollPerfGuard` constructed on every scroll-to-reveal.
- **Fix:** Gate behind `tracing::enabled!()` or feature-flag for production builds.

---

**NEXT_AREA:** Analyze the **grouping + caching pipeline** behind `get_grouped_results_cached()` and `list_item::coerce_selection()` — how `GroupedListItem` vectors are built/updated, and whether navigation-triggered renders or selection changes cause recomputation or extra allocations.
