Got the full Oracle response. GPT-5.2 Pro produced 2 well-structured tasks. However, Task 1 is overloaded — it tries to do too much in one worker. Let me refine these into a cleaner swarm task list based on the Oracle analysis and my own reading of the code. The key insight is solid: `infer_script_type()` re-creates lowercased strings that `SelectChoiceIndex::from_choice()` already computes, and the `format!("{ext}#")` pattern inside `.any()` is wasteful.

Here's the swarm task list:

---

## SWARM TASK LIST

### Task 1: `infer-type-zero-alloc`

**Scope:** `src/prompts/select/types.rs`

**Task:**
In `src/prompts/select/types.rs`, the function `infer_script_type(choice: &Choice) -> Option<String>` (line 132) allocates 3 lowercased `String`s (`name_lower`, `value_lower`, `description_lower`), a `format!("{} {} {}", ...)` combined string, and then inside the script extension check (line 166) calls `format!("{ext}#")` for each of the 12 extensions in `.any()`. This produces ~16 heap allocations per call. Meanwhile, `SelectChoiceIndex::from_choice()` (line 24) already computes and stores `name_lower`, `description_lower`, and `value_lower` as `String` fields. The fix eliminates all redundant allocations by introducing a zero-alloc `&str`-based inference helper.

Add a new private function `fn infer_script_type_from_lowercase(name_lower: &str, description_lower: &str, value_lower: &str) -> Option<&'static str>` that contains the current inference logic but with these changes: (1) Replace `let combined = format!(...)` with a closure `let contains_any = |needle: &str| name_lower.contains(needle) || description_lower.contains(needle) || value_lower.contains(needle);`, then use `contains_any("scriptlet")`, `contains_any("extension")`, `contains_any("agent")`, `contains_any("script")` for the respective checks. (2) Replace the `format!("{ext}#")` pattern with a `const SCRIPT_EXT_FRAGMENTS: [(&str, &str); 12]` array at module scope containing pairs like `(".ts", ".ts#"), (".tsx", ".tsx#"), (".js", ".js#"), (".jsx", ".jsx#"), (".mjs", ".mjs#"), (".cjs", ".cjs#"), (".sh", ".sh#"), (".py", ".py#"), (".rb", ".rb#"), (".ps1", ".ps1#"), (".zsh", ".zsh#"), (".bash", ".bash#")`, then check `SCRIPT_EXT_FRAGMENTS.iter().any(|(ext, ext_hash)| value_lower.ends_with(ext) || value_lower.contains(ext_hash))`. Return `&'static str` values `"Scriptlet"`, `"Extension"`, `"Agent"`, `"Script"` — the caller maps with `.map(str::to_string)` or `.map(String::from)`.

Then refactor the existing `infer_script_type(choice: &Choice) -> Option<String>` to be a thin wrapper: compute the 3 lowercase strings as today (for callers that don't already have them), call `infer_script_type_from_lowercase(...)`, and map to `String`. Next, update `SelectChoiceIndex::from_choice()` to compute `name_lower`, `description_lower`, `value_lower` first, then call `ChoiceDisplayMetadata::from_choice_with_lower(choice, &name_lower, &description_lower, &value_lower)` — a new `pub(super)` method on `ChoiceDisplayMetadata` that runs the same description-parsing logic but calls `infer_script_type_from_lowercase` instead of `infer_script_type` when `item_type` is `None`, avoiding the duplicate lowercase allocations. Keep `ChoiceDisplayMetadata::from_choice(choice: &Choice)` as a convenience that internally lowercases and delegates. Verify with `cargo check && cargo clippy --all-targets -- -D warnings && cargo test`. No `unwrap()` in production code.

### Task 2: `tests-infer-type-fragments`

**Scope:** `src/prompts/select/tests.rs`

**Task:**
In `src/prompts/select/tests.rs`, add regression tests that lock in the script-type inference behavior for the cases most affected by the allocation refactor — specifically the `format!("{ext}#")` removal and the `combined` string elimination. These tests must be written BEFORE or alongside the refactor to catch any behavioral regressions. Use the existing test helper pattern in the file (construct `Choice` values with `name`, `value`, `description` fields, call `ChoiceDisplayMetadata::from_choice()`, assert on `metadata.item_type`).

Add these test cases: (1) A choice with value `"/tmp/demo.ts#section"` and no "script" keyword in name or description — must infer `Some("Script")` from the `.ts#` fragment pattern. (2) A choice with value `"/tmp/readme.md#foo"` — must infer `Some("Scriptlet")` because `.md#` triggers the scriptlet branch. (3) A choice with value `"/home/user/extensions/my-ext"` and no explicit type token — must infer `Some("Extension")` from the `/extensions/` path. (4) A choice with name `"My Agent"` and a generic value like `"/tools/helper"` — must infer `Some("Agent")` from the name containing "agent". (5) A choice with value ending in `.ts` (e.g. `"/scripts/run.ts"`) with no keywords — must infer `Some("Script")` from the extension. (6) A choice with no matching signals at all (name `"Settings"`, value `"settings"`) — must return `None`.

Use `#[test]` functions inside the existing `#[cfg(test)] mod tests` block. Only assert on `ChoiceDisplayMetadata::from_choice()` output — do not test internal helper functions directly. Verify with `cargo check && cargo clippy --all-targets -- -D warnings && cargo test`. Use `.expect("message")` in tests (allowed), but no `unwrap()`.

NEXT_AREA: `subtitle_text()` in `ChoiceDisplayMetadata` (line 103-129) allocates multiple `String`s and `Vec`s on every call — since it's called per-choice during rendering, it could benefit from returning `Cow<str>` or pre-computing the subtitle during `from_choice()`.
