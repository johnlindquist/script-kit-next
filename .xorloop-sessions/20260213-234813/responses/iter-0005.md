I now have a thorough understanding of all the issues. Let me also check if the `cache.rs:38` `expect()` is in test code or production code (it's in `get_image_cache()` which is production).

Now I have the complete picture. Here's the analysis:

**Production code issues found:**

1. **`database.rs:197`** — `DB_CONNECTION.get().unwrap()` can panic during concurrent initialization race
2. **`db_worker/mod.rs:267-329`** — 15 `let _ = reply.send(...)` silently swallowing channel send errors
3. **`cache.rs:38`** — `.expect("cache size must be non-zero")` in production `get_image_cache()` (though the constant is 100, so it can't actually fail — but it violates the rule)
4. **`database.rs:97,113,130,153`** — `.unwrap_or(false)` / `.unwrap_or(0)` on query results in migrations — these are fine (graceful handling)

All the `.expect()` calls in `macos_paste.rs`, `image.rs`, `types.rs`, etc. are inside `#[cfg(test)]` blocks — those are OK per project rules.

Here are the swarm tasks:

---

### Task 1: `fix-db-connection-unwrap`

**Scope:** `src/clipboard_history/database.rs`

**Task:**
In `src/clipboard_history/database.rs`, the function `get_connection()` at line 196-197 has a race-condition panic. When `DB_CONNECTION.set(conn.clone()).is_err()` — meaning another thread already set the OnceLock — the code does `return Ok(DB_CONNECTION.get().unwrap().clone())`. The `.unwrap()` violates the project's non-negotiable rule: "No unwrap/expect in production code." While the `OnceLock::set` returning `Err` implies the lock is already populated, using `.unwrap()` here is both a style violation and theoretically fragile if the OnceLock implementation changes.

Replace line 197 (`return Ok(DB_CONNECTION.get().unwrap().clone());`) with a match that returns an error if `get()` unexpectedly returns `None`:
```rust
if DB_CONNECTION.set(conn.clone()).is_err() {
    return DB_CONNECTION
        .get()
        .cloned()
        .ok_or_else(|| anyhow::anyhow!("DB_CONNECTION set failed but get() returned None"));
}
```
Note that `DB_CONNECTION` is `OnceLock<Arc<Mutex<Connection>>>`, so `.get()` returns `Option<&Arc<Mutex<Connection>>>` and `.cloned()` gives `Option<Arc<Mutex<Connection>>>`. The `ok_or_else` converts that to `Result<Arc<Mutex<Connection>>>`.

Verify by running `cargo check && cargo clippy --all-targets -- -D warnings && cargo test`. Do not modify any other functions in this file. Do not add comments or documentation. The existing tests in the `#[cfg(test)]` block at the bottom of the file should continue to pass unchanged.

---

### Task 2: `fix-dbworker-reply-send`

**Scope:** `src/clipboard_history/db_worker/mod.rs`

**Task:**
In `src/clipboard_history/db_worker/mod.rs`, the function `handle_request()` (lines 255-337) handles 15 different `DbRequest` variants. Every single one sends its result back through a oneshot `SyncSender` channel with `let _ = reply.send(...)`, unconditionally discarding the send error. If the receiver has been dropped (caller timed out, task cancelled, etc.), the DB operation completes successfully but the result is silently lost. This should log a warning so operators can detect when callers are dropping receivers. The file already imports `tracing::{debug, error, info}` on line 21 — add `warn` to that import.

For each of the 15 `let _ = reply.send(...)` patterns (lines 267, 279, 282, 289, 296, 299, 302, 305, 308, 311, 317, 320, 323, 326, 329), replace the `let _ = reply.send(...)` with:
```rust
if reply.send(...).is_err() {
    warn!("DbRequest::<VariantName> reply dropped");
}
```
Where `<VariantName>` matches the enum variant being handled (AddOrTouch, GetContent, GetEntry, GetMeta, GetPage, GetCount, Pin, Unpin, Remove, Clear, Prune, TrimOversized, UpdateOcr, IncrementalVacuum, WalCheckpoint). For example, line 279 becomes:
```rust
if reply.send(get_content_impl(conn, &id)).is_err() {
    warn!("DbRequest::GetContent reply dropped");
}
```
For the multi-line `AddOrTouch` case (lines 267-276), compute the result first, then send:
```rust
let result = add_or_touch_impl(conn, &content, content_type, &content_hash, text_preview, image_width, image_height, byte_size);
if reply.send(result).is_err() {
    warn!("DbRequest::AddOrTouch reply dropped");
}
```

Update the import on line 21 from `use tracing::{debug, error, info};` to `use tracing::{debug, error, info, warn};`. Verify with `cargo check && cargo clippy --all-targets -- -D warnings && cargo test`. Note: this entire module has `#![allow(dead_code)]` at line 11 — do not remove that attribute. Do not modify any other files.

---

### Task 3: `fix-cache-expect`

**Scope:** `src/clipboard_history/cache.rs`

**Task:**
In `src/clipboard_history/cache.rs`, the function `get_image_cache()` at line 38 uses `.expect("cache size must be non-zero")` inside a `OnceLock::get_or_init` closure. While the constant `MAX_IMAGE_CACHE_ENTRIES` is 100 (so `NonZeroUsize::new(100)` will never return `None`), this violates the project's non-negotiable rule: "No unwrap/expect in production code." The fix is safe because the value is a compile-time constant, but the rule exists to prevent inconsistency that confuses AI agents working on the codebase.

Replace the `expect` with a fallback using `unwrap_or`. Since `NonZeroUsize::new()` only fails for 0, and we know the constant is 100, use a safe fallback:
```rust
pub fn get_image_cache() -> &'static Mutex<LruCache<String, Arc<RenderImage>>> {
    IMAGE_CACHE.get_or_init(|| {
        // SAFETY: MAX_IMAGE_CACHE_ENTRIES is 100, never zero
        let cap = NonZeroUsize::new(MAX_IMAGE_CACHE_ENTRIES)
            .unwrap_or(NonZeroUsize::new(100).unwrap_or(NonZeroUsize::MIN));
        Mutex::new(LruCache::new(cap))
    })
}
```
Wait — that still has an `unwrap_or` chain that's awkward. A cleaner approach: since `NonZeroUsize::MIN` is guaranteed to be 1 (it's a const), use:
```rust
let cap = NonZeroUsize::new(MAX_IMAGE_CACHE_ENTRIES).unwrap_or(NonZeroUsize::MIN);
```
This is a single line change on line 38. `NonZeroUsize::MIN` is a `const` equal to `NonZeroUsize::new(1).unwrap()` — it's always valid and never panics at runtime. Do NOT change any other functions in this file. Verify with `cargo check && cargo clippy --all-targets -- -D warnings && cargo test`. The existing tests at the bottom of the file must pass unchanged.

---

NEXT_AREA: `src/clipboard_history/ocr.rs` — line 433 has `let _ = blob_path;` (dead binding) and the OCR worker likely has similar `let _ =` patterns on channel operations that may silently swallow errors
